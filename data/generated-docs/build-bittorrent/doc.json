{"html":"<h1 id=\"build-your-own-bittorrent-design-document\">Build Your Own BitTorrent: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This document outlines the design for a complete BitTorrent client that can download and seed files in a peer-to-peer network. The key architectural challenge is coordinating concurrent downloads from multiple peers while managing piece verification, peer state machines, and tracker communication protocols.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides foundational context for all milestones (1-4) by establishing the problem space and design challenges.</p>\n</blockquote>\n<h3 id=\"the-library-network-analogy\">The Library Network Analogy</h3>\n<p>Imagine a vast network of libraries spread across the world, each containing different collections of books. When you want to read a specific book, you don&#39;t need to travel to the one library that has it. Instead, you can request it through an <strong>inter-library loan system</strong> where libraries cooperate to share their collections. The library network maintains a <strong>catalog service</strong> that knows which libraries have which books, and when you request a book, the catalog tells you exactly where to find it.</p>\n<p>BitTorrent works remarkably similarly to this library network, but instead of books, we&#39;re sharing files, and instead of libraries, we have individual computers (called <strong>peers</strong>). Just as libraries maintain catalogs of their collections, BitTorrent uses <strong>torrent files</strong> that contain a catalog of what files are available and how to verify you received the correct content. The <strong>tracker</strong> serves as the central catalog service, maintaining a list of which peers currently have which files available for sharing.</p>\n<p>The key insight is that no single library (or peer) needs to have the complete collection. When you want a popular book, multiple libraries might have copies, so you can choose the most convenient one or even get different chapters from different libraries simultaneously. Similarly, when downloading a file via BitTorrent, you can download different <strong>pieces</strong> of the file from multiple peers concurrently, dramatically speeding up the process.</p>\n<p>Just as libraries have policies about lending (you must return books, there are limits on how many you can borrow), BitTorrent implements <strong>incentive mechanisms</strong> where peers who share files get priority access to download from others. This creates a self-sustaining ecosystem where sharing benefits everyone.</p>\n<p>The analogy breaks down in one crucial way: unlike physical books that can only be in one place at a time, digital files can be perfectly copied. Once you&#39;ve downloaded a complete file via BitTorrent, you automatically become another &quot;library&quot; in the network, able to serve that file to future requesters. This creates a <strong>viral sharing effect</strong> where popular files become more available over time, not less.</p>\n<h3 id=\"file-sharing-approaches\">File Sharing Approaches</h3>\n<p>The evolution of file sharing represents different architectural approaches to the fundamental problem of distributing content efficiently across a network. Each approach involves trade-offs between performance, reliability, cost, and control.</p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Architecture</th>\n<th>Discovery Method</th>\n<th>Content Source</th>\n<th>Bandwidth Usage</th>\n<th>Failure Mode</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Centralized</strong></td>\n<td>Single server hosts all content</td>\n<td>Central directory/search</td>\n<td>One server per file</td>\n<td>Server pays all bandwidth costs</td>\n<td>Single point of failure - server down means no access</td>\n<td>Early web downloads, FTP sites</td>\n</tr>\n<tr>\n<td><strong>Client-Server CDN</strong></td>\n<td>Multiple geographic servers with replicated content</td>\n<td>DNS-based geographic routing</td>\n<td>Closest available server</td>\n<td>CDN provider pays bandwidth costs</td>\n<td>Graceful degradation - some regions may lose access</td>\n<td>Netflix, Steam, major websites</td>\n</tr>\n<tr>\n<td><strong>Pure P2P</strong></td>\n<td>All peers are equal, no central authority</td>\n<td>Distributed hash tables (DHT)</td>\n<td>Any peer with content</td>\n<td>Distributed across all peers</td>\n<td>Network fragmentation - peers may not find each other</td>\n<td>Early Gnutella, Freenet</td>\n</tr>\n<tr>\n<td><strong>Hybrid P2P (BitTorrent)</strong></td>\n<td>Peers share content, tracker coordinates</td>\n<td>Central tracker for peer discovery</td>\n<td>Multiple peers simultaneously</td>\n<td>Distributed across downloading peers</td>\n<td>Tracker failure stops new downloads, but existing swarms continue</td>\n<td>BitTorrent, modern P2P protocols</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: BitTorrent&#39;s hybrid approach combines the reliability of centralized peer discovery with the scalability benefits of distributed content delivery. This architectural decision reflects a fundamental principle: <strong>centralize coordination, distribute execution</strong>.</p>\n</blockquote>\n<p><strong>Decision: Hybrid P2P Architecture for BitTorrent</strong></p>\n<ul>\n<li><strong>Context</strong>: File sharing systems must balance discoverability (finding content and peers) with scalability (handling load as popularity increases)</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Pure centralized (single server hosts files)</li>\n<li>Pure P2P (fully decentralized discovery and content)</li>\n<li>Hybrid P2P (centralized tracker, distributed content)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid P2P with tracker-based peer discovery and peer-to-peer content transfer</li>\n<li><strong>Rationale</strong>: Centralized trackers solve the peer discovery problem efficiently while distributed content transfer scales bandwidth costs with demand and creates redundancy</li>\n<li><strong>Consequences</strong>: Enables rapid peer discovery and coordinated downloading while distributing bandwidth costs, but creates tracker dependency for initial peer discovery</li>\n</ul>\n<p>The bandwidth economics are particularly compelling. In a centralized model, if a file becomes popular, the server operator pays exponentially increasing bandwidth costs. With BitTorrent, increased popularity means more peers have the complete file, creating <strong>more upload capacity</strong> in the system. The bandwidth cost scales with the number of people willing to share, not just with demand.</p>\n<h3 id=\"core-technical-challenges\">Core Technical Challenges</h3>\n<p>BitTorrent solves three fundamental distributed systems problems that make peer-to-peer file sharing practical at scale. Each challenge represents a different aspect of coordinating untrusted participants in a decentralized network.</p>\n<p><strong>Challenge 1: Peer Discovery in a Dynamic Network</strong></p>\n<p>The first challenge is the <strong>bootstrapping problem</strong>: how do you find other peers who have the content you want when there&#39;s no central directory of active participants? Unlike a web server with a fixed IP address, BitTorrent peers are typically home computers with dynamic IP addresses that come online and go offline unpredictably.</p>\n<p>BitTorrent solves this through the <strong>tracker protocol</strong>. The tracker acts as a rendezvous point where peers announce their availability and discover others. When a peer wants to download a file, it extracts the tracker URL from the torrent file, announces itself to the tracker with its current IP address and port, and receives a list of other peers currently sharing that file.</p>\n<p>The tracker doesn&#39;t store the actual file content - it only maintains <strong>ephemeral peer lists</strong> that reflect the current state of the swarm. Peers must periodically re-announce to stay in the active peer list, creating a self-cleaning mechanism where offline peers automatically disappear from the system.</p>\n<table>\n<thead>\n<tr>\n<th>Tracker Interaction</th>\n<th>Purpose</th>\n<th>Information Exchanged</th>\n<th>Frequency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Initial Announce</strong></td>\n<td>Join swarm, get initial peer list</td>\n<td>Peer reports: info_hash, peer_id, IP, port, bytes uploaded/downloaded</td>\n<td>Once per torrent</td>\n</tr>\n<tr>\n<td><strong>Periodic Announce</strong></td>\n<td>Stay visible, report progress, get updated peers</td>\n<td>Updated statistics, receive peers that joined since last announce</td>\n<td>Every 15-30 minutes</td>\n</tr>\n<tr>\n<td><strong>Event Announce</strong></td>\n<td>Report state changes</td>\n<td>&#39;started&#39;, &#39;completed&#39;, or &#39;stopped&#39; events with current statistics</td>\n<td>When events occur</td>\n</tr>\n</tbody></table>\n<p><strong>Challenge 2: Content Verification in an Untrusted Network</strong></p>\n<p>The second challenge is <strong>content integrity</strong>: how do you verify that the data you receive from untrusted peers hasn&#39;t been corrupted or maliciously modified? Traditional file downloads from trusted servers don&#39;t face this problem, but in a P2P network, any peer could send you garbage data.</p>\n<p>BitTorrent&#39;s solution is <strong>cryptographic piece verification</strong>. The torrent file contains SHA-1 hashes of every piece of the target file. When a peer receives a piece from another peer, it immediately computes the SHA-1 hash of the received data and compares it to the expected hash from the torrent file. If the hashes don&#39;t match, the piece is discarded and requested again from a different peer.</p>\n<p>This creates a <strong>trustless verification system</strong> where peers don&#39;t need to trust each other - they only need to trust the cryptographic hashes in the torrent file. The hash verification happens at the <strong>piece level</strong> (typically 256KB to 1MB chunks) rather than the entire file, allowing verification to occur incrementally during download.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Stage</th>\n<th>Data Verified</th>\n<th>Hash Source</th>\n<th>Action on Mismatch</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Torrent File</strong></td>\n<td>Info dictionary metadata</td>\n<td>SHA-1 of bencoded info dict</td>\n<td>Reject torrent as invalid</td>\n</tr>\n<tr>\n<td><strong>Individual Pieces</strong></td>\n<td>Each 256KB-1MB piece</td>\n<td>Pre-computed SHA-1 in pieces list</td>\n<td>Discard piece, request from different peer</td>\n</tr>\n<tr>\n<td><strong>Complete File</strong></td>\n<td>Assembled final file</td>\n<td>Recompute all piece hashes</td>\n<td>File complete and verified</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Security Property</strong>: The piece hashing system ensures that even if malicious peers control 99% of the swarm, they cannot corrupt your download as long as at least one honest peer has each piece. The cryptographic verification makes corruption detectable with overwhelming probability.</p>\n</blockquote>\n<p><strong>Challenge 3: Fair Sharing Incentives</strong></p>\n<p>The third challenge is the <strong>free rider problem</strong>: in a system where anyone can download files, what prevents everyone from downloading without uploading, causing the system to collapse from lack of seeders? This is a classic tragedy of the commons scenario.</p>\n<p>BitTorrent addresses this through <strong>tit-for-tat reciprocity</strong> and the <strong>choking algorithm</strong>. Peers track how much data they&#39;ve uploaded to and downloaded from each connected peer. Each peer &quot;unchokes&quot; (allows downloads from) only a limited number of other peers at any time, prioritizing peers who are uploading data back to them.</p>\n<p>The choking mechanism creates <strong>economic incentives</strong> for sharing. Peers who upload get better download performance because other peers prioritize them. Peers who only try to download get &quot;choked&quot; by most peers, severely limiting their download speed. This creates a virtuous cycle where contributing to the network directly improves your own experience.</p>\n<table>\n<thead>\n<tr>\n<th>Peer Relationship</th>\n<th>Upload to Them</th>\n<th>Download from Them</th>\n<th>Their Incentive</th>\n<th>Your Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Mutual Exchange</strong></td>\n<td>High</td>\n<td>High</td>\n<td>You provide content they want</td>\n<td>Fast downloads from them</td>\n</tr>\n<tr>\n<td><strong>Optimistic Unchoke</strong></td>\n<td>High</td>\n<td>Low (they&#39;re new)</td>\n<td>Bootstraps new peers into economy</td>\n<td>Potential future reciprocation</td>\n</tr>\n<tr>\n<td><strong>Free Rider</strong></td>\n<td>Low/Zero</td>\n<td>Low (choked)</td>\n<td>Strong incentive to start sharing</td>\n<td>Preserve bandwidth for contributors</td>\n</tr>\n<tr>\n<td><strong>Seed</strong></td>\n<td>High</td>\n<td>Zero (they&#39;re complete)</td>\n<td>Altruistic sharing</td>\n<td>Community health, future availability</td>\n</tr>\n</tbody></table>\n<p>The <strong>optimistic unchoke</strong> mechanism provides a crucial bootstrap path for new peers who haven&#39;t yet contributed to the swarm. Periodically, peers will unchoke a random peer regardless of reciprocation history, giving newcomers a chance to start downloading and begin contributing.</p>\n<blockquote>\n<p><strong>Economic Design Insight</strong>: BitTorrent&#39;s incentive system transforms file sharing from a pure public good (where rational actors free ride) into a <strong>reciprocal economy</strong> where contribution directly improves individual outcomes. This aligns individual incentives with system health.</p>\n</blockquote>\n<p>These three challenges - peer discovery, content verification, and fair sharing - represent the core technical problems that any practical P2P file sharing system must solve. BitTorrent&#39;s solutions to these problems have proven remarkably durable, with the core protocols remaining largely unchanged for over two decades while handling enormous volumes of global file sharing traffic.</p>\n<p>The interdependence of these solutions is crucial to understand. The tracker system enables rapid peer discovery, but peers must implement content verification because they can&#39;t trust discovered peers. The verification system enables safe downloading from untrusted sources, but the incentive system ensures there are sources worth downloading from. Each component reinforces the others to create a robust, self-sustaining ecosystem.</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"BitTorrent Client Architecture\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing the BitTorrent client architecture in Go, with complete starter code for infrastructure components and detailed skeletons for core learning components.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommendation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTTP Client</strong></td>\n<td><code>net/http</code> package</td>\n<td>Custom HTTP with connection pooling</td>\n<td>Simple - Go&#39;s HTTP client handles tracker communication well</td>\n</tr>\n<tr>\n<td><strong>TCP Networking</strong></td>\n<td><code>net.Conn</code> with manual protocol</td>\n<td>Framework like <code>github.com/pion/webrtc</code></td>\n<td>Simple - BitTorrent wire protocol is straightforward TCP</td>\n</tr>\n<tr>\n<td><strong>Concurrency</strong></td>\n<td>Goroutines with channels</td>\n<td>Worker pool libraries</td>\n<td>Simple - Go&#39;s built-in concurrency is perfect for P2P</td>\n</tr>\n<tr>\n<td><strong>File I/O</strong></td>\n<td><code>os.File</code> with <code>io</code> interfaces</td>\n<td>Memory-mapped files with <code>mmap</code></td>\n<td>Simple - Sequential piece writing doesn&#39;t need mmap</td>\n</tr>\n<tr>\n<td><strong>Hashing</strong></td>\n<td><code>crypto/sha1</code> package</td>\n<td>Hardware-accelerated crypto</td>\n<td>Simple - SHA-1 performance is sufficient</td>\n</tr>\n<tr>\n<td><strong>Bencode Parsing</strong></td>\n<td>Custom recursive parser</td>\n<td>Third-party bencode library</td>\n<td><strong>Custom</strong> - Parsing is core learning objective</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>bittorrent-client/\n├── cmd/\n│   └── bt-client/\n│       └── main.go              ← CLI entry point, argument parsing\n├── internal/\n│   ├── bencode/\n│   │   ├── decoder.go           ← Bencode parser (Milestone 1)\n│   │   └── decoder_test.go\n│   ├── torrent/\n│   │   ├── metainfo.go          ← Torrent file structures\n│   │   ├── parser.go            ← Torrent parsing (Milestone 1)\n│   │   └── parser_test.go\n│   ├── tracker/\n│   │   ├── client.go            ← HTTP tracker client (Milestone 2)\n│   │   ├── announce.go          ← Announce request/response\n│   │   └── tracker_test.go\n│   ├── peer/\n│   │   ├── connection.go        ← Peer wire protocol (Milestone 3)\n│   │   ├── handshake.go         ← Handshake implementation\n│   │   ├── messages.go          ← Protocol message types\n│   │   └── peer_test.go\n│   ├── piece/\n│   │   ├── manager.go           ← Piece download coordination (Milestone 4)\n│   │   ├── verification.go      ← Hash verification\n│   │   └── piece_test.go\n│   └── client/\n│       ├── client.go            ← Main BitTorrent client orchestration\n│       └── client_test.go\n├── pkg/                         ← Public APIs (if building library)\n├── testdata/                    ← Sample .torrent files for testing\n├── go.mod\n└── README.md</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Here&#39;s complete, working infrastructure code that handles non-core concerns:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/torrent/metainfo.go - Complete data structures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetaInfo represents the complete parsed torrent file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetaInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Announce     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"announce\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreationDate </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"creation_date,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Comment      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"comment,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">  `json:\"info_hash\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Info         </span><span style=\"color:#B392F0\">Info</span><span style=\"color:#9ECBFF\">      `json:\"info\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Info represents the info dictionary from the torrent file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Info</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length      </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">  `json:\"length\"`</span><span style=\"color:#6A737D\">           // Single file mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceLength </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">  `json:\"piece_length\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pieces      []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\"> `json:\"pieces\"`</span><span style=\"color:#6A737D\">           // SHA-1 hashes concatenated</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Files       []</span><span style=\"color:#B392F0\">File</span><span style=\"color:#9ECBFF\"> `json:\"files,omitempty\"`</span><span style=\"color:#6A737D\">  // Multi-file mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// File represents a file in multi-file torrent mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> File</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">    `json:\"length\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path   []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetPieceHashes returns individual piece hashes from the concatenated pieces field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetPieceHashes</span><span style=\"color:#E1E4E8\">() [][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    numPieces </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(i.Pieces) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 20</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hashes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, numPieces)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> numPieces; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(hashes[i][:], i.Pieces[i</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">:(i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hashes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateInfoHash computes SHA-1 hash of bencoded info dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CalculateInfoHash</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bencoded</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sha1.</span><span style=\"color:#B392F0\">Sum</span><span style=\"color:#E1E4E8\">(bencoded)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/tracker/announce.go - Complete tracker protocol structures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> tracker</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/url</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AnnounceRequest represents parameters sent to tracker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AnnounceRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash   [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PeerID     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port       </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Uploaded   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Downloaded </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Left       </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Event      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // \"started\", \"completed\", \"stopped\", or empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AnnounceResponse represents tracker's response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AnnounceResponse</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Interval    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `bencode:\"interval\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Complete    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `bencode:\"complete\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Incomplete  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `bencode:\"incomplete\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Peers       []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\"> `bencode:\"peers\"`</span><span style=\"color:#6A737D\">        // Compact format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FailureReason </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `bencode:\"failure reason,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PeerInfo represents a single peer from tracker response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PeerInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IP   [</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BuildAnnounceURL constructs the complete tracker announce URL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">req </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AnnounceRequest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BuildAnnounceURL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">announceURL</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> url.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">(announceURL)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    params </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> url</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Values</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    params.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"info_hash\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(req.InfoHash[:]))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    params.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"peer_id\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(req.PeerID[:]))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    params.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"port\"</span><span style=\"color:#E1E4E8\">, strconv.</span><span style=\"color:#B392F0\">Itoa</span><span style=\"color:#E1E4E8\">(req.Port))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    params.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"uploaded\"</span><span style=\"color:#E1E4E8\">, strconv.</span><span style=\"color:#B392F0\">FormatInt</span><span style=\"color:#E1E4E8\">(req.Uploaded, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    params.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"downloaded\"</span><span style=\"color:#E1E4E8\">, strconv.</span><span style=\"color:#B392F0\">FormatInt</span><span style=\"color:#E1E4E8\">(req.Downloaded, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    params.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"left\"</span><span style=\"color:#E1E4E8\">, strconv.</span><span style=\"color:#B392F0\">FormatInt</span><span style=\"color:#E1E4E8\">(req.Left, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    params.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"compact\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> req.Event </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        params.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"event\"</span><span style=\"color:#E1E4E8\">, req.Event)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base.RawQuery </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params.</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> base.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseCompactPeers decodes compact peer list from tracker response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseCompactPeers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">compactPeers</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">PeerInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    numPeers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(compactPeers) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">PeerInfo</span><span style=\"color:#E1E4E8\">, numPeers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> numPeers; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(peers[i].IP[:], compactPeers[offset:offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peers[i].Port </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">(compactPeers[offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#F97583\"> +</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">(compactPeers[offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> peers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>For the main learning objectives, provide detailed skeletons that map to the algorithm steps:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/bencode/decoder.go - Core learning skeleton</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> bencode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Decoder handles recursive parsing of bencode data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Decoder</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reader </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDecoder creates a decoder for the given data stream</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDecoder</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">{reader: bufio.</span><span style=\"color:#B392F0\">NewReader</span><span style=\"color:#E1E4E8\">(r)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Decode parses the next bencode value and returns it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is the main entry point for bencode parsing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Decode</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Peek at the next byte to determine the type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If byte is 'i', call d.decodeInteger()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If byte is 'l', call d.decodeList()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If byte is 'd', call d.decodeDictionary()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If byte is digit (0-9), call d.decodeString()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return error for any other byte value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use d.reader.Peek(1) to look at next byte without consuming it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// decodeString parses a bencode string: &#x3C;length>:&#x3C;content></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">decodeString</span><span style=\"color:#E1E4E8\">() ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read digits until ':' to get length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Convert length string to integer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read exactly 'length' bytes for string content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the raw bytes (don't convert to string - could be binary)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use d.reader.ReadBytes(':') to read until delimiter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// decodeInteger parses a bencode integer: i&#x3C;number>e</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">decodeInteger</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read and verify 'i' prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read digits (and possible '-') until 'e'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Convert to int64 using strconv.ParseInt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Read and verify 'e' suffix</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// decodeList parses a bencode list: l&#x3C;item1>&#x3C;item2>...e</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">decodeList</span><span style=\"color:#E1E4E8\">() ([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read and verify 'l' prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create empty slice for results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Loop until next byte is 'e':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4:   Call d.Decode() recursively for each item</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5:   Append result to slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Read and verify 'e' suffix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return completed slice</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// decodeDictionary parses a bencode dictionary: d&#x3C;key1>&#x3C;value1>&#x3C;key2>&#x3C;value2>...e</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">decodeDictionary</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read and verify 'd' prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create empty map for results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Loop until next byte is 'e':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4:   Call d.decodeString() for key (keys are always strings)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5:   Call d.Decode() recursively for value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6:   Store key-value pair in map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Read and verify 'e' suffix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return completed map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Convert key bytes to string: string(keyBytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/client/client.go - Main orchestration skeleton</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> client</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Client coordinates all aspects of BitTorrent downloading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Client</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metaInfo     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trackerClient </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tracker</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peers        </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">peer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieceManager </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">piece</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Synchronization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx          </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel       </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewClient creates a BitTorrent client for the given torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">metaInfo</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metaInfo: metaInfo,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peers:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">peer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ctx:      ctx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cancel:   cancel,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Download orchestrates the complete download process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Download</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">outputPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize piece manager with metaInfo piece data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Contact tracker to get initial peer list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Connect to multiple peers concurrently (start with 3-5)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start download coordinator goroutine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Periodically re-announce to tracker (every 30 minutes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Monitor for completion - all pieces downloaded and verified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Write final file and transition to seeding mode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Handle graceful shutdown on context cancellation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<p>Go-specific implementation tips for BitTorrent development:</p>\n<ul>\n<li><strong>Byte Handling</strong>: Use <code>[]byte</code> for all binary data (piece hashes, peer IDs). Never convert to string unless displaying to user.</li>\n<li><strong>Network Timeouts</strong>: Always set timeouts on network operations: <code>conn.SetDeadline(time.Now().Add(30*time.Second))</code></li>\n<li><strong>Binary Protocol</strong>: Use <code>encoding/binary</code> for reading/writing network byte order: <code>binary.BigEndian.Uint32(bytes)</code></li>\n<li><strong>Concurrency</strong>: Use <code>sync.RWMutex</code> for peer map access. Use channels to coordinate between goroutines.</li>\n<li><strong>Error Handling</strong>: Wrap errors with context: <code>fmt.Errorf(&quot;failed to parse piece %d: %w&quot;, pieceIndex, err)</code></li>\n<li><strong>File I/O</strong>: Use <code>os.OpenFile</code> with <code>O_CREATE|O_WRONLY</code> flags. Call <code>file.Sync()</code> after writing pieces.</li>\n<li><strong>HTTP Client</strong>: Reuse <code>http.Client</code> instance across tracker requests for connection pooling.</li>\n</ul>\n<p><strong>F. Milestone Checkpoints</strong></p>\n<p>After implementing each milestone, verify these behaviors:</p>\n<p><strong>Milestone 1 Checkpoint - Torrent Parsing</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/bt-client/main.go</span><span style=\"color:#9ECBFF\"> parse</span><span style=\"color:#9ECBFF\"> testdata/sample.torrent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Announce URL: http://tracker.example.com:8080/announce</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Info Hash: 1234567890abcdef1234567890abcdef12345678</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># File Name: example.txt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># File Size: 1048576 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Piece Length: 262144 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Number of Pieces: 4</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint - Tracker Communication</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/bt-client/main.go</span><span style=\"color:#9ECBFF\"> announce</span><span style=\"color:#9ECBFF\"> testdata/sample.torrent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Contacting tracker: http://tracker.example.com:8080/announce</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Received 15 peers:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   192.168.1.100:6881</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   10.0.0.5:51234</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   [... more peers]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Interval: 1800 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Complete: 5, Incomplete: 10</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint - Peer Protocol</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/bt-client/main.go</span><span style=\"color:#9ECBFF\"> connect</span><span style=\"color:#9ECBFF\"> testdata/sample.torrent</span><span style=\"color:#9ECBFF\"> 192.168.1.100:6881</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Connecting to peer 192.168.1.100:6881</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Handshake successful: peer_id = abcdef1234567890abcdef1234567890abcdef12</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Received bitfield: 11110000 (peer has first 4 pieces)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Peer unchoked us, ready to request pieces</span></span></code></pre></div>\n\n\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section defines the scope for all milestones (1-4) by establishing clear boundaries for what our BitTorrent client will and will not implement.</p>\n</blockquote>\n<p>Building a complete BitTorrent client involves numerous complex features and protocols that have evolved over decades of peer-to-peer development. Without clear scope boundaries, it&#39;s easy to get overwhelmed by the sheer breadth of functionality that modern BitTorrent clients support. Think of this like planning a cross-country road trip: you need to decide upfront which cities you&#39;ll visit, which scenic routes you&#39;ll take, and which detours you&#39;ll skip, or you&#39;ll end up wandering aimlessly and never reach your destination.</p>\n<p>This section establishes three critical categories of requirements: <strong>functional goals</strong> (the core features we must implement), <strong>non-functional goals</strong> (the quality attributes our system must exhibit), and <strong>explicit non-goals</strong> (features we deliberately choose not to implement). This scope definition serves as our north star throughout the implementation process, helping us make consistent decisions about complexity trade-offs and feature prioritization.</p>\n<p>The goal-setting process for a BitTorrent client is particularly challenging because the protocol ecosystem includes dozens of optional extensions, performance optimizations, and compatibility quirks developed over 20+ years of evolution. A production BitTorrent client like qBittorrent or Transmission supports hundreds of features. Our learning-focused implementation needs to capture the essential complexity of BitTorrent without getting bogged down in edge cases that obscure the core concepts.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>Our BitTorrent client will implement the four core pillars of BitTorrent functionality that enable complete participation in a peer-to-peer swarm. These represent the minimum viable feature set for a working BitTorrent client that can successfully download and share files with other peers in the ecosystem.</p>\n<blockquote>\n<p><strong>Decision: Core BitTorrent Protocol Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: BitTorrent encompasses many protocol extensions and optional features developed over two decades</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Implement only basic downloading without seeding</li>\n<li>Implement full BitTorrent v1 protocol with downloading and seeding</li>\n<li>Include modern extensions like DHT and magnet links</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement complete BitTorrent v1 protocol including seeding capability</li>\n<li><strong>Rationale</strong>: Seeding is essential for understanding BitTorrent&#39;s reciprocity model and makes our client a good network citizen. BitTorrent v1 provides all core concepts without extension complexity.</li>\n<li><strong>Consequences</strong>: More implementation complexity than download-only, but creates a complete learning experience and functional client</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Functional Goal</th>\n<th>Description</th>\n<th>Key Components</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Torrent File Parsing</strong></td>\n<td>Parse <code>.torrent</code> files to extract all metadata needed for downloading</td>\n<td>Bencode decoder, metadata extractor, info hash calculator</td>\n<td>Successfully parse real torrent files and extract announce URL, file info, piece hashes</td>\n</tr>\n<tr>\n<td><strong>Tracker Communication</strong></td>\n<td>Communicate with HTTP trackers to discover peers</td>\n<td>HTTP client, announce protocol, peer list parser</td>\n<td>Receive valid peer lists from public trackers, handle tracker responses and errors</td>\n</tr>\n<tr>\n<td><strong>Peer Wire Protocol</strong></td>\n<td>Implement complete peer-to-peer communication protocol</td>\n<td>TCP connection manager, message parser, state machine</td>\n<td>Successfully handshake with real BitTorrent clients, exchange messages, download blocks</td>\n</tr>\n<tr>\n<td><strong>File Download Management</strong></td>\n<td>Coordinate downloading file pieces from multiple peers</td>\n<td>Piece scheduler, download orchestrator, content verifier</td>\n<td>Download complete files that match original content hash, handle peer disconnections</td>\n</tr>\n<tr>\n<td><strong>Content Verification</strong></td>\n<td>Verify integrity of downloaded data using cryptographic hashes</td>\n<td>SHA-1 hasher, piece validator, corruption detector</td>\n<td>Reject corrupted pieces, re-request invalid data, ensure file integrity</td>\n</tr>\n<tr>\n<td><strong>Upload and Seeding</strong></td>\n<td>Serve file pieces to other peers requesting them</td>\n<td>Upload manager, request responder, bandwidth tracker</td>\n<td>Successfully seed files to other clients, track upload statistics for tracker reporting</td>\n</tr>\n</tbody></table>\n<p><strong>Torrent File Parsing</strong> forms the foundation of our client by extracting all metadata required for the download process. The Bencode decoder must handle the four Bencode data types (strings, integers, lists, dictionaries) with proper binary string support. The metadata extractor pulls critical information including the tracker announce URL, file specifications, and piece hash list. Most importantly, the info hash calculation must compute the SHA-1 digest from the exact bencoded bytes of the info dictionary, as this serves as the unique identifier for the torrent across the entire BitTorrent network.</p>\n<p><strong>Tracker Communication</strong> implements the HTTP-based announce protocol that serves as BitTorrent&#39;s peer discovery mechanism. Our client must construct properly formatted announce requests with URL-encoded parameters including the info hash, peer ID, port number, and transfer statistics. The tracker responds with a list of peers in compact binary format (6 bytes per peer: 4 bytes IP + 2 bytes port) that we must parse into usable network addresses. The client must also implement the announce interval system, re-contacting the tracker periodically to report progress and discover new peers.</p>\n<p><strong>Peer Wire Protocol</strong> represents the most complex functional requirement, implementing the standardized message-based protocol that BitTorrent peers use to coordinate file transfers. This includes the 68-byte handshake sequence that establishes connections, the length-prefixed message framing system, and the complete set of peer protocol messages (choke, unchoke, interested, have, bitfield, request, piece). The implementation must maintain per-peer state machines tracking choking and interest status, manage request pipelining for optimal throughput, and handle the intricate dance of peer coordination.</p>\n<p><strong>File Download Management</strong> orchestrates the complex process of downloading file pieces from multiple peers simultaneously. This requires implementing piece selection algorithms (starting with random selection, evolving toward rarest-first for efficiency), managing concurrent downloads to avoid requesting the same piece multiple times, and coordinating the assembly of completed pieces into the final output file. The download manager must handle peer disconnections gracefully, redistributing incomplete piece requests to other available peers.</p>\n<p><strong>Content Verification</strong> ensures the integrity of downloaded data by validating each piece against its expected SHA-1 hash from the torrent metadata. When a piece download completes, the client must compute the piece&#39;s hash and compare it against the corresponding 20-byte hash from the torrent&#39;s piece hash list. Corrupted or invalid pieces must be discarded and re-requested from different peers. This verification system is critical for security and prevents the propagation of corrupted data through the swarm.</p>\n<p><strong>Upload and Seeding</strong> completes the reciprocal nature of BitTorrent by serving file pieces to other peers. When peers send request messages for specific pieces our client possesses, we must respond with the corresponding piece data. This requires tracking which pieces we have available, managing upload bandwidth fairly across requesting peers, and maintaining statistics on bytes uploaded for tracker reporting. Effective seeding behavior is essential for swarm health and BitTorrent&#39;s long-term sustainability.</p>\n<h3 id=\"non-functional-goals\">Non-Functional Goals</h3>\n<p>Beyond core functionality, our BitTorrent client must meet specific quality attributes that determine its effectiveness and usability in real-world scenarios. These non-functional requirements define how well the system performs its functional goals rather than what it does.</p>\n<blockquote>\n<p><strong>Decision: Performance vs. Simplicity Balance</strong></p>\n<ul>\n<li><strong>Context</strong>: BitTorrent clients can be optimized for extreme performance with complex algorithms, or kept simple for educational clarity</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Prioritize maximum performance with advanced optimizations</li>\n<li>Prioritize code clarity and educational value</li>\n<li>Balance reasonable performance with maintainable code</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Target reasonable performance with maintainable, well-documented code</li>\n<li><strong>Rationale</strong>: Educational goals require readable code, but unusably slow performance would prevent real-world testing and learning</li>\n<li><strong>Consequences</strong>: May not match production client performance, but provides solid foundation for learning and future optimization</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Non-Functional Goal</th>\n<th>Requirement</th>\n<th>Measurement Criteria</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Download Performance</strong></td>\n<td>Achieve reasonable download speeds comparable to other clients</td>\n<td>Download 100MB+ files at 70%+ of available bandwidth</td>\n<td>Implement request pipelining, concurrent peer connections, efficient piece selection</td>\n</tr>\n<tr>\n<td><strong>Memory Efficiency</strong></td>\n<td>Handle large torrents without excessive memory usage</td>\n<td>Support 1GB+ torrents with &lt;100MB RAM usage</td>\n<td>Stream piece data to disk, avoid loading entire files in memory</td>\n</tr>\n<tr>\n<td><strong>Connection Reliability</strong></td>\n<td>Maintain stable connections with multiple peers</td>\n<td>Successfully maintain 10+ concurrent peer connections</td>\n<td>Implement proper TCP connection management, handle network interruptions</td>\n</tr>\n<tr>\n<td><strong>Error Recovery</strong></td>\n<td>Gracefully handle common failure scenarios</td>\n<td>Recover from tracker failures, peer disconnections, corrupted data</td>\n<td>Comprehensive error handling, retry logic, fallback mechanisms</td>\n</tr>\n<tr>\n<td><strong>Resource Fairness</strong></td>\n<td>Share upload bandwidth fairly among requesting peers</td>\n<td>No single peer monopolizes upload capacity</td>\n<td>Implement upload slot management, fair queuing for requests</td>\n</tr>\n<tr>\n<td><strong>Code Maintainability</strong></td>\n<td>Produce readable, well-documented, testable code</td>\n<td>All components have unit tests, clear module boundaries</td>\n<td>Modular architecture, comprehensive documentation, test coverage</td>\n</tr>\n</tbody></table>\n<p><strong>Download Performance</strong> ensures our client can achieve reasonable throughput when downloading files from healthy swarms. While we don&#39;t need to match the performance of highly optimized production clients like libtorrent, the client must download files fast enough to be practically useful. This requires implementing request pipelining (maintaining multiple outstanding block requests per peer), managing concurrent connections to multiple peers, and using effective piece selection strategies that minimize download time.</p>\n<p><strong>Memory Efficiency</strong> becomes critical when handling large torrents with hundreds or thousands of pieces. Our client must avoid loading entire files into memory, instead streaming piece data directly to disk as it arrives. The piece management system should maintain metadata about piece availability and download progress without storing the actual piece content in RAM. This approach enables handling multi-gigabyte torrents on resource-constrained systems.</p>\n<p><strong>Connection Reliability</strong> addresses the inherent instability of peer-to-peer networks where peers frequently join and leave the swarm. Our client must detect failed connections promptly, clean up resources from disconnected peers, and continuously discover new peers to replace lost connections. The connection management system should handle common network issues like timeouts, connection resets, and temporary network partitions without crashing or stalling downloads.</p>\n<p><strong>Error Recovery</strong> encompasses the broad category of graceful degradation when things go wrong. Tracker servers may become unavailable, requiring fallback strategies or retry logic. Peers may send malformed messages that require defensive parsing. Downloaded pieces may fail hash verification and need re-downloading from different sources. The client must handle these scenarios without human intervention, automatically recovering and continuing the download process.</p>\n<p><strong>Resource Fairness</strong> reflects BitTorrent&#39;s fundamental principle of reciprocity – peers that contribute upload bandwidth should receive better download performance. Our client must avoid selfish behavior that would harm swarm health, such as downloading without seeding or monopolizing other peers&#39; upload capacity. This includes implementing reasonable limits on concurrent requests per peer and fairly distributing our upload capacity among requesting peers.</p>\n<p><strong>Code Maintainability</strong> recognizes that this implementation serves educational purposes and may be extended or modified by learners. The codebase must prioritize clarity and comprehensibility over micro-optimizations. Each component should have well-defined responsibilities, clear interfaces, and comprehensive unit tests. Documentation should explain not just what the code does, but why specific design decisions were made.</p>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>Defining what we will NOT implement is equally important as defining what we will implement. These explicit non-goals help maintain project scope and prevent feature creep that could derail the core learning objectives. Modern BitTorrent clients implement dozens of protocol extensions and advanced features that, while valuable in production, would obscure the fundamental concepts we&#39;re trying to teach.</p>\n<blockquote>\n<p><strong>Decision: Exclude Advanced BitTorrent Extensions</strong></p>\n<ul>\n<li><strong>Context</strong>: Modern BitTorrent includes many protocol extensions (DHT, PEX, encryption, etc.) that provide additional functionality</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Implement all major extensions for feature completeness</li>\n<li>Implement basic extensions like DHT for modern compatibility</li>\n<li>Focus solely on core BitTorrent v1 protocol</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Exclude all protocol extensions and advanced features</li>\n<li><strong>Rationale</strong>: Extensions add significant complexity without teaching new fundamental concepts. Core protocol provides complete learning experience.</li>\n<li><strong>Consequences</strong>: Client won&#39;t support magnet links or trackerless operation, but remains focused on essential BitTorrent concepts</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Explicit Non-Goal</th>\n<th>Rationale</th>\n<th>Complexity Impact</th>\n<th>Alternative Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Distributed Hash Table (DHT)</strong></td>\n<td>DHT is a complex distributed systems topic that deserves separate study</td>\n<td>Would add 500+ lines of complex networking code</td>\n<td>Use tracker-based torrents only</td>\n</tr>\n<tr>\n<td><strong>Magnet Link Support</strong></td>\n<td>Requires DHT implementation for metadata download</td>\n<td>Depends on DHT, adds metadata resolution complexity</td>\n<td>Work with traditional <code>.torrent</code> files</td>\n</tr>\n<tr>\n<td><strong>Protocol Encryption</strong></td>\n<td>Crypto implementation is error-prone and adds little educational value</td>\n<td>SSL/TLS integration, key exchange protocols</td>\n<td>Rely on network-level security if needed</td>\n</tr>\n<tr>\n<td><strong>Multi-Tracker Support</strong></td>\n<td>Tracker failover logic adds complexity without new concepts</td>\n<td>Redundant with single-tracker error handling</td>\n<td>Use single primary tracker per torrent</td>\n</tr>\n<tr>\n<td><strong>Peer Exchange (PEX)</strong></td>\n<td>Peer discovery optimization that doesn&#39;t change core concepts</td>\n<td>Additional message types and peer management</td>\n<td>Rely on tracker for peer discovery</td>\n</tr>\n<tr>\n<td><strong>Web Seeding (HTTP/FTP)</strong></td>\n<td>Hybrid P2P/client-server model that complicates architecture</td>\n<td>HTTP client integration, different download paths</td>\n<td>Pure P2P downloading only</td>\n</tr>\n<tr>\n<td><strong>Selective File Download</strong></td>\n<td>File filtering within multi-file torrents</td>\n<td>Piece-to-file mapping complexity, partial completion</td>\n<td>Download complete torrents only</td>\n</tr>\n<tr>\n<td><strong>Bandwidth Limiting</strong></td>\n<td>QoS feature that doesn&#39;t impact core protocol understanding</td>\n<td>Rate limiting algorithms, traffic shaping</td>\n<td>Rely on OS-level bandwidth management</td>\n</tr>\n<tr>\n<td><strong>Advanced Piece Selection</strong></td>\n<td>Sophisticated algorithms like endgame mode and smart seeding</td>\n<td>Complex heuristics and optimization logic</td>\n<td>Use simple rarest-first selection</td>\n</tr>\n<tr>\n<td><strong>Resume/Persistence</strong></td>\n<td>Saving and restoring partial download state</td>\n<td>Serialization, state management, crash recovery</td>\n<td>Restart downloads from beginning</td>\n</tr>\n</tbody></table>\n<p><strong>Distributed Hash Table (DHT)</strong> represents a completely separate distributed systems concept that enables trackerless operation. While DHT is fascinating technology, implementing it properly requires understanding distributed consensus, network partitions, routing table maintenance, and peer bootstrapping – topics that could fill their own comprehensive tutorial. Including DHT would double the project&#39;s complexity while teaching concepts orthogonal to BitTorrent&#39;s core file-sharing mechanisms.</p>\n<p><strong>Magnet Link Support</strong> depends heavily on DHT for metadata resolution, since magnet links contain only the info hash rather than complete torrent metadata. Without DHT, magnet links become unusable, making this feature dependent on our DHT non-goal. Traditional <code>.torrent</code> files provide all necessary metadata upfront, eliminating the need for complex metadata discovery protocols.</p>\n<p><strong>Protocol Encryption</strong> adds cryptographic complexity that doesn&#39;t enhance understanding of BitTorrent&#39;s core concepts. Implementing encryption properly requires deep knowledge of cryptographic protocols, key exchange mechanisms, and security best practices – specialized knowledge that&#39;s orthogonal to peer-to-peer file sharing concepts. Network-level security (VPN, HTTPS) can provide encryption when needed without complicating the BitTorrent implementation.</p>\n<p><strong>Multi-Tracker Support</strong> allows torrents to specify backup trackers for redundancy, but the failover logic and tracker prioritization algorithms don&#39;t teach new concepts beyond single-tracker communication. The error handling patterns for tracker failures apply equally whether dealing with one tracker or ten. Supporting multi-tracker scenarios would add configuration complexity and edge cases without educational benefit.</p>\n<p><strong>Peer Exchange (PEX)</strong> enables peers to share information about other peers in the swarm, providing an additional peer discovery mechanism beyond tracker announcements. While PEX improves swarm connectivity and reduces tracker load, it&#39;s essentially an optimization that doesn&#39;t change the fundamental peer-to-peer download process. Tracker-based peer discovery provides sufficient peer connectivity for learning purposes.</p>\n<p><strong>Web Seeding</strong> allows torrents to include HTTP or FTP servers as additional download sources, creating a hybrid P2P/client-server architecture. This feature requires implementing HTTP range requests, integrating with existing piece management systems, and handling the different reliability characteristics of web servers versus P2P peers. The added complexity doesn&#39;t reinforce core BitTorrent concepts and introduces architectural complications.</p>\n<p><strong>Selective File Download</strong> enables users to choose specific files from multi-file torrents, downloading only desired content. This requires complex piece-to-file mapping logic, partial torrent completion tracking, and modified seeding behavior for incomplete torrents. While useful in practice, selective downloading obscures the fundamental concept of torrents as atomic units of content sharing.</p>\n<p><strong>Bandwidth Limiting</strong> provides quality-of-service features that help users manage network resource consumption. However, implementing effective bandwidth limiting requires understanding rate limiting algorithms, traffic shaping, and network scheduling – topics that don&#39;t reinforce BitTorrent protocol concepts. Operating system tools and network-level QoS provide better bandwidth management without complicating the BitTorrent implementation.</p>\n<p><strong>Advanced Piece Selection</strong> algorithms like endgame mode (requesting final pieces from all peers) and smart seeding (prioritizing rare pieces when seeding) can significantly improve download performance and swarm health. However, these optimizations involve complex heuristics and game-theoretic considerations that obscure the basic piece selection concept. Simple rarest-first selection provides adequate performance while remaining easy to understand and implement.</p>\n<p><strong>Resume/Persistence</strong> enables users to stop and restart downloads without losing progress, requiring serialization of download state, piece completion tracking, and crash recovery logic. While extremely valuable for user experience, persistence adds significant implementation complexity around state management and error recovery that doesn&#39;t teach new BitTorrent protocol concepts. Starting downloads from scratch simplifies implementation and testing.</p>\n<blockquote>\n<p>The key insight behind these non-goals is that BitTorrent&#39;s core concepts – bencoding, tracker communication, peer protocol, and piece management – provide a complete and challenging learning experience. Advanced features, while valuable in production systems, often optimize or extend these core concepts without introducing fundamentally new ideas. By maintaining strict scope boundaries, we ensure learners master the essential concepts before exploring the rich ecosystem of BitTorrent extensions.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete technology recommendations and architectural guidance for implementing our scoped BitTorrent client in Go.</p>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTTP Client</strong></td>\n<td><code>net/http</code> with default client</td>\n<td><code>net/http</code> with custom transport and timeouts</td>\n</tr>\n<tr>\n<td><strong>TCP Networking</strong></td>\n<td><code>net.Conn</code> with basic I/O</td>\n<td><code>net.Conn</code> with connection pooling and buffering</td>\n</tr>\n<tr>\n<td><strong>Concurrency</strong></td>\n<td>Goroutines with channels</td>\n<td>Worker pools with <code>sync.WaitGroup</code> coordination</td>\n</tr>\n<tr>\n<td><strong>File I/O</strong></td>\n<td><code>os.File</code> with synchronous writes</td>\n<td><code>os.File</code> with buffered writes and fsync</td>\n</tr>\n<tr>\n<td><strong>Hashing</strong></td>\n<td><code>crypto/sha1</code> standard library</td>\n<td><code>crypto/sha1</code> with pre-allocated buffers</td>\n</tr>\n<tr>\n<td><strong>Bencode</strong></td>\n<td>Custom recursive parser</td>\n<td>Third-party library (not recommended for learning)</td>\n</tr>\n<tr>\n<td><strong>Logging</strong></td>\n<td><code>log</code> standard library</td>\n<td>Structured logging with <code>slog</code> (Go 1.21+)</td>\n</tr>\n<tr>\n<td><strong>Testing</strong></td>\n<td><code>testing</code> with table-driven tests</td>\n<td><code>testing</code> with property-based testing</td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>Hard-coded constants</td>\n<td><code>flag</code> package for command-line options</td>\n</tr>\n</tbody></table>\n<p>The simple options provide everything needed for a functional BitTorrent client while keeping dependencies minimal and code transparent. Advanced options offer better performance and production-readiness but add complexity that may distract from core learning objectives.</p>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>bittorrent-client/\n├── cmd/\n│   └── bittorrent/\n│       └── main.go                 ← CLI entry point\n├── internal/\n│   ├── bencode/\n│   │   ├── decoder.go              ← Bencode parsing logic\n│   │   └── decoder_test.go\n│   ├── torrent/\n│   │   ├── metainfo.go            ← Torrent file structures and parsing\n│   │   └── metainfo_test.go\n│   ├── tracker/\n│   │   ├── client.go              ← HTTP tracker communication\n│   │   ├── announce.go            ← Announce request/response handling\n│   │   └── client_test.go\n│   ├── peer/\n│   │   ├── connection.go          ← Individual peer connection management\n│   │   ├── protocol.go            ← Wire protocol message handling\n│   │   ├── handshake.go          ← Connection handshake logic\n│   │   └── connection_test.go\n│   ├── piece/\n│   │   ├── manager.go             ← Piece download coordination\n│   │   ├── scheduler.go           ← Piece selection algorithms\n│   │   ├── verifier.go           ← Content hash verification\n│   │   └── manager_test.go\n│   └── client/\n│       ├── client.go              ← Main BitTorrent client orchestration\n│       └── client_test.go\n├── pkg/\n│   └── bittorrent/\n│       └── types.go               ← Public API types and constants\n├── testdata/\n│   ├── sample.torrent            ← Test torrent files\n│   └── sample_content/           ← Expected file content for tests\n├── go.mod\n├── go.sum\n└── README.md</code></pre></div>\n\n<p>This structure separates concerns cleanly: <code>cmd/</code> contains the executable entry point, <code>internal/</code> contains implementation packages that map to our architectural components, <code>pkg/</code> exposes public APIs for potential library use, and <code>testdata/</code> provides test fixtures. Each component gets its own package with focused responsibilities and comprehensive tests.</p>\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>File: <code>internal/bencode/decoder.go</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> bencode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common bencode parsing errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrUnexpectedEOF    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected end of input\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrInvalidFormat    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid bencode format\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrInvalidInteger   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid integer format\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrInvalidString    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid string format\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Decoder handles bencode parsing from an input stream</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Decoder</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reader </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDecoder creates a new bencode decoder for the given reader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDecoder</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reader: bufio.</span><span style=\"color:#B392F0\">NewReader</span><span style=\"color:#E1E4E8\">(r),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// peekByte returns the next byte without consuming it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">peekByte</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> d.reader.</span><span style=\"color:#B392F0\">Peek</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bytes[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// readByte consumes and returns the next byte</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readByte</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> d.reader.</span><span style=\"color:#B392F0\">ReadByte</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// readUntil reads bytes until the specified delimiter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readUntil</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">delim</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> d.reader.</span><span style=\"color:#B392F0\">ReadSlice</span><span style=\"color:#E1E4E8\">(delim)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Decode parses the next bencode value from the input stream</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Decode</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement main decode dispatch based on first byte</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Look at first character to determine type:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // '0'-'9': string (length prefix)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 'i': integer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 'l': list  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 'd': dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"decode not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>pkg/bittorrent/types.go</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> bittorrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Standard BitTorrent constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PIECE_HASH_SIZE</span><span style=\"color:#F97583\">    =</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#6A737D\">  // SHA-1 produces 20-byte hashes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMPACT_PEER_SIZE</span><span style=\"color:#F97583\">  =</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#6A737D\">   // 4 bytes IP + 2 bytes port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCK_SIZE</span><span style=\"color:#F97583\">         =</span><span style=\"color:#79B8FF\"> 16384</span><span style=\"color:#6A737D\"> // Standard 16KB block size</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_PEERS</span><span style=\"color:#F97583\">          =</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#6A737D\">  // Reasonable concurrent connection limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetaInfo represents the complete parsed torrent file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetaInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Announce     </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Primary tracker announce URL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreationDate </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\"> // When torrent was created</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Comment      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Optional comment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // SHA-1 hash of info dictionary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Info         </span><span style=\"color:#B392F0\">Info</span><span style=\"color:#6A737D\">      // File and piece information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Info contains the core file and piece information from torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Info</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Suggested filename or directory name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length      </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">   // Total file size (single-file torrents only)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceLength </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">   // Size of each piece except possibly the last</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pieces      []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // Concatenated SHA-1 hashes of all pieces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Files       []</span><span style=\"color:#B392F0\">File</span><span style=\"color:#6A737D\">  // File list (multi-file torrents only)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// File represents a single file in a multi-file torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> File</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">    // File size in bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path   []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Path components for file location</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetPieceHashes splits the concatenated piece hashes into individual hashes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetPieceHashes</span><span style=\"color:#E1E4E8\">() [][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    numPieces </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(i.Pieces) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> PIECE_HASH_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hashes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, numPieces)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> numPieces; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(hashes[i][:], i.Pieces[i</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">PIECE_HASH_SIZE:(i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">PIECE_HASH_SIZE])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hashes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PeerInfo represents a peer's network address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PeerInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IP   [</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\"> // IPv4 address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // TCP port number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// String formats peer info as \"IP:port\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#B392F0\">PeerInfo</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, p.IP[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], p.IP[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], p.IP[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], p.IP[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], p.Port)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>File: <code>internal/torrent/metainfo.go</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/bencode</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/pkg/bittorrent</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseFromFile reads and parses a torrent file from disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseFromFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filepath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">bittorrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Open the torrent file for reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create bencode decoder for the file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Decode the root dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Extract announce URL from root dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Extract info dictionary from root dict  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Calculate info hash from bencoded info dict bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Parse info dictionary into Info struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return populated MetaInfo struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use CalculateInfoHash() helper function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateInfoHash computes SHA-1 hash of bencoded info dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CalculateInfoHash</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bencoded</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create SHA-1 hasher</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Write bencoded bytes to hasher</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Get final hash sum as [20]byte array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use crypto/sha1 package</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseInfo converts bencode dictionary to Info struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseInfo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">infoDict</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#B392F0\">bittorrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract \"name\" field as string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Extract \"piece length\" field as int64</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Extract \"pieces\" field as byte slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if single-file torrent (has \"length\" field)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If single-file, extract \"length\" field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If multi-file, extract \"files\" list and parse each file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate piece length and pieces alignment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return populated Info struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Handle both single-file and multi-file torrent formats</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> bittorrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<p><strong>Go-Specific Implementation Tips:</strong></p>\n<ul>\n<li><p><strong>Bencode Parsing</strong>: Use <code>bufio.Reader</code> for efficient byte-by-byte parsing. The <code>ReadSlice()</code> method is particularly useful for reading until delimiters.</p>\n</li>\n<li><p><strong>Binary Data Handling</strong>: Bencode strings are binary data, not UTF-8 text. Always work with <code>[]byte</code> slices and avoid string conversion unless specifically needed for text fields.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Create specific error types for different parsing failures. Use <code>errors.New()</code> for constant errors and <code>fmt.Errorf()</code> for contextual errors.</p>\n</li>\n<li><p><strong>HTTP Requests</strong>: Use <code>http.Get()</code> for simple tracker requests. For production code, create custom <code>http.Client</code> with timeouts: <code>&amp;http.Client{Timeout: 30 * time.Second}</code>.</p>\n</li>\n<li><p><strong>Concurrency</strong>: Use goroutines for peer connections and channels for coordination. Pattern: <code>go handlePeer(conn, pieceManager)</code> for each peer connection.</p>\n</li>\n<li><p><strong>File I/O</strong>: Use <code>os.OpenFile()</code> with <code>O_CREATE|O_WRONLY</code> flags for output files. Call <code>file.Sync()</code> after writing each piece to ensure data persistence.</p>\n</li>\n<li><p><strong>Network Byte Order</strong>: BitTorrent uses big-endian byte order. Use <code>binary.BigEndian.Uint32()</code> and <code>binary.BigEndian.PutUint32()</code> for multi-byte integers.</p>\n</li>\n<li><p><strong>Testing</strong>: Create test torrents using existing BitTorrent clients. Keep small test files (&lt; 1MB) for fast test execution.</p>\n</li>\n</ul>\n<h4 id=\"f-milestone-checkpoints\">F. Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Torrent Parsing):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test command</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/bencode/...</span><span style=\"color:#9ECBFF\"> ./internal/torrent/...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># All tests pass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Can parse real .torrent files </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Info hash matches other BitTorrent clients</span></span></code></pre></div>\n\n<p><strong>Verification Steps:</strong></p>\n<ol>\n<li>Download a small torrent file from a legal source (Linux distributions work well)</li>\n<li>Parse it with your implementation and extract the info hash</li>\n<li>Verify the info hash matches what other BitTorrent clients show</li>\n<li>Check that announce URL and file information are correctly extracted</li>\n</ol>\n<p><strong>After Milestone 2 (Tracker Communication):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test with actual tracker</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/bittorrent/main.go</span><span style=\"color:#9ECBFF\"> announce</span><span style=\"color:#9ECBFF\"> sample.torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Found X peers from tracker</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Peer list: [IP:port IP:port ...]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># No network errors or parsing failures</span></span></code></pre></div>\n\n<p><strong>After Milestone 3 (Peer Protocol):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test peer connections</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/bittorrent/main.go</span><span style=\"color:#9ECBFF\"> connect</span><span style=\"color:#9ECBFF\"> sample.torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Successfully handshake with multiple peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Receive bitfield and piece messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># No protocol violations or connection errors</span></span></code></pre></div>\n\n<p><strong>After Milestone 4 (Complete Download):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Full download test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/bittorrent/main.go</span><span style=\"color:#9ECBFF\"> download</span><span style=\"color:#9ECBFF\"> sample.torrent</span><span style=\"color:#9ECBFF\"> output.file</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Download completes successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Output file matches original content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Can seed file to other clients</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>&quot;Invalid info hash&quot;</strong></td>\n<td>Wrong bytes used for SHA-1 calculation</td>\n<td>Compare raw info dict bytes with working client</td>\n<td>Use exact bencoded bytes, not re-encoded</td>\n</tr>\n<tr>\n<td><strong>&quot;Tracker returns error&quot;</strong></td>\n<td>Malformed announce request</td>\n<td>Check URL encoding of info hash and peer ID</td>\n<td>Properly URL-encode binary data</td>\n</tr>\n<tr>\n<td><strong>&quot;Peers reject handshake&quot;</strong></td>\n<td>Wrong protocol string or info hash</td>\n<td>Log handshake bytes, compare with specification</td>\n<td>Use exact 19-byte protocol string</td>\n</tr>\n<tr>\n<td><strong>&quot;Download stalls&quot;</strong></td>\n<td>Not sending interested/request messages</td>\n<td>Log peer message exchange</td>\n<td>Send interested after bitfield, request after unchoke</td>\n</tr>\n<tr>\n<td><strong>&quot;Piece verification fails&quot;</strong></td>\n<td>Wrong piece boundaries or corruption</td>\n<td>Compare piece hashes with torrent metadata</td>\n<td>Check piece length calculation and SHA-1 implementation</td>\n</tr>\n<tr>\n<td><strong>&quot;Connection timeouts&quot;</strong></td>\n<td>Network issues or wrong peer addresses</td>\n<td>Test peer connectivity with telnet/nc</td>\n<td>Implement connection timeouts and retry logic</td>\n</tr>\n</tbody></table>\n<p><strong>Common Implementation Mistakes:</strong></p>\n<p>⚠️ <strong>Pitfall: Re-encoding Info Dictionary</strong>\nMany learners calculate the info hash by parsing the info dictionary and then re-encoding it with their own bencode encoder. This fails because bencode allows multiple valid encodings of the same data (different key ordering, etc.). The info hash MUST be calculated from the exact original bytes.</p>\n<p>⚠️ <strong>Pitfall: String vs Binary Confusion</strong>\nBencode &quot;strings&quot; are actually binary data. Converting them to Go strings can corrupt binary data like piece hashes or compact peer lists. Always work with <code>[]byte</code> slices until you specifically need text representation.</p>\n<p>⚠️ <strong>Pitfall: Blocking on Choked Peers</strong>\nNew implementations often send piece requests immediately after handshake, but peers start in the &quot;choked&quot; state. You must wait for an &quot;unchoke&quot; message before sending requests, or the peer will ignore your requests and potentially disconnect.</p>\n<p>This comprehensive scope definition and implementation guidance provides the foundation for building a complete BitTorrent client while maintaining focus on the essential concepts that make BitTorrent work.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the architectural foundation for all milestones (1-4) by defining the core components and their interactions that will be built incrementally throughout the project.</p>\n</blockquote>\n<p>Building a BitTorrent client is like orchestrating a complex distributed system where multiple specialized components must work together seamlessly. Think of it as organizing a massive library project where you need a <strong>cataloger</strong> to understand what books you&#39;re looking for (torrent parsing), a <strong>directory service</strong> to find libraries that have those books (tracker communication), a <strong>librarian network</strong> to manage relationships with other libraries (peer management), and a <strong>book assembly team</strong> to piece together chapters from different sources while verifying they&#39;re authentic (piece management).</p>\n<p>The architecture follows a clear separation of concerns, where each component has a well-defined responsibility and communicates with others through clean interfaces. This modular design allows us to implement and test each component independently while maintaining the ability to coordinate complex multi-peer downloads. The key architectural insight is that BitTorrent&#39;s complexity lies not in any single protocol, but in the careful coordination between multiple concurrent processes that must share state and make decisions based on constantly changing network conditions.</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"BitTorrent Client Architecture\"></p>\n<h3 id=\"component-responsibilities\">Component Responsibilities</h3>\n<p>The BitTorrent client architecture consists of four major components, each with distinct responsibilities and well-defined interfaces. Understanding these boundaries is crucial because BitTorrent&#39;s distributed nature means that each component must handle its own failures gracefully while contributing to the overall system&#39;s resilience.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Key Interfaces</th>\n<th>External Dependencies</th>\n<th>State Managed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>TorrentParser</strong></td>\n<td>Decode <code>.torrent</code> files and extract metadata required for download coordination</td>\n<td><code>ParseFromFile(filepath) (*MetaInfo, error)</code>, <code>GetPieceHashes() [][20]byte</code>, <code>CalculateInfoHash([]byte) [20]byte</code></td>\n<td>File system for reading torrent files</td>\n<td>Parsed torrent metadata, info hash, piece information</td>\n</tr>\n<tr>\n<td><strong>TrackerClient</strong></td>\n<td>Communicate with tracker servers to discover peers and report download progress</td>\n<td><code>Announce(*AnnounceRequest) (*AnnounceResponse, error)</code>, <code>BuildAnnounceURL(announceURL) string</code>, <code>ParseCompactPeers([]byte) []PeerInfo</code></td>\n<td>HTTP client for tracker communication</td>\n<td>Peer list, announce intervals, upload/download statistics</td>\n</tr>\n<tr>\n<td><strong>PeerManager</strong></td>\n<td>Manage connections to multiple peers and implement the BitTorrent wire protocol</td>\n<td><code>ConnectToPeer(PeerInfo) (*Connection, error)</code>, <code>SendHandshake(*Connection) error</code>, <code>ReceiveMessage(*Connection) (Message, error)</code></td>\n<td>TCP networking, peer connections</td>\n<td>Connection states, message queues, peer capabilities</td>\n</tr>\n<tr>\n<td><strong>PieceManager</strong></td>\n<td>Coordinate piece downloads, verify content integrity, and schedule requests across peers</td>\n<td><code>RequestPiece(pieceIndex int) error</code>, <code>VerifyPiece(pieceIndex int, data []byte) bool</code>, <code>GetNextPiece() (int, error)</code>, <code>AssembleFile(outputPath string) error</code></td>\n<td>File system for writing completed pieces</td>\n<td>Piece availability, download progress, verification status</td>\n</tr>\n</tbody></table>\n<p>The <strong>TorrentParser</strong> serves as the system&#39;s entry point, transforming human-readable torrent files into the structured metadata that drives all subsequent operations. Its most critical responsibility is computing the <strong>info hash</strong> correctly, as this 20-byte identifier serves as the unique key that connects all other components. The parser must handle the intricacies of Bencode format while maintaining exact byte-for-byte fidelity when calculating the SHA-1 hash of the info dictionary.</p>\n<p>The <strong>TrackerClient</strong> acts as the system&#39;s directory service, maintaining the bridge between our client and the centralized coordination provided by tracker servers. It translates our internal state into the HTTP-based tracker protocol and decodes the compact peer format that trackers use to efficiently transmit lists of available peers. This component must handle tracker failures gracefully and implement proper re-announce scheduling to maintain our presence in the swarm.</p>\n<blockquote>\n<p><strong>Key Architectural Insight:</strong> The separation between TrackerClient and PeerManager reflects BitTorrent&#39;s hybrid design—centralized peer discovery with decentralized data transfer. This separation allows us to implement different tracker types (HTTP, UDP) without affecting peer communication logic.</p>\n</blockquote>\n<p>The <strong>PeerManager</strong> implements the complex state machines required by the BitTorrent wire protocol. Each peer connection maintains independent state for choking, interest, and message queues, but the PeerManager coordinates these connections to maximize overall throughput. It must handle connection failures, implement proper handshaking, and manage the flow control mechanisms that prevent any single peer from overwhelming the client.</p>\n<p>The <strong>PieceManager</strong> orchestrates the actual file reconstruction process, making decisions about which pieces to request from which peers based on availability and rarity. This component embodies the BitTorrent protocol&#39;s clever incentive mechanisms—by preferring rare pieces, it ensures that the entire swarm maintains good piece distribution. The PieceManager also handles the critical content verification step, rejecting corrupted data and coordinating retries when hash verification fails.</p>\n<h3 id=\"recommended-module-structure\">Recommended Module Structure</h3>\n<p>The Go implementation benefits from a clean module structure that mirrors the architectural boundaries while providing clear import paths and testability. The structure follows Go conventions for internal packages while maintaining the flexibility to expose public APIs as the client evolves.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>bittorrent-client/\n├── cmd/\n│   └── bittorrent/\n│       └── main.go                    ← CLI entry point, orchestrates all components\n├── internal/\n│   ├── torrent/\n│   │   ├── parser.go                  ← MetaInfo struct, ParseFromFile implementation\n│   │   ├── bencode.go                 ← Bencode decoder with all four type handlers\n│   │   ├── metadata.go                ← Info, File structs and hash calculations  \n│   │   └── parser_test.go             ← Unit tests for parsing logic\n│   ├── tracker/\n│   │   ├── client.go                  ← TrackerClient struct, HTTP announce logic\n│   │   ├── protocol.go                ← AnnounceRequest/Response structs\n│   │   ├── peers.go                   ← Compact peer parsing, PeerInfo struct\n│   │   └── client_test.go             ← Mock tracker tests\n│   ├── peer/\n│   │   ├── manager.go                 ← PeerManager coordination logic\n│   │   ├── connection.go              ← Individual peer connection state machine\n│   │   ├── protocol.go                ← Wire protocol message structs\n│   │   ├── handshake.go               ← Handshake implementation\n│   │   └── manager_test.go            ← Peer protocol tests\n│   ├── piece/\n│   │   ├── manager.go                 ← PieceManager with selection algorithms\n│   │   ├── scheduler.go               ← Rarest-first and endgame logic\n│   │   ├── verifier.go                ← SHA-1 verification and retry logic\n│   │   ├── assembler.go               ← File reconstruction from pieces\n│   │   └── manager_test.go            ← Piece management tests\n│   └── client/\n│       ├── client.go                  ← Main Client struct coordinating all components\n│       ├── download.go                ← Download orchestration logic\n│       └── client_test.go             ← Integration tests\n├── pkg/                               ← Public APIs (if building a library)\n│   └── bittorrent/\n│       └── client.go                  ← Public client interface\n├── testdata/                          ← Sample torrent files for testing\n│   ├── sample.torrent\n│   └── multi-file.torrent\n├── go.mod                             ← Go module definition\n└── README.md                          ← Usage instructions and examples</code></pre></div>\n\n<blockquote>\n<p><strong>Decision: Internal Package Structure</strong></p>\n<ul>\n<li><strong>Context</strong>: Go&#39;s <code>internal/</code> package convention prevents external imports while allowing clean separation of concerns</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Flat structure with all components in root package</li>\n<li>Public packages exposing all internals</li>\n<li>Internal packages with selective public API exposure</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use <code>internal/</code> packages with a small public API surface</li>\n<li><strong>Rationale</strong>: This approach provides implementation flexibility while preventing external code from depending on internal details that may change as we optimize the BitTorrent implementation</li>\n<li><strong>Consequences</strong>: Forces us to design clean interfaces between components and makes testing more systematic, but requires more careful API design for any public library usage</li>\n</ul>\n</blockquote>\n<p>The <strong>cmd/bittorrent/</strong> directory contains the command-line interface that demonstrates how all components work together. This separation allows the core BitTorrent logic to be testable independently of CLI argument parsing and user interaction. The main.go file serves as the integration point where we instantiate all components and coordinate their interactions.</p>\n<p>Each <strong>internal/</strong> package corresponds directly to one of our architectural components, with clear responsibility boundaries. The separation between <code>connection.go</code> and <code>manager.go</code> in the peer package reflects the difference between managing individual peer state machines versus coordinating across multiple peers. Similarly, the piece package separates the scheduling algorithms (<code>scheduler.go</code>) from the verification logic (<code>verifier.go</code>) because these concerns have different testing requirements and failure modes.</p>\n<p>The <strong>testdata/</strong> directory provides sample torrent files that enable integration testing without requiring network access. These files should include various scenarios: single-file torrents, multi-file torrents, and edge cases like very small piece sizes or unusual announce URLs.</p>\n<h3 id=\"high-level-data-flow\">High-Level Data Flow</h3>\n<p>Understanding how data flows through the BitTorrent client helps clarify the relationships between components and identifies the critical paths where errors can propagate. The data flow follows a clear pipeline from static torrent metadata through dynamic network coordination to final file reconstruction.</p>\n<p>The complete data flow can be visualized as four distinct phases, each dominated by a different component but requiring coordination with others:</p>\n<p><strong>Phase 1: Metadata Extraction</strong> - The TorrentParser reads the <code>.torrent</code> file from disk and transforms it through several representations. Raw bytes become Bencode tokens, which become structured dictionaries, which finally become strongly-typed <code>MetaInfo</code> and <code>Info</code> structs. The critical output is the info hash, computed from the exact bencoded bytes of the info dictionary, which becomes the unique identifier used by all subsequent phases.</p>\n<table>\n<thead>\n<tr>\n<th>Data Transform</th>\n<th>Input Format</th>\n<th>Output Format</th>\n<th>Key Operations</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File → Bencode</td>\n<td>Raw bytes from disk</td>\n<td>Bencode token stream</td>\n<td><code>NewDecoder()</code>, <code>Decode()</code></td>\n<td>File not found, invalid Bencode syntax</td>\n</tr>\n<tr>\n<td>Bencode → Structs</td>\n<td>Decoded dictionaries/lists</td>\n<td><code>MetaInfo</code>, <code>Info</code> structs</td>\n<td>Field extraction, type conversion</td>\n<td>Missing required fields, wrong types</td>\n</tr>\n<tr>\n<td>Info → Hash</td>\n<td>Bencoded info dictionary</td>\n<td>20-byte SHA-1 hash</td>\n<td><code>CalculateInfoHash()</code></td>\n<td>None (SHA-1 is deterministic)</td>\n</tr>\n<tr>\n<td>Pieces → Hashes</td>\n<td>Concatenated piece hashes</td>\n<td>Array of <code>[20]byte</code></td>\n<td><code>GetPieceHashes()</code></td>\n<td>Invalid piece string length</td>\n</tr>\n</tbody></table>\n<p><strong>Phase 2: Peer Discovery</strong> - The TrackerClient uses the info hash and file metadata to construct announce requests that discover other clients in the swarm. The tracker responds with a compact list of peer IP addresses and ports, along with timing information that controls how frequently we should re-announce our presence. This phase transforms our isolated client into a participant in the distributed swarm.</p>\n<table>\n<thead>\n<tr>\n<th>Data Transform</th>\n<th>Input Format</th>\n<th>Output Format</th>\n<th>Key Operations</th>\n<th>Coordination Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MetaInfo → Request</td>\n<td>Torrent metadata</td>\n<td>HTTP GET URL</td>\n<td><code>BuildAnnounceURL()</code></td>\n<td>None (pure transformation)</td>\n</tr>\n<tr>\n<td>Request → Response</td>\n<td>HTTP request</td>\n<td>Bencode response</td>\n<td>HTTP client, response parsing</td>\n<td>Network I/O, tracker availability</td>\n</tr>\n<tr>\n<td>Response → Peers</td>\n<td>Compact peer data</td>\n<td><code>[]PeerInfo</code> structs</td>\n<td><code>ParseCompactPeers()</code></td>\n<td>None (parsing is deterministic)</td>\n</tr>\n<tr>\n<td>Progress → Stats</td>\n<td>Download state</td>\n<td>Updated request params</td>\n<td>Progress tracking</td>\n<td>Coordination with PieceManager</td>\n</tr>\n</tbody></table>\n<p><strong>Phase 3: Connection Establishment</strong> - The PeerManager takes the list of potential peers and establishes BitTorrent protocol connections with a subset of them. Each connection involves a handshake exchange that verifies both clients are working with the same torrent (via info hash comparison) and establishes the message framing that will be used for all subsequent communication. This phase transforms network addresses into active protocol connections.</p>\n<p>The peer connection process requires careful coordination between components because the PeerManager needs piece availability information from the PieceManager to make intelligent connection decisions, while the PieceManager needs peer capabilities from the PeerManager to schedule downloads effectively.</p>\n<table>\n<thead>\n<tr>\n<th>Connection Phase</th>\n<th>Data Input</th>\n<th>Data Output</th>\n<th>Component Interaction</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP Connect</td>\n<td>IP address, port</td>\n<td>TCP socket</td>\n<td>Network layer only</td>\n<td>Retry with exponential backoff</td>\n</tr>\n<tr>\n<td>Handshake</td>\n<td>Info hash, peer ID</td>\n<td>Verified connection</td>\n<td>Verify info hash matches</td>\n<td>Close connection on mismatch</td>\n</tr>\n<tr>\n<td>Bitfield Exchange</td>\n<td>Local piece state</td>\n<td>Peer piece availability</td>\n<td>Share with PieceManager</td>\n<td>Assume peer has no pieces</td>\n</tr>\n<tr>\n<td>Message Loop</td>\n<td>Protocol messages</td>\n<td>Updated peer state</td>\n<td>Continuous PeerManager coordination</td>\n<td>Connection cleanup and retry</td>\n</tr>\n</tbody></table>\n<p><strong>Phase 4: Content Transfer</strong> - The PieceManager coordinates the actual download process by deciding which pieces to request from which peers, verifying the integrity of downloaded data, and assembling verified pieces into the final file. This phase involves complex scheduling decisions that balance piece rarity, peer performance, and download completion objectives.</p>\n<p>The content transfer phase represents the most complex data flow because it involves continuous bidirectional communication between all components. The PieceManager must track piece availability across all connected peers, make scheduling decisions that optimize for swarm health, and coordinate with the PeerManager to send block requests to appropriate connections.</p>\n<blockquote>\n<p><strong>Critical Data Flow Insight:</strong> The info hash serves as the system&#39;s primary key, flowing from TorrentParser through TrackerClient to PeerManager as the identifier that ensures all components are coordinating around the same file. Any corruption of this 20-byte value will cause complete system failure.</p>\n</blockquote>\n<p><strong>Inter-Phase Coordination Points:</strong></p>\n<ol>\n<li><strong>Parser → Tracker</strong>: <code>MetaInfo</code> structure provides announce URL, info hash, and file size needed for tracker communication</li>\n<li><strong>Tracker → Peer</strong>: <code>[]PeerInfo</code> list drives connection establishment, but PeerManager may connect to subset based on configured limits</li>\n<li><strong>Peer → Piece</strong>: Bitfield messages from successful handshakes inform piece availability, enabling intelligent scheduling decisions</li>\n<li><strong>Piece → Tracker</strong>: Download progress (bytes downloaded, uploaded, remaining) flows back to tracker for announce updates</li>\n<li><strong>Piece → Peer</strong>: Block requests and piece completion notifications create continuous bidirectional communication</li>\n</ol>\n<p>The data flow design ensures that each component can operate with appropriate autonomy while maintaining the coordination necessary for efficient downloads. Error conditions in any phase can be isolated and handled without bringing down the entire system, though certain failures (like tracker unavailability) may significantly impact performance.</p>\n<blockquote>\n<p><strong>Decision: Unidirectional Data Flow with Coordination Channels</strong></p>\n<ul>\n<li><strong>Context</strong>: BitTorrent requires complex coordination between components that operate at different time scales (parsing is one-time, tracker announces are periodic, peer connections are persistent, piece transfers are continuous)</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Shared mutable state with locks for coordination</li>\n<li>Message-passing architecture with channels</li>\n<li>Unidirectional flow with explicit coordination points</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Unidirectional primary data flow with well-defined coordination interfaces</li>\n<li><strong>Rationale</strong>: This provides the predictability of functional programming (data flows one direction) while accommodating the necessary coordination through clean interfaces rather than shared mutable state</li>\n<li><strong>Consequences</strong>: Each component can be tested independently, but we must carefully design the coordination interfaces to avoid deadlocks or race conditions</li>\n</ul>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Building the high-level architecture requires careful attention to Go-specific patterns and project organization. The following guidance provides the infrastructure and project structure needed to implement the component-based design effectively.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommended for Learning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Client</td>\n<td><code>net/http</code> standard library</td>\n<td>Custom HTTP client with connection pooling</td>\n<td><code>net/http</code> (focus on BitTorrent, not HTTP optimization)</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td><code>sync.Mutex</code> + goroutines</td>\n<td><code>sync.RWMutex</code> + worker pools</td>\n<td>Start with <code>sync.Mutex</code>, add <code>RWMutex</code> for piece availability</td>\n</tr>\n<tr>\n<td>Networking</td>\n<td><code>net.Conn</code> with manual framing</td>\n<td><code>bufio.Reader/Writer</code> wrappers</td>\n<td><code>bufio</code> for message parsing (handles partial reads)</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td><code>log</code> standard library</td>\n<td>Structured logging (logrus/zap)</td>\n<td><code>log</code> initially, upgrade to structured when debugging</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td><code>testing</code> standard library</td>\n<td><code>testify</code> for assertions</td>\n<td><code>testing</code> (learn Go idioms first)</td>\n</tr>\n</tbody></table>\n<p><strong>Complete Infrastructure Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/client/client.go - Main coordination structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> client</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bittorrent-client/internal/torrent</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bittorrent-client/internal/tracker</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bittorrent-client/internal/peer</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bittorrent-client/internal/piece</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Client coordinates all BitTorrent operations for a single torrent download</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Client</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metaInfo        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trackerClient   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tracker</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerManager     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">peer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieceManager    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">piece</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Coordination channels</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerUpdates     </span><span style=\"color:#F97583\">chan</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">tracker</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PeerInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    progressUpdates </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> piece</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ProgressUpdate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Synchronization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu              </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx             </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel          </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewClient creates a BitTorrent client for the given torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">metaInfo</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metaInfo:        metaInfo,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        trackerClient:   tracker.</span><span style=\"color:#B392F0\">NewClient</span><span style=\"color:#E1E4E8\">(metaInfo.Announce, metaInfo.InfoHash),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peerManager:     peer.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">(metaInfo.InfoHash),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pieceManager:    piece.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">(metaInfo.Info),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peerUpdates:     </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">tracker</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PeerInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        progressUpdates: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> piece</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ProgressUpdate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ctx:             ctx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cancel:          cancel,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Download orchestrates the complete download process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Download</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">outputPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start tracker announce loop in separate goroutine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start peer connection management in separate goroutine  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start piece download coordination in separate goroutine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for download completion or context cancellation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Clean up all goroutines and connections</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close stops all operations and cleans up resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.</span><span style=\"color:#B392F0\">cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Close all connections and wait for goroutines to finish</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/client/coordination.go - Inter-component coordination helpers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> client</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bittorrent-client/internal/tracker</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bittorrent-client/internal/piece</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// startTrackerAnnounces manages periodic communication with tracker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">startTrackerAnnounces</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initial announce to get peer list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second) </span><span style=\"color:#6A737D\">// Default interval</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">c.ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Get current progress from PieceManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Build announce request with current stats</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Send announce to tracker</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Parse response and send peers to peerUpdates channel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Update ticker interval based on tracker response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// startPeerManagement handles peer connections and message processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">startPeerManagement</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">c.ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> newPeers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">c.peerUpdates:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Connect to new peers (up to MAX_PEERS limit)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Start message processing for each connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Handle peer disconnections and errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// startPieceCoordination manages piece requests and assembly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">startPieceCoordination</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">c.ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> progress </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">c.progressUpdates:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Update piece availability based on peer bitfields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Select next pieces using rarest-first algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Send block requests to appropriate peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Verify completed pieces and retry on hash failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Assemble verified pieces into output file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Component Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/torrent/parser.go - Core torrent parsing logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetaInfo represents parsed torrent file metadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetaInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Announce     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreationDate </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Comment      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Info         </span><span style=\"color:#B392F0\">Info</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Info represents the info dictionary from torrent file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Info</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length      </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceLength </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pieces      []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Files       []</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// File represents individual file in multi-file torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> File</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path   []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseFromFile reads and parses a torrent file from disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseFromFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filepath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Open file and read all bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create bencode decoder from file data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Decode top-level dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Extract announce URL and optional fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Extract info dictionary and calculate hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Parse file information from info dict</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetPieceHashes extracts individual piece hashes from concatenated pieces field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetPieceHashes</span><span style=\"color:#E1E4E8\">() [][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify pieces length is multiple of 20</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Split pieces into 20-byte chunks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Convert each chunk to [20]byte array</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateInfoHash computes SHA1 hash of bencoded info dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CalculateInfoHash</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bencoded</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sha1.</span><span style=\"color:#B392F0\">Sum</span><span style=\"color:#E1E4E8\">(bencoded)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File Structure Setup Script:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># setup-project.sh - Creates the complete project structure</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> bittorrent-client/{cmd/bittorrent,internal/{torrent,tracker,peer,piece,client},pkg/bittorrent,testdata}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create go.mod</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> bittorrent-client/go.mod</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> 'EOF'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">module bittorrent-client</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">go 1.21</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">require (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    // Add dependencies as needed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create main.go entry point</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> bittorrent-client/cmd/bittorrent/main.go</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> 'EOF'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">package main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"flag\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"fmt\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"log\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"os\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"bittorrent-client/internal/torrent\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"bittorrent-client/internal/client\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">func main() {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    var (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        torrentFile = flag.String(\"torrent\", \"\", \"Path to .torrent file\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        output      = flag.String(\"output\", \"\", \"Output file path\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    )</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    flag.Parse()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    if *torrentFile == \"\" || *output == \"\" {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        fmt.Fprintf(os.Stderr, \"Usage: %s -torrent &#x3C;file> -output &#x3C;path>\\n\", os.Args[0])</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        os.Exit(1)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    // Parse torrent file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    metaInfo, err := torrent.ParseFromFile(*torrentFile)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    if err != nil {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        log.Fatalf(\"Failed to parse torrent: %v\", err)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    // Create and run client</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    client := client.NewClient(metaInfo)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    defer client.Close()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    if err := client.Download(*output); err != nil {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        log.Fatalf(\"Download failed: %v\", err)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    fmt.Printf(\"Download completed: %s\\n\", *output)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">EOF</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the high-level architecture:</p>\n<ol>\n<li><strong>Structure Verification</strong>: Run <code>find bittorrent-client -name &quot;*.go&quot; | head -10</code> - you should see the organized package structure</li>\n<li><strong>Compilation Check</strong>: Run <code>go build ./cmd/bittorrent</code> - should compile without errors (even with panic statements)</li>\n<li><strong>Import Verification</strong>: All internal packages should import cleanly without circular dependencies</li>\n<li><strong>Interface Validation</strong>: Each component should have clear interface methods defined (even if not implemented)</li>\n</ol>\n<p><strong>Common Architecture Pitfalls:</strong></p>\n<p>⚠️ <strong>Pitfall: Circular Import Dependencies</strong>\nCreating circular imports between packages (e.g., peer imports piece, piece imports peer) will prevent compilation. Solve this by defining shared interfaces in a common package or using dependency injection to break cycles.</p>\n<p>⚠️ <strong>Pitfall: Shared Mutable State Without Synchronization</strong> \nComponents accessing shared data structures without proper locking will cause race conditions. Use Go&#39;s race detector (<code>go run -race</code>) to detect these issues during development.</p>\n<p>⚠️ <strong>Pitfall: Blocking Operations in Coordination Channels</strong>\nSending to channels without proper buffering or goroutine management can deadlock the entire system. Always use <code>select</code> statements with context cancellation for coordination code.</p>\n<p><strong>Debugging Hints:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Import cycle errors</td>\n<td>Circular dependencies between packages</td>\n<td>Check import statements in each package</td>\n<td>Move shared interfaces to separate package</td>\n</tr>\n<tr>\n<td>Deadlocks during shutdown</td>\n<td>Goroutines waiting on channels that never close</td>\n<td>Add logging to goroutine lifecycles</td>\n<td>Implement proper context cancellation</td>\n</tr>\n<tr>\n<td>Race condition panics</td>\n<td>Shared data access without locks</td>\n<td>Run with <code>-race</code> flag</td>\n<td>Add mutex protection to shared state</td>\n</tr>\n<tr>\n<td>Memory leaks</td>\n<td>Goroutines not terminating</td>\n<td>Use <code>go tool pprof</code> to check goroutine count</td>\n<td>Ensure all goroutines respect context cancellation</td>\n</tr>\n</tbody></table>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the foundational data structures that will be built across all milestones: torrent metadata parsing (Milestone 1), tracker communication (Milestone 2), peer protocol (Milestone 3), and piece management (Milestone 4).</p>\n</blockquote>\n<p>Building a BitTorrent client requires carefully designed data structures that capture the complex relationships between torrent files, peer connections, piece downloads, and protocol messages. Think of the data model as the <strong>blueprint for a complex construction project</strong> - just as architects must specify every beam, joint, and connection before builders can construct a skyscraper, we must define every struct, field, and relationship before implementing the BitTorrent protocol. Each data structure serves as a contract between different components of our system, ensuring they can communicate effectively and maintain consistent state.</p>\n<p>The BitTorrent data model spans four distinct domains: <strong>torrent metadata</strong> (what files we&#39;re sharing and how they&#39;re structured), <strong>peer state</strong> (who we&#39;re connected to and what they can provide), <strong>piece management</strong> (tracking download progress and verification), and <strong>protocol messages</strong> (the language peers use to communicate). These domains interact in sophisticated ways - torrent metadata defines the pieces we need, peer state determines who can provide them, piece management coordinates the downloads, and protocol messages facilitate the actual data transfer.</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fdata-model.svg\" alt=\"Core Data Structures\"></p>\n<h3 id=\"torrent-metadata-structures\">Torrent Metadata Structures</h3>\n<p>The torrent metadata structures represent the parsed contents of a <code>.torrent</code> file, which serves as the <strong>recipe for reconstructing a file or collection of files</strong> from pieces distributed across the peer-to-peer network. Think of torrent metadata as a <strong>detailed recipe book</strong> - it tells you what ingredients you need (the pieces), how much of each ingredient (piece lengths and hashes), where to find suppliers (tracker URLs), and how to verify you&#39;ve got the right ingredients (SHA-1 hashes for verification). This metadata is the authoritative source of truth for everything about a torrent.</p>\n<blockquote>\n<p><strong>Decision: Hierarchical Metadata Structure</strong></p>\n<ul>\n<li><strong>Context</strong>: Torrent files contain nested information - global metadata (announce URL, creation date) and file-specific information (name, length, pieces). We need to decide how to structure this data in memory.</li>\n<li><strong>Options Considered</strong>: Flat structure with all fields at one level, hierarchical structure matching the original Bencode format, separate structures for single vs multi-file torrents</li>\n<li><strong>Decision</strong>: Hierarchical structure with <code>MetaInfo</code> containing global metadata and an <code>Info</code> struct containing file-specific data</li>\n<li><strong>Rationale</strong>: Mirrors the original Bencode structure, makes info hash calculation straightforward (we hash just the <code>Info</code> portion), and provides clear separation between tracker-related metadata and content-related metadata</li>\n<li><strong>Consequences</strong>: Requires two-level access for file information but makes the protocol implementation cleaner and more maintainable</li>\n</ul>\n</blockquote>\n<p>The <code>MetaInfo</code> structure represents the top-level torrent file contents and serves as the entry point for all torrent operations. Every BitTorrent client begins by parsing a torrent file into this structure, which then drives all subsequent operations from tracker communication to piece verification.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Announce</code></td>\n<td><code>string</code></td>\n<td>Primary tracker URL where peers can be found for this torrent</td>\n</tr>\n<tr>\n<td><code>CreationDate</code></td>\n<td><code>time.Time</code></td>\n<td>When this torrent was created (optional field from torrent file)</td>\n</tr>\n<tr>\n<td><code>Comment</code></td>\n<td><code>string</code></td>\n<td>Human-readable description of the torrent contents (optional field)</td>\n</tr>\n<tr>\n<td><code>InfoHash</code></td>\n<td><code>[20]byte</code></td>\n<td>SHA-1 hash of the bencoded info dictionary - the unique identifier for this torrent</td>\n</tr>\n<tr>\n<td><code>Info</code></td>\n<td><code>Info</code></td>\n<td>The info dictionary containing file structure and piece information</td>\n</tr>\n</tbody></table>\n<p>The <code>InfoHash</code> field deserves special attention as it serves as the <strong>unique fingerprint</strong> for the entire torrent. This 20-byte SHA-1 hash is computed from the exact bencoded bytes of the info dictionary and is used everywhere in the BitTorrent protocol - tracker announces include it to identify which torrent they&#39;re interested in, peer handshakes include it to verify both peers are talking about the same torrent, and DHT lookups use it as the key. The info hash must be calculated from the original bencoded bytes, not from a re-encoding of the parsed data structure, because even tiny differences in encoding would produce different hashes.</p>\n<p>The <code>Info</code> structure contains the core file and piece information that defines what we&#39;re actually downloading. This structure is hashed to produce the info hash, so its contents are immutable once a torrent is created.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Suggested name for the file or top-level directory when saving</td>\n</tr>\n<tr>\n<td><code>Length</code></td>\n<td><code>int64</code></td>\n<td>Total length in bytes for single-file torrents (zero for multi-file)</td>\n</tr>\n<tr>\n<td><code>PieceLength</code></td>\n<td><code>int64</code></td>\n<td>Size in bytes of each piece (typically 256KB, 512KB, or 1MB)</td>\n</tr>\n<tr>\n<td><code>Pieces</code></td>\n<td><code>[]byte</code></td>\n<td>Concatenated SHA-1 hashes of all pieces (20 bytes per piece)</td>\n</tr>\n<tr>\n<td><code>Files</code></td>\n<td><code>[]File</code></td>\n<td>List of files in multi-file torrents (empty for single-file)</td>\n</tr>\n</tbody></table>\n<p>The <code>Pieces</code> field requires careful handling as it contains concatenated 20-byte SHA-1 hashes rather than a slice of individual hashes. For a torrent with 1000 pieces, this field contains exactly 20,000 bytes. The <code>GetPieceHashes()</code> method extracts individual hashes from this concatenated format, providing a more convenient interface for piece verification operations.</p>\n<blockquote>\n<p><strong>Critical Design Insight</strong>: The <code>Length</code> and <code>Files</code> fields are mutually exclusive - single-file torrents use <code>Length</code> and leave <code>Files</code> empty, while multi-file torrents populate <code>Files</code> and set <code>Length</code> to zero. This design follows the original BitTorrent specification and avoids redundant data storage.</p>\n</blockquote>\n<p>For multi-file torrents, the <code>File</code> structure describes each individual file within the torrent. Multi-file torrents are conceptually <strong>flat streams of bytes</strong> that happen to be logically divided into files, similar to a ZIP archive that preserves directory structure.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Length</code></td>\n<td><code>int64</code></td>\n<td>Size of this specific file in bytes</td>\n</tr>\n<tr>\n<td><code>Path</code></td>\n<td><code>[]string</code></td>\n<td>Directory path components leading to this file (e.g., [&quot;docs&quot;, &quot;readme.txt&quot;])</td>\n</tr>\n</tbody></table>\n<p>The <code>Path</code> field uses a slice of strings rather than a single path string to avoid platform-specific path separator issues. When writing files to disk, the client joins these components using the operating system&#39;s appropriate path separator.</p>\n<h3 id=\"peer-and-connection-state\">Peer and Connection State</h3>\n<p>Peer and connection state structures manage the complex relationships and state machines involved in BitTorrent peer communication. Think of peer state management as <strong>managing relationships in a complex social network</strong> - you need to track who you know (discovered peers), who you&#39;re actively talking to (connected peers), what each person is interested in (piece availability), and the current status of each relationship (choking and interested states). Each peer connection is essentially an independent state machine that must be carefully coordinated with piece management and download strategies.</p>\n<blockquote>\n<p><strong>Decision: Separation of Peer Discovery and Connection State</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to distinguish between peers we&#39;ve discovered (from tracker or DHT) and peers we&#39;re actively connected to. These have different data requirements and lifecycles.</li>\n<li><strong>Options Considered</strong>: Single structure for both discovered and connected peers, separate structures for each state, connection state as extension of peer info</li>\n<li><strong>Decision</strong>: Separate <code>PeerInfo</code> for discovered peers and <code>Connection</code> for active connections</li>\n<li><strong>Rationale</strong>: Discovered peers only need IP/port information, while active connections need message queues, state machines, and buffers. Separation keeps memory usage reasonable and makes state transitions clear.</li>\n<li><strong>Consequences</strong>: Requires mapping between peer info and connections, but provides cleaner abstraction and better resource management</li>\n</ul>\n</blockquote>\n<p>The <code>PeerInfo</code> structure represents a peer discovered through tracker announces or DHT lookups. This is the minimal information needed to attempt a connection to a peer.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>IP</code></td>\n<td><code>[4]byte</code></td>\n<td>IPv4 address of the peer (big-endian byte order)</td>\n</tr>\n<tr>\n<td><code>Port</code></td>\n<td><code>uint16</code></td>\n<td>TCP port number where peer accepts BitTorrent connections</td>\n</tr>\n</tbody></table>\n<p>The compact peer format used by trackers packs this information into exactly 6 bytes per peer - 4 bytes for the IPv4 address followed by 2 bytes for the port in network byte order. The <code>ParseCompactPeers()</code> function converts this packed format into <code>PeerInfo</code> structures for easier handling.</p>\n<p>Active peer connections require significantly more state tracking than simple peer discovery. Each connection maintains multiple pieces of state: the TCP connection itself, protocol state (handshake completion, supported extensions), choking state (four-flag state machine), piece availability (bitfield of what pieces the peer has), and request queues (outstanding block requests).</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Conn</code></td>\n<td><code>net.Conn</code></td>\n<td>Underlying TCP connection to the peer</td>\n</tr>\n<tr>\n<td><code>PeerID</code></td>\n<td><code>[20]byte</code></td>\n<td>Unique identifier for this peer (received during handshake)</td>\n</tr>\n<tr>\n<td><code>Bitfield</code></td>\n<td><code>[]byte</code></td>\n<td>Bitmap indicating which pieces this peer has available</td>\n</tr>\n<tr>\n<td><code>AmChoking</code></td>\n<td><code>bool</code></td>\n<td>Whether we are choking this peer (refusing to upload to them)</td>\n</tr>\n<tr>\n<td><code>AmInterested</code></td>\n<td><code>bool</code></td>\n<td>Whether we are interested in pieces this peer has</td>\n</tr>\n<tr>\n<td><code>PeerChoking</code></td>\n<td><code>bool</code></td>\n<td>Whether this peer is choking us (refusing to upload to us)</td>\n</tr>\n<tr>\n<td><code>PeerInterested</code></td>\n<td><code>bool</code></td>\n<td>Whether this peer is interested in pieces we have</td>\n</tr>\n<tr>\n<td><code>PendingRequests</code></td>\n<td><code>map[int]BlockRequest</code></td>\n<td>Outstanding block requests we&#39;ve sent to this peer</td>\n</tr>\n<tr>\n<td><code>RequestQueue</code></td>\n<td><code>chan BlockRequest</code></td>\n<td>Queue of block requests waiting to be sent</td>\n</tr>\n</tbody></table>\n<p>The four boolean flags (<code>AmChoking</code>, <code>AmInterested</code>, <code>PeerChoking</code>, <code>PeerInterested</code>) implement the core BitTorrent choking algorithm. This creates a state machine with 16 possible states, though only certain combinations are meaningful for data transfer.</p>\n<table>\n<thead>\n<tr>\n<th>Our State</th>\n<th>Peer State</th>\n<th>Can Download</th>\n<th>Can Upload</th>\n<th>Typical Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Interested, Unchoked</td>\n<td>Any</td>\n<td>Yes</td>\n<td>Varies</td>\n<td>Send piece requests</td>\n</tr>\n<tr>\n<td>Interested, Choked</td>\n<td>Any</td>\n<td>No</td>\n<td>Varies</td>\n<td>Wait for unchoke</td>\n</tr>\n<tr>\n<td>Not Interested</td>\n<td>Any</td>\n<td>No</td>\n<td>Varies</td>\n<td>Update interest when pieces change</td>\n</tr>\n<tr>\n<td>Any</td>\n<td>Interested, We Unchoke</td>\n<td>Varies</td>\n<td>Yes</td>\n<td>Send requested pieces</td>\n</tr>\n<tr>\n<td>Any</td>\n<td>Interested, We Choke</td>\n<td>Varies</td>\n<td>No</td>\n<td>Ignore piece requests</td>\n</tr>\n<tr>\n<td>Any</td>\n<td>Not Interested</td>\n<td>Varies</td>\n<td>No</td>\n<td>No upload activity</td>\n</tr>\n</tbody></table>\n<p>The <code>Bitfield</code> uses a compact bitmap representation where each bit indicates whether the peer has the corresponding piece. For a torrent with 1000 pieces, the bitfield requires 125 bytes (1000 bits rounded up to the nearest byte boundary). Bit manipulation operations check and set individual pieces within this bitmap.</p>\n<blockquote>\n<p><strong>Protocol Design Insight</strong>: The choking mechanism serves as BitTorrent&#39;s incentive system - peers upload to those who upload to them, creating a tit-for-tat relationship that encourages participation rather than freeloading. New peers get optimistic unchokes to bootstrap the relationship.</p>\n</blockquote>\n<h3 id=\"piece-and-block-management\">Piece and Block Management</h3>\n<p>Piece and block management structures coordinate the complex process of downloading, verifying, and assembling pieces into complete files. Think of piece management as <strong>coordinating a massive jigsaw puzzle</strong> where multiple people are working on different sections simultaneously, pieces must be verified before acceptance, and you need to track which pieces are rarest to prioritize them appropriately. The challenge is coordinating concurrent downloads while avoiding duplicate work and ensuring data integrity.</p>\n<p>Pieces and blocks represent different granularities of data transfer. A <strong>piece</strong> is the unit of verification (typically 256KB to 1MB) that can be independently hash-checked, while a <strong>block</strong> is the unit of network transfer (typically 16KB) that fits in a single protocol message. Each piece contains multiple blocks, and blocks must be requested individually from peers.</p>\n<blockquote>\n<p><strong>Decision: Separate Piece and Block Granularity</strong></p>\n<ul>\n<li><strong>Context</strong>: BitTorrent uses different sizes for verification (pieces) and network transfer (blocks). We need to decide how to model this relationship.</li>\n<li><strong>Options Considered</strong>: Single granularity using pieces only, single granularity using blocks only, separate piece and block concepts with mapping between them</li>\n<li><strong>Decision</strong>: Separate piece and block concepts with explicit mapping and state tracking</li>\n<li><strong>Rationale</strong>: Matches protocol design where pieces are verified independently but transferred as smaller blocks. Allows request pipelining and partial piece recovery if connections fail.</li>\n<li><strong>Consequences</strong>: More complex state management but better network efficiency and failure handling</li>\n</ul>\n</blockquote>\n<p>The <code>PieceState</code> structure tracks the download progress and verification status of a single piece. Each piece progresses through several states during download: not started, in progress (with some blocks downloaded), complete but unverified, verified and available, or failed verification.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Index</code></td>\n<td><code>int</code></td>\n<td>Zero-based index of this piece in the torrent</td>\n</tr>\n<tr>\n<td><code>Length</code></td>\n<td><code>int</code></td>\n<td>Total size of this piece in bytes (may be smaller for last piece)</td>\n</tr>\n<tr>\n<td><code>Hash</code></td>\n<td><code>[20]byte</code></td>\n<td>Expected SHA-1 hash for verification of complete piece</td>\n</tr>\n<tr>\n<td><code>Blocks</code></td>\n<td><code>map[int]*Block</code></td>\n<td>Map of block offset to block state within this piece</td>\n</tr>\n<tr>\n<td><code>State</code></td>\n<td><code>PieceStateEnum</code></td>\n<td>Current state: NotStarted, InProgress, Complete, Verified, Failed</td>\n</tr>\n<tr>\n<td><code>Priority</code></td>\n<td><code>int</code></td>\n<td>Download priority (higher numbers downloaded first)</td>\n</tr>\n<tr>\n<td><code>Availability</code></td>\n<td><code>int</code></td>\n<td>Number of connected peers that have this piece</td>\n</tr>\n</tbody></table>\n<p>The <code>Blocks</code> map uses byte offsets as keys, allowing efficient lookup of specific blocks within the piece. Block offsets are typically multiples of <code>BLOCK_SIZE</code> (16384 bytes), with the final block in each piece potentially being smaller.</p>\n<p>Individual blocks represent the smallest unit of data transfer and request management. Each block tracks its own download state and can be independently requested from different peers.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PieceIndex</code></td>\n<td><code>int</code></td>\n<td>Which piece this block belongs to</td>\n</tr>\n<tr>\n<td><code>Offset</code></td>\n<td><code>int</code></td>\n<td>Byte offset within the piece where this block starts</td>\n</tr>\n<tr>\n<td><code>Length</code></td>\n<td><code>int</code></td>\n<td>Size of this block in bytes (typically 16KB, smaller for last block)</td>\n</tr>\n<tr>\n<td><code>Data</code></td>\n<td><code>[]byte</code></td>\n<td>The actual downloaded data (nil until downloaded)</td>\n</tr>\n<tr>\n<td><code>State</code></td>\n<td><code>BlockStateEnum</code></td>\n<td>Current state: NotRequested, Requested, Downloaded</td>\n</tr>\n<tr>\n<td><code>RequestedFrom</code></td>\n<td><code>string</code></td>\n<td>Peer ID that we requested this block from (for timeout handling)</td>\n</tr>\n<tr>\n<td><code>RequestTime</code></td>\n<td><code>time.Time</code></td>\n<td>When we sent the request (for timeout detection)</td>\n</tr>\n</tbody></table>\n<p>Block state management requires careful coordination to avoid duplicate requests while ensuring failed requests are retried. The <code>RequestedFrom</code> and <code>RequestTime</code> fields enable timeout detection - if a block request isn&#39;t fulfilled within a reasonable time, it can be re-requested from a different peer.</p>\n<table>\n<thead>\n<tr>\n<th>Block State</th>\n<th>Next States</th>\n<th>Trigger</th>\n<th>Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NotRequested</td>\n<td>Requested</td>\n<td>Peer available and not choked</td>\n<td>Send request message</td>\n</tr>\n<tr>\n<td>Requested</td>\n<td>Downloaded</td>\n<td>Piece message received</td>\n<td>Store data, verify length</td>\n</tr>\n<tr>\n<td>Requested</td>\n<td>NotRequested</td>\n<td>Request timeout</td>\n<td>Mark for retry with different peer</td>\n</tr>\n<tr>\n<td>Downloaded</td>\n<td>NotRequested</td>\n<td>Piece verification failed</td>\n<td>Mark all blocks for re-download</td>\n</tr>\n</tbody></table>\n<p>The piece selection and scheduling system coordinates downloads across multiple peers to optimize performance. The <code>PieceManager</code> maintains global state about download progress and peer availability.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Pieces</code></td>\n<td><code>map[int]*PieceState</code></td>\n<td>State of all pieces in the torrent</td>\n</tr>\n<tr>\n<td><code>IncompletePieces</code></td>\n<td><code>[]int</code></td>\n<td>Pieces that are partially downloaded (for endgame mode)</td>\n</tr>\n<tr>\n<td><code>RequestQueue</code></td>\n<td><code>chan BlockRequest</code></td>\n<td>Global queue of blocks that need downloading</td>\n</tr>\n<tr>\n<td><code>CompletedPieces</code></td>\n<td><code>map[int]bool</code></td>\n<td>Quick lookup for pieces that are verified and complete</td>\n</tr>\n<tr>\n<td><code>TotalPieces</code></td>\n<td><code>int</code></td>\n<td>Total number of pieces in this torrent</td>\n</tr>\n<tr>\n<td><code>TotalLength</code></td>\n<td><code>int64</code></td>\n<td>Total size of all data in bytes</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Scheduling Strategy</strong>: The piece selection algorithm implements <strong>rarest-first scheduling</strong> - pieces held by fewer peers are downloaded first to improve overall swarm health. This prevents situations where common pieces are over-replicated while rare pieces risk being lost if their few holders disconnect.</p>\n</blockquote>\n<h3 id=\"protocol-message-formats\">Protocol Message Formats</h3>\n<p>Protocol message structures define the language that BitTorrent peers use to communicate. Think of these messages as <strong>vocabulary in a formal diplomatic protocol</strong> - each message type has a specific format, purpose, and expected response, and both sides must follow the protocol exactly or communication breaks down. The wire protocol uses binary encoding for efficiency, with each message having a specific structure that must be parsed and generated correctly.</p>\n<p>The BitTorrent peer wire protocol uses a simple message framing format: each message starts with a 4-byte length prefix (in big-endian byte order), followed by a 1-byte message ID, followed by the message payload. The handshake message is special and doesn&#39;t follow this framing format.</p>\n<blockquote>\n<p><strong>Decision: Structured Message Types with Union-Style Interface</strong></p>\n<ul>\n<li><strong>Context</strong>: BitTorrent messages have different payloads but share common framing. We need to decide how to represent this variety in a type-safe way.</li>\n<li><strong>Options Considered</strong>: Single message struct with optional fields, interface with concrete types for each message, raw byte handling with manual parsing</li>\n<li><strong>Decision</strong>: Interface-based design with concrete types for each message category</li>\n<li><strong>Rationale</strong>: Provides type safety, makes message handling explicit, and allows for easy extension with new message types</li>\n<li><strong>Consequences</strong>: Requires more types but provides better compile-time checking and clearer message handling logic</li>\n</ul>\n</blockquote>\n<p>The handshake message establishes a BitTorrent connection and verifies both peers are talking about the same torrent. This message has a fixed 68-byte format that differs from all other protocol messages.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Size</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ProtocolLength</code></td>\n<td><code>uint8</code></td>\n<td>1 byte</td>\n<td>Length of protocol string (always 19 for BitTorrent)</td>\n</tr>\n<tr>\n<td><code>Protocol</code></td>\n<td><code>string</code></td>\n<td>19 bytes</td>\n<td>Protocol identifier: &quot;BitTorrent protocol&quot;</td>\n</tr>\n<tr>\n<td><code>Reserved</code></td>\n<td><code>[8]byte</code></td>\n<td>8 bytes</td>\n<td>Reserved for extension flags (usually all zeros)</td>\n</tr>\n<tr>\n<td><code>InfoHash</code></td>\n<td><code>[20]byte</code></td>\n<td>20 bytes</td>\n<td>SHA-1 hash identifying the torrent</td>\n</tr>\n<tr>\n<td><code>PeerID</code></td>\n<td><code>[20]byte</code></td>\n<td>20 bytes</td>\n<td>Unique identifier for the sending peer</td>\n</tr>\n</tbody></table>\n<p>After the handshake, all messages follow the standard framing format. The message ID determines how to interpret the payload that follows.</p>\n<table>\n<thead>\n<tr>\n<th>Message ID</th>\n<th>Name</th>\n<th>Payload Size</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-1</td>\n<td>Keep-alive</td>\n<td>0 bytes</td>\n<td>Maintain connection when no other messages needed</td>\n</tr>\n<tr>\n<td>0</td>\n<td>Choke</td>\n<td>0 bytes</td>\n<td>Sender will not fulfill requests from receiver</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Unchoke</td>\n<td>0 bytes</td>\n<td>Sender will fulfill requests from receiver</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Interested</td>\n<td>0 bytes</td>\n<td>Sender wants to download from receiver</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Not interested</td>\n<td>0 bytes</td>\n<td>Sender doesn&#39;t want anything from receiver</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Have</td>\n<td>4 bytes</td>\n<td>Announces sender has completed a piece</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Bitfield</td>\n<td>Variable</td>\n<td>Announces which pieces sender has (sent after handshake)</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Request</td>\n<td>12 bytes</td>\n<td>Request a block of data from a piece</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Piece</td>\n<td>Variable</td>\n<td>Deliver requested block data</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Cancel</td>\n<td>12 bytes</td>\n<td>Cancel a previously sent request</td>\n</tr>\n</tbody></table>\n<p>The <code>Have</code> message announces when a peer completes downloading a piece. This allows other peers to update their availability calculations for piece selection.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PieceIndex</code></td>\n<td><code>uint32</code></td>\n<td>Zero-based index of the completed piece</td>\n</tr>\n</tbody></table>\n<p>The <code>Bitfield</code> message is sent immediately after handshake completion to announce which pieces the peer already has. This message uses the same compact bitmap format as the <code>Bitfield</code> field in connection state.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Bitfield</code></td>\n<td><code>[]byte</code></td>\n<td>Bitmap of available pieces (1 bit per piece)</td>\n</tr>\n</tbody></table>\n<p>The <code>Request</code> message asks a peer to send a specific block of data. BitTorrent clients typically pipeline multiple requests to keep the network connection busy.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PieceIndex</code></td>\n<td><code>uint32</code></td>\n<td>Which piece contains the desired block</td>\n</tr>\n<tr>\n<td><code>BlockOffset</code></td>\n<td><code>uint32</code></td>\n<td>Byte offset within the piece where block starts</td>\n</tr>\n<tr>\n<td><code>BlockLength</code></td>\n<td><code>uint32</code></td>\n<td>Size of the requested block (typically 16384 bytes)</td>\n</tr>\n</tbody></table>\n<p>The <code>Piece</code> message delivers requested block data. This is the core message that actually transfers file content between peers.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PieceIndex</code></td>\n<td><code>uint32</code></td>\n<td>Which piece this block belongs to</td>\n</tr>\n<tr>\n<td><code>BlockOffset</code></td>\n<td><code>uint32</code></td>\n<td>Byte offset within the piece</td>\n</tr>\n<tr>\n<td><code>BlockData</code></td>\n<td><code>[]byte</code></td>\n<td>The actual file data for this block</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Protocol Efficiency Note</strong>: Block requests are typically pipelined - clients send multiple request messages before receiving the first piece response. This keeps the network connection saturated and improves transfer speeds, but requires careful tracking of outstanding requests.</p>\n</blockquote>\n<p>The <code>Cancel</code> message allows clients to cancel previously sent requests, typically used in endgame mode when the same block is requested from multiple peers to avoid slow connections.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PieceIndex</code></td>\n<td><code>uint32</code></td>\n<td>Which piece contained the block to cancel</td>\n</tr>\n<tr>\n<td><code>BlockOffset</code></td>\n<td><code>uint32</code></td>\n<td>Byte offset of the block to cancel</td>\n</tr>\n<tr>\n<td><code>BlockLength</code></td>\n<td><code>uint32</code></td>\n<td>Size of the block to cancel</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Info Hash Calculation from Re-encoded Data</strong>\nMany developers make the mistake of calculating the info hash by re-encoding the parsed <code>Info</code> structure back to Bencode format. This fails because Bencode encoding is not canonical - the same data can be encoded in multiple ways (dictionary key ordering, integer representation). The info hash must be calculated from the original bytes of the info dictionary as it appeared in the torrent file. Store these original bytes during parsing or calculate the hash before parsing the info dictionary contents.</p>\n<p>⚠️ <strong>Pitfall: Bitfield Bit Ordering Confusion</strong>\nThe bitfield uses big-endian bit ordering within each byte, which can be confusing. The first piece (index 0) is represented by the most significant bit of the first byte. When checking if piece N is available, use <code>bitfield[N/8] &amp; (0x80 &gt;&gt; (N%8))</code> rather than assuming little-endian bit ordering. Test with a known bitfield pattern to verify your bit manipulation is correct.</p>\n<p>⚠️ <strong>Pitfall: Block Boundary Calculations</strong>\nThe last piece in a torrent is typically smaller than the standard piece length, and the last block in any piece may be smaller than the standard block size. Always calculate block and piece sizes dynamically rather than assuming they&#39;re all the same size. Use <code>min(BLOCK_SIZE, remaining_piece_bytes)</code> when calculating block lengths to handle these boundary conditions correctly.</p>\n<p>⚠️ <strong>Pitfall: Concurrent Access to Peer State</strong>\nPeer connections run in separate goroutines and can modify connection state concurrently with the main piece management logic. Protect all shared state (bitfields, pending requests, choking flags) with appropriate synchronization. Use separate mutexes for different aspects of peer state to avoid lock contention while ensuring consistency.</p>\n<p>⚠️ <strong>Pitfall: Message Length Validation</strong>\nAlways validate message lengths before parsing message payloads. A malicious or buggy peer could send a message claiming to be much larger than it actually is, leading to buffer overruns or excessive memory allocation. Check that declared message lengths match expected sizes for fixed-format messages, and impose reasonable limits on variable-length messages like bitfields and piece data.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The data model implementation requires careful attention to memory layout, serialization formats, and concurrent access patterns. Go&#39;s strong typing system helps prevent many common errors, but BitTorrent&#39;s binary protocols require explicit handling of byte ordering and bit manipulation.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serialization</td>\n<td>Manual byte manipulation with encoding/binary</td>\n<td>Protocol Buffers with custom wire format</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>sync.Mutex for each data structure</td>\n<td>sync.RWMutex with fine-grained locking</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Standard garbage collection</td>\n<td>sync.Pool for frequent allocations</td>\n</tr>\n<tr>\n<td>Bit Operations</td>\n<td>Standard bit shifting and masking</td>\n<td>Third-party bitset library</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The data model spans multiple packages to maintain clean separation of concerns and enable independent testing of each component.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  torrent/\n    metadata.go          ← MetaInfo, Info, File structures\n    metadata_test.go     ← Torrent parsing tests\n  peer/\n    connection.go        ← Connection state and peer management\n    connection_test.go   ← Peer state machine tests\n  piece/\n    manager.go          ← PieceState, Block, and scheduling logic\n    manager_test.go     ← Piece selection and verification tests\n  protocol/\n    messages.go         ← All protocol message types\n    messages_test.go    ← Message parsing and generation tests</code></pre></div>\n\n<h4 id=\"complete-infrastructure-code\">Complete Infrastructure Code</h4>\n<p>Here&#39;s the complete message framing infrastructure that handles the binary protocol details:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> protocol</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HANDSHAKE_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 68</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PROTOCOL_STRING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"BitTorrent protocol\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MessageFramer handles the binary framing of BitTorrent protocol messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageFramer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn </span><span style=\"color:#B392F0\">io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ReadWriter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMessageFramer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">conn</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ReadWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageFramer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MessageFramer</span><span style=\"color:#E1E4E8\">{conn: conn}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadMessage reads a complete framed message from the connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageFramer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadMessage</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">MessageID</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read 4-byte length prefix</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(mf.conn, binary.BigEndian, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">length)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read message length: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle keep-alive messages (length = 0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> KEEPALIVE, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read message ID (1 byte)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> messageID </span><span style=\"color:#F97583\">uint8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> binary.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(mf.conn, binary.BigEndian, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">messageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read message ID: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read remaining payload</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, length</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// -1 because we already read message ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">ReadFull</span><span style=\"color:#E1E4E8\">(mf.conn, payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read message payload: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> MessageID</span><span style=\"color:#E1E4E8\">(messageID), payload, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteMessage writes a framed message to the connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageFramer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">messageID</span><span style=\"color:#B392F0\"> MessageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate total length (message ID + payload)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(payload))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write length prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(mf.conn, binary.BigEndian, length)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write message length: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write message ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> binary.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(mf.conn, binary.BigEndian, </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#E1E4E8\">(messageID))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write message ID: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write payload</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mf.conn.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write message payload: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Complete bitfield manipulation utilities:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> peer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#B392F0\">math</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BitfieldOps provides utilities for manipulating piece availability bitfields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BitfieldOps</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitfield []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    numPieces </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBitfield</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">numPieces</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    byteCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(math.</span><span style=\"color:#B392F0\">Ceil</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(numPieces) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8.0</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bitfield: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, byteCount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        numPieces: numPieces,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetPiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> bf.numPieces {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    byteIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bf.bitfield[byteIndex] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#F97583\"> >></span><span style=\"color:#E1E4E8\"> bitOffset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HasPiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> bf.numPieces {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    byteIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (bf.bitfield[byteIndex] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#F97583\"> >></span><span style=\"color:#E1E4E8\"> bitOffset)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CountPieces</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> bf.numPieces; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> bf.</span><span style=\"color:#B392F0\">HasPiece</span><span style=\"color:#E1E4E8\">(i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ToBytes</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(bf.bitfield))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(result, bf.bitfield)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeletons\">Core Logic Skeletons</h4>\n<p>Here are the key data structure definitions with TODO comments for the core logic that learners should implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetaInfo represents the parsed contents of a .torrent file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetaInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Announce     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreationDate </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Comment      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Info         </span><span style=\"color:#B392F0\">Info</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateInfoHash computes the SHA-1 hash of the bencoded info dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mi </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CalculateInfoHash</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bencodedInfoDict</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Use crypto/sha1 to create a new hash instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Write the exact bencoded bytes to the hasher</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call Sum() to get the final 20-byte hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Convert the slice to a [20]byte array and return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: This must use the original bencoded bytes, not re-encoded data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Info represents the info dictionary from a torrent file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Info</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length      </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceLength </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pieces      []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Files       []</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetPieceHashes extracts individual 20-byte piece hashes from concatenated pieces field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">info </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetPieceHashes</span><span style=\"color:#E1E4E8\">() [][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate how many pieces there are (len(Pieces) / 20)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create a slice to hold the individual hashes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Loop through the Pieces field in 20-byte chunks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Copy each 20-byte chunk into a [20]byte array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Append each hash array to the result slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use copy() to convert []byte to [20]byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateTotalLength returns total bytes across all files (for multi-file torrents)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">info </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CalculateTotalLength</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If this is a single-file torrent (Length > 0), return Length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Otherwise, iterate through Files slice and sum all file lengths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the total calculated length</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> peer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Connection represents an active connection to a BitTorrent peer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Connection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn            </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Conn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerID          [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitfield        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amChoking       </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amInterested    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerChoking     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerInterested  </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pendingRequests </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BlockRequest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateInterest checks if we should be interested in this peer based on their pieces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateInterest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">neededPieces</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Lock the connection for reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if peer has any pieces we need (iterate through neededPieces)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If peer has needed pieces and we're not interested, send INTERESTED message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If peer has no needed pieces and we are interested, send NOT_INTERESTED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update the amInterested flag accordingly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Unlock the connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use bitfield.HasPiece() to check peer's available pieces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CanDownload returns true if we can request blocks from this peer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CanDownload</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Lock for reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if we're interested AND peer is not choking us</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Both conditions must be true for downloads to proceed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> piece</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manager coordinates piece downloads and verification across multiple peers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Manager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieces          </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    completedPieces </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inProgress      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalPieces     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieceLength     </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieceHashes     [][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SelectNextPiece implements rarest-first piece selection strategy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SelectNextPiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">peerBitfield</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Lock for reading to examine piece availability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Build a list of pieces we need that this peer has</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Count how many peers have each candidate piece (availability)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Sort candidates by availability (rarest first)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the rarest piece index, or -1 if no pieces needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Lower availability count = higher priority for download</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerifyPiece checks if a completed piece matches its expected hash</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">VerifyPiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get the expected hash for this piece from pieceHashes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate SHA-1 hash of the provided data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare calculated hash with expected hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If hashes match, mark piece as completed and return true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If hashes don't match, mark piece for re-download and return false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use bytes.Equal() to compare hash arrays</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li>Use <code>encoding/binary.BigEndian</code> for all network byte order conversions in protocol messages</li>\n<li>The <code>[20]byte</code> array type is not directly assignable from <code>[]byte</code> slices - use <code>copy()</code> for conversion</li>\n<li>Implement <code>String()</code> methods on your message types for better debugging output</li>\n<li>Use <code>sync.RWMutex</code> for data structures that are read frequently but written infrequently</li>\n<li>Consider using <code>context.Context</code> for cancellation in long-running download operations</li>\n<li>The <code>net.Conn</code> interface provides both reading and writing, but you may need to wrap it with <code>bufio.Reader</code> for efficient parsing</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing the data model structures, verify the following behavior:</p>\n<p><strong>Milestone 1 Checkpoint</strong>: Torrent metadata parsing works correctly</p>\n<ul>\n<li>Run <code>go test ./internal/torrent/...</code> - all bencode parsing tests should pass</li>\n<li>Parse a real .torrent file and verify the info hash matches other BitTorrent clients</li>\n<li>Check that <code>GetPieceHashes()</code> returns the correct number of 20-byte hashes</li>\n<li>Verify multi-file torrents correctly populate the <code>Files</code> slice</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint</strong>: Peer state management functions properly</p>\n<ul>\n<li>Run <code>go test ./internal/peer/...</code> - connection state tests should pass</li>\n<li>Create a bitfield, set some pieces, and verify <code>HasPiece()</code> returns correct results</li>\n<li>Test the four-flag state machine with various choking/interested combinations</li>\n<li>Verify that <code>CanDownload()</code> returns true only when interested and unchoked</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint</strong>: Protocol message handling works</p>\n<ul>\n<li>Run <code>go test ./internal/protocol/...</code> - message parsing tests should pass</li>\n<li>Create each message type and verify serialization round-trips correctly</li>\n<li>Test message framing with various payload sizes including zero-length messages</li>\n<li>Verify handshake message format matches the 68-byte specification exactly</li>\n</ul>\n<p><strong>Milestone 4 Checkpoint</strong>: Piece management coordinates correctly</p>\n<ul>\n<li>Run <code>go test ./internal/piece/...</code> - piece selection and verification tests should pass</li>\n<li>Test piece selection with various peer bitfield configurations</li>\n<li>Verify piece verification correctly accepts good hashes and rejects bad ones</li>\n<li>Check that completed pieces are properly tracked and not re-downloaded</li>\n</ul>\n<h2 id=\"torrent-file-parsing-milestone-1\">Torrent File Parsing (Milestone 1)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 1 - Torrent File Parsing, implementing Bencode decoding and torrent metadata extraction with proper info hash calculation.</p>\n</blockquote>\n<p>Torrent file parsing forms the foundation of any BitTorrent client. Before we can connect to trackers, discover peers, or download pieces, we must first understand what files we&#39;re trying to download and how they&#39;re organized. This milestone involves decoding the Bencode format used by BitTorrent and extracting critical metadata that drives the entire download process.</p>\n<p>The parsing process involves three fundamental challenges. First, we must decode the Bencode binary encoding format that stores all torrent metadata in a compact, language-agnostic form. Second, we need to extract specific fields from the decoded data structure to understand file organization, tracker locations, and piece verification data. Third, we must compute the info hash - a cryptographic identifier that uniquely identifies the torrent across the entire BitTorrent network.</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fdata-model.svg\" alt=\"Core Data Structures\"></p>\n<p>Understanding torrent file structure is essential because every subsequent operation in our BitTorrent client depends on this metadata. The announce URL tells us where to find other peers, the piece length and piece hashes enable us to verify downloaded data integrity, and the info hash serves as our torrent&#39;s unique fingerprint for tracker communication and peer handshakes.</p>\n<h3 id=\"bencode-binary-json-analogy\">Bencode: Binary JSON Analogy</h3>\n<p>Think of Bencode as JSON&#39;s binary cousin designed specifically for peer-to-peer applications. Just like JSON provides a structured way to represent nested data (objects, arrays, strings, numbers), Bencode offers the same organizational capabilities but with two key differences that make it perfect for BitTorrent.</p>\n<p>First, Bencode handles binary data natively. While JSON struggles with binary content and requires encoding schemes like Base64, Bencode treats byte strings as first-class citizens. This matters enormously in BitTorrent because piece hashes are raw 20-byte SHA-1 digests, peer IDs contain arbitrary binary data, and the protocol frequently exchanges binary payloads. Imagine trying to represent a piece hash like <code>\\x12\\x34\\x56...</code> in JSON - you&#39;d need encoding layers that add complexity and overhead.</p>\n<p>Second, Bencode produces completely deterministic output. Unlike JSON, where the same data structure can be serialized in multiple valid ways (different key ordering, varied whitespace), Bencode has exactly one canonical representation for any given data structure. This determinism is crucial for computing info hashes, since the SHA-1 digest must be calculated from the exact bytes of the serialized info dictionary.</p>\n<p>The mental model to internalize is this: <strong>Bencode is like JSON, but designed for systems that need binary data support and cryptographic hashing</strong>. Just as you might parse JSON to extract a web API response, we parse Bencode to extract torrent metadata. The same concepts apply - nested dictionaries become maps, arrays become lists, and values can be strings, numbers, or nested structures.</p>\n<p>Bencode supports exactly four data types, mirroring the essential types found in most structured data formats:</p>\n<table>\n<thead>\n<tr>\n<th>Bencode Type</th>\n<th>JSON Equivalent</th>\n<th>Format</th>\n<th>Example</th>\n<th>Use in Torrents</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Byte String</td>\n<td>String (but binary-safe)</td>\n<td><code>&lt;length&gt;:&lt;data&gt;</code></td>\n<td><code>4:spam</code></td>\n<td>File names, piece hashes, tracker URLs</td>\n</tr>\n<tr>\n<td>Integer</td>\n<td>Number</td>\n<td><code>i&lt;value&gt;e</code></td>\n<td><code>i42e</code></td>\n<td>File lengths, piece length, creation date</td>\n</tr>\n<tr>\n<td>List</td>\n<td>Array</td>\n<td><code>l&lt;items&gt;e</code></td>\n<td><code>l4:spam3:egge</code></td>\n<td>File lists, announce list</td>\n</tr>\n<tr>\n<td>Dictionary</td>\n<td>Object</td>\n<td><code>d&lt;key&gt;&lt;value&gt;e</code></td>\n<td><code>d3:cow3:moo4:spam4:eggse</code></td>\n<td>Root structure, info dict</td>\n</tr>\n</tbody></table>\n<p>The elegance of Bencode lies in its simplicity. There are no null values, no floating-point numbers, no boolean types - just the minimal set of types needed to represent structured data with binary content. This simplicity makes the parser straightforward to implement while ensuring compatibility across different programming languages and platforms.</p>\n<h3 id=\"bencode-decoder-design\">Bencode Decoder Design</h3>\n<p>The Bencode decoder uses a recursive descent parsing strategy, where each data type has a dedicated parsing method that handles its specific format. This approach mirrors how you might parse a mathematical expression by recognizing operators and recursively evaluating sub-expressions.</p>\n<p>The core insight is that Bencode is <strong>self-delimiting</strong> - each encoded value contains enough information to determine where it ends. Strings begin with their length, integers are wrapped with <code>i</code> and <code>e</code> markers, and container types (lists and dictionaries) use <code>l</code>/<code>d</code> and <code>e</code> delimiters. This means our parser can read a single character to determine the upcoming data type, then delegate to the appropriate parsing method.</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fbencode-parsing.svg\" alt=\"Bencode Parsing State Machine\"></p>\n<p>The parsing state machine operates on a simple principle: examine the next character to determine the value type, then consume exactly the bytes needed for that value. For strings, we read digits until we hit a colon, parse the length, then read exactly that many data bytes. For integers, we consume characters between <code>i</code> and <code>e</code> markers. For containers, we recursively parse items until we encounter the closing <code>e</code>.</p>\n<blockquote>\n<p><strong>Decision: Recursive Descent Parser Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to parse nested Bencode structures containing arbitrary nesting of lists and dictionaries</li>\n<li><strong>Options Considered</strong>: Recursive descent parser, table-driven parser, hand-written state machine</li>\n<li><strong>Decision</strong>: Recursive descent with method-per-type design</li>\n<li><strong>Rationale</strong>: Bencode&#39;s simple grammar maps naturally to recursive methods, making the code readable and maintainable. The nesting depth is typically shallow in torrent files, so stack overflow isn&#39;t a concern.</li>\n<li><strong>Consequences</strong>: Simple implementation and good error reporting, but potential stack overflow on pathological inputs</li>\n</ul>\n</blockquote>\n<p>The <code>Decoder</code> struct maintains parsing state through a buffered reader that provides lookahead capabilities for type discrimination. The core <code>Decode</code> method acts as a dispatcher, examining the next byte to determine which specialized parsing method to invoke.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Purpose</th>\n<th>Input Format</th>\n<th>Returns</th>\n<th>Error Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Decode()</code></td>\n<td>Main entry point, dispatches to type-specific parsers</td>\n<td>Any valid Bencode</td>\n<td><code>interface{}</code>, <code>error</code></td>\n<td>Invalid type prefix, EOF</td>\n</tr>\n<tr>\n<td><code>decodeString()</code></td>\n<td>Parse length-prefixed byte strings</td>\n<td><code>&lt;digits&gt;:&lt;data&gt;</code></td>\n<td><code>[]byte</code>, <code>error</code></td>\n<td>Invalid length, insufficient data</td>\n</tr>\n<tr>\n<td><code>decodeInteger()</code></td>\n<td>Parse signed integers</td>\n<td><code>i&lt;digits&gt;e</code></td>\n<td><code>int64</code>, <code>error</code></td>\n<td>Invalid digits, missing terminator</td>\n</tr>\n<tr>\n<td><code>decodeList()</code></td>\n<td>Parse heterogeneous arrays</td>\n<td><code>l&lt;items&gt;e</code></td>\n<td><code>[]interface{}</code>, <code>error</code></td>\n<td>Malformed items, missing terminator</td>\n</tr>\n<tr>\n<td><code>decodeDictionary()</code></td>\n<td>Parse string-keyed maps</td>\n<td><code>d&lt;pairs&gt;e</code></td>\n<td><code>map[string]interface{}</code>, <code>error</code></td>\n<td>Non-string keys, unsorted keys</td>\n</tr>\n</tbody></table>\n<p>The string parsing algorithm demonstrates the careful byte handling required for binary data:</p>\n<ol>\n<li>Read decimal digits until encountering a colon character</li>\n<li>Parse the accumulated digits as the string length (validate non-negative)</li>\n<li>Allocate a byte slice of exactly that length</li>\n<li>Read exactly that many bytes from the input stream (not text lines)</li>\n<li>Return the raw byte slice without any encoding interpretation</li>\n</ol>\n<p>Integer parsing requires careful handling of the <code>i</code> and <code>e</code> delimiters while supporting negative values:</p>\n<ol>\n<li>Verify the current byte is <code>i</code> and advance past it</li>\n<li>Read characters until encountering <code>e</code>, accumulating digits and optional negative sign</li>\n<li>Validate the accumulated string represents a valid integer (no leading zeros except for zero itself)</li>\n<li>Parse the string as a signed 64-bit integer</li>\n<li>Consume the closing <code>e</code> delimiter</li>\n</ol>\n<p>List parsing showcases the recursive nature of the algorithm:</p>\n<ol>\n<li>Verify the current byte is <code>l</code> and advance past it</li>\n<li>Initialize an empty slice to accumulate parsed items</li>\n<li>While the next byte is not <code>e</code>, recursively call <code>Decode()</code> to parse the next item</li>\n<li>Append each successfully parsed item to the accumulating slice</li>\n<li>Consume the closing <code>e</code> delimiter and return the completed slice</li>\n</ol>\n<p>Dictionary parsing adds the complexity of maintaining sorted key order and ensuring all keys are strings:</p>\n<ol>\n<li>Verify the current byte is <code>d</code> and advance past it</li>\n<li>Initialize an empty map to accumulate key-value pairs</li>\n<li>While the next byte is not <code>e</code>, parse a key-value pair:<ul>\n<li>Parse the key (must be a string, return error if not)</li>\n<li>Parse the value (recursive call to <code>Decode()</code>)</li>\n<li>Verify key ordering (current key must be lexicographically greater than previous)</li>\n<li>Insert the pair into the accumulating map</li>\n</ul>\n</li>\n<li>Consume the closing <code>e</code> delimiter and return the completed map</li>\n</ol>\n<p>The key ordering validation is crucial because Bencode requires dictionary keys to appear in sorted order. This ensures deterministic serialization, which is essential for computing consistent info hashes. If we encounter keys out of order, we must reject the input as malformed.</p>\n<h3 id=\"torrent-metadata-extraction\">Torrent Metadata Extraction</h3>\n<p>Once we&#39;ve decoded the Bencode structure into native data types, we need to extract the specific fields that define a torrent&#39;s characteristics. Think of this process like extracting structured information from a parsed JSON API response - we know the expected schema and need to navigate the nested data to find the values we need.</p>\n<p>The root level of every torrent file contains several key fields that serve different purposes in the BitTorrent ecosystem:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Purpose</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>announce</code></td>\n<td>String</td>\n<td>Yes</td>\n<td>Primary tracker URL for peer discovery</td>\n<td><code>http://tracker.example.com:8080/announce</code></td>\n</tr>\n<tr>\n<td><code>announce-list</code></td>\n<td>List of Lists</td>\n<td>No</td>\n<td>Backup tracker URLs organized by tiers</td>\n<td><code>[[&quot;http://primary.com&quot;], [&quot;http://backup1.com&quot;, &quot;http://backup2.com&quot;]]</code></td>\n</tr>\n<tr>\n<td><code>info</code></td>\n<td>Dictionary</td>\n<td>Yes</td>\n<td>File and piece information (used for info hash)</td>\n<td>Contains <code>name</code>, <code>length</code>, <code>pieces</code>, etc.</td>\n</tr>\n<tr>\n<td><code>creation date</code></td>\n<td>Integer</td>\n<td>No</td>\n<td>Unix timestamp when torrent was created</td>\n<td><code>1609459200</code></td>\n</tr>\n<tr>\n<td><code>comment</code></td>\n<td>String</td>\n<td>No</td>\n<td>Human-readable description</td>\n<td><code>&quot;Ubuntu 20.04.1 Desktop amd64&quot;</code></td>\n</tr>\n<tr>\n<td><code>created by</code></td>\n<td>String</td>\n<td>No</td>\n<td>Software that created the torrent</td>\n<td><code>&quot;mktorrent 1.1&quot;</code></td>\n</tr>\n</tbody></table>\n<p>The <code>info</code> dictionary contains the core file and piece information that defines what we&#39;re downloading:</p>\n<table>\n<thead>\n<tr>\n<th>Info Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Purpose</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>name</code></td>\n<td>String</td>\n<td>Yes</td>\n<td>Suggested filename or directory name</td>\n<td>UTF-8 encoded, used for local file creation</td>\n</tr>\n<tr>\n<td><code>piece length</code></td>\n<td>Integer</td>\n<td>Yes</td>\n<td>Size of each piece in bytes (except possibly the last)</td>\n<td>Typically powers of 2, between 16KB and 8MB</td>\n</tr>\n<tr>\n<td><code>pieces</code></td>\n<td>String</td>\n<td>Yes</td>\n<td>Concatenated SHA-1 hashes of all pieces</td>\n<td>Length must be multiple of 20 bytes</td>\n</tr>\n<tr>\n<td><code>length</code></td>\n<td>Integer</td>\n<td>Single-file</td>\n<td>Total file size in bytes</td>\n<td>Present only for single-file torrents</td>\n</tr>\n<tr>\n<td><code>files</code></td>\n<td>List</td>\n<td>Multi-file</td>\n<td>List of file descriptors for multi-file torrents</td>\n<td>Each contains <code>length</code> and <code>path</code></td>\n</tr>\n</tbody></table>\n<p>The metadata extraction algorithm operates by navigating the decoded Bencode structure and type-checking each expected field:</p>\n<ol>\n<li><strong>Validate root structure</strong>: Ensure the decoded result is a dictionary containing required top-level keys</li>\n<li><strong>Extract announce URL</strong>: Retrieve the <code>announce</code> field as a string and validate it&#39;s a well-formed HTTP or UDP URL</li>\n<li><strong>Extract info dictionary</strong>: Retrieve the <code>info</code> field as a dictionary for further processing</li>\n<li><strong>Extract file information</strong>: Determine if this is a single-file or multi-file torrent and extract appropriate file metadata</li>\n<li><strong>Extract piece information</strong>: Retrieve piece length and piece hashes for download verification</li>\n<li><strong>Extract optional fields</strong>: Safely extract creation date, comment, and other non-critical metadata</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Single vs Multi-File Torrent Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: Torrents can contain either a single file (with <code>length</code> in info) or multiple files (with <code>files</code> array)</li>\n<li><strong>Options Considered</strong>: Separate parsing paths for each type, normalize to common representation, support both natively</li>\n<li><strong>Decision</strong>: Normalize single-file torrents to the multi-file representation internally</li>\n<li><strong>Rationale</strong>: Simplifies downstream code by providing a uniform interface, while preserving all original metadata</li>\n<li><strong>Consequences</strong>: Slight overhead for single-file torrents, but dramatically simplified piece and download management logic</li>\n</ul>\n</blockquote>\n<p>The piece hash extraction deserves special attention because it&#39;s critical for content verification. The <code>pieces</code> field contains concatenated 20-byte SHA-1 hashes, so we must split this byte string into individual hash values:</p>\n<ol>\n<li>Validate that the pieces string length is a multiple of 20 bytes</li>\n<li>Calculate the number of pieces as <code>len(pieces) / 20</code></li>\n<li>Iterate through the string in 20-byte chunks, extracting each piece hash</li>\n<li>Store the hashes in a slice for indexed access during downloads</li>\n</ol>\n<p>For multi-file torrents, we need to process the <code>files</code> array to understand the directory structure:</p>\n<ol>\n<li>Iterate through each file descriptor in the files array</li>\n<li>Extract the file length as an integer</li>\n<li>Extract the path as a list of strings representing the directory hierarchy</li>\n<li>Validate that path components don&#39;t contain directory traversal sequences like <code>..</code></li>\n<li>Accumulate total torrent size by summing individual file lengths</li>\n</ol>\n<p>The extraction process must handle missing optional fields gracefully while strictly validating required fields. For optional fields like creation date, we check for their presence before attempting type conversion. For required fields like announce URL, we return an error if the field is missing or has the wrong type.</p>\n<h3 id=\"info-hash-calculation\">Info Hash Calculation</h3>\n<p>The info hash represents the cryptographic identity of a torrent - it&#39;s how trackers, peers, and clients uniquely identify the specific content being shared. Think of it as a fingerprint that&#39;s computed from the torrent&#39;s file and piece information. This 20-byte SHA-1 digest is derived not from the parsed data structure, but from the exact encoded bytes of the info dictionary as it appears in the torrent file.</p>\n<p>This distinction is absolutely critical. We cannot simply re-encode the parsed info dictionary and compute its hash, because Bencode serialization must produce identical output to the original file. Even though Bencode is deterministic, our parser might represent the data differently than the original encoder (for example, using different string types or numeric representations).</p>\n<blockquote>\n<p>The info hash must be computed from the original Bencode bytes, not from re-serialized parsed data. This ensures consistency across all BitTorrent clients regardless of their internal data representations.</p>\n</blockquote>\n<p>The info hash serves multiple purposes in the BitTorrent ecosystem:</p>\n<table>\n<thead>\n<tr>\n<th>Use Case</th>\n<th>Purpose</th>\n<th>Why Identity Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tracker Communication</td>\n<td>Identifies which swarm to join</td>\n<td>Trackers group peers by info hash</td>\n</tr>\n<tr>\n<td>Peer Handshakes</td>\n<td>Verifies peers are sharing the same content</td>\n<td>Prevents mixing incompatible swarms</td>\n</tr>\n<tr>\n<td>DHT Lookups</td>\n<td>Distributed hash table key for peer discovery</td>\n<td>DHT stores peer lists keyed by info hash</td>\n</tr>\n<tr>\n<td>Magnet Links</td>\n<td>Content identifier in magnet URIs</td>\n<td>Allows torrent-less peer discovery</td>\n</tr>\n<tr>\n<td>Duplicate Detection</td>\n<td>Prevents downloading same content twice</td>\n<td>Client can identify already-downloaded torrents</td>\n</tr>\n</tbody></table>\n<p>The algorithm for info hash calculation requires careful handling of the original Bencode stream:</p>\n<ol>\n<li><strong>Locate info dictionary boundaries</strong>: Find the start of the info dictionary in the original Bencode data</li>\n<li><strong>Extract exact bytes</strong>: Copy the complete info dictionary including its <code>d</code> and <code>e</code> delimiters</li>\n<li><strong>Compute SHA-1 hash</strong>: Apply SHA-1 cryptographic hash function to these exact bytes</li>\n<li><strong>Store as 20-byte array</strong>: Preserve the binary hash for use in protocol messages</li>\n</ol>\n<p>The boundary location algorithm must parse the Bencode structure while tracking byte positions:</p>\n<ol>\n<li>Begin parsing at the root dictionary marker <code>d</code></li>\n<li>Parse key-value pairs, tracking the byte offset of each key</li>\n<li>When encountering the key <code>&quot;info&quot;</code>, record the current byte position</li>\n<li>Parse the info dictionary value completely, recording the ending byte position</li>\n<li>Extract the substring from start position to end position inclusive of delimiters</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Original Bytes vs Re-encoding for Info Hash</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to compute SHA-1 hash of info dictionary for torrent identification</li>\n<li><strong>Options Considered</strong>: Re-encode parsed data, track original bytes during parsing, separate parsing pass for hash calculation</li>\n<li><strong>Decision</strong>: Track byte boundaries during initial parse to extract original info bytes</li>\n<li><strong>Rationale</strong>: Guarantees hash consistency with torrent creator and other clients, avoids re-encoding complexity</li>\n<li><strong>Consequences</strong>: Slightly more complex parser but ensures protocol compliance and interoperability</li>\n</ul>\n</blockquote>\n<p>The implementation must handle the info dictionary as a contiguous byte slice from the original torrent file. This means our parser needs to either track byte positions during parsing or provide a method to locate dictionary boundaries after parsing is complete.</p>\n<p>A robust approach involves augmenting our Bencode decoder to track parsing positions:</p>\n<ol>\n<li><strong>Enhanced decoder state</strong>: Modify the <code>Decoder</code> to track current byte position alongside the buffered reader</li>\n<li><strong>Boundary recording</strong>: When parsing the root dictionary, record start and end positions for the info key&#39;s value</li>\n<li><strong>Byte extraction</strong>: After successful parsing, extract the info dictionary bytes using recorded boundaries</li>\n<li><strong>Hash computation</strong>: Apply SHA-1 to the extracted bytes and store the result in our <code>MetaInfo</code> structure</li>\n</ol>\n<p>The info hash becomes the torrent&#39;s primary key throughout the BitTorrent protocol. It appears in tracker announce requests, peer handshake messages, and DHT queries. Every piece of communication about this torrent will reference this 20-byte identifier, making its correct calculation essential for protocol compatibility.</p>\n<h3 id=\"common-parsing-pitfalls\">Common Parsing Pitfalls</h3>\n<p>Torrent file parsing involves several subtle challenges that frequently trip up implementers. Understanding these pitfalls and their solutions is crucial for building a robust BitTorrent client that works correctly with real-world torrent files.</p>\n<p>⚠️ <strong>Pitfall: Treating Bencode Strings as Text</strong></p>\n<p>Many developers assume Bencode strings contain UTF-8 text and attempt to decode them as such. This fails catastrophically with binary data like piece hashes, which contain arbitrary byte values that aren&#39;t valid UTF-8 sequences. The pieces field, for example, contains concatenated SHA-1 hashes that include null bytes, control characters, and invalid UTF-8 sequences.</p>\n<p><strong>Why it&#39;s wrong</strong>: Bencode byte strings can contain any byte values from 0x00 to 0xFF. Attempting UTF-8 decoding will either fail with encoding errors or silently corrupt the binary data through replacement characters.</p>\n<p><strong>How to fix</strong>: Always handle Bencode strings as raw byte slices (<code>[]byte</code> in Go). Only convert to text strings when you&#39;re certain the content is textual (like file names) and need to display it to users. For protocol fields like piece hashes and peer IDs, preserve the binary representation.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Info Dictionary Boundary Detection</strong></p>\n<p>Computing the info hash requires extracting the exact bytes of the info dictionary from the original torrent file. A common mistake is attempting to find these boundaries through string searching or regex matching, which fails when the info dictionary contains binary data that happens to include the search patterns.</p>\n<p><strong>Why it&#39;s wrong</strong>: String-based searches can match content inside binary fields, leading to incorrect boundary detection. For example, searching for the byte sequence <code>&quot;e&quot;</code> to find the dictionary end might match a byte inside a piece hash.</p>\n<p><strong>How to fix</strong>: Parse the Bencode structure properly while tracking byte positions. The parser understands the structure and can correctly identify where the info dictionary begins and ends, even when it contains arbitrary binary data.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Dictionary Key Ordering Requirements</strong></p>\n<p>Bencode requires dictionary keys to appear in lexicographically sorted order. Some implementations skip this validation, accepting malformed torrent files that would be rejected by other clients. This can lead to info hash mismatches when different clients compute hashes from differently-ordered data.</p>\n<p><strong>Why it&#39;s wrong</strong>: The Bencode specification mandates key ordering to ensure deterministic serialization. Accepting out-of-order keys means your client might compute different info hashes than other clients for the same logical content.</p>\n<p><strong>How to fix</strong>: Validate key ordering during dictionary parsing. Maintain the previous key and ensure each new key is lexicographically greater. Reject torrent files with misordered keys as malformed.</p>\n<p>⚠️ <strong>Pitfall: Integer Parsing Edge Cases</strong></p>\n<p>Bencode integer parsing has several edge cases that naive implementations handle incorrectly. These include leading zeros (forbidden except for zero itself), empty integer fields, and very large numbers that exceed language-specific integer ranges.</p>\n<p><strong>Why it&#39;s wrong</strong>: Incorrect integer parsing can lead to wrong file sizes, piece lengths, or creation dates. More critically, accepting malformed integers that other clients reject can cause protocol incompatibilities.</p>\n<p><strong>How to fix</strong>: Implement strict integer validation:</p>\n<ul>\n<li>Reject integers with leading zeros except for <code>i0e</code></li>\n<li>Reject empty integers like <code>ie</code></li>\n<li>Handle potential overflow for very large file sizes</li>\n<li>Validate that integers are well-formed decimal numbers</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Path Traversal in Multi-File Torrents</strong></p>\n<p>Multi-file torrents specify file paths as arrays of path components. Malicious torrent files might include path components like <code>&quot;..&quot;</code> that could cause files to be written outside the intended download directory, potentially overwriting system files.</p>\n<p><strong>Why it&#39;s wrong</strong>: Path traversal attacks can compromise the user&#39;s system by overwriting arbitrary files. A torrent containing a file path like <code>[&quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;etc&quot;, &quot;passwd&quot;]</code> could overwrite <code>/etc/passwd</code> on Unix systems.</p>\n<p><strong>How to fix</strong>: Validate all path components during metadata extraction:</p>\n<ul>\n<li>Reject path components that are <code>&quot;.&quot;</code> or <code>&quot;..&quot;</code></li>\n<li>Reject absolute paths that start with <code>/</code> or drive letters</li>\n<li>Sanitize path components to remove dangerous characters</li>\n<li>Construct file paths within a designated download directory</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Piece Hash Count Validation</strong></p>\n<p>The pieces field contains concatenated SHA-1 hashes, so its length must be a multiple of 20 bytes. However, you also need to validate that the number of piece hashes matches the expected count based on total file size and piece length.</p>\n<p><strong>Why it&#39;s wrong</strong>: Accepting torrents with incorrect piece counts can lead to downloads that can never complete (missing pieces) or buffer overruns when accessing piece hashes by index.</p>\n<p><strong>How to fix</strong>: Calculate expected piece count and validate consistency:</p>\n<ul>\n<li>Compute expected pieces as <code>ceil(total_file_size / piece_length)</code></li>\n<li>Verify that <code>len(pieces) / 20 == expected_piece_count</code></li>\n<li>Reject torrents where the piece hash count doesn&#39;t match the calculated requirement</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Memory Exhaustion on Large Torrents</strong></p>\n<p>Very large torrents can contain millions of pieces, each requiring a 20-byte hash. Loading all piece hashes into memory simultaneously might exhaust available RAM for torrents containing terabytes of data.</p>\n<p><strong>Why it&#39;s wrong</strong>: Memory exhaustion can crash your client or make the system unresponsive. A 1TB torrent with 256KB pieces requires about 80MB just for piece hashes.</p>\n<p><strong>How to fix</strong>: For very large torrents, consider streaming piece hash access rather than loading everything into memory. Implement lazy loading where piece hashes are read from the torrent file as needed, or use memory-mapped files for efficient access without full loading.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides the concrete Go implementation infrastructure needed to parse torrent files and extract metadata. The focus is on providing complete, working code for supporting components while leaving the core learning objectives as exercises for implementation.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File I/O</td>\n<td><code>os.File</code> with <code>io.Reader</code> interface</td>\n<td>Memory-mapped files with <code>golang.org/x/exp/mmap</code></td>\n</tr>\n<tr>\n<td>Hash Computation</td>\n<td><code>crypto/sha1</code> standard library</td>\n<td>Streaming hash computation for large files</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Basic <code>error</code> returns with wrapped context</td>\n<td>Structured error types with error codes</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Table-driven tests with <code>testing</code> package</td>\n<td>Property-based testing with <code>github.com/leanovate/gopter</code></td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard <code>log</code> package for debugging</td>\n<td>Structured logging with <code>github.com/sirupsen/logrus</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   └── torrent/\n│       └── main.go              ← CLI entry point for testing\n├── internal/\n│   ├── bencode/\n│   │   ├── decoder.go           ← Core bencode parsing logic\n│   │   ├── decoder_test.go      ← Unit tests for decoder\n│   │   └── types.go             ← Bencode type constants\n│   ├── torrent/\n│   │   ├── metainfo.go          ← Torrent metadata structures\n│   │   ├── parser.go            ← High-level torrent file parsing\n│   │   ├── parser_test.go       ← Integration tests with real torrents\n│   │   └── infohash.go          ← Info hash calculation utilities\n│   └── testdata/\n│       ├── single-file.torrent  ← Test torrent files\n│       ├── multi-file.torrent\n│       └── invalid-*.torrent    ← Malformed files for error testing\n└── go.mod</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>File: <code>internal/bencode/types.go</code> (Complete - Ready to Use)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> bencode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BencodeType represents the four fundamental Bencode data types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BencodeType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTypeString</span><span style=\"color:#B392F0\"> BencodeType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTypeInteger</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTypeList</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTypeDictionary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common Bencode parsing errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tErrInvalidType       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid bencode type marker\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tErrUnexpectedEOF     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected end of input\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tErrInvalidInteger    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid integer format\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tErrInvalidLength     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid string length\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tErrUnsortedKeys      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"dictionary keys not in sorted order\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tErrNonStringKey      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"dictionary key is not a string\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tErrInsufficientData  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"insufficient data for declared length\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseError wraps parsing errors with position information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tOffset </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tErr    </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ParseError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bencode parse error at offset </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Offset, e.Err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ParseError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Unwrap</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> e.Err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsValidInteger checks if a string represents a valid Bencode integer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> IsValidInteger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(s) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Handle negative numbers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> s[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">-</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(s) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#6A737D\"> // Just \"-\" is invalid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tstart </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Check for leading zeros (forbidden except for \"0\" itself)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> s[start] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(s) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> start</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Verify all remaining characters are digits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> start; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(s); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> s[i] </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> s[i] </span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>internal/torrent/metainfo.go</code> (Complete - Ready to Use)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetaInfo represents the complete torrent file metadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetaInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAnnounce     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"announce\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAnnounceList [][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"announce_list,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreationDate </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">  `json:\"creation_date,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tComment      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"comment,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedBy    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"created_by,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tInfoHash     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">   `json:\"info_hash\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tInfo         </span><span style=\"color:#B392F0\">Info</span><span style=\"color:#9ECBFF\">       `json:\"info\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Info represents the info dictionary containing file and piece data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Info</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tLength      </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">  `json:\"length,omitempty\"`</span><span style=\"color:#6A737D\">      // Single-file torrents only</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tFiles       []</span><span style=\"color:#B392F0\">File</span><span style=\"color:#9ECBFF\"> `json:\"files,omitempty\"`</span><span style=\"color:#6A737D\">       // Multi-file torrents only</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPieceLength </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">  `json:\"piece_length\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPieces      []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\"> `json:\"pieces\"`</span><span style=\"color:#6A737D\">                // Concatenated SHA-1 hashes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// File represents a single file in a multi-file torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> File</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tLength </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">    `json:\"length\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPath   []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetPieceHashes extracts individual piece hashes from the concatenated pieces field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">info </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetPieceHashes</span><span style=\"color:#E1E4E8\">() [][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tconst</span><span style=\"color:#79B8FF\"> PIECE_HASH_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 20</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tnumPieces </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(info.Pieces) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> PIECE_HASH_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thashes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([][</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, numPieces)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> numPieces; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tstart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PIECE_HASH_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\t\tcopy</span><span style=\"color:#E1E4E8\">(hashes[i][:], info.Pieces[start:start</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">PIECE_HASH_SIZE])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> hashes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TotalLength calculates the total size of all files in the torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">info </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TotalLength</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> info.Length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Single-file torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> info.Length</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Multi-file torrent - sum all file lengths</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttotal </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> _, file </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> info.Files {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttotal </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> file.Length</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> total</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExpectedPieceCount calculates how many pieces this torrent should have</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">info </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExpectedPieceCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttotalLength </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> info.</span><span style=\"color:#B392F0\">TotalLength</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">((totalLength </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> info.PieceLength </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> info.PieceLength) </span><span style=\"color:#6A737D\">// Ceiling division</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidatePieceHashes checks that the piece hash count matches expected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">info </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidatePieceHashes</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tconst</span><span style=\"color:#79B8FF\"> PIECE_HASH_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 20</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(info.Pieces)</span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\">PIECE_HASH_SIZE </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pieces field length is not a multiple of 20\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tactualCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(info.Pieces) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> PIECE_HASH_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\texpectedCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> info.</span><span style=\"color:#B392F0\">ExpectedPieceCount</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> actualCount </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expectedCount {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"piece hash count mismatch: got </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, expected </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tactualCount, expectedCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>File: <code>internal/bencode/decoder.go</code> (Skeleton - Implement the TODOs)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> bencode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Decoder handles parsing of Bencode data streams</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Decoder</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\treader </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\toffset </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // Track current byte position for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDecoder creates a new Bencode decoder for the given reader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDecoder</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\treader: bufio.</span><span style=\"color:#B392F0\">NewReader</span><span style=\"color:#E1E4E8\">(r),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\toffset: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Decode parses the next Bencode value from the stream</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the parsed value as interface{} - caller must type assert</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Decode</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Peek at the next byte to determine value type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Dispatch to appropriate parsing method based on type:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - '0'-'9': string (starts with length digits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - 'i': integer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - 'l': list  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - 'd': dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Return ParseError with offset information for invalid types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use d.reader.Peek(1) to look ahead without consuming</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// decodeString parses a Bencode string in format \"length:data\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">decodeString</span><span style=\"color:#E1E4E8\">() ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Read decimal digits until hitting ':' character</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Parse the accumulated digits as string length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Validate length is non-negative using IsValidInteger</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Read exactly that many bytes as the string data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Return the raw bytes (don't convert to text)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use d.readUntil(':') helper and strconv.Atoi for parsing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// decodeInteger parses a Bencode integer in format \"i&#x3C;number>e\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">decodeInteger</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Verify next byte is 'i' and consume it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Read characters until 'e', accumulating the number string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Validate integer format using IsValidInteger (no leading zeros)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Parse as int64 and handle potential overflow</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Consume the closing 'e' delimiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use d.readUntil('e') and strconv.ParseInt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// decodeList parses a Bencode list in format \"l&#x3C;items>e\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">decodeList</span><span style=\"color:#E1E4E8\">() ([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Verify next byte is 'l' and consume it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Initialize empty slice for accumulating items</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Loop while next byte is not 'e':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - Recursively call Decode() for each item</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - Append successful results to slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Consume closing 'e' delimiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Return completed slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Check d.peekByte() != 'e' for loop condition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// decodeDictionary parses a Bencode dictionary in format \"d&#x3C;pairs>e\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">decodeDictionary</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Verify next byte is 'd' and consume it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Initialize empty map and previousKey for sorting validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Loop while next byte is not 'e':</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - Parse key (must be string type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - Validate key is lexicographically > previousKey</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - Parse value (recursive Decode() call)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         - Insert key-value pair into map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Consume closing 'e' delimiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Return completed map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use string comparison for key ordering validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper methods (Complete - Ready to Use)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readByte</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tb, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> d.reader.</span><span style=\"color:#B392F0\">ReadByte</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\td.offset</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> b, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">peekByte</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbytes, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> d.reader.</span><span style=\"color:#B392F0\">Peek</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> bytes[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readUntil</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">delimiter</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tvar</span><span style=\"color:#E1E4E8\"> result []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tb, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> d.</span><span style=\"color:#B392F0\">readByte</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> delimiter {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\tbreak</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tresult </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(result, b)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">(result), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>internal/torrent/parser.go</code> (Skeleton - Implement the TODOs)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">your-project/internal/bencode</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseFromFile reads and parses a torrent file from disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseFromFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filepath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Open the torrent file for reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create a Bencode decoder for the file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Parse the complete Bencode structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Extract metadata using extractMetaInfo</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Calculate info hash from original file bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: You'll need to re-read the file to get original info bytes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// extractMetaInfo converts decoded Bencode data to MetaInfo struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> extractMetaInfo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">decoded</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Type assert root as map[string]interface{}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Extract required 'announce' field as string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Extract required 'info' dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Extract optional fields (announce-list, creation date, comment)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Parse the info dictionary using extractInfo</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Validate extracted metadata for consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use type assertion with ok pattern: value, ok := data.(string)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// extractInfo converts decoded info dictionary to Info struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> extractInfo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">infoDict</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Type assert as map[string]interface{}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Extract required fields: name, piece length, pieces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Determine single-file vs multi-file by checking for 'files' field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: For single-file: extract 'length' field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: For multi-file: extract 'files' array and process each file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Validate piece length and pieces field format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Return populated Info struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Check for 'files' field presence to determine torrent type</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateInfoHash computes SHA-1 hash of the info dictionary bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CalculateInfoHash</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">torrentData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) ([</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Parse Bencode to find info dictionary boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Extract exact bytes of info dict including 'd' and 'e' delimiters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Compute SHA-1 hash of those exact bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Return as 20-byte array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Need to track byte positions during parsing to extract original bytes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Go-Specific Implementation Tips:</strong></p>\n<ul>\n<li>Use <code>bufio.Reader</code> for efficient parsing with lookahead capabilities via <code>Peek()</code></li>\n<li>Handle binary data with <code>[]byte</code> slices - never convert to <code>string</code> unless displaying to users</li>\n<li>Use <code>strconv.ParseInt()</code> with base 10 for integer parsing with overflow detection</li>\n<li>Implement error wrapping with <code>fmt.Errorf(&quot;context: %w&quot;, originalError)</code> for better debugging</li>\n<li>Use type assertions with the two-value form: <code>value, ok := data.(string)</code> to avoid panics</li>\n<li>Apply <code>crypto/sha1.Sum()</code> for hash calculation - it returns <code>[20]byte</code> directly</li>\n<li>Consider using <code>os.Open()</code> with <code>defer file.Close()</code> for proper resource management</li>\n</ul>\n<p><strong>Common Go Gotchas in This Context:</strong></p>\n<ul>\n<li>String vs <code>[]byte</code> confusion: Bencode &quot;strings&quot; are binary data, use <code>[]byte</code></li>\n<li>Integer overflow: Use <code>int64</code> for all numeric fields to handle large files</li>\n<li>Map iteration order: Go maps have random iteration order, but Bencode requires sorted keys during encoding</li>\n<li>Error handling: Always check errors from I/O operations before using results</li>\n<li>Type assertions: Failed type assertions panic unless using the two-value form</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the core parsing logic, verify your implementation with these tests:</p>\n<p><strong>Test Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> internal/bencode</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> ../torrent</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ol>\n<li><strong>Bencode decoder tests pass</strong>: All four value types parse correctly, edge cases are handled</li>\n<li><strong>Torrent parsing integration test</strong>: Parse a real torrent file and extract metadata</li>\n<li><strong>Info hash consistency</strong>: Calculate same info hash as other BitTorrent clients for the same torrent</li>\n</ol>\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Download a simple torrent file (like Ubuntu ISO) from a legitimate source</li>\n<li>Parse it with your implementation: <code>go run cmd/torrent/main.go parse ubuntu.torrent</code></li>\n<li>Expected output should show:<ul>\n<li>Announce URL (HTTP tracker)</li>\n<li>File name and size matching the actual ISO</li>\n<li>Piece count and piece length (typically 512KB to 4MB for large files)</li>\n<li>Valid 40-character hex info hash</li>\n</ul>\n</li>\n<li>Compare info hash with another BitTorrent client - they should match exactly</li>\n</ol>\n<p><strong>Signs Something Is Wrong:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Debug</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parse errors on valid torrents</td>\n<td>Bencode decoder bugs</td>\n<td>Test each type separately</td>\n<td>Review string/integer parsing logic</td>\n</tr>\n<tr>\n<td>Info hash doesn&#39;t match other clients</td>\n<td>Using re-encoded bytes instead of original</td>\n<td>Print hash input bytes</td>\n<td>Extract exact original info dict bytes</td>\n</tr>\n<tr>\n<td>Piece count validation fails</td>\n<td>Incorrect total size calculation</td>\n<td>Check multi-file length summing</td>\n<td>Verify Files vs Length handling</td>\n</tr>\n<tr>\n<td>Panic on type assertions</td>\n<td>Missing error handling</td>\n<td>Add two-value type assertions</td>\n<td>Use <code>value, ok := data.(type)</code> pattern</td>\n</tr>\n</tbody></table>\n<h2 id=\"tracker-communication-milestone-2\">Tracker Communication (Milestone 2)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 2 - Tracker Communication, implementing HTTP tracker protocol for peer discovery with proper URL encoding and response parsing.</p>\n</blockquote>\n<p>After successfully parsing a torrent file and extracting its metadata, our BitTorrent client faces a fundamental challenge: finding other peers who have the same file. Unlike a traditional client-server model where you simply connect to a known server, BitTorrent operates as a decentralized peer-to-peer network. The <strong>tracker</strong> serves as the coordination point that helps peers discover each other, acting as a matchmaker in the distributed file-sharing ecosystem.</p>\n<h3 id=\"tracker-as-matchmaking-service\">Tracker as Matchmaking Service</h3>\n<p>Think of a BitTorrent tracker as a sophisticated dating app for files. Just as a dating app helps people with similar interests find each other, a tracker helps peers interested in the same files discover and connect to one another. When you join a dating app, you create a profile describing yourself and what you&#39;re looking for. Similarly, when your BitTorrent client contacts a tracker, it announces its identity, what file it wants (identified by the info hash), and its current status (how much it has downloaded, uploaded, and how much is left).</p>\n<p>The dating app doesn&#39;t store the actual conversations between matched users—it just facilitates the initial introduction. Likewise, the tracker doesn&#39;t participate in the actual file transfer. It simply maintains a registry of peers interested in each torrent and provides peer lists when requested. The tracker knows which peers are actively participating in a swarm (the collection of all peers sharing a particular torrent), their network addresses, and their current participation status.</p>\n<p>This analogy extends to the periodic check-ins that both systems require. Dating apps might ask you to update your profile or confirm you&#39;re still active. Similarly, BitTorrent clients must periodically re-announce to the tracker, reporting their progress and confirming they&#39;re still participating in the swarm. This prevents the tracker from serving stale peer information and ensures an accurate view of swarm health.</p>\n<p>The tracker protocol is intentionally lightweight and stateless. The tracker doesn&#39;t need to remember complex state about each peer—it simply maintains a current snapshot of who&#39;s interested in what files and their network coordinates. This simplicity allows trackers to serve thousands of concurrent torrents and handle massive swarms efficiently.</p>\n<h3 id=\"announce-request-protocol\">Announce Request Protocol</h3>\n<p>The <strong>announce request</strong> is the fundamental communication mechanism between BitTorrent clients and trackers. This HTTP GET request follows a specific format defined by the BitTorrent protocol specification, carrying essential information about the client&#39;s current state and requesting a list of peers participating in the same swarm.</p>\n<p>The announce URL construction begins with the base tracker URL extracted from the torrent file&#39;s <code>announce</code> field. To this base URL, we append a query string containing several required parameters that inform the tracker about our client&#39;s current status and capabilities.</p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Type</th>\n<th>Description</th>\n<th>Encoding Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>info_hash</code></td>\n<td>20-byte binary</td>\n<td>SHA-1 hash identifying the torrent</td>\n<td>URL-encoded binary data</td>\n</tr>\n<tr>\n<td><code>peer_id</code></td>\n<td>20-byte binary</td>\n<td>Unique identifier for our client instance</td>\n<td>URL-encoded binary data</td>\n</tr>\n<tr>\n<td><code>port</code></td>\n<td>Integer</td>\n<td>TCP port our client listens on for peer connections</td>\n<td>Decimal string</td>\n</tr>\n<tr>\n<td><code>uploaded</code></td>\n<td>Integer</td>\n<td>Total bytes uploaded to other peers</td>\n<td>Decimal string</td>\n</tr>\n<tr>\n<td><code>downloaded</code></td>\n<td>Integer</td>\n<td>Total bytes downloaded from other peers</td>\n<td>Decimal string</td>\n</tr>\n<tr>\n<td><code>left</code></td>\n<td>Integer</td>\n<td>Bytes remaining to complete the download</td>\n<td>Decimal string</td>\n</tr>\n<tr>\n<td><code>compact</code></td>\n<td>Integer</td>\n<td>Request compact peer list format (always 1)</td>\n<td>Literal &quot;1&quot;</td>\n</tr>\n<tr>\n<td><code>event</code></td>\n<td>String</td>\n<td>Current client state transition</td>\n<td>&quot;started&quot;, &quot;completed&quot;, &quot;stopped&quot;, or omitted</td>\n</tr>\n</tbody></table>\n<p>The most critical aspect of announce request construction is proper URL encoding of binary parameters. The <code>info_hash</code> and <code>peer_id</code> are 20-byte binary values that must be percent-encoded for HTTP transmission. Each byte that is not a unreserved character (alphanumeric, hyphen, underscore, period, or tilde) must be represented as <code>%XX</code> where XX is the hexadecimal representation of the byte value.</p>\n<blockquote>\n<p><strong>Decision: HTTP GET vs POST for Announce Requests</strong></p>\n<ul>\n<li><strong>Context</strong>: The BitTorrent specification allows both GET and POST methods for announce requests, requiring implementers to choose an approach</li>\n<li><strong>Options Considered</strong>: HTTP GET with query parameters, HTTP POST with form data, HTTP POST with request body</li>\n<li><strong>Decision</strong>: Use HTTP GET with query parameters</li>\n<li><strong>Rationale</strong>: GET requests are simpler to implement, debug, and cache. They&#39;re stateless and idempotent by nature, matching the tracker protocol&#39;s design. Most existing trackers expect GET requests, ensuring maximum compatibility</li>\n<li><strong>Consequences</strong>: URL length limitations could theoretically be an issue with very long announce URLs, but in practice BitTorrent announce requests are well within browser and server URL limits</li>\n</ul>\n</blockquote>\n<p>The <code>event</code> parameter deserves special attention as it communicates significant state changes to the tracker. When a client first starts downloading a torrent, it sends <code>event=started</code> to announce its entry into the swarm. Upon completing the download, it sends <code>event=completed</code> to indicate it&#39;s now seeding. When shutting down gracefully, it sends <code>event=stopped</code> to allow the tracker to remove it from the peer list immediately rather than waiting for a timeout.</p>\n<p>Announce requests also serve as a progress reporting mechanism. The <code>uploaded</code>, <code>downloaded</code>, and <code>left</code> fields allow the tracker to maintain statistics about swarm health and individual peer contribution. Some trackers use this information for ratio enforcement or to provide preferential treatment to peers who contribute more upload bandwidth.</p>\n<p>The <code>compact</code> parameter requests that the tracker return peer information in a space-efficient binary format rather than a more verbose dictionary format. This compact format reduces bandwidth usage and parsing overhead, making it the preferred approach for production implementations.</p>\n<p>Here&#39;s the step-by-step process for constructing and sending an announce request:</p>\n<ol>\n<li>Extract the base announce URL from the torrent&#39;s <code>MetaInfo.Announce</code> field</li>\n<li>Generate a unique 20-byte <code>peer_id</code> for this client session (commonly using a prefix identifying the client software followed by random bytes)</li>\n<li>Calculate current progress values: bytes uploaded, downloaded, and remaining</li>\n<li>URL-encode the binary <code>info_hash</code> and <code>peer_id</code> values using percent-encoding</li>\n<li>Construct the query string by concatenating all parameters with proper separators</li>\n<li>Append the query string to the base URL and send an HTTP GET request</li>\n<li>Parse the response to extract peer information and tracker guidance</li>\n</ol>\n<h3 id=\"peer-list-response-parsing\">Peer List Response Parsing</h3>\n<p>The tracker&#39;s response to an announce request contains critical information for peer discovery and swarm coordination. This response is encoded using the same Bencode format used for torrent files, requiring our existing decoder to parse the structured data.</p>\n<table>\n<thead>\n<tr>\n<th>Response Field</th>\n<th>Type</th>\n<th>Description</th>\n<th>Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>interval</code></td>\n<td>Integer</td>\n<td>Seconds to wait before next announce</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code>complete</code></td>\n<td>Integer</td>\n<td>Number of peers with complete file (seeders)</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>incomplete</code></td>\n<td>Integer</td>\n<td>Number of peers still downloading (leechers)</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>peers</code></td>\n<td>Binary String</td>\n<td>Compact peer list in 6-byte format</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code>failure reason</code></td>\n<td>String</td>\n<td>Error message if request failed</td>\n<td>Only on failure</td>\n</tr>\n</tbody></table>\n<p>The most important field is the <code>peers</code> binary string, which contains a concatenated list of peer network addresses in compact format. Each peer is represented by exactly 6 bytes: 4 bytes for the IPv4 address followed by 2 bytes for the port number, both in network byte order (big-endian).</p>\n<p>Parsing the compact peer list requires careful handling of binary data and endianness conversion:</p>\n<ol>\n<li>Verify the peers field length is a multiple of 6 bytes (each peer requires exactly 6 bytes)</li>\n<li>Iterate through the binary data in 6-byte chunks</li>\n<li>Extract bytes 0-3 as the IPv4 address in network byte order</li>\n<li>Extract bytes 4-5 as the port number in network byte order</li>\n<li>Convert the port from big-endian to host byte order</li>\n<li>Create a <code>PeerInfo</code> structure containing the IP address and port</li>\n</ol>\n<p>The <code>interval</code> field specifies how long the client should wait before making the next announce request. This prevents clients from overwhelming the tracker with excessive requests while ensuring the tracker maintains reasonably current swarm information. Typical intervals range from 15 minutes to several hours, with shorter intervals used for more active torrents.</p>\n<blockquote>\n<p><strong>Critical Implementation Detail</strong>: The compact peer format uses network byte order (big-endian) for both IP addresses and port numbers. Many programming languages use host byte order internally, requiring explicit conversion using functions like <code>binary.BigEndian.Uint16()</code> in Go or <code>socket.ntohs()</code> in C. Failure to perform this conversion results in incorrect peer addresses and connection failures.</p>\n</blockquote>\n<p>The <code>complete</code> and <code>incomplete</code> fields provide valuable swarm health information. <code>complete</code> indicates the number of seeders (peers with the complete file), while <code>incomplete</code> shows the number of leechers (peers still downloading). This information helps clients assess download viability—a torrent with no seeders cannot be completed, while one with many seeders typically offers faster download speeds.</p>\n<p><strong>Re-announce scheduling</strong> is crucial for maintaining accurate peer lists and swarm participation. The client must track the time of the last announce and schedule the next one based on the tracker&#39;s <code>interval</code> response. This scheduling should account for network delays and provide some jitter to prevent all clients from announcing simultaneously.</p>\n<p>The re-announce process follows this algorithm:</p>\n<ol>\n<li>Record the timestamp of the successful announce response</li>\n<li>Extract the <code>interval</code> value from the tracker response</li>\n<li>Schedule the next announce for <code>current_time + interval + random_jitter</code></li>\n<li>Use a small random jitter (±10% of interval) to distribute load</li>\n<li>Include updated progress statistics in the next announce request</li>\n<li>Reset the schedule if any announce request fails, implementing exponential backoff</li>\n</ol>\n<h3 id=\"tracker-error-handling\">Tracker Error Handling</h3>\n<p>Robust tracker communication requires comprehensive error handling to deal with network failures, server errors, and protocol violations. The distributed nature of BitTorrent means that tracker failures should not prevent file downloads—clients must gracefully degrade and continue operating with cached peer information.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Retry Timing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network timeout</td>\n<td>HTTP request timeout</td>\n<td>Exponential backoff retry</td>\n<td>30s, 60s, 120s, 300s</td>\n</tr>\n<tr>\n<td>HTTP error status</td>\n<td>4xx/5xx response codes</td>\n<td>Check failure reason, retry with backoff</td>\n<td>Based on status code</td>\n</tr>\n<tr>\n<td>Invalid response format</td>\n<td>Bencode parsing failure</td>\n<td>Log error, use cached peers</td>\n<td>Next scheduled interval</td>\n</tr>\n<tr>\n<td>Tracker failure reason</td>\n<td>&quot;failure reason&quot; field in response</td>\n<td>Log reason, retry with backoff</td>\n<td>5min, 15min, 30min</td>\n</tr>\n<tr>\n<td>DNS resolution failure</td>\n<td>Domain name lookup failure</td>\n<td>Retry with exponential backoff</td>\n<td>60s, 300s, 900s</td>\n</tr>\n<tr>\n<td>Connection refused</td>\n<td>TCP connection failure</td>\n<td>Assume temporary failure, retry</td>\n<td>30s, 120s, 300s</td>\n</tr>\n</tbody></table>\n<p><strong>Network timeout handling</strong> requires careful balance between responsiveness and resource usage. Tracker requests should have reasonable timeouts (typically 30-60 seconds) to detect unresponsive servers without blocking the client indefinitely. When timeouts occur, implement exponential backoff with jitter to avoid overwhelming recovering servers.</p>\n<p><strong>HTTP error response handling</strong> depends on the specific status code received. 4xx errors typically indicate client-side issues (malformed requests, invalid info hashes) that won&#39;t resolve with retries, while 5xx errors suggest server-side problems that may be temporary. The client should distinguish between these cases and adjust retry behavior accordingly.</p>\n<p><strong>Malformed response handling</strong> occurs when the tracker returns data that doesn&#39;t conform to the expected Bencode format or contains invalid peer information. Rather than crashing, the client should log the error details and continue operating with previously cached peer information. This allows downloads to continue even when trackers misbehave.</p>\n<blockquote>\n<p><strong>Design Principle</strong>: Graceful degradation is fundamental to BitTorrent&#39;s robustness. The protocol is designed to continue functioning even when central infrastructure (like trackers) fails. Clients should never become completely non-functional due to tracker issues.</p>\n</blockquote>\n<p><strong>Exponential backoff implementation</strong> prevents clients from overwhelming failing trackers while still attempting recovery. The backoff algorithm should:</p>\n<ol>\n<li>Start with a base delay (e.g., 30 seconds) after the first failure</li>\n<li>Double the delay after each subsequent failure, up to a maximum (e.g., 30 minutes)</li>\n<li>Add random jitter (±25% of the delay) to prevent thundering herd effects</li>\n<li>Reset to the base delay after any successful request</li>\n<li>Continue attempting indefinitely, as trackers may recover after extended outages</li>\n</ol>\n<p><strong>Alternative tracker support</strong> enhances reliability when torrents specify multiple tracker URLs in the <code>announce-list</code> field. The client should try trackers in order, falling back to alternatives when the primary tracker fails. This requires tracking the health of each tracker and implementing intelligent failover logic.</p>\n<p>The failover algorithm proceeds as follows:</p>\n<ol>\n<li>Attempt to contact the primary tracker from <code>announce</code> field</li>\n<li>If the primary tracker fails, iterate through <code>announce-list</code> tiers</li>\n<li>Within each tier, try trackers in random order to distribute load</li>\n<li>Mark trackers as failed after multiple consecutive failures</li>\n<li>Periodically retry failed trackers to detect when they recover</li>\n<li>Prefer trackers that have recently provided successful responses</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete implementation details for the tracker communication system, including complete working code for HTTP transport and response parsing, plus detailed skeletons for the core tracker protocol logic.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Client</td>\n<td><code>net/http.Client</code> with custom timeout</td>\n<td><code>net/http.Client</code> with retry middleware and connection pooling</td>\n</tr>\n<tr>\n<td>URL Encoding</td>\n<td><code>url.QueryEscape()</code> for individual parameters</td>\n<td>Custom percent-encoding for binary data compliance</td>\n</tr>\n<tr>\n<td>Response Parsing</td>\n<td>Reuse existing Bencode decoder</td>\n<td>Streaming Bencode parser for large peer lists</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>Single goroutine with timer-based scheduling</td>\n<td>Worker pool with priority queue for multiple trackers</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Simple retry with fixed delays</td>\n<td>Exponential backoff with jitter and circuit breaker</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/tracker/\n  client.go              ← main tracker client implementation\n  client_test.go         ← unit tests for tracker communication\n  announce.go            ← announce request/response structures\n  peers.go               ← peer list parsing and management\n  errors.go              ← tracker-specific error types\ncmd/torrent-client/\n  main.go                ← integrates tracker client with overall application</code></pre></div>\n\n<h4 id=\"infrastructure-code-http-client-and-url-encoding\">Infrastructure Code: HTTP Client and URL Encoding</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package tracker provides BitTorrent tracker communication functionality</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> tracker</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/url</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HTTPClient wraps net/http.Client with BitTorrent-specific configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HTTPClient</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewHTTPClient creates an HTTP client configured for tracker communication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewHTTPClient</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPClient</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">HTTPClient</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        client: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Timeout: </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Transport: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Transport</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                MaxIdleConns:        </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                IdleConnTimeout:     </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                DisableCompression:  </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Bencode responses don't compress well</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                MaxIdleConnsPerHost: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get performs an HTTP GET request with proper error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">url</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewRequestWithContext</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">, url, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating request: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set User-Agent to identify our BitTorrent client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req.Header.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"User-Agent\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"go-torrent-client/1.0\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resp, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> h.client.</span><span style=\"color:#B392F0\">Do</span><span style=\"color:#E1E4E8\">(req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"executing request: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> resp.Body.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> resp.StatusCode </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.StatusOK {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"HTTP error: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, resp.StatusCode, resp.Status)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">ReadAll</span><span style=\"color:#E1E4E8\">(resp.Body)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reading response body: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> body, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// URLEncodeBinary performs percent-encoding for binary data (info_hash and peer_id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is more strict than url.QueryEscape() to ensure BitTorrent compatibility</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> URLEncodeBinary</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(data)</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// Worst case: all bytes need encoding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, b </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> data {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Unreserved characters: A-Z, a-z, 0-9, -, _, ., ~</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (b </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">A</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">Z</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> (b </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">a</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">z</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           (b </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">-</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">_</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           b </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">.</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">~</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(result, b)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(result, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">%</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(result, </span><span style=\"color:#9ECBFF\">\"0123456789ABCDEF\"</span><span style=\"color:#E1E4E8\">[b</span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(result, </span><span style=\"color:#9ECBFF\">\"0123456789ABCDEF\"</span><span style=\"color:#E1E4E8\">[b</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">(result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BackoffScheduler implements exponential backoff for failed requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BackoffScheduler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseDelay    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxDelay     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentDelay </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failures     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewBackoffScheduler creates a scheduler with sensible defaults for tracker communication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBackoffScheduler</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackoffScheduler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BackoffScheduler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        baseDelay:    </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxDelay:     </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentDelay: </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OnFailure records a failure and returns the next delay duration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackoffScheduler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">OnFailure</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.failures</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Exponential backoff with jitter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitter </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(b.currentDelay) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">rand.</span><span style=\"color:#B392F0\">Float64</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    delay </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> b.currentDelay </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> jitter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Double for next time, up to maximum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.currentDelay </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> b.currentDelay </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> b.maxDelay {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        b.currentDelay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b.maxDelay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> delay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OnSuccess resets the backoff state after a successful request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackoffScheduler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">OnSuccess</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.failures </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.currentDelay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b.baseDelay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-data-structures\">Core Data Structures</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// AnnounceRequest represents the parameters sent to a BitTorrent tracker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AnnounceRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash   [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\"> // SHA-1 hash of the torrent's info dictionary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PeerID     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\"> // Unique identifier for this client instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port       </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">      // TCP port this client listens on</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Uploaded   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">    // Total bytes uploaded to other peers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Downloaded </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">    // Total bytes downloaded from other peers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Left       </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">    // Bytes remaining to complete download</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Event      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">   // \"started\", \"completed\", \"stopped\", or empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AnnounceResponse represents the tracker's response to an announce request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AnnounceResponse</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Interval      </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Seconds until next announce</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Complete      </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Number of seeders (peers with complete file)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Incomplete    </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Number of leechers (peers downloading)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Peers         []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\"> // Compact peer list (6 bytes per peer)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FailureReason </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Error message if request failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PeerInfo represents a single peer's network address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PeerInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IP   [</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // IPv4 address in network byte order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">   // TCP port in host byte order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// String returns a human-readable representation of the peer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#B392F0\">PeerInfo</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, p.IP[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], p.IP[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], p.IP[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], p.IP[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], p.Port)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Client manages communication with BitTorrent trackers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Client</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    httpClient </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPClient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    backoff    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackoffScheduler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Tracker state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    announceURL   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastAnnounce  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nextAnnounce  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trackerID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Optional tracker-assigned ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-tracker-client-implementation\">Core Logic Skeleton: Tracker Client Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NewClient creates a tracker client for the given torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">announceURL</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        httpClient:  </span><span style=\"color:#B392F0\">NewHTTPClient</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        backoff:     </span><span style=\"color:#B392F0\">NewBackoffScheduler</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        announceURL: announceURL,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BuildAnnounceURL constructs the complete tracker URL with all required parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BuildAnnounceURL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> AnnounceRequest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse the base announce URL to separate base from existing query parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: URL-encode the binary info_hash using URLEncodeBinary function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: URL-encode the binary peer_id using URLEncodeBinary function  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Build query parameter string with all required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle optional event parameter (only include if not empty)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Include tracker_id if we received one from previous response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Add compact=1 to request compact peer format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Combine base URL with query parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use url.Values{} to build query parameters safely</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Don't use url.QueryEscape for info_hash/peer_id - use URLEncodeBinary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Announce sends an announce request to the tracker and parses the response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Announce</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> AnnounceRequest</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AnnounceResponse</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Build the complete announce URL using BuildAnnounceURL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send HTTP GET request using c.httpClient.Get with context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle HTTP errors and network timeouts appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse the response body as Bencode using existing decoder</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Extract announce response fields from Bencode dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for \"failure reason\" field and return error if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate that required fields (interval, peers) are present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Update c.lastAnnounce and c.nextAnnounce timestamps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Store tracker_id if provided for future requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Reset backoff scheduler on successful response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Reuse the Bencode decoder from milestone 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Return tracker errors (failure reason) as a distinct error type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseCompactPeers converts the binary peer list into PeerInfo structures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseCompactPeers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">compactPeers</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">PeerInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that peer list length is multiple of 6 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate number of peers from total length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create slice to hold parsed peer information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Iterate through compact peer data in 6-byte chunks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Extract 4-byte IP address in network byte order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Extract 2-byte port number in network byte order  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Convert port from big-endian to host byte order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Create PeerInfo struct and add to result slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Return completed peer list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use binary.BigEndian.Uint16() for port conversion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: IP address bytes can be copied directly (already in network order)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ScheduleNextAnnounce determines when the next announce should occur</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ScheduleNextAnnounce</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">interval</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate base next announce time as lastAnnounce + interval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add small random jitter (±10% of interval) to distribute load</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Ensure next announce is not in the past</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update c.nextAnnounce field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the scheduled time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use rand.Float64() for jitter calculation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: time.Now().Add() for time arithmetic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShouldAnnounce returns true if it's time to send another announce request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ShouldAnnounce</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Compare current time with c.nextAnnounce</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return true if current time is after scheduled announce time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle case where nextAnnounce is zero (first announce)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OnAnnounceError handles announce request failures with backoff</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">OnAnnounceError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Record the failure with backoff scheduler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Get the next retry delay from backoff.OnFailure()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update nextAnnounce to current time + retry delay</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log the error with appropriate detail level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the retry delay for caller information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Distinguish between different error types for logging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Network errors vs tracker errors may need different handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"testing-and-validation-checkpoints\">Testing and Validation Checkpoints</h4>\n<p>After implementing the tracker communication system, verify correct behavior with these checkpoints:</p>\n<p><strong>Unit Test Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/tracker/...</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>Expected test coverage should include:</p>\n<ul>\n<li>URL encoding of binary data (info_hash and peer_id)</li>\n<li>Compact peer list parsing with various list sizes</li>\n<li>Announce request parameter construction</li>\n<li>Error handling for malformed tracker responses</li>\n<li>Backoff scheduling behavior</li>\n</ul>\n<p><strong>Integration Test with Real Tracker:</strong></p>\n<ol>\n<li>Use a test torrent file with a known working tracker</li>\n<li>Send an announce request with <code>event=started</code></li>\n<li>Verify you receive a valid peer list in the response</li>\n<li>Check that the <code>interval</code> field contains a reasonable value (300-1800 seconds)</li>\n<li>Confirm peer IP addresses and ports are correctly parsed</li>\n</ol>\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Enable debug logging to see announce URLs being constructed</li>\n<li>Copy an announce URL and test it manually with <code>curl</code> - you should get Bencode response</li>\n<li>Verify that URL encoding produces valid HTTP URLs (no unescaped binary data)</li>\n<li>Check that periodic re-announce happens at the correct intervals</li>\n<li>Test error handling by using an invalid tracker URL</li>\n</ol>\n<p><strong>Common Issues and Debugging:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Invalid info_hash&quot; error</td>\n<td>Incorrect URL encoding of binary data</td>\n<td>Use URLEncodeBinary, not url.QueryEscape</td>\n</tr>\n<tr>\n<td>Empty peer list returned</td>\n<td>Torrent has no active peers, or announce parameters incorrect</td>\n<td>Test with popular torrent, verify all required parameters</td>\n</tr>\n<tr>\n<td>Connection timeouts</td>\n<td>Network issues or unresponsive tracker</td>\n<td>Implement proper timeout handling and retry logic</td>\n</tr>\n<tr>\n<td>Parse errors on response</td>\n<td>Tracker returned non-Bencode data</td>\n<td>Add response format validation before parsing</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fdownload-sequence.svg\" alt=\"Complete Download Flow\"></p>\n<p>The tracker communication implementation provides the foundation for peer discovery in our BitTorrent client. Once we can successfully retrieve peer lists from trackers, the next milestone will focus on establishing direct connections with those peers using the BitTorrent wire protocol.</p>\n<h2 id=\"peer-wire-protocol-milestone-3\">Peer Wire Protocol (Milestone 3)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 3 - Peer Protocol, implementing the BitTorrent peer wire protocol including handshakes, message framing, and state machines.</p>\n</blockquote>\n<p>After establishing communication with the tracker and discovering peers in Milestone 2, we now face the core challenge of the BitTorrent protocol: establishing direct peer-to-peer connections and coordinating the actual transfer of file data. The peer wire protocol is BitTorrent&#39;s application-layer communication standard that governs how peers handshake, exchange availability information, negotiate transfers, and maintain fair sharing relationships.</p>\n<p>The peer wire protocol operates over TCP connections and implements a sophisticated state machine that balances efficiency with fairness. Unlike simple client-server protocols, BitTorrent peers must simultaneously act as both clients (requesting data) and servers (providing data), while maintaining multiple concurrent connections and enforcing upload reciprocity through choking mechanisms.</p>\n<h3 id=\"peer-protocol-as-conversation-rules\">Peer Protocol as Conversation Rules</h3>\n<p>Think of the BitTorrent peer wire protocol like the formal conversation rules at a diplomatic dinner party. When diplomats from different countries meet, they follow established etiquette to ensure productive communication despite language barriers and cultural differences.</p>\n<p>The <strong>handshake</strong> is like the formal introduction where diplomats present their credentials and verify they&#39;re attending the same event (same torrent). They exchange names (peer IDs) and confirm they&#39;re discussing the same topic (info hash verification).</p>\n<p>The <strong>bitfield exchange</strong> is like each diplomat placing their briefcase contents on the table, showing what documents (pieces) they brought to share. This transparency allows everyone to see who has what information, enabling efficient negotiation.</p>\n<p>The <strong>choking and interest system</strong> mirrors diplomatic negotiation protocols. A diplomat might be &quot;interested&quot; in another&#39;s documents but &quot;choked&quot; (denied access) until they offer something valuable in return. The &quot;unchoke&quot; decision represents granting access based on reciprocal value exchange.</p>\n<p><strong>Message framing</strong> provides the structured communication format, like diplomatic protocols that specify how to format official communications with proper headers, lengths, and content organization to prevent misunderstandings.</p>\n<p>This analogy captures the essential challenge: BitTorrent peers must coordinate complex multi-party exchanges while maintaining fairness and preventing exploitation, just as diplomatic protocols enable cooperation between self-interested parties.</p>\n<h3 id=\"connection-handshake\">Connection Handshake</h3>\n<p>The BitTorrent handshake serves as the authentication and compatibility verification phase that must complete successfully before any data transfer can begin. This 68-byte message exchange ensures both peers are speaking the same protocol version and participating in the same torrent swarm.</p>\n<p>The handshake message format consists of five distinct components that provide comprehensive connection validation:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Length</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Protocol Length</td>\n<td>1 byte</td>\n<td>uint8</td>\n<td>Always 19 (length of &quot;BitTorrent protocol&quot;)</td>\n</tr>\n<tr>\n<td>Protocol String</td>\n<td>19 bytes</td>\n<td>ASCII</td>\n<td>Always &quot;BitTorrent protocol&quot;</td>\n</tr>\n<tr>\n<td>Reserved Bytes</td>\n<td>8 bytes</td>\n<td>uint64</td>\n<td>Feature flags (all zeros for basic implementation)</td>\n</tr>\n<tr>\n<td>Info Hash</td>\n<td>20 bytes</td>\n<td>[20]byte</td>\n<td>SHA-1 hash identifying the specific torrent</td>\n</tr>\n<tr>\n<td>Peer ID</td>\n<td>20 bytes</td>\n<td>[20]byte</td>\n<td>Unique identifier for the connecting peer</td>\n</tr>\n</tbody></table>\n<p>The handshake exchange follows a specific sequence that validates compatibility at each step:</p>\n<ol>\n<li><p><strong>Connection establishment</strong>: The initiating peer opens a TCP connection to the remote peer&#39;s IP and port (discovered from tracker).</p>\n</li>\n<li><p><strong>Handshake transmission</strong>: The initiator immediately sends the complete 68-byte handshake message without waiting for any response.</p>\n</li>\n<li><p><strong>Protocol validation</strong>: The receiving peer reads the first 20 bytes and verifies the protocol length (19) and protocol string (&quot;BitTorrent protocol&quot;) match expected values.</p>\n</li>\n<li><p><strong>Torrent validation</strong>: The receiving peer extracts the info hash from bytes 28-47 and confirms it matches a torrent they&#39;re actively sharing.</p>\n</li>\n<li><p><strong>Response handshake</strong>: If validation succeeds, the receiving peer sends back its own 68-byte handshake message with the same info hash but its own peer ID.</p>\n</li>\n<li><p><strong>Mutual validation</strong>: The initiating peer receives and validates the response handshake, confirming the info hash matches and noting the remote peer&#39;s ID.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Immediate Handshake Transmission</strong></p>\n<ul>\n<li><strong>Context</strong>: Handshake could wait for connection confirmation or send immediately after TCP establishment</li>\n<li><strong>Options Considered</strong>: Wait for explicit ready signal vs. immediate transmission vs. HTTP-style request/response</li>\n<li><strong>Decision</strong>: Send handshake immediately after TCP connection establishment</li>\n<li><strong>Rationale</strong>: Reduces round-trip latency, matches BitTorrent specification exactly, and simplifies state machine (no waiting state needed)</li>\n<li><strong>Consequences</strong>: Enables faster connection establishment but requires careful handling of partial reads during handshake parsing</li>\n</ul>\n</blockquote>\n<p>The info hash validation is the critical security check that prevents peers from different torrents from establishing connections. Since the info hash is computed from the exact bencoded bytes of the torrent&#39;s info dictionary, it serves as both a unique identifier and a cryptographic commitment to the specific file contents and structure being shared.</p>\n<p>Peer ID validation serves multiple purposes beyond simple identification. Well-formed peer IDs follow conventions that identify the BitTorrent client software and version, enabling peers to implement client-specific optimizations or compatibility workarounds. Our implementation should generate a recognizable peer ID that identifies our client while remaining unique across instances.</p>\n<p>The reserved bytes field provides extensibility for future protocol features like encryption, DHT support, or enhanced messaging. For a basic implementation, these bytes should be set to zero, but the field must be preserved during handshake forwarding to maintain protocol compatibility.</p>\n<p><strong>Handshake Error Conditions and Recovery:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Wrong protocol string</td>\n<td>String comparison mismatch</td>\n<td>Close connection immediately</td>\n</tr>\n<tr>\n<td>Unknown info hash</td>\n<td>Info hash not in active torrents</td>\n<td>Send handshake with error info hash</td>\n</tr>\n<tr>\n<td>Connection timeout</td>\n<td>No handshake received within 30s</td>\n<td>Close connection and retry</td>\n</tr>\n<tr>\n<td>Partial handshake</td>\n<td>TCP connection closed mid-handshake</td>\n<td>Log error and attempt reconnection</td>\n</tr>\n<tr>\n<td>Duplicate peer ID</td>\n<td>Same peer ID as local client</td>\n<td>Close connection (connecting to self)</td>\n</tr>\n</tbody></table>\n<h3 id=\"message-framing-and-parsing\">Message Framing and Parsing</h3>\n<p>After successful handshake completion, all subsequent communication uses the BitTorrent message framing format, which provides reliable message boundaries over the streaming TCP connection. This framing system must handle variable-length messages while maintaining parsing efficiency and error recovery capabilities.</p>\n<p>Every BitTorrent message (except the handshake) follows a standardized format that begins with a length prefix to enable proper message boundary detection:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Length</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Length</td>\n<td>4 bytes</td>\n<td>uint32 (big-endian)</td>\n<td>Total bytes in message (0 for keep-alive)</td>\n</tr>\n<tr>\n<td>Message ID</td>\n<td>1 byte</td>\n<td>uint8</td>\n<td>Message type identifier (omitted for keep-alive)</td>\n</tr>\n<tr>\n<td>Payload</td>\n<td>Variable</td>\n<td>bytes</td>\n<td>Message-specific data (length = Message Length - 1)</td>\n</tr>\n</tbody></table>\n<p>The message framing protocol defines nine standard message types that handle all peer communication needs:</p>\n<table>\n<thead>\n<tr>\n<th>Message ID</th>\n<th>Name</th>\n<th>Payload Length</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-</td>\n<td>keep-alive</td>\n<td>0 bytes</td>\n<td>Maintain connection (length = 0, no ID)</td>\n</tr>\n<tr>\n<td>0</td>\n<td>choke</td>\n<td>0 bytes</td>\n<td>Refuse to upload to peer</td>\n</tr>\n<tr>\n<td>1</td>\n<td>unchoke</td>\n<td>0 bytes</td>\n<td>Allow uploads to peer</td>\n</tr>\n<tr>\n<td>2</td>\n<td>interested</td>\n<td>0 bytes</td>\n<td>Want to download from peer</td>\n</tr>\n<tr>\n<td>3</td>\n<td>not interested</td>\n<td>0 bytes</td>\n<td>No longer want to download</td>\n</tr>\n<tr>\n<td>4</td>\n<td>have</td>\n<td>4 bytes</td>\n<td>Announce piece availability</td>\n</tr>\n<tr>\n<td>5</td>\n<td>bitfield</td>\n<td>Variable</td>\n<td>Announce complete piece availability</td>\n</tr>\n<tr>\n<td>6</td>\n<td>request</td>\n<td>12 bytes</td>\n<td>Request specific block of data</td>\n</tr>\n<tr>\n<td>7</td>\n<td>piece</td>\n<td>9 + block size</td>\n<td>Deliver requested block data</td>\n</tr>\n<tr>\n<td>8</td>\n<td>cancel</td>\n<td>12 bytes</td>\n<td>Cancel previous block request</td>\n</tr>\n</tbody></table>\n<p>The message parsing state machine must handle the streaming nature of TCP while maintaining message boundaries and providing robust error recovery:</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fmessage-parsing-flow.svg\" alt=\"Peer Message Parsing\"></p>\n<p><strong>Message Parsing Algorithm:</strong></p>\n<ol>\n<li><p><strong>Length Reading State</strong>: Read exactly 4 bytes from the TCP connection to get the message length field, handling partial reads by maintaining a read buffer.</p>\n</li>\n<li><p><strong>Length Validation</strong>: Verify the message length is reasonable (0 for keep-alive, 1-17 for standard messages, larger values only valid for bitfield and piece messages).</p>\n</li>\n<li><p><strong>Keep-Alive Detection</strong>: If length is 0, this is a keep-alive message. Reset connection timeout and return to length reading state.</p>\n</li>\n<li><p><strong>Message ID Reading</strong>: Read 1 byte for the message ID, validating it falls within the expected range (0-8 for standard protocol).</p>\n</li>\n<li><p><strong>Payload Length Calculation</strong>: Calculate payload length as (message length - 1) and validate it matches expected length for the message type.</p>\n</li>\n<li><p><strong>Payload Reading</strong>: Read exactly the calculated payload bytes, handling partial reads and maintaining progress state.</p>\n</li>\n<li><p><strong>Message Dispatch</strong>: Parse the complete message according to its type and dispatch to appropriate handler function.</p>\n</li>\n<li><p><strong>State Reset</strong>: Return to length reading state for the next message.</p>\n</li>\n</ol>\n<p>The parser must handle several challenging scenarios that arise from TCP&#39;s streaming nature and network reliability issues:</p>\n<blockquote>\n<p><strong>Critical Insight: Partial Read Handling</strong></p>\n<p>TCP provides a byte stream, not message boundaries. A single <code>Read()</code> call might return part of a message, multiple complete messages, or a combination. The parser must accumulate bytes across multiple reads and only dispatch complete messages.</p>\n</blockquote>\n<p><strong>Message Parsing State Management:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parser State</th>\n<th>Data Needed</th>\n<th>Next State</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ReadingLength</td>\n<td>4 bytes</td>\n<td>ReadingMessage or KeepAlive</td>\n<td>Connection closed, invalid length</td>\n</tr>\n<tr>\n<td>ReadingMessage</td>\n<td>Message Length bytes</td>\n<td>ReadingLength</td>\n<td>Connection closed, timeout</td>\n</tr>\n<tr>\n<td>KeepAlive</td>\n<td>0 bytes</td>\n<td>ReadingLength</td>\n<td>N/A</td>\n</tr>\n</tbody></table>\n<p>The message framer must maintain parsing state across multiple read operations, accumulating partial data until complete messages are available. This requires careful buffer management to avoid memory leaks while handling arbitrarily large messages (piece messages can be 16KB+).</p>\n<p><strong>Endianness Considerations:</strong></p>\n<p>All multi-byte integers in BitTorrent messages use big-endian (network) byte order. The message length, piece indices, block offsets, and block lengths must be converted from network byte order to host byte order during parsing and vice versa during message construction.</p>\n<p>⚠️ <strong>Pitfall: Partial Message Processing</strong>\nMany implementations incorrectly assume that a single TCP read will return a complete message. This works during testing with local connections but fails under network stress or with slow peers. Always accumulate bytes until you have a complete message before processing.</p>\n<h3 id=\"peer-state-management\">Peer State Management</h3>\n<p>BitTorrent peers maintain a four-flag state machine that governs upload and download permissions between connected peers. This state system implements the core game theory mechanism that incentivizes sharing and prevents freeloading by requiring reciprocal exchange.</p>\n<p>The peer state consists of four independent boolean flags that capture the bidirectional nature of BitTorrent relationships:</p>\n<table>\n<thead>\n<tr>\n<th>State Flag</th>\n<th>Direction</th>\n<th>Meaning</th>\n<th>Initial Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>am_choking</td>\n<td>Local → Remote</td>\n<td>We refuse to upload to peer</td>\n<td>true</td>\n</tr>\n<tr>\n<td>am_interested</td>\n<td>Local → Remote</td>\n<td>We want to download from peer</td>\n<td>false</td>\n</tr>\n<tr>\n<td>peer_choking</td>\n<td>Remote → Local</td>\n<td>Peer refuses to upload to us</td>\n<td>true</td>\n</tr>\n<tr>\n<td>peer_interested</td>\n<td>Remote → Local</td>\n<td>Peer wants to download from us</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<p>These flags combine to determine the actual data transfer permissions and drive the message exchange patterns between peers:</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fpeer-state-machine.svg\" alt=\"Peer Connection State Machine\"></p>\n<p><strong>State Transition Rules:</strong></p>\n<p>The state machine transitions occur in response to specific message types and local decision-making algorithms:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Message/Event</th>\n<th>New State</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>am_choking=true</td>\n<td>Send unchoke</td>\n<td>am_choking=false</td>\n<td>Allow uploads to peer</td>\n</tr>\n<tr>\n<td>am_choking=false</td>\n<td>Send choke</td>\n<td>am_choking=true</td>\n<td>Block uploads to peer</td>\n</tr>\n<tr>\n<td>am_interested=false</td>\n<td>Local decision</td>\n<td>am_interested=true</td>\n<td>Send interested message</td>\n</tr>\n<tr>\n<td>am_interested=true</td>\n<td>Local decision</td>\n<td>am_interested=false</td>\n<td>Send not interested</td>\n</tr>\n<tr>\n<td>peer_choking=true</td>\n<td>Receive unchoke</td>\n<td>peer_choking=false</td>\n<td>Can send requests</td>\n</tr>\n<tr>\n<td>peer_choking=false</td>\n<td>Receive choke</td>\n<td>peer_choking=true</td>\n<td>Cancel pending requests</td>\n</tr>\n<tr>\n<td>peer_interested=false</td>\n<td>Receive interested</td>\n<td>peer_interested=true</td>\n<td>Consider unchoking</td>\n</tr>\n<tr>\n<td>peer_interested=true</td>\n<td>Receive not interested</td>\n<td>peer_interested=false</td>\n<td>May choke peer</td>\n</tr>\n</tbody></table>\n<p>The combination of these flags determines the operational mode of the peer relationship:</p>\n<p><strong>Operational Modes:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Mode</th>\n<th>Conditions</th>\n<th>Upload Allowed</th>\n<th>Download Allowed</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mutual Exchange</td>\n<td>!am_choking &amp;&amp; !peer_choking &amp;&amp; am_interested &amp;&amp; peer_interested</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Optimal trading state</td>\n</tr>\n<tr>\n<td>Uploading Only</td>\n<td>!am_choking &amp;&amp; peer_choking &amp;&amp; !am_interested &amp;&amp; peer_interested</td>\n<td>Yes</td>\n<td>No</td>\n<td>Seeding to downloader</td>\n</tr>\n<tr>\n<td>Downloading Only</td>\n<td>am_choking &amp;&amp; !peer_choking &amp;&amp; am_interested &amp;&amp; !peer_interested</td>\n<td>No</td>\n<td>Yes</td>\n<td>Receiving from seeder</td>\n</tr>\n<tr>\n<td>Idle Connection</td>\n<td>am_choking &amp;&amp; peer_choking</td>\n<td>No</td>\n<td>No</td>\n<td>Maintaining connection</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Four-Flag State Model</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to track bidirectional choking and interest state between peers</li>\n<li><strong>Options Considered</strong>: Single combined state enum vs. separate directional flags vs. simplified choke-only model</li>\n<li><strong>Decision</strong>: Four independent boolean flags (am_choking, am_interested, peer_choking, peer_interested)</li>\n<li><strong>Rationale</strong>: Matches BitTorrent specification exactly, enables independent state transitions, simplifies message handling logic</li>\n<li><strong>Consequences</strong>: Requires careful synchronization but provides full protocol compliance and optimal flexibility</li>\n</ul>\n</blockquote>\n<p><strong>Interest Determination Algorithm:</strong></p>\n<p>The <code>am_interested</code> flag should be updated whenever the peer&#39;s available pieces change or our local needs change:</p>\n<ol>\n<li><p><strong>Bitfield Analysis</strong>: When receiving a peer&#39;s initial bitfield, check if they have any pieces we need.</p>\n</li>\n<li><p><strong>Have Message Processing</strong>: When peer announces a new piece via <code>have</code> message, check if we need that specific piece.</p>\n</li>\n<li><p><strong>Local Completion</strong>: When we complete a piece, check if we still need any pieces the peer has.</p>\n</li>\n<li><p><strong>Interest Update</strong>: Send <code>interested</code> or <code>not interested</code> message only when the interest state actually changes.</p>\n</li>\n</ol>\n<p><strong>Choking Decision Algorithm:</strong></p>\n<p>The choking decisions implement BitTorrent&#39;s incentive mechanism and should balance fairness with performance:</p>\n<ol>\n<li><p><strong>Reciprocity Analysis</strong>: Prefer to unchoke peers who are uploading to us at good rates.</p>\n</li>\n<li><p><strong>Optimistic Unchoking</strong>: Periodically unchoke a random peer to discover better trading partners.</p>\n</li>\n<li><p><strong>Seeding Strategy</strong>: When seeding (we have all pieces), unchoke peers with the best download rates to maximize distribution efficiency.</p>\n</li>\n<li><p><strong>Connection Limits</strong>: Maintain reasonable limits on simultaneously unchoked peers (typically 4-5) to prevent connection overload.</p>\n</li>\n</ol>\n<p>The state machine must handle message ordering carefully, as network delays can cause messages to arrive out of expected sequence. For example, a peer might send a <code>request</code> message just before receiving our <code>choke</code> message, requiring graceful handling of this race condition.</p>\n<h3 id=\"request-pipelining\">Request Pipelining</h3>\n<p>Request pipelining allows BitTorrent clients to maintain multiple outstanding block requests simultaneously, dramatically improving download throughput by overlapping network round-trip times with data transmission. Without pipelining, the client would wait for each 16KB block to arrive before requesting the next one, severely limiting throughput on high-latency connections.</p>\n<p>The pipelining system must carefully balance throughput optimization with resource management and fairness considerations. Too few outstanding requests waste bandwidth due to round-trip delays, while too many requests consume excessive memory and can overwhelm slower peers.</p>\n<p><strong>Request Pipeline Architecture:</strong></p>\n<p>Each peer connection maintains a request pipeline that tracks outstanding requests and manages the flow of new requests based on network conditions and peer capabilities:</p>\n<table>\n<thead>\n<tr>\n<th>Pipeline Component</th>\n<th>Purpose</th>\n<th>Typical Size</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Outstanding Requests</td>\n<td>Map of sent but not received requests</td>\n<td>5-10 requests</td>\n</tr>\n<tr>\n<td>Request Queue</td>\n<td>Prepared requests waiting to send</td>\n<td>20-50 requests</td>\n</tr>\n<tr>\n<td>Receive Buffer</td>\n<td>Arriving piece data being assembled</td>\n<td>16KB per request</td>\n</tr>\n<tr>\n<td>Timeout Tracker</td>\n<td>Monitors request response times</td>\n<td>Per-request timers</td>\n</tr>\n</tbody></table>\n<p><strong>Request Message Format:</strong></p>\n<p>Each request message specifies exactly which 16KB block is needed from a specific piece:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Length</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece Index</td>\n<td>4 bytes</td>\n<td>uint32</td>\n<td>Which piece contains the desired block</td>\n</tr>\n<tr>\n<td>Block Offset</td>\n<td>4 bytes</td>\n<td>uint32</td>\n<td>Byte offset within the piece</td>\n</tr>\n<tr>\n<td>Block Length</td>\n<td>4 bytes</td>\n<td>uint32</td>\n<td>Number of bytes requested (typically 16384)</td>\n</tr>\n</tbody></table>\n<p>The request pipelining algorithm coordinates multiple concurrent block downloads while maintaining proper flow control:</p>\n<p><strong>Pipeline Management Algorithm:</strong></p>\n<ol>\n<li><p><strong>Pipeline Capacity Check</strong>: Determine how many additional requests can be sent based on current outstanding count and peer capacity.</p>\n</li>\n<li><p><strong>Block Selection</strong>: Choose the next needed blocks from the piece selection algorithm, prioritizing blocks from pieces that are already partially downloaded.</p>\n</li>\n<li><p><strong>Request Transmission</strong>: Send request messages for selected blocks, recording each request with timestamp and expected response size.</p>\n</li>\n<li><p><strong>Response Processing</strong>: When piece messages arrive, match them to outstanding requests, validate block data, and update pipeline state.</p>\n</li>\n<li><p><strong>Timeout Handling</strong>: Periodically check for requests that have exceeded reasonable response times and re-request from other peers.</p>\n</li>\n<li><p><strong>Pipeline Refill</strong>: Continuously add new requests to maintain optimal pipeline depth based on network conditions.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Adaptive Pipeline Depth</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to optimize throughput while avoiding peer overload and memory exhaustion</li>\n<li><strong>Options Considered</strong>: Fixed pipeline depth vs. adaptive sizing vs. unlimited pipelining</li>\n<li><strong>Decision</strong>: Adaptive pipeline sizing based on peer performance and network conditions</li>\n<li><strong>Rationale</strong>: Fixed depth wastes opportunities with fast peers and overloads slow peers; adaptive sizing maximizes efficiency</li>\n<li><strong>Consequences</strong>: Requires performance monitoring and dynamic adjustment but provides optimal throughput across diverse network conditions</li>\n</ul>\n</blockquote>\n<p><strong>Pipeline Depth Calculation:</strong></p>\n<p>The optimal pipeline depth depends on the bandwidth-delay product of the connection and the peer&#39;s processing capacity:</p>\n<ol>\n<li><p><strong>Bandwidth Estimation</strong>: Monitor the peer&#39;s actual data delivery rate over recent time windows.</p>\n</li>\n<li><p><strong>Latency Measurement</strong>: Track round-trip times between request messages and corresponding piece messages.</p>\n</li>\n<li><p><strong>Capacity Calculation</strong>: Estimate how many blocks should be in-flight to maintain continuous data flow: <code>pipeline_depth = (bandwidth * round_trip_time) / block_size</code>.</p>\n</li>\n<li><p><strong>Peer Limits</strong>: Respect any peer-advertised limits on concurrent requests and avoid overwhelming slower peers.</p>\n</li>\n<li><p><strong>Memory Constraints</strong>: Cap pipeline depth based on available memory for buffering outstanding requests.</p>\n</li>\n</ol>\n<p><strong>Request Timeout and Recovery:</strong></p>\n<p>Network issues and peer problems can cause some requests to be lost or delayed indefinitely. The pipeline must detect these situations and recover gracefully:</p>\n<table>\n<thead>\n<tr>\n<th>Timeout Condition</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Slow Response</td>\n<td>Request age &gt; 2 * average RTT</td>\n<td>Mark as slow, reduce pipeline depth</td>\n</tr>\n<tr>\n<td>Lost Request</td>\n<td>Request age &gt; 60 seconds</td>\n<td>Cancel and re-request from different peer</td>\n</tr>\n<tr>\n<td>Peer Disconnect</td>\n<td>TCP connection closed</td>\n<td>Cancel all requests, redistribute to other peers</td>\n</tr>\n<tr>\n<td>Invalid Response</td>\n<td>Piece data fails validation</td>\n<td>Re-request block, potential peer ban</td>\n</tr>\n</tbody></table>\n<p><strong>Endgame Mode Considerations:</strong></p>\n<p>When downloading the final pieces of a torrent, the standard rarest-first selection may result in only a few peers having the remaining pieces. In this situation, endgame mode modifies the pipelining strategy:</p>\n<ol>\n<li><p><strong>Redundant Requests</strong>: Send requests for the same blocks to multiple peers to avoid stalling on slow responses.</p>\n</li>\n<li><p><strong>Cancel Propagation</strong>: When a block arrives, immediately send cancel messages to other peers for the same block to avoid wasted bandwidth.</p>\n</li>\n<li><p><strong>Aggressive Timeouts</strong>: Use shorter timeout periods since completion is prioritized over bandwidth efficiency.</p>\n</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Memory Leaks in Pipeline Management</strong>\nOutstanding request tracking must carefully manage memory allocation and cleanup. Failed to cancel requests on peer disconnection leads to memory leaks, while failed to remove completed requests causes unbounded memory growth.</p>\n<h3 id=\"common-protocol-pitfalls\">Common Protocol Pitfalls</h3>\n<p>The BitTorrent peer wire protocol contains several subtle requirements and edge cases that frequently trip up implementers. These pitfalls often manifest as connection failures, poor performance, or protocol violations that cause other clients to disconnect.</p>\n<p>⚠️ <strong>Pitfall: Endianness Confusion</strong></p>\n<p><strong>Problem</strong>: All multi-byte integers in BitTorrent messages use big-endian (network) byte order, but many developers forget to convert between network and host byte order when parsing or constructing messages.</p>\n<p><strong>Symptoms</strong>: Message parsing fails with apparently random values, piece indices seem impossibly large, or length fields cause buffer overruns.</p>\n<p><strong>Example</strong>: A 4-byte piece index of <code>0x00000001</code> (piece 1) appears as <code>0x01000000</code> (piece 16777216) on little-endian systems without proper conversion.</p>\n<p><strong>Fix</strong>: Always use proper byte order conversion functions (<code>binary.BigEndian</code> in Go) when reading or writing multi-byte fields in protocol messages.</p>\n<p>⚠️ <strong>Pitfall: Partial TCP Read Handling</strong></p>\n<p><strong>Problem</strong>: Assuming that a single TCP <code>read()</code> call returns a complete message. TCP is a stream protocol and may deliver data in arbitrary chunks unrelated to message boundaries.</p>\n<p><strong>Symptoms</strong>: Messages appear truncated, parsing fails intermittently (especially under load), or the client works locally but fails with remote peers.</p>\n<p><strong>Example</strong>: A 17KB piece message might arrive as three separate reads of 8KB, 8KB, and 1KB, requiring accumulation across multiple read operations.</p>\n<p><strong>Fix</strong>: Always accumulate bytes until you have a complete message. Maintain parsing state across multiple read operations and only process complete messages.</p>\n<p>⚠️ <strong>Pitfall: Blocking on Choked Peers</strong></p>\n<p><strong>Problem</strong>: Sending request messages to peers who have choked us, or failing to cancel outstanding requests when a peer sends a choke message.</p>\n<p><strong>Symptoms</strong>: Download stalls even though peers are connected, requests time out repeatedly, or peers disconnect due to protocol violations.</p>\n<p><strong>Example</strong>: Peer sends choke message but client continues sending request messages, violating the protocol and causing the peer to close the connection.</p>\n<p><strong>Fix</strong>: Immediately cancel all outstanding requests when receiving a choke message, and only send new requests to peers who are not choking us.</p>\n<p>⚠️ <strong>Pitfall: Handshake Validation Ordering</strong></p>\n<p><strong>Problem</strong>: Performing handshake validation checks in the wrong order or with incorrect byte ranges, leading to connection establishment failures.</p>\n<p><strong>Symptoms</strong>: All incoming connections fail with protocol errors, connections work with some clients but not others, or info hash mismatches are reported.</p>\n<p><strong>Example</strong>: Reading the info hash from bytes 20-39 instead of bytes 28-47, causing validation to fail against random data from the reserved bytes field.</p>\n<p><strong>Fix</strong>: Follow the exact handshake format: 1 byte length + 19 bytes protocol string + 8 bytes reserved + 20 bytes info hash + 20 bytes peer ID.</p>\n<p>⚠️ <strong>Pitfall: State Machine Synchronization Errors</strong></p>\n<p><strong>Problem</strong>: Updating peer state flags inconsistently or failing to synchronize state changes with message transmission, leading to desynchronized state machines between peers.</p>\n<p><strong>Symptoms</strong>: Peers appear to be in impossible states, upload/download permissions don&#39;t match message exchange, or connections deadlock.</p>\n<p><strong>Example</strong>: Setting <code>am_choking = false</code> locally but forgetting to send the unchoke message, causing state desynchronization.</p>\n<p><strong>Fix</strong>: Always update local state and send corresponding messages atomically. Never change state flags without sending appropriate protocol messages.</p>\n<p>⚠️ <strong>Pitfall: Request Pipeline Memory Management</strong></p>\n<p><strong>Problem</strong>: Failing to properly cleanup outstanding requests when peers disconnect, or not limiting pipeline depth based on available memory.</p>\n<p><strong>Symptoms</strong>: Memory usage grows unboundedly during downloads, request timeouts don&#39;t trigger cleanup, or the client crashes with out-of-memory errors.</p>\n<p><strong>Example</strong>: Peer disconnects with 50 outstanding 16KB requests, but the request tracking structures are never cleaned up, leaking 800KB per disconnection.</p>\n<p><strong>Fix</strong>: Implement proper resource cleanup on peer disconnection and enforce reasonable limits on concurrent outstanding requests based on available memory.</p>\n<p>⚠️ <strong>Pitfall: Keep-Alive Timing Issues</strong></p>\n<p><strong>Problem</strong>: Not sending keep-alive messages during idle periods, or failing to reset connection timeouts when receiving keep-alive messages.</p>\n<p><strong>Symptoms</strong>: Connections drop unexpectedly during periods of no data transfer, peers disconnect after exactly 2-3 minutes of inactivity.</p>\n<p><strong>Example</strong>: During endgame phase when few requests are being sent, connections time out because no keep-alive messages are transmitted.</p>\n<p><strong>Fix</strong>: Send keep-alive messages (zero-length messages) every 2 minutes when no other messages have been sent, and reset timeout timers when receiving any message including keep-alives.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides the practical foundation for implementing the BitTorrent peer wire protocol, focusing on TCP connection management, message parsing infrastructure, and state tracking systems that enable robust peer communication.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP Networking</td>\n<td>net.Conn with basic read/write</td>\n<td>Custom connection pooling with bufio</td>\n</tr>\n<tr>\n<td>Message Parsing</td>\n<td>Manual byte slicing</td>\n<td>Protocol buffer style parser</td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>Simple struct with mutexes</td>\n<td>Actor model with message channels</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>One goroutine per peer</td>\n<td>Worker pool with shared connections</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Basic error returns</td>\n<td>Structured error types with recovery</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<p>The peer protocol implementation should be organized to separate networking concerns from protocol logic:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/peer/\n  connection.go           ← TCP connection management and handshake\n  message.go             ← Message parsing and framing\n  protocol.go            ← Peer state machine and protocol logic\n  pipeline.go            ← Request pipelining and flow control\n  connection_test.go     ← Connection and handshake tests\n  message_test.go        ← Message parsing tests\n  protocol_test.go       ← State machine and integration tests\ninternal/wire/\n  messages.go            ← Message type definitions and constants\n  framer.go             ← Message framing utilities</code></pre></div>\n\n<p><strong>Core Infrastructure - Complete Message Framing System:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> wire</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Message type constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgKeepAlive</span><span style=\"color:#F97583\">    =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#6A737D\">  // Special case for keep-alive (no ID)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgChoke</span><span style=\"color:#F97583\">        =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgUnchoke</span><span style=\"color:#F97583\">      =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgInterested</span><span style=\"color:#F97583\">   =</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgNotInterested</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgHave</span><span style=\"color:#F97583\">         =</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgBitfield</span><span style=\"color:#F97583\">     =</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgRequest</span><span style=\"color:#F97583\">      =</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgPiece</span><span style=\"color:#F97583\">        =</span><span style=\"color:#79B8FF\"> 7</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgCancel</span><span style=\"color:#F97583\">       =</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HANDSHAKE_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 68</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PROTOCOL_STRING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"BitTorrent protocol\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCK_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 16384</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_MESSAGE_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#6A737D\">  // piece message with full block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Message represents a parsed BitTorrent protocol message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Payload []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MessageFramer handles reading and writing length-prefixed messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageFramer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn   </span><span style=\"color:#B392F0\">io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ReadWriter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // Reusable buffer for parsing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMessageFramer creates a message framer for the given connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMessageFramer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">conn</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ReadWriter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageFramer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MessageFramer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        conn:   conn,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, MAX_MESSAGE_LENGTH</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#6A737D\">// +4 for length prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadMessage reads and parses the next message from the connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageFramer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadMessage</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read 4-byte length prefix</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">ReadFull</span><span style=\"color:#E1E4E8\">(mf.conn, mf.buffer[:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reading message length: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(mf.buffer[:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle keep-alive message (length = 0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">{ID: MsgKeepAlive, Payload: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate message length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_MESSAGE_LENGTH {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"message too large: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">, length)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read message ID + payload</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">ReadFull</span><span style=\"color:#E1E4E8\">(mf.conn, mf.buffer[:length]); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reading message body: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(mf.buffer[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, length</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(payload, mf.buffer[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:length])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">{ID: messageID, Payload: payload}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteMessage writes a message to the connection with proper framing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageFramer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> msg.ID </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> MsgKeepAlive {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Keep-alive: just write 4 zero bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(mf.buffer[:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mf.conn.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(mf.buffer[:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messageLength </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(msg.Payload) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// +1 for message ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(mf.buffer[:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], messageLength)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mf.buffer[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(msg.ID)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(mf.buffer[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">:], msg.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mf.conn.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(mf.buffer[:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">messageLength])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Handshake represents the initial 68-byte handshake message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Handshake</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PeerID   [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MarshalBinary serializes handshake to 68-byte wire format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Handshake</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MarshalBinary</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, HANDSHAKE_LENGTH)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 19</span><span style=\"color:#6A737D\">  // Protocol string length</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">], PROTOCOL_STRING)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // buf[20:28] reserved bytes (already zero)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">48</span><span style=\"color:#E1E4E8\">], h.InfoHash[:])</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">48</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">68</span><span style=\"color:#E1E4E8\">], h.PeerID[:])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UnmarshalBinary parses 68-byte handshake from wire format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Handshake</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UnmarshalBinary</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> HANDSHAKE_LENGTH {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid handshake length: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(data))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 19</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid protocol length: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">(data[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> PROTOCOL_STRING {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid protocol string: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, data[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(h.InfoHash[:], data[</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">48</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(h.PeerID[:], data[</span><span style=\"color:#79B8FF\">48</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">68</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Infrastructure - Bitfield Operations:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> peer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BitfieldOps provides efficient operations on piece availability bitfields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BitfieldOps</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitfield  []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    numPieces </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewBitfieldOps creates a bitfield for the specified number of pieces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBitfieldOps</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">numPieces</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    byteCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (numPieces </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#6A737D\">  // Round up to nearest byte</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bitfield:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, byteCount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        numPieces: numPieces,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetPiece marks a piece as available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetPiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> bf.numPieces {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    byteIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bf.bitfield[byteIndex] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#F97583\"> >></span><span style=\"color:#E1E4E8\"> bitIndex)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HasPiece returns true if the specified piece is available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HasPiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> bf.numPieces {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    byteIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (bf.bitfield[byteIndex] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#F97583\"> >></span><span style=\"color:#E1E4E8\"> bitIndex)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CountAvailablePieces returns the number of pieces marked as available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CountAvailablePieces</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> bf.numPieces; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> bf.</span><span style=\"color:#B392F0\">HasPiece</span><span style=\"color:#E1E4E8\">(i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bytes returns the raw bitfield bytes for transmission</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bf </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Bytes</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(bf.bitfield))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(result, bf.bitfield)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton - Peer Connection Management:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> peer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Connection represents a single peer connection with full state tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Connection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn     </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Conn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    framer   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">wire</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MessageFramer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Peer identification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerID   [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    infoHash [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // State machine flags</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amChoking       </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amInterested    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerChoking     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerInterested  </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Piece availability</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitfield </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Request pipeline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pendingRequests </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PendingRequest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxPipeline     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Synchronization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx    </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PendingRequest tracks an outstanding block request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PendingRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceIndex  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Offset      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RequestTime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewConnection creates a new peer connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">conn</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Conn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">infoHash</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">peerID</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        conn:            conn,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        framer:          wire.</span><span style=\"color:#B392F0\">NewMessageFramer</span><span style=\"color:#E1E4E8\">(conn),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        infoHash:        infoHash,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peerID:          peerID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        amChoking:       </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\">// Start choked</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        amInterested:    </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Start not interested</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peerChoking:     </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\">// Assume peer starts choked</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peerInterested:  </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Assume peer starts not interested</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pendingRequests: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PendingRequest</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxPipeline:     </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">,      </span><span style=\"color:#6A737D\">// Conservative initial pipeline depth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ctx:             ctx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cancel:          cancel,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PerformHandshake executes the BitTorrent handshake protocol</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PerformHandshake</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create handshake message with our info hash and peer ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send handshake to peer using conn.Write()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read 68-byte response using io.ReadFull()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse response handshake and validate protocol string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify info hash matches our torrent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store peer's ID for future reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use wire.Handshake struct and its marshal/unmarshal methods</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement handshake\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateInterest updates our interested state based on peer's available pieces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateInterest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">neededPieces</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if peer has any pieces we need using bitfield.HasPiece()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Determine new interested state (true if any needed pieces available)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If interest state changed, send appropriate message (interested/not interested)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update amInterested flag to match new state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Only send message if state actually changes to avoid redundant traffic</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement interest updating\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SendRequest sends a block request if peer is unchoked and pipeline has capacity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SendRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if peer is choking us (peer_choking flag)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if we have pipeline capacity (len(pendingRequests) &#x3C; maxPipeline)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create request message with piece index, offset, length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Send request message using framer.WriteMessage()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add request to pendingRequests map for tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Record request time for timeout detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use fmt.Sprintf(\"%d-%d-%d\", pieceIndex, offset, length) as request key</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement request sending\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessMessage handles incoming messages from the peer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">wire</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> msg.ID {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgChoke:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handleChoke</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgUnchoke:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handleUnchoke</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgInterested:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handleInterested</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgNotInterested:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handleNotInterested</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgHave:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handleHave</span><span style=\"color:#E1E4E8\">(msg.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgBitfield:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handleBitfield</span><span style=\"color:#E1E4E8\">(msg.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgRequest:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handleRequest</span><span style=\"color:#E1E4E8\">(msg.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgPiece:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handlePiece</span><span style=\"color:#E1E4E8\">(msg.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> wire.MsgCancel:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">handleCancel</span><span style=\"color:#E1E4E8\">(msg.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unknown message type: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, msg.ID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleChoke processes incoming choke message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleChoke</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set peerChoking flag to true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Cancel all pending requests (clear pendingRequests map)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Notify piece manager that requests were cancelled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Choking means peer won't fulfill our requests, so clean up pipeline</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement choke handling\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleUnchoke processes incoming unchoke message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleUnchoke</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set peerChoking flag to false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Notify piece manager that we can now send requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Unchoking enables request sending, but don't automatically send requests here</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement unchoke handling\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CanDownload returns true if we can request blocks from this peer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CanDownload</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that we're interested in peer's pieces (amInterested)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check that peer is not choking us (peerChoking == false)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return true only if both conditions are met</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement download capability check\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ul>\n<li><p><strong>TCP Connection Management</strong>: Use <code>net.Dial()</code> for outgoing connections and <code>net.Listen()</code> for incoming connections. Set reasonable timeouts with <code>SetDeadline()</code> methods.</p>\n</li>\n<li><p><strong>Binary Protocol Parsing</strong>: Use <code>encoding/binary</code> package with <code>binary.BigEndian</code> for all multi-byte integer conversions. Use <code>io.ReadFull()</code> to ensure complete reads.</p>\n</li>\n<li><p><strong>Concurrency</strong>: Use separate goroutines for reading and writing messages. Protect shared state with <code>sync.RWMutex</code> - use read locks for queries and write locks for modifications.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Distinguish between recoverable errors (temporary network issues) and fatal errors (protocol violations). Use context cancellation for graceful shutdown.</p>\n</li>\n<li><p><strong>Memory Management</strong>: Reuse message buffers where possible to reduce garbage collection pressure. Use buffer pools for frequently allocated/deallocated structures.</p>\n</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the peer wire protocol, verify the following behavior:</p>\n<ol>\n<li><strong>Handshake Verification</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/client/main.go</span><span style=\"color:#9ECBFF\"> handshake</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">torrent-fil</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#F97583\">></span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">peer-i</span><span style=\"color:#E1E4E8\">p</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">peer-por</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should output: \"Handshake successful: peer ID &#x3C;hex-encoded-peer-id>\"</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><p><strong>Message Exchange Test</strong>:</p>\n<ul>\n<li>Connect to a peer and complete handshake</li>\n<li>Receive and parse bitfield message</li>\n<li>Send interested message if peer has needed pieces</li>\n<li>Verify state transitions occur correctly</li>\n</ul>\n</li>\n<li><p><strong>Pipeline Test</strong>:</p>\n<ul>\n<li>Send multiple request messages to an unchoked peer</li>\n<li>Verify requests are tracked in pending requests map</li>\n<li>Process incoming piece messages and match to requests</li>\n<li>Confirm pipeline refills automatically</li>\n</ul>\n</li>\n</ol>\n<p><strong>Expected Output Examples:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>INFO: Connecting to peer 192.168.1.100:6881\nINFO: Handshake completed, peer ID: 2d5458333030302d787878787878787878\nINFO: Received bitfield: peer has 847/1000 pieces\nINFO: Sent interested message (peer has pieces we need)\nINFO: Received unchoke message, can now download\nINFO: Sent 5 requests, pipeline full\nINFO: Received piece 0 block 0 (16384 bytes)\nINFO: Pipeline refilled, sent request for piece 0 block 1</code></pre></div>\n\n<p><strong>Common Implementation Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Handshake always fails</td>\n<td>Wrong byte offsets in parsing</td>\n<td>Use exact offsets: info hash at 28-47, peer ID at 48-67</td>\n</tr>\n<tr>\n<td>Messages appear corrupted</td>\n<td>Missing endianness conversion</td>\n<td>Use binary.BigEndian for all multi-byte fields</td>\n</tr>\n<tr>\n<td>Download stalls after start</td>\n<td>Sending requests to choked peers</td>\n<td>Check peerChoking flag before sending requests</td>\n</tr>\n<tr>\n<td>Memory usage grows continuously</td>\n<td>Not cleaning up disconnected peers</td>\n<td>Implement proper connection cleanup with context cancellation</td>\n</tr>\n<tr>\n<td>Connections drop frequently</td>\n<td>Missing keep-alive messages</td>\n<td>Send keep-alive every 2 minutes during idle periods</td>\n</tr>\n</tbody></table>\n<h2 id=\"piece-management-amp-seeding-milestone-4\">Piece Management &amp; Seeding (Milestone 4)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 4 - Piece Management &amp; Seeding, implementing piece verification, download scheduling, and upload capabilities for complete BitTorrent functionality.</p>\n</blockquote>\n<p>The final milestone transforms our BitTorrent client from a simple peer protocol implementation into a fully functional file-sharing system. This phase introduces the sophisticated orchestration layer that coordinates concurrent downloads, verifies data integrity, schedules piece requests efficiently, and serves data to other peers. The challenge lies in managing the complex interplay between multiple concurrent peer connections while ensuring data correctness and optimal download performance.</p>\n<h3 id=\"piece-management-as-jigsaw-puzzle\">Piece Management as Jigsaw Puzzle</h3>\n<p>Think of piece management as coordinating a massive <strong>collaborative jigsaw puzzle</strong> where multiple people work together to assemble a picture, but with several critical constraints. Each person (peer) has different puzzle pieces available, some pieces might be damaged and need replacement, and you want to prioritize the rarest pieces first to ensure the puzzle can be completed even if people leave.</p>\n<p>In this analogy, each <strong>piece</strong> represents a fixed-size chunk of the file with a unique verification code (SHA1 hash) that proves it&#39;s the correct piece. The <strong>puzzle box</strong> (torrent metadata) tells you exactly what each completed piece should look like. <strong>Multiple helpers</strong> (peers) each have different subsets of pieces, and you need to coordinate requests so that you&#39;re not asking the same person for pieces they don&#39;t have, while ensuring you get the rarest pieces before common ones.</p>\n<p>The key insight is that unlike a physical puzzle, digital pieces can be <strong>copied</strong> rather than moved, so successful completion helps everyone else by making pieces more available. However, pieces can also be <strong>corrupted</strong> in transit, requiring verification against the expected hash before acceptance.</p>\n<p>This mental model captures the essential challenges: <strong>availability tracking</strong> (knowing who has which pieces), <strong>request coordination</strong> (avoiding duplicate work), <strong>rarity-based prioritization</strong> (getting scarce pieces first), <strong>integrity verification</strong> (ensuring pieces aren&#39;t corrupted), and <strong>reciprocal sharing</strong> (becoming a piece source for others).</p>\n<blockquote>\n<p><strong>Decision: Piece-Centric vs Block-Centric Management</strong></p>\n<ul>\n<li><strong>Context</strong>: BitTorrent transfers data in 16KB blocks, but verifies integrity at the piece level (typically 256KB-1MB). We must decide whether our primary abstraction tracks pieces or individual blocks.</li>\n<li><strong>Options Considered</strong>: Block-centric tracking (fine-grained but complex), Piece-centric tracking (simpler but less granular), Hybrid approach (piece state with block progress)</li>\n<li><strong>Decision</strong>: Piece-centric management with internal block tracking</li>\n<li><strong>Rationale</strong>: Pieces are the unit of verification and sharing, making them the natural abstraction. Block-level details are implementation concerns within piece management.</li>\n<li><strong>Consequences</strong>: Simpler state management and clear verification boundaries, but requires careful block coordination within pieces to avoid request conflicts.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Management Approach</th>\n<th>Granularity</th>\n<th>State Complexity</th>\n<th>Verification Model</th>\n<th>Request Coordination</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Block-Centric</td>\n<td>16KB blocks</td>\n<td>High (thousands of states)</td>\n<td>Deferred until piece complete</td>\n<td>Complex inter-block dependencies</td>\n</tr>\n<tr>\n<td>Piece-Centric</td>\n<td>256KB-1MB pieces</td>\n<td>Medium (hundreds of states)</td>\n<td>Natural verification unit</td>\n<td>Clear piece-level coordination</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Pieces with block progress</td>\n<td>Medium-High</td>\n<td>Piece-level verification</td>\n<td>Block coordination within pieces</td>\n</tr>\n</tbody></table>\n<h3 id=\"content-verification\">Content Verification</h3>\n<p>Content verification forms the <strong>trust foundation</strong> of the entire BitTorrent system. Unlike centralized downloads where you trust the server, peer-to-peer networks require cryptographic proof that received data hasn&#39;t been corrupted or maliciously altered. Every piece must pass SHA1 hash verification before being considered valid and available for sharing to other peers.</p>\n<p>The verification process operates as a <strong>cryptographic gatekeeper</strong> where each completed piece undergoes mandatory hash computation and comparison against the expected value from the torrent metadata. This verification serves multiple purposes: detecting network transmission errors, identifying malicious peers sending corrupt data, ensuring file integrity across the distributed network, and preventing the propagation of corrupted data to other peers.</p>\n<p><strong>Verification Algorithm:</strong></p>\n<ol>\n<li>Accumulate all blocks belonging to a piece until the piece is complete (typically 16-64 blocks per piece)</li>\n<li>Concatenate the block data in correct offset order to reconstruct the complete piece</li>\n<li>Compute the SHA1 hash of the reconstructed piece data using a cryptographic hash function</li>\n<li>Compare the computed hash against the expected hash from the torrent&#39;s piece list</li>\n<li>If hashes match, mark the piece as verified and available for sharing; if they don&#39;t match, discard the piece data and re-request all blocks</li>\n<li>Update the local bitfield to reflect piece availability and notify connected peers of the new piece</li>\n<li>Write the verified piece data to the appropriate file offset on disk</li>\n</ol>\n<blockquote>\n<p>The critical insight is that verification happens at piece boundaries, not block boundaries. Blocks are network transfer units, but pieces are integrity units. A single corrupted block invalidates the entire piece.</p>\n</blockquote>\n<p><strong>Hash Verification State Machine:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Downloading</td>\n<td>All blocks received</td>\n<td>Verifying</td>\n<td>Concatenate blocks, compute SHA1</td>\n</tr>\n<tr>\n<td>Verifying</td>\n<td>Hash matches expected</td>\n<td>Complete</td>\n<td>Write to disk, update bitfield, notify peers</td>\n</tr>\n<tr>\n<td>Verifying</td>\n<td>Hash mismatch</td>\n<td>Failed</td>\n<td>Discard data, reset block states, ban peer</td>\n</tr>\n<tr>\n<td>Failed</td>\n<td>Retry requested</td>\n<td>Downloading</td>\n<td>Clear piece state, re-request blocks</td>\n</tr>\n<tr>\n<td>Complete</td>\n<td>Seed request received</td>\n<td>Complete</td>\n<td>Serve piece data from disk</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Partial Piece Verification</strong>\nMany implementations attempt to verify pieces before all blocks are received, or try to verify individual blocks. This is fundamentally wrong because SHA1 hashes are computed over complete pieces. Attempting early verification leads to false negatives and wasted computation. Always wait for complete piece assembly before verification.</p>\n<p>⚠️ <strong>Pitfall: Memory vs Disk Trade-offs</strong>\nHolding multiple complete pieces in memory during verification can consume significant RAM (megabytes per piece). However, writing unverified data to disk risks file corruption. The solution is careful memory management: verify pieces immediately upon completion and implement memory pressure handling by prioritizing verification of the oldest complete pieces first.</p>\n<p><strong>Corruption Handling Strategy:</strong></p>\n<p>When piece verification fails, the client must implement a sophisticated response that balances network efficiency with peer reputation management. The failure could indicate a transmission error (temporary) or a malicious peer (permanent). Our approach prioritizes data integrity while maintaining reasonable download performance.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Scenario</th>\n<th>Detection Method</th>\n<th>Response Strategy</th>\n<th>Peer Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single block corruption</td>\n<td>Hash mismatch</td>\n<td>Re-request all piece blocks from different peers</td>\n<td>Mark suspect peer, don&#39;t ban immediately</td>\n</tr>\n<tr>\n<td>Repeated failures from peer</td>\n<td>Multiple hash failures</td>\n<td>Ban peer, close connection</td>\n<td>Add to peer blacklist</td>\n</tr>\n<tr>\n<td>Systematic corruption</td>\n<td>Hash failures across multiple pieces</td>\n<td>Re-request from different peer set</td>\n<td>Evaluate peer selection algorithm</td>\n</tr>\n<tr>\n<td>Network transmission error</td>\n<td>Occasional random failures</td>\n<td>Retry with exponential backoff</td>\n<td>No peer penalty</td>\n</tr>\n</tbody></table>\n<h3 id=\"piece-selection-strategy\">Piece Selection Strategy</h3>\n<p>Piece selection determines download efficiency and swarm health through sophisticated algorithms that balance individual download speed with overall network resilience. The primary strategy, <strong>rarest-first selection</strong>, prioritizes pieces held by the fewest peers, ensuring that scarce content remains available even as peers leave the swarm.</p>\n<p>Think of rarest-first as <strong>digital archaeology</strong> where you prioritize acquiring the most fragile artifacts first. If a piece is only held by one peer, losing that peer means the entire swarm loses access to that piece, potentially making the file incompletable. By prioritizing rare pieces, we improve overall swarm health while ensuring our own download can complete.</p>\n<p><strong>Rarest-First Algorithm:</strong></p>\n<ol>\n<li>For each connected peer, maintain a bitfield indicating which pieces they possess</li>\n<li>For each piece we still need, count how many connected peers possess it (availability count)</li>\n<li>Sort needed pieces by ascending availability count, breaking ties by piece index</li>\n<li>When selecting the next piece to request, choose the piece with the lowest availability count that we haven&#39;t started downloading</li>\n<li>If multiple pieces have the same (lowest) availability, prefer pieces closer to the beginning of the file for sequential access benefits</li>\n<li>Once a piece is selected, immediately begin requesting blocks from peers that have the piece</li>\n</ol>\n<blockquote>\n<p>The fundamental insight is that rarest-first is an <strong>insurance policy</strong> for the swarm. By ensuring rare pieces get distributed quickly, we prevent scenarios where the swarm becomes incomplete due to peer departure.</p>\n</blockquote>\n<p><strong>Availability Tracking Data Structures:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Purpose</th>\n<th>Update Triggers</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece availability map</td>\n<td>Maps piece index to peer count</td>\n<td>Peer connect/disconnect, bitfield/have messages</td>\n<td>O(1) lookup, O(n) update on peer change</td>\n</tr>\n<tr>\n<td>Needed piece priority queue</td>\n<td>Sorted list of pieces by rarity</td>\n<td>Piece completion, availability changes</td>\n<td>O(log n) insertion, O(1) top access</td>\n</tr>\n<tr>\n<td>Peer piece bitfields</td>\n<td>Which pieces each peer has</td>\n<td>Initial bitfield, subsequent have messages</td>\n<td>O(1) lookup per peer, O(m) storage per peer</td>\n</tr>\n<tr>\n<td>In-progress piece set</td>\n<td>Pieces currently being downloaded</td>\n<td>Piece selection, completion, failure</td>\n<td>O(1) membership test, prevents duplicate requests</td>\n</tr>\n</tbody></table>\n<p><strong>Advanced Selection Strategies:</strong></p>\n<p>Beyond basic rarest-first, sophisticated clients implement additional strategies for different phases of the download process:</p>\n<p><strong>Random First Phase:</strong> For the initial pieces, some clients use random selection rather than rarest-first. This provides faster startup by avoiding competition for the same rare pieces among new peers in the swarm. Random first typically applies to the first 4-8 pieces.</p>\n<p><strong>Endgame Mode:</strong> When only a few pieces remain (typically less than 10% of total pieces), switch to endgame mode where all remaining blocks are requested from all available peers. This prevents the download from stalling on slow peers holding the last few pieces. Endgame mode requires careful duplicate request handling to avoid wasting bandwidth.</p>\n<p><strong>Sequential Mode:</strong> For streaming applications, sequential selection downloads pieces in file order rather than rarity order. This enables playback of media files before download completion but can harm swarm health by reducing piece diversity.</p>\n<p><strong>Endgame Mode Algorithm:</strong></p>\n<ol>\n<li>Trigger when fewer than <code>MAX_ENDGAME_PIECES</code> (typically 10-20) pieces remain incomplete</li>\n<li>For each remaining block in any incomplete piece, send requests to ALL peers that have the corresponding piece</li>\n<li>When any peer sends a block, immediately send cancel messages to all other peers that were requested for the same block</li>\n<li>Continue until all pieces are complete, accepting the bandwidth overhead for guaranteed completion</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Selection Strategy</th>\n<th>Phase</th>\n<th>Priority Metric</th>\n<th>Benefits</th>\n<th>Drawbacks</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random First</td>\n<td>Startup (first ~5 pieces)</td>\n<td>Random selection</td>\n<td>Fast startup, reduced competition</td>\n<td>Ignores rarity, may hurt swarm</td>\n</tr>\n<tr>\n<td>Rarest First</td>\n<td>Main download</td>\n<td>Ascending availability count</td>\n<td>Improves swarm health, ensures completion</td>\n<td>Can be slow for initial pieces</td>\n</tr>\n<tr>\n<td>Endgame</td>\n<td>Final ~10 pieces</td>\n<td>Request from all available peers</td>\n<td>Prevents stalling, guaranteed completion</td>\n<td>High bandwidth overhead</td>\n</tr>\n<tr>\n<td>Sequential</td>\n<td>Streaming use cases</td>\n<td>File offset order</td>\n<td>Enables progressive playback</td>\n<td>Poor swarm health, inefficient</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Availability Count Staleness</strong>\nAvailability counts can become stale when peers disconnect without notification or when bitfield updates are missed. Stale counts lead to poor piece selection decisions. The solution is periodic availability recalculation and timeout-based peer connection validation. Implement a background task that recalculates availability counts every 60-120 seconds.</p>\n<p>⚠️ <strong>Pitfall: Endgame Mode Triggering</strong>\nTriggering endgame mode too early wastes bandwidth through duplicate requests. Triggering too late causes stalling on slow peers. Monitor both the absolute number of remaining pieces AND the download rate. If download rate drops below a threshold AND few pieces remain, consider endgame mode even if the piece count hasn&#39;t reached the normal threshold.</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fpiece-selection-flow.svg\" alt=\"Piece Selection Algorithm\"></p>\n<h3 id=\"concurrent-download-management\">Concurrent Download Management</h3>\n<p>Concurrent download management orchestrates multiple peer connections to maximize throughput while avoiding conflicts and ensuring efficient resource utilization. This involves coordinating piece requests across peers, managing block-level request pipelining, and handling the complex state synchronization required for safe concurrent access to shared data structures.</p>\n<p>Think of concurrent download management as conducting a <strong>symphony orchestra</strong> where each musician (peer connection) plays their part (downloads specific pieces) while following the conductor&#39;s coordination (piece manager) to create harmonious music (efficient file download). Each musician has different capabilities (bandwidth, piece availability) and may occasionally miss notes (network failures), requiring real-time adaptation and coordination.</p>\n<p>The primary challenge is <strong>request coordination</strong> - ensuring that multiple peers don&#39;t waste bandwidth downloading the same blocks while maintaining sufficient request pipelining to keep connections busy. This requires sophisticated state tracking and communication between peer connection handlers and the central piece manager.</p>\n<p><strong>Concurrent Download Architecture:</strong></p>\n<p>The system employs a <strong>centralized coordination</strong> model where a single <code>PieceManager</code> component orchestrates downloads across multiple <code>PeerConnection</code> instances. This design trades some efficiency for simplicity and correctness, avoiding the complex distributed coordination required in fully decentralized approaches.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibilities</th>\n<th>Concurrency Model</th>\n<th>State Management</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PieceManager</td>\n<td>Piece selection, request coordination, verification</td>\n<td>Single goroutine with channels</td>\n<td>Centralized piece state, availability tracking</td>\n</tr>\n<tr>\n<td>PeerConnection</td>\n<td>Block requests, message handling, peer state</td>\n<td>One goroutine per peer</td>\n<td>Local peer state, pending requests</td>\n</tr>\n<tr>\n<td>RequestCoordinator</td>\n<td>Block assignment, duplicate prevention</td>\n<td>Shared state with mutexes</td>\n<td>Block reservation map, timeout tracking</td>\n</tr>\n<tr>\n<td>VerificationQueue</td>\n<td>Hash computation, disk writes</td>\n<td>Dedicated worker pool</td>\n<td>Verification work queue, completion callbacks</td>\n</tr>\n</tbody></table>\n<p><strong>Request Coordination Protocol:</strong></p>\n<p>Effective request coordination prevents bandwidth waste while ensuring sufficient parallelism. The protocol operates through a reservation system where blocks are reserved before requests are sent, preventing duplicate downloads.</p>\n<p><strong>Block Request Algorithm:</strong></p>\n<ol>\n<li><code>PeerConnection</code> requests work from <code>PieceManager</code> by sending a work request message</li>\n<li><code>PieceManager</code> selects the highest-priority piece that the peer has and we need</li>\n<li><code>PieceManager</code> identifies unreserved blocks within the selected piece (blocks not currently being downloaded by other peers)</li>\n<li>Reserve up to <code>MAX_PIPELINE_DEPTH</code> blocks for this peer, marking them as &quot;reserved&quot; with peer ID and timestamp</li>\n<li>Return block list to <code>PeerConnection</code> for immediate request transmission</li>\n<li><code>PeerConnection</code> sends BitTorrent request messages to the peer for each reserved block</li>\n<li>Track pending requests with timeouts; if no response within <code>BLOCK_TIMEOUT</code>, return blocks to unreserved state</li>\n<li>When block data arrives, forward to <code>PieceManager</code> for assembly and potential verification</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Request State</th>\n<th>Meaning</th>\n<th>Timeout</th>\n<th>Transition Triggers</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Available</td>\n<td>Block can be requested</td>\n<td>N/A</td>\n<td>New piece selected, block request timeout</td>\n</tr>\n<tr>\n<td>Reserved</td>\n<td>Block assigned to peer</td>\n<td>30-60 seconds</td>\n<td>Block request sent to peer</td>\n</tr>\n<tr>\n<td>Requested</td>\n<td>Request sent to peer</td>\n<td>120-180 seconds</td>\n<td>Block data received, peer disconnect</td>\n</tr>\n<tr>\n<td>Received</td>\n<td>Data received, awaiting assembly</td>\n<td>N/A</td>\n<td>All piece blocks received</td>\n</tr>\n</tbody></table>\n<p><strong>Synchronization and Locking Strategy:</strong></p>\n<p>Concurrent access to shared piece state requires careful synchronization to prevent race conditions while maintaining performance. The design uses a combination of channels for coordination and fine-grained locking for shared data structures.</p>\n<blockquote>\n<p><strong>Decision: Channel-Based vs Mutex-Based Coordination</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple goroutines need coordinated access to piece state, request queues, and peer availability information.</li>\n<li><strong>Options Considered</strong>: Pure channel-based CSP model, Pure mutex-based shared memory, Hybrid approach with channels for coordination and mutexes for data</li>\n<li><strong>Decision</strong>: Hybrid approach with channels for major coordination and fine-grained mutexes for shared data structures</li>\n<li><strong>Rationale</strong>: Channels provide clean coordination semantics for work distribution, while mutexes offer efficient access to frequently-read data like bitfields and availability maps.</li>\n<li><strong>Consequences</strong>: Simpler reasoning about coordination flows but requires discipline to avoid deadlocks between channel operations and mutex acquisition.</li>\n</ul>\n</blockquote>\n<p><strong>Concurrency Synchronization Points:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Shared Resource</th>\n<th>Protection Mechanism</th>\n<th>Access Pattern</th>\n<th>Lock Granularity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece availability map</td>\n<td>Read-write mutex</td>\n<td>Frequent reads, rare writes</td>\n<td>Per-piece or global RWMutex</td>\n</tr>\n<tr>\n<td>Block reservation map</td>\n<td>Mutex</td>\n<td>Moderate read/write</td>\n<td>Per-piece or global mutex</td>\n</tr>\n<tr>\n<td>Peer bitfields</td>\n<td>Read-write mutex</td>\n<td>Frequent reads during selection</td>\n<td>Per-peer RWMutex</td>\n</tr>\n<tr>\n<td>Piece completion status</td>\n<td>Atomic operations</td>\n<td>High-frequency status checks</td>\n<td>Lock-free with atomic.Bool</td>\n</tr>\n<tr>\n<td>Download statistics</td>\n<td>Atomic operations</td>\n<td>Frequent updates, periodic reads</td>\n<td>Lock-free counters</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Lock Ordering and Deadlocks</strong>\nWhen multiple locks must be acquired, inconsistent ordering leads to deadlocks. Establish a clear lock hierarchy: always acquire piece-level locks before peer-level locks, and never hold a peer lock while waiting for a piece lock. Use timeouts on lock acquisition in critical paths to detect potential deadlocks.</p>\n<p>⚠️ <strong>Pitfall: Request Pipeline Starvation</strong>\nIf piece selection is too slow or block reservation contention is high, peer connections can starve for work, leading to underutilized bandwidth. Implement request pipeline depth monitoring and preemptive block reservation to ensure each peer connection always has 3-5 outstanding requests.</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fconcurrent-download.svg\" alt=\"Multi-Peer Download Coordination\"></p>\n<h3 id=\"upload-and-seeding\">Upload and Seeding</h3>\n<p>Upload and seeding capabilities transform our client from a simple downloader into a full participant in the BitTorrent ecosystem. This involves serving piece data to other peers, implementing fair sharing policies, tracking upload statistics for tracker reporting, and maintaining connections specifically for seeding purposes.</p>\n<p>Think of seeding as <strong>running a specialized library</strong> where you&#39;ve completed collecting a particular book series and now help other collectors find the volumes they need. You need to track which books you have, respond to requests efficiently, maintain fair lending policies (not always serving the same frequent borrower), and keep statistics on how much you&#39;ve helped the community.</p>\n<p>The seeding process requires <strong>role reversal</strong> from the downloading logic - instead of selecting pieces to request, you respond to incoming requests by serving data from your completed files. However, the underlying mechanisms (message handling, connection management, piece verification) remain largely the same.</p>\n<p><strong>Upload Request Handling:</strong></p>\n<p>When acting as a seeder, the client receives <code>MsgRequest</code> messages from peers asking for specific blocks. The upload handler must validate requests, check local piece availability, read data from disk, and respond with <code>MsgPiece</code> messages containing the requested data.</p>\n<p><strong>Upload Response Algorithm:</strong></p>\n<ol>\n<li>Receive <code>MsgRequest</code> message containing piece index, block offset, and block length</li>\n<li>Validate request parameters: piece index within torrent bounds, offset aligned to block boundaries, length not exceeding maximum block size</li>\n<li>Check local bitfield to confirm we have the requested piece (respond with rejection if not available)</li>\n<li>Verify peer is not choked - if choked, ignore the request (peer should not have sent it)</li>\n<li>Read requested data from the appropriate file offset on disk (piece_index × piece_length + block_offset)</li>\n<li>Construct <code>MsgPiece</code> response with piece index, block offset, and data payload</li>\n<li>Send response to peer and update upload statistics (bytes uploaded, pieces served)</li>\n<li>Apply bandwidth limiting if configured to prevent overwhelming network connection</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Request Validation</th>\n<th>Check</th>\n<th>Failure Response</th>\n<th>Security Implication</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece bounds</td>\n<td><code>0 ≤ piece_index &lt; total_pieces</code></td>\n<td>Ignore request</td>\n<td>Prevents buffer overruns</td>\n</tr>\n<tr>\n<td>Block offset alignment</td>\n<td><code>offset % BLOCK_SIZE == 0</code></td>\n<td>Ignore request</td>\n<td>Ensures proper block boundaries</td>\n</tr>\n<tr>\n<td>Block length limits</td>\n<td><code>length ≤ BLOCK_SIZE</code></td>\n<td>Ignore request</td>\n<td>Prevents excessive memory allocation</td>\n</tr>\n<tr>\n<td>Peer choke state</td>\n<td><code>!peer_choking</code></td>\n<td>Ignore request</td>\n<td>Enforces BitTorrent protocol</td>\n</tr>\n<tr>\n<td>Local piece availability</td>\n<td><code>HasPiece(piece_index)</code></td>\n<td>Ignore or send rejection</td>\n<td>Prevents serving unavailable data</td>\n</tr>\n</tbody></table>\n<p><strong>Choking and Unchoking Policy:</strong></p>\n<p>BitTorrent&#39;s choking mechanism implements <strong>tit-for-tat reciprocity</strong> where peers prioritize uploading to those who provide good download speeds in return. This creates incentives for mutual cooperation while preventing pure &quot;leeching&quot; behavior that would harm the swarm.</p>\n<p><strong>Standard Choking Algorithm:</strong></p>\n<ol>\n<li>Maintain upload rate statistics for each connected peer over the last 20-30 seconds</li>\n<li>Every 10 seconds (choking round), recalculate which peers to unchoke based on their download rates to us</li>\n<li>Unchoke the top 3-4 peers providing the best download rates (reciprocal unchoking)</li>\n<li>Additionally, unchoke one random peer every 30 seconds (optimistic unchoking) to discover new high-speed peers</li>\n<li>Send <code>MsgChoke</code> to peers being choked and <code>MsgUnchoke</code> to peers being unchoked</li>\n<li>Peers that are choked should not send requests; ignore any requests from choked peers</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Choking Category</th>\n<th>Selection Criteria</th>\n<th>Update Frequency</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Reciprocal Unchoke</td>\n<td>Top 3-4 peers by download rate to us</td>\n<td>Every 10 seconds</td>\n<td>Reward peers providing good service</td>\n</tr>\n<tr>\n<td>Optimistic Unchoke</td>\n<td>Random peer selection</td>\n<td>Every 30 seconds</td>\n<td>Discover new high-speed peers</td>\n</tr>\n<tr>\n<td>Seed Optimistic</td>\n<td>Random among interested peers</td>\n<td>Every 30 seconds</td>\n<td>Distribute pieces when we&#39;re seeding</td>\n</tr>\n<tr>\n<td>Anti-snubbing</td>\n<td>Peers not choking us</td>\n<td>When snubbed</td>\n<td>Maintain reciprocity relationships</td>\n</tr>\n</tbody></table>\n<p><strong>Seeding-Specific Adaptations:</strong></p>\n<p>When seeding (upload-only mode after download completion), the choking algorithm adapts since there are no download rates to reciprocate. Seeding policies focus on <strong>fairness</strong> and <strong>swarm health</strong> rather than direct reciprocity.</p>\n<p><strong>Seeding Upload Policy:</strong></p>\n<ol>\n<li>Prefer peers with the lowest upload rates (helping slower peers)</li>\n<li>Rotate unchoked peers regularly to ensure fair access across the swarm</li>\n<li>Prioritize peers requesting rare pieces to improve swarm piece distribution</li>\n<li>Implement bandwidth limits to prevent seeding from overwhelming the connection</li>\n<li>Consider peer reputation and protocol compliance when making unchoking decisions</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Upload Without Download Tracking</strong>\nWhen seeding, it&#39;s tempting to remove download rate tracking since we&#39;re not downloading. However, proper reciprocity tracking is essential for effective peer relationships. Maintain download statistics even while seeding - they inform which peers to prioritize and help identify protocol violations.</p>\n<p>⚠️ <strong>Pitfall: Disk I/O Performance</strong>\nServing upload requests requires frequent disk reads at random offsets, which can become a performance bottleneck with many concurrent requesters. Implement an LRU piece cache in memory to serve frequently requested pieces without disk access. Monitor disk I/O patterns and consider read-ahead strategies for sequential requests.</p>\n<p><strong>Upload Statistics and Tracker Reporting:</strong></p>\n<p>Accurate upload statistics are essential for tracker communication and monitoring seeding effectiveness. The client must track bytes uploaded, pieces served, and upload rates for both local monitoring and tracker reporting.</p>\n<table>\n<thead>\n<tr>\n<th>Upload Metric</th>\n<th>Tracking Granularity</th>\n<th>Reporting Frequency</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Total bytes uploaded</td>\n<td>Global counter</td>\n<td>Every tracker announce</td>\n<td>Tracker reporting, ratio monitoring</td>\n</tr>\n<tr>\n<td>Upload rate (current)</td>\n<td>30-second rolling average</td>\n<td>Continuous</td>\n<td>Choking decisions, bandwidth monitoring</td>\n</tr>\n<tr>\n<td>Pieces served</td>\n<td>Per-piece counters</td>\n<td>On piece completion</td>\n<td>Swarm health analysis</td>\n</tr>\n<tr>\n<td>Peer upload rates</td>\n<td>Per-peer statistics</td>\n<td>20-second windows</td>\n<td>Reciprocity calculations</td>\n</tr>\n<tr>\n<td>Bandwidth utilization</td>\n<td>Connection-level monitoring</td>\n<td>Real-time</td>\n<td>Bandwidth limiting, QoS</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-piece-management-pitfalls\">Common Piece Management Pitfalls</h3>\n<p>Piece management introduces complex state coordination and timing challenges that frequently trip up implementations. Understanding these common pitfalls helps avoid subtle bugs that can lead to download failures, data corruption, or poor performance.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in Piece Completion</strong>\nMultiple peer connections may simultaneously complete different blocks of the same piece, leading to race conditions during piece assembly and verification. The symptom is pieces being verified multiple times or verification failing due to incomplete piece data.</p>\n<p><strong>Problem:</strong> Two peers send the final blocks of a piece simultaneously. Both connections detect piece completion and attempt verification concurrently, but one connection may start verification before the other&#39;s block is incorporated.</p>\n<p><strong>Solution:</strong> Use atomic piece completion detection with compare-and-swap operations. Only allow one goroutine to transition a piece from &quot;downloading&quot; to &quot;verifying&quot; state. Implement piece-level mutexes for assembly operations.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example of atomic piece completion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> atomic.</span><span style=\"color:#B392F0\">CompareAndSwapInt32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">piece.state, StateDownloading, StateVerifying) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only one goroutine will execute this verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#B392F0\"> verifyPiece</span><span style=\"color:#E1E4E8\">(piece)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Memory Leaks from Uncompleted Pieces</strong>\nPieces that never complete (due to peer disconnections or failures) can accumulate partial block data in memory indefinitely, leading to memory leaks in long-running clients.</p>\n<p><strong>Problem:</strong> Peers disconnect while downloading pieces, leaving partially completed pieces with allocated block buffers that are never freed because the piece never enters the cleanup path.</p>\n<p><strong>Solution:</strong> Implement periodic piece cleanup that identifies pieces stuck in downloading state for extended periods. Add reference counting for block data and timeout-based cleanup for abandoned pieces.</p>\n<p>⚠️ <strong>Pitfall: Inefficient Piece Selection Updates</strong>\nRecalculating piece priorities after every peer connection change or piece completion can become a performance bottleneck with large torrents and many peers.</p>\n<p><strong>Problem:</strong> With 1000+ piece torrents and dozens of peers, naively recalculating the entire piece priority queue after each bitfield update results in O(n log n) operations that can consume significant CPU time.</p>\n<p><strong>Solution:</strong> Implement incremental priority updates that only recalculate affected pieces. Use efficient data structures like priority queues that support decrease-key operations for targeted updates.</p>\n<p>⚠️ <strong>Pitfall: Verification CPU Blocking</strong>\nComputing SHA1 hashes for large pieces (1MB+) in the main goroutine blocks other operations, leading to poor responsiveness and connection timeouts.</p>\n<p><strong>Problem:</strong> SHA1 computation for large pieces can take several milliseconds, during which the piece manager cannot respond to new requests or handle peer messages, causing apparent hangs.</p>\n<p><strong>Solution:</strong> Perform verification in a dedicated worker pool. Use channels to queue verification work and return results asynchronously. Implement verification priority queues to prioritize pieces needed for immediate requests.</p>\n<p>⚠️ <strong>Pitfall: Endgame Mode Bandwidth Waste</strong>\nPoorly implemented endgame mode can waste enormous bandwidth by continuing to request blocks that have already been received from faster peers.</p>\n<p><strong>Problem:</strong> Endgame mode sends duplicate requests to all available peers but fails to promptly cancel requests when blocks arrive, leading to multiple peers sending the same block data.</p>\n<p><strong>Solution:</strong> Implement aggressive request cancellation in endgame mode. When any block arrives, immediately send cancel messages to all other peers that were sent requests for that block. Track which peers have been sent cancel messages to avoid redundant cancellations.</p>\n<p>⚠️ <strong>Pitfall: Disk I/O Concurrency Issues</strong>\nMultiple goroutines attempting to write different pieces to the same file simultaneously can lead to corruption or poor performance due to seek thrashing.</p>\n<p><strong>Problem:</strong> Concurrent piece writes to random file offsets cause excessive disk seeking and potential data races if file operations aren&#39;t properly synchronized.</p>\n<p><strong>Solution:</strong> Implement a disk I/O coordinator that serializes writes to the same file. Use file-level mutexes or dedicated I/O worker goroutines per file. Consider write coalescing for pieces that map to the same file regions.</p>\n<table>\n<thead>\n<tr>\n<th>Pitfall Category</th>\n<th>Primary Symptom</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Race Conditions</td>\n<td>Verification failures, corrupt pieces</td>\n<td>Stress testing with many peers</td>\n<td>Atomic state transitions, piece-level locking</td>\n</tr>\n<tr>\n<td>Memory Leaks</td>\n<td>Growing memory usage</td>\n<td>Memory profiling, leak detection</td>\n<td>Timeout-based cleanup, reference counting</td>\n</tr>\n<tr>\n<td>Performance Issues</td>\n<td>High CPU usage, slow response</td>\n<td>CPU profiling, latency monitoring</td>\n<td>Incremental updates, async operations</td>\n</tr>\n<tr>\n<td>Protocol Violations</td>\n<td>Peer disconnections, bandwidth waste</td>\n<td>Network traffic analysis</td>\n<td>Strict protocol compliance, proper cancellation</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides concrete Go code for building the piece management and seeding system. The focus is on providing complete infrastructure components and detailed skeletons for the core learning algorithms.</p>\n<p><strong>A. Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hash Computation</td>\n<td><code>crypto/sha1</code> with <code>io.Copy</code></td>\n<td>Worker pool with <code>crypto/sha1</code> for parallelism</td>\n</tr>\n<tr>\n<td>Disk I/O</td>\n<td><code>os.File</code> with <code>Seek</code> and <code>Read/Write</code></td>\n<td>Memory-mapped files with <code>syscall.Mmap</code></td>\n</tr>\n<tr>\n<td>Concurrency Coordination</td>\n<td>Channels with <code>select</code> statements</td>\n<td><code>sync.WaitGroup</code> and <code>context.Context</code> trees</td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>Maps with <code>sync.RWMutex</code></td>\n<td>Lock-free structures with <code>sync/atomic</code></td>\n</tr>\n<tr>\n<td>Priority Queues</td>\n<td><code>container/heap</code> with custom types</td>\n<td>Third-party libraries like <code>github.com/emirpasic/gods</code></td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  piece/\n    manager.go           ← PieceManager and coordination logic\n    state.go            ← PieceState and Block data structures  \n    verification.go     ← Hash verification worker pool\n    selection.go        ← Piece selection algorithms\n    upload.go           ← Upload handling and seeding logic\n    manager_test.go     ← Unit tests for piece management\n  download/\n    coordinator.go      ← Multi-peer download coordination\n    endgame.go         ← Endgame mode implementation\n    statistics.go      ← Upload/download statistics tracking</code></pre></div>\n\n<p><strong>C. Infrastructure Code - Verification Worker Pool:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/piece/verification.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> piece</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerificationRequest represents a piece that needs hash verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VerificationRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceIndex </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Data       []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExpectedHash [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Callback   </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">verified</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerificationPool manages concurrent piece verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VerificationPool</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    workers    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    requests   </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> VerificationRequest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wg         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">WaitGroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shutdown   </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewVerificationPool creates a verification worker pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewVerificationPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">workers</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VerificationPool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">VerificationPool</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        workers:  workers,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        requests: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> VerificationRequest</span><span style=\"color:#E1E4E8\">, workers</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        shutdown: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start worker goroutines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> workers; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pool.wg.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#E1E4E8\"> pool.</span><span style=\"color:#B392F0\">worker</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SubmitVerification queues a piece for verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VerificationPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SubmitVerification</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> VerificationRequest</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> p.requests </span><span style=\"color:#F97583\">&#x3C;-</span><span style=\"color:#E1E4E8\"> req:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Successfully queued</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">p.shutdown:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Pool is shutting down</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        req.</span><span style=\"color:#B392F0\">Callback</span><span style=\"color:#E1E4E8\">(req.PieceIndex, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// worker processes verification requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VerificationPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">worker</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> p.wg.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> req </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">p.requests:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            verified </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">verifyPiece</span><span style=\"color:#E1E4E8\">(req.Data, req.ExpectedHash)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            req.</span><span style=\"color:#B392F0\">Callback</span><span style=\"color:#E1E4E8\">(req.PieceIndex, verified)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">p.shutdown:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// verifyPiece computes SHA1 and compares with expected hash</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VerificationPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">verifyPiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    computed </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sha1.</span><span style=\"color:#B392F0\">Sum</span><span style=\"color:#E1E4E8\">(data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> computed </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shutdown gracefully stops the verification pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VerificationPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(p.shutdown)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.wg.</span><span style=\"color:#B392F0\">Wait</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(p.requests)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Infrastructure Code - Priority Queue for Piece Selection:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/piece/selection.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> piece</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">container/heap</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PiecePriority represents a piece with its priority for selection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PiecePriority</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Index        </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Availability </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Lower is higher priority (rarest first)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Priority     </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Manual priority adjustment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PriorityQueue implements heap.Interface for piece selection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PriorityQueue</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PiecePriority</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pq </span><span style=\"color:#B392F0\">PriorityQueue</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(pq) }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pq </span><span style=\"color:#B392F0\">PriorityQueue</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">i</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">j</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Primary: lowest availability (rarest first)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pq[i].Availability </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> pq[j].Availability {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> pq[i].Availability </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> pq[j].Availability</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Secondary: manual priority</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pq[i].Priority </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> pq[j].Priority {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> pq[i].Priority </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> pq[j].Priority</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Tertiary: lowest index (sequential preference)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pq[i].Index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> pq[j].Index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pq </span><span style=\"color:#B392F0\">PriorityQueue</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Swap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">i</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">j</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) { pq[i], pq[j] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pq[j], pq[i] }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pq </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PriorityQueue</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">x</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pq </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pq, x.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PiecePriority</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pq </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PriorityQueue</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pop</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pq</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(old)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    item </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> old[n</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pq </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> old[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\"> : n</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> item</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PieceSelector manages piece selection with thread-safe priority queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PieceSelector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue     </span><span style=\"color:#B392F0\">PriorityQueue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    available </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // piece index -> availability count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    needed    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\"> // pieces we still need</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewPieceSelector creates a piece selector for the given torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPieceSelector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">totalPieces</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceSelector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PieceSelector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queue:     </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PriorityQueue</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        available: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        needed:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateAvailability updates piece availability from peer bitfields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ps </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceSelector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateAvailability</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">available</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ps.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ps.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> available {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ps.available[pieceIndex]</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ps.available[pieceIndex]</span><span style=\"color:#F97583\">--</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ps.available[pieceIndex] </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            delete</span><span style=\"color:#E1E4E8\">(ps.available, pieceIndex)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Rebuild priority queue if needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ps.</span><span style=\"color:#B392F0\">rebuildQueue</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SelectNextPiece returns the highest priority piece we need</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ps </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceSelector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SelectNextPiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">peerBitfield</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ps.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ps.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find highest priority piece that peer has and we need</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> ps.queue.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        piece </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> heap.</span><span style=\"color:#B392F0\">Pop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ps.queue).(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PiecePriority</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ps.needed[piece.Index] </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> peerBitfield.</span><span style=\"color:#B392F0\">HasPiece</span><span style=\"color:#E1E4E8\">(piece.Index) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> piece.Index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#6A737D\"> // No suitable piece found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MarkComplete removes a piece from needed set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ps </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceSelector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MarkComplete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ps.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ps.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(ps.needed, pieceIndex)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ps.</span><span style=\"color:#B392F0\">rebuildQueue</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// rebuildQueue reconstructs priority queue (call with mutex held)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ps </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceSelector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">rebuildQueue</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ps.queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ps.queue[:</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> pieceIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> ps.needed {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        availability </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ps.available[pieceIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        piece </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PiecePriority</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Index:        pieceIndex,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Availability: availability,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Priority:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Default priority</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        heap.</span><span style=\"color:#B392F0\">Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ps.queue, piece)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Core Logic Skeleton - Piece Manager:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/piece/manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> piece</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PieceManager coordinates piece downloads, verification, and serving</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PieceManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metaInfo        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieces          </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selector        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceSelector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verificationPool </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VerificationPool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statistics      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Channels for coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    workRequests    </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> WorkRequest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    blockData       </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> BlockData</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verificationResults </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> VerificationResult</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WorkRequest represents a peer asking for work</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WorkRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PeerID    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Bitfield  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitfieldOps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Response  </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> WorkResponse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WorkResponse contains blocks assigned to a peer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WorkResponse</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Blocks []</span><span style=\"color:#B392F0\">BlockRequest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Error  </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BlockRequest represents a specific block to download</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BlockRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceIndex </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Offset     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Length     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewPieceManager creates a piece manager for the given torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPieceManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">metaInfo</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize piece state map with one PieceState per piece</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create piece selector with total piece count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize verification pool with appropriate worker count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set up communication channels with proper buffer sizes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start main coordination goroutine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use len(metaInfo.Info.GetPieceHashes()) for piece count</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement NewPieceManager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RequestWork assigns blocks to a peer for downloading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RequestWork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">peerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">peerBitfield</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BitfieldOps</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">BlockRequest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create WorkRequest with peer information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send request on workRequests channel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Wait for response on the response channel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return assigned blocks or error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use buffered response channel to avoid goroutine leaks</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement RequestWork\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SubmitBlockData processes received block data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SubmitBlockData</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">peerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate block parameters (bounds checking)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create BlockData message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send on blockData channel for processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update download statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Validate offset + len(data) doesn't exceed piece bounds</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement SubmitBlockData\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServeUploadRequest handles requests from other peers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ServeUploadRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate request parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if we have the requested piece</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read data from disk at appropriate offset</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update upload statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return requested data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Calculate file offset as piece_index * piece_length + offset</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement ServeUploadRequest\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// coordinator is the main coordination goroutine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">coordinator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> workReq </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">pm.workRequests:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Use piece selector to find next piece for this peer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Find unreserved blocks in the selected piece</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Reserve blocks for this peer with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Create BlockRequest list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Send response on workReq.Response channel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Hint: Limit blocks per peer to MAX_PIPELINE_DEPTH (5-10)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> blockData </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">pm.blockData:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Find the piece state for this block</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Add block data to piece assembly buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Check if piece is now complete (all blocks received)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: If complete, submit for verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Update block reservation status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Hint: Use atomic operations for piece completion detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> verifyResult </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">pm.verificationResults:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Check verification result (hash match)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: If verified, mark piece complete and write to disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: If failed, reset piece state for re-download</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Update bitfield and notify connected peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Update piece selector with completion status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Hint: Send Have messages to all connected peers for verified pieces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// selectBlocksForPeer finds unreserved blocks in a piece for download</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">selectBlocksForPeer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">maxBlocks</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">BlockRequest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get piece state for the specified piece</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through blocks in the piece</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Find blocks that are not reserved or completed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Reserve found blocks for this peer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create BlockRequest list up to maxBlocks limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Standard block size is 16KB except for the last block of a piece</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement selectBlocksForPeer\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// assemblePiece combines received blocks into complete piece data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">assemblePiece</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get piece state and verify all blocks are present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate total piece size (may be less than piece_length for last piece)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create output buffer of appropriate size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Copy each block's data to correct offset in output buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return assembled piece data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Sort blocks by offset before assembly to ensure correct order</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement assemblePiece\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>F. Core Logic Skeleton - Endgame Mode:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/download/endgame.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> download</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EndgameManager handles aggressive downloading of final pieces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EndgameManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieceManager   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">piece</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PieceManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connections    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">peer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeRequests </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">BlockKey</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // block -> list of peers requested from</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    enabled        </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BlockKey uniquely identifies a block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BlockKey</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceIndex </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Offset     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEndgameManager creates endgame mode coordinator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEndgameManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">piece</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EndgameManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">EndgameManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pieceManager:   pm,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        connections:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">peer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeRequests: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">BlockKey</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShouldEnterEndgame determines if endgame mode should be activated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">em </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EndgameManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ShouldEnterEndgame</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Count remaining incomplete pieces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check current download rate trend</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate percentage of completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return true if conditions met for endgame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Typical threshold is &#x3C;20 pieces remaining and >95% complete</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement ShouldEnterEndgame\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RequestAllRemaining sends requests for all incomplete blocks to all available peers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">em </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EndgameManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RequestAllRemaining</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get list of all incomplete pieces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each piece, identify incomplete blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each block, send requests to all peers that have the piece</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Track all outstanding requests for cancellation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set timeouts for endgame requests (shorter than normal)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Only request from peers that are not choking us</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement RequestAllRemaining\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OnBlockReceived handles block completion in endgame mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">em </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EndgameManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">OnBlockReceived</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fromPeer</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create BlockKey for the received block</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Find all other peers that were sent requests for this block</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send Cancel messages to those peers immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove block from active requests tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update statistics for bandwidth saved by cancellation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Send cancellation even if peer hasn't responded yet</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement OnBlockReceived\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>G. Milestone Checkpoint:</strong></p>\n<p>After implementing piece management and seeding:</p>\n<ol>\n<li><strong>Basic Verification Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/piece/...</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should pass all unit tests for piece management</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Integration Test with Real Torrent:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/bittorrent/main.go</span><span style=\"color:#9ECBFF\"> download</span><span style=\"color:#9ECBFF\"> test.torrent</span><span style=\"color:#9ECBFF\"> output_file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should successfully download and verify a small torrent</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Expected Behavior Verification:</strong></p>\n<ul>\n<li>Piece selection should prioritize rarest pieces first</li>\n<li>Hash verification should reject corrupted pieces and re-request</li>\n<li>Multiple peer connections should coordinate without conflicts</li>\n<li>Seeding should respond to upload requests from other clients</li>\n<li>Download should enter endgame mode for final pieces</li>\n</ul>\n</li>\n<li><p><strong>Performance Monitoring:</strong></p>\n<ul>\n<li>Monitor piece verification time (should be &lt;100ms per piece)</li>\n<li>Check memory usage (should not grow unboundedly)</li>\n<li>Verify concurrent download efficiency (multiple active peers)</li>\n<li>Measure upload responsiveness (request handling latency)</li>\n</ul>\n</li>\n</ol>\n<p><strong>H. Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Method</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Download stalls at 99%</td>\n<td>Endgame mode not triggered</td>\n<td>Check remaining piece count</td>\n<td>Implement proper endgame threshold</td>\n</tr>\n<tr>\n<td>Hash verification failures</td>\n<td>Network corruption or malicious peer</td>\n<td>Log piece hashes and peer sources</td>\n<td>Add peer reputation tracking</td>\n</tr>\n<tr>\n<td>Memory usage grows constantly</td>\n<td>Piece cleanup not working</td>\n<td>Profile memory allocation</td>\n<td>Implement timeout-based cleanup</td>\n</tr>\n<tr>\n<td>Poor download speed</td>\n<td>Inefficient piece selection</td>\n<td>Analyze piece request patterns</td>\n<td>Optimize rarest-first algorithm</td>\n</tr>\n<tr>\n<td>Upload requests ignored</td>\n<td>Choking logic errors</td>\n<td>Check peer choke/unchoke states</td>\n<td>Fix reciprocity algorithm</td>\n</tr>\n</tbody></table>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section integrates all four milestones (1-4) by showing how torrent parsing, tracker communication, peer protocols, and piece management work together during the complete download lifecycle.</p>\n</blockquote>\n<p>Building a BitTorrent client involves orchestrating multiple concurrent subsystems that must work together seamlessly. Think of this like conducting a symphony orchestra where each musician (component) has their own part to play, but the magic happens when they synchronize their timing and harmonize their contributions. The torrent parser provides the sheet music, the tracker acts as the concert program listing all performers, the peer connections are the individual instruments playing their parts, and the piece manager is the conductor ensuring everything comes together into a coherent performance.</p>\n<p>This orchestration becomes particularly complex because BitTorrent operates in a highly concurrent, distributed environment where failures are common and coordination must happen without central control. Unlike a traditional client-server application where one component controls the flow, BitTorrent requires careful choreography between autonomous components that each maintain their own state and make independent decisions while contributing to the collective goal of file transfer.</p>\n<p>The key architectural challenge is managing shared state and coordination points without introducing race conditions or deadlocks. Each component operates in its own goroutines with its own lifecycle, but they must coordinate access to shared data structures like piece availability maps, peer connection pools, and download progress tracking. This requires careful design of synchronization primitives and message passing patterns.</p>\n<h3 id=\"complete-download-lifecycle\">Complete Download Lifecycle</h3>\n<p>The BitTorrent download process follows a well-defined sequence that progresses through distinct phases, each building upon the previous phase&#39;s results. Think of this like planning and executing a complex heist where each step must be completed successfully before the next can begin, but once the operation is underway, multiple activities happen simultaneously while maintaining coordination.</p>\n<p><strong>Phase 1: Initialization and Metadata Extraction</strong></p>\n<p>The lifecycle begins when a user provides a torrent file path to the client. The <code>TorrentParser</code> immediately takes control and begins the metadata extraction process. This phase is entirely synchronous and must complete successfully before any networking can begin.</p>\n<p>The parser creates a <code>Decoder</code> instance and begins parsing the bencode structure. As it processes the torrent file, it extracts critical information including the announce URL, file information, piece length, and piece hashes. Most importantly, it calculates the info hash by taking the SHA-1 digest of the exact bencoded bytes of the info dictionary. This info hash becomes the unique identifier that ties together all subsequent operations.</p>\n<p>Once parsing completes successfully, the system has a complete <code>MetaInfo</code> structure containing all the information needed to begin the download. At this point, the client calculates derived information like the total file size, expected number of pieces, and creates the initial piece state map where every piece is marked as needed and unavailable.</p>\n<blockquote>\n<p>The info hash calculation during this phase is critical because it serves as the cryptographic fingerprint that ensures all peers are working on exactly the same file. Even a single byte difference in the original torrent would produce a completely different info hash, preventing any coordination.</p>\n</blockquote>\n<p><strong>Phase 2: Peer Discovery Through Tracker Communication</strong></p>\n<p>With the torrent metadata successfully parsed, the system transitions to peer discovery. The <code>TrackerClient</code> takes the lead in this phase, using the announce URL and info hash from the metadata to contact the tracker and obtain a list of peers participating in the swarm.</p>\n<p>The tracker client constructs an <code>AnnounceRequest</code> containing the info hash, a randomly generated peer ID, the port the client will listen on, and initial statistics (zero bytes uploaded/downloaded, total bytes left equal to file size). This request gets sent as an HTTP GET to the tracker&#39;s announce URL with proper URL encoding of binary fields.</p>\n<p>When the tracker responds with an <code>AnnounceResponse</code>, the system parses the compact peer list to extract IP addresses and ports of available peers. The tracker also provides an announce interval that determines when the client should next contact the tracker to update its status and refresh the peer list.</p>\n<p>This phase typically completes quickly (within a few seconds) but establishes an ongoing relationship with the tracker. The client schedules periodic re-announces that will continue throughout the download to report progress and discover new peers joining the swarm.</p>\n<p><strong>Phase 3: Concurrent Peer Connection Establishment</strong></p>\n<p>Once the system has a list of potential peers, it enters the most complex phase where multiple activities happen simultaneously. The <code>PeerManager</code> begins establishing TCP connections to multiple peers in parallel, typically limiting itself to around 50 concurrent connections to avoid overwhelming the network or the local system.</p>\n<p>For each successful TCP connection, the peer manager creates a <code>Connection</code> instance that immediately begins the BitTorrent handshake process. The handshake involves sending a 68-byte message containing the protocol identifier, info hash, and the client&#39;s peer ID, then waiting for the peer to respond with their own handshake message.</p>\n<p>Successful handshakes are followed immediately by an exchange of bitfield messages where each peer announces which pieces they currently have available. This bitfield information gets stored in each connection&#39;s state and becomes crucial for piece selection decisions.</p>\n<p>During this phase, connections may fail for various reasons: peers may be unreachable, handshakes may fail due to mismatched info hashes, or peers may disconnect. The system handles these failures gracefully by maintaining a pool of connection attempts and replacing failed connections with new attempts to different peers.</p>\n<p><strong>Phase 4: Coordinated Multi-Peer Downloading</strong></p>\n<p>With multiple peer connections established and bitfield information exchanged, the system enters the core downloading phase where the <code>PieceManager</code> coordinates piece requests across all available peers. This is where the orchestration becomes most complex because multiple components must work together while maintaining high throughput.</p>\n<p>The piece manager implements a rarest-first selection strategy where it continuously monitors which pieces are available from which peers and prioritizes downloading pieces that are held by the fewest peers. This strategy helps ensure that rare pieces get downloaded early, preventing situations where the download stalls because only one peer has a needed piece and that peer becomes unavailable.</p>\n<p>For each peer connection, the piece manager examines the peer&#39;s bitfield and selects appropriate pieces to request based on the rarest-first algorithm and the peer&#39;s choking state. When a peer is unchoked and interested, the connection begins sending block requests for 16KB chunks within selected pieces, maintaining a pipeline of several outstanding requests to maximize throughput.</p>\n<p>As block data arrives from peers, the piece manager buffers the blocks until an entire piece is complete, then immediately verifies the piece by computing its SHA-1 hash and comparing it to the expected hash from the torrent metadata. Successfully verified pieces get written to disk at the correct file offset and the piece is marked as complete in the system&#39;s piece map.</p>\n<p>This coordination requires careful synchronization because multiple peers may be downloading different pieces simultaneously, pieces must be assembled in the correct order in the output file, and the system must track which blocks have been requested from which peers to avoid duplicate requests and detect when re-requests are needed.</p>\n<p><strong>Phase 5: Endgame and Completion</strong></p>\n<p>As the download nears completion, the system enters endgame mode when only a small number of pieces remain unfinished. During endgame, the piece selection strategy changes from rarest-first to a more aggressive approach where the remaining blocks are requested from all peers that have them, ensuring that the download doesn&#39;t stall waiting for a single slow peer.</p>\n<p>Once the final piece is downloaded and verified, the system performs a final integrity check of the complete file and transitions into seeding mode where it can serve pieces to other peers in the swarm. The tracker client sends a final announce with the &quot;completed&quot; event to inform the tracker that this peer now has the complete file.</p>\n<h3 id=\"inter-component-communication\">Inter-Component Communication</h3>\n<p>The BitTorrent client&#39;s components communicate through a carefully designed combination of direct method calls, channel-based message passing, and shared data structures protected by synchronization primitives. Think of this like a modern office building where different departments (components) need to coordinate their work through various communication channels: some use direct phone calls for urgent matters, others send memos through internal mail systems, and some share information through central bulletin boards that everyone can access.</p>\n<p><strong>Direct Method Invocation for Synchronous Operations</strong></p>\n<p>Certain operations require immediate, synchronous responses and use direct method calls between components. These typically involve configuration queries, state checks, and operations that must complete atomically.</p>\n<p>The <code>PieceManager</code> directly calls methods on <code>Connection</code> objects when it needs to send requests or check peer state. When the piece manager determines that a peer should download a specific piece, it calls <code>SendRequest()</code> directly on the connection object with the piece index, block offset, and block length. This synchronous call allows the piece manager to immediately know whether the request was successfully queued for transmission.</p>\n<p>Similarly, when connections receive incoming messages from peers, they make direct calls to piece manager methods to report received blocks or state changes. The connection calls <code>SubmitBlockData()</code> on the piece manager when a piece message arrives, providing the piece index, block offset, and data payload. This direct call allows the connection to immediately know if the block was accepted or if there was an error.</p>\n<p>The torrent parser operates entirely through direct method calls since it provides a synchronous service to initialize the other components. The main client code calls <code>ParseFromFile()</code> and receives a complete <code>MetaInfo</code> structure that it then passes to other components during their initialization.</p>\n<p><strong>Channel-Based Message Passing for Asynchronous Coordination</strong></p>\n<p>For operations that can be handled asynchronously or that involve coordination between multiple goroutines, the system uses Go channels to pass messages and work items between components. This approach prevents blocking and allows components to process work at their own pace while maintaining proper ordering.</p>\n<p>The piece manager uses several channels to coordinate its internal operations:</p>\n<table>\n<thead>\n<tr>\n<th>Channel</th>\n<th>Type</th>\n<th>Purpose</th>\n<th>Producer</th>\n<th>Consumer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>workRequests</code></td>\n<td><code>chan WorkRequest</code></td>\n<td>Assigns download work to peers</td>\n<td>PieceManager main goroutine</td>\n<td>Peer request handlers</td>\n</tr>\n<tr>\n<td><code>blockData</code></td>\n<td><code>chan BlockData</code></td>\n<td>Reports received block data</td>\n<td>Connection goroutines</td>\n<td>PieceManager verification</td>\n</tr>\n<tr>\n<td><code>verificationResults</code></td>\n<td><code>chan VerificationResult</code></td>\n<td>Reports piece verification outcomes</td>\n<td>Verification pool workers</td>\n<td>PieceManager state updates</td>\n</tr>\n<tr>\n<td><code>peerEvents</code></td>\n<td><code>chan PeerEvent</code></td>\n<td>Reports peer connection changes</td>\n<td>PeerManager</td>\n<td>PieceManager interest updates</td>\n</tr>\n</tbody></table>\n<p>The tracker client uses channels to handle periodic announces without blocking other operations. It runs a background goroutine that waits on a timer channel and sends announce requests at the appropriate intervals, then sends results back through a response channel that other components can monitor.</p>\n<p><strong>Shared Data Structures with Synchronization</strong></p>\n<p>Some information must be accessible to multiple components simultaneously, requiring shared data structures protected by mutexes or other synchronization primitives. These structures serve as the &quot;single source of truth&quot; for critical state that affects coordination decisions.</p>\n<p>The piece state map is the most important shared data structure, containing the current status of every piece in the torrent:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Access Pattern</th>\n<th>Protection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pieces</code></td>\n<td><code>map[int]*PieceState</code></td>\n<td>Read: all components, Write: PieceManager only</td>\n<td><code>sync.RWMutex</code></td>\n</tr>\n<tr>\n<td><code>statistics</code></td>\n<td><code>*Statistics</code></td>\n<td>Read: tracker client, Write: piece manager</td>\n<td><code>sync.RWMutex</code></td>\n</tr>\n<tr>\n<td><code>connections</code></td>\n<td><code>map[string]*Connection</code></td>\n<td>Read: piece manager, Write: peer manager</td>\n<td><code>sync.RWMutex</code></td>\n</tr>\n<tr>\n<td><code>bitfields</code></td>\n<td><code>map[string]*BitfieldOps</code></td>\n<td>Read: piece manager, Write: connections</td>\n<td>Per-connection mutex</td>\n</tr>\n</tbody></table>\n<p>The piece manager holds the write lock on the piece map when updating piece states after verification, but uses read locks when selecting pieces for download. This allows multiple peer connections to concurrently check piece availability without blocking each other, while ensuring consistency when pieces are completed.</p>\n<p>Connection state is managed through per-connection mutexes that protect the choking/interested flags and pending request maps. When a connection receives a choke message from a peer, it acquires its own mutex to update the <code>peerChoking</code> flag and clear any pending requests, then notifies the piece manager through a channel message.</p>\n<p><strong>Event-Driven State Updates</strong></p>\n<p>The system uses an event-driven architecture where state changes in one component trigger notifications to other components that need to react to those changes. This decouples components and allows them to operate independently while maintaining system-wide consistency.</p>\n<p>When a peer connection completes its handshake and receives a bitfield, it generates a <code>PeerAvailable</code> event that gets sent to the piece manager. The piece manager responds by updating its peer availability map and potentially selecting new pieces to download from the newly available peer.</p>\n<p>Similarly, when the piece manager completes verification of a downloaded piece, it generates events that notify the tracker client (to update upload/download statistics), the peer connections (to update interest states), and the file writer (to persist the piece data to disk).</p>\n<p>The tracker client operates on a timer-driven event model where it generates <code>AnnounceNeeded</code> events based on the interval provided by the tracker, then sends <code>PeerListUpdate</code> events when announce responses are received with new peer information.</p>\n<blockquote>\n<p><strong>Decision: Channel-Based vs Callback-Based Event System</strong></p>\n<ul>\n<li><strong>Context</strong>: Components need to notify each other of state changes without tight coupling</li>\n<li><strong>Options Considered</strong>: Direct callbacks, observer pattern, channel-based messaging</li>\n<li><strong>Decision</strong>: Channel-based messaging with typed event structures</li>\n<li><strong>Rationale</strong>: Channels provide natural backpressure, are type-safe, integrate well with Go&#39;s concurrency model, and allow easy testing by mocking channel interactions</li>\n<li><strong>Consequences</strong>: Slightly more complex setup but much better testability, debuggability, and resilience to component failures</li>\n</ul>\n</blockquote>\n<h3 id=\"concurrency-coordination\">Concurrency Coordination</h3>\n<p>Managing concurrency in a BitTorrent client presents unique challenges because the system must coordinate dozens of independent peer connections while maintaining consistency of shared state and avoiding race conditions. Think of this like managing a busy restaurant kitchen where multiple chefs (peer connections) are working on different dishes (pieces) simultaneously, sharing common ingredients (blocks) and equipment (network resources), while the head chef (piece manager) coordinates the timing so that complete meals (verified pieces) are delivered to customers (written to disk) in the correct order.</p>\n<p>The complexity comes from the fact that BitTorrent operations are inherently asynchronous and distributed, with network delays, peer behavior, and piece availability constantly changing. The system must handle these dynamic conditions while ensuring that shared data structures remain consistent and that the download progresses efficiently.</p>\n<p><strong>Goroutine Architecture and Lifecycle Management</strong></p>\n<p>The BitTorrent client uses a structured approach to goroutine management where each major component runs in its own goroutine or goroutine pool, with clearly defined lifecycles and shutdown procedures.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Goroutines</th>\n<th>Lifecycle</th>\n<th>Shutdown Signal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>TrackerClient</code></td>\n<td>1 announce goroutine</td>\n<td>Starts with first announce, runs until completion</td>\n<td>Context cancellation</td>\n</tr>\n<tr>\n<td><code>PeerManager</code></td>\n<td>1 connection manager + N connection handlers</td>\n<td>Starts during peer discovery, connection handlers spawn/die with connections</td>\n<td>Connection-specific contexts</td>\n</tr>\n<tr>\n<td><code>PieceManager</code></td>\n<td>1 coordinator + M verification workers</td>\n<td>Starts immediately after metadata parsing, runs until completion</td>\n<td>Completion detection</td>\n</tr>\n<tr>\n<td><code>Connection</code></td>\n<td>2 per connection (read/write)</td>\n<td>Spawned when TCP connection established, dies on disconnect</td>\n<td>Connection close</td>\n</tr>\n</tbody></table>\n<p>Each goroutine operates independently but coordinates through the message passing and shared state mechanisms described earlier. The key insight is that goroutines should own their local state and communicate changes rather than directly modifying shared state, reducing the need for fine-grained locking.</p>\n<p>The main client goroutine acts as the lifecycle coordinator, starting and stopping component goroutines in the correct order and handling shutdown signals. When the user cancels the download or the download completes, the main goroutine cancels the root context, which cascades cancellation signals to all component contexts.</p>\n<p><strong>Shared State Synchronization Patterns</strong></p>\n<p>The most critical synchronization challenge involves the piece state map, which must be accessed by multiple peer connections simultaneously for piece selection and progress tracking, while being updated by the piece manager when pieces are completed.</p>\n<p>The system uses a read-write mutex pattern where the piece manager holds exclusive write access during state updates, but allows concurrent read access for piece selection:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Reader Pattern (Piece Selection):\n1. Acquire read lock on piece map\n2. Examine piece states and peer bitfields\n3. Identify candidate pieces for download\n4. Release read lock\n5. Make download requests (no locks held)\n\nWriter Pattern (Piece Completion):\n1. Verify piece hash outside of any locks\n2. Acquire write lock on piece map\n3. Update piece state to completed\n4. Update statistics and availability maps\n5. Release write lock\n6. Notify other components via channels</code></pre></div>\n\n<p>This pattern minimizes lock contention because piece selection (read operations) happens much more frequently than piece completion (write operations), and the read operations can proceed concurrently without interfering with each other.</p>\n<p>Connection state synchronization follows a different pattern because each connection&#39;s state is independent. Each <code>Connection</code> object has its own mutex that protects its local state (choking flags, pending requests, bitfield), eliminating contention between different peer connections.</p>\n<p><strong>Request Pipeline Coordination</strong></p>\n<p>One of the most complex coordination challenges involves managing the request pipeline where multiple blocks within a piece may be requested from different peers, and the system must track which blocks have been requested, received, and verified while avoiding duplicate requests and handling peer failures.</p>\n<p>The piece manager maintains a sophisticated state machine for each piece that tracks individual block states:</p>\n<table>\n<thead>\n<tr>\n<th>Block State</th>\n<th>Meaning</th>\n<th>Next States</th>\n<th>Coordination Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Needed</code></td>\n<td>Block not yet requested</td>\n<td><code>Requested</code></td>\n<td>None - initial state</td>\n</tr>\n<tr>\n<td><code>Requested</code></td>\n<td>Block requested from specific peer</td>\n<td><code>Received</code>, <code>Needed</code></td>\n<td>Must track timeout and peer identity</td>\n</tr>\n<tr>\n<td><code>Received</code></td>\n<td>Block data received and buffered</td>\n<td><code>Verified</code></td>\n<td>Must wait for all blocks in piece</td>\n</tr>\n<tr>\n<td><code>Verified</code></td>\n<td>Part of completed, hash-verified piece</td>\n<td>Final state</td>\n<td>Must coordinate file write</td>\n</tr>\n</tbody></table>\n<p>The coordination challenge comes from the fact that block requests may time out, peers may disconnect, or multiple peers may send the same block. The system handles these scenarios through careful state management:</p>\n<p>When a peer connection wants to request blocks, it calls <code>RequestWork()</code> on the piece manager with its peer ID and available piece bitfield. The piece manager examines its internal state, selects appropriate blocks that are in the <code>Needed</code> state, atomically transitions them to <code>Requested</code> with the requesting peer&#39;s ID, and returns the list of blocks to request.</p>\n<p>If a peer disconnects or a request times out, the piece manager scans for blocks in the <code>Requested</code> state associated with that peer and transitions them back to <code>Needed</code> so they can be requested from other peers. This recovery process must be atomic to prevent blocks from being lost or double-requested.</p>\n<p><strong>Endgame Mode Coordination</strong></p>\n<p>The endgame mode presents the most complex coordination challenge because the normal piece selection rules change and the system begins requesting the same blocks from multiple peers simultaneously. This requires careful coordination to avoid wasting bandwidth while ensuring the download completes quickly.</p>\n<p>The <code>EndgameManager</code> monitors download progress and activates when fewer than <code>MAX_ENDGAME_PIECES</code> remain incomplete. Once activated, it changes the request strategy to send requests for remaining blocks to all peers that have the containing pieces, then cancels duplicate requests as soon as any peer provides the block.</p>\n<p>This coordination requires tracking which peers have been sent requests for which blocks, and when a block is received, immediately sending cancel messages to all other peers that were sent requests for the same block. The timing is critical because cancel messages may not arrive before peers send the duplicate data, so the system must be prepared to receive and discard duplicate blocks.</p>\n<blockquote>\n<p><strong>Decision: Optimistic vs Pessimistic Concurrency Control</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple peers may attempt to download the same pieces simultaneously</li>\n<li><strong>Options Considered</strong>: Pessimistic locking (reserve pieces), optimistic conflicts (detect and resolve), hybrid approach</li>\n<li><strong>Decision</strong>: Optimistic with conflict detection for normal mode, pessimistic for endgame</li>\n<li><strong>Rationale</strong>: Optimistic allows better parallelism when conflicts are rare, but endgame requires careful coordination to avoid waste</li>\n<li><strong>Consequences</strong>: More complex state management but better performance and simpler deadlock avoidance</li>\n</ul>\n</blockquote>\n<p><strong>Graceful Shutdown Coordination</strong></p>\n<p>Properly shutting down a BitTorrent client requires careful coordination to ensure that in-flight operations complete cleanly and that the final state is reported to the tracker. The shutdown process follows a specific sequence that allows components to complete their work before terminating.</p>\n<p>When shutdown is initiated (either by user request or download completion), the main goroutine begins an orderly shutdown process. First, it signals the peer manager to stop accepting new connections and begin closing existing connections gracefully. Existing connections are allowed to complete any in-flight piece requests before closing.</p>\n<p>The piece manager continues processing incoming block data and verification until all peer connections have closed, ensuring that any blocks received during shutdown are properly handled. Only after all peer connections have terminated does the piece manager shut down its verification workers.</p>\n<p>Finally, the tracker client sends a final announce to report the current statistics and indicate that the peer is leaving the swarm. This announce uses the &quot;stopped&quot; event type and helps other peers in the swarm understand that this peer is no longer available.</p>\n<p>The entire shutdown process is coordinated through context cancellation that flows from the main goroutine to all component goroutines, with each component responsible for completing its cleanup tasks before the context deadline expires.</p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fdownload-sequence.svg\" alt=\"Complete Download Flow\"></p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"BitTorrent Client Architecture\"></p>\n<p><img src=\"/api/project/build-bittorrent/architecture-doc/asset?path=diagrams%2Fconcurrent-download.svg\" alt=\"Multi-Peer Download Coordination\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides the infrastructure and coordination code needed to orchestrate the complete BitTorrent download lifecycle. The target is a clean, production-ready implementation that handles the complex interactions between components.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Coordination Aspect</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Inter-component messaging</td>\n<td>Go channels with struct types</td>\n<td>Event bus with typed handlers</td>\n</tr>\n<tr>\n<td>State synchronization</td>\n<td><code>sync.RWMutex</code> on shared maps</td>\n<td>Lock-free data structures with atomic operations</td>\n</tr>\n<tr>\n<td>Goroutine coordination</td>\n<td>Context-based cancellation</td>\n<td>Supervised goroutine trees with restart policies</td>\n</tr>\n<tr>\n<td>Error propagation</td>\n<td>Error return values + logging</td>\n<td>Structured error events with recovery strategies</td>\n</tr>\n<tr>\n<td>Progress tracking</td>\n<td>Atomic counters + periodic reports</td>\n<td>Real-time metrics with time-series storage</td>\n</tr>\n</tbody></table>\n<p>For a learning implementation, stick with the simple approaches that use Go&#39;s built-in concurrency primitives effectively.</p>\n<p><strong>Recommended Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  client/\n    client.go              ← Main orchestration logic\n    lifecycle.go           ← Download lifecycle management\n    events.go             ← Inter-component event types\n  coordination/\n    piece_coordinator.go   ← Piece request coordination\n    peer_coordinator.go    ← Peer connection coordination\n    state_manager.go       ← Shared state synchronization\n  statistics/\n    tracker.go            ← Download progress tracking\n    metrics.go            ← Performance metrics</code></pre></div>\n\n<p><strong>Event System Infrastructure (Complete)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> client</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EventType represents the type of events that flow between components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EventType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EventPeerConnected</span><span style=\"color:#B392F0\"> EventType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EventPeerDisconnected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EventPieceCompleted</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EventBlockReceived</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EventTrackerResponse</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EventDownloadComplete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Event represents a coordination event between components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type      </span><span style=\"color:#B392F0\">EventType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PeerID    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Data      </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EventBus coordinates message passing between components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EventBus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscribers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">EventType</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> Event</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex       </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx         </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel      </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEventBus creates a new event coordination system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEventBus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    busCtx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">EventBus</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        subscribers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">EventType</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ctx:         busCtx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cancel:      cancel,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Subscribe registers a channel to receive events of specified type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">eb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Subscribe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">eventType</span><span style=\"color:#B392F0\"> EventType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bufferSize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eb.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> eb.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ch </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">, bufferSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eb.subscribers[eventType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(eb.subscribers[eventType], ch)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Publish sends an event to all subscribers of the event type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">eb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Publish</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eb.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscribers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> eb.subscribers[event.Type]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eb.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event.Timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, ch </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> subscribers {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> ch </span><span style=\"color:#F97583\">&#x3C;-</span><span style=\"color:#E1E4E8\"> event:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Event delivered successfully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">eb.ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Subscriber's buffer is full, skip this subscriber</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // In production, might want to log this condition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shutdown closes all subscriber channels and stops the event bus</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">eb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eb.</span><span style=\"color:#B392F0\">cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eb.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> eb.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, channels </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> eb.subscribers {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, ch </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> channels {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            close</span><span style=\"color:#E1E4E8\">(ch)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eb.subscribers </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">EventType</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>State Synchronization Infrastructure (Complete)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> coordination</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SharedState manages synchronized access to global BitTorrent state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SharedState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieces      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connections </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statistics  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieceMutex      </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connectionMutex </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statsMutex      </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Statistics tracks download progress and performance metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Statistics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Downloaded    </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">     // Bytes successfully downloaded and verified</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Uploaded      </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">     // Bytes uploaded to other peers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Left          </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">     // Bytes remaining to download</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\"> // When download began</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CompletedPieces </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">     // Number of pieces completed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalPieces     </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">     // Total pieces in torrent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectedPeers  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">     // Currently connected peer count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewSharedState creates synchronized state manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewSharedState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">totalPieces</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">totalLength</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pieces:      </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceState</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        connections: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        statistics: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">Statistics</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Left:        totalLength,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            StartTime:   time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            TotalPieces: totalPieces,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetPieceState safely retrieves piece state for reading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ss </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetPieceState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.pieceMutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ss.pieceMutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ss.pieces[pieceIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdatePieceState safely updates piece state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ss </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdatePieceState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">PieceState</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.pieceMutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ss.pieceMutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.pieces[pieceIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetAvailablePieces returns slice of piece indices that need downloading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ss </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetAvailablePieces</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.pieceMutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ss.pieceMutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> needed []</span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> index, piece </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> ss.pieces {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> piece.State </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PieceStateNeeded {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            needed </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(needed, index)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddConnection registers a new peer connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ss </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">peerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">conn</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.connectionMutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ss.connectionMutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.connections[peerID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> conn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statsMutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statistics.ConnectedPeers</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statsMutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveConnection unregisters a peer connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ss </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">peerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.connectionMutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ss.connectionMutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(ss.connections, peerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statsMutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statistics.ConnectedPeers</span><span style=\"color:#F97583\">--</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statsMutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetConnections returns all active connections (copy for safety)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ss </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetConnections</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.connectionMutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ss.connectionMutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connections </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Connection</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> id, conn </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> ss.connections {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        connections[id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> conn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> connections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateStatistics safely updates download progress statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ss </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateStatistics</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">downloaded</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">uploaded</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">completedPieces</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statsMutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ss.statsMutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statistics.Downloaded </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> downloaded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statistics.Uploaded </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> uploaded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statistics.Left </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ss.statistics.Left </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (downloaded </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> ss.statistics.Downloaded)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statistics.CompletedPieces </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> completedPieces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetStatistics returns current statistics (copy for safety)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ss </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SharedState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetStatistics</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Statistics</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ss.statsMutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ss.statsMutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ss.statistics </span><span style=\"color:#6A737D\">// Return copy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Main Client Orchestration (Skeleton)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> client</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">internal/coordination</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">internal/peer</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">internal/piece</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">internal/torrent</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">internal/tracker</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Client orchestrates the complete BitTorrent download process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Client</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metaInfo     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sharedState  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">coordination</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SharedState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eventBus     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trackerClient </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tracker</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerManager   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">peer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieceManager  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">piece</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PieceManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx    </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewClient creates a BitTorrent client for the specified torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">torrentPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse torrent file using torrent.ParseFromFile()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate total file length and expected piece count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create shared state manager with piece count and file size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create event bus for component coordination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Initialize tracker client with metainfo</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Initialize peer manager with event bus</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Initialize piece manager with metainfo and shared state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Set up context for lifecycle management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Download orchestrates the complete download lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Download</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">outputPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start tracker communication to get initial peer list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Subscribe to peer connection events from peer manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Subscribe to piece completion events from piece manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start peer manager to begin connection attempts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start piece manager to coordinate downloads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Monitor download progress and handle events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Detect completion condition (all pieces verified)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Send completion announce to tracker</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Begin seeding mode (serve pieces to other peers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use select statement to handle multiple event channels</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check for context cancellation to support early termination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handlePeerEvent processes peer connection state changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handlePeerEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract peer ID and event type from event data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update shared state based on connection/disconnection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For new connections, trigger interest state updates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For disconnections, clean up pending requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update connection count statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handlePieceEvent processes piece completion and verification events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handlePieceEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract piece index and verification result from event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update piece state in shared state manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update download statistics (bytes downloaded, pieces completed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if download is complete (all pieces verified)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Notify tracker client if significant progress made</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update interest states for all peer connections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shutdown gracefully terminates all client operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Cancel context to signal shutdown to all components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Stop accepting new peer connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Allow in-flight piece requests to complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Send final statistics to tracker with \"stopped\" event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Close all peer connections gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Shutdown event bus and clean up resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Wait for all goroutines to terminate with timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// isDownloadComplete checks if all pieces have been verified</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isDownloadComplete</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get current statistics from shared state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compare completed pieces to total expected pieces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return true only if all pieces completed and verified</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints</strong></p>\n<p>After implementing the coordination infrastructure, verify these behaviors:</p>\n<ol>\n<li><p><strong>Event Flow Verification</strong>: Create a simple test that publishes events through the event bus and verifies that subscribers receive them in the correct order without blocking.</p>\n</li>\n<li><p><strong>Concurrent State Access</strong>: Run multiple goroutines that simultaneously read and write piece states through the shared state manager, ensuring no race conditions occur.</p>\n</li>\n<li><p><strong>Lifecycle Coordination</strong>: Start the full client with a small test torrent and verify that components start up in the correct order and shut down cleanly when cancelled.</p>\n</li>\n<li><p><strong>Progress Reporting</strong>: Monitor the statistics during a real download to ensure that progress is accurately tracked and reported to the tracker at appropriate intervals.</p>\n</li>\n</ol>\n<p>Expected behavior: The client should successfully coordinate all components, handle peer connections and disconnections gracefully, maintain accurate download progress, and complete downloads without deadlocks or race conditions.</p>\n<p><strong>Common Integration Issues</strong></p>\n<p>⚠️ <strong>Pitfall: Deadlocks in State Access</strong>\nWhen multiple components need to access shared state simultaneously, incorrect lock ordering can cause deadlocks. Always acquire locks in a consistent order: pieces, then connections, then statistics.</p>\n<p>⚠️ <strong>Pitfall: Event Channel Blocking</strong>\nIf event subscribers don&#39;t process events quickly enough, the event bus can block publishers. Use buffered channels and handle the case where subscribers can&#39;t keep up by dropping events if necessary.</p>\n<p>⚠️ <strong>Pitfall: Goroutine Leaks During Shutdown</strong>\nComponents may not terminate cleanly if they&#39;re blocked on channel operations or waiting for network I/O. Always use context cancellation with timeouts to force termination if graceful shutdown fails.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in Statistics</strong>\nDownload statistics are accessed by multiple components simultaneously. Protect all statistics updates with mutexes and be careful about compound operations that read-modify-write multiple fields.</p>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to all milestones (1-4) by establishing comprehensive error handling strategies that ensure robustness across torrent parsing, tracker communication, peer protocols, and piece management.</p>\n</blockquote>\n<p>Building a robust BitTorrent client requires anticipating and gracefully handling numerous failure scenarios that arise in distributed peer-to-peer systems. Unlike centralized systems where failures are localized and predictable, BitTorrent clients must operate in an adversarial environment where peers may misbehave, networks partition unpredictably, and data corruption occurs frequently. This section establishes comprehensive error handling strategies that transform a fragile prototype into a production-ready client capable of operating reliably in the chaotic world of peer-to-peer file sharing.</p>\n<p>Think of error handling in BitTorrent like designing a ship to navigate treacherous waters. Just as a well-designed vessel must handle storms, equipment failures, and unpredictable conditions while maintaining course toward its destination, a BitTorrent client must gracefully handle network failures, malicious peers, and data corruption while continuing to make progress toward completing the download. The key insight is that failures are not exceptional cases to be avoided, but normal operating conditions that must be anticipated and managed systematically.</p>\n<h3 id=\"system-failure-modes\">System Failure Modes</h3>\n<p>Understanding the complete catalog of potential failures is essential for building comprehensive error handling. BitTorrent clients operate in a complex distributed environment where failures can occur at every layer of the system stack, from low-level network connectivity to high-level protocol violations. Each failure mode requires specific detection mechanisms and recovery strategies.</p>\n<p><strong>Network-Level Failures</strong></p>\n<p>Network failures represent the most common category of issues encountered in peer-to-peer systems. These failures can occur at any point in the network stack and often manifest as timeouts, connection resets, or partial data transmission.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Mechanism</th>\n<th>Symptoms</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Timeout</td>\n<td>Socket connect() timeout</td>\n<td>TCP connection never establishes</td>\n<td>Exponential backoff retry with peer blacklisting</td>\n</tr>\n<tr>\n<td>Connection Reset</td>\n<td>ECONNRESET error</td>\n<td>Existing connection drops unexpectedly</td>\n<td>Immediate reconnection attempt with request replay</td>\n</tr>\n<tr>\n<td>Partial Read</td>\n<td>Incomplete message framing</td>\n<td>Message length prefix without payload</td>\n<td>Buffer incomplete data, retry read with timeout</td>\n</tr>\n<tr>\n<td>DNS Resolution Failure</td>\n<td>Resolver error for tracker hostname</td>\n<td>Cannot resolve tracker announce URL</td>\n<td>Try backup trackers, fallback to IP addresses</td>\n</tr>\n<tr>\n<td>Network Partition</td>\n<td>Multiple connection failures</td>\n<td>All peer connections timeout simultaneously</td>\n<td>Pause operations, retry after exponential backoff</td>\n</tr>\n<tr>\n<td>Bandwidth Exhaustion</td>\n<td>Slow transfer rates, timeouts</td>\n<td>Block downloads taking excessive time</td>\n<td>Reduce concurrent connections, implement rate limiting</td>\n</tr>\n</tbody></table>\n<p><strong>Tracker-Level Failures</strong></p>\n<p>Tracker failures directly impact peer discovery, which is critical for maintaining a healthy swarm connection. These failures require sophisticated retry logic and fallback mechanisms to ensure the client can continue discovering peers even when primary trackers are unavailable.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Mechanism</th>\n<th>Symptoms</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP 4xx Client Error</td>\n<td>HTTP response status code</td>\n<td>400-499 status in announce response</td>\n<td>Validate request parameters, fix encoding issues</td>\n</tr>\n<tr>\n<td>HTTP 5xx Server Error</td>\n<td>HTTP response status code</td>\n<td>500-599 status in announce response</td>\n<td>Exponential backoff retry, try backup trackers</td>\n</tr>\n<tr>\n<td>Malformed Response</td>\n<td>Bencode parsing error</td>\n<td>Invalid bencode in tracker response</td>\n<td>Skip response, mark tracker as unreliable</td>\n</tr>\n<tr>\n<td>Missing Required Fields</td>\n<td>Field validation error</td>\n<td>Response missing &#39;peers&#39; or &#39;interval&#39;</td>\n<td>Use default values where possible, retry announce</td>\n</tr>\n<tr>\n<td>Tracker Timeout</td>\n<td>HTTP request timeout</td>\n<td>No response within configured timeout</td>\n<td>Mark tracker as slow, increase timeout for retries</td>\n</tr>\n<tr>\n<td>Invalid Peer List</td>\n<td>Compact peer parsing error</td>\n<td>Malformed compact peer data</td>\n<td>Skip invalid entries, use successfully parsed peers</td>\n</tr>\n</tbody></table>\n<p><strong>Peer Protocol Failures</strong></p>\n<p>Peer protocol failures occur during direct communication between BitTorrent clients and can range from simple message format errors to complex state machine violations. These failures require careful state management to prevent protocol deadlocks and ensure fair resource allocation.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Mechanism</th>\n<th>Symptoms</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Handshake Mismatch</td>\n<td>Info hash comparison</td>\n<td>Peer reports different info hash</td>\n<td>Immediately disconnect, blacklist peer</td>\n</tr>\n<tr>\n<td>Protocol Violation</td>\n<td>State machine validation</td>\n<td>Invalid message for current state</td>\n<td>Send protocol error, attempt graceful disconnect</td>\n</tr>\n<tr>\n<td>Message Corruption</td>\n<td>Length/checksum validation</td>\n<td>Message length doesn&#39;t match payload</td>\n<td>Request message retransmission, reset connection</td>\n</tr>\n<tr>\n<td>Peer Timeout</td>\n<td>Keepalive timer expiration</td>\n<td>No messages received within keepalive period</td>\n<td>Send keepalive, disconnect if no response</td>\n</tr>\n<tr>\n<td>Request Queue Overflow</td>\n<td>Pipeline depth tracking</td>\n<td>Too many outstanding requests</td>\n<td>Stop sending new requests, wait for completions</td>\n</tr>\n<tr>\n<td>Choke/Unchoke Cycling</td>\n<td>State change frequency monitoring</td>\n<td>Rapid choke/unchoke state changes</td>\n<td>Implement choke state dampening, reduce request rate</td>\n</tr>\n</tbody></table>\n<p><strong>Data Integrity Failures</strong></p>\n<p>Data integrity failures are particularly critical in BitTorrent because they can corrupt the downloaded file and waste significant bandwidth. These failures require immediate detection and recovery to prevent propagation of corrupt data.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Mechanism</th>\n<th>Symptoms</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece Hash Mismatch</td>\n<td>SHA1 verification</td>\n<td>Downloaded piece hash doesn&#39;t match torrent</td>\n<td>Discard piece, redownload from different peers</td>\n</tr>\n<tr>\n<td>Block Data Corruption</td>\n<td>Piece assembly validation</td>\n<td>Block doesn&#39;t fit expected piece structure</td>\n<td>Request block retransmission, check peer reliability</td>\n</tr>\n<tr>\n<td>File System Errors</td>\n<td>Write operation failures</td>\n<td>Cannot write piece data to disk</td>\n<td>Check disk space, permissions, retry with backoff</td>\n</tr>\n<tr>\n<td>Incomplete Piece Assembly</td>\n<td>Block count validation</td>\n<td>Missing blocks when piece should be complete</td>\n<td>Request missing blocks, verify block tracking</td>\n</tr>\n<tr>\n<td>Size Mismatch</td>\n<td>File length validation</td>\n<td>Downloaded file size doesn&#39;t match torrent metadata</td>\n<td>Verify piece boundaries, check for padding errors</td>\n</tr>\n<tr>\n<td>Write Permission Errors</td>\n<td>File system error codes</td>\n<td>Cannot create or modify output files</td>\n<td>Check permissions, suggest alternative output paths</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight</strong>: The key to robust error handling in BitTorrent is understanding that failures cascade through multiple layers. A network timeout doesn&#39;t just mean &quot;retry the connection&quot; – it means reassessing piece assignments, updating peer reliability scores, adjusting request pipeline depths, and potentially triggering tracker re-announce to find alternative peers.</p>\n</blockquote>\n<p><strong>State Consistency Failures</strong></p>\n<p>State consistency failures occur when different components of the BitTorrent client maintain conflicting views of system state. These failures are particularly dangerous because they can lead to subtle bugs that only manifest under specific timing conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Mechanism</th>\n<th>Symptoms</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece State Divergence</td>\n<td>Cross-component validation</td>\n<td>Different components report conflicting piece states</td>\n<td>Rebuild state from authoritative source (disk)</td>\n</tr>\n<tr>\n<td>Peer State Desynchronization</td>\n<td>Connection state validation</td>\n<td>Local peer state doesn&#39;t match peer&#39;s reported state</td>\n<td>Perform handshake renegotiation</td>\n</tr>\n<tr>\n<td>Request Tracking Mismatch</td>\n<td>Pipeline validation</td>\n<td>Outstanding requests don&#39;t match sent requests</td>\n<td>Clear request queue, resend active requests</td>\n</tr>\n<tr>\n<td>Bitfield Inconsistency</td>\n<td>Availability counting errors</td>\n<td>Peer availability doesn&#39;t match bitfield data</td>\n<td>Request fresh bitfield update</td>\n</tr>\n<tr>\n<td>Statistics Corruption</td>\n<td>Counter validation</td>\n<td>Downloaded/uploaded counters are inconsistent</td>\n<td>Recalculate statistics from piece state</td>\n</tr>\n<tr>\n<td>Concurrent Modification</td>\n<td>Lock validation failures</td>\n<td>Multiple threads modify shared state simultaneously</td>\n<td>Implement stricter locking, detect race conditions</td>\n</tr>\n</tbody></table>\n<h3 id=\"recovery-and-retry-logic\">Recovery and Retry Logic</h3>\n<p>Effective recovery from failures requires sophisticated retry logic that adapts to different types of failures and learns from past experiences. The key insight is that not all failures are equal – some indicate temporary network issues that resolve quickly, while others suggest fundamental problems requiring different recovery strategies.</p>\n<p><strong>Exponential Backoff Strategy</strong></p>\n<p>Exponential backoff prevents overwhelming failed services with repeated requests while providing reasonable recovery times for transient failures. The strategy must be tailored to different failure types because network timeouts require different backoff parameters than tracker server errors.</p>\n<p>The <code>BackoffScheduler</code> manages retry timing for different types of operations:</p>\n<table>\n<thead>\n<tr>\n<th>Operation Type</th>\n<th>Base Delay</th>\n<th>Max Delay</th>\n<th>Multiplier</th>\n<th>Jitter</th>\n<th>Reset Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tracker Announce</td>\n<td>30 seconds</td>\n<td>15 minutes</td>\n<td>2.0</td>\n<td>±25%</td>\n<td>Successful announce</td>\n</tr>\n<tr>\n<td>Peer Connection</td>\n<td>5 seconds</td>\n<td>5 minutes</td>\n<td>1.5</td>\n<td>±20%</td>\n<td>Successful handshake</td>\n</tr>\n<tr>\n<td>Block Request</td>\n<td>1 second</td>\n<td>30 seconds</td>\n<td>2.0</td>\n<td>±10%</td>\n<td>Successful block receipt</td>\n</tr>\n<tr>\n<td>File I/O Operation</td>\n<td>100ms</td>\n<td>10 seconds</td>\n<td>3.0</td>\n<td>±15%</td>\n<td>Successful write</td>\n</tr>\n<tr>\n<td>DNS Resolution</td>\n<td>2 seconds</td>\n<td>2 minutes</td>\n<td>2.0</td>\n<td>±30%</td>\n<td>Successful resolution</td>\n</tr>\n</tbody></table>\n<p>The backoff algorithm follows this progression:</p>\n<ol>\n<li>Start with the base delay for the operation type</li>\n<li>After each failure, multiply the current delay by the multiplier</li>\n<li>Add random jitter to prevent thundering herd effects</li>\n<li>Cap the delay at the maximum value for the operation type</li>\n<li>Reset to base delay when the reset condition is met</li>\n<li>Track consecutive failures to implement circuit breaker patterns</li>\n</ol>\n<p><strong>Circuit Breaker Pattern</strong></p>\n<p>Circuit breakers prevent the client from repeatedly attempting operations that are likely to fail, providing fast failure responses and reducing resource waste. Different components require different circuit breaker configurations based on their failure characteristics and recovery patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Failure Threshold</th>\n<th>Recovery Timeout</th>\n<th>Half-Open Requests</th>\n<th>Success Threshold</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tracker Client</td>\n<td>5 consecutive failures</td>\n<td>5 minutes</td>\n<td>1 announce</td>\n<td>2 successes</td>\n</tr>\n<tr>\n<td>Peer Connection</td>\n<td>3 consecutive handshake failures</td>\n<td>2 minutes</td>\n<td>1 connection</td>\n<td>1 success</td>\n</tr>\n<tr>\n<td>File Writer</td>\n<td>10 consecutive write failures</td>\n<td>30 seconds</td>\n<td>1 write</td>\n<td>3 successes</td>\n</tr>\n<tr>\n<td>DNS Resolver</td>\n<td>3 consecutive resolution failures</td>\n<td>1 minute</td>\n<td>1 resolution</td>\n<td>1 success</td>\n</tr>\n</tbody></table>\n<p>The circuit breaker state machine operates as follows:</p>\n<ol>\n<li><strong>Closed State</strong>: Normal operation, all requests pass through</li>\n<li><strong>Open State</strong>: All requests fail immediately without attempting the operation</li>\n<li><strong>Half-Open State</strong>: Allow limited requests to test if the service has recovered</li>\n<li><strong>Recovery</strong>: If half-open requests succeed, return to closed state</li>\n</ol>\n<p><strong>Peer Quality Scoring</strong></p>\n<p>Peer quality scoring helps the client prioritize reliable peers and avoid problematic ones. The scoring system tracks multiple metrics to build a comprehensive view of peer reliability and performance.</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Weight</th>\n<th>Positive Factors</th>\n<th>Negative Factors</th>\n<th>Decay Rate</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Reliability</td>\n<td>0.3</td>\n<td>Successful handshakes</td>\n<td>Connection timeouts, resets</td>\n<td>0.95/hour</td>\n</tr>\n<tr>\n<td>Data Quality</td>\n<td>0.4</td>\n<td>Correct piece hashes</td>\n<td>Hash mismatches, corruption</td>\n<td>0.9/hour</td>\n</tr>\n<tr>\n<td>Transfer Performance</td>\n<td>0.2</td>\n<td>Fast block transfers</td>\n<td>Slow responses, timeouts</td>\n<td>0.98/hour</td>\n</tr>\n<tr>\n<td>Protocol Compliance</td>\n<td>0.1</td>\n<td>Proper message format</td>\n<td>Protocol violations</td>\n<td>0.85/hour</td>\n</tr>\n</tbody></table>\n<p>The scoring algorithm maintains a running average for each peer:</p>\n<ol>\n<li>Initialize all peers with a neutral score (0.5)</li>\n<li>Update scores based on observed behavior using weighted factors</li>\n<li>Apply time-based decay to prevent permanent peer blacklisting</li>\n<li>Use scores to prioritize connection attempts and request assignments</li>\n<li>Implement minimum score thresholds for different operations</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Peer Scoring vs. Simple Blacklisting</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to handle unreliable peers while maintaining adequate peer diversity</li>\n<li><strong>Options Considered</strong>: Binary blacklisting, simple success/failure counters, comprehensive scoring system</li>\n<li><strong>Decision</strong>: Comprehensive scoring system with time-based decay</li>\n<li><strong>Rationale</strong>: Peers may become reliable over time, binary decisions lose valuable peer diversity, scoring provides fine-grained prioritization</li>\n<li><strong>Consequences</strong>: More complex implementation but better peer utilization and fault tolerance</li>\n</ul>\n</blockquote>\n<p><strong>Request Recovery and Replay</strong></p>\n<p>When peer connections fail during active downloads, the client must recover in-flight requests and reassign them to other peers. This process requires careful coordination between the piece manager and peer connections to prevent data loss and duplicate work.</p>\n<p>The request recovery process follows these steps:</p>\n<ol>\n<li><strong>Failure Detection</strong>: Peer connection detects network failure or timeout</li>\n<li><strong>Request Inventory</strong>: Catalog all outstanding requests for the failed peer</li>\n<li><strong>State Validation</strong>: Verify which requests were actually in progress</li>\n<li><strong>Peer Notification</strong>: Inform piece manager of the connection failure</li>\n<li><strong>Request Reassignment</strong>: Piece manager reassigns requests to other available peers</li>\n<li><strong>Progress Preservation</strong>: Maintain download progress statistics and piece state</li>\n<li><strong>Quality Update</strong>: Update peer quality scores based on the failure</li>\n</ol>\n<p>The reassignment algorithm prioritizes requests based on several factors:</p>\n<table>\n<thead>\n<tr>\n<th>Priority Factor</th>\n<th>Weight</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece Rarity</td>\n<td>0.4</td>\n<td>Rare pieces are harder to obtain from alternative peers</td>\n</tr>\n<tr>\n<td>Request Age</td>\n<td>0.3</td>\n<td>Older requests represent more invested effort</td>\n</tr>\n<tr>\n<td>Peer Availability</td>\n<td>0.2</td>\n<td>More available peers increase reassignment success probability</td>\n</tr>\n<tr>\n<td>Block Position</td>\n<td>0.1</td>\n<td>Later blocks in a piece represent more completion progress</td>\n</tr>\n</tbody></table>\n<h3 id=\"protocol-edge-cases\">Protocol Edge Cases</h3>\n<p>BitTorrent protocol edge cases arise from the interaction between the formal protocol specification and real-world implementation variations. These edge cases often involve timing issues, message ordering problems, and interpretation ambiguities that can cause interoperability failures between different BitTorrent clients.</p>\n<p><strong>Message Ordering and Timing Edge Cases</strong></p>\n<p>The peer wire protocol assumes certain message ordering constraints, but network delays and concurrent processing can violate these assumptions. The client must handle out-of-order messages and timing-dependent protocol states gracefully.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Scenario</th>\n<th>Detection</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bitfield After Pieces</td>\n<td>Peer sends bitfield after piece messages</td>\n<td>Message sequence validation</td>\n<td>Merge bitfield with existing piece knowledge</td>\n</tr>\n<tr>\n<td>Request Before Unchoke</td>\n<td>Request received while peer should be choked</td>\n<td>Choke state validation</td>\n<td>Queue request for when peer becomes unchoked</td>\n</tr>\n<tr>\n<td>Piece for Unrequested Block</td>\n<td>Piece message for block we didn&#39;t request</td>\n<td>Request tracking validation</td>\n<td>Accept piece if needed, update request tracking</td>\n</tr>\n<tr>\n<td>Double Handshake</td>\n<td>Multiple handshake messages on same connection</td>\n<td>Handshake completion flag</td>\n<td>Ignore duplicate handshake, continue normal protocol</td>\n</tr>\n<tr>\n<td>Stale Keep-Alive</td>\n<td>Keep-alive messages after connection should be closed</td>\n<td>Connection state tracking</td>\n<td>Ignore keep-alive, proceed with connection cleanup</td>\n</tr>\n<tr>\n<td>Race Condition Choke</td>\n<td>Choke message arrives after request sent</td>\n<td>Message timestamp comparison</td>\n<td>Honor choke, cancel in-flight requests</td>\n</tr>\n</tbody></table>\n<p><strong>Message Format Edge Cases</strong></p>\n<p>Real-world BitTorrent implementations sometimes generate messages that deviate from the strict protocol specification. The client must be liberal in what it accepts while maintaining security and correctness.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Violation</th>\n<th>Tolerance Strategy</th>\n<th>Security Consideration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Oversized Bitfield</td>\n<td>Bitfield longer than expected piece count</td>\n<td>Truncate to expected length</td>\n<td>Validate against maximum torrent size</td>\n</tr>\n<tr>\n<td>Invalid Message Length</td>\n<td>Length prefix doesn&#39;t match payload size</td>\n<td>Attempt payload parsing with actual length</td>\n<td>Limit maximum message size to prevent DoS</td>\n</tr>\n<tr>\n<td>Unknown Message Type</td>\n<td>Message ID not in protocol specification</td>\n<td>Log and ignore unknown messages</td>\n<td>Track unknown message frequency per peer</td>\n</tr>\n<tr>\n<td>Missing Keep-Alive</td>\n<td>No keep-alive within expected interval</td>\n<td>Extend timeout, send our own keep-alive</td>\n<td>Implement maximum silence period</td>\n</tr>\n<tr>\n<td>Zero-Length Request</td>\n<td>Request with zero-byte length</td>\n<td>Treat as invalid, send rejection</td>\n<td>Prevent infinite loops in request handling</td>\n</tr>\n<tr>\n<td>Duplicate Have Messages</td>\n<td>Multiple have messages for same piece</td>\n<td>Ignore duplicates, update availability once</td>\n<td>Track message frequency to detect spam</td>\n</tr>\n</tbody></table>\n<p><strong>State Machine Violations</strong></p>\n<p>Peer state machines can enter invalid states due to message loss, network partitions, or implementation bugs. The client must detect these violations and recover to a consistent state.</p>\n<table>\n<thead>\n<tr>\n<th>Violation Type</th>\n<th>Invalid Transition</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request While Choked</td>\n<td>Sending request when peer is choking us</td>\n<td>Outbound message validation</td>\n<td>Buffer request until unchoked</td>\n</tr>\n<tr>\n<td>Interest Without Need</td>\n<td>Claiming interest in peer with no needed pieces</td>\n<td>Bitfield intersection check</td>\n<td>Send not-interested message</td>\n</tr>\n<tr>\n<td>Choke Oscillation</td>\n<td>Rapid choke/unchoke cycles</td>\n<td>State change frequency tracking</td>\n<td>Implement choke state dampening</td>\n</tr>\n<tr>\n<td>Stale Interested State</td>\n<td>Remaining interested after obtaining all pieces</td>\n<td>Periodic interest validation</td>\n<td>Send not-interested and update state</td>\n</tr>\n<tr>\n<td>Request Pipeline Overflow</td>\n<td>Too many outstanding requests</td>\n<td>Pipeline depth tracking</td>\n<td>Stop sending requests until pipeline drains</td>\n</tr>\n<tr>\n<td>Bitfield Desync</td>\n<td>Peer&#39;s have messages inconsistent with bitfield</td>\n<td>Cross-reference have messages with bitfield</td>\n<td>Request fresh bitfield update</td>\n</tr>\n</tbody></table>\n<p><strong>Data Validation Edge Cases</strong></p>\n<p>Data validation must handle various forms of corruption and malicious data while maintaining download progress. The challenge is distinguishing between innocent errors and malicious attacks.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Data Issue</th>\n<th>Validation Approach</th>\n<th>Response Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Partial Hash Match</td>\n<td>Piece data partially correct</td>\n<td>Block-level validation where possible</td>\n<td>Re-request specific corrupt blocks</td>\n</tr>\n<tr>\n<td>Size Overflow</td>\n<td>Piece larger than expected</td>\n<td>Strict size limits before hash calculation</td>\n<td>Reject oversized pieces, penalize peer</td>\n</tr>\n<tr>\n<td>Encoding Issues</td>\n<td>Binary data in string fields</td>\n<td>Validate data encoding expectations</td>\n<td>Accept binary strings, log encoding mismatches</td>\n</tr>\n<tr>\n<td>Padding Bytes</td>\n<td>Extra bytes in file pieces</td>\n<td>Check against file boundary expectations</td>\n<td>Handle padding according to torrent specification</td>\n</tr>\n<tr>\n<td>Timestamp Anomalies</td>\n<td>Future or ancient timestamp in metadata</td>\n<td>Timestamp range validation</td>\n<td>Accept valid torrents with suspicious timestamps</td>\n</tr>\n<tr>\n<td>Unicode Issues</td>\n<td>Non-UTF8 strings in text fields</td>\n<td>Graceful encoding handling</td>\n<td>Attempt common encodings, fallback to byte display</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Treating All Protocol Violations as Attacks</strong></p>\n<p>Many developers implement overly strict protocol validation that disconnects peers for minor infractions. This approach reduces peer diversity and can prevent successful downloads. Instead, implement graduated responses: log minor violations, penalize moderate violations, and disconnect only for severe violations that threaten system integrity.</p>\n<p><strong>Concurrency and Race Condition Edge Cases</strong></p>\n<p>BitTorrent clients are inherently concurrent systems with multiple peer connections, piece management threads, and I/O operations running simultaneously. Race conditions and synchronization issues can lead to subtle bugs that only manifest under specific timing conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Race Condition</th>\n<th>Scenario</th>\n<th>Detection</th>\n<th>Prevention</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece Completion Race</td>\n<td>Multiple peers complete same piece simultaneously</td>\n<td>Duplicate completion detection</td>\n<td>Atomic piece state transitions</td>\n</tr>\n<tr>\n<td>Connection State Race</td>\n<td>Peer state changes while processing messages</td>\n<td>State consistency validation</td>\n<td>Message processing serialization</td>\n</tr>\n<tr>\n<td>Request Assignment Race</td>\n<td>Multiple threads assign same block</td>\n<td>Request tracking validation</td>\n<td>Centralized request coordination</td>\n</tr>\n<tr>\n<td>File Write Race</td>\n<td>Concurrent writes to same file region</td>\n<td>Write operation validation</td>\n<td>Serialize writes per file region</td>\n</tr>\n<tr>\n<td>Statistics Update Race</td>\n<td>Concurrent updates to download statistics</td>\n<td>Counter inconsistency detection</td>\n<td>Atomic counter operations</td>\n</tr>\n<tr>\n<td>Shutdown Race</td>\n<td>Component shutdown during active operations</td>\n<td>Operation completion tracking</td>\n<td>Graceful shutdown coordination</td>\n</tr>\n</tbody></table>\n<p>The key to preventing race conditions is implementing proper synchronization at the right granularity. Too coarse-grained locking reduces parallelism, while too fine-grained locking increases complexity and deadlock risk.</p>\n<blockquote>\n<p><strong>Decision: Fine-Grained vs. Coarse-Grained Locking</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance concurrency performance with synchronization complexity</li>\n<li><strong>Options Considered</strong>: Single global lock, per-component locks, fine-grained field-level locks</li>\n<li><strong>Decision</strong>: Per-component locks with careful lock ordering</li>\n<li><strong>Rationale</strong>: Provides good parallelism without excessive complexity, follows lock hierarchy to prevent deadlocks</li>\n<li><strong>Consequences</strong>: Enables concurrent operations while maintaining predictable synchronization behavior</li>\n</ul>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling implementation requires careful coordination between all system components to ensure consistent error recovery behavior. The key insight is building error handling into the system architecture from the beginning rather than adding it as an afterthought.</p>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Types</td>\n<td>Standard Go errors with error wrapping</td>\n<td>Custom error hierarchy with error codes and context</td>\n</tr>\n<tr>\n<td>Retry Logic</td>\n<td>Simple exponential backoff timers</td>\n<td>Configurable backoff strategies with circuit breakers</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard log package with structured fields</td>\n<td>Structured logging with error correlation IDs</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Basic error counters and timing metrics</td>\n<td>Comprehensive metrics with error categorization</td>\n</tr>\n<tr>\n<td>Recovery</td>\n<td>Manual retry on specific error conditions</td>\n<td>Automatic recovery with pluggable recovery strategies</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  errors/\n    types.go              ← Custom error types and error hierarchy\n    recovery.go           ← Retry and recovery logic implementations\n    circuit.go            ← Circuit breaker pattern implementation\n  coordinator/\n    errors.go             ← Component-specific error handling\n    recovery.go           ← Component recovery procedures\n  tracker/\n    errors.go             ← Tracker communication error handling\n    backoff.go            ← Tracker-specific retry logic\n  peer/\n    errors.go             ← Peer protocol error handling\n    validation.go         ← Message and state validation\n  piece/\n    errors.go             ← Piece management error handling\n    verification.go       ← Data integrity validation</code></pre></div>\n\n<p><strong>Infrastructure Starter Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package errors provides comprehensive error handling infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ErrorType categorizes different types of errors for appropriate handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ErrorType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorTypeNetwork</span><span style=\"color:#B392F0\"> ErrorType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorTypeProtocol</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorTypeData</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorTypeTracker</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorTypeFileSystem</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorTypeConcurrency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BitTorrentError wraps standard errors with additional context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BitTorrentError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type      </span><span style=\"color:#B392F0\">ErrorType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Component </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operation </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Err       </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Context   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitTorrentError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Component, e.Operation, e.Type, e.Err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BitTorrentError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Unwrap</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> e.Err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BackoffScheduler implements exponential backoff with jitter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BackoffScheduler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseDelay     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxDelay      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    multiplier    </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitterPercent </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentDelay  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failures      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBackoffScheduler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">base</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">multiplier</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackoffScheduler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BackoffScheduler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        baseDelay:     base,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxDelay:      max,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        multiplier:    multiplier,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        jitterPercent: </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentDelay:  base,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackoffScheduler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NextDelay</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    delay </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> b.currentDelay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.failures</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate next delay with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    next </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(b.currentDelay) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b.multiplier)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> b.maxDelay {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b.maxDelay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.currentDelay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add jitter to prevent thundering herd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitter </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(delay) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b.jitterPercent) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitterAmount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(rand.</span><span style=\"color:#B392F0\">Int63n</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(jitter</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">))) </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> jitter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> delay </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> jitterAmount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackoffScheduler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reset</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.currentDelay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b.baseDelay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.failures </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CircuitBreaker implements circuit breaker pattern for fail-fast behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CircuitBreaker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name              </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureThreshold  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recoveryTimeout   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    successThreshold  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state             </span><span style=\"color:#B392F0\">CircuitState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failures          </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    successes         </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastFailureTime   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex             </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CircuitState</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CircuitClosed</span><span style=\"color:#B392F0\"> CircuitState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CircuitOpen</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CircuitHalfOpen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCircuitBreaker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">failureThreshold</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">recoveryTimeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name:             name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        failureThreshold: failureThreshold,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        recoveryTimeout:  recoveryTimeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        successThreshold: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state:           CircuitClosed,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cb.</span><span style=\"color:#B392F0\">canExecute</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BitTorrentError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Type:      ErrorTypeNetwork,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Component: </span><span style=\"color:#9ECBFF\">\"circuit-breaker\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Operation: cb.name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Err:       fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"circuit breaker open\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Timestamp: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> operation</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.</span><span style=\"color:#B392F0\">recordResult</span><span style=\"color:#E1E4E8\">(err)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">canExecute</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cb.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> cb.state {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> CircuitClosed:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> CircuitOpen:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(cb.lastFailureTime) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> cb.recoveryTimeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> CircuitHalfOpen:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">recordResult</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cb.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cb.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cb.failures</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cb.lastFailureTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cb.failures </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> cb.failureThreshold {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CircuitOpen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cb.successes</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cb.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CircuitHalfOpen </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> cb.successes </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> cb.successThreshold {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CircuitClosed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.failures </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cb.successes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PeerQualityScorer tracks peer reliability and performance metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PeerQualityScorer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scores </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeerScore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex  </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PeerScore</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionReliability </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DataQuality          </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TransferPerformance  </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProtocolCompliance   </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastUpdate          </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPeerQualityScorer</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeerQualityScorer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PeerQualityScorer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scores: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeerScore</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pqs </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeerQualityScorer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateScore</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">peerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">metric</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pqs.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> pqs.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    score, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pqs.scores[peerID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        score </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PeerScore</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ConnectionReliability: </span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            DataQuality:          </span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            TransferPerformance:  </span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ProtocolCompliance:   </span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pqs.scores[peerID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> score</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Exponential moving average with time-based decay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alpha </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0.1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    decay </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pqs.</span><span style=\"color:#B392F0\">calculateDecay</span><span style=\"color:#E1E4E8\">(score.LastUpdate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> metric {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"connection\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        score.ConnectionReliability </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> score.ConnectionReliability</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">decay </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> value</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">alpha</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"data\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        score.DataQuality </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> score.DataQuality</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">decay </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> value</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">alpha</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"performance\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        score.TransferPerformance </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> score.TransferPerformance</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">decay </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> value</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">alpha</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"protocol\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        score.ProtocolCompliance </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> score.ProtocolCompliance</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">decay </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> value</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">alpha</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    score.LastUpdate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pqs </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeerQualityScorer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">calculateDecay</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">lastUpdate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hoursSince </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(lastUpdate).</span><span style=\"color:#B392F0\">Hours</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> math.</span><span style=\"color:#B392F0\">Pow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0.95</span><span style=\"color:#E1E4E8\">, hoursSince) </span><span style=\"color:#6A737D\">// 5% decay per hour</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ErrorHandler coordinates error recovery across all system components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ErrorHandler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    backoffSchedulers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackoffScheduler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    circuitBreakers   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CircuitBreaker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    qualityScorer     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeerQualityScorer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recoveryStrategies </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">ErrorType</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">RecoveryStrategy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eventBus          </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex             </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleError processes errors and determines appropriate recovery actions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">eh </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ErrorHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecoveryAction</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Unwrap error to extract BitTorrentError with type and context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Determine error severity and classification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check circuit breaker state for the failing component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate backoff delay based on error history</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Select appropriate recovery strategy based on error type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update peer quality scores if error involves specific peer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Publish error event to event bus for component coordination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return recovery action with delay and retry parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use type assertion to extract BitTorrentError details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecoverFromFailure executes recovery procedures for different failure types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">eh </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ErrorHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecoverFromFailure</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">failureType</span><span style=\"color:#B392F0\"> ErrorType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">component</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up recovery strategy for the specific failure type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if circuit breaker allows recovery attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate appropriate backoff delay before retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute pre-recovery validation and cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Attempt recovery operation with timeout and context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update component state based on recovery success/failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Record recovery metrics and update error statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Reset backoff scheduler on successful recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Recovery strategies may involve reconnection, re-announce, or state reset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateMessageIntegrity checks peer protocol messages for correctness</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateMessageIntegrity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">expectedType</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">maxSize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate message is not nil and has required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check message type matches expected type or is valid alternative</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify message payload size is within reasonable bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate message-specific payload format and constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check for known malformed message patterns from misbehaving clients</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return appropriate error type for different validation failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Different message types have different validation requirements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandlePieceVerificationFailure manages data integrity failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PieceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandlePieceVerificationFailure</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pieceIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">peerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Log piece verification failure with hash mismatch details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update peer quality score to reflect data integrity issue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Mark piece as incomplete and remove corrupted data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Cancel any outstanding requests for this piece from the same peer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add peer to temporary blacklist for this piece</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Request piece from alternative peers with higher quality scores</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update piece availability tracking to reflect failed verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Notify statistics tracker of wasted bandwidth and retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Consider whether this is first failure or repeated failure from same peer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleConnectionFailure manages peer connection loss and recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeerManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleConnectionFailure</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">peerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Catalog all outstanding requests for the failed peer connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update connection statistics and peer quality scores</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Notify piece manager to reassign outstanding requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Clean up connection state and release allocated resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Determine if connection should be retried or peer should be avoided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Schedule reconnection attempt with appropriate backoff delay</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update peer availability for piece selection algorithms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Trigger tracker re-announce if too many connections have failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Different error types suggest different retry strategies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ul>\n<li>Use Go&#39;s error wrapping with <code>fmt.Errorf(&quot;context: %w&quot;, err)</code> to maintain error chains for debugging</li>\n<li>Implement custom error types with methods like <code>Temporary() bool</code> and <code>Timeout() bool</code> for classification</li>\n<li>Use <code>context.WithTimeout()</code> for operations that need deadline-based failure detection</li>\n<li>Leverage Go&#39;s <code>sync.RWMutex</code> for protecting shared error state while allowing concurrent reads</li>\n<li>Use <code>time.NewTicker()</code> for implementing periodic error recovery attempts</li>\n<li>Implement proper cleanup with <code>defer</code> statements to ensure resources are released on error paths</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing comprehensive error handling:</p>\n<ol>\n<li><strong>Test Network Failure Recovery</strong>: Disconnect network during download, verify client recovers gracefully when connectivity returns</li>\n<li><strong>Verify Tracker Failover</strong>: Stop primary tracker, confirm client switches to backup trackers automatically</li>\n<li><strong>Validate Data Corruption Handling</strong>: Introduce corrupted piece data, verify client detects and recovers</li>\n<li><strong>Test Peer Protocol Violations</strong>: Send malformed messages, confirm client handles gracefully without crashing</li>\n<li><strong>Monitor Error Metrics</strong>: Verify error counters, backoff timers, and circuit breaker states update correctly</li>\n<li><strong>Check Concurrency Safety</strong>: Run under race detector (<code>go test -race</code>) to detect synchronization issues</li>\n</ol>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Client hangs after errors</td>\n<td>Deadlock in error recovery</td>\n<td>Check goroutine stack traces</td>\n<td>Review lock ordering, add timeouts</td>\n</tr>\n<tr>\n<td>Excessive retry attempts</td>\n<td>Backoff not working</td>\n<td>Log retry delays and counts</td>\n<td>Verify backoff implementation, add circuit breakers</td>\n</tr>\n<tr>\n<td>Memory leaks during errors</td>\n<td>Resources not cleaned up</td>\n<td>Monitor memory usage over time</td>\n<td>Add proper cleanup in error paths</td>\n</tr>\n<tr>\n<td>Inconsistent error handling</td>\n<td>Missing error checks</td>\n<td>Review error propagation</td>\n<td>Add error wrapping and consistent handling</td>\n</tr>\n<tr>\n<td>Performance degradation</td>\n<td>Too aggressive error recovery</td>\n<td>Profile CPU and network usage</td>\n<td>Tune backoff parameters, reduce retry frequency</td>\n</tr>\n<tr>\n<td>Error message confusion</td>\n<td>Poor error context</td>\n<td>Examine error message quality</td>\n<td>Add structured error information and correlation IDs</td>\n</tr>\n</tbody></table>\n<p>The comprehensive error handling system transforms a fragile BitTorrent prototype into a robust client capable of operating reliably in production environments. By anticipating failures, implementing graduated recovery strategies, and learning from past experiences, the client can maintain download progress even in challenging network conditions with unreliable peers.</p>\n<h2 id=\"testing-strategy-and-milestones\">Testing Strategy and Milestones</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides comprehensive testing guidance for all milestones (1-4) by establishing verification strategies, test checkpoints, and debugging approaches that ensure correct implementation across torrent parsing, tracker communication, peer protocols, and piece management.</p>\n</blockquote>\n<p>Building a BitTorrent client involves complex interactions between multiple concurrent systems, making testing both crucial and challenging. Think of testing a BitTorrent client like <strong>quality assurance for a busy restaurant kitchen</strong> — you need to verify that individual stations (bencode parser, tracker client) work correctly in isolation, that the coordination between stations (peer manager talking to piece manager) flows smoothly, and that the entire kitchen can handle a full dinner rush (downloading a complete torrent with multiple peers) without breaking down. Just as a restaurant needs both ingredient quality checks and full service simulations, our BitTorrent client requires both unit tests for individual components and integration tests with real torrents and peer interactions.</p>\n<p>The testing strategy must address several unique challenges in P2P systems: network failures can occur at any time, peers may behave unpredictably or maliciously, race conditions emerge from concurrent downloads, and timing-dependent behaviors make tests non-deterministic. Unlike traditional client-server applications where you control one endpoint, BitTorrent testing requires coordinating with external peers and trackers that may be unreliable or unavailable.</p>\n<p>Our testing approach follows a <strong>pyramid structure</strong> with three distinct layers, each serving different verification goals and catching different classes of bugs. The foundation consists of fast, deterministic unit tests that verify individual component logic without external dependencies. The middle layer includes integration tests that exercise component interactions using controlled environments and mock peers. The apex contains end-to-end tests that download real torrents from live networks, validating the complete system under realistic conditions.</p>\n<h3 id=\"unit-testing-strategy\">Unit Testing Strategy</h3>\n<p><strong>Unit testing</strong> for BitTorrent components focuses on verifying the correctness of individual algorithms and data transformations without network dependencies or concurrency complications. Think of unit tests as <strong>testing individual tools in a workshop</strong> — you verify that each hammer swings correctly, each saw cuts accurately, and each measuring tape gives precise readings before attempting to build furniture. Each component must demonstrate correct behavior under various inputs, edge cases, and error conditions in isolation.</p>\n<p>The bencode parsing component serves as an excellent example of comprehensive unit testing. Bencode parsing involves recursive data structure handling, binary string processing, and precise byte-level operations that are perfect candidates for deterministic unit tests. The parser must handle well-formed inputs correctly, detect malformed inputs gracefully, and maintain proper state across recursive calls.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Cases</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Valid Bencode Strings</td>\n<td><code>4:spam</code>, <code>0:</code>, <code>10:helloworld</code></td>\n<td>Correct byte array extraction</td>\n<td>Compare parsed bytes with expected values</td>\n</tr>\n<tr>\n<td>Valid Bencode Integers</td>\n<td><code>i42e</code>, <code>i-42e</code>, <code>i0e</code></td>\n<td>Correct integer conversion</td>\n<td>Verify parsed integer matches expected value</td>\n</tr>\n<tr>\n<td>Valid Bencode Lists</td>\n<td><code>le</code>, <code>l4:spami42ee</code>, nested lists</td>\n<td>Proper list structure and element parsing</td>\n<td>Recursively validate list contents and types</td>\n</tr>\n<tr>\n<td>Valid Bencode Dictionaries</td>\n<td><code>de</code>, <code>d4:spami42ee</code>, nested dicts</td>\n<td>Correct key-value mapping and ordering</td>\n<td>Verify all keys present with correct values</td>\n</tr>\n<tr>\n<td>Malformed Input</td>\n<td><code>4:spa</code>, <code>i42</code>, <code>l4:spam</code>, incomplete structures</td>\n<td>Appropriate error reporting</td>\n<td>Verify specific error types and positions</td>\n</tr>\n<tr>\n<td>Edge Cases</td>\n<td>Empty strings, zero integers, maximum values</td>\n<td>Boundary condition handling</td>\n<td>Test limits of integer ranges and string lengths</td>\n</tr>\n</tbody></table>\n<p>The torrent metadata extraction component requires tests that verify correct field extraction, info hash calculation, and validation logic. These tests use pre-computed torrent files with known metadata values, allowing precise verification of parsing accuracy.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Test Focus</th>\n<th>Key Test Cases</th>\n<th>Verification Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MetaInfo</code> Parsing</td>\n<td>Field extraction accuracy</td>\n<td>Single-file torrents, multi-file torrents, optional fields</td>\n<td>Compare extracted fields with manually verified values</td>\n</tr>\n<tr>\n<td>Info Hash Calculation</td>\n<td>SHA1 computation precision</td>\n<td>Various info dictionaries, edge cases</td>\n<td>Pre-compute expected hashes using reference implementations</td>\n</tr>\n<tr>\n<td>Piece Hash Extraction</td>\n<td>Hash array processing</td>\n<td>Different piece counts, hash validation</td>\n<td>Verify individual piece hashes match expected values</td>\n</tr>\n<tr>\n<td>URL Validation</td>\n<td>Announce URL processing</td>\n<td>HTTP/HTTPS URLs, multi-tracker lists</td>\n<td>Validate URL parsing and format requirements</td>\n</tr>\n</tbody></table>\n<p>Tracker communication unit tests focus on URL construction, parameter encoding, and response parsing without making actual HTTP requests. Mock HTTP responses allow testing various tracker response formats and error conditions in a controlled environment.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Input Data</th>\n<th>Expected Output</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Announce URL Construction</td>\n<td><code>AnnounceRequest</code> with all fields</td>\n<td>Properly encoded URL with all parameters</td>\n<td>Missing required fields should cause validation errors</td>\n</tr>\n<tr>\n<td>Binary Data Encoding</td>\n<td>Info hash with special bytes</td>\n<td>Correct percent-encoding</td>\n<td>Invalid byte sequences should be handled gracefully</td>\n</tr>\n<tr>\n<td>Compact Peer Parsing</td>\n<td>6-byte peer entries</td>\n<td><code>PeerInfo</code> structs with correct IP/port</td>\n<td>Truncated or invalid peer data should trigger errors</td>\n</tr>\n<tr>\n<td>Response Validation</td>\n<td>Tracker response dictionary</td>\n<td>Extracted interval, peer list, counts</td>\n<td>Missing required fields should be detected</td>\n</tr>\n</tbody></table>\n<p>The peer wire protocol components benefit enormously from unit testing because the protocol involves precise byte-level message formatting, state machine transitions, and binary data handling. These operations are deterministic and perfect for fast, reliable unit tests.</p>\n<table>\n<thead>\n<tr>\n<th>Protocol Component</th>\n<th>Test Categories</th>\n<th>Critical Test Cases</th>\n<th>Verification Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Handshake</code> Processing</td>\n<td>Serialization/deserialization</td>\n<td>Valid handshakes, wrong protocol, invalid lengths</td>\n<td>Binary comparison with reference implementations</td>\n</tr>\n<tr>\n<td><code>Message</code> Framing</td>\n<td>Length-prefixed parsing</td>\n<td>All message types, keep-alive, oversized messages</td>\n<td>Verify correct message reconstruction from bytes</td>\n</tr>\n<tr>\n<td><code>BitfieldOps</code> Operations</td>\n<td>Bit manipulation</td>\n<td>Set/get operations, edge piece indices, empty bitfields</td>\n<td>Mathematical verification of bit operations</td>\n</tr>\n<tr>\n<td>Peer State Machine</td>\n<td>State transitions</td>\n<td>All valid transitions, invalid transition attempts</td>\n<td>State verification after each message</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Testing with Real Network Dependencies</strong></p>\n<p>A common mistake in BitTorrent testing is writing unit tests that make actual network requests to trackers or attempt to connect to live peers. This approach creates flaky tests that fail due to network conditions, tracker availability, or external peer behavior rather than code bugs. Unit tests must be <strong>completely isolated</strong> from external dependencies.</p>\n<p>Instead, use dependency injection to provide mock implementations during testing. The tracker client should accept an HTTP client interface that can be replaced with a mock during testing. Similarly, peer connections should use mock network connections that simulate various network conditions and peer behaviors without requiring actual TCP connections.</p>\n<p>The piece management component presents unique unit testing challenges because it involves complex algorithms like rarest-first selection, concurrent request management, and content verification. However, these algorithms can be tested deterministically by providing controlled peer availability data and verifying piece selection decisions.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Test Focus</th>\n<th>Input Scenarios</th>\n<th>Expected Behaviors</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Rarest-First Selection</td>\n<td>Piece prioritization</td>\n<td>Various availability distributions</td>\n<td>Pieces with lowest availability selected first</td>\n</tr>\n<tr>\n<td>Block Request Generation</td>\n<td>Work distribution</td>\n<td>Peer bitfields, pipeline limits</td>\n<td>Correct block ranges, no overlapping requests</td>\n</tr>\n<tr>\n<td>Piece Verification</td>\n<td>Content integrity</td>\n<td>Valid pieces, corrupted pieces, hash mismatches</td>\n<td>Accept valid pieces, reject corrupt pieces with specific errors</td>\n</tr>\n<tr>\n<td>Endgame Detection</td>\n<td>Mode transition</td>\n<td>Nearly complete downloads</td>\n<td>Endgame activates at correct thresholds</td>\n</tr>\n</tbody></table>\n<h3 id=\"integration-testing\">Integration Testing</h3>\n<p><strong>Integration testing</strong> verifies that BitTorrent components work correctly together, handling the complex interactions between concurrent subsystems without the unpredictability of live network conditions. Think of integration testing as <strong>testing the entire restaurant service flow</strong> — you verify that orders flow correctly from the front-of-house to the kitchen, that timing coordination works between different cooking stations, and that completed dishes reach the correct tables. Integration tests use controlled environments with mock peers and local trackers to simulate realistic BitTorrent interactions.</p>\n<p>The key challenge in BitTorrent integration testing is managing the <strong>concurrency and timing dependencies</strong> that emerge when multiple components interact. The tracker client must coordinate with the peer manager to provide fresh peer lists, the peer manager must coordinate with the piece manager to request needed blocks, and the piece manager must coordinate with file I/O to assemble completed pieces. These interactions involve shared state, message passing, and timing-sensitive behaviors that require careful test orchestration.</p>\n<p>Integration tests for BitTorrent use several <strong>controlled environment techniques</strong> to provide realistic interactions while maintaining test reliability and speed. Local tracker servers provide predictable peer discovery without external dependencies. Mock peer implementations simulate various peer behaviors including normal operation, slow responses, connection failures, and protocol violations. Dedicated test torrents with known content allow verification of complete download cycles with predictable outcomes.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Test Level</th>\n<th>Components Involved</th>\n<th>Test Environment</th>\n<th>Validation Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parser + Tracker</td>\n<td><code>TorrentParser</code>, <code>TrackerClient</code></td>\n<td>Local HTTP server</td>\n<td>Torrent metadata flows correctly to tracker requests</td>\n</tr>\n<tr>\n<td>Tracker + Peer Manager</td>\n<td><code>TrackerClient</code>, <code>PeerManager</code></td>\n<td>Mock tracker with controlled peer lists</td>\n<td>Peer discovery and connection establishment</td>\n</tr>\n<tr>\n<td>Peer + Piece Manager</td>\n<td><code>PeerManager</code>, <code>PieceManager</code></td>\n<td>Mock peers with controlled bitfields</td>\n<td>Block request coordination and piece assembly</td>\n</tr>\n<tr>\n<td>Complete Download Flow</td>\n<td>All components</td>\n<td>Local tracker + mock peers + test torrent</td>\n<td>End-to-end download with verification</td>\n</tr>\n</tbody></table>\n<p>The <strong>tracker integration tests</strong> verify that the tracker client correctly processes torrent metadata to build announce requests and that the peer manager can establish connections with discovered peers. These tests use a local HTTP server that implements the tracker protocol, allowing precise control over tracker responses and timing.</p>\n<blockquote>\n<p><strong>Design Insight: Test Torrent Creation</strong>\nIntegration tests require specially crafted torrent files with predictable content and known piece hashes. Create test torrents from small text files with easily verifiable content (like &quot;Hello, World!&quot; repeated to fill exact piece boundaries). This allows tests to verify both the download mechanics and the final file content without requiring large data transfers.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Mock Tracker Behavior</th>\n<th>Expected Client Response</th>\n<th>Validation Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Successful Announce</td>\n<td>Return peer list with 3 mock peers</td>\n<td>Establish connections to all 3 peers</td>\n<td>Verify connection count, handshake completion</td>\n</tr>\n<tr>\n<td>Tracker Error Response</td>\n<td>Return failure reason</td>\n<td>Implement backoff and retry</td>\n<td>Verify exponential backoff timing</td>\n</tr>\n<tr>\n<td>Compact Peer Format</td>\n<td>Return binary peer list</td>\n<td>Parse IP/port correctly</td>\n<td>Verify individual peer addresses</td>\n</tr>\n<tr>\n<td>Re-announce Timing</td>\n<td>Specify announce interval</td>\n<td>Re-announce at correct intervals</td>\n<td>Verify timing and updated statistics</td>\n</tr>\n</tbody></table>\n<p><strong>Peer protocol integration tests</strong> focus on the interaction between peer connections and the piece management system. These tests use mock peer implementations that simulate various peer behaviors and network conditions to verify that the peer manager correctly handles the protocol state machine and block transfer logic.</p>\n<p>The mock peer implementation provides controlled responses to handshakes, bitfield exchanges, and piece requests. This allows testing various peer behaviors including immediate responses, delayed responses, connection drops, and protocol violations. The piece manager&#39;s reaction to these behaviors validates the robustness of the peer coordination logic.</p>\n<table>\n<thead>\n<tr>\n<th>Mock Peer Behavior</th>\n<th>Test Purpose</th>\n<th>Expected Client Reaction</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal Operation</td>\n<td>Happy path verification</td>\n<td>Complete block downloads</td>\n<td>All requested blocks received correctly</td>\n</tr>\n<tr>\n<td>Slow Responses</td>\n<td>Timeout handling</td>\n<td>Request retry or peer replacement</td>\n<td>Download continues with other peers</td>\n</tr>\n<tr>\n<td>Connection Drop</td>\n<td>Network failure resilience</td>\n<td>Graceful connection cleanup</td>\n<td>No resource leaks, request redistribution</td>\n</tr>\n<tr>\n<td>Invalid Messages</td>\n<td>Protocol violation handling</td>\n<td>Connection termination with error logging</td>\n<td>Malformed messages don&#39;t crash client</td>\n</tr>\n<tr>\n<td>Choking Behavior</td>\n<td>Upload permission changes</td>\n<td>Pause requests when choked, resume when unchoked</td>\n<td>Respect peer choking decisions</td>\n</tr>\n</tbody></table>\n<p><strong>Piece assembly integration tests</strong> verify the coordination between downloading blocks from multiple peers and assembling them into complete, verified pieces. These tests use multiple mock peers, each providing different pieces or blocks, to simulate the parallel downloading that occurs in real BitTorrent swarms.</p>\n<p>The test setup involves creating a small test torrent with 3-4 pieces, then using mock peers that each have different piece availability. The integration test verifies that the piece manager correctly coordinates block requests across peers, assembles received blocks into pieces, verifies piece hashes, and writes completed pieces to the output file.</p>\n<table>\n<thead>\n<tr>\n<th>Test Configuration</th>\n<th>Peer Setup</th>\n<th>Download Pattern</th>\n<th>Validation Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sequential Pieces</td>\n<td>Each peer has consecutive pieces</td>\n<td>Download pieces 0,1,2,3 in order</td>\n<td>Basic piece assembly and file writing</td>\n</tr>\n<tr>\n<td>Interleaved Availability</td>\n<td>Peers have overlapping piece sets</td>\n<td>Rarest-first selection with multiple sources</td>\n<td>Piece selection algorithm and peer coordination</td>\n</tr>\n<tr>\n<td>Partial Availability</td>\n<td>Some pieces only available from one peer</td>\n<td>Handle peer bottlenecks</td>\n<td>Request distribution and peer management</td>\n</tr>\n<tr>\n<td>Corrupted Pieces</td>\n<td>Mock peer sends invalid piece data</td>\n<td>Hash verification and re-request</td>\n<td>Content integrity and error recovery</td>\n</tr>\n</tbody></table>\n<h3 id=\"milestone-verification-checkpoints\">Milestone Verification Checkpoints</h3>\n<p><strong>Milestone verification checkpoints</strong> provide concrete, measurable criteria for determining whether each implementation phase is working correctly before proceeding to the next phase. Think of these checkpoints as <strong>quality gates in a manufacturing process</strong> — each stage must meet specific standards before the product moves to the next assembly station. These checkpoints catch integration issues early and ensure that each milestone provides a solid foundation for subsequent development.</p>\n<p>Each milestone checkpoint includes both <strong>automated verification</strong> through test execution and <strong>manual verification</strong> through observable behavior and output inspection. The automated tests provide rapid feedback on correctness, while manual verification ensures that the system exhibits expected behavior under realistic conditions.</p>\n<h4 id=\"milestone-1-torrent-file-parsing-checkpoints\">Milestone 1: Torrent File Parsing Checkpoints</h4>\n<p>The first milestone focuses on torrent file parsing and metadata extraction. Successful completion requires accurate bencode decoding, correct field extraction, and proper info hash calculation. The verification checkpoints ensure that parsing works correctly with various torrent file formats and edge cases.</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Method</th>\n<th>Expected Outcome</th>\n<th>Troubleshooting</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bencode Decoder</td>\n<td>Unit test suite with 50+ test cases</td>\n<td>All tests pass, handles all four bencode types</td>\n<td>Check for off-by-one errors in length parsing</td>\n</tr>\n<tr>\n<td>Torrent Metadata</td>\n<td>Parse real torrent files from various sources</td>\n<td>Extract announce URL, file info, piece data correctly</td>\n<td>Verify info dict boundaries using hex editor</td>\n</tr>\n<tr>\n<td>Info Hash Calculation</td>\n<td>Compare with reference implementations</td>\n<td>SHA1 hash matches expected values exactly</td>\n<td>Ensure bencoding preserves exact byte sequences</td>\n</tr>\n<tr>\n<td>Edge Case Handling</td>\n<td>Test with malformed and unusual torrents</td>\n<td>Graceful error reporting with specific error types</td>\n<td>Check error message clarity and debugging information</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification for Milestone 1:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test with a real torrent file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./bittorrent</span><span style=\"color:#9ECBFF\"> parse</span><span style=\"color:#9ECBFF\"> ubuntu-20.04.3-desktop-amd64.iso.torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Expected</span><span style=\"color:#9ECBFF\"> Output:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Announce</span><span style=\"color:#9ECBFF\"> URL:</span><span style=\"color:#9ECBFF\"> http://torrent.ubuntu.com:6969/announce</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Info</span><span style=\"color:#9ECBFF\"> Hash:</span><span style=\"color:#9ECBFF\"> a3b5c7e9f1d3e5a7b9c1f3e5a7b9c1d3e5a7b9c1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">File</span><span style=\"color:#9ECBFF\"> Name:</span><span style=\"color:#9ECBFF\"> ubuntu-20.04.3-desktop-amd64.iso</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">File</span><span style=\"color:#9ECBFF\"> Size:</span><span style=\"color:#9ECBFF\"> 2,785,017,856</span><span style=\"color:#9ECBFF\"> bytes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Piece</span><span style=\"color:#9ECBFF\"> Length:</span><span style=\"color:#9ECBFF\"> 262,144</span><span style=\"color:#9ECBFF\"> bytes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Piece</span><span style=\"color:#9ECBFF\"> Count:</span><span style=\"color:#9ECBFF\"> 10,630</span><span style=\"color:#9ECBFF\"> pieces</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Info Hash Calculation Errors</strong></p>\n<p>The most common error in Milestone 1 is incorrect info hash calculation due to improper handling of the bencoded info dictionary boundaries. The info hash must be calculated from the <strong>exact bencoded bytes</strong> of the info dictionary, not from a re-encoded version. Parse the torrent file, locate the start and end positions of the info dictionary in the original bytes, then calculate SHA1 from that exact byte slice.</p>\n<h4 id=\"milestone-2-tracker-communication-checkpoints\">Milestone 2: Tracker Communication Checkpoints</h4>\n<p>The second milestone implements tracker communication for peer discovery. Successful completion requires proper URL construction, binary data encoding, HTTP request handling, and peer list parsing. The checkpoints verify that the client can successfully communicate with various tracker types and handle different response formats.</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Method</th>\n<th>Expected Outcome</th>\n<th>Common Issues</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Announce URL Construction</td>\n<td>Unit tests with various parameter combinations</td>\n<td>Correctly formatted URLs with proper encoding</td>\n<td>Binary data encoding, parameter ordering</td>\n</tr>\n<tr>\n<td>HTTP Tracker Communication</td>\n<td>Integration test with local tracker</td>\n<td>Successful announce and peer list retrieval</td>\n<td>URL encoding, content-type headers</td>\n</tr>\n<tr>\n<td>Compact Peer Parsing</td>\n<td>Unit tests with known peer data</td>\n<td>Correct IP/port extraction from binary format</td>\n<td>Endianness, byte order interpretation</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Test with various tracker error responses</td>\n<td>Appropriate error detection and reporting</td>\n<td>HTTP status codes, tracker error messages</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification for Milestone 2:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test tracker communication</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./bittorrent</span><span style=\"color:#9ECBFF\"> announce</span><span style=\"color:#9ECBFF\"> ubuntu-20.04.3-desktop-amd64.iso.torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Expected</span><span style=\"color:#9ECBFF\"> Output:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Announcing</span><span style=\"color:#9ECBFF\"> to:</span><span style=\"color:#9ECBFF\"> http://torrent.ubuntu.com:6969/announce</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Announce</span><span style=\"color:#9ECBFF\"> Response:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  Interval:</span><span style=\"color:#79B8FF\"> 1800</span><span style=\"color:#9ECBFF\"> seconds</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  Complete:</span><span style=\"color:#79B8FF\"> 147</span><span style=\"color:#9ECBFF\"> seeders</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  Incomplete:</span><span style=\"color:#79B8FF\"> 23</span><span style=\"color:#9ECBFF\"> leechers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  Peers</span><span style=\"color:#9ECBFF\"> discovered:</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#9ECBFF\"> peers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  Sample</span><span style=\"color:#9ECBFF\"> peers:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    91.189.89.123:51413</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    185.125.190.39:42000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ...</span></span></code></pre></div>\n\n<p>The tracker communication checkpoint must verify that the client correctly handles both successful announcements and various error conditions. Test with multiple tracker URLs, including trackers that return errors, timeouts, and malformed responses.</p>\n<h4 id=\"milestone-3-peer-wire-protocol-checkpoints\">Milestone 3: Peer Wire Protocol Checkpoints</h4>\n<p>The third milestone implements the peer wire protocol including handshakes, message framing, and state management. The checkpoints verify correct protocol implementation, message parsing, and peer state coordination.</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Method</th>\n<th>Expected Outcome</th>\n<th>Critical Validations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Handshake Protocol</td>\n<td>Integration test with mock peers</td>\n<td>Successful handshake exchange</td>\n<td>Protocol string, info hash verification</td>\n</tr>\n<tr>\n<td>Message Parsing</td>\n<td>Unit tests with all message types</td>\n<td>Correct message deserialization</td>\n<td>Length framing, message ID handling</td>\n</tr>\n<tr>\n<td>Bitfield Exchange</td>\n<td>Integration test with controlled peers</td>\n<td>Accurate piece availability tracking</td>\n<td>Bitfield size calculation, bit operations</td>\n</tr>\n<tr>\n<td>State Machine</td>\n<td>Unit tests covering all transitions</td>\n<td>Proper choking/interested state management</td>\n<td>State transition validation, invalid state handling</td>\n</tr>\n<tr>\n<td>Request Pipeline</td>\n<td>Integration test with mock peer responses</td>\n<td>Multiple outstanding requests managed correctly</td>\n<td>Pipeline depth limits, request/response correlation</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification for Milestone 3:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test peer protocol with verbose logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./bittorrent</span><span style=\"color:#9ECBFF\"> connect</span><span style=\"color:#9ECBFF\"> 91.189.89.123:51413</span><span style=\"color:#79B8FF\"> --info-hash=a3b5c7e9f1d3e5a7b9c1f3e5a7b9c1d3e5a7b9c1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Expected</span><span style=\"color:#9ECBFF\"> Output:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Connecting</span><span style=\"color:#9ECBFF\"> to</span><span style=\"color:#9ECBFF\"> peer</span><span style=\"color:#9ECBFF\"> 91.189.89.123:51413...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Sending</span><span style=\"color:#9ECBFF\"> handshake...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Received</span><span style=\"color:#9ECBFF\"> handshake</span><span style=\"color:#9ECBFF\"> response:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  Protocol:</span><span style=\"color:#9ECBFF\"> BitTorrent</span><span style=\"color:#9ECBFF\"> protocol</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  Info</span><span style=\"color:#9ECBFF\"> Hash:</span><span style=\"color:#9ECBFF\"> a3b5c7e9f1d3e5a7b9c1f3e5a7b9c1d3e5a7b9c1</span><span style=\"color:#9ECBFF\"> ✓</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  Peer</span><span style=\"color:#9ECBFF\"> ID:</span><span style=\"color:#79B8FF\"> -UT355W-[random bytes]</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Received</span><span style=\"color:#9ECBFF\"> bitfield</span><span style=\"color:#9ECBFF\"> message:</span><span style=\"color:#9ECBFF\"> 1,327</span><span style=\"color:#9ECBFF\"> bytes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Peer</span><span style=\"color:#9ECBFF\"> has</span><span style=\"color:#9ECBFF\"> 8,547</span><span style=\"color:#9ECBFF\"> of</span><span style=\"color:#9ECBFF\"> 10,630</span><span style=\"color:#9ECBFF\"> pieces</span><span style=\"color:#E1E4E8\"> (80.4%)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Sending</span><span style=\"color:#9ECBFF\"> interested</span><span style=\"color:#9ECBFF\"> message...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Peer</span><span style=\"color:#9ECBFF\"> state:</span><span style=\"color:#9ECBFF\"> not</span><span style=\"color:#9ECBFF\"> choking,</span><span style=\"color:#9ECBFF\"> we</span><span style=\"color:#9ECBFF\"> are</span><span style=\"color:#9ECBFF\"> interested</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Message Framing Errors</strong></p>\n<p>Peer protocol message framing errors are common and difficult to debug. Each message starts with a 4-byte big-endian length prefix followed by the message data. Partial reads from TCP connections can split messages across multiple read operations. Implement a message buffer that accumulates bytes until complete messages are available for processing.</p>\n<h4 id=\"milestone-4-piece-management-amp-seeding-checkpoints\">Milestone 4: Piece Management &amp; Seeding Checkpoints</h4>\n<p>The final milestone implements piece downloading, verification, and seeding capabilities. The checkpoints verify complete download functionality, content integrity, and upload capabilities.</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Method</th>\n<th>Expected Outcome</th>\n<th>Key Metrics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece Verification</td>\n<td>Download test torrent with known content</td>\n<td>All pieces pass SHA1 verification</td>\n<td>Zero hash verification failures</td>\n</tr>\n<tr>\n<td>Download Completion</td>\n<td>End-to-end test with small torrent</td>\n<td>Complete file matches original exactly</td>\n<td>File size and content hash verification</td>\n</tr>\n<tr>\n<td>Rarest-First Selection</td>\n<td>Test with controlled peer availability</td>\n<td>Pieces selected in order of increasing availability</td>\n<td>Selection algorithm correctness</td>\n</tr>\n<tr>\n<td>Upload Capability</td>\n<td>Test with requesting peers</td>\n<td>Successfully serve piece data to other peers</td>\n<td>Upload statistics and peer satisfaction</td>\n</tr>\n<tr>\n<td>Concurrent Downloads</td>\n<td>Test with multiple simultaneous peers</td>\n<td>Efficient bandwidth utilization across peers</td>\n<td>Download rate and peer coordination</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification for Milestone 4:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Complete download test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./bittorrent</span><span style=\"color:#9ECBFF\"> download</span><span style=\"color:#9ECBFF\"> test-file.torrent</span><span style=\"color:#79B8FF\"> --output=/tmp/downloaded</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Expected</span><span style=\"color:#9ECBFF\"> Output:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Parsing</span><span style=\"color:#9ECBFF\"> torrent</span><span style=\"color:#9ECBFF\"> file...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Contacting</span><span style=\"color:#9ECBFF\"> tracker...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Discovered</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#9ECBFF\"> peers,</span><span style=\"color:#9ECBFF\"> connecting...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Connected</span><span style=\"color:#9ECBFF\"> to</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#9ECBFF\"> peers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Downloading...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Progress:</span><span style=\"color:#E1E4E8\"> [██████████████████████████████] 100% (</span><span style=\"color:#B392F0\">1.2</span><span style=\"color:#9ECBFF\"> MB/s</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Download</span><span style=\"color:#9ECBFF\"> complete:</span><span style=\"color:#9ECBFF\"> 2,785,017,856</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#9ECBFF\"> in</span><span style=\"color:#9ECBFF\"> 38m</span><span style=\"color:#9ECBFF\"> 42s</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Verifying</span><span style=\"color:#9ECBFF\"> final</span><span style=\"color:#9ECBFF\"> file</span><span style=\"color:#9ECBFF\"> hash...</span><span style=\"color:#9ECBFF\"> ✓</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Starting</span><span style=\"color:#9ECBFF\"> seeding</span><span style=\"color:#9ECBFF\"> mode...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Serving</span><span style=\"color:#9ECBFF\"> requests</span><span style=\"color:#9ECBFF\"> from</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#9ECBFF\"> peers...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Uploaded</span><span style=\"color:#79B8FF\"> 45.2</span><span style=\"color:#9ECBFF\"> MB</span><span style=\"color:#9ECBFF\"> to</span><span style=\"color:#9ECBFF\"> other</span><span style=\"color:#9ECBFF\"> peers</span></span></code></pre></div>\n\n<p>The final checkpoint must verify that the downloaded file is <strong>byte-for-byte identical</strong> to the original. Calculate the SHA1 hash of the completed file and compare it with the expected hash from the torrent metadata. Additionally, test that the client can successfully serve piece requests from other peers, demonstrating complete BitTorrent protocol implementation.</p>\n<blockquote>\n<p><strong>Critical Success Criteria</strong>\nThe ultimate test of Milestone 4 success is downloading a real torrent file from a live BitTorrent network. Choose a small, popular torrent (like a Linux distribution ISO) that has many seeders. Your client should successfully discover peers, download all pieces, verify content integrity, and produce a file that matches the original exactly. This demonstrates that your implementation is compatible with the broader BitTorrent ecosystem.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing infrastructure for a BitTorrent client requires careful setup to provide reliable, fast feedback while covering the complex interactions between concurrent components. The testing strategy emphasizes <strong>isolation</strong> for unit tests, <strong>controlled environments</strong> for integration tests, and <strong>realistic conditions</strong> for milestone verification.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Testing Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Testing Framework</td>\n<td>Go&#39;s built-in testing package (<code>testing</code>)</td>\n<td>Ginkgo + Gomega for BDD-style tests</td>\n</tr>\n<tr>\n<td>Mock Generation</td>\n<td>Manual mock interfaces</td>\n<td>GoMock for automatic mock generation</td>\n</tr>\n<tr>\n<td>HTTP Mocking</td>\n<td>httptest package for mock servers</td>\n<td>WireMock for complex HTTP scenarios</td>\n</tr>\n<tr>\n<td>Binary Test Data</td>\n<td>Embedded hex strings in test code</td>\n<td>Binary test files with loading utilities</td>\n</tr>\n<tr>\n<td>Test Assertion Library</td>\n<td>Basic Go assert functions</td>\n<td>Testify for rich assertion methods</td>\n</tr>\n<tr>\n<td>Concurrent Testing</td>\n<td>Go race detector (<code>go test -race</code>)</td>\n<td>Stress testing with multiple goroutines</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The testing structure mirrors the main code organization while providing comprehensive coverage and easy test execution:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/bittorrent/\n    main.go\n    main_test.go              ← CLI integration tests\n  internal/\n    torrent/\n      parser.go\n      parser_test.go          ← Bencode and metadata parsing tests\n      testdata/               ← Sample torrent files for testing\n        small.torrent\n        multi-file.torrent\n        malformed.torrent\n    tracker/\n      client.go\n      client_test.go          ← Tracker communication unit tests\n      mock_tracker_test.go    ← Local HTTP server for integration tests\n    peer/\n      connection.go\n      connection_test.go      ← Peer protocol unit tests\n      mock_peer_test.go       ← Mock peer implementations\n      protocol_test.go        ← Message framing and state machine tests\n    piece/\n      manager.go\n      manager_test.go         ← Piece selection and verification tests\n      integration_test.go     ← Multi-component integration tests\n  test/\n    fixtures/                 ← Test data and utilities\n      test_torrents/          ← Known good torrents for integration testing\n      mock_tracker.go         ← Reusable mock tracker implementation\n      mock_peer.go           ← Reusable mock peer implementation\n    integration/              ← End-to-end integration tests\n      download_test.go        ← Complete download cycle tests\n      seeding_test.go         ← Upload and seeding tests</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Test Torrent Generator</strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test/fixtures/torrent_generator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> fixtures</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourusername/bittorrent/internal/torrent</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestTorrentConfig defines parameters for generating test torrents</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TestTorrentConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FileName     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Content      []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PieceLength  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AnnounceURL  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateTestTorrent creates a complete torrent file with known content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// for testing download and verification logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> GenerateTestTorrent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> TestTorrentConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate piece count and generate piece hashes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pieceCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(config.Content)) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> config.PieceLength </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> config.PieceLength</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> pieceHashes []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">); i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> pieceCount; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> config.PieceLength</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> config.PieceLength</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">></span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(config.Content)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(config.Content))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sha1.</span><span style=\"color:#B392F0\">Sum</span><span style=\"color:#E1E4E8\">(config.Content[start:end])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pieceHashes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(pieceHashes, hash[:]</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build info dictionary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    info </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name:        config.FileName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Length:      </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(config.Content)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PieceLength: config.PieceLength,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Pieces:      pieceHashes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate info hash (would use actual bencode encoding)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    infoHash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sha1.</span><span style=\"color:#B392F0\">Sum</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mock-info-dict\"</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#6A737D\">// TODO: Implement proper bencoding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metaInfo </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Announce:     config.AnnounceURL,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CreationDate: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment:      </span><span style=\"color:#9ECBFF\">\"Generated for testing\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CreatedBy:    </span><span style=\"color:#9ECBFF\">\"BitTorrent Test Suite\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        InfoHash:     infoHash,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Info:         info,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> metaInfo, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteTestFile creates the actual file content for a test torrent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WriteTestFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">content</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Dir</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(path, content, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadTestTorrent loads a pre-built test torrent from the fixtures directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadTestTorrent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"testdata\"</span><span style=\"color:#E1E4E8\">, name</span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\">\".torrent\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> torrent.</span><span style=\"color:#B392F0\">ParseFromFile</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Mock Tracker Implementation</strong> (Complete HTTP server):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test/fixtures/mock_tracker.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> fixtures</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http/httptest</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/url</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MockTracker provides controlled tracker responses for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MockTracker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">httptest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    responses </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrackerResponse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    requests  []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrackerRequest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TrackerResponse</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Interval   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Complete   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Incomplete </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Peers      []</span><span style=\"color:#B392F0\">MockPeer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Error      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TrackerRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PeerID     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port       </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Uploaded   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Downloaded </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Left       </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Event      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MockPeer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IP   </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMockTracker creates a local HTTP server that implements tracker protocol</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMockTracker</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockTracker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MockTracker</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        responses: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrackerResponse</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        requests:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrackerRequest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewServeMux</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/announce\"</span><span style=\"color:#E1E4E8\">, mt.handleAnnounce)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mt.server </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> httptest.</span><span style=\"color:#B392F0\">NewServer</span><span style=\"color:#E1E4E8\">(mux)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> mt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetResponse configures the tracker response for a specific info hash</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockTracker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">infoHash</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">response</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TrackerResponse</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mt.responses[infoHash] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetRequests returns all announce requests received by the tracker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockTracker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetRequests</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrackerRequest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> mt.requests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// URL returns the mock tracker's announce URL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockTracker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">URL</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> mt.server.URL </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"/announce\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close shuts down the mock tracker server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockTracker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mt.server.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockTracker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleAnnounce</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse announce request parameters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    query </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.URL.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    request </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TrackerRequest</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        InfoHash:   query.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"info_hash\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PeerID:     query.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"peer_id\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Event:      query.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"event\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp:  time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse numeric parameters with error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> port, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">Atoi</span><span style=\"color:#E1E4E8\">(query.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"port\"</span><span style=\"color:#E1E4E8\">)); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request.Port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> uploaded, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(query.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"uploaded\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request.Uploaded </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> uploaded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> downloaded, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(query.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"downloaded\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request.Downloaded </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> downloaded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(query.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"left\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request.Left </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> left</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mt.requests </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(mt.requests, request)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Look up configured response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mt.responses[request.InfoHash]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Unknown torrent\"</span><span style=\"color:#E1E4E8\">, http.StatusNotFound)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return error response if configured</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> response.Error </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/plain\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusInternalServerError)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(response.Error))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build bencode response (simplified - would use proper bencode encoding)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    compactPeers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(response.Peers)</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, peer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> response.Peers {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(compactPeers[i</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">:], peer.IP.</span><span style=\"color:#B392F0\">To4</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(compactPeers[i</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">:], peer.Port)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement proper bencode encoding for production use</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/plain\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"d8:intervali\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">Itoa</span><span style=\"color:#E1E4E8\">(response.Interval) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                   \"e8:completei\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">Itoa</span><span style=\"color:#E1E4E8\">(response.Complete) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                   \"e10:incompletei\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">Itoa</span><span style=\"color:#E1E4E8\">(response.Incomplete) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                   \"e5:peers\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">Itoa</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(compactPeers)) </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \":\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(compactPeers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"e\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DefaultPeers returns a standard set of mock peers for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DefaultPeers</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">MockPeer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">MockPeer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {IP: net.</span><span style=\"color:#B392F0\">ParseIP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"192.168.1.100\"</span><span style=\"color:#E1E4E8\">), Port: </span><span style=\"color:#79B8FF\">6881</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {IP: net.</span><span style=\"color:#B392F0\">ParseIP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"10.0.0.50\"</span><span style=\"color:#E1E4E8\">), Port: </span><span style=\"color:#79B8FF\">51413</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {IP: net.</span><span style=\"color:#B392F0\">ParseIP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"172.16.1.200\"</span><span style=\"color:#E1E4E8\">), Port: </span><span style=\"color:#79B8FF\">42000</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-testing-logic-skeletons\">Core Testing Logic Skeletons</h4>\n<p><strong>Torrent Parsing Test Suite</strong> (Structure with detailed TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/torrent/parser_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestBencodeDecoding</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Test valid string decoding - create test cases for various string lengths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Test valid integer decoding - include positive, negative, and zero values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test valid list decoding - include empty lists and nested structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test valid dictionary decoding - include empty dicts and nested structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test malformed input handling - verify specific error types and positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Test edge cases - empty strings, maximum integer values, deeply nested structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use table-driven tests with input/expected output pairs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestTorrentMetadataExtraction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load test torrent file from testdata directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse torrent file using ParseFromFile function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify announce URL extraction matches expected value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify file info extraction (name, length, piece length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify piece hash extraction and count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Test with multi-file torrents and verify file list parsing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Pre-compute expected values using a reference BitTorrent implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestInfoHashCalculation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load torrent file and extract raw bencode bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Locate info dictionary boundaries in the raw bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate SHA1 hash of exact info dictionary bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Compare with expected hash from reference implementation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test with multiple torrent files to ensure consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify that re-encoding doesn't change the hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use hex.DecodeString to create expected hash values from known torrents</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Integration Test Suite</strong> (Structure with coordination logic):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test/integration/download_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> integration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourusername/bittorrent/test/fixtures</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCompleteDownloadCycle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create test torrent with known content using fixtures.GenerateTestTorrent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start mock tracker with configured peer list using fixtures.NewMockTracker</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start mock peers that serve the test torrent content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create BitTorrent client and initiate download</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Monitor download progress and verify piece-by-piece completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify final file content matches original exactly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Test seeding mode by having client serve requests from other mock peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use timeouts to prevent test hangs, typical integration test takes 10-30 seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestMultiPeerCoordination</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithTimeout</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">60</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create test torrent with multiple pieces (4-6 pieces)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Configure 3 mock peers with different piece availability patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Peer 1: has pieces 0, 2, 4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Peer 2: has pieces 1, 3, 5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Peer 3: has pieces 0, 1, 2 (overlapping)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify client discovers all peers through mock tracker</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Monitor piece requests to ensure optimal distribution across peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify rarest-first selection algorithm chooses pieces correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Simulate peer disconnection and verify client handles gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify download completes successfully using remaining peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Log all peer interactions to verify correct protocol behavior</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-scripts\">Milestone Checkpoint Scripts</h4>\n<p><strong>Automated Verification Scripts</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># scripts/verify-milestone-1.sh</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== Milestone 1: Torrent File Parsing Verification ===\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run unit tests</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Running bencode parsing tests...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/torrent/...</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestBencode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Running torrent metadata extraction tests...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/torrent/...</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestMetadata</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test with real torrent file</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Testing with real torrent file...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./bittorrent</span><span style=\"color:#9ECBFF\"> parse</span><span style=\"color:#9ECBFF\"> test/fixtures/testdata/small.torrent</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /tmp/parse_output.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify expected output format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"Announce URL:\"</span><span style=\"color:#9ECBFF\"> /tmp/parse_output.txt</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"Info Hash:\"</span><span style=\"color:#9ECBFF\"> /tmp/parse_output.txt</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"File Name:\"</span><span style=\"color:#9ECBFF\"> /tmp/parse_output.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✓ Torrent parsing output format correct\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✗ Torrent parsing output format incorrect\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cat</span><span style=\"color:#9ECBFF\"> /tmp/parse_output.txt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== Milestone 1 Verification Complete ===\"</span></span></code></pre></div>\n\n<p>The testing strategy provides a comprehensive foundation for building a robust BitTorrent client through systematic verification at multiple levels. Unit tests catch algorithmic errors and edge cases early, integration tests verify component interactions in controlled environments, and milestone checkpoints ensure each implementation phase meets quality standards before proceeding. This layered approach builds confidence that the final system will work correctly in the complex, unpredictable environment of real BitTorrent networks.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides essential debugging guidance for all milestones (1-4) by establishing systematic approaches to diagnose and fix common issues across torrent parsing, tracker communication, peer protocols, and piece management.</p>\n</blockquote>\n<p>Building a BitTorrent client involves multiple interacting systems: binary protocol parsing, concurrent networking, cryptographic verification, and complex state management. When things go wrong, the symptoms can be misleading and the root causes can be buried deep in protocol minutiae or race conditions. This debugging guide provides systematic approaches to diagnose and resolve the most common issues that learners encounter when implementing each milestone.</p>\n<p>Think of debugging a BitTorrent client like being a detective investigating a crime scene. Each symptom is a clue that points toward potential causes, but the evidence can be scattered across multiple components. A failed download might be caused by incorrect Bencode parsing, malformed tracker requests, peer protocol violations, or piece verification failures. The key is building a systematic methodology to collect evidence, form hypotheses, and test them methodically.</p>\n<p>The debugging process follows a consistent pattern across all components: observe the symptoms, collect diagnostic data, form hypotheses about root causes, test the hypotheses with targeted experiments, and verify the fixes. This section provides specific guidance for each milestone&#39;s unique challenges while establishing common debugging practices that apply across the entire system.</p>\n<h3 id=\"torrent-parsing-debug-guide\">Torrent Parsing Debug Guide</h3>\n<p>Torrent file parsing forms the foundation of the entire BitTorrent client, and parsing errors can manifest as mysterious failures much later in the download process. The Bencode format, while simple in concept, has several edge cases that can trap unwary implementers. Understanding these pitfalls and their debugging approaches is crucial for building a robust foundation.</p>\n<h4 id=\"bencode-parsing-issues\">Bencode Parsing Issues</h4>\n<p>The most common torrent parsing failures stem from incorrect Bencode decoding, which can produce subtly corrupted data that only manifests when used by other components. These issues require systematic diagnosis starting from the lowest level of byte interpretation.</p>\n<p><strong>Symptom-Cause-Fix Mapping for Bencode Parsing:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parser crashes on &quot;invalid character&quot;</td>\n<td>Treating binary data as UTF-8 string</td>\n<td>Print raw bytes around error offset, check for non-printable characters</td>\n<td>Use <code>[]byte</code> for all Bencode strings, not Go <code>string</code> type</td>\n</tr>\n<tr>\n<td>Info hash doesn&#39;t match tracker expectations</td>\n<td>Including extra bytes in info dict boundaries</td>\n<td>Log exact byte ranges used for hash calculation, compare with reference implementation</td>\n<td>Parse info dict as complete bencoded value, not individual fields</td>\n</tr>\n<tr>\n<td>Piece count mismatch</td>\n<td>Incorrect piece hash extraction from concatenated field</td>\n<td>Verify pieces field length is multiple of 20, count extracted hashes</td>\n<td>Extract 20-byte chunks sequentially, verify total length</td>\n</tr>\n<tr>\n<td>Random parsing failures on large files</td>\n<td>Buffer overruns or incorrect offset tracking</td>\n<td>Add offset logging to every parse step, verify buffer boundaries</td>\n<td>Implement proper bounds checking in decoder</td>\n</tr>\n<tr>\n<td>Nested dictionary corruption</td>\n<td>Stack overflow in recursive parsing</td>\n<td>Monitor recursion depth, check for circular references</td>\n<td>Add recursion depth limits and iterative parsing for deep nesting</td>\n</tr>\n</tbody></table>\n<p>The most insidious Bencode parsing bug involves the treatment of binary strings. Many implementers assume Bencode strings contain text data and convert them to their language&#39;s native string type. However, Bencode strings frequently contain binary data (like piece hashes or info dictionaries), and any encoding conversion corrupts this data.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: Bencode strings are binary-safe byte sequences, not text strings. Always parse them as byte arrays and only convert to text when you know the content is actually textual (like file names or announce URLs).</p>\n</blockquote>\n<h4 id=\"info-hash-calculation-debugging\">Info Hash Calculation Debugging</h4>\n<p>The info hash serves as the unique identifier for a torrent and must be calculated from the exact bencoded bytes of the info dictionary. Any deviation in these bytes produces a different hash, causing tracker and peer rejections. Info hash calculation errors are particularly difficult to debug because the hash looks &quot;correct&quot; but doesn&#39;t match what other clients compute.</p>\n<p><strong>Info Hash Validation Process:</strong></p>\n<ol>\n<li><strong>Isolate the exact info dictionary bytes</strong>: The info hash must be computed from the exact bencoded representation of the info dictionary as it appears in the torrent file, not from a re-encoding of parsed data</li>\n<li><strong>Verify byte boundaries</strong>: Log the start and end positions of the info dictionary within the torrent file and ensure no extra bytes are included</li>\n<li><strong>Cross-reference with known tools</strong>: Use standard tools like <code>transmission-show</code> or online torrent analyzers to get the expected info hash for comparison</li>\n<li><strong>Validate the SHA1 calculation</strong>: Ensure you&#39;re using SHA1 (not SHA256 or other hash functions) and computing it over the raw bytes</li>\n<li><strong>Check for encoding issues</strong>: Verify that no character encoding conversion has occurred on the info dictionary bytes</li>\n</ol>\n<p>A common debugging technique is to export the exact bytes used for hash calculation to a file and compute the SHA1 manually using command-line tools to verify your calculation logic.</p>\n<h4 id=\"torrent-metadata-extraction-issues\">Torrent Metadata Extraction Issues</h4>\n<p>Once Bencode parsing succeeds, extracting meaningful metadata from the parsed structures presents its own challenges. The BitTorrent specification has evolved over time, leading to multiple ways to represent the same information, and real-world torrent files often contain unexpected variations.</p>\n<p><strong>Metadata Extraction Debug Checklist:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Validation Check</th>\n<th>Expected Behavior</th>\n<th>Common Errors</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Announce URL</td>\n<td>URL format validation</td>\n<td>Valid HTTP/HTTPS/UDP URL</td>\n<td>Missing protocol, malformed URL encoding</td>\n</tr>\n<tr>\n<td>File Information</td>\n<td>Single vs multi-file detection</td>\n<td>Length field XOR files array present</td>\n<td>Both or neither present, incorrect total size calculation</td>\n</tr>\n<tr>\n<td>Piece Information</td>\n<td>Piece count calculation</td>\n<td><code>(pieces field length) / 20 == ceiling(total size / piece length)</code></td>\n<td>Off-by-one errors, integer division rounding</td>\n</tr>\n<tr>\n<td>Creation Date</td>\n<td>Unix timestamp validation</td>\n<td>Valid time within reasonable range</td>\n<td>Negative timestamps, far-future dates</td>\n</tr>\n<tr>\n<td>Encoding Fields</td>\n<td>Character set handling</td>\n<td>UTF-8 for modern torrents, other encodings for legacy</td>\n<td>Incorrect encoding assumptions</td>\n</tr>\n</tbody></table>\n<p>The piece count validation deserves special attention because it involves multiple related calculations. The number of piece hashes in the pieces field should match the number of pieces required to cover the total file size given the piece length. Mismatches indicate either parsing errors or corrupted torrent files.</p>\n<h3 id=\"network-protocol-debugging\">Network Protocol Debugging</h3>\n<p>Network protocol debugging requires understanding both the HTTP tracker protocol and the BitTorrent peer wire protocol. Network issues can manifest as connection failures, timeouts, protocol violations, or data corruption. The key to effective network debugging is systematic observation of the actual bytes sent and received, not just the application-level interpretation of those bytes.</p>\n<h4 id=\"tracker-communication-issues\">Tracker Communication Issues</h4>\n<p>Tracker communication failures are often the first network-related problems encountered during implementation. These issues typically stem from incorrect URL encoding, missing parameters, or mishandling of the tracker response format.</p>\n<p><strong>Tracker Debug Investigation Process:</strong></p>\n<ol>\n<li><strong>Capture the exact HTTP request</strong>: Log the complete URL with all parameters to verify proper construction</li>\n<li><strong>Verify URL encoding</strong>: Ensure binary data (like info hash) is percent-encoded correctly for URLs</li>\n<li><strong>Check parameter completeness</strong>: Confirm all required parameters (info_hash, peer_id, port, uploaded, downloaded, left) are present</li>\n<li><strong>Validate response parsing</strong>: Log the raw tracker response before attempting to parse it</li>\n<li><strong>Handle error responses</strong>: Check for error messages in tracker responses before assuming success</li>\n</ol>\n<p>The most frequent tracker communication bug involves incorrect URL encoding of the info hash. The 20-byte SHA1 hash contains binary data that must be percent-encoded for inclusion in HTTP URLs, but many implementers use incorrect encoding methods.</p>\n<p><strong>Tracker Communication Debug Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Diagnostic Command</th>\n<th>Expected Result</th>\n<th>Common Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Invalid info_hash&quot; error</td>\n<td><code>curl -v &quot;tracker_url&quot;</code> with parameters</td>\n<td>HTTP 200 with peer list</td>\n<td>Correct URL encoding of binary info hash</td>\n</tr>\n<tr>\n<td>Empty peer list</td>\n<td>Check <code>left</code> parameter value</td>\n<td>Should be &gt; 0 for incomplete downloads</td>\n<td>Set <code>left</code> to remaining bytes, not total bytes</td>\n</tr>\n<tr>\n<td>Tracker timeouts</td>\n<td>Network connectivity test to tracker</td>\n<td>Successful connection</td>\n<td>Implement proper timeout handling and retries</td>\n</tr>\n<tr>\n<td>Malformed peer data</td>\n<td>Hex dump of peers field in response</td>\n<td>6-byte entries (4 bytes IP + 2 bytes port)</td>\n<td>Handle compact peer format correctly</td>\n</tr>\n<tr>\n<td>Authentication failures</td>\n<td>Verify announce URL from torrent</td>\n<td>URL should match exactly</td>\n<td>Use announce URL from torrent, not guessed URL</td>\n</tr>\n</tbody></table>\n<h4 id=\"peer-wire-protocol-debugging\">Peer Wire Protocol Debugging</h4>\n<p>The BitTorrent peer wire protocol is more complex than HTTP tracker communication, involving stateful connections, message framing, and binary protocol adherence. Peer protocol debugging requires understanding the exact message formats and state machine transitions.</p>\n<p><strong>Peer Protocol Debug Strategy:</strong></p>\n<p>The peer protocol debugging process follows a layered approach, starting from the lowest level (TCP connection) and working up through handshakes, message framing, and application logic.</p>\n<p><strong>Connection Establishment Debug Steps:</strong></p>\n<ol>\n<li><strong>TCP connection verification</strong>: Confirm that TCP connections to peers can be established successfully</li>\n<li><strong>Handshake exchange validation</strong>: Verify that both sides of the handshake follow the exact 68-byte format</li>\n<li><strong>Protocol string matching</strong>: Ensure the 19-byte protocol identifier matches exactly</li>\n<li><strong>Info hash verification</strong>: Confirm that handshake info hashes match the torrent being downloaded</li>\n<li><strong>Peer ID exchange</strong>: Validate that peer IDs are exchanged correctly and stored for connection tracking</li>\n</ol>\n<p><strong>Message Framing Debug Process:</strong></p>\n<p>Message framing errors are particularly insidious because they can cause the entire connection to become unsynchronized, leading to cascading parsing failures for subsequent messages.</p>\n<table>\n<thead>\n<tr>\n<th>Framing Issue</th>\n<th>Symptoms</th>\n<th>Debug Approach</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Length prefix errors</td>\n<td>Messages appear corrupted or truncated</td>\n<td>Log raw bytes of length prefix, verify network byte order</td>\n<td>Use <code>binary.BigEndian</code> for 4-byte length prefix</td>\n</tr>\n<tr>\n<td>Partial message reads</td>\n<td>Parser hangs or fails randomly</td>\n<td>Implement complete message buffering before parsing</td>\n<td>Read exact message length bytes before processing</td>\n</tr>\n<tr>\n<td>Message type confusion</td>\n<td>Unexpected message type errors</td>\n<td>Log message ID byte after length prefix</td>\n<td>Verify message ID matches expected protocol values</td>\n</tr>\n<tr>\n<td>Keep-alive handling</td>\n<td>Connection timeouts or unexpected closes</td>\n<td>Monitor for zero-length messages</td>\n<td>Handle keep-alive messages (length 0) without message ID</td>\n</tr>\n<tr>\n<td>Buffer boundary errors</td>\n<td>Corruption at message boundaries</td>\n<td>Validate buffer management between messages</td>\n<td>Reset buffers properly between message reads</td>\n</tr>\n</tbody></table>\n<h4 id=\"state-machine-debugging\">State Machine Debugging</h4>\n<p>The peer protocol involves a complex state machine governing when requests can be sent and received. State machine violations can cause peers to disconnect or refuse to serve data.</p>\n<p><strong>Peer State Machine Debug Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Attempted Action</th>\n<th>Expected Behavior</th>\n<th>Debug Check</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>peer_choking = true</code></td>\n<td>Send request message</td>\n<td>Should be rejected/ignored</td>\n<td>Verify choke state before sending requests</td>\n</tr>\n<tr>\n<td><code>am_interested = false</code></td>\n<td>Expect piece messages</td>\n<td>Peer should not send data</td>\n<td>Send interested message before expecting data</td>\n</tr>\n<tr>\n<td><code>bitfield</code> not received</td>\n<td>Send requests for pieces</td>\n<td>Should fail or be ignored</td>\n<td>Wait for bitfield after handshake</td>\n</tr>\n<tr>\n<td>Connection just established</td>\n<td>Send requests immediately</td>\n<td>Should fail</td>\n<td>Complete handshake and bitfield exchange first</td>\n</tr>\n<tr>\n<td>Multiple pending requests</td>\n<td>Connection suddenly closes</td>\n<td>Likely protocol violation</td>\n<td>Check request pipelining limits</td>\n</tr>\n</tbody></table>\n<h3 id=\"concurrency-and-state-issues\">Concurrency and State Issues</h3>\n<p>BitTorrent clients are inherently concurrent systems, managing multiple peer connections, piece downloads, and verification processes simultaneously. Concurrency bugs are among the most challenging to debug because they often involve race conditions that only manifest under specific timing conditions or high load.</p>\n<h4 id=\"race-condition-identification\">Race Condition Identification</h4>\n<p>Race conditions in BitTorrent clients typically occur around shared data structures like piece state, peer connection management, and download progress tracking. These bugs are notoriously difficult to reproduce and debug because they depend on specific timing of concurrent operations.</p>\n<p><strong>Common Race Condition Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Race Condition Type</th>\n<th>Manifestation</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Piece state corruption</td>\n<td>Same piece downloaded multiple times or verification failures</td>\n<td>Log all piece state changes with timestamps and goroutine IDs</td>\n<td>Use mutex protection around piece state updates</td>\n</tr>\n<tr>\n<td>Connection map corruption</td>\n<td>Peer connections appear/disappear randomly</td>\n<td>Monitor connection map size and detect unexpected changes</td>\n<td>Synchronize all connection map access with read-write locks</td>\n</tr>\n<tr>\n<td>Download statistics inconsistency</td>\n<td>Progress reporting jumps or decreases</td>\n<td>Validate statistics consistency at regular intervals</td>\n<td>Use atomic operations for counter updates</td>\n</tr>\n<tr>\n<td>Request duplication</td>\n<td>Multiple requests for same block sent to different peers</td>\n<td>Log all outgoing requests with peer identification</td>\n<td>Coordinate block requests through central manager</td>\n</tr>\n<tr>\n<td>Verification race</td>\n<td>Piece verification runs on partially downloaded data</td>\n<td>Check for incomplete pieces entering verification</td>\n<td>Ensure atomic piece completion before verification</td>\n</tr>\n</tbody></table>\n<h4 id=\"deadlock-detection-and-prevention\">Deadlock Detection and Prevention</h4>\n<p>Deadlocks can occur when multiple goroutines wait for locks held by each other, typically involving the piece manager, peer connections, and shared state coordination. Deadlock detection requires understanding the lock acquisition order across different components.</p>\n<p><strong>Deadlock Prevention Strategy:</strong></p>\n<ol>\n<li><strong>Establish lock ordering</strong>: Define a consistent order for acquiring multiple locks across all components</li>\n<li><strong>Minimize lock scope</strong>: Hold locks for the shortest possible duration to reduce contention</li>\n<li><strong>Use timeouts</strong>: Implement timeout-based lock acquisition to detect potential deadlocks</li>\n<li><strong>Monitor lock contention</strong>: Log lock acquisition and release events during debugging</li>\n<li><strong>Separate read and write operations</strong>: Use read-write locks to allow concurrent reads when possible</li>\n</ol>\n<h4 id=\"state-synchronization-issues\">State Synchronization Issues</h4>\n<p>The BitTorrent client maintains complex shared state across multiple concurrent operations, and synchronization failures can lead to inconsistent views of download progress, peer availability, and piece completion status.</p>\n<p><strong>State Synchronization Debug Approach:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Shared State</th>\n<th>Synchronization Mechanism</th>\n<th>Common Issues</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PieceManager</td>\n<td>Piece completion status</td>\n<td>Read-write mutex on piece map</td>\n<td>Pieces marked complete before verification</td>\n</tr>\n<tr>\n<td>PeerManager</td>\n<td>Connection status and capabilities</td>\n<td>Connection map mutex</td>\n<td>Stale connection references</td>\n</tr>\n<tr>\n<td>Statistics</td>\n<td>Download/upload counters</td>\n<td>Atomic operations</td>\n<td>Inconsistent progress reporting</td>\n</tr>\n<tr>\n<td>BitfieldOps</td>\n<td>Available piece tracking</td>\n<td>Bitfield-level locking</td>\n<td>Race between bitfield updates and reads</td>\n</tr>\n<tr>\n<td>EventBus</td>\n<td>Event distribution</td>\n<td>Channel-based message passing</td>\n<td>Blocked subscribers causing deadlocks</td>\n</tr>\n</tbody></table>\n<h4 id=\"memory-leak-detection\">Memory Leak Detection</h4>\n<p>Long-running BitTorrent clients can develop memory leaks through accumulated goroutines, unclosed connections, or retained data structures. Memory leak debugging requires systematic monitoring of resource usage patterns.</p>\n<p><strong>Memory Leak Investigation Process:</strong></p>\n<ol>\n<li><strong>Monitor goroutine count</strong>: Use <code>runtime.NumGoroutine()</code> to detect goroutine leaks</li>\n<li><strong>Track connection lifecycle</strong>: Ensure all network connections are properly closed</li>\n<li><strong>Validate buffer management</strong>: Check for growing buffers that are never reset</li>\n<li><strong>Monitor piece data retention</strong>: Ensure completed pieces don&#39;t retain unnecessary data</li>\n<li><strong>Check event subscriber cleanup</strong>: Verify event bus subscribers are unregistered properly</li>\n</ol>\n<h3 id=\"debugging-tools-and-techniques\">Debugging Tools and Techniques</h3>\n<p>Effective BitTorrent debugging requires a combination of logging strategies, network monitoring tools, and systematic testing approaches. The distributed and concurrent nature of BitTorrent makes traditional debugging approaches insufficient.</p>\n<h4 id=\"logging-strategy\">Logging Strategy</h4>\n<p>A comprehensive logging strategy is essential for BitTorrent debugging because many issues only become apparent through analysis of event sequences across multiple components and connections.</p>\n<p><strong>Structured Logging Framework:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Log Level</th>\n<th>Component</th>\n<th>Event Types</th>\n<th>Example Information</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEBUG</td>\n<td>Bencode Parser</td>\n<td>Parse events, offset tracking</td>\n<td>&quot;Parsing dictionary at offset 1234, found 5 keys&quot;</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>Tracker Client</td>\n<td>Announce requests/responses</td>\n<td>&quot;Announce successful: 25 peers returned, interval 1800s&quot;</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>Peer Manager</td>\n<td>Connection lifecycle</td>\n<td>&quot;Connected to peer 192.168.1.5:6881, capabilities: extension protocol&quot;</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>Piece Manager</td>\n<td>Piece completion</td>\n<td>&quot;Piece 42 verified successfully, 847/1000 pieces complete&quot;</td>\n</tr>\n<tr>\n<td>WARN</td>\n<td>Protocol Handler</td>\n<td>Protocol violations</td>\n<td>&quot;Peer 192.168.1.5 sent request while choked, ignoring&quot;</td>\n</tr>\n<tr>\n<td>ERROR</td>\n<td>All Components</td>\n<td>Error conditions</td>\n<td>&quot;Failed to verify piece 15: hash mismatch, requesting from different peer&quot;</td>\n</tr>\n</tbody></table>\n<h4 id=\"network-traffic-analysis\">Network Traffic Analysis</h4>\n<p>Network-level debugging provides ground truth about what data is actually being sent and received, independent of application-level interpretation.</p>\n<p><strong>Network Analysis Tools:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Use Case</th>\n<th>Command Example</th>\n<th>Interpretation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Wireshark</td>\n<td>Complete protocol analysis</td>\n<td>GUI-based capture and filtering</td>\n<td>Examine exact bytes, timing, TCP behavior</td>\n</tr>\n<tr>\n<td>tcpdump</td>\n<td>Command-line packet capture</td>\n<td><code>tcpdump -i eth0 -s 0 host tracker.example.com</code></td>\n<td>Verify tracker communication</td>\n</tr>\n<tr>\n<td>netstat</td>\n<td>Connection state monitoring</td>\n<td><code>netstat -an | grep :6881</code></td>\n<td>Check peer connection status</td>\n</tr>\n<tr>\n<td>ss</td>\n<td>Modern connection analysis</td>\n<td><code>ss -tuln</code></td>\n<td>Monitor listening sockets and connections</td>\n</tr>\n<tr>\n<td>curl</td>\n<td>Manual HTTP testing</td>\n<td><code>curl -v &quot;http://tracker/announce?info_hash=...&quot;</code></td>\n<td>Test tracker requests manually</td>\n</tr>\n</tbody></table>\n<h4 id=\"state-inspection-techniques\">State Inspection Techniques</h4>\n<p>BitTorrent clients maintain complex internal state that changes rapidly during operation. Effective debugging requires the ability to snapshot and analyze this state at key points.</p>\n<p><strong>State Inspection Methods:</strong></p>\n<ol>\n<li><strong>Component state dumps</strong>: Implement methods to export complete component state in human-readable format</li>\n<li><strong>Periodic state snapshots</strong>: Capture state at regular intervals to identify trends and anomalies</li>\n<li><strong>Event correlation</strong>: Link state changes to specific events across component boundaries  </li>\n<li><strong>Consistency validation</strong>: Implement invariant checking to detect state corruption early</li>\n<li><strong>Interactive debugging interfaces</strong>: Provide runtime access to internal state for investigation</li>\n</ol>\n<h4 id=\"test-environment-setup\">Test Environment Setup</h4>\n<p>Debugging BitTorrent clients requires controlled test environments that can simulate various network conditions, peer behaviors, and failure scenarios.</p>\n<p><strong>Controlled Testing Environment Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Purpose</th>\n<th>Implementation</th>\n<th>Benefits</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mock Tracker</td>\n<td>Simulate tracker responses</td>\n<td>Local HTTP server with configurable responses</td>\n<td>Test tracker error handling, peer list variations</td>\n</tr>\n<tr>\n<td>Mock Peers</td>\n<td>Simulate peer behavior</td>\n<td>TCP servers implementing peer protocol</td>\n<td>Test protocol edge cases, malformed messages</td>\n</tr>\n<tr>\n<td>Network Simulation</td>\n<td>Control network conditions</td>\n<td>Traffic shaping, packet loss injection</td>\n<td>Test timeout handling, connection recovery</td>\n</tr>\n<tr>\n<td>Test Torrents</td>\n<td>Known content validation</td>\n<td>Generated torrents with predictable data</td>\n<td>Verify piece assembly, hash calculation</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td>Concurrent connection handling</td>\n<td>Multiple simultaneous peer connections</td>\n<td>Identify race conditions, resource leaks</td>\n</tr>\n</tbody></table>\n<h4 id=\"performance-profiling\">Performance Profiling</h4>\n<p>BitTorrent clients involve significant CPU usage for cryptographic operations, network I/O, and concurrent coordination. Performance profiling helps identify bottlenecks that might not cause functional failures but impact user experience.</p>\n<p><strong>Profiling Strategy:</strong></p>\n<ol>\n<li><strong>CPU profiling</strong>: Identify hot spots in piece verification, protocol parsing, and coordination logic</li>\n<li><strong>Memory profiling</strong>: Track allocation patterns and identify potential leaks</li>\n<li><strong>Goroutine profiling</strong>: Monitor concurrent operation patterns and identify coordination bottlenecks  </li>\n<li><strong>Network I/O profiling</strong>: Measure throughput and identify network-related performance issues</li>\n<li><strong>Lock contention analysis</strong>: Identify synchronization bottlenecks that limit concurrency</li>\n</ol>\n<h4 id=\"systematic-bug-reproduction\">Systematic Bug Reproduction</h4>\n<p>BitTorrent bugs often involve complex interactions between multiple components, making them difficult to reproduce reliably. Systematic reproduction techniques help isolate the root causes.</p>\n<p><strong>Bug Reproduction Methodology:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Approach</th>\n<th>Tools</th>\n<th>Documentation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Minimal reproduction case</td>\n<td>Reduce to simplest failing scenario</td>\n<td>Small test torrents, single peers</td>\n<td>Record exact steps and environment</td>\n</tr>\n<tr>\n<td>Environment isolation</td>\n<td>Eliminate external variables</td>\n<td>Local network, controlled peers</td>\n<td>Document all dependencies</td>\n</tr>\n<tr>\n<td>Timing manipulation</td>\n<td>Control concurrent execution</td>\n<td>Artificial delays, single-threaded mode</td>\n<td>Identify timing-sensitive bugs</td>\n</tr>\n<tr>\n<td>Input variation</td>\n<td>Systematically vary inputs</td>\n<td>Different torrent files, peer behaviors</td>\n<td>Map failure boundaries</td>\n</tr>\n<tr>\n<td>State injection</td>\n<td>Start from known problematic states</td>\n<td>Save/restore component state</td>\n<td>Test specific scenarios</td>\n</tr>\n</tbody></table>\n<h4 id=\"debug-output-organization\">Debug Output Organization</h4>\n<p>The volume of debug information in a BitTorrent client can be overwhelming without proper organization and filtering strategies.</p>\n<p><strong>Debug Output Management:</strong></p>\n<ol>\n<li><strong>Component-based filtering</strong>: Enable/disable debugging for specific components</li>\n<li><strong>Severity-based filtering</strong>: Control output volume through log level selection</li>\n<li><strong>Context correlation</strong>: Tag all log messages with operation context (torrent ID, peer ID, piece index)</li>\n<li><strong>Timeline reconstruction</strong>: Ensure all debug output includes precise timestamps</li>\n<li><strong>Cross-component tracing</strong>: Use correlation IDs to track operations across component boundaries</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides practical debugging tools and techniques specifically tailored for Go implementation, along with complete infrastructure code for debugging support.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Debugging Aspect</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging Framework</td>\n<td>Standard <code>log</code> package with custom formatting</td>\n<td><code>github.com/sirupsen/logrus</code> or <code>go.uber.org/zap</code></td>\n</tr>\n<tr>\n<td>Network Analysis</td>\n<td><code>tcpdump</code> command-line tool</td>\n<td>Wireshark GUI with BitTorrent protocol dissectors</td>\n</tr>\n<tr>\n<td>Profiling</td>\n<td>Built-in <code>go tool pprof</code> with <code>net/http/pprof</code></td>\n<td>Continuous profiling with <code>github.com/pyroscope-io/pyroscope</code></td>\n</tr>\n<tr>\n<td>Test Environment</td>\n<td>Manual mock servers</td>\n<td><code>github.com/jarcoal/httpmock</code> for HTTP, custom TCP mocks</td>\n</tr>\n<tr>\n<td>State Inspection</td>\n<td>JSON marshal of structs</td>\n<td>Custom debug HTTP endpoints with live state</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    bittorrent-debug/\n      main.go                 ← debug CLI tool\n  internal/\n    debug/\n      logger.go              ← structured logging infrastructure\n      profiler.go            ← performance profiling utilities\n      state_inspector.go     ← runtime state inspection\n      mock_tracker.go        ← test tracker implementation\n      mock_peer.go           ← test peer implementation\n    torrent/\n      parser_debug.go        ← torrent parsing debug utilities\n    tracker/\n      client_debug.go        ← tracker communication debugging\n    peer/\n      connection_debug.go    ← peer protocol debugging\n    piece/\n      manager_debug.go       ← piece management debugging\n  test/\n    fixtures/\n      test_torrents/         ← known test torrent files\n      expected_outputs/      ← expected parsing results</code></pre></div>\n\n<h4 id=\"complete-debugging-infrastructure-code\">Complete Debugging Infrastructure Code</h4>\n<p><strong>Structured Logging System (<code>internal/debug/logger.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LogLevel represents logging severity levels</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEBUG</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INFO</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WARN</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> levelNames </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">LogLevel</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DEBUG: </span><span style=\"color:#9ECBFF\">\"DEBUG\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    INFO:  </span><span style=\"color:#9ECBFF\">\"INFO\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WARN:  </span><span style=\"color:#9ECBFF\">\"WARN\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ERROR: </span><span style=\"color:#9ECBFF\">\"ERROR\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ComponentLogger provides structured logging with component identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ComponentLogger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    level     </span><span style=\"color:#B392F0\">LogLevel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output    </span><span style=\"color:#B392F0\">io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Writer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BitTorrentLogger manages logging across all components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BitTorrentLogger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loggers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex   </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> globalLogger </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BitTorrentLogger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loggers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewComponentLogger creates a logger for a specific component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewComponentLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">component</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalLogger.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> globalLogger.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> logger, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> globalLogger.loggers[component]; exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        component: component,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        level:     INFO, </span><span style=\"color:#6A737D\">// Default level</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        output:    os.Stdout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalLogger.loggers[component] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logger</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetLevel configures the minimum log level for this component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetLevel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> l.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> level</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Debug logs debug-level messages with detailed context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\"> ...interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">logf</span><span style=\"color:#E1E4E8\">(DEBUG, format, args</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Info logs informational messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\"> ...interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">logf</span><span style=\"color:#E1E4E8\">(INFO, format, args</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Warn logs warning messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\"> ...interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">logf</span><span style=\"color:#E1E4E8\">(WARN, format, args</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error logs error messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\"> ...interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">logf</span><span style=\"color:#E1E4E8\">(ERROR, format, args</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">logf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\"> ...interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> level </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> l.level {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        l.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> l.output</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> l.component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get caller information for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, file, line, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">Caller</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> caller </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ok {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(file, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            caller </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, parts[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(parts)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"2006-01-02 15:04:05.000\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    levelName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> levelNames[level]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(format, args</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logLine </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> [</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timestamp, levelName, component, caller, message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Fprint</span><span style=\"color:#E1E4E8\">(output, logLine)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetGlobalLevel sets the log level for all components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SetGlobalLevel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalLogger.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> globalLogger.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> globalLogger.loggers {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.</span><span style=\"color:#B392F0\">SetLevel</span><span style=\"color:#E1E4E8\">(level)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>State Inspector (<code>internal/debug/state_inspector.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StateInspector provides runtime inspection of component state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StateInspector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    components </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">StateProvider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex      </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StateProvider interface allows components to expose their state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StateProvider</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetState</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetStatistics</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SystemStats provides system-level debugging information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SystemStats</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Goroutines    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `json:\"goroutines\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryUsage   </span><span style=\"color:#B392F0\">MemoryStats</span><span style=\"color:#9ECBFF\">   `json:\"memory\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Uptime        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"uptime\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MemoryStats</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Allocated   </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"allocated\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalAlloc  </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"total_alloc\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemMem   </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"system_mem\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NumGC       </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#9ECBFF\"> `json:\"num_gc\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> globalInspector </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">StateInspector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    components: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">StateProvider</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> startTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterComponent adds a component for state inspection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RegisterComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">provider</span><span style=\"color:#B392F0\"> StateProvider</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalInspector.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> globalInspector.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalInspector.components[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> provider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartDebugServer launches HTTP server for state inspection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> StartDebugServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewServeMux</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System state endpoint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/system\"</span><span style=\"color:#E1E4E8\">, handleSystemState)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component state endpoints</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/components\"</span><span style=\"color:#E1E4E8\">, handleComponentList)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/component/\"</span><span style=\"color:#E1E4E8\">, handleComponentState)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Memory and goroutine debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/goroutines\"</span><span style=\"color:#E1E4E8\">, handleGoroutineDebug)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalInspector.server </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Addr:    fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\":</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, port),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Handler: mux,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> globalInspector.server.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> handleSystemState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> memStats </span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MemStats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    runtime.</span><span style=\"color:#B392F0\">ReadMemStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">memStats)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SystemStats</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Goroutines: runtime.</span><span style=\"color:#B392F0\">NumGoroutine</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MemoryUsage: </span><span style=\"color:#B392F0\">MemoryStats</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Allocated:  memStats.Alloc,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            TotalAlloc: memStats.TotalAlloc,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            SystemMem:  memStats.Sys,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            NumGC:      memStats.NumGC,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Uptime:    time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(startTime),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(stats)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> handleComponentList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalInspector.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> globalInspector.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    components </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(globalInspector.components))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> globalInspector.components {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        components </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(components, name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"components\"</span><span style=\"color:#E1E4E8\">: components,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"count\"</span><span style=\"color:#E1E4E8\">:      </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(components),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> handleComponentState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    componentName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.URL.Path[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/component/\"</span><span style=\"color:#E1E4E8\">):]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalInspector.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    provider, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> globalInspector.components[componentName]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    globalInspector.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Component not found\"</span><span style=\"color:#E1E4E8\">, http.StatusNotFound)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"component\"</span><span style=\"color:#E1E4E8\">:  componentName,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"state\"</span><span style=\"color:#E1E4E8\">:      provider.</span><span style=\"color:#B392F0\">GetState</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"statistics\"</span><span style=\"color:#E1E4E8\">: provider.</span><span style=\"color:#B392F0\">GetStatistics</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">:  time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(state)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> handleGoroutineDebug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This would typically use pprof for detailed goroutine analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">NumGoroutine</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"goroutine_count\"</span><span style=\"color:#E1E4E8\">: count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">:       time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"warning\"</span><span style=\"color:#E1E4E8\">:         </span><span style=\"color:#9ECBFF\">\"Use 'go tool pprof http://localhost:port/debug/pprof/goroutine' for detailed analysis\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(response)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-debugging-skeleton\">Core Logic Debugging Skeleton</h4>\n<p><strong>Bencode Parser Debugging (<code>internal/torrent/parser_debug.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DebugDecoder wraps the standard decoder with extensive logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DebugDecoder</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#B392F0\">Decoder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">debug</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ComponentLogger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDebugDecoder creates a decoder with comprehensive debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDebugDecoder</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugDecoder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DebugDecoder</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Decoder: </span><span style=\"color:#B392F0\">NewDecoder</span><span style=\"color:#E1E4E8\">(r),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger:  debug.</span><span style=\"color:#B392F0\">NewComponentLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BencodeParser\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DebugDecode parses with extensive logging of parse state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugDecoder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DebugDecode</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Log initial parser state (offset, buffer size)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call standard Decode() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Log final state and parsed value type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If error occurs, log exact position and surrounding bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For successful parses, validate the parsed structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use d.logger.Debug() for detailed parse steps</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement DebugDecode\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateInfoHash compares calculated hash with expected value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateInfoHash</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">metaInfo</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">expectedHex</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Convert expected hex string to byte array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compare with metaInfo.InfoHash using bytes.Equal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If mismatch, log both hashes in hex format for comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return descriptive error with both hash values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use fmt.Sprintf(\"%x\", hash) for hex formatting</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement ValidateInfoHash\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 - Torrent Parsing:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Verify Bencode parsing with debug output</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/debug/main.go</span><span style=\"color:#9ECBFF\"> parse</span><span style=\"color:#9ECBFF\"> test/fixtures/ubuntu.torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output should include:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - All torrent metadata fields correctly extracted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Info hash matching standard tools: transmission-show ubuntu.torrent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Piece count calculation: total_size/piece_length (rounded up)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - No parsing errors or warnings</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">transmission-show</span><span style=\"color:#9ECBFF\"> test/fixtures/ubuntu.torrent</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"Hash:\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Compare with your parser output</span></span></code></pre></div>\n\n<p><strong>After Milestone 2 - Tracker Communication:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test tracker communication with debug logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/debug/main.go</span><span style=\"color:#9ECBFF\"> tracker</span><span style=\"color:#9ECBFF\"> test/fixtures/ubuntu.torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - HTTP GET request logged with all parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Successful response with peer list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Compact peer format correctly decoded to IP:port pairs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - No URL encoding errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> \"http://tracker-url/announce?info_hash=...\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should return bencoded response with peer list</span></span></code></pre></div>\n\n<p><strong>After Milestone 3 - Peer Protocol:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test peer connections with protocol debugging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/debug/main.go</span><span style=\"color:#9ECBFF\"> peer</span><span style=\"color:#9ECBFF\"> test/fixtures/ubuntu.torrent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - TCP connections established to multiple peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Handshake exchange completed successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Bitfield messages received and parsed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - State machine transitions logged correctly</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check debug server:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/debug/component/PeerManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show connected peers and their states</span></span></code></pre></div>\n\n<p><strong>After Milestone 4 - Complete Download:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Full download with comprehensive debugging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/debug/main.go</span><span style=\"color:#9ECBFF\"> download</span><span style=\"color:#9ECBFF\"> test/fixtures/ubuntu.torrent</span><span style=\"color:#9ECBFF\"> output/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - All pieces downloaded and verified successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - No hash verification failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Multiple concurrent peer connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Final file matches expected checksum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify file integrity:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sha1sum</span><span style=\"color:#9ECBFF\"> output/ubuntu-file.iso</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should match published hash</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips-table\">Debugging Tips Table</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Command</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Connection refused&quot; to peers</td>\n<td>Firewall blocking, wrong port</td>\n<td><code>telnet peer-ip peer-port</code></td>\n<td>Check firewall, verify port from tracker</td>\n</tr>\n<tr>\n<td>Handshake timeout</td>\n<td>Protocol mismatch, wrong info hash</td>\n<td>Wireshark capture of handshake</td>\n<td>Verify 68-byte format, check info hash</td>\n</tr>\n<tr>\n<td>No piece requests sent</td>\n<td>Peer choking, not interested</td>\n<td>Debug peer state machine</td>\n<td>Send interested message, wait for unchoke</td>\n</tr>\n<tr>\n<td>Piece verification fails</td>\n<td>Data corruption, wrong hash</td>\n<td>Compare downloaded vs expected hash</td>\n<td>Re-request piece, check hash calculation</td>\n</tr>\n<tr>\n<td>Download stalls</td>\n<td>All peers choking</td>\n<td>Monitor choke/unchoke messages</td>\n<td>Implement optimistic unchoking</td>\n</tr>\n<tr>\n<td>Memory leak during download</td>\n<td>Goroutines not cleaned up</td>\n<td><code>curl localhost:8080/debug/system</code></td>\n<td>Ensure connection cleanup on errors</td>\n</tr>\n<tr>\n<td>Race condition crashes</td>\n<td>Concurrent access to shared state</td>\n<td>Run with <code>go run -race</code></td>\n<td>Add proper mutex protection</td>\n</tr>\n<tr>\n<td>Tracker &quot;Invalid request&quot;</td>\n<td>Missing/wrong parameters</td>\n<td>Log complete URL before request</td>\n<td>Check parameter encoding, completeness</td>\n</tr>\n</tbody></table>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section builds upon all four milestones (1-4) by outlining advanced BitTorrent features and optimizations that can be added to the core implementation, showing how the current architecture accommodates extensibility.</p>\n</blockquote>\n<p>Building a complete BitTorrent client following the four core milestones creates a solid foundation, but the BitTorrent ecosystem offers many advanced features that can significantly enhance functionality, performance, and user experience. This section explores how our carefully designed architecture can accommodate these extensions without requiring fundamental rewrites.</p>\n<p>Think of our current BitTorrent client as a reliable bicycle that gets you from point A to point B. The future extensions described here are like upgrading to an electric bike with GPS navigation, anti-theft systems, and performance monitoring. The core mechanics remain the same - you still pedal, steer, and brake - but the enhanced features make the journey faster, safer, and more enjoyable. Similarly, our core architecture of torrent parsing, tracker communication, peer protocols, and piece management remains intact while we layer on sophisticated enhancements.</p>\n<p>The extensibility of our design stems from several architectural decisions made throughout the previous sections. The modular component structure with well-defined interfaces, the event bus for loose coupling between components, the shared state management system, and the pluggable error handling framework all contribute to making extensions straightforward to implement without disrupting existing functionality.</p>\n<h3 id=\"advanced-protocol-features\">Advanced Protocol Features</h3>\n<p>The BitTorrent protocol has evolved significantly since its inception, with numerous BitTorrent Enhancement Proposals (BEPs) adding powerful features for peer discovery, security, and convenience. Our current architecture provides excellent hooks for integrating these advanced protocol features.</p>\n<h4 id=\"distributed-hash-table-dht-integration\">Distributed Hash Table (DHT) Integration</h4>\n<p>The most significant limitation of our current tracker-based approach is the single point of failure represented by centralized trackers. <strong>Distributed Hash Table (DHT)</strong> technology, specifically the Kademlia-based Mainline DHT used by BitTorrent, eliminates this dependency by creating a decentralized peer discovery network.</p>\n<p>Think of DHT as transforming our library network from one that relies on a central catalog service to a system where every library maintains connections to a few neighboring libraries and can find any book by asking neighbors, who ask their neighbors, creating a web of knowledge that requires no central authority. Each peer becomes both a user and a provider of the peer discovery service.</p>\n<p>The DHT protocol involves several key components that integrate naturally with our existing architecture:</p>\n<table>\n<thead>\n<tr>\n<th>DHT Component</th>\n<th>Purpose</th>\n<th>Integration Point</th>\n<th>Data Structures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node ID</td>\n<td>160-bit identifier for DHT participation</td>\n<td>New field in <code>PeerInfo</code></td>\n<td><code>NodeID [20]byte</code></td>\n</tr>\n<tr>\n<td>Routing Table</td>\n<td>Maintains k-closest nodes in each bucket</td>\n<td>New <code>DHTClient</code> component</td>\n<td><code>RoutingTable</code> with buckets</td>\n</tr>\n<tr>\n<td>Query Engine</td>\n<td>Implements find_node and get_peers queries</td>\n<td>Extends <code>TrackerClient</code> interface</td>\n<td><code>DHTQuery</code> and <code>DHTResponse</code> types</td>\n</tr>\n<tr>\n<td>Announce Protocol</td>\n<td>Announces presence for info hashes</td>\n<td>Parallel to HTTP announces</td>\n<td><code>DHTAnnounce</code> message type</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: DHT as Tracker Fallback</strong></p>\n<ul>\n<li><strong>Context</strong>: Our current design relies solely on HTTP/UDP trackers which can become unavailable or censored</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Replace tracker system entirely with DHT</li>\n<li>Implement DHT as primary with tracker fallback  </li>\n<li>Implement DHT as tracker fallback with gradual promotion</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement DHT as tracker fallback that can be promoted to primary</li>\n<li><strong>Rationale</strong>: This approach maintains backward compatibility while providing resilience, and allows users to choose their preferred discovery method</li>\n<li><strong>Consequences</strong>: Requires dual peer discovery pipelines but provides maximum flexibility and fault tolerance</li>\n</ul>\n</blockquote>\n<p>The DHT integration extends our existing <code>TrackerClient</code> interface by implementing a <code>DHTClient</code> that conforms to the same announce/response pattern. This allows the <code>PeerManager</code> to treat DHT and HTTP trackers uniformly, trying DHT when HTTP trackers fail or supplementing HTTP results with DHT peers for better swarm connectivity.</p>\n<p>The technical implementation involves UDP message handling for the DHT protocol, maintaining a routing table of nearby nodes, and implementing the iterative query algorithm that contacts progressively closer nodes until finding peers for a specific info hash. The routing table requires periodic maintenance to remove stale nodes and discover new ones, which integrates well with our existing event bus system for coordinating background maintenance tasks.</p>\n<h4 id=\"magnet-link-support\">Magnet Link Support</h4>\n<p><strong>Magnet links</strong> represent a paradigm shift from torrent files to pure metadata URLs that enable instant sharing without distributing actual torrent files. Think of magnet links as GPS coordinates that lead you to a treasure location - instead of carrying a detailed treasure map (torrent file), you have just enough information to find other treasure hunters who can share their maps with you.</p>\n<p>A typical magnet link contains:</p>\n<ul>\n<li><strong>Info hash</strong>: The 20-byte SHA1 identifier for the torrent</li>\n<li><strong>Display name</strong>: Human-readable file or torrent name  </li>\n<li><strong>Tracker URLs</strong>: Optional list of backup trackers</li>\n<li><strong>File size</strong>: Optional hint about total download size</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Magnet Component</th>\n<th>Format</th>\n<th>Purpose</th>\n<th>Integration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Info Hash</td>\n<td><code>xt=urn:btih:[40-char-hex]</code></td>\n<td>Unique torrent identifier</td>\n<td>Directly usable by DHT queries</td>\n</tr>\n<tr>\n<td>Display Name</td>\n<td><code>dn=[url-encoded-name]</code></td>\n<td>User interface display</td>\n<td>Temporary <code>MetaInfo.Info.Name</code></td>\n</tr>\n<tr>\n<td>Trackers</td>\n<td><code>tr=[url-encoded-tracker]</code></td>\n<td>Fallback peer discovery</td>\n<td>Added to <code>MetaInfo.AnnounceList</code></td>\n</tr>\n<tr>\n<td>Exact Length</td>\n<td><code>xl=[byte-count]</code></td>\n<td>Progress tracking hint</td>\n<td>Temporary <code>MetaInfo.Info.Length</code></td>\n</tr>\n</tbody></table>\n<p>The magnet link workflow requires significant extensions to our torrent parsing pipeline. Instead of starting with a complete <code>MetaInfo</code> structure parsed from a torrent file, magnet links provide only partial metadata. Our client must:</p>\n<ol>\n<li><strong>Parse the magnet URL</strong> to extract the info hash and optional metadata</li>\n<li><strong>Create a skeleton MetaInfo</strong> with the known information and placeholder values</li>\n<li><strong>Query DHT and trackers</strong> using the info hash to find peers</li>\n<li><strong>Request metadata from peers</strong> using the Extension Protocol (BEP 9)</li>\n<li><strong>Reconstruct the complete MetaInfo</strong> once metadata is received from peers</li>\n<li><strong>Validate the reconstructed info hash</strong> matches the original magnet link</li>\n<li><strong>Proceed with normal download</strong> using the complete metadata</li>\n</ol>\n<p>This workflow integrates naturally with our existing architecture by extending the <code>ParseFromFile</code> function to also accept magnet URLs, creating a new <code>MetadataFetcher</code> component that requests missing information from peers, and using the event bus to coordinate the transition from partial to complete metadata.</p>\n<h4 id=\"protocol-encryption-and-obfuscation\">Protocol Encryption and Obfuscation</h4>\n<p>Network-level protocol encryption addresses ISP throttling and deep packet inspection by making BitTorrent traffic appear as generic encrypted data rather than recognizable P2P patterns. <strong>Message Stream Encryption (MSE)</strong>, defined in BEP 3, provides this capability through a negotiated encryption layer.</p>\n<p>Think of protocol encryption as having a conversation in a crowded restaurant where network monitors represent eavesdroppers. Without encryption, your BitTorrent conversation is clearly audible to anyone listening. With encryption, your conversation appears as meaningless whispers that reveal neither the topic (file being shared) nor the participants (peer IP addresses in piece requests).</p>\n<p>The encryption negotiation occurs during the connection handshake phase, making it a natural extension to our existing <code>Connection.PerformHandshake()</code> method:</p>\n<table>\n<thead>\n<tr>\n<th>Encryption Phase</th>\n<th>Purpose</th>\n<th>Data Exchanged</th>\n<th>Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Diffie-Hellman</td>\n<td>Establish shared secret</td>\n<td>Public keys (96-768 bytes)</td>\n<td>Before protocol handshake</td>\n</tr>\n<tr>\n<td>Method Selection</td>\n<td>Choose encryption level</td>\n<td>Plaintext/RC4/AES preference</td>\n<td>Extends handshake options</td>\n</tr>\n<tr>\n<td>Verification</td>\n<td>Confirm successful setup</td>\n<td>Encrypted hash verification</td>\n<td>After key establishment</td>\n</tr>\n<tr>\n<td>Stream Mode</td>\n<td>Ongoing message protection</td>\n<td>All subsequent messages</td>\n<td>Wraps <code>MessageFramer</code></td>\n</tr>\n</tbody></table>\n<p>The implementation requires cryptographic libraries for Diffie-Hellman key exchange and stream ciphers, but integrates cleanly by creating an <code>EncryptedConnection</code> wrapper around our existing <code>Connection</code> type. The <code>MessageFramer</code> operates identically but reads/writes through the encryption layer instead of directly to the TCP connection.</p>\n<h4 id=\"multi-tracker-and-tracker-tiers\">Multi-Tracker and Tracker Tiers</h4>\n<p>Modern torrents often specify multiple trackers organized in tiers for redundancy and load balancing. <strong>Multi-tracker support</strong> ensures download success even when some trackers are unavailable and distributes the announce load across multiple servers.</p>\n<p>Think of multi-tracker support as having multiple weather services for planning outdoor activities. Instead of relying on a single meteorologist who might be unavailable or incorrect, you consult several services simultaneously and use the best available information from all sources combined.</p>\n<p>The tracker tier system works hierarchically:</p>\n<table>\n<thead>\n<tr>\n<th>Tier Level</th>\n<th>Behavior</th>\n<th>Failure Handling</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tier 0 (Primary)</td>\n<td>Try all trackers simultaneously</td>\n<td>Move to Tier 1 if all fail</td>\n<td>Any tracker responds successfully</td>\n</tr>\n<tr>\n<td>Tier 1+ (Backup)</td>\n<td>Try after primary tier fails</td>\n<td>Move to next tier if all fail</td>\n<td>Continue with any working tracker</td>\n</tr>\n<tr>\n<td>Cross-Tier</td>\n<td>Periodically retry failed tiers</td>\n<td>Promote working trackers</td>\n<td>Maintain best available service</td>\n</tr>\n</tbody></table>\n<p>This extends our <code>TrackerClient</code> to manage multiple tracker instances, implementing a <code>TrackerPool</code> that coordinates announces across tiers and aggregates peer lists from multiple sources. The event bus facilitates coordination between tracker instances, allowing successful responses from any tracker to update the global peer list while failed trackers are relegated to lower priority.</p>\n<h3 id=\"performance-optimizations\">Performance Optimizations</h3>\n<p>While our core implementation focuses on correctness and protocol compliance, real-world BitTorrent usage demands sophisticated optimizations for bandwidth efficiency, connection management, and intelligent piece selection that goes far beyond basic rarest-first algorithms.</p>\n<h4 id=\"advanced-piece-selection-strategies\">Advanced Piece Selection Strategies</h4>\n<p>The <strong>rarest-first algorithm</strong> implemented in Milestone 4 provides a solid foundation, but production BitTorrent clients employ much more sophisticated piece selection that adapts to network conditions, peer behavior, and download progress phases.</p>\n<p>Think of advanced piece selection as evolving from a simple &quot;buy the least common baseball card first&quot; strategy to a sophisticated trading algorithm that considers card condition, trader reliability, geographic proximity, and market trends. The goal remains completing your collection, but the strategy adapts to complex real-world conditions.</p>\n<p>Advanced selection strategies include multiple complementary algorithms:</p>\n<table>\n<thead>\n<tr>\n<th>Selection Strategy</th>\n<th>Use Case</th>\n<th>Algorithm</th>\n<th>Benefits</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random First Piece</td>\n<td>Cold start with no pieces</td>\n<td>Random selection from available</td>\n<td>Immediate participation in swarm</td>\n</tr>\n<tr>\n<td>Strict Priority</td>\n<td>Important files first</td>\n<td>User-defined file ordering</td>\n<td>Critical content downloaded first</td>\n</tr>\n<tr>\n<td>Availability-Based</td>\n<td>Rare piece prioritization</td>\n<td>Enhanced rarest-first with scoring</td>\n<td>Better swarm health maintenance</td>\n</tr>\n<tr>\n<td>Locality-Aware</td>\n<td>Network topology optimization</td>\n<td>Prefer peers with low latency</td>\n<td>Reduced bandwidth costs</td>\n</tr>\n<tr>\n<td>Completion Clustering</td>\n<td>Sequential reading support</td>\n<td>Group adjacent pieces</td>\n<td>Enables streaming playback</td>\n</tr>\n</tbody></table>\n<p>The implementation extends our existing <code>PieceSelector</code> with a strategy pattern that dynamically chooses algorithms based on download state:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Download Phase → Strategy Selection:\n- Bootstrap (0-5% complete): Random first piece to join swarm quickly  \n- Ramp-up (5-90% complete): Availability-based rarest-first for efficiency\n- Endgame (90-100% complete): Multi-source requesting for final pieces\n- Streaming mode: Completion clustering for sequential piece availability</code></pre></div>\n\n<p><strong>Locality-aware selection</strong> optimizes for network topology by preferring peers that are geographically or topologically close. This reduces internet transit costs and improves download speeds by utilizing high-bandwidth local connections. The implementation maintains peer latency statistics and factors proximity into piece assignment decisions.</p>\n<p><strong>Completion clustering</strong> groups piece requests to enable streaming playback of media files. Instead of downloading pieces purely by rarity, the algorithm identifies the current playback position and ensures a buffer of sequential pieces ahead of the playback cursor. This enables video streaming while the file is still downloading.</p>\n<h4 id=\"bandwidth-management-and-traffic-shaping\">Bandwidth Management and Traffic Shaping</h4>\n<p>Effective bandwidth management ensures BitTorrent activity doesn&#39;t overwhelm network connections while maximizing throughput within specified limits. <strong>Adaptive bandwidth allocation</strong> monitors network conditions and adjusts transfer rates dynamically.</p>\n<p>Think of bandwidth management as managing water flow through a complex irrigation system. You have a fixed amount of water (bandwidth) that must be distributed among many fields (connections) while ensuring no field is flooded (connection overwhelmed) or drought-stricken (connection starved), and the distribution must adapt to changing weather conditions (network congestion).</p>\n<p>The bandwidth management system operates at multiple levels:</p>\n<table>\n<thead>\n<tr>\n<th>Management Level</th>\n<th>Scope</th>\n<th>Controls</th>\n<th>Adaptation Triggers</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Global Limits</td>\n<td>Entire client</td>\n<td>Total upload/download caps</td>\n<td>User configuration</td>\n</tr>\n<tr>\n<td>Per-Torrent</td>\n<td>Individual torrents</td>\n<td>Torrent priority weighting</td>\n<td>Progress-based adjustment</td>\n</tr>\n<tr>\n<td>Per-Peer</td>\n<td>Individual connections</td>\n<td>Fair share allocation</td>\n<td>Peer performance metrics</td>\n</tr>\n<tr>\n<td>Congestion Control</td>\n<td>Network conditions</td>\n<td>Dynamic rate adjustment</td>\n<td>RTT and loss detection</td>\n</tr>\n</tbody></table>\n<p><strong>Token bucket algorithms</strong> provide smooth rate limiting by allowing brief bursts above the average rate while maintaining long-term compliance with bandwidth limits. Each connection receives tokens at a controlled rate and consumes tokens for data transfer, preventing sustained overconsumption while accommodating natural traffic patterns.</p>\n<p><strong>Congestion detection</strong> monitors round-trip times and packet loss indicators to detect network congestion early and reduce transmission rates before connections timeout. This maintains higher overall throughput by avoiding the dramatic rate reductions that occur when TCP connections detect congestion through timeouts.</p>\n<p>The implementation creates a <code>BandwidthManager</code> component that integrates with our existing <code>Connection</code> objects by intercepting read/write operations and applying rate limiting. The manager maintains token buckets per connection and globally, coordinating through the event bus to redistribute unused bandwidth allocation from idle connections to active transfers.</p>\n<h4 id=\"connection-optimization-and-pooling\">Connection Optimization and Pooling</h4>\n<p>Efficient connection management maximizes throughput while minimizing resource consumption through intelligent peer selection, connection reuse, and protocol optimizations.</p>\n<p><strong>Connection pooling</strong> maintains pools of established connections that can be quickly reassigned between torrents sharing the same peers. Think of this as maintaining relationships with reliable trading partners across multiple card collections - instead of introducing yourself repeatedly for each new collection, you leverage existing trust relationships for faster transactions.</p>\n<p>The connection optimization strategies include:</p>\n<table>\n<thead>\n<tr>\n<th>Optimization</th>\n<th>Mechanism</th>\n<th>Benefits</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Keep-Alive</td>\n<td>Maintain idle connections</td>\n<td>Reduced handshake overhead</td>\n<td>Extended connection timeouts</td>\n</tr>\n<tr>\n<td>Multiplexing</td>\n<td>Multiple torrents per connection</td>\n<td>Better resource utilization</td>\n<td>Protocol extension negotiation</td>\n</tr>\n<tr>\n<td>Fast Extensions</td>\n<td>Optimized message flow</td>\n<td>Reduced round-trip delays</td>\n<td>Fast peer and allowed fast messages</td>\n</tr>\n<tr>\n<td>Pipelining Tuning</td>\n<td>Dynamic pipeline depth</td>\n<td>Optimal throughput/latency</td>\n<td>RTT-based pipeline adjustment</td>\n</tr>\n</tbody></table>\n<p><strong>Fast Extension Protocol</strong> (BEP 6) reduces the time from connection establishment to active data transfer by allowing peers to immediately request pieces without waiting for complete bitfield exchange. This is particularly beneficial for peers that reconnect frequently or have high-latency connections.</p>\n<p><strong>Dynamic pipeline tuning</strong> adjusts the number of outstanding block requests based on measured round-trip times and bandwidth-delay product. High-latency connections benefit from deeper pipelines that keep the network path saturated, while low-latency connections require shallower pipelines to maintain responsiveness.</p>\n<p>The optimization integrates with our existing <code>Connection</code> and <code>PeerManager</code> by adding connection lifecycle management, peer performance tracking, and protocol capability negotiation. The event bus coordinates connection reallocation between torrents and communicates performance metrics for optimization decisions.</p>\n<h3 id=\"user-interface-integration\">User Interface Integration</h3>\n<p>Our carefully designed core architecture provides excellent separation between the BitTorrent protocol engine and user interface concerns, enabling integration with diverse interface paradigms from command-line tools to sophisticated graphical applications.</p>\n<h4 id=\"api-design-for-gui-integration\">API Design for GUI Integration</h4>\n<p>The key to successful GUI integration lies in designing clean APIs that expose BitTorrent functionality through well-defined interfaces while hiding protocol complexity from interface developers.</p>\n<p>Think of the API design as creating a car dashboard for BitTorrent - the dashboard shows speed, fuel level, and engine temperature without requiring the driver to understand internal combustion, fuel injection timing, or cooling system pressure. Similarly, GUI developers need download progress, peer counts, and transfer rates without needing to understand Bencode parsing, piece verification, or message framing protocols.</p>\n<p>The API architecture follows a layered approach:</p>\n<table>\n<thead>\n<tr>\n<th>API Layer</th>\n<th>Purpose</th>\n<th>Interface Style</th>\n<th>Data Format</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Core Engine</td>\n<td>Protocol implementation</td>\n<td>Internal Go interfaces</td>\n<td>Native Go types</td>\n</tr>\n<tr>\n<td>Service Layer</td>\n<td>Business logic abstraction</td>\n<td>Method calls with callbacks</td>\n<td>Structured events</td>\n</tr>\n<tr>\n<td>Transport Layer</td>\n<td>External communication</td>\n<td>REST/gRPC/WebSockets</td>\n<td>JSON/Protocol Buffers</td>\n</tr>\n<tr>\n<td>Client SDKs</td>\n<td>Language-specific bindings</td>\n<td>Native language idioms</td>\n<td>Language-native types</td>\n</tr>\n</tbody></table>\n<p><strong>Event-driven architecture</strong> provides the foundation for responsive user interfaces by exposing BitTorrent state changes through structured events rather than requiring interfaces to poll for status updates. Our existing event bus naturally extends to external consumers:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Internal Event → API Event Translation:\n- EventPieceCompleted → {type: &quot;progress&quot;, torrent: &quot;abc123&quot;, percent: 45.2}\n- EventPeerConnected → {type: &quot;peer_update&quot;, torrent: &quot;abc123&quot;, peers: 12}  \n- EventDownloadComplete → {type: &quot;complete&quot;, torrent: &quot;abc123&quot;, path: &quot;/downloads/file.mp4&quot;}</code></pre></div>\n\n<p><strong>REST API design</strong> provides HTTP-based access for web interfaces and cross-platform compatibility. The API follows RESTful principles while accommodating BitTorrent-specific operations:</p>\n<table>\n<thead>\n<tr>\n<th>Endpoint</th>\n<th>Method</th>\n<th>Purpose</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>/torrents</code></td>\n<td>GET</td>\n<td>List all active torrents</td>\n<td>Torrent summary array</td>\n</tr>\n<tr>\n<td><code>/torrents</code></td>\n<td>POST</td>\n<td>Add new torrent</td>\n<td>Created torrent details</td>\n</tr>\n<tr>\n<td><code>/torrents/{id}</code></td>\n<td>GET</td>\n<td>Detailed torrent status</td>\n<td>Complete torrent state</td>\n</tr>\n<tr>\n<td><code>/torrents/{id}/pause</code></td>\n<td>POST</td>\n<td>Pause/resume torrent</td>\n<td>Operation result</td>\n</tr>\n<tr>\n<td><code>/torrents/{id}/files</code></td>\n<td>GET</td>\n<td>File list and priorities</td>\n<td>File details array</td>\n</tr>\n<tr>\n<td><code>/events</code></td>\n<td>WebSocket</td>\n<td>Real-time updates</td>\n<td>Event stream</td>\n</tr>\n</tbody></table>\n<h4 id=\"real-time-status-updates\">Real-time Status Updates</h4>\n<p>Modern BitTorrent interfaces require real-time updates for download progress, peer connectivity, and transfer statistics. <strong>WebSocket-based event streaming</strong> provides efficient real-time communication without the overhead of continuous HTTP polling.</p>\n<p>Think of real-time updates as the difference between checking your mailbox every few minutes versus having a notification system that immediately alerts you when mail arrives. WebSocket connections maintain persistent communication channels that deliver updates instantly as they occur within the BitTorrent engine.</p>\n<p>The real-time update system streams multiple categories of information:</p>\n<table>\n<thead>\n<tr>\n<th>Update Category</th>\n<th>Frequency</th>\n<th>Data Elements</th>\n<th>Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Progress Updates</td>\n<td>Per piece completion</td>\n<td>Percentage, ETA, speed</td>\n<td>Progress bars, statistics</td>\n</tr>\n<tr>\n<td>Peer Information</td>\n<td>Connection changes</td>\n<td>Count, locations, quality</td>\n<td>Network visualization</td>\n</tr>\n<tr>\n<td>Transfer Metrics</td>\n<td>Every few seconds</td>\n<td>Rates, totals, ratios</td>\n<td>Performance monitoring</td>\n</tr>\n<tr>\n<td>System Events</td>\n<td>As they occur</td>\n<td>Errors, completions, alerts</td>\n<td>User notifications</td>\n</tr>\n</tbody></table>\n<p><strong>Update aggregation and throttling</strong> prevents overwhelming clients with excessive messages during high-activity periods. The system batches related updates and applies rate limiting to maintain responsive interfaces without message flooding:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Aggregation Strategy:\n- Progress updates: Maximum once per second per torrent\n- Peer updates: Batch connection changes every 5 seconds  \n- Transfer metrics: Smooth using exponential moving averages\n- Critical events: Send immediately without throttling</code></pre></div>\n\n<p>The implementation extends our event bus with external subscription capabilities, WebSocket connection management, and update aggregation logic. The system maintains separate update channels for different client types, allowing mobile apps to receive minimal updates while desktop applications get comprehensive information.</p>\n<h4 id=\"web-based-dashboard-implementation\">Web-based Dashboard Implementation</h4>\n<p>A <strong>web-based dashboard</strong> provides universal access to BitTorrent functionality through standard web browsers, eliminating the need for platform-specific client installation while providing rich interactive capabilities.</p>\n<p>Think of the web dashboard as transforming BitTorrent from a desktop application into a web service similar to how email evolved from desktop clients to Gmail - the core functionality remains the same, but web access provides universal availability, easy updates, and consistent cross-platform experience.</p>\n<p>The web dashboard architecture separates concerns cleanly:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Technology</th>\n<th>Responsibility</th>\n<th>Integration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Backend API</td>\n<td>Go HTTP server</td>\n<td>Protocol engine interface</td>\n<td>Wraps our core components</td>\n</tr>\n<tr>\n<td>Frontend SPA</td>\n<td>React/Vue/Angular</td>\n<td>User interface logic</td>\n<td>Consumes REST API</td>\n</tr>\n<tr>\n<td>Real-time Updates</td>\n<td>WebSockets</td>\n<td>Live data streaming</td>\n<td>Event bus integration</td>\n</tr>\n<tr>\n<td>Authentication</td>\n<td>JWT/OAuth</td>\n<td>Access control</td>\n<td>Optional security layer</td>\n</tr>\n</tbody></table>\n<p><strong>Single Page Application (SPA) design</strong> provides responsive user experience through client-side rendering and AJAX communication. The SPA maintains application state locally and synchronizes with the BitTorrent engine through API calls and WebSocket events.</p>\n<p><strong>Responsive design principles</strong> ensure the dashboard works effectively across device sizes from smartphones to desktop monitors. The interface adapts layout, information density, and interaction patterns based on screen size and input capabilities.</p>\n<p>Key dashboard features include:</p>\n<ul>\n<li><strong>Torrent management</strong>: Add, remove, pause, and prioritize torrents</li>\n<li><strong>Progress monitoring</strong>: Real-time download progress with speed charts</li>\n<li><strong>Peer visualization</strong>: Geographic and network maps of peer connections  </li>\n<li><strong>File management</strong>: Individual file priorities and selective downloading</li>\n<li><strong>Statistics dashboard</strong>: Historical transfer rates and ratio tracking</li>\n<li><strong>Settings configuration</strong>: Bandwidth limits, port configuration, and preferences</li>\n</ul>\n<p>The web dashboard integrates with our core architecture by running the BitTorrent engine as a background service with HTTP API endpoints. The separation allows the protocol engine to operate independently while providing multiple interface options - web dashboard, desktop GUI, mobile app, or command-line interface - all accessing the same underlying functionality.</p>\n<p><strong>Security considerations</strong> for web interfaces include CSRF protection, input validation, and optional authentication systems. Since BitTorrent clients often run on local networks, the security model balances ease of use with protection against unauthorized access.</p>\n<p>The implementation creates a new <code>cmd/web-server/</code> directory containing the HTTP server, API handlers, and web assets. The server embeds the frontend assets using Go&#39;s embed functionality for single-binary deployment while supporting development mode with external asset serving.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The extensive use of interfaces and event-driven architecture in our core implementation makes these extensions possible without fundamental architectural changes. Each extension builds upon existing abstractions rather than requiring rewrites, demonstrating the value of thoughtful initial design.</p>\n</blockquote>\n<p>These future extensions transform our functional BitTorrent client into a production-ready system capable of competing with commercial clients. The extensions maintain the educational value of the core implementation while showcasing how proper architecture enables sophisticated functionality through incremental enhancement rather than replacement.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing the advanced features described above, focusing on architectural integration points and technology choices that build upon our existing Go-based BitTorrent client.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DHT Implementation</td>\n<td>Basic Kademlia with UDP sockets</td>\n<td>Full BEP 5 with routing table optimization</td>\n</tr>\n<tr>\n<td>Magnet Link Parsing</td>\n<td>Regular expressions + URL parsing</td>\n<td>Dedicated parser with validation</td>\n</tr>\n<tr>\n<td>Protocol Encryption</td>\n<td>RC4 stream cipher</td>\n<td>AES with multiple cipher support</td>\n</tr>\n<tr>\n<td>Web API</td>\n<td>Standard library HTTP + JSON</td>\n<td>Gin/Echo framework + Protocol Buffers</td>\n</tr>\n<tr>\n<td>Real-time Updates</td>\n<td>Server-Sent Events</td>\n<td>WebSocket with message queues</td>\n</tr>\n<tr>\n<td>Frontend Framework</td>\n<td>Vanilla JavaScript + HTMX</td>\n<td>React/Vue with TypeScript</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<p>The extensions integrate into our existing project structure while maintaining clear separation of concerns:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    torrent-client/main.go    ← original CLI client\n    web-server/main.go        ← new web dashboard server\n  internal/\n    torrent/                  ← core components (unchanged)\n    tracker/                  ← existing tracker client\n    peer/                     ← existing peer protocol\n    piece/                    ← existing piece management\n    dht/                      ← new DHT implementation\n      client.go\n      routing_table.go\n      protocol.go\n    magnet/                   ← new magnet link support\n      parser.go\n      metadata_fetcher.go\n    encryption/               ← new protocol encryption\n      mse.go\n      cipher.go\n    api/                      ← new web API\n      handlers.go\n      websocket.go\n      models.go\n    dashboard/                ← new web frontend\n      static/\n      templates/\n  web/                        ← frontend assets\n    src/\n    dist/\n  pkg/\n    extensions/               ← reusable extension interfaces</code></pre></div>\n\n<h4 id=\"dht-implementation-starter-code\">DHT Implementation Starter Code</h4>\n<p>The DHT implementation extends our existing tracker interface pattern:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package dht implements Distributed Hash Table peer discovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> dht</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/tracker</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Client implements tracker.Client interface for DHT-based peer discovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Client</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">UDPConn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    routingTable </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RoutingTable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queries    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PendingQuery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eventBus   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx        </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel     </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RoutingTable maintains k-closest nodes for DHT queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RoutingTable</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID  [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buckets []</span><span style=\"color:#B392F0\">Bucket</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex   </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bucket contains up to K nodes with similar node IDs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Bucket</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodes     []</span><span style=\"color:#B392F0\">NodeInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastSeen  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NodeInfo represents a DHT node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID       [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Addr     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">UDPAddr</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastSeen </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDHTClient creates a DHT client that implements tracker.Client interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDHTClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize UDP socket on specified port</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Generate random 160-bit node ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create routing table with 160 buckets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Start maintenance goroutines for routing table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Bootstrap from well-known DHT nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Announce implements tracker.Client.Announce for DHT peer discovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Announce</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> tracker</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AnnounceRequest</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tracker</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AnnounceResponse</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Perform get_peers query for req.InfoHash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: If no peers found, perform announce_peer to store our info</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Aggregate peers from all responding nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return tracker.AnnounceResponse with discovered peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use iterative deepening to find closest nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"magnet-link-support-implementation\">Magnet Link Support Implementation</h4>\n<p>Magnet link support extends our torrent parsing pipeline:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package magnet handles magnet link parsing and metadata fetching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> magnet</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/url</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/torrent</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/peer</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MagnetLink represents parsed magnet URI components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MagnetLink</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash    [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DisplayName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Trackers    []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExactLength </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetadataFetcher retrieves missing torrent metadata from peers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetadataFetcher</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    infoHash     [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peerManager  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">peer</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eventBus     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx          </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseMagnetLink extracts components from magnet URI</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseMagnetLink</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">magnetURI</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MagnetLink</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Parse URL and validate magnet: scheme</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Extract xt parameter and decode info hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Extract dn parameter for display name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Extract tr parameters for tracker URLs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Extract xl parameter for exact length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use net/url.ParseQuery for parameter extraction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FetchMetadata retrieves complete torrent metadata from peers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">f </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetadataFetcher</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FetchMetadata</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">torrent</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetaInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Connect to peers using DHT/tracker discovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send metadata extension handshake (BEP 9)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Request metadata pieces from multiple peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify metadata integrity against info hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Construct complete MetaInfo structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use Extension Protocol with ut_metadata message type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"web-api-infrastructure\">Web API Infrastructure</h4>\n<p>The web API provides HTTP and WebSocket endpoints for external client integration:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package api provides HTTP API for external client integration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> api</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/gorilla/websocket</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/coordination</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Server provides HTTP API and WebSocket endpoints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Server</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eventBus  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EventBus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    upgrader  </span><span style=\"color:#B392F0\">websocket</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Upgrader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wsClients </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">websocket</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Conn</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TorrentStatus represents API torrent information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TorrentStatus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InfoHash     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"info_hash\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Size         </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">   `json:\"size\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Downloaded   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">   `json:\"downloaded\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Uploaded     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">   `json:\"uploaded\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Progress     </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\"> `json:\"progress\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DownloadRate </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\"> `json:\"download_rate\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UploadRate   </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\"> `json:\"upload_rate\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Peers        </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">     `json:\"peers\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewAPIServer creates HTTP server with REST and WebSocket endpoints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAPIServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">client</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize HTTP server with CORS middleware</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register REST endpoint handlers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Configure WebSocket upgrader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Subscribe to client event bus</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Start WebSocket broadcast goroutine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleTorrents provides GET /torrents endpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleTorrents</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Collect status from all active torrents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Transform internal state to API format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return JSON array of torrent status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use json.NewEncoder for response formatting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleWebSocket upgrades HTTP to WebSocket for real-time updates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleWebSocket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Upgrade HTTP connection to WebSocket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register client for event broadcasts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle client disconnection cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send periodic keep-alive pings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use gorilla/websocket for protocol handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>DHT Integration Checkpoint:</strong>\nAfter implementing basic DHT support, verify functionality:</p>\n<ul>\n<li>Start client with DHT enabled: <code>./torrent-client --enable-dht example.torrent</code></li>\n<li>Check logs for DHT bootstrap messages and routing table population</li>\n<li>Verify peer discovery works without HTTP trackers</li>\n<li>Expected: &quot;DHT discovered 15 peers for torrent&quot; log messages</li>\n</ul>\n<p><strong>Magnet Link Checkpoint:</strong><br>After implementing magnet link parsing and metadata fetching:</p>\n<ul>\n<li>Add magnet link: <code>./torrent-client &quot;magnet:?xt=urn:btih:abcd1234...&quot;</code></li>\n<li>Verify metadata fetching from peers: watch for &quot;Fetching metadata from peer&quot; logs</li>\n<li>Check that download proceeds normally after metadata retrieval</li>\n<li>Expected: Complete download from magnet link without original torrent file</li>\n</ul>\n<p><strong>Web API Checkpoint:</strong>\nAfter implementing HTTP API and WebSocket updates:</p>\n<ul>\n<li>Start web server: <code>./web-server --port 8080</code></li>\n<li>Test REST endpoints: <code>curl http://localhost:8080/torrents</code></li>\n<li>Connect WebSocket client and verify real-time updates</li>\n<li>Expected: JSON responses and live progress updates via WebSocket</li>\n</ul>\n<h4 id=\"performance-testing-and-optimization\">Performance Testing and Optimization</h4>\n<p>Advanced features require performance validation to ensure they enhance rather than degrade the client experience:</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Performance Metric</th>\n<th>Testing Method</th>\n<th>Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DHT Integration</td>\n<td>Query response time</td>\n<td>Measure average get_peers latency</td>\n<td>&lt; 2 seconds</td>\n</tr>\n<tr>\n<td>Magnet Links</td>\n<td>Metadata fetch time</td>\n<td>Time from magnet to first piece</td>\n<td>&lt; 30 seconds</td>\n</tr>\n<tr>\n<td>API Throughput</td>\n<td>Requests per second</td>\n<td>HTTP load testing with concurrent clients</td>\n<td>&gt; 100 RPS</td>\n</tr>\n<tr>\n<td>WebSocket Updates</td>\n<td>Message latency</td>\n<td>Measure event to client delivery time</td>\n<td>&lt; 100ms</td>\n</tr>\n</tbody></table>\n<p>Use Go&#39;s built-in benchmarking for performance testing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> BenchmarkDHTQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">B</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> setupTestDHTClient</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    infoHash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">14</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">17</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">18</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">19</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.</span><span style=\"color:#B392F0\">ResetTimer</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> b.N; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peers, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">FindPeers</span><span style=\"color:#E1E4E8\">(infoHash)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            b.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(peers) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            b.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"No peers found\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The future extensions described in this section demonstrate how thoughtful architectural design enables sophisticated functionality through incremental enhancement. Each extension builds upon existing interfaces and patterns, proving that well-designed systems can evolve gracefully to meet new requirements without fundamental rewrites.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This glossary supports all milestones (1-4) by providing comprehensive definitions of BitTorrent-specific terms, protocols, and technical concepts used throughout the implementation.</p>\n</blockquote>\n<p>This glossary serves as a comprehensive reference for all BitTorrent-specific terminology, protocol concepts, and technical terms used throughout the design document. Understanding these terms is essential for implementing a correct BitTorrent client, as the protocol has many domain-specific concepts that differ from general networking or file transfer protocols.</p>\n<p>The terms are organized alphabetically within conceptual categories to help developers quickly locate definitions while working on specific components. Each definition includes not only the meaning but also the context in which the term is used and its relationship to other BitTorrent concepts.</p>\n<h3 id=\"bittorrent-protocol-core-concepts\">BitTorrent Protocol Core Concepts</h3>\n<p><strong>announce</strong>: An HTTP request sent by a BitTorrent client to a tracker server to report the client&#39;s current status (uploaded, downloaded, left) and request a list of other peers sharing the same torrent. The announce request includes the info hash, peer ID, port number, and progress statistics. Announces are sent periodically at intervals specified by the tracker, typically every 30 minutes, and also when the client starts downloading, completes downloading, or stops.</p>\n<p><strong>bencode</strong>: A binary encoding format used exclusively by BitTorrent for serializing structured data in torrent files and some protocol messages. Bencode supports four data types: byte strings (length:content), integers (i<number>e), lists (l<items>e), and dictionaries (d<key><value>e). Unlike JSON, bencode preserves exact byte representation, which is crucial for calculating consistent info hashes across different implementations.</p>\n<p><strong>bitfield</strong>: A compact bitmap data structure where each bit represents whether a peer has a specific piece of the torrent. The bitfield is typically sent immediately after the handshake to inform the remote peer about piece availability. Bitfields allow efficient communication of piece availability using minimal bandwidth - for a torrent with 1000 pieces, the bitfield requires only 125 bytes compared to 4000 bytes if piece numbers were sent individually.</p>\n<p><strong>block</strong>: A 16KB (16,384 byte) subdivision of pieces used as the unit of network transfer between peers. While pieces are the unit of verification (each has a SHA-1 hash), blocks are the unit of network requests to optimize pipeline efficiency and reduce memory usage. A typical piece of 256KB contains 16 blocks. Peers request specific blocks within pieces rather than entire pieces to enable concurrent downloads from multiple peers.</p>\n<p><strong>choking</strong>: A flow control mechanism where a peer refuses to upload data to another peer, even if that peer is interested in downloading. Choking prevents peers from being overwhelmed by too many simultaneous upload requests and implements BitTorrent&#39;s reciprocal sharing incentive - peers typically unchoke others who are uploading to them. The choking state is communicated via choke/unchoke messages in the peer wire protocol.</p>\n<p><strong>compact peer format</strong>: A space-efficient binary encoding for peer information in tracker responses, where each peer is represented as 6 bytes: 4 bytes for IPv4 address and 2 bytes for port number in network byte order. This format reduces tracker response size compared to the dictionary format and is now the standard format used by most trackers and clients.</p>\n<p><strong>endgame mode</strong>: An aggressive downloading strategy activated when only a few pieces remain to complete a torrent. In endgame mode, the client requests all remaining blocks from all available peers simultaneously to avoid stalling on slow peers. Once a block is received from any peer, requests to other peers for that block are canceled. This prevents the common scenario where the last few percent of a download becomes very slow.</p>\n<p><strong>handshake</strong>: The initial 68-byte message exchanged between BitTorrent peers to establish a connection. The handshake contains the protocol string (&quot;BitTorrent protocol&quot;), info hash of the torrent, and the sender&#39;s peer ID. Both peers must send handshakes, and each must verify that the remote peer&#39;s info hash matches the expected torrent. The handshake serves as authentication that both peers are participating in the same torrent swarm.</p>\n<p><strong>info hash</strong>: A 20-byte SHA-1 cryptographic hash of the bencoded info dictionary from a torrent file. The info hash serves as the unique identifier for a torrent across the BitTorrent network - all peers sharing the same torrent will have identical info hashes. The info hash is used in tracker announces, peer handshakes, and DHT operations. Calculating the info hash correctly requires hashing the exact bencoded bytes of the info dictionary, not a re-encoded version.</p>\n<p><strong>message framing</strong>: The protocol mechanism for parsing variable-length messages from a TCP byte stream. BitTorrent messages use a length-prefix framing format: 4 bytes for message length in network byte order, followed by 1 byte for message type, followed by the message payload. Proper message framing prevents protocol desynchronization and enables reliable parsing of message boundaries in the TCP stream.</p>\n<p><strong>peer</strong>: An individual computer or BitTorrent client participating in the sharing of a specific torrent. Peers can be in various states: seeders (have complete file), leechers (downloading), or partial seeders (have some pieces). Each peer is identified by a unique peer ID and can simultaneously connect to multiple other peers to exchange pieces. The collection of all peers sharing a torrent is called a swarm.</p>\n<p><strong>piece</strong>: A fixed-size chunk of the torrent&#39;s data that serves as the unit of verification and availability tracking. Each piece has a SHA-1 hash specified in the torrent metadata, allowing peers to verify data integrity after downloading. Piece sizes are typically powers of 2 (64KB, 128KB, 256KB, 512KB) and are chosen to balance verification granularity with metadata overhead. Pieces are subdivided into 16KB blocks for network transfer.</p>\n<p><strong>pipeline</strong>: The practice of maintaining multiple outstanding block requests to a peer simultaneously, rather than waiting for each request to complete before sending the next. Pipelining dramatically improves download throughput by keeping the network connection saturated and reducing the impact of network round-trip time. Most clients maintain 5-10 outstanding requests per peer, though the optimal depth depends on network conditions.</p>\n<p><strong>rarest-first</strong>: A piece selection algorithm that prioritizes downloading pieces that are held by the fewest number of connected peers. This strategy increases the overall availability of pieces in the swarm by ensuring that rare pieces are duplicated quickly, reducing the risk of pieces becoming unavailable if peers leave. Rarest-first is crucial for swarm health but is typically disabled for the first few pieces to enable quick startup.</p>\n<p><strong>seeding</strong>: The process of uploading complete pieces to other peers after finishing the download. Seeders are essential for torrent health as they ensure availability of all pieces. The seeding process involves responding to piece requests from other peers by reading data from the completed file and sending it via piece messages. Many BitTorrent clients implement seeding ratios to encourage users to seed for extended periods.</p>\n<p><strong>swarm</strong>: The complete collection of peers participating in the sharing of a specific torrent, identified by the same info hash. A healthy swarm contains multiple seeders and maintains good piece availability across all participants. Swarm dynamics involve peers joining (downloading), completing (becoming seeders), and leaving, with the tracker coordinating peer discovery within the swarm.</p>\n<p><strong>tracker</strong>: A server that maintains lists of peers participating in torrents and coordinates peer discovery. Trackers do not store or transfer file data - they only facilitate peer connections by providing lists of active peers for each torrent. Clients communicate with trackers via HTTP announce requests at regular intervals to report status and discover new peers. Modern BitTorrent also supports trackerless operation using Distributed Hash Tables (DHT).</p>\n<p><strong>torrent file</strong>: A metadata file with a .torrent extension containing all information needed to download and verify a file or set of files. Torrent files are bencoded dictionaries containing the tracker URL, file information (names, sizes, directory structure), piece size, and SHA-1 hashes of all pieces. The torrent file serves as the authoritative specification for what constitutes the complete, correct version of the shared content.</p>\n<h3 id=\"protocol-message-types\">Protocol Message Types</h3>\n<p><strong>choke message</strong>: A peer wire protocol message (ID 0) sent to inform a remote peer that no data will be uploaded to them, regardless of requests. Choking is BitTorrent&#39;s primary flow control and incentive mechanism. A peer typically chokes others when bandwidth is limited or when implementing tit-for-tat reciprocal sharing strategies. The choke state persists until an explicit unchoke message is sent.</p>\n<p><strong>have message</strong>: A peer wire protocol message (ID 4) announcing that the sender has successfully downloaded and verified a specific piece. Have messages enable peers to maintain accurate bitfields of what pieces their connected peers possess. These messages are broadcast to all connected peers immediately after successful piece verification, allowing the swarm to quickly learn about new piece availability.</p>\n<p><strong>interested message</strong>: A peer wire protocol message (ID 2) indicating that the sender wants to download data from the recipient. A peer becomes interested when it needs pieces that the remote peer has available. The interested state is a prerequisite for receiving data - choked but interested peers will be unchoked when bandwidth becomes available, while uninterested peers remain choked regardless of their upload contribution.</p>\n<p><strong>piece message</strong>: A peer wire protocol message (ID 7) containing actual file data in response to a request. Piece messages include the piece index, byte offset within the piece, and the block data. These are typically the largest messages in the protocol, carrying 16KB blocks of content. Piece messages are only sent to unchoked peers and represent the core data transfer mechanism of BitTorrent.</p>\n<p><strong>request message</strong>: A peer wire protocol message (ID 6) asking for a specific 16KB block within a piece. Requests specify the piece index, byte offset within the piece, and block length (usually 16KB). Peers can pipeline multiple requests for efficiency, but must not request from choked peers. Request messages drive the actual data transfer process in BitTorrent.</p>\n<p><strong>unchoke message</strong>: A peer wire protocol message (ID 1) indicating that the sender is willing to upload data to the recipient in response to requests. Unchoking typically occurs as part of reciprocal sharing algorithms - peers unchoke others who are uploading to them. The number of simultaneous unchokes is usually limited (typically 4-8) to prevent upload bandwidth from being spread too thin across many peers.</p>\n<h3 id=\"data-structures-and-technical-terms\">Data Structures and Technical Terms</h3>\n<p><strong>AnnounceRequest</strong>: A data structure containing all parameters needed for a tracker announce request, including info hash, peer ID, port, uploaded/downloaded/left byte counts, and event type. This structure is serialized into HTTP GET parameters when communicating with trackers. Proper construction of announce requests is critical for tracker communication and peer discovery.</p>\n<p><strong>AnnounceResponse</strong>: A data structure representing the tracker&#39;s response to an announce request, containing the announce interval, swarm statistics (complete/incomplete peer counts), and the compact peer list. Trackers may also return failure reasons for invalid requests. Parsing announce responses correctly is essential for extracting peer information and scheduling future announces.</p>\n<p><strong>BitfieldOps</strong>: A data structure and associated operations for managing piece availability bitmaps efficiently. Provides methods to set/clear/test individual bits, count available pieces, and serialize bitfields for transmission. Bitfield operations must handle bit-level manipulation correctly, including proper byte boundary handling for piece counts that aren&#39;t multiples of 8.</p>\n<p><strong>Connection</strong>: A data structure representing an active TCP connection to another BitTorrent peer, including socket, message framer, peer state flags (choking/interested), bitfield, and pending request queues. Connection objects manage the complete lifecycle of peer communication, from handshake through message exchange to cleanup. Proper connection state management is crucial for protocol correctness.</p>\n<p><strong>Decoder</strong>: A bencode decoder implementation that can parse the four bencode data types from a byte stream. The decoder uses recursive descent parsing to handle nested structures like lists and dictionaries. Decoder state includes current position in the stream and error handling for malformed bencode data. Correct bencode parsing is fundamental to torrent file processing.</p>\n<p><strong>Info</strong>: A data structure representing the info dictionary from a torrent file, containing file names, lengths, piece length, and concatenated piece hashes. The info dictionary describes the actual content being shared and is used to calculate the info hash that identifies the torrent. All torrent metadata validation and file construction depends on correct Info parsing.</p>\n<p><strong>MetaInfo</strong>: The complete data structure representing a parsed torrent file, including tracker URLs, creation metadata, and the info dictionary. MetaInfo serves as the authoritative source of torrent configuration throughout the client&#39;s operation. Proper MetaInfo construction from bencode data enables all subsequent BitTorrent operations.</p>\n<p><strong>PieceState</strong>: A data structure tracking the download progress and verification status of an individual piece, including block completion status, hash verification results, and piece priority. Piece state management coordinates concurrent downloads from multiple peers and ensures data integrity through hash verification.</p>\n<h3 id=\"networking-and-concurrency-concepts\">Networking and Concurrency Concepts</h3>\n<p><strong>circuit breaker</strong>: A software pattern that prevents repeated failures by automatically failing fast when error rates exceed thresholds. In BitTorrent contexts, circuit breakers protect against misbehaving peers or trackers by temporarily avoiding connection attempts after repeated failures, then gradually allowing test connections to detect recovery.</p>\n<p><strong>event bus</strong>: An asynchronous messaging system enabling loose coupling between BitTorrent client components. Components publish events (peer connected, piece completed, tracker response) and subscribe to events they need to handle. Event buses simplify coordination between components like piece managers, peer managers, and user interfaces without tight coupling.</p>\n<p><strong>exponential backoff</strong>: A retry strategy where the delay between retry attempts increases exponentially after each failure, often with random jitter to prevent synchronized retries across multiple clients. BitTorrent clients use exponential backoff for tracker announces, peer connections, and piece requests to avoid overwhelming struggling resources.</p>\n<p><strong>graceful shutdown</strong>: A shutdown procedure that allows in-flight operations to complete before terminating the program. For BitTorrent clients, graceful shutdown includes completing piece verifications, sending final tracker announces, closing peer connections cleanly, and flushing any buffered file writes. Proper shutdown prevents data corruption and maintains good network citizenship.</p>\n<p><strong>message framing</strong>: The protocol mechanism for parsing variable-length messages from TCP byte streams using length prefixes. BitTorrent&#39;s framing uses 4-byte length headers followed by message payloads. Correct framing implementation prevents protocol desynchronization and enables reliable message parsing even with partial TCP reads.</p>\n<p><strong>shared state</strong>: Data structures accessible by multiple concurrent goroutines or threads, requiring synchronization mechanisms like mutexes to prevent race conditions. In BitTorrent clients, shared state includes piece availability maps, peer connection lists, and download statistics that multiple components access concurrently.</p>\n<p><strong>state machine</strong>: A computational model defining system behavior through states, transitions, and events. BitTorrent peer connections implement state machines tracking choking/unchoking and interested/uninterested states, with message-driven transitions between states. Proper state machine implementation ensures protocol correctness and prevents invalid state combinations.</p>\n<h3 id=\"file-and-data-management\">File and Data Management</h3>\n<p><strong>piece verification</strong>: The process of computing SHA-1 hashes of downloaded pieces and comparing them against the expected hashes from the torrent metadata. Verification ensures data integrity and detects corruption or malicious peers. Failed verification requires re-downloading the piece from different peers. Verification typically occurs immediately after completing a piece download.</p>\n<p><strong>rarest-first selection</strong>: A piece selection algorithm that prioritizes pieces held by the fewest connected peers, increasing overall swarm health by duplicating rare pieces quickly. The algorithm maintains availability counts for all pieces across connected peers and selects pieces with minimum availability. This strategy prevents pieces from becoming unavailable when peers leave the swarm.</p>\n<h3 id=\"advanced-bittorrent-features\">Advanced BitTorrent Features</h3>\n<p><strong>Distributed Hash Table (DHT)</strong>: A decentralized peer discovery mechanism that eliminates dependence on central tracker servers. DHT networks store peer information distributed across participating nodes, allowing torrent clients to find peers without tracker access. DHT implementation involves the Kademlia distributed hash table protocol with peer routing tables and distributed key-value storage.</p>\n<p><strong>magnet link</strong>: A URI scheme for identifying torrents using their info hash rather than torrent files. Magnet links enable instant sharing without distributing torrent files, with the complete metadata fetched from peers after connection. Magnet links typically include the info hash, display name, and tracker URLs, enabling clients to join swarms and download metadata on-demand.</p>\n<p><strong>Message Stream Encryption (MSE)</strong>: A protocol extension providing encryption for BitTorrent communications to prevent ISP throttling and deep packet inspection. MSE encrypts the peer wire protocol after handshake completion while maintaining protocol compatibility. Implementation involves cryptographic key exchange and stream cipher encryption of subsequent messages.</p>\n<h3 id=\"error-handling-and-quality-assurance\">Error Handling and Quality Assurance</h3>\n<p><strong>failure cascade</strong>: A failure mode where one component failure triggers additional failures in dependent components, potentially leading to system-wide problems. BitTorrent clients must implement circuit breakers, timeouts, and isolation mechanisms to prevent tracker failures from affecting peer communications or piece verification failures from disrupting other downloads.</p>\n<p><strong>peer quality scoring</strong>: A system for evaluating and ranking peer reliability based on metrics like connection stability, data transfer rates, protocol compliance, and data integrity. Quality scores influence peer selection decisions, connection priorities, and choking algorithms to optimize overall download performance by preferring high-quality peers.</p>\n<p><strong>protocol violation</strong>: Deviation from the BitTorrent wire protocol specification that can cause interoperability problems or security vulnerabilities. Common violations include incorrect message formatting, invalid state transitions, or sending data to choked peers. Robust clients must detect and handle protocol violations gracefully while maintaining compatibility with compliant peers.</p>\n<h3 id=\"testing-and-development\">Testing and Development</h3>\n<p><strong>integration testing</strong>: Testing approach that verifies component interactions using controlled environments like mock trackers and test torrents with known content. Integration tests validate complete workflows like announce → peer discovery → handshake → piece download → verification, ensuring all components work together correctly.</p>\n<p><strong>mock tracker</strong>: A test implementation of the tracker protocol using local HTTP servers to provide predictable responses for testing. Mock trackers enable controlled testing of announce requests, error handling, peer list parsing, and retry logic without depending on external tracker infrastructure or network conditions.</p>\n<p><strong>test torrent</strong>: A specially crafted torrent file with known content, piece boundaries, and expected hashes for verification during testing. Test torrents enable automated verification of parsing, downloading, and verification logic by providing predictable inputs and expected outputs for test cases.</p>\n<p><strong>unit testing</strong>: Testing individual components in isolation without external dependencies like network connections or file systems. Unit tests verify specific functionality like bencode parsing, piece hash calculation, bitfield operations, and message serialization using controlled inputs and expected outputs.</p>\n<h3 id=\"performance-and-optimization\">Performance and Optimization</h3>\n<p><strong>bandwidth management</strong>: Techniques for controlling upload and download rates to optimize performance and comply with user-configured limits. Implementation involves token bucket algorithms, rate limiting, connection prioritization, and adaptive adjustment based on network conditions and peer performance.</p>\n<p><strong>connection pooling</strong>: Maintaining reusable network connections across multiple torrents or operations to reduce connection establishment overhead. Connection pools must handle connection lifetime management, error recovery, and resource cleanup while maintaining protocol compliance and security boundaries.</p>\n<p><strong>token bucket algorithm</strong>: A rate limiting algorithm that allows controlled bursts while maintaining average rate limits over time. Token buckets accumulate tokens at a fixed rate up to a maximum capacity, with each operation consuming tokens. This enables BitTorrent clients to achieve smooth bandwidth utilization while respecting rate limits.</p>\n<h3 id=\"user-interface-and-api\">User Interface and API</h3>\n<p><strong>Single Page Application (SPA)</strong>: A web application architecture where client-side JavaScript handles user interface updates and communicates with server APIs via AJAX. SPA BitTorrent interfaces provide responsive user experiences with real-time torrent status updates, file browsing, and download management without page refreshes.</p>\n<p><strong>WebSocket</strong>: A persistent bidirectional communication protocol enabling real-time updates between web browsers and servers. BitTorrent web interfaces use WebSocket connections to push live status updates, peer statistics, and download progress to user interfaces without polling overhead.</p>\n<h3 id=\"security-and-network\">Security and Network</h3>\n<p><strong>DHT bootstrap</strong>: The process of joining a Distributed Hash Table network by connecting to well-known bootstrap nodes that provide initial routing table entries. Bootstrap nodes help new clients discover other DHT participants and begin participating in distributed peer discovery operations.</p>\n<p><strong>metadata fetching</strong>: The process of retrieving complete torrent metadata from peers using the Extension Protocol when only an info hash is available (such as from magnet links). Metadata fetching involves requesting metadata pieces from peers who have the complete torrent information.</p>\n","toc":[{"level":1,"text":"Build Your Own BitTorrent: Design Document","id":"build-your-own-bittorrent-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"The Library Network Analogy","id":"the-library-network-analogy"},{"level":3,"text":"File Sharing Approaches","id":"file-sharing-approaches"},{"level":3,"text":"Core Technical Challenges","id":"core-technical-challenges"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":3,"text":"Non-Functional Goals","id":"non-functional-goals"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoints","id":"f-milestone-checkpoints"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Responsibilities","id":"component-responsibilities"},{"level":3,"text":"Recommended Module Structure","id":"recommended-module-structure"},{"level":3,"text":"High-Level Data Flow","id":"high-level-data-flow"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Torrent Metadata Structures","id":"torrent-metadata-structures"},{"level":3,"text":"Peer and Connection State","id":"peer-and-connection-state"},{"level":3,"text":"Piece and Block Management","id":"piece-and-block-management"},{"level":3,"text":"Protocol Message Formats","id":"protocol-message-formats"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Complete Infrastructure Code","id":"complete-infrastructure-code"},{"level":4,"text":"Core Logic Skeletons","id":"core-logic-skeletons"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Torrent File Parsing (Milestone 1)","id":"torrent-file-parsing-milestone-1"},{"level":3,"text":"Bencode: Binary JSON Analogy","id":"bencode-binary-json-analogy"},{"level":3,"text":"Bencode Decoder Design","id":"bencode-decoder-design"},{"level":3,"text":"Torrent Metadata Extraction","id":"torrent-metadata-extraction"},{"level":3,"text":"Info Hash Calculation","id":"info-hash-calculation"},{"level":3,"text":"Common Parsing Pitfalls","id":"common-parsing-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Tracker Communication (Milestone 2)","id":"tracker-communication-milestone-2"},{"level":3,"text":"Tracker as Matchmaking Service","id":"tracker-as-matchmaking-service"},{"level":3,"text":"Announce Request Protocol","id":"announce-request-protocol"},{"level":3,"text":"Peer List Response Parsing","id":"peer-list-response-parsing"},{"level":3,"text":"Tracker Error Handling","id":"tracker-error-handling"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Code: HTTP Client and URL Encoding","id":"infrastructure-code-http-client-and-url-encoding"},{"level":4,"text":"Core Data Structures","id":"core-data-structures"},{"level":4,"text":"Core Logic Skeleton: Tracker Client Implementation","id":"core-logic-skeleton-tracker-client-implementation"},{"level":4,"text":"Testing and Validation Checkpoints","id":"testing-and-validation-checkpoints"},{"level":2,"text":"Peer Wire Protocol (Milestone 3)","id":"peer-wire-protocol-milestone-3"},{"level":3,"text":"Peer Protocol as Conversation Rules","id":"peer-protocol-as-conversation-rules"},{"level":3,"text":"Connection Handshake","id":"connection-handshake"},{"level":3,"text":"Message Framing and Parsing","id":"message-framing-and-parsing"},{"level":3,"text":"Peer State Management","id":"peer-state-management"},{"level":3,"text":"Request Pipelining","id":"request-pipelining"},{"level":3,"text":"Common Protocol Pitfalls","id":"common-protocol-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Piece Management &amp; Seeding (Milestone 4)","id":"piece-management-amp-seeding-milestone-4"},{"level":3,"text":"Piece Management as Jigsaw Puzzle","id":"piece-management-as-jigsaw-puzzle"},{"level":3,"text":"Content Verification","id":"content-verification"},{"level":3,"text":"Piece Selection Strategy","id":"piece-selection-strategy"},{"level":3,"text":"Concurrent Download Management","id":"concurrent-download-management"},{"level":3,"text":"Upload and Seeding","id":"upload-and-seeding"},{"level":3,"text":"Common Piece Management Pitfalls","id":"common-piece-management-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Complete Download Lifecycle","id":"complete-download-lifecycle"},{"level":3,"text":"Inter-Component Communication","id":"inter-component-communication"},{"level":3,"text":"Concurrency Coordination","id":"concurrency-coordination"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"System Failure Modes","id":"system-failure-modes"},{"level":3,"text":"Recovery and Retry Logic","id":"recovery-and-retry-logic"},{"level":3,"text":"Protocol Edge Cases","id":"protocol-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Testing Strategy and Milestones","id":"testing-strategy-and-milestones"},{"level":3,"text":"Unit Testing Strategy","id":"unit-testing-strategy"},{"level":3,"text":"Integration Testing","id":"integration-testing"},{"level":3,"text":"Milestone Verification Checkpoints","id":"milestone-verification-checkpoints"},{"level":4,"text":"Milestone 1: Torrent File Parsing Checkpoints","id":"milestone-1-torrent-file-parsing-checkpoints"},{"level":4,"text":"Milestone 2: Tracker Communication Checkpoints","id":"milestone-2-tracker-communication-checkpoints"},{"level":4,"text":"Milestone 3: Peer Wire Protocol Checkpoints","id":"milestone-3-peer-wire-protocol-checkpoints"},{"level":4,"text":"Milestone 4: Piece Management &amp; Seeding Checkpoints","id":"milestone-4-piece-management-amp-seeding-checkpoints"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Testing Logic Skeletons","id":"core-testing-logic-skeletons"},{"level":4,"text":"Milestone Checkpoint Scripts","id":"milestone-checkpoint-scripts"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Torrent Parsing Debug Guide","id":"torrent-parsing-debug-guide"},{"level":4,"text":"Bencode Parsing Issues","id":"bencode-parsing-issues"},{"level":4,"text":"Info Hash Calculation Debugging","id":"info-hash-calculation-debugging"},{"level":4,"text":"Torrent Metadata Extraction Issues","id":"torrent-metadata-extraction-issues"},{"level":3,"text":"Network Protocol Debugging","id":"network-protocol-debugging"},{"level":4,"text":"Tracker Communication Issues","id":"tracker-communication-issues"},{"level":4,"text":"Peer Wire Protocol Debugging","id":"peer-wire-protocol-debugging"},{"level":4,"text":"State Machine Debugging","id":"state-machine-debugging"},{"level":3,"text":"Concurrency and State Issues","id":"concurrency-and-state-issues"},{"level":4,"text":"Race Condition Identification","id":"race-condition-identification"},{"level":4,"text":"Deadlock Detection and Prevention","id":"deadlock-detection-and-prevention"},{"level":4,"text":"State Synchronization Issues","id":"state-synchronization-issues"},{"level":4,"text":"Memory Leak Detection","id":"memory-leak-detection"},{"level":3,"text":"Debugging Tools and Techniques","id":"debugging-tools-and-techniques"},{"level":4,"text":"Logging Strategy","id":"logging-strategy"},{"level":4,"text":"Network Traffic Analysis","id":"network-traffic-analysis"},{"level":4,"text":"State Inspection Techniques","id":"state-inspection-techniques"},{"level":4,"text":"Test Environment Setup","id":"test-environment-setup"},{"level":4,"text":"Performance Profiling","id":"performance-profiling"},{"level":4,"text":"Systematic Bug Reproduction","id":"systematic-bug-reproduction"},{"level":4,"text":"Debug Output Organization","id":"debug-output-organization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Complete Debugging Infrastructure Code","id":"complete-debugging-infrastructure-code"},{"level":4,"text":"Core Logic Debugging Skeleton","id":"core-logic-debugging-skeleton"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips Table","id":"debugging-tips-table"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Advanced Protocol Features","id":"advanced-protocol-features"},{"level":4,"text":"Distributed Hash Table (DHT) Integration","id":"distributed-hash-table-dht-integration"},{"level":4,"text":"Magnet Link Support","id":"magnet-link-support"},{"level":4,"text":"Protocol Encryption and Obfuscation","id":"protocol-encryption-and-obfuscation"},{"level":4,"text":"Multi-Tracker and Tracker Tiers","id":"multi-tracker-and-tracker-tiers"},{"level":3,"text":"Performance Optimizations","id":"performance-optimizations"},{"level":4,"text":"Advanced Piece Selection Strategies","id":"advanced-piece-selection-strategies"},{"level":4,"text":"Bandwidth Management and Traffic Shaping","id":"bandwidth-management-and-traffic-shaping"},{"level":4,"text":"Connection Optimization and Pooling","id":"connection-optimization-and-pooling"},{"level":3,"text":"User Interface Integration","id":"user-interface-integration"},{"level":4,"text":"API Design for GUI Integration","id":"api-design-for-gui-integration"},{"level":4,"text":"Real-time Status Updates","id":"real-time-status-updates"},{"level":4,"text":"Web-based Dashboard Implementation","id":"web-based-dashboard-implementation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"DHT Implementation Starter Code","id":"dht-implementation-starter-code"},{"level":4,"text":"Magnet Link Support Implementation","id":"magnet-link-support-implementation"},{"level":4,"text":"Web API Infrastructure","id":"web-api-infrastructure"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Performance Testing and Optimization","id":"performance-testing-and-optimization"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"BitTorrent Protocol Core Concepts","id":"bittorrent-protocol-core-concepts"},{"level":3,"text":"Protocol Message Types","id":"protocol-message-types"},{"level":3,"text":"Data Structures and Technical Terms","id":"data-structures-and-technical-terms"},{"level":3,"text":"Networking and Concurrency Concepts","id":"networking-and-concurrency-concepts"},{"level":3,"text":"File and Data Management","id":"file-and-data-management"},{"level":3,"text":"Advanced BitTorrent Features","id":"advanced-bittorrent-features"},{"level":3,"text":"Error Handling and Quality Assurance","id":"error-handling-and-quality-assurance"},{"level":3,"text":"Testing and Development","id":"testing-and-development"},{"level":3,"text":"Performance and Optimization","id":"performance-and-optimization"},{"level":3,"text":"User Interface and API","id":"user-interface-and-api"},{"level":3,"text":"Security and Network","id":"security-and-network"}],"title":"Build Your Own BitTorrent: Design Document","markdown":"# Build Your Own BitTorrent: Design Document\n\n\n## Overview\n\nThis document outlines the design for a complete BitTorrent client that can download and seed files in a peer-to-peer network. The key architectural challenge is coordinating concurrent downloads from multiple peers while managing piece verification, peer state machines, and tracker communication protocols.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** This section provides foundational context for all milestones (1-4) by establishing the problem space and design challenges.\n\n### The Library Network Analogy\n\nImagine a vast network of libraries spread across the world, each containing different collections of books. When you want to read a specific book, you don't need to travel to the one library that has it. Instead, you can request it through an **inter-library loan system** where libraries cooperate to share their collections. The library network maintains a **catalog service** that knows which libraries have which books, and when you request a book, the catalog tells you exactly where to find it.\n\nBitTorrent works remarkably similarly to this library network, but instead of books, we're sharing files, and instead of libraries, we have individual computers (called **peers**). Just as libraries maintain catalogs of their collections, BitTorrent uses **torrent files** that contain a catalog of what files are available and how to verify you received the correct content. The **tracker** serves as the central catalog service, maintaining a list of which peers currently have which files available for sharing.\n\nThe key insight is that no single library (or peer) needs to have the complete collection. When you want a popular book, multiple libraries might have copies, so you can choose the most convenient one or even get different chapters from different libraries simultaneously. Similarly, when downloading a file via BitTorrent, you can download different **pieces** of the file from multiple peers concurrently, dramatically speeding up the process.\n\nJust as libraries have policies about lending (you must return books, there are limits on how many you can borrow), BitTorrent implements **incentive mechanisms** where peers who share files get priority access to download from others. This creates a self-sustaining ecosystem where sharing benefits everyone.\n\nThe analogy breaks down in one crucial way: unlike physical books that can only be in one place at a time, digital files can be perfectly copied. Once you've downloaded a complete file via BitTorrent, you automatically become another \"library\" in the network, able to serve that file to future requesters. This creates a **viral sharing effect** where popular files become more available over time, not less.\n\n### File Sharing Approaches\n\nThe evolution of file sharing represents different architectural approaches to the fundamental problem of distributing content efficiently across a network. Each approach involves trade-offs between performance, reliability, cost, and control.\n\n| Approach | Architecture | Discovery Method | Content Source | Bandwidth Usage | Failure Mode | Example |\n|----------|-------------|------------------|----------------|-----------------|--------------|---------|\n| **Centralized** | Single server hosts all content | Central directory/search | One server per file | Server pays all bandwidth costs | Single point of failure - server down means no access | Early web downloads, FTP sites |\n| **Client-Server CDN** | Multiple geographic servers with replicated content | DNS-based geographic routing | Closest available server | CDN provider pays bandwidth costs | Graceful degradation - some regions may lose access | Netflix, Steam, major websites |\n| **Pure P2P** | All peers are equal, no central authority | Distributed hash tables (DHT) | Any peer with content | Distributed across all peers | Network fragmentation - peers may not find each other | Early Gnutella, Freenet |\n| **Hybrid P2P (BitTorrent)** | Peers share content, tracker coordinates | Central tracker for peer discovery | Multiple peers simultaneously | Distributed across downloading peers | Tracker failure stops new downloads, but existing swarms continue | BitTorrent, modern P2P protocols |\n\n> **Key Insight**: BitTorrent's hybrid approach combines the reliability of centralized peer discovery with the scalability benefits of distributed content delivery. This architectural decision reflects a fundamental principle: **centralize coordination, distribute execution**.\n\n**Decision: Hybrid P2P Architecture for BitTorrent**\n- **Context**: File sharing systems must balance discoverability (finding content and peers) with scalability (handling load as popularity increases)\n- **Options Considered**: \n  1. Pure centralized (single server hosts files)\n  2. Pure P2P (fully decentralized discovery and content)\n  3. Hybrid P2P (centralized tracker, distributed content)\n- **Decision**: Hybrid P2P with tracker-based peer discovery and peer-to-peer content transfer\n- **Rationale**: Centralized trackers solve the peer discovery problem efficiently while distributed content transfer scales bandwidth costs with demand and creates redundancy\n- **Consequences**: Enables rapid peer discovery and coordinated downloading while distributing bandwidth costs, but creates tracker dependency for initial peer discovery\n\nThe bandwidth economics are particularly compelling. In a centralized model, if a file becomes popular, the server operator pays exponentially increasing bandwidth costs. With BitTorrent, increased popularity means more peers have the complete file, creating **more upload capacity** in the system. The bandwidth cost scales with the number of people willing to share, not just with demand.\n\n### Core Technical Challenges\n\nBitTorrent solves three fundamental distributed systems problems that make peer-to-peer file sharing practical at scale. Each challenge represents a different aspect of coordinating untrusted participants in a decentralized network.\n\n**Challenge 1: Peer Discovery in a Dynamic Network**\n\nThe first challenge is the **bootstrapping problem**: how do you find other peers who have the content you want when there's no central directory of active participants? Unlike a web server with a fixed IP address, BitTorrent peers are typically home computers with dynamic IP addresses that come online and go offline unpredictably.\n\nBitTorrent solves this through the **tracker protocol**. The tracker acts as a rendezvous point where peers announce their availability and discover others. When a peer wants to download a file, it extracts the tracker URL from the torrent file, announces itself to the tracker with its current IP address and port, and receives a list of other peers currently sharing that file.\n\nThe tracker doesn't store the actual file content - it only maintains **ephemeral peer lists** that reflect the current state of the swarm. Peers must periodically re-announce to stay in the active peer list, creating a self-cleaning mechanism where offline peers automatically disappear from the system.\n\n| Tracker Interaction | Purpose | Information Exchanged | Frequency |\n|---------------------|---------|---------------------|-----------|\n| **Initial Announce** | Join swarm, get initial peer list | Peer reports: info_hash, peer_id, IP, port, bytes uploaded/downloaded | Once per torrent |\n| **Periodic Announce** | Stay visible, report progress, get updated peers | Updated statistics, receive peers that joined since last announce | Every 15-30 minutes |\n| **Event Announce** | Report state changes | 'started', 'completed', or 'stopped' events with current statistics | When events occur |\n\n**Challenge 2: Content Verification in an Untrusted Network**\n\nThe second challenge is **content integrity**: how do you verify that the data you receive from untrusted peers hasn't been corrupted or maliciously modified? Traditional file downloads from trusted servers don't face this problem, but in a P2P network, any peer could send you garbage data.\n\nBitTorrent's solution is **cryptographic piece verification**. The torrent file contains SHA-1 hashes of every piece of the target file. When a peer receives a piece from another peer, it immediately computes the SHA-1 hash of the received data and compares it to the expected hash from the torrent file. If the hashes don't match, the piece is discarded and requested again from a different peer.\n\nThis creates a **trustless verification system** where peers don't need to trust each other - they only need to trust the cryptographic hashes in the torrent file. The hash verification happens at the **piece level** (typically 256KB to 1MB chunks) rather than the entire file, allowing verification to occur incrementally during download.\n\n| Verification Stage | Data Verified | Hash Source | Action on Mismatch |\n|-------------------|---------------|-------------|-------------------|\n| **Torrent File** | Info dictionary metadata | SHA-1 of bencoded info dict | Reject torrent as invalid |\n| **Individual Pieces** | Each 256KB-1MB piece | Pre-computed SHA-1 in pieces list | Discard piece, request from different peer |\n| **Complete File** | Assembled final file | Recompute all piece hashes | File complete and verified |\n\n> **Critical Security Property**: The piece hashing system ensures that even if malicious peers control 99% of the swarm, they cannot corrupt your download as long as at least one honest peer has each piece. The cryptographic verification makes corruption detectable with overwhelming probability.\n\n**Challenge 3: Fair Sharing Incentives**\n\nThe third challenge is the **free rider problem**: in a system where anyone can download files, what prevents everyone from downloading without uploading, causing the system to collapse from lack of seeders? This is a classic tragedy of the commons scenario.\n\nBitTorrent addresses this through **tit-for-tat reciprocity** and the **choking algorithm**. Peers track how much data they've uploaded to and downloaded from each connected peer. Each peer \"unchokes\" (allows downloads from) only a limited number of other peers at any time, prioritizing peers who are uploading data back to them.\n\nThe choking mechanism creates **economic incentives** for sharing. Peers who upload get better download performance because other peers prioritize them. Peers who only try to download get \"choked\" by most peers, severely limiting their download speed. This creates a virtuous cycle where contributing to the network directly improves your own experience.\n\n| Peer Relationship | Upload to Them | Download from Them | Their Incentive | Your Benefit |\n|-------------------|----------------|-------------------|----------------|--------------|\n| **Mutual Exchange** | High | High | You provide content they want | Fast downloads from them |\n| **Optimistic Unchoke** | High | Low (they're new) | Bootstraps new peers into economy | Potential future reciprocation |\n| **Free Rider** | Low/Zero | Low (choked) | Strong incentive to start sharing | Preserve bandwidth for contributors |\n| **Seed** | High | Zero (they're complete) | Altruistic sharing | Community health, future availability |\n\nThe **optimistic unchoke** mechanism provides a crucial bootstrap path for new peers who haven't yet contributed to the swarm. Periodically, peers will unchoke a random peer regardless of reciprocation history, giving newcomers a chance to start downloading and begin contributing.\n\n> **Economic Design Insight**: BitTorrent's incentive system transforms file sharing from a pure public good (where rational actors free ride) into a **reciprocal economy** where contribution directly improves individual outcomes. This aligns individual incentives with system health.\n\nThese three challenges - peer discovery, content verification, and fair sharing - represent the core technical problems that any practical P2P file sharing system must solve. BitTorrent's solutions to these problems have proven remarkably durable, with the core protocols remaining largely unchanged for over two decades while handling enormous volumes of global file sharing traffic.\n\nThe interdependence of these solutions is crucial to understand. The tracker system enables rapid peer discovery, but peers must implement content verification because they can't trust discovered peers. The verification system enables safe downloading from untrusted sources, but the incentive system ensures there are sources worth downloading from. Each component reinforces the others to create a robust, self-sustaining ecosystem.\n\n![BitTorrent Client Architecture](./diagrams/system-architecture.svg)\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing the BitTorrent client architecture in Go, with complete starter code for infrastructure components and detailed skeletons for core learning components.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option | Recommendation |\n|-----------|---------------|-----------------|----------------|\n| **HTTP Client** | `net/http` package | Custom HTTP with connection pooling | Simple - Go's HTTP client handles tracker communication well |\n| **TCP Networking** | `net.Conn` with manual protocol | Framework like `github.com/pion/webrtc` | Simple - BitTorrent wire protocol is straightforward TCP |\n| **Concurrency** | Goroutines with channels | Worker pool libraries | Simple - Go's built-in concurrency is perfect for P2P |\n| **File I/O** | `os.File` with `io` interfaces | Memory-mapped files with `mmap` | Simple - Sequential piece writing doesn't need mmap |\n| **Hashing** | `crypto/sha1` package | Hardware-accelerated crypto | Simple - SHA-1 performance is sufficient |\n| **Bencode Parsing** | Custom recursive parser | Third-party bencode library | **Custom** - Parsing is core learning objective |\n\n**B. Recommended Module Structure**\n\n```\nbittorrent-client/\n├── cmd/\n│   └── bt-client/\n│       └── main.go              ← CLI entry point, argument parsing\n├── internal/\n│   ├── bencode/\n│   │   ├── decoder.go           ← Bencode parser (Milestone 1)\n│   │   └── decoder_test.go\n│   ├── torrent/\n│   │   ├── metainfo.go          ← Torrent file structures\n│   │   ├── parser.go            ← Torrent parsing (Milestone 1)\n│   │   └── parser_test.go\n│   ├── tracker/\n│   │   ├── client.go            ← HTTP tracker client (Milestone 2)\n│   │   ├── announce.go          ← Announce request/response\n│   │   └── tracker_test.go\n│   ├── peer/\n│   │   ├── connection.go        ← Peer wire protocol (Milestone 3)\n│   │   ├── handshake.go         ← Handshake implementation\n│   │   ├── messages.go          ← Protocol message types\n│   │   └── peer_test.go\n│   ├── piece/\n│   │   ├── manager.go           ← Piece download coordination (Milestone 4)\n│   │   ├── verification.go      ← Hash verification\n│   │   └── piece_test.go\n│   └── client/\n│       ├── client.go            ← Main BitTorrent client orchestration\n│       └── client_test.go\n├── pkg/                         ← Public APIs (if building library)\n├── testdata/                    ← Sample .torrent files for testing\n├── go.mod\n└── README.md\n```\n\n**C. Infrastructure Starter Code**\n\nHere's complete, working infrastructure code that handles non-core concerns:\n\n```go\n// internal/torrent/metainfo.go - Complete data structures\npackage torrent\n\nimport (\n    \"crypto/sha1\"\n    \"time\"\n)\n\n// MetaInfo represents the complete parsed torrent file\ntype MetaInfo struct {\n    Announce     string    `json:\"announce\"`\n    CreationDate time.Time `json:\"creation_date,omitempty\"`\n    Comment      string    `json:\"comment,omitempty\"`\n    InfoHash     [20]byte  `json:\"info_hash\"`\n    Info         Info      `json:\"info\"`\n}\n\n// Info represents the info dictionary from the torrent file\ntype Info struct {\n    Name        string `json:\"name\"`\n    Length      int64  `json:\"length\"`           // Single file mode\n    PieceLength int64  `json:\"piece_length\"`\n    Pieces      []byte `json:\"pieces\"`           // SHA-1 hashes concatenated\n    Files       []File `json:\"files,omitempty\"`  // Multi-file mode\n}\n\n// File represents a file in multi-file torrent mode\ntype File struct {\n    Length int64    `json:\"length\"`\n    Path   []string `json:\"path\"`\n}\n\n// GetPieceHashes returns individual piece hashes from the concatenated pieces field\nfunc (i *Info) GetPieceHashes() [][20]byte {\n    numPieces := len(i.Pieces) / 20\n    hashes := make([][20]byte, numPieces)\n    for i := 0; i < numPieces; i++ {\n        copy(hashes[i][:], i.Pieces[i*20:(i+1)*20])\n    }\n    return hashes\n}\n\n// CalculateInfoHash computes SHA-1 hash of bencoded info dictionary\nfunc CalculateInfoHash(bencoded []byte) [20]byte {\n    return sha1.Sum(bencoded)\n}\n```\n\n```go\n// internal/tracker/announce.go - Complete tracker protocol structures\npackage tracker\n\nimport (\n    \"net/url\"\n    \"strconv\"\n    \"time\"\n)\n\n// AnnounceRequest represents parameters sent to tracker\ntype AnnounceRequest struct {\n    InfoHash   [20]byte\n    PeerID     [20]byte\n    Port       int\n    Uploaded   int64\n    Downloaded int64\n    Left       int64\n    Event      string // \"started\", \"completed\", \"stopped\", or empty\n}\n\n// AnnounceResponse represents tracker's response\ntype AnnounceResponse struct {\n    Interval    int    `bencode:\"interval\"`\n    Complete    int    `bencode:\"complete\"`\n    Incomplete  int    `bencode:\"incomplete\"`\n    Peers       []byte `bencode:\"peers\"`        // Compact format\n    FailureReason string `bencode:\"failure reason,omitempty\"`\n}\n\n// PeerInfo represents a single peer from tracker response\ntype PeerInfo struct {\n    IP   [4]byte\n    Port uint16\n}\n\n// BuildAnnounceURL constructs the complete tracker announce URL\nfunc (req *AnnounceRequest) BuildAnnounceURL(announceURL string) string {\n    base, _ := url.Parse(announceURL)\n    params := url.Values{}\n    \n    params.Set(\"info_hash\", string(req.InfoHash[:]))\n    params.Set(\"peer_id\", string(req.PeerID[:]))\n    params.Set(\"port\", strconv.Itoa(req.Port))\n    params.Set(\"uploaded\", strconv.FormatInt(req.Uploaded, 10))\n    params.Set(\"downloaded\", strconv.FormatInt(req.Downloaded, 10))\n    params.Set(\"left\", strconv.FormatInt(req.Left, 10))\n    params.Set(\"compact\", \"1\")\n    \n    if req.Event != \"\" {\n        params.Set(\"event\", req.Event)\n    }\n    \n    base.RawQuery = params.Encode()\n    return base.String()\n}\n\n// ParseCompactPeers decodes compact peer list from tracker response\nfunc ParseCompactPeers(compactPeers []byte) []PeerInfo {\n    numPeers := len(compactPeers) / 6\n    peers := make([]PeerInfo, numPeers)\n    \n    for i := 0; i < numPeers; i++ {\n        offset := i * 6\n        copy(peers[i].IP[:], compactPeers[offset:offset+4])\n        peers[i].Port = uint16(compactPeers[offset+4])<<8 + uint16(compactPeers[offset+5])\n    }\n    \n    return peers\n}\n```\n\n**D. Core Logic Skeleton Code**\n\nFor the main learning objectives, provide detailed skeletons that map to the algorithm steps:\n\n```go\n// internal/bencode/decoder.go - Core learning skeleton\npackage bencode\n\nimport (\n    \"bufio\"\n    \"errors\"\n    \"io\"\n)\n\n// Decoder handles recursive parsing of bencode data\ntype Decoder struct {\n    reader *bufio.Reader\n}\n\n// NewDecoder creates a decoder for the given data stream\nfunc NewDecoder(r io.Reader) *Decoder {\n    return &Decoder{reader: bufio.NewReader(r)}\n}\n\n// Decode parses the next bencode value and returns it\n// This is the main entry point for bencode parsing\nfunc (d *Decoder) Decode() (interface{}, error) {\n    // TODO 1: Peek at the next byte to determine the type\n    // TODO 2: If byte is 'i', call d.decodeInteger()\n    // TODO 3: If byte is 'l', call d.decodeList()\n    // TODO 4: If byte is 'd', call d.decodeDictionary()\n    // TODO 5: If byte is digit (0-9), call d.decodeString()\n    // TODO 6: Return error for any other byte value\n    // Hint: Use d.reader.Peek(1) to look at next byte without consuming it\n    return nil, errors.New(\"not implemented\")\n}\n\n// decodeString parses a bencode string: <length>:<content>\nfunc (d *Decoder) decodeString() ([]byte, error) {\n    // TODO 1: Read digits until ':' to get length\n    // TODO 2: Convert length string to integer\n    // TODO 3: Read exactly 'length' bytes for string content\n    // TODO 4: Return the raw bytes (don't convert to string - could be binary)\n    // Hint: Use d.reader.ReadBytes(':') to read until delimiter\n    return nil, errors.New(\"not implemented\")\n}\n\n// decodeInteger parses a bencode integer: i<number>e\nfunc (d *Decoder) decodeInteger() (int64, error) {\n    // TODO 1: Read and verify 'i' prefix\n    // TODO 2: Read digits (and possible '-') until 'e'\n    // TODO 3: Convert to int64 using strconv.ParseInt\n    // TODO 4: Read and verify 'e' suffix\n    return 0, errors.New(\"not implemented\")\n}\n\n// decodeList parses a bencode list: l<item1><item2>...e\nfunc (d *Decoder) decodeList() ([]interface{}, error) {\n    // TODO 1: Read and verify 'l' prefix\n    // TODO 2: Create empty slice for results\n    // TODO 3: Loop until next byte is 'e':\n    // TODO 4:   Call d.Decode() recursively for each item\n    // TODO 5:   Append result to slice\n    // TODO 6: Read and verify 'e' suffix\n    // TODO 7: Return completed slice\n    return nil, errors.New(\"not implemented\")\n}\n\n// decodeDictionary parses a bencode dictionary: d<key1><value1><key2><value2>...e\nfunc (d *Decoder) decodeDictionary() (map[string]interface{}, error) {\n    // TODO 1: Read and verify 'd' prefix\n    // TODO 2: Create empty map for results\n    // TODO 3: Loop until next byte is 'e':\n    // TODO 4:   Call d.decodeString() for key (keys are always strings)\n    // TODO 5:   Call d.Decode() recursively for value\n    // TODO 6:   Store key-value pair in map\n    // TODO 7: Read and verify 'e' suffix\n    // TODO 8: Return completed map\n    // Hint: Convert key bytes to string: string(keyBytes)\n    return nil, errors.New(\"not implemented\")\n}\n```\n\n```go\n// internal/client/client.go - Main orchestration skeleton\npackage client\n\nimport (\n    \"context\"\n    \"sync\"\n)\n\n// Client coordinates all aspects of BitTorrent downloading\ntype Client struct {\n    metaInfo     *torrent.MetaInfo\n    trackerClient *tracker.Client\n    peers        map[string]*peer.Connection\n    pieceManager *piece.Manager\n    \n    // Synchronization\n    mu           sync.RWMutex\n    ctx          context.Context\n    cancel       context.CancelFunc\n}\n\n// NewClient creates a BitTorrent client for the given torrent\nfunc NewClient(metaInfo *torrent.MetaInfo) *Client {\n    ctx, cancel := context.WithCancel(context.Background())\n    return &Client{\n        metaInfo: metaInfo,\n        peers:    make(map[string]*peer.Connection),\n        ctx:      ctx,\n        cancel:   cancel,\n    }\n}\n\n// Download orchestrates the complete download process\nfunc (c *Client) Download(outputPath string) error {\n    // TODO 1: Initialize piece manager with metaInfo piece data\n    // TODO 2: Contact tracker to get initial peer list\n    // TODO 3: Connect to multiple peers concurrently (start with 3-5)\n    // TODO 4: Start download coordinator goroutine\n    // TODO 5: Periodically re-announce to tracker (every 30 minutes)\n    // TODO 6: Monitor for completion - all pieces downloaded and verified\n    // TODO 7: Write final file and transition to seeding mode\n    // TODO 8: Handle graceful shutdown on context cancellation\n    return errors.New(\"not implemented\")\n}\n```\n\n**E. Language-Specific Hints**\n\nGo-specific implementation tips for BitTorrent development:\n\n- **Byte Handling**: Use `[]byte` for all binary data (piece hashes, peer IDs). Never convert to string unless displaying to user.\n- **Network Timeouts**: Always set timeouts on network operations: `conn.SetDeadline(time.Now().Add(30*time.Second))`\n- **Binary Protocol**: Use `encoding/binary` for reading/writing network byte order: `binary.BigEndian.Uint32(bytes)`\n- **Concurrency**: Use `sync.RWMutex` for peer map access. Use channels to coordinate between goroutines.\n- **Error Handling**: Wrap errors with context: `fmt.Errorf(\"failed to parse piece %d: %w\", pieceIndex, err)`\n- **File I/O**: Use `os.OpenFile` with `O_CREATE|O_WRONLY` flags. Call `file.Sync()` after writing pieces.\n- **HTTP Client**: Reuse `http.Client` instance across tracker requests for connection pooling.\n\n**F. Milestone Checkpoints**\n\nAfter implementing each milestone, verify these behaviors:\n\n**Milestone 1 Checkpoint - Torrent Parsing**:\n```bash\ngo run cmd/bt-client/main.go parse testdata/sample.torrent\n# Expected output:\n# Announce URL: http://tracker.example.com:8080/announce\n# Info Hash: 1234567890abcdef1234567890abcdef12345678\n# File Name: example.txt\n# File Size: 1048576 bytes\n# Piece Length: 262144 bytes\n# Number of Pieces: 4\n```\n\n**Milestone 2 Checkpoint - Tracker Communication**:\n```bash\ngo run cmd/bt-client/main.go announce testdata/sample.torrent\n# Expected output:\n# Contacting tracker: http://tracker.example.com:8080/announce\n# Received 15 peers:\n#   192.168.1.100:6881\n#   10.0.0.5:51234\n#   [... more peers]\n# Interval: 1800 seconds\n# Complete: 5, Incomplete: 10\n```\n\n**Milestone 3 Checkpoint - Peer Protocol**:\n```bash\ngo run cmd/bt-client/main.go connect testdata/sample.torrent 192.168.1.100:6881\n# Expected output:\n# Connecting to peer 192.168.1.100:6881\n# Handshake successful: peer_id = abcdef1234567890abcdef1234567890abcdef12\n# Received bitfield: 11110000 (peer has first 4 pieces)\n# Peer unchoked us, ready to request pieces\n\n```\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** This section defines the scope for all milestones (1-4) by establishing clear boundaries for what our BitTorrent client will and will not implement.\n\nBuilding a complete BitTorrent client involves numerous complex features and protocols that have evolved over decades of peer-to-peer development. Without clear scope boundaries, it's easy to get overwhelmed by the sheer breadth of functionality that modern BitTorrent clients support. Think of this like planning a cross-country road trip: you need to decide upfront which cities you'll visit, which scenic routes you'll take, and which detours you'll skip, or you'll end up wandering aimlessly and never reach your destination.\n\nThis section establishes three critical categories of requirements: **functional goals** (the core features we must implement), **non-functional goals** (the quality attributes our system must exhibit), and **explicit non-goals** (features we deliberately choose not to implement). This scope definition serves as our north star throughout the implementation process, helping us make consistent decisions about complexity trade-offs and feature prioritization.\n\nThe goal-setting process for a BitTorrent client is particularly challenging because the protocol ecosystem includes dozens of optional extensions, performance optimizations, and compatibility quirks developed over 20+ years of evolution. A production BitTorrent client like qBittorrent or Transmission supports hundreds of features. Our learning-focused implementation needs to capture the essential complexity of BitTorrent without getting bogged down in edge cases that obscure the core concepts.\n\n### Functional Goals\n\nOur BitTorrent client will implement the four core pillars of BitTorrent functionality that enable complete participation in a peer-to-peer swarm. These represent the minimum viable feature set for a working BitTorrent client that can successfully download and share files with other peers in the ecosystem.\n\n> **Decision: Core BitTorrent Protocol Implementation**\n> - **Context**: BitTorrent encompasses many protocol extensions and optional features developed over two decades\n> - **Options Considered**: \n>   1. Implement only basic downloading without seeding\n>   2. Implement full BitTorrent v1 protocol with downloading and seeding\n>   3. Include modern extensions like DHT and magnet links\n> - **Decision**: Implement complete BitTorrent v1 protocol including seeding capability\n> - **Rationale**: Seeding is essential for understanding BitTorrent's reciprocity model and makes our client a good network citizen. BitTorrent v1 provides all core concepts without extension complexity.\n> - **Consequences**: More implementation complexity than download-only, but creates a complete learning experience and functional client\n\n| Functional Goal | Description | Key Components | Success Criteria |\n|-----------------|-------------|----------------|------------------|\n| **Torrent File Parsing** | Parse `.torrent` files to extract all metadata needed for downloading | Bencode decoder, metadata extractor, info hash calculator | Successfully parse real torrent files and extract announce URL, file info, piece hashes |\n| **Tracker Communication** | Communicate with HTTP trackers to discover peers | HTTP client, announce protocol, peer list parser | Receive valid peer lists from public trackers, handle tracker responses and errors |\n| **Peer Wire Protocol** | Implement complete peer-to-peer communication protocol | TCP connection manager, message parser, state machine | Successfully handshake with real BitTorrent clients, exchange messages, download blocks |\n| **File Download Management** | Coordinate downloading file pieces from multiple peers | Piece scheduler, download orchestrator, content verifier | Download complete files that match original content hash, handle peer disconnections |\n| **Content Verification** | Verify integrity of downloaded data using cryptographic hashes | SHA-1 hasher, piece validator, corruption detector | Reject corrupted pieces, re-request invalid data, ensure file integrity |\n| **Upload and Seeding** | Serve file pieces to other peers requesting them | Upload manager, request responder, bandwidth tracker | Successfully seed files to other clients, track upload statistics for tracker reporting |\n\n**Torrent File Parsing** forms the foundation of our client by extracting all metadata required for the download process. The Bencode decoder must handle the four Bencode data types (strings, integers, lists, dictionaries) with proper binary string support. The metadata extractor pulls critical information including the tracker announce URL, file specifications, and piece hash list. Most importantly, the info hash calculation must compute the SHA-1 digest from the exact bencoded bytes of the info dictionary, as this serves as the unique identifier for the torrent across the entire BitTorrent network.\n\n**Tracker Communication** implements the HTTP-based announce protocol that serves as BitTorrent's peer discovery mechanism. Our client must construct properly formatted announce requests with URL-encoded parameters including the info hash, peer ID, port number, and transfer statistics. The tracker responds with a list of peers in compact binary format (6 bytes per peer: 4 bytes IP + 2 bytes port) that we must parse into usable network addresses. The client must also implement the announce interval system, re-contacting the tracker periodically to report progress and discover new peers.\n\n**Peer Wire Protocol** represents the most complex functional requirement, implementing the standardized message-based protocol that BitTorrent peers use to coordinate file transfers. This includes the 68-byte handshake sequence that establishes connections, the length-prefixed message framing system, and the complete set of peer protocol messages (choke, unchoke, interested, have, bitfield, request, piece). The implementation must maintain per-peer state machines tracking choking and interest status, manage request pipelining for optimal throughput, and handle the intricate dance of peer coordination.\n\n**File Download Management** orchestrates the complex process of downloading file pieces from multiple peers simultaneously. This requires implementing piece selection algorithms (starting with random selection, evolving toward rarest-first for efficiency), managing concurrent downloads to avoid requesting the same piece multiple times, and coordinating the assembly of completed pieces into the final output file. The download manager must handle peer disconnections gracefully, redistributing incomplete piece requests to other available peers.\n\n**Content Verification** ensures the integrity of downloaded data by validating each piece against its expected SHA-1 hash from the torrent metadata. When a piece download completes, the client must compute the piece's hash and compare it against the corresponding 20-byte hash from the torrent's piece hash list. Corrupted or invalid pieces must be discarded and re-requested from different peers. This verification system is critical for security and prevents the propagation of corrupted data through the swarm.\n\n**Upload and Seeding** completes the reciprocal nature of BitTorrent by serving file pieces to other peers. When peers send request messages for specific pieces our client possesses, we must respond with the corresponding piece data. This requires tracking which pieces we have available, managing upload bandwidth fairly across requesting peers, and maintaining statistics on bytes uploaded for tracker reporting. Effective seeding behavior is essential for swarm health and BitTorrent's long-term sustainability.\n\n### Non-Functional Goals\n\nBeyond core functionality, our BitTorrent client must meet specific quality attributes that determine its effectiveness and usability in real-world scenarios. These non-functional requirements define how well the system performs its functional goals rather than what it does.\n\n> **Decision: Performance vs. Simplicity Balance**\n> - **Context**: BitTorrent clients can be optimized for extreme performance with complex algorithms, or kept simple for educational clarity\n> - **Options Considered**:\n>   1. Prioritize maximum performance with advanced optimizations\n>   2. Prioritize code clarity and educational value\n>   3. Balance reasonable performance with maintainable code\n> - **Decision**: Target reasonable performance with maintainable, well-documented code\n> - **Rationale**: Educational goals require readable code, but unusably slow performance would prevent real-world testing and learning\n> - **Consequences**: May not match production client performance, but provides solid foundation for learning and future optimization\n\n| Non-Functional Goal | Requirement | Measurement Criteria | Implementation Strategy |\n|---------------------|-------------|---------------------|------------------------|\n| **Download Performance** | Achieve reasonable download speeds comparable to other clients | Download 100MB+ files at 70%+ of available bandwidth | Implement request pipelining, concurrent peer connections, efficient piece selection |\n| **Memory Efficiency** | Handle large torrents without excessive memory usage | Support 1GB+ torrents with <100MB RAM usage | Stream piece data to disk, avoid loading entire files in memory |\n| **Connection Reliability** | Maintain stable connections with multiple peers | Successfully maintain 10+ concurrent peer connections | Implement proper TCP connection management, handle network interruptions |\n| **Error Recovery** | Gracefully handle common failure scenarios | Recover from tracker failures, peer disconnections, corrupted data | Comprehensive error handling, retry logic, fallback mechanisms |\n| **Resource Fairness** | Share upload bandwidth fairly among requesting peers | No single peer monopolizes upload capacity | Implement upload slot management, fair queuing for requests |\n| **Code Maintainability** | Produce readable, well-documented, testable code | All components have unit tests, clear module boundaries | Modular architecture, comprehensive documentation, test coverage |\n\n**Download Performance** ensures our client can achieve reasonable throughput when downloading files from healthy swarms. While we don't need to match the performance of highly optimized production clients like libtorrent, the client must download files fast enough to be practically useful. This requires implementing request pipelining (maintaining multiple outstanding block requests per peer), managing concurrent connections to multiple peers, and using effective piece selection strategies that minimize download time.\n\n**Memory Efficiency** becomes critical when handling large torrents with hundreds or thousands of pieces. Our client must avoid loading entire files into memory, instead streaming piece data directly to disk as it arrives. The piece management system should maintain metadata about piece availability and download progress without storing the actual piece content in RAM. This approach enables handling multi-gigabyte torrents on resource-constrained systems.\n\n**Connection Reliability** addresses the inherent instability of peer-to-peer networks where peers frequently join and leave the swarm. Our client must detect failed connections promptly, clean up resources from disconnected peers, and continuously discover new peers to replace lost connections. The connection management system should handle common network issues like timeouts, connection resets, and temporary network partitions without crashing or stalling downloads.\n\n**Error Recovery** encompasses the broad category of graceful degradation when things go wrong. Tracker servers may become unavailable, requiring fallback strategies or retry logic. Peers may send malformed messages that require defensive parsing. Downloaded pieces may fail hash verification and need re-downloading from different sources. The client must handle these scenarios without human intervention, automatically recovering and continuing the download process.\n\n**Resource Fairness** reflects BitTorrent's fundamental principle of reciprocity – peers that contribute upload bandwidth should receive better download performance. Our client must avoid selfish behavior that would harm swarm health, such as downloading without seeding or monopolizing other peers' upload capacity. This includes implementing reasonable limits on concurrent requests per peer and fairly distributing our upload capacity among requesting peers.\n\n**Code Maintainability** recognizes that this implementation serves educational purposes and may be extended or modified by learners. The codebase must prioritize clarity and comprehensibility over micro-optimizations. Each component should have well-defined responsibilities, clear interfaces, and comprehensive unit tests. Documentation should explain not just what the code does, but why specific design decisions were made.\n\n### Explicit Non-Goals\n\nDefining what we will NOT implement is equally important as defining what we will implement. These explicit non-goals help maintain project scope and prevent feature creep that could derail the core learning objectives. Modern BitTorrent clients implement dozens of protocol extensions and advanced features that, while valuable in production, would obscure the fundamental concepts we're trying to teach.\n\n> **Decision: Exclude Advanced BitTorrent Extensions**\n> - **Context**: Modern BitTorrent includes many protocol extensions (DHT, PEX, encryption, etc.) that provide additional functionality\n> - **Options Considered**:\n>   1. Implement all major extensions for feature completeness\n>   2. Implement basic extensions like DHT for modern compatibility\n>   3. Focus solely on core BitTorrent v1 protocol\n> - **Decision**: Exclude all protocol extensions and advanced features\n> - **Rationale**: Extensions add significant complexity without teaching new fundamental concepts. Core protocol provides complete learning experience.\n> - **Consequences**: Client won't support magnet links or trackerless operation, but remains focused on essential BitTorrent concepts\n\n| Explicit Non-Goal | Rationale | Complexity Impact | Alternative Approach |\n|-------------------|-----------|-------------------|---------------------|\n| **Distributed Hash Table (DHT)** | DHT is a complex distributed systems topic that deserves separate study | Would add 500+ lines of complex networking code | Use tracker-based torrents only |\n| **Magnet Link Support** | Requires DHT implementation for metadata download | Depends on DHT, adds metadata resolution complexity | Work with traditional `.torrent` files |\n| **Protocol Encryption** | Crypto implementation is error-prone and adds little educational value | SSL/TLS integration, key exchange protocols | Rely on network-level security if needed |\n| **Multi-Tracker Support** | Tracker failover logic adds complexity without new concepts | Redundant with single-tracker error handling | Use single primary tracker per torrent |\n| **Peer Exchange (PEX)** | Peer discovery optimization that doesn't change core concepts | Additional message types and peer management | Rely on tracker for peer discovery |\n| **Web Seeding (HTTP/FTP)** | Hybrid P2P/client-server model that complicates architecture | HTTP client integration, different download paths | Pure P2P downloading only |\n| **Selective File Download** | File filtering within multi-file torrents | Piece-to-file mapping complexity, partial completion | Download complete torrents only |\n| **Bandwidth Limiting** | QoS feature that doesn't impact core protocol understanding | Rate limiting algorithms, traffic shaping | Rely on OS-level bandwidth management |\n| **Advanced Piece Selection** | Sophisticated algorithms like endgame mode and smart seeding | Complex heuristics and optimization logic | Use simple rarest-first selection |\n| **Resume/Persistence** | Saving and restoring partial download state | Serialization, state management, crash recovery | Restart downloads from beginning |\n\n**Distributed Hash Table (DHT)** represents a completely separate distributed systems concept that enables trackerless operation. While DHT is fascinating technology, implementing it properly requires understanding distributed consensus, network partitions, routing table maintenance, and peer bootstrapping – topics that could fill their own comprehensive tutorial. Including DHT would double the project's complexity while teaching concepts orthogonal to BitTorrent's core file-sharing mechanisms.\n\n**Magnet Link Support** depends heavily on DHT for metadata resolution, since magnet links contain only the info hash rather than complete torrent metadata. Without DHT, magnet links become unusable, making this feature dependent on our DHT non-goal. Traditional `.torrent` files provide all necessary metadata upfront, eliminating the need for complex metadata discovery protocols.\n\n**Protocol Encryption** adds cryptographic complexity that doesn't enhance understanding of BitTorrent's core concepts. Implementing encryption properly requires deep knowledge of cryptographic protocols, key exchange mechanisms, and security best practices – specialized knowledge that's orthogonal to peer-to-peer file sharing concepts. Network-level security (VPN, HTTPS) can provide encryption when needed without complicating the BitTorrent implementation.\n\n**Multi-Tracker Support** allows torrents to specify backup trackers for redundancy, but the failover logic and tracker prioritization algorithms don't teach new concepts beyond single-tracker communication. The error handling patterns for tracker failures apply equally whether dealing with one tracker or ten. Supporting multi-tracker scenarios would add configuration complexity and edge cases without educational benefit.\n\n**Peer Exchange (PEX)** enables peers to share information about other peers in the swarm, providing an additional peer discovery mechanism beyond tracker announcements. While PEX improves swarm connectivity and reduces tracker load, it's essentially an optimization that doesn't change the fundamental peer-to-peer download process. Tracker-based peer discovery provides sufficient peer connectivity for learning purposes.\n\n**Web Seeding** allows torrents to include HTTP or FTP servers as additional download sources, creating a hybrid P2P/client-server architecture. This feature requires implementing HTTP range requests, integrating with existing piece management systems, and handling the different reliability characteristics of web servers versus P2P peers. The added complexity doesn't reinforce core BitTorrent concepts and introduces architectural complications.\n\n**Selective File Download** enables users to choose specific files from multi-file torrents, downloading only desired content. This requires complex piece-to-file mapping logic, partial torrent completion tracking, and modified seeding behavior for incomplete torrents. While useful in practice, selective downloading obscures the fundamental concept of torrents as atomic units of content sharing.\n\n**Bandwidth Limiting** provides quality-of-service features that help users manage network resource consumption. However, implementing effective bandwidth limiting requires understanding rate limiting algorithms, traffic shaping, and network scheduling – topics that don't reinforce BitTorrent protocol concepts. Operating system tools and network-level QoS provide better bandwidth management without complicating the BitTorrent implementation.\n\n**Advanced Piece Selection** algorithms like endgame mode (requesting final pieces from all peers) and smart seeding (prioritizing rare pieces when seeding) can significantly improve download performance and swarm health. However, these optimizations involve complex heuristics and game-theoretic considerations that obscure the basic piece selection concept. Simple rarest-first selection provides adequate performance while remaining easy to understand and implement.\n\n**Resume/Persistence** enables users to stop and restart downloads without losing progress, requiring serialization of download state, piece completion tracking, and crash recovery logic. While extremely valuable for user experience, persistence adds significant implementation complexity around state management and error recovery that doesn't teach new BitTorrent protocol concepts. Starting downloads from scratch simplifies implementation and testing.\n\n> The key insight behind these non-goals is that BitTorrent's core concepts – bencoding, tracker communication, peer protocol, and piece management – provide a complete and challenging learning experience. Advanced features, while valuable in production systems, often optimize or extend these core concepts without introducing fundamentally new ideas. By maintaining strict scope boundaries, we ensure learners master the essential concepts before exploring the rich ecosystem of BitTorrent extensions.\n\n### Implementation Guidance\n\nThis section provides concrete technology recommendations and architectural guidance for implementing our scoped BitTorrent client in Go.\n\n#### A. Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **HTTP Client** | `net/http` with default client | `net/http` with custom transport and timeouts |\n| **TCP Networking** | `net.Conn` with basic I/O | `net.Conn` with connection pooling and buffering |\n| **Concurrency** | Goroutines with channels | Worker pools with `sync.WaitGroup` coordination |\n| **File I/O** | `os.File` with synchronous writes | `os.File` with buffered writes and fsync |\n| **Hashing** | `crypto/sha1` standard library | `crypto/sha1` with pre-allocated buffers |\n| **Bencode** | Custom recursive parser | Third-party library (not recommended for learning) |\n| **Logging** | `log` standard library | Structured logging with `slog` (Go 1.21+) |\n| **Testing** | `testing` with table-driven tests | `testing` with property-based testing |\n| **Configuration** | Hard-coded constants | `flag` package for command-line options |\n\nThe simple options provide everything needed for a functional BitTorrent client while keeping dependencies minimal and code transparent. Advanced options offer better performance and production-readiness but add complexity that may distract from core learning objectives.\n\n#### B. Recommended File/Module Structure\n\n```\nbittorrent-client/\n├── cmd/\n│   └── bittorrent/\n│       └── main.go                 ← CLI entry point\n├── internal/\n│   ├── bencode/\n│   │   ├── decoder.go              ← Bencode parsing logic\n│   │   └── decoder_test.go\n│   ├── torrent/\n│   │   ├── metainfo.go            ← Torrent file structures and parsing\n│   │   └── metainfo_test.go\n│   ├── tracker/\n│   │   ├── client.go              ← HTTP tracker communication\n│   │   ├── announce.go            ← Announce request/response handling\n│   │   └── client_test.go\n│   ├── peer/\n│   │   ├── connection.go          ← Individual peer connection management\n│   │   ├── protocol.go            ← Wire protocol message handling\n│   │   ├── handshake.go          ← Connection handshake logic\n│   │   └── connection_test.go\n│   ├── piece/\n│   │   ├── manager.go             ← Piece download coordination\n│   │   ├── scheduler.go           ← Piece selection algorithms\n│   │   ├── verifier.go           ← Content hash verification\n│   │   └── manager_test.go\n│   └── client/\n│       ├── client.go              ← Main BitTorrent client orchestration\n│       └── client_test.go\n├── pkg/\n│   └── bittorrent/\n│       └── types.go               ← Public API types and constants\n├── testdata/\n│   ├── sample.torrent            ← Test torrent files\n│   └── sample_content/           ← Expected file content for tests\n├── go.mod\n├── go.sum\n└── README.md\n```\n\nThis structure separates concerns cleanly: `cmd/` contains the executable entry point, `internal/` contains implementation packages that map to our architectural components, `pkg/` exposes public APIs for potential library use, and `testdata/` provides test fixtures. Each component gets its own package with focused responsibilities and comprehensive tests.\n\n#### C. Infrastructure Starter Code\n\n**File: `internal/bencode/decoder.go`**\n```go\npackage bencode\n\nimport (\n    \"bufio\"\n    \"errors\"\n    \"fmt\"\n    \"io\"\n    \"strconv\"\n)\n\n// Common bencode parsing errors\nvar (\n    ErrUnexpectedEOF    = errors.New(\"unexpected end of input\")\n    ErrInvalidFormat    = errors.New(\"invalid bencode format\")\n    ErrInvalidInteger   = errors.New(\"invalid integer format\")\n    ErrInvalidString    = errors.New(\"invalid string format\")\n)\n\n// Decoder handles bencode parsing from an input stream\ntype Decoder struct {\n    reader *bufio.Reader\n}\n\n// NewDecoder creates a new bencode decoder for the given reader\nfunc NewDecoder(r io.Reader) *Decoder {\n    return &Decoder{\n        reader: bufio.NewReader(r),\n    }\n}\n\n// peekByte returns the next byte without consuming it\nfunc (d *Decoder) peekByte() (byte, error) {\n    bytes, err := d.reader.Peek(1)\n    if err != nil {\n        return 0, err\n    }\n    return bytes[0], nil\n}\n\n// readByte consumes and returns the next byte\nfunc (d *Decoder) readByte() (byte, error) {\n    return d.reader.ReadByte()\n}\n\n// readUntil reads bytes until the specified delimiter\nfunc (d *Decoder) readUntil(delim byte) ([]byte, error) {\n    return d.reader.ReadSlice(delim)\n}\n\n// Decode parses the next bencode value from the input stream\nfunc (d *Decoder) Decode() (interface{}, error) {\n    // TODO: Implement main decode dispatch based on first byte\n    // Hint: Look at first character to determine type:\n    // '0'-'9': string (length prefix)\n    // 'i': integer\n    // 'l': list  \n    // 'd': dictionary\n    return nil, fmt.Errorf(\"decode not implemented\")\n}\n```\n\n**File: `pkg/bittorrent/types.go`**\n```go\npackage bittorrent\n\nimport \"time\"\n\n// Standard BitTorrent constants\nconst (\n    PIECE_HASH_SIZE    = 20  // SHA-1 produces 20-byte hashes\n    COMPACT_PEER_SIZE  = 6   // 4 bytes IP + 2 bytes port\n    BLOCK_SIZE         = 16384 // Standard 16KB block size\n    MAX_PEERS          = 50  // Reasonable concurrent connection limit\n)\n\n// MetaInfo represents the complete parsed torrent file\ntype MetaInfo struct {\n    Announce     string    // Primary tracker announce URL\n    CreationDate time.Time // When torrent was created\n    Comment      string    // Optional comment\n    InfoHash     [20]byte  // SHA-1 hash of info dictionary\n    Info         Info      // File and piece information\n}\n\n// Info contains the core file and piece information from torrent\ntype Info struct {\n    Name        string  // Suggested filename or directory name\n    Length      int64   // Total file size (single-file torrents only)\n    PieceLength int64   // Size of each piece except possibly the last\n    Pieces      []byte  // Concatenated SHA-1 hashes of all pieces\n    Files       []File  // File list (multi-file torrents only)\n}\n\n// File represents a single file in a multi-file torrent\ntype File struct {\n    Length int64    // File size in bytes\n    Path   []string // Path components for file location\n}\n\n// GetPieceHashes splits the concatenated piece hashes into individual hashes\nfunc (i *Info) GetPieceHashes() [][20]byte {\n    numPieces := len(i.Pieces) / PIECE_HASH_SIZE\n    hashes := make([][20]byte, numPieces)\n    \n    for i := 0; i < numPieces; i++ {\n        copy(hashes[i][:], i.Pieces[i*PIECE_HASH_SIZE:(i+1)*PIECE_HASH_SIZE])\n    }\n    \n    return hashes\n}\n\n// PeerInfo represents a peer's network address\ntype PeerInfo struct {\n    IP   [4]byte // IPv4 address\n    Port uint16  // TCP port number\n}\n\n// String formats peer info as \"IP:port\"\nfunc (p PeerInfo) String() string {\n    return fmt.Sprintf(\"%d.%d.%d.%d:%d\", p.IP[0], p.IP[1], p.IP[2], p.IP[3], p.Port)\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**File: `internal/torrent/metainfo.go`**\n```go\npackage torrent\n\nimport (\n    \"crypto/sha1\"\n    \"fmt\"\n    \"time\"\n    \n    \"your-project/internal/bencode\"\n    \"your-project/pkg/bittorrent\"\n)\n\n// ParseFromFile reads and parses a torrent file from disk\nfunc ParseFromFile(filepath string) (*bittorrent.MetaInfo, error) {\n    // TODO 1: Open the torrent file for reading\n    // TODO 2: Create bencode decoder for the file\n    // TODO 3: Decode the root dictionary\n    // TODO 4: Extract announce URL from root dict\n    // TODO 5: Extract info dictionary from root dict  \n    // TODO 6: Calculate info hash from bencoded info dict bytes\n    // TODO 7: Parse info dictionary into Info struct\n    // TODO 8: Return populated MetaInfo struct\n    // Hint: Use CalculateInfoHash() helper function\n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// CalculateInfoHash computes SHA-1 hash of bencoded info dictionary\nfunc CalculateInfoHash(bencoded []byte) [20]byte {\n    // TODO 1: Create SHA-1 hasher\n    // TODO 2: Write bencoded bytes to hasher\n    // TODO 3: Get final hash sum as [20]byte array\n    // TODO 4: Return the hash\n    // Hint: Use crypto/sha1 package\n    return [20]byte{}\n}\n\n// parseInfo converts bencode dictionary to Info struct\nfunc parseInfo(infoDict map[string]interface{}) (bittorrent.Info, error) {\n    // TODO 1: Extract \"name\" field as string\n    // TODO 2: Extract \"piece length\" field as int64\n    // TODO 3: Extract \"pieces\" field as byte slice\n    // TODO 4: Check if single-file torrent (has \"length\" field)\n    // TODO 5: If single-file, extract \"length\" field\n    // TODO 6: If multi-file, extract \"files\" list and parse each file\n    // TODO 7: Validate piece length and pieces alignment\n    // TODO 8: Return populated Info struct\n    // Hint: Handle both single-file and multi-file torrent formats\n    return bittorrent.Info{}, fmt.Errorf(\"not implemented\")\n}\n```\n\n#### E. Language-Specific Hints\n\n**Go-Specific Implementation Tips:**\n\n- **Bencode Parsing**: Use `bufio.Reader` for efficient byte-by-byte parsing. The `ReadSlice()` method is particularly useful for reading until delimiters.\n\n- **Binary Data Handling**: Bencode strings are binary data, not UTF-8 text. Always work with `[]byte` slices and avoid string conversion unless specifically needed for text fields.\n\n- **Error Handling**: Create specific error types for different parsing failures. Use `errors.New()` for constant errors and `fmt.Errorf()` for contextual errors.\n\n- **HTTP Requests**: Use `http.Get()` for simple tracker requests. For production code, create custom `http.Client` with timeouts: `&http.Client{Timeout: 30 * time.Second}`.\n\n- **Concurrency**: Use goroutines for peer connections and channels for coordination. Pattern: `go handlePeer(conn, pieceManager)` for each peer connection.\n\n- **File I/O**: Use `os.OpenFile()` with `O_CREATE|O_WRONLY` flags for output files. Call `file.Sync()` after writing each piece to ensure data persistence.\n\n- **Network Byte Order**: BitTorrent uses big-endian byte order. Use `binary.BigEndian.Uint32()` and `binary.BigEndian.PutUint32()` for multi-byte integers.\n\n- **Testing**: Create test torrents using existing BitTorrent clients. Keep small test files (< 1MB) for fast test execution.\n\n#### F. Milestone Checkpoints\n\n**After Milestone 1 (Torrent Parsing):**\n```bash\n# Test command\ngo test ./internal/bencode/... ./internal/torrent/...\n\n# Expected behavior\n# All tests pass\n# Can parse real .torrent files \n# Info hash matches other BitTorrent clients\n```\n\n**Verification Steps:**\n1. Download a small torrent file from a legal source (Linux distributions work well)\n2. Parse it with your implementation and extract the info hash\n3. Verify the info hash matches what other BitTorrent clients show\n4. Check that announce URL and file information are correctly extracted\n\n**After Milestone 2 (Tracker Communication):**\n```bash\n# Test with actual tracker\ngo run cmd/bittorrent/main.go announce sample.torrent\n\n# Expected output\n# Found X peers from tracker\n# Peer list: [IP:port IP:port ...]\n# No network errors or parsing failures\n```\n\n**After Milestone 3 (Peer Protocol):**\n```bash\n# Test peer connections\ngo run cmd/bittorrent/main.go connect sample.torrent\n\n# Expected behavior  \n# Successfully handshake with multiple peers\n# Receive bitfield and piece messages\n# No protocol violations or connection errors\n```\n\n**After Milestone 4 (Complete Download):**\n```bash\n# Full download test\ngo run cmd/bittorrent/main.go download sample.torrent output.file\n\n# Expected behavior\n# Download completes successfully\n# Output file matches original content\n# Can seed file to other clients\n```\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **\"Invalid info hash\"** | Wrong bytes used for SHA-1 calculation | Compare raw info dict bytes with working client | Use exact bencoded bytes, not re-encoded |\n| **\"Tracker returns error\"** | Malformed announce request | Check URL encoding of info hash and peer ID | Properly URL-encode binary data |\n| **\"Peers reject handshake\"** | Wrong protocol string or info hash | Log handshake bytes, compare with specification | Use exact 19-byte protocol string |\n| **\"Download stalls\"** | Not sending interested/request messages | Log peer message exchange | Send interested after bitfield, request after unchoke |\n| **\"Piece verification fails\"** | Wrong piece boundaries or corruption | Compare piece hashes with torrent metadata | Check piece length calculation and SHA-1 implementation |\n| **\"Connection timeouts\"** | Network issues or wrong peer addresses | Test peer connectivity with telnet/nc | Implement connection timeouts and retry logic |\n\n**Common Implementation Mistakes:**\n\n⚠️ **Pitfall: Re-encoding Info Dictionary**\nMany learners calculate the info hash by parsing the info dictionary and then re-encoding it with their own bencode encoder. This fails because bencode allows multiple valid encodings of the same data (different key ordering, etc.). The info hash MUST be calculated from the exact original bytes.\n\n⚠️ **Pitfall: String vs Binary Confusion**\nBencode \"strings\" are actually binary data. Converting them to Go strings can corrupt binary data like piece hashes or compact peer lists. Always work with `[]byte` slices until you specifically need text representation.\n\n⚠️ **Pitfall: Blocking on Choked Peers**\nNew implementations often send piece requests immediately after handshake, but peers start in the \"choked\" state. You must wait for an \"unchoke\" message before sending requests, or the peer will ignore your requests and potentially disconnect.\n\nThis comprehensive scope definition and implementation guidance provides the foundation for building a complete BitTorrent client while maintaining focus on the essential concepts that make BitTorrent work.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** This section establishes the architectural foundation for all milestones (1-4) by defining the core components and their interactions that will be built incrementally throughout the project.\n\nBuilding a BitTorrent client is like orchestrating a complex distributed system where multiple specialized components must work together seamlessly. Think of it as organizing a massive library project where you need a **cataloger** to understand what books you're looking for (torrent parsing), a **directory service** to find libraries that have those books (tracker communication), a **librarian network** to manage relationships with other libraries (peer management), and a **book assembly team** to piece together chapters from different sources while verifying they're authentic (piece management).\n\nThe architecture follows a clear separation of concerns, where each component has a well-defined responsibility and communicates with others through clean interfaces. This modular design allows us to implement and test each component independently while maintaining the ability to coordinate complex multi-peer downloads. The key architectural insight is that BitTorrent's complexity lies not in any single protocol, but in the careful coordination between multiple concurrent processes that must share state and make decisions based on constantly changing network conditions.\n\n![BitTorrent Client Architecture](./diagrams/system-architecture.svg)\n\n### Component Responsibilities\n\nThe BitTorrent client architecture consists of four major components, each with distinct responsibilities and well-defined interfaces. Understanding these boundaries is crucial because BitTorrent's distributed nature means that each component must handle its own failures gracefully while contributing to the overall system's resilience.\n\n| Component | Primary Responsibility | Key Interfaces | External Dependencies | State Managed |\n|-----------|----------------------|----------------|---------------------|---------------|\n| **TorrentParser** | Decode `.torrent` files and extract metadata required for download coordination | `ParseFromFile(filepath) (*MetaInfo, error)`, `GetPieceHashes() [][20]byte`, `CalculateInfoHash([]byte) [20]byte` | File system for reading torrent files | Parsed torrent metadata, info hash, piece information |\n| **TrackerClient** | Communicate with tracker servers to discover peers and report download progress | `Announce(*AnnounceRequest) (*AnnounceResponse, error)`, `BuildAnnounceURL(announceURL) string`, `ParseCompactPeers([]byte) []PeerInfo` | HTTP client for tracker communication | Peer list, announce intervals, upload/download statistics |\n| **PeerManager** | Manage connections to multiple peers and implement the BitTorrent wire protocol | `ConnectToPeer(PeerInfo) (*Connection, error)`, `SendHandshake(*Connection) error`, `ReceiveMessage(*Connection) (Message, error)` | TCP networking, peer connections | Connection states, message queues, peer capabilities |\n| **PieceManager** | Coordinate piece downloads, verify content integrity, and schedule requests across peers | `RequestPiece(pieceIndex int) error`, `VerifyPiece(pieceIndex int, data []byte) bool`, `GetNextPiece() (int, error)`, `AssembleFile(outputPath string) error` | File system for writing completed pieces | Piece availability, download progress, verification status |\n\nThe **TorrentParser** serves as the system's entry point, transforming human-readable torrent files into the structured metadata that drives all subsequent operations. Its most critical responsibility is computing the **info hash** correctly, as this 20-byte identifier serves as the unique key that connects all other components. The parser must handle the intricacies of Bencode format while maintaining exact byte-for-byte fidelity when calculating the SHA-1 hash of the info dictionary.\n\nThe **TrackerClient** acts as the system's directory service, maintaining the bridge between our client and the centralized coordination provided by tracker servers. It translates our internal state into the HTTP-based tracker protocol and decodes the compact peer format that trackers use to efficiently transmit lists of available peers. This component must handle tracker failures gracefully and implement proper re-announce scheduling to maintain our presence in the swarm.\n\n> **Key Architectural Insight:** The separation between TrackerClient and PeerManager reflects BitTorrent's hybrid design—centralized peer discovery with decentralized data transfer. This separation allows us to implement different tracker types (HTTP, UDP) without affecting peer communication logic.\n\nThe **PeerManager** implements the complex state machines required by the BitTorrent wire protocol. Each peer connection maintains independent state for choking, interest, and message queues, but the PeerManager coordinates these connections to maximize overall throughput. It must handle connection failures, implement proper handshaking, and manage the flow control mechanisms that prevent any single peer from overwhelming the client.\n\nThe **PieceManager** orchestrates the actual file reconstruction process, making decisions about which pieces to request from which peers based on availability and rarity. This component embodies the BitTorrent protocol's clever incentive mechanisms—by preferring rare pieces, it ensures that the entire swarm maintains good piece distribution. The PieceManager also handles the critical content verification step, rejecting corrupted data and coordinating retries when hash verification fails.\n\n### Recommended Module Structure\n\nThe Go implementation benefits from a clean module structure that mirrors the architectural boundaries while providing clear import paths and testability. The structure follows Go conventions for internal packages while maintaining the flexibility to expose public APIs as the client evolves.\n\n```\nbittorrent-client/\n├── cmd/\n│   └── bittorrent/\n│       └── main.go                    ← CLI entry point, orchestrates all components\n├── internal/\n│   ├── torrent/\n│   │   ├── parser.go                  ← MetaInfo struct, ParseFromFile implementation\n│   │   ├── bencode.go                 ← Bencode decoder with all four type handlers\n│   │   ├── metadata.go                ← Info, File structs and hash calculations  \n│   │   └── parser_test.go             ← Unit tests for parsing logic\n│   ├── tracker/\n│   │   ├── client.go                  ← TrackerClient struct, HTTP announce logic\n│   │   ├── protocol.go                ← AnnounceRequest/Response structs\n│   │   ├── peers.go                   ← Compact peer parsing, PeerInfo struct\n│   │   └── client_test.go             ← Mock tracker tests\n│   ├── peer/\n│   │   ├── manager.go                 ← PeerManager coordination logic\n│   │   ├── connection.go              ← Individual peer connection state machine\n│   │   ├── protocol.go                ← Wire protocol message structs\n│   │   ├── handshake.go               ← Handshake implementation\n│   │   └── manager_test.go            ← Peer protocol tests\n│   ├── piece/\n│   │   ├── manager.go                 ← PieceManager with selection algorithms\n│   │   ├── scheduler.go               ← Rarest-first and endgame logic\n│   │   ├── verifier.go                ← SHA-1 verification and retry logic\n│   │   ├── assembler.go               ← File reconstruction from pieces\n│   │   └── manager_test.go            ← Piece management tests\n│   └── client/\n│       ├── client.go                  ← Main Client struct coordinating all components\n│       ├── download.go                ← Download orchestration logic\n│       └── client_test.go             ← Integration tests\n├── pkg/                               ← Public APIs (if building a library)\n│   └── bittorrent/\n│       └── client.go                  ← Public client interface\n├── testdata/                          ← Sample torrent files for testing\n│   ├── sample.torrent\n│   └── multi-file.torrent\n├── go.mod                             ← Go module definition\n└── README.md                          ← Usage instructions and examples\n```\n\n> **Decision: Internal Package Structure**\n> - **Context**: Go's `internal/` package convention prevents external imports while allowing clean separation of concerns\n> - **Options Considered**: \n>   1. Flat structure with all components in root package\n>   2. Public packages exposing all internals\n>   3. Internal packages with selective public API exposure\n> - **Decision**: Use `internal/` packages with a small public API surface\n> - **Rationale**: This approach provides implementation flexibility while preventing external code from depending on internal details that may change as we optimize the BitTorrent implementation\n> - **Consequences**: Forces us to design clean interfaces between components and makes testing more systematic, but requires more careful API design for any public library usage\n\nThe **cmd/bittorrent/** directory contains the command-line interface that demonstrates how all components work together. This separation allows the core BitTorrent logic to be testable independently of CLI argument parsing and user interaction. The main.go file serves as the integration point where we instantiate all components and coordinate their interactions.\n\nEach **internal/** package corresponds directly to one of our architectural components, with clear responsibility boundaries. The separation between `connection.go` and `manager.go` in the peer package reflects the difference between managing individual peer state machines versus coordinating across multiple peers. Similarly, the piece package separates the scheduling algorithms (`scheduler.go`) from the verification logic (`verifier.go`) because these concerns have different testing requirements and failure modes.\n\nThe **testdata/** directory provides sample torrent files that enable integration testing without requiring network access. These files should include various scenarios: single-file torrents, multi-file torrents, and edge cases like very small piece sizes or unusual announce URLs.\n\n### High-Level Data Flow\n\nUnderstanding how data flows through the BitTorrent client helps clarify the relationships between components and identifies the critical paths where errors can propagate. The data flow follows a clear pipeline from static torrent metadata through dynamic network coordination to final file reconstruction.\n\nThe complete data flow can be visualized as four distinct phases, each dominated by a different component but requiring coordination with others:\n\n**Phase 1: Metadata Extraction** - The TorrentParser reads the `.torrent` file from disk and transforms it through several representations. Raw bytes become Bencode tokens, which become structured dictionaries, which finally become strongly-typed `MetaInfo` and `Info` structs. The critical output is the info hash, computed from the exact bencoded bytes of the info dictionary, which becomes the unique identifier used by all subsequent phases.\n\n| Data Transform | Input Format | Output Format | Key Operations | Error Conditions |\n|----------------|--------------|---------------|----------------|------------------|\n| File → Bencode | Raw bytes from disk | Bencode token stream | `NewDecoder()`, `Decode()` | File not found, invalid Bencode syntax |\n| Bencode → Structs | Decoded dictionaries/lists | `MetaInfo`, `Info` structs | Field extraction, type conversion | Missing required fields, wrong types |\n| Info → Hash | Bencoded info dictionary | 20-byte SHA-1 hash | `CalculateInfoHash()` | None (SHA-1 is deterministic) |\n| Pieces → Hashes | Concatenated piece hashes | Array of `[20]byte` | `GetPieceHashes()` | Invalid piece string length |\n\n**Phase 2: Peer Discovery** - The TrackerClient uses the info hash and file metadata to construct announce requests that discover other clients in the swarm. The tracker responds with a compact list of peer IP addresses and ports, along with timing information that controls how frequently we should re-announce our presence. This phase transforms our isolated client into a participant in the distributed swarm.\n\n| Data Transform | Input Format | Output Format | Key Operations | Coordination Required |\n|----------------|--------------|---------------|----------------|----------------------|\n| MetaInfo → Request | Torrent metadata | HTTP GET URL | `BuildAnnounceURL()` | None (pure transformation) |\n| Request → Response | HTTP request | Bencode response | HTTP client, response parsing | Network I/O, tracker availability |\n| Response → Peers | Compact peer data | `[]PeerInfo` structs | `ParseCompactPeers()` | None (parsing is deterministic) |\n| Progress → Stats | Download state | Updated request params | Progress tracking | Coordination with PieceManager |\n\n**Phase 3: Connection Establishment** - The PeerManager takes the list of potential peers and establishes BitTorrent protocol connections with a subset of them. Each connection involves a handshake exchange that verifies both clients are working with the same torrent (via info hash comparison) and establishes the message framing that will be used for all subsequent communication. This phase transforms network addresses into active protocol connections.\n\nThe peer connection process requires careful coordination between components because the PeerManager needs piece availability information from the PieceManager to make intelligent connection decisions, while the PieceManager needs peer capabilities from the PeerManager to schedule downloads effectively.\n\n| Connection Phase | Data Input | Data Output | Component Interaction | Failure Handling |\n|------------------|------------|-------------|----------------------|------------------|\n| TCP Connect | IP address, port | TCP socket | Network layer only | Retry with exponential backoff |\n| Handshake | Info hash, peer ID | Verified connection | Verify info hash matches | Close connection on mismatch |\n| Bitfield Exchange | Local piece state | Peer piece availability | Share with PieceManager | Assume peer has no pieces |\n| Message Loop | Protocol messages | Updated peer state | Continuous PeerManager coordination | Connection cleanup and retry |\n\n**Phase 4: Content Transfer** - The PieceManager coordinates the actual download process by deciding which pieces to request from which peers, verifying the integrity of downloaded data, and assembling verified pieces into the final file. This phase involves complex scheduling decisions that balance piece rarity, peer performance, and download completion objectives.\n\nThe content transfer phase represents the most complex data flow because it involves continuous bidirectional communication between all components. The PieceManager must track piece availability across all connected peers, make scheduling decisions that optimize for swarm health, and coordinate with the PeerManager to send block requests to appropriate connections.\n\n> **Critical Data Flow Insight:** The info hash serves as the system's primary key, flowing from TorrentParser through TrackerClient to PeerManager as the identifier that ensures all components are coordinating around the same file. Any corruption of this 20-byte value will cause complete system failure.\n\n**Inter-Phase Coordination Points:**\n\n1. **Parser → Tracker**: `MetaInfo` structure provides announce URL, info hash, and file size needed for tracker communication\n2. **Tracker → Peer**: `[]PeerInfo` list drives connection establishment, but PeerManager may connect to subset based on configured limits\n3. **Peer → Piece**: Bitfield messages from successful handshakes inform piece availability, enabling intelligent scheduling decisions\n4. **Piece → Tracker**: Download progress (bytes downloaded, uploaded, remaining) flows back to tracker for announce updates\n5. **Piece → Peer**: Block requests and piece completion notifications create continuous bidirectional communication\n\nThe data flow design ensures that each component can operate with appropriate autonomy while maintaining the coordination necessary for efficient downloads. Error conditions in any phase can be isolated and handled without bringing down the entire system, though certain failures (like tracker unavailability) may significantly impact performance.\n\n> **Decision: Unidirectional Data Flow with Coordination Channels**\n> - **Context**: BitTorrent requires complex coordination between components that operate at different time scales (parsing is one-time, tracker announces are periodic, peer connections are persistent, piece transfers are continuous)\n> - **Options Considered**:\n>   1. Shared mutable state with locks for coordination\n>   2. Message-passing architecture with channels\n>   3. Unidirectional flow with explicit coordination points\n> - **Decision**: Unidirectional primary data flow with well-defined coordination interfaces\n> - **Rationale**: This provides the predictability of functional programming (data flows one direction) while accommodating the necessary coordination through clean interfaces rather than shared mutable state\n> - **Consequences**: Each component can be tested independently, but we must carefully design the coordination interfaces to avoid deadlocks or race conditions\n\n### Implementation Guidance\n\nBuilding the high-level architecture requires careful attention to Go-specific patterns and project organization. The following guidance provides the infrastructure and project structure needed to implement the component-based design effectively.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option | Recommended for Learning |\n|-----------|---------------|-----------------|-------------------------|\n| HTTP Client | `net/http` standard library | Custom HTTP client with connection pooling | `net/http` (focus on BitTorrent, not HTTP optimization) |\n| Concurrency | `sync.Mutex` + goroutines | `sync.RWMutex` + worker pools | Start with `sync.Mutex`, add `RWMutex` for piece availability |\n| Networking | `net.Conn` with manual framing | `bufio.Reader/Writer` wrappers | `bufio` for message parsing (handles partial reads) |\n| Logging | `log` standard library | Structured logging (logrus/zap) | `log` initially, upgrade to structured when debugging |\n| Testing | `testing` standard library | `testify` for assertions | `testing` (learn Go idioms first) |\n\n**Complete Infrastructure Code:**\n\n```go\n// internal/client/client.go - Main coordination structure\npackage client\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n\n    \"bittorrent-client/internal/torrent\"\n    \"bittorrent-client/internal/tracker\"\n    \"bittorrent-client/internal/peer\"\n    \"bittorrent-client/internal/piece\"\n)\n\n// Client coordinates all BitTorrent operations for a single torrent download\ntype Client struct {\n    metaInfo        *torrent.MetaInfo\n    trackerClient   *tracker.Client\n    peerManager     *peer.Manager\n    pieceManager    *piece.Manager\n    \n    // Coordination channels\n    peerUpdates     chan []tracker.PeerInfo\n    progressUpdates chan piece.ProgressUpdate\n    \n    // Synchronization\n    mu              sync.RWMutex\n    ctx             context.Context\n    cancel          context.CancelFunc\n}\n\n// NewClient creates a BitTorrent client for the given torrent\nfunc NewClient(metaInfo *torrent.MetaInfo) *Client {\n    ctx, cancel := context.WithCancel(context.Background())\n    \n    client := &Client{\n        metaInfo:        metaInfo,\n        trackerClient:   tracker.NewClient(metaInfo.Announce, metaInfo.InfoHash),\n        peerManager:     peer.NewManager(metaInfo.InfoHash),\n        pieceManager:    piece.NewManager(metaInfo.Info),\n        peerUpdates:     make(chan []tracker.PeerInfo, 10),\n        progressUpdates: make(chan piece.ProgressUpdate, 100),\n        ctx:             ctx,\n        cancel:          cancel,\n    }\n    \n    return client\n}\n\n// Download orchestrates the complete download process\nfunc (c *Client) Download(outputPath string) error {\n    // TODO 1: Start tracker announce loop in separate goroutine\n    // TODO 2: Start peer connection management in separate goroutine  \n    // TODO 3: Start piece download coordination in separate goroutine\n    // TODO 4: Wait for download completion or context cancellation\n    // TODO 5: Clean up all goroutines and connections\n    panic(\"implement me\")\n}\n\n// Close stops all operations and cleans up resources\nfunc (c *Client) Close() error {\n    c.cancel()\n    // TODO: Close all connections and wait for goroutines to finish\n    return nil\n}\n```\n\n```go\n// internal/client/coordination.go - Inter-component coordination helpers\npackage client\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n\n    \"bittorrent-client/internal/tracker\"\n    \"bittorrent-client/internal/piece\"\n)\n\n// startTrackerAnnounces manages periodic communication with tracker\nfunc (c *Client) startTrackerAnnounces() {\n    // Initial announce to get peer list\n    go func() {\n        ticker := time.NewTicker(30 * time.Second) // Default interval\n        defer ticker.Stop()\n        \n        for {\n            select {\n            case <-c.ctx.Done():\n                return\n            case <-ticker.C:\n                // TODO: Get current progress from PieceManager\n                // TODO: Build announce request with current stats\n                // TODO: Send announce to tracker\n                // TODO: Parse response and send peers to peerUpdates channel\n                // TODO: Update ticker interval based on tracker response\n            }\n        }\n    }()\n}\n\n// startPeerManagement handles peer connections and message processing\nfunc (c *Client) startPeerManagement() {\n    go func() {\n        for {\n            select {\n            case <-c.ctx.Done():\n                return\n            case newPeers := <-c.peerUpdates:\n                // TODO: Connect to new peers (up to MAX_PEERS limit)\n                // TODO: Start message processing for each connection\n                // TODO: Handle peer disconnections and errors\n            }\n        }\n    }()\n}\n\n// startPieceCoordination manages piece requests and assembly\nfunc (c *Client) startPieceCoordination() {\n    go func() {\n        for {\n            select {\n            case <-c.ctx.Done():\n                return\n            case progress := <-c.progressUpdates:\n                // TODO: Update piece availability based on peer bitfields\n                // TODO: Select next pieces using rarest-first algorithm\n                // TODO: Send block requests to appropriate peers\n                // TODO: Verify completed pieces and retry on hash failure\n                // TODO: Assemble verified pieces into output file\n            }\n        }\n    }()\n}\n```\n\n**Core Component Skeleton:**\n\n```go\n// internal/torrent/parser.go - Core torrent parsing logic\npackage torrent\n\nimport (\n    \"crypto/sha1\"\n    \"os\"\n    \"time\"\n)\n\n// MetaInfo represents parsed torrent file metadata\ntype MetaInfo struct {\n    Announce     string\n    CreationDate time.Time\n    Comment      string\n    InfoHash     [20]byte\n    Info         Info\n}\n\n// Info represents the info dictionary from torrent file\ntype Info struct {\n    Name        string\n    Length      int64\n    PieceLength int64\n    Pieces      []byte\n    Files       []File\n}\n\n// File represents individual file in multi-file torrent\ntype File struct {\n    Length int64\n    Path   []string\n}\n\n// ParseFromFile reads and parses a torrent file from disk\nfunc ParseFromFile(filepath string) (*MetaInfo, error) {\n    // TODO 1: Open file and read all bytes\n    // TODO 2: Create bencode decoder from file data\n    // TODO 3: Decode top-level dictionary\n    // TODO 4: Extract announce URL and optional fields\n    // TODO 5: Extract info dictionary and calculate hash\n    // TODO 6: Parse file information from info dict\n    panic(\"implement me\")\n}\n\n// GetPieceHashes extracts individual piece hashes from concatenated pieces field\nfunc (i *Info) GetPieceHashes() [][20]byte {\n    // TODO 1: Verify pieces length is multiple of 20\n    // TODO 2: Split pieces into 20-byte chunks\n    // TODO 3: Convert each chunk to [20]byte array\n    panic(\"implement me\")\n}\n\n// CalculateInfoHash computes SHA1 hash of bencoded info dictionary\nfunc CalculateInfoHash(bencoded []byte) [20]byte {\n    hash := sha1.Sum(bencoded)\n    return hash\n}\n```\n\n**File Structure Setup Script:**\n\n```bash\n#!/bin/bash\n# setup-project.sh - Creates the complete project structure\n\nmkdir -p bittorrent-client/{cmd/bittorrent,internal/{torrent,tracker,peer,piece,client},pkg/bittorrent,testdata}\n\n# Create go.mod\ncat > bittorrent-client/go.mod << 'EOF'\nmodule bittorrent-client\n\ngo 1.21\n\nrequire (\n    // Add dependencies as needed\n)\nEOF\n\n# Create main.go entry point\ncat > bittorrent-client/cmd/bittorrent/main.go << 'EOF'\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"bittorrent-client/internal/torrent\"\n    \"bittorrent-client/internal/client\"\n)\n\nfunc main() {\n    var (\n        torrentFile = flag.String(\"torrent\", \"\", \"Path to .torrent file\")\n        output      = flag.String(\"output\", \"\", \"Output file path\")\n    )\n    flag.Parse()\n\n    if *torrentFile == \"\" || *output == \"\" {\n        fmt.Fprintf(os.Stderr, \"Usage: %s -torrent <file> -output <path>\\n\", os.Args[0])\n        os.Exit(1)\n    }\n\n    // Parse torrent file\n    metaInfo, err := torrent.ParseFromFile(*torrentFile)\n    if err != nil {\n        log.Fatalf(\"Failed to parse torrent: %v\", err)\n    }\n\n    // Create and run client\n    client := client.NewClient(metaInfo)\n    defer client.Close()\n\n    if err := client.Download(*output); err != nil {\n        log.Fatalf(\"Download failed: %v\", err)\n    }\n\n    fmt.Printf(\"Download completed: %s\\n\", *output)\n}\nEOF\n```\n\n**Milestone Checkpoint:**\n\nAfter implementing the high-level architecture:\n\n1. **Structure Verification**: Run `find bittorrent-client -name \"*.go\" | head -10` - you should see the organized package structure\n2. **Compilation Check**: Run `go build ./cmd/bittorrent` - should compile without errors (even with panic statements)\n3. **Import Verification**: All internal packages should import cleanly without circular dependencies\n4. **Interface Validation**: Each component should have clear interface methods defined (even if not implemented)\n\n**Common Architecture Pitfalls:**\n\n⚠️ **Pitfall: Circular Import Dependencies**\nCreating circular imports between packages (e.g., peer imports piece, piece imports peer) will prevent compilation. Solve this by defining shared interfaces in a common package or using dependency injection to break cycles.\n\n⚠️ **Pitfall: Shared Mutable State Without Synchronization** \nComponents accessing shared data structures without proper locking will cause race conditions. Use Go's race detector (`go run -race`) to detect these issues during development.\n\n⚠️ **Pitfall: Blocking Operations in Coordination Channels**\nSending to channels without proper buffering or goroutine management can deadlock the entire system. Always use `select` statements with context cancellation for coordination code.\n\n**Debugging Hints:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|-----------------|-----|\n| Import cycle errors | Circular dependencies between packages | Check import statements in each package | Move shared interfaces to separate package |\n| Deadlocks during shutdown | Goroutines waiting on channels that never close | Add logging to goroutine lifecycles | Implement proper context cancellation |\n| Race condition panics | Shared data access without locks | Run with `-race` flag | Add mutex protection to shared state |\n| Memory leaks | Goroutines not terminating | Use `go tool pprof` to check goroutine count | Ensure all goroutines respect context cancellation |\n\n\n## Data Model\n\n> **Milestone(s):** This section establishes the foundational data structures that will be built across all milestones: torrent metadata parsing (Milestone 1), tracker communication (Milestone 2), peer protocol (Milestone 3), and piece management (Milestone 4).\n\nBuilding a BitTorrent client requires carefully designed data structures that capture the complex relationships between torrent files, peer connections, piece downloads, and protocol messages. Think of the data model as the **blueprint for a complex construction project** - just as architects must specify every beam, joint, and connection before builders can construct a skyscraper, we must define every struct, field, and relationship before implementing the BitTorrent protocol. Each data structure serves as a contract between different components of our system, ensuring they can communicate effectively and maintain consistent state.\n\nThe BitTorrent data model spans four distinct domains: **torrent metadata** (what files we're sharing and how they're structured), **peer state** (who we're connected to and what they can provide), **piece management** (tracking download progress and verification), and **protocol messages** (the language peers use to communicate). These domains interact in sophisticated ways - torrent metadata defines the pieces we need, peer state determines who can provide them, piece management coordinates the downloads, and protocol messages facilitate the actual data transfer.\n\n![Core Data Structures](./diagrams/data-model.svg)\n\n### Torrent Metadata Structures\n\nThe torrent metadata structures represent the parsed contents of a `.torrent` file, which serves as the **recipe for reconstructing a file or collection of files** from pieces distributed across the peer-to-peer network. Think of torrent metadata as a **detailed recipe book** - it tells you what ingredients you need (the pieces), how much of each ingredient (piece lengths and hashes), where to find suppliers (tracker URLs), and how to verify you've got the right ingredients (SHA-1 hashes for verification). This metadata is the authoritative source of truth for everything about a torrent.\n\n> **Decision: Hierarchical Metadata Structure**\n> - **Context**: Torrent files contain nested information - global metadata (announce URL, creation date) and file-specific information (name, length, pieces). We need to decide how to structure this data in memory.\n> - **Options Considered**: Flat structure with all fields at one level, hierarchical structure matching the original Bencode format, separate structures for single vs multi-file torrents\n> - **Decision**: Hierarchical structure with `MetaInfo` containing global metadata and an `Info` struct containing file-specific data\n> - **Rationale**: Mirrors the original Bencode structure, makes info hash calculation straightforward (we hash just the `Info` portion), and provides clear separation between tracker-related metadata and content-related metadata\n> - **Consequences**: Requires two-level access for file information but makes the protocol implementation cleaner and more maintainable\n\nThe `MetaInfo` structure represents the top-level torrent file contents and serves as the entry point for all torrent operations. Every BitTorrent client begins by parsing a torrent file into this structure, which then drives all subsequent operations from tracker communication to piece verification.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Announce` | `string` | Primary tracker URL where peers can be found for this torrent |\n| `CreationDate` | `time.Time` | When this torrent was created (optional field from torrent file) |\n| `Comment` | `string` | Human-readable description of the torrent contents (optional field) |\n| `InfoHash` | `[20]byte` | SHA-1 hash of the bencoded info dictionary - the unique identifier for this torrent |\n| `Info` | `Info` | The info dictionary containing file structure and piece information |\n\nThe `InfoHash` field deserves special attention as it serves as the **unique fingerprint** for the entire torrent. This 20-byte SHA-1 hash is computed from the exact bencoded bytes of the info dictionary and is used everywhere in the BitTorrent protocol - tracker announces include it to identify which torrent they're interested in, peer handshakes include it to verify both peers are talking about the same torrent, and DHT lookups use it as the key. The info hash must be calculated from the original bencoded bytes, not from a re-encoding of the parsed data structure, because even tiny differences in encoding would produce different hashes.\n\nThe `Info` structure contains the core file and piece information that defines what we're actually downloading. This structure is hashed to produce the info hash, so its contents are immutable once a torrent is created.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Name` | `string` | Suggested name for the file or top-level directory when saving |\n| `Length` | `int64` | Total length in bytes for single-file torrents (zero for multi-file) |\n| `PieceLength` | `int64` | Size in bytes of each piece (typically 256KB, 512KB, or 1MB) |\n| `Pieces` | `[]byte` | Concatenated SHA-1 hashes of all pieces (20 bytes per piece) |\n| `Files` | `[]File` | List of files in multi-file torrents (empty for single-file) |\n\nThe `Pieces` field requires careful handling as it contains concatenated 20-byte SHA-1 hashes rather than a slice of individual hashes. For a torrent with 1000 pieces, this field contains exactly 20,000 bytes. The `GetPieceHashes()` method extracts individual hashes from this concatenated format, providing a more convenient interface for piece verification operations.\n\n> **Critical Design Insight**: The `Length` and `Files` fields are mutually exclusive - single-file torrents use `Length` and leave `Files` empty, while multi-file torrents populate `Files` and set `Length` to zero. This design follows the original BitTorrent specification and avoids redundant data storage.\n\nFor multi-file torrents, the `File` structure describes each individual file within the torrent. Multi-file torrents are conceptually **flat streams of bytes** that happen to be logically divided into files, similar to a ZIP archive that preserves directory structure.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Length` | `int64` | Size of this specific file in bytes |\n| `Path` | `[]string` | Directory path components leading to this file (e.g., [\"docs\", \"readme.txt\"]) |\n\nThe `Path` field uses a slice of strings rather than a single path string to avoid platform-specific path separator issues. When writing files to disk, the client joins these components using the operating system's appropriate path separator.\n\n### Peer and Connection State\n\nPeer and connection state structures manage the complex relationships and state machines involved in BitTorrent peer communication. Think of peer state management as **managing relationships in a complex social network** - you need to track who you know (discovered peers), who you're actively talking to (connected peers), what each person is interested in (piece availability), and the current status of each relationship (choking and interested states). Each peer connection is essentially an independent state machine that must be carefully coordinated with piece management and download strategies.\n\n> **Decision: Separation of Peer Discovery and Connection State**\n> - **Context**: We need to distinguish between peers we've discovered (from tracker or DHT) and peers we're actively connected to. These have different data requirements and lifecycles.\n> - **Options Considered**: Single structure for both discovered and connected peers, separate structures for each state, connection state as extension of peer info\n> - **Decision**: Separate `PeerInfo` for discovered peers and `Connection` for active connections\n> - **Rationale**: Discovered peers only need IP/port information, while active connections need message queues, state machines, and buffers. Separation keeps memory usage reasonable and makes state transitions clear.\n> - **Consequences**: Requires mapping between peer info and connections, but provides cleaner abstraction and better resource management\n\nThe `PeerInfo` structure represents a peer discovered through tracker announces or DHT lookups. This is the minimal information needed to attempt a connection to a peer.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `IP` | `[4]byte` | IPv4 address of the peer (big-endian byte order) |\n| `Port` | `uint16` | TCP port number where peer accepts BitTorrent connections |\n\nThe compact peer format used by trackers packs this information into exactly 6 bytes per peer - 4 bytes for the IPv4 address followed by 2 bytes for the port in network byte order. The `ParseCompactPeers()` function converts this packed format into `PeerInfo` structures for easier handling.\n\nActive peer connections require significantly more state tracking than simple peer discovery. Each connection maintains multiple pieces of state: the TCP connection itself, protocol state (handshake completion, supported extensions), choking state (four-flag state machine), piece availability (bitfield of what pieces the peer has), and request queues (outstanding block requests).\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Conn` | `net.Conn` | Underlying TCP connection to the peer |\n| `PeerID` | `[20]byte` | Unique identifier for this peer (received during handshake) |\n| `Bitfield` | `[]byte` | Bitmap indicating which pieces this peer has available |\n| `AmChoking` | `bool` | Whether we are choking this peer (refusing to upload to them) |\n| `AmInterested` | `bool` | Whether we are interested in pieces this peer has |\n| `PeerChoking` | `bool` | Whether this peer is choking us (refusing to upload to us) |\n| `PeerInterested` | `bool` | Whether this peer is interested in pieces we have |\n| `PendingRequests` | `map[int]BlockRequest` | Outstanding block requests we've sent to this peer |\n| `RequestQueue` | `chan BlockRequest` | Queue of block requests waiting to be sent |\n\nThe four boolean flags (`AmChoking`, `AmInterested`, `PeerChoking`, `PeerInterested`) implement the core BitTorrent choking algorithm. This creates a state machine with 16 possible states, though only certain combinations are meaningful for data transfer.\n\n| Our State | Peer State | Can Download | Can Upload | Typical Action |\n|-----------|------------|--------------|------------|----------------|\n| Interested, Unchoked | Any | Yes | Varies | Send piece requests |\n| Interested, Choked | Any | No | Varies | Wait for unchoke |\n| Not Interested | Any | No | Varies | Update interest when pieces change |\n| Any | Interested, We Unchoke | Varies | Yes | Send requested pieces |\n| Any | Interested, We Choke | Varies | No | Ignore piece requests |\n| Any | Not Interested | Varies | No | No upload activity |\n\nThe `Bitfield` uses a compact bitmap representation where each bit indicates whether the peer has the corresponding piece. For a torrent with 1000 pieces, the bitfield requires 125 bytes (1000 bits rounded up to the nearest byte boundary). Bit manipulation operations check and set individual pieces within this bitmap.\n\n> **Protocol Design Insight**: The choking mechanism serves as BitTorrent's incentive system - peers upload to those who upload to them, creating a tit-for-tat relationship that encourages participation rather than freeloading. New peers get optimistic unchokes to bootstrap the relationship.\n\n### Piece and Block Management\n\nPiece and block management structures coordinate the complex process of downloading, verifying, and assembling pieces into complete files. Think of piece management as **coordinating a massive jigsaw puzzle** where multiple people are working on different sections simultaneously, pieces must be verified before acceptance, and you need to track which pieces are rarest to prioritize them appropriately. The challenge is coordinating concurrent downloads while avoiding duplicate work and ensuring data integrity.\n\nPieces and blocks represent different granularities of data transfer. A **piece** is the unit of verification (typically 256KB to 1MB) that can be independently hash-checked, while a **block** is the unit of network transfer (typically 16KB) that fits in a single protocol message. Each piece contains multiple blocks, and blocks must be requested individually from peers.\n\n> **Decision: Separate Piece and Block Granularity**\n> - **Context**: BitTorrent uses different sizes for verification (pieces) and network transfer (blocks). We need to decide how to model this relationship.\n> - **Options Considered**: Single granularity using pieces only, single granularity using blocks only, separate piece and block concepts with mapping between them\n> - **Decision**: Separate piece and block concepts with explicit mapping and state tracking\n> - **Rationale**: Matches protocol design where pieces are verified independently but transferred as smaller blocks. Allows request pipelining and partial piece recovery if connections fail.\n> - **Consequences**: More complex state management but better network efficiency and failure handling\n\nThe `PieceState` structure tracks the download progress and verification status of a single piece. Each piece progresses through several states during download: not started, in progress (with some blocks downloaded), complete but unverified, verified and available, or failed verification.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Index` | `int` | Zero-based index of this piece in the torrent |\n| `Length` | `int` | Total size of this piece in bytes (may be smaller for last piece) |\n| `Hash` | `[20]byte` | Expected SHA-1 hash for verification of complete piece |\n| `Blocks` | `map[int]*Block` | Map of block offset to block state within this piece |\n| `State` | `PieceStateEnum` | Current state: NotStarted, InProgress, Complete, Verified, Failed |\n| `Priority` | `int` | Download priority (higher numbers downloaded first) |\n| `Availability` | `int` | Number of connected peers that have this piece |\n\nThe `Blocks` map uses byte offsets as keys, allowing efficient lookup of specific blocks within the piece. Block offsets are typically multiples of `BLOCK_SIZE` (16384 bytes), with the final block in each piece potentially being smaller.\n\nIndividual blocks represent the smallest unit of data transfer and request management. Each block tracks its own download state and can be independently requested from different peers.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `PieceIndex` | `int` | Which piece this block belongs to |\n| `Offset` | `int` | Byte offset within the piece where this block starts |\n| `Length` | `int` | Size of this block in bytes (typically 16KB, smaller for last block) |\n| `Data` | `[]byte` | The actual downloaded data (nil until downloaded) |\n| `State` | `BlockStateEnum` | Current state: NotRequested, Requested, Downloaded |\n| `RequestedFrom` | `string` | Peer ID that we requested this block from (for timeout handling) |\n| `RequestTime` | `time.Time` | When we sent the request (for timeout detection) |\n\nBlock state management requires careful coordination to avoid duplicate requests while ensuring failed requests are retried. The `RequestedFrom` and `RequestTime` fields enable timeout detection - if a block request isn't fulfilled within a reasonable time, it can be re-requested from a different peer.\n\n| Block State | Next States | Trigger | Action |\n|-------------|-------------|---------|--------|\n| NotRequested | Requested | Peer available and not choked | Send request message |\n| Requested | Downloaded | Piece message received | Store data, verify length |\n| Requested | NotRequested | Request timeout | Mark for retry with different peer |\n| Downloaded | NotRequested | Piece verification failed | Mark all blocks for re-download |\n\nThe piece selection and scheduling system coordinates downloads across multiple peers to optimize performance. The `PieceManager` maintains global state about download progress and peer availability.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Pieces` | `map[int]*PieceState` | State of all pieces in the torrent |\n| `IncompletePieces` | `[]int` | Pieces that are partially downloaded (for endgame mode) |\n| `RequestQueue` | `chan BlockRequest` | Global queue of blocks that need downloading |\n| `CompletedPieces` | `map[int]bool` | Quick lookup for pieces that are verified and complete |\n| `TotalPieces` | `int` | Total number of pieces in this torrent |\n| `TotalLength` | `int64` | Total size of all data in bytes |\n\n> **Scheduling Strategy**: The piece selection algorithm implements **rarest-first scheduling** - pieces held by fewer peers are downloaded first to improve overall swarm health. This prevents situations where common pieces are over-replicated while rare pieces risk being lost if their few holders disconnect.\n\n### Protocol Message Formats\n\nProtocol message structures define the language that BitTorrent peers use to communicate. Think of these messages as **vocabulary in a formal diplomatic protocol** - each message type has a specific format, purpose, and expected response, and both sides must follow the protocol exactly or communication breaks down. The wire protocol uses binary encoding for efficiency, with each message having a specific structure that must be parsed and generated correctly.\n\nThe BitTorrent peer wire protocol uses a simple message framing format: each message starts with a 4-byte length prefix (in big-endian byte order), followed by a 1-byte message ID, followed by the message payload. The handshake message is special and doesn't follow this framing format.\n\n> **Decision: Structured Message Types with Union-Style Interface**\n> - **Context**: BitTorrent messages have different payloads but share common framing. We need to decide how to represent this variety in a type-safe way.\n> - **Options Considered**: Single message struct with optional fields, interface with concrete types for each message, raw byte handling with manual parsing\n> - **Decision**: Interface-based design with concrete types for each message category\n> - **Rationale**: Provides type safety, makes message handling explicit, and allows for easy extension with new message types\n> - **Consequences**: Requires more types but provides better compile-time checking and clearer message handling logic\n\nThe handshake message establishes a BitTorrent connection and verifies both peers are talking about the same torrent. This message has a fixed 68-byte format that differs from all other protocol messages.\n\n| Field | Type | Size | Description |\n|-------|------|------|-------------|\n| `ProtocolLength` | `uint8` | 1 byte | Length of protocol string (always 19 for BitTorrent) |\n| `Protocol` | `string` | 19 bytes | Protocol identifier: \"BitTorrent protocol\" |\n| `Reserved` | `[8]byte` | 8 bytes | Reserved for extension flags (usually all zeros) |\n| `InfoHash` | `[20]byte` | 20 bytes | SHA-1 hash identifying the torrent |\n| `PeerID` | `[20]byte` | 20 bytes | Unique identifier for the sending peer |\n\nAfter the handshake, all messages follow the standard framing format. The message ID determines how to interpret the payload that follows.\n\n| Message ID | Name | Payload Size | Purpose |\n|------------|------|--------------|---------|\n| -1 | Keep-alive | 0 bytes | Maintain connection when no other messages needed |\n| 0 | Choke | 0 bytes | Sender will not fulfill requests from receiver |\n| 1 | Unchoke | 0 bytes | Sender will fulfill requests from receiver |\n| 2 | Interested | 0 bytes | Sender wants to download from receiver |\n| 3 | Not interested | 0 bytes | Sender doesn't want anything from receiver |\n| 4 | Have | 4 bytes | Announces sender has completed a piece |\n| 5 | Bitfield | Variable | Announces which pieces sender has (sent after handshake) |\n| 6 | Request | 12 bytes | Request a block of data from a piece |\n| 7 | Piece | Variable | Deliver requested block data |\n| 8 | Cancel | 12 bytes | Cancel a previously sent request |\n\nThe `Have` message announces when a peer completes downloading a piece. This allows other peers to update their availability calculations for piece selection.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `PieceIndex` | `uint32` | Zero-based index of the completed piece |\n\nThe `Bitfield` message is sent immediately after handshake completion to announce which pieces the peer already has. This message uses the same compact bitmap format as the `Bitfield` field in connection state.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Bitfield` | `[]byte` | Bitmap of available pieces (1 bit per piece) |\n\nThe `Request` message asks a peer to send a specific block of data. BitTorrent clients typically pipeline multiple requests to keep the network connection busy.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `PieceIndex` | `uint32` | Which piece contains the desired block |\n| `BlockOffset` | `uint32` | Byte offset within the piece where block starts |\n| `BlockLength` | `uint32` | Size of the requested block (typically 16384 bytes) |\n\nThe `Piece` message delivers requested block data. This is the core message that actually transfers file content between peers.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `PieceIndex` | `uint32` | Which piece this block belongs to |\n| `BlockOffset` | `uint32` | Byte offset within the piece |\n| `BlockData` | `[]byte` | The actual file data for this block |\n\n> **Protocol Efficiency Note**: Block requests are typically pipelined - clients send multiple request messages before receiving the first piece response. This keeps the network connection saturated and improves transfer speeds, but requires careful tracking of outstanding requests.\n\nThe `Cancel` message allows clients to cancel previously sent requests, typically used in endgame mode when the same block is requested from multiple peers to avoid slow connections.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `PieceIndex` | `uint32` | Which piece contained the block to cancel |\n| `BlockOffset` | `uint32` | Byte offset of the block to cancel |\n| `BlockLength` | `uint32` | Size of the block to cancel |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Info Hash Calculation from Re-encoded Data**\nMany developers make the mistake of calculating the info hash by re-encoding the parsed `Info` structure back to Bencode format. This fails because Bencode encoding is not canonical - the same data can be encoded in multiple ways (dictionary key ordering, integer representation). The info hash must be calculated from the original bytes of the info dictionary as it appeared in the torrent file. Store these original bytes during parsing or calculate the hash before parsing the info dictionary contents.\n\n⚠️ **Pitfall: Bitfield Bit Ordering Confusion**\nThe bitfield uses big-endian bit ordering within each byte, which can be confusing. The first piece (index 0) is represented by the most significant bit of the first byte. When checking if piece N is available, use `bitfield[N/8] & (0x80 >> (N%8))` rather than assuming little-endian bit ordering. Test with a known bitfield pattern to verify your bit manipulation is correct.\n\n⚠️ **Pitfall: Block Boundary Calculations**\nThe last piece in a torrent is typically smaller than the standard piece length, and the last block in any piece may be smaller than the standard block size. Always calculate block and piece sizes dynamically rather than assuming they're all the same size. Use `min(BLOCK_SIZE, remaining_piece_bytes)` when calculating block lengths to handle these boundary conditions correctly.\n\n⚠️ **Pitfall: Concurrent Access to Peer State**\nPeer connections run in separate goroutines and can modify connection state concurrently with the main piece management logic. Protect all shared state (bitfields, pending requests, choking flags) with appropriate synchronization. Use separate mutexes for different aspects of peer state to avoid lock contention while ensuring consistency.\n\n⚠️ **Pitfall: Message Length Validation**\nAlways validate message lengths before parsing message payloads. A malicious or buggy peer could send a message claiming to be much larger than it actually is, leading to buffer overruns or excessive memory allocation. Check that declared message lengths match expected sizes for fixed-format messages, and impose reasonable limits on variable-length messages like bitfields and piece data.\n\n### Implementation Guidance\n\nThe data model implementation requires careful attention to memory layout, serialization formats, and concurrent access patterns. Go's strong typing system helps prevent many common errors, but BitTorrent's binary protocols require explicit handling of byte ordering and bit manipulation.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Serialization | Manual byte manipulation with encoding/binary | Protocol Buffers with custom wire format |\n| Concurrency | sync.Mutex for each data structure | sync.RWMutex with fine-grained locking |\n| Memory Management | Standard garbage collection | sync.Pool for frequent allocations |\n| Bit Operations | Standard bit shifting and masking | Third-party bitset library |\n\n#### Recommended File Structure\n\nThe data model spans multiple packages to maintain clean separation of concerns and enable independent testing of each component.\n\n```\ninternal/\n  torrent/\n    metadata.go          ← MetaInfo, Info, File structures\n    metadata_test.go     ← Torrent parsing tests\n  peer/\n    connection.go        ← Connection state and peer management\n    connection_test.go   ← Peer state machine tests\n  piece/\n    manager.go          ← PieceState, Block, and scheduling logic\n    manager_test.go     ← Piece selection and verification tests\n  protocol/\n    messages.go         ← All protocol message types\n    messages_test.go    ← Message parsing and generation tests\n```\n\n#### Complete Infrastructure Code\n\nHere's the complete message framing infrastructure that handles the binary protocol details:\n\n```go\npackage protocol\n\nimport (\n    \"encoding/binary\"\n    \"fmt\"\n    \"io\"\n)\n\nconst (\n    HANDSHAKE_LENGTH = 68\n    PROTOCOL_STRING = \"BitTorrent protocol\"\n)\n\n// MessageFramer handles the binary framing of BitTorrent protocol messages\ntype MessageFramer struct {\n    conn io.ReadWriter\n}\n\nfunc NewMessageFramer(conn io.ReadWriter) *MessageFramer {\n    return &MessageFramer{conn: conn}\n}\n\n// ReadMessage reads a complete framed message from the connection\nfunc (mf *MessageFramer) ReadMessage() (MessageID, []byte, error) {\n    // Read 4-byte length prefix\n    var length uint32\n    err := binary.Read(mf.conn, binary.BigEndian, &length)\n    if err != nil {\n        return 0, nil, fmt.Errorf(\"failed to read message length: %w\", err)\n    }\n    \n    // Handle keep-alive messages (length = 0)\n    if length == 0 {\n        return KEEPALIVE, nil, nil\n    }\n    \n    // Read message ID (1 byte)\n    var messageID uint8\n    err = binary.Read(mf.conn, binary.BigEndian, &messageID)\n    if err != nil {\n        return 0, nil, fmt.Errorf(\"failed to read message ID: %w\", err)\n    }\n    \n    // Read remaining payload\n    payload := make([]byte, length-1) // -1 because we already read message ID\n    _, err = io.ReadFull(mf.conn, payload)\n    if err != nil {\n        return 0, nil, fmt.Errorf(\"failed to read message payload: %w\", err)\n    }\n    \n    return MessageID(messageID), payload, nil\n}\n\n// WriteMessage writes a framed message to the connection\nfunc (mf *MessageFramer) WriteMessage(messageID MessageID, payload []byte) error {\n    // Calculate total length (message ID + payload)\n    length := uint32(1 + len(payload))\n    \n    // Write length prefix\n    err := binary.Write(mf.conn, binary.BigEndian, length)\n    if err != nil {\n        return fmt.Errorf(\"failed to write message length: %w\", err)\n    }\n    \n    // Write message ID\n    err = binary.Write(mf.conn, binary.BigEndian, uint8(messageID))\n    if err != nil {\n        return fmt.Errorf(\"failed to write message ID: %w\", err)\n    }\n    \n    // Write payload\n    _, err = mf.conn.Write(payload)\n    if err != nil {\n        return fmt.Errorf(\"failed to write message payload: %w\", err)\n    }\n    \n    return nil\n}\n```\n\nComplete bitfield manipulation utilities:\n\n```go\npackage peer\n\nimport \"math\"\n\n// BitfieldOps provides utilities for manipulating piece availability bitfields\ntype BitfieldOps struct {\n    bitfield []byte\n    numPieces int\n}\n\nfunc NewBitfield(numPieces int) *BitfieldOps {\n    byteCount := int(math.Ceil(float64(numPieces) / 8.0))\n    return &BitfieldOps{\n        bitfield: make([]byte, byteCount),\n        numPieces: numPieces,\n    }\n}\n\nfunc (bf *BitfieldOps) SetPiece(pieceIndex int) {\n    if pieceIndex >= bf.numPieces {\n        return\n    }\n    byteIndex := pieceIndex / 8\n    bitOffset := pieceIndex % 8\n    bf.bitfield[byteIndex] |= (0x80 >> bitOffset)\n}\n\nfunc (bf *BitfieldOps) HasPiece(pieceIndex int) bool {\n    if pieceIndex >= bf.numPieces {\n        return false\n    }\n    byteIndex := pieceIndex / 8\n    bitOffset := pieceIndex % 8\n    return (bf.bitfield[byteIndex] & (0x80 >> bitOffset)) != 0\n}\n\nfunc (bf *BitfieldOps) CountPieces() int {\n    count := 0\n    for i := 0; i < bf.numPieces; i++ {\n        if bf.HasPiece(i) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc (bf *BitfieldOps) ToBytes() []byte {\n    result := make([]byte, len(bf.bitfield))\n    copy(result, bf.bitfield)\n    return result\n}\n```\n\n#### Core Logic Skeletons\n\nHere are the key data structure definitions with TODO comments for the core logic that learners should implement:\n\n```go\npackage torrent\n\nimport (\n    \"crypto/sha1\"\n    \"time\"\n)\n\n// MetaInfo represents the parsed contents of a .torrent file\ntype MetaInfo struct {\n    Announce     string\n    CreationDate time.Time\n    Comment      string\n    InfoHash     [20]byte\n    Info         Info\n}\n\n// CalculateInfoHash computes the SHA-1 hash of the bencoded info dictionary\nfunc (mi *MetaInfo) CalculateInfoHash(bencodedInfoDict []byte) [20]byte {\n    // TODO 1: Use crypto/sha1 to create a new hash instance\n    // TODO 2: Write the exact bencoded bytes to the hasher\n    // TODO 3: Call Sum() to get the final 20-byte hash\n    // TODO 4: Convert the slice to a [20]byte array and return\n    // Hint: This must use the original bencoded bytes, not re-encoded data\n}\n\n// Info represents the info dictionary from a torrent file\ntype Info struct {\n    Name        string\n    Length      int64\n    PieceLength int64\n    Pieces      []byte\n    Files       []File\n}\n\n// GetPieceHashes extracts individual 20-byte piece hashes from concatenated pieces field\nfunc (info *Info) GetPieceHashes() [][20]byte {\n    // TODO 1: Calculate how many pieces there are (len(Pieces) / 20)\n    // TODO 2: Create a slice to hold the individual hashes\n    // TODO 3: Loop through the Pieces field in 20-byte chunks\n    // TODO 4: Copy each 20-byte chunk into a [20]byte array\n    // TODO 5: Append each hash array to the result slice\n    // Hint: Use copy() to convert []byte to [20]byte\n}\n\n// CalculateTotalLength returns total bytes across all files (for multi-file torrents)\nfunc (info *Info) CalculateTotalLength() int64 {\n    // TODO 1: If this is a single-file torrent (Length > 0), return Length\n    // TODO 2: Otherwise, iterate through Files slice and sum all file lengths\n    // TODO 3: Return the total calculated length\n}\n```\n\n```go\npackage peer\n\nimport (\n    \"net\"\n    \"sync\"\n    \"time\"\n)\n\n// Connection represents an active connection to a BitTorrent peer\ntype Connection struct {\n    conn            net.Conn\n    peerID          [20]byte\n    bitfield        *BitfieldOps\n    amChoking       bool\n    amInterested    bool\n    peerChoking     bool\n    peerInterested  bool\n    pendingRequests map[string]*BlockRequest\n    mutex           sync.RWMutex\n}\n\n// UpdateInterest checks if we should be interested in this peer based on their pieces\nfunc (c *Connection) UpdateInterest(neededPieces []int) {\n    // TODO 1: Lock the connection for reading\n    // TODO 2: Check if peer has any pieces we need (iterate through neededPieces)\n    // TODO 3: If peer has needed pieces and we're not interested, send INTERESTED message\n    // TODO 4: If peer has no needed pieces and we are interested, send NOT_INTERESTED\n    // TODO 5: Update the amInterested flag accordingly\n    // TODO 6: Unlock the connection\n    // Hint: Use bitfield.HasPiece() to check peer's available pieces\n}\n\n// CanDownload returns true if we can request blocks from this peer\nfunc (c *Connection) CanDownload() bool {\n    // TODO 1: Lock for reading\n    // TODO 2: Check if we're interested AND peer is not choking us\n    // TODO 3: Return the result\n    // Hint: Both conditions must be true for downloads to proceed\n}\n```\n\n```go\npackage piece\n\nimport (\n    \"crypto/sha1\"\n    \"sync\"\n)\n\n// Manager coordinates piece downloads and verification across multiple peers\ntype Manager struct {\n    pieces          map[int]*PieceState\n    completedPieces map[int]bool\n    inProgress      map[int]bool\n    totalPieces     int\n    pieceLength     int64\n    pieceHashes     [][20]byte\n    mutex           sync.RWMutex\n}\n\n// SelectNextPiece implements rarest-first piece selection strategy\nfunc (pm *Manager) SelectNextPiece(peerBitfield *BitfieldOps) int {\n    // TODO 1: Lock for reading to examine piece availability\n    // TODO 2: Build a list of pieces we need that this peer has\n    // TODO 3: Count how many peers have each candidate piece (availability)\n    // TODO 4: Sort candidates by availability (rarest first)\n    // TODO 5: Return the rarest piece index, or -1 if no pieces needed\n    // Hint: Lower availability count = higher priority for download\n}\n\n// VerifyPiece checks if a completed piece matches its expected hash\nfunc (pm *Manager) VerifyPiece(pieceIndex int, data []byte) bool {\n    // TODO 1: Get the expected hash for this piece from pieceHashes\n    // TODO 2: Calculate SHA-1 hash of the provided data\n    // TODO 3: Compare calculated hash with expected hash\n    // TODO 4: If hashes match, mark piece as completed and return true\n    // TODO 5: If hashes don't match, mark piece for re-download and return false\n    // Hint: Use bytes.Equal() to compare hash arrays\n}\n```\n\n#### Language-Specific Hints\n\n- Use `encoding/binary.BigEndian` for all network byte order conversions in protocol messages\n- The `[20]byte` array type is not directly assignable from `[]byte` slices - use `copy()` for conversion\n- Implement `String()` methods on your message types for better debugging output\n- Use `sync.RWMutex` for data structures that are read frequently but written infrequently\n- Consider using `context.Context` for cancellation in long-running download operations\n- The `net.Conn` interface provides both reading and writing, but you may need to wrap it with `bufio.Reader` for efficient parsing\n\n#### Milestone Checkpoints\n\nAfter implementing the data model structures, verify the following behavior:\n\n**Milestone 1 Checkpoint**: Torrent metadata parsing works correctly\n- Run `go test ./internal/torrent/...` - all bencode parsing tests should pass\n- Parse a real .torrent file and verify the info hash matches other BitTorrent clients\n- Check that `GetPieceHashes()` returns the correct number of 20-byte hashes\n- Verify multi-file torrents correctly populate the `Files` slice\n\n**Milestone 2 Checkpoint**: Peer state management functions properly\n- Run `go test ./internal/peer/...` - connection state tests should pass\n- Create a bitfield, set some pieces, and verify `HasPiece()` returns correct results\n- Test the four-flag state machine with various choking/interested combinations\n- Verify that `CanDownload()` returns true only when interested and unchoked\n\n**Milestone 3 Checkpoint**: Protocol message handling works\n- Run `go test ./internal/protocol/...` - message parsing tests should pass\n- Create each message type and verify serialization round-trips correctly\n- Test message framing with various payload sizes including zero-length messages\n- Verify handshake message format matches the 68-byte specification exactly\n\n**Milestone 4 Checkpoint**: Piece management coordinates correctly\n- Run `go test ./internal/piece/...` - piece selection and verification tests should pass\n- Test piece selection with various peer bitfield configurations\n- Verify piece verification correctly accepts good hashes and rejects bad ones\n- Check that completed pieces are properly tracked and not re-downloaded\n\n\n## Torrent File Parsing (Milestone 1)\n\n> **Milestone(s):** This section corresponds to Milestone 1 - Torrent File Parsing, implementing Bencode decoding and torrent metadata extraction with proper info hash calculation.\n\nTorrent file parsing forms the foundation of any BitTorrent client. Before we can connect to trackers, discover peers, or download pieces, we must first understand what files we're trying to download and how they're organized. This milestone involves decoding the Bencode format used by BitTorrent and extracting critical metadata that drives the entire download process.\n\nThe parsing process involves three fundamental challenges. First, we must decode the Bencode binary encoding format that stores all torrent metadata in a compact, language-agnostic form. Second, we need to extract specific fields from the decoded data structure to understand file organization, tracker locations, and piece verification data. Third, we must compute the info hash - a cryptographic identifier that uniquely identifies the torrent across the entire BitTorrent network.\n\n![Core Data Structures](./diagrams/data-model.svg)\n\nUnderstanding torrent file structure is essential because every subsequent operation in our BitTorrent client depends on this metadata. The announce URL tells us where to find other peers, the piece length and piece hashes enable us to verify downloaded data integrity, and the info hash serves as our torrent's unique fingerprint for tracker communication and peer handshakes.\n\n### Bencode: Binary JSON Analogy\n\nThink of Bencode as JSON's binary cousin designed specifically for peer-to-peer applications. Just like JSON provides a structured way to represent nested data (objects, arrays, strings, numbers), Bencode offers the same organizational capabilities but with two key differences that make it perfect for BitTorrent.\n\nFirst, Bencode handles binary data natively. While JSON struggles with binary content and requires encoding schemes like Base64, Bencode treats byte strings as first-class citizens. This matters enormously in BitTorrent because piece hashes are raw 20-byte SHA-1 digests, peer IDs contain arbitrary binary data, and the protocol frequently exchanges binary payloads. Imagine trying to represent a piece hash like `\\x12\\x34\\x56...` in JSON - you'd need encoding layers that add complexity and overhead.\n\nSecond, Bencode produces completely deterministic output. Unlike JSON, where the same data structure can be serialized in multiple valid ways (different key ordering, varied whitespace), Bencode has exactly one canonical representation for any given data structure. This determinism is crucial for computing info hashes, since the SHA-1 digest must be calculated from the exact bytes of the serialized info dictionary.\n\nThe mental model to internalize is this: **Bencode is like JSON, but designed for systems that need binary data support and cryptographic hashing**. Just as you might parse JSON to extract a web API response, we parse Bencode to extract torrent metadata. The same concepts apply - nested dictionaries become maps, arrays become lists, and values can be strings, numbers, or nested structures.\n\nBencode supports exactly four data types, mirroring the essential types found in most structured data formats:\n\n| Bencode Type | JSON Equivalent | Format | Example | Use in Torrents |\n|-------------|----------------|---------|---------|-----------------|\n| Byte String | String (but binary-safe) | `<length>:<data>` | `4:spam` | File names, piece hashes, tracker URLs |\n| Integer | Number | `i<value>e` | `i42e` | File lengths, piece length, creation date |\n| List | Array | `l<items>e` | `l4:spam3:egge` | File lists, announce list |\n| Dictionary | Object | `d<key><value>e` | `d3:cow3:moo4:spam4:eggse` | Root structure, info dict |\n\nThe elegance of Bencode lies in its simplicity. There are no null values, no floating-point numbers, no boolean types - just the minimal set of types needed to represent structured data with binary content. This simplicity makes the parser straightforward to implement while ensuring compatibility across different programming languages and platforms.\n\n### Bencode Decoder Design\n\nThe Bencode decoder uses a recursive descent parsing strategy, where each data type has a dedicated parsing method that handles its specific format. This approach mirrors how you might parse a mathematical expression by recognizing operators and recursively evaluating sub-expressions.\n\nThe core insight is that Bencode is **self-delimiting** - each encoded value contains enough information to determine where it ends. Strings begin with their length, integers are wrapped with `i` and `e` markers, and container types (lists and dictionaries) use `l`/`d` and `e` delimiters. This means our parser can read a single character to determine the upcoming data type, then delegate to the appropriate parsing method.\n\n![Bencode Parsing State Machine](./diagrams/bencode-parsing.svg)\n\nThe parsing state machine operates on a simple principle: examine the next character to determine the value type, then consume exactly the bytes needed for that value. For strings, we read digits until we hit a colon, parse the length, then read exactly that many data bytes. For integers, we consume characters between `i` and `e` markers. For containers, we recursively parse items until we encounter the closing `e`.\n\n> **Decision: Recursive Descent Parser Architecture**\n> - **Context**: Need to parse nested Bencode structures containing arbitrary nesting of lists and dictionaries\n> - **Options Considered**: Recursive descent parser, table-driven parser, hand-written state machine\n> - **Decision**: Recursive descent with method-per-type design\n> - **Rationale**: Bencode's simple grammar maps naturally to recursive methods, making the code readable and maintainable. The nesting depth is typically shallow in torrent files, so stack overflow isn't a concern.\n> - **Consequences**: Simple implementation and good error reporting, but potential stack overflow on pathological inputs\n\nThe `Decoder` struct maintains parsing state through a buffered reader that provides lookahead capabilities for type discrimination. The core `Decode` method acts as a dispatcher, examining the next byte to determine which specialized parsing method to invoke.\n\n| Method | Purpose | Input Format | Returns | Error Cases |\n|--------|---------|-------------|---------|-------------|\n| `Decode()` | Main entry point, dispatches to type-specific parsers | Any valid Bencode | `interface{}`, `error` | Invalid type prefix, EOF |\n| `decodeString()` | Parse length-prefixed byte strings | `<digits>:<data>` | `[]byte`, `error` | Invalid length, insufficient data |\n| `decodeInteger()` | Parse signed integers | `i<digits>e` | `int64`, `error` | Invalid digits, missing terminator |\n| `decodeList()` | Parse heterogeneous arrays | `l<items>e` | `[]interface{}`, `error` | Malformed items, missing terminator |\n| `decodeDictionary()` | Parse string-keyed maps | `d<pairs>e` | `map[string]interface{}`, `error` | Non-string keys, unsorted keys |\n\nThe string parsing algorithm demonstrates the careful byte handling required for binary data:\n\n1. Read decimal digits until encountering a colon character\n2. Parse the accumulated digits as the string length (validate non-negative)\n3. Allocate a byte slice of exactly that length\n4. Read exactly that many bytes from the input stream (not text lines)\n5. Return the raw byte slice without any encoding interpretation\n\nInteger parsing requires careful handling of the `i` and `e` delimiters while supporting negative values:\n\n1. Verify the current byte is `i` and advance past it\n2. Read characters until encountering `e`, accumulating digits and optional negative sign\n3. Validate the accumulated string represents a valid integer (no leading zeros except for zero itself)\n4. Parse the string as a signed 64-bit integer\n5. Consume the closing `e` delimiter\n\nList parsing showcases the recursive nature of the algorithm:\n\n1. Verify the current byte is `l` and advance past it\n2. Initialize an empty slice to accumulate parsed items\n3. While the next byte is not `e`, recursively call `Decode()` to parse the next item\n4. Append each successfully parsed item to the accumulating slice\n5. Consume the closing `e` delimiter and return the completed slice\n\nDictionary parsing adds the complexity of maintaining sorted key order and ensuring all keys are strings:\n\n1. Verify the current byte is `d` and advance past it\n2. Initialize an empty map to accumulate key-value pairs\n3. While the next byte is not `e`, parse a key-value pair:\n   - Parse the key (must be a string, return error if not)\n   - Parse the value (recursive call to `Decode()`)\n   - Verify key ordering (current key must be lexicographically greater than previous)\n   - Insert the pair into the accumulating map\n4. Consume the closing `e` delimiter and return the completed map\n\nThe key ordering validation is crucial because Bencode requires dictionary keys to appear in sorted order. This ensures deterministic serialization, which is essential for computing consistent info hashes. If we encounter keys out of order, we must reject the input as malformed.\n\n### Torrent Metadata Extraction\n\nOnce we've decoded the Bencode structure into native data types, we need to extract the specific fields that define a torrent's characteristics. Think of this process like extracting structured information from a parsed JSON API response - we know the expected schema and need to navigate the nested data to find the values we need.\n\nThe root level of every torrent file contains several key fields that serve different purposes in the BitTorrent ecosystem:\n\n| Field | Type | Required | Purpose | Example |\n|-------|------|----------|---------|---------|\n| `announce` | String | Yes | Primary tracker URL for peer discovery | `http://tracker.example.com:8080/announce` |\n| `announce-list` | List of Lists | No | Backup tracker URLs organized by tiers | `[[\"http://primary.com\"], [\"http://backup1.com\", \"http://backup2.com\"]]` |\n| `info` | Dictionary | Yes | File and piece information (used for info hash) | Contains `name`, `length`, `pieces`, etc. |\n| `creation date` | Integer | No | Unix timestamp when torrent was created | `1609459200` |\n| `comment` | String | No | Human-readable description | `\"Ubuntu 20.04.1 Desktop amd64\"` |\n| `created by` | String | No | Software that created the torrent | `\"mktorrent 1.1\"` |\n\nThe `info` dictionary contains the core file and piece information that defines what we're downloading:\n\n| Info Field | Type | Required | Purpose | Notes |\n|------------|------|----------|---------|-------|\n| `name` | String | Yes | Suggested filename or directory name | UTF-8 encoded, used for local file creation |\n| `piece length` | Integer | Yes | Size of each piece in bytes (except possibly the last) | Typically powers of 2, between 16KB and 8MB |\n| `pieces` | String | Yes | Concatenated SHA-1 hashes of all pieces | Length must be multiple of 20 bytes |\n| `length` | Integer | Single-file | Total file size in bytes | Present only for single-file torrents |\n| `files` | List | Multi-file | List of file descriptors for multi-file torrents | Each contains `length` and `path` |\n\nThe metadata extraction algorithm operates by navigating the decoded Bencode structure and type-checking each expected field:\n\n1. **Validate root structure**: Ensure the decoded result is a dictionary containing required top-level keys\n2. **Extract announce URL**: Retrieve the `announce` field as a string and validate it's a well-formed HTTP or UDP URL\n3. **Extract info dictionary**: Retrieve the `info` field as a dictionary for further processing\n4. **Extract file information**: Determine if this is a single-file or multi-file torrent and extract appropriate file metadata\n5. **Extract piece information**: Retrieve piece length and piece hashes for download verification\n6. **Extract optional fields**: Safely extract creation date, comment, and other non-critical metadata\n\n> **Decision: Single vs Multi-File Torrent Handling**\n> - **Context**: Torrents can contain either a single file (with `length` in info) or multiple files (with `files` array)\n> - **Options Considered**: Separate parsing paths for each type, normalize to common representation, support both natively\n> - **Decision**: Normalize single-file torrents to the multi-file representation internally\n> - **Rationale**: Simplifies downstream code by providing a uniform interface, while preserving all original metadata\n> - **Consequences**: Slight overhead for single-file torrents, but dramatically simplified piece and download management logic\n\nThe piece hash extraction deserves special attention because it's critical for content verification. The `pieces` field contains concatenated 20-byte SHA-1 hashes, so we must split this byte string into individual hash values:\n\n1. Validate that the pieces string length is a multiple of 20 bytes\n2. Calculate the number of pieces as `len(pieces) / 20`\n3. Iterate through the string in 20-byte chunks, extracting each piece hash\n4. Store the hashes in a slice for indexed access during downloads\n\nFor multi-file torrents, we need to process the `files` array to understand the directory structure:\n\n1. Iterate through each file descriptor in the files array\n2. Extract the file length as an integer\n3. Extract the path as a list of strings representing the directory hierarchy\n4. Validate that path components don't contain directory traversal sequences like `..`\n5. Accumulate total torrent size by summing individual file lengths\n\nThe extraction process must handle missing optional fields gracefully while strictly validating required fields. For optional fields like creation date, we check for their presence before attempting type conversion. For required fields like announce URL, we return an error if the field is missing or has the wrong type.\n\n### Info Hash Calculation\n\nThe info hash represents the cryptographic identity of a torrent - it's how trackers, peers, and clients uniquely identify the specific content being shared. Think of it as a fingerprint that's computed from the torrent's file and piece information. This 20-byte SHA-1 digest is derived not from the parsed data structure, but from the exact encoded bytes of the info dictionary as it appears in the torrent file.\n\nThis distinction is absolutely critical. We cannot simply re-encode the parsed info dictionary and compute its hash, because Bencode serialization must produce identical output to the original file. Even though Bencode is deterministic, our parser might represent the data differently than the original encoder (for example, using different string types or numeric representations).\n\n> The info hash must be computed from the original Bencode bytes, not from re-serialized parsed data. This ensures consistency across all BitTorrent clients regardless of their internal data representations.\n\nThe info hash serves multiple purposes in the BitTorrent ecosystem:\n\n| Use Case | Purpose | Why Identity Matters |\n|----------|---------|---------------------|\n| Tracker Communication | Identifies which swarm to join | Trackers group peers by info hash |\n| Peer Handshakes | Verifies peers are sharing the same content | Prevents mixing incompatible swarms |\n| DHT Lookups | Distributed hash table key for peer discovery | DHT stores peer lists keyed by info hash |\n| Magnet Links | Content identifier in magnet URIs | Allows torrent-less peer discovery |\n| Duplicate Detection | Prevents downloading same content twice | Client can identify already-downloaded torrents |\n\nThe algorithm for info hash calculation requires careful handling of the original Bencode stream:\n\n1. **Locate info dictionary boundaries**: Find the start of the info dictionary in the original Bencode data\n2. **Extract exact bytes**: Copy the complete info dictionary including its `d` and `e` delimiters\n3. **Compute SHA-1 hash**: Apply SHA-1 cryptographic hash function to these exact bytes\n4. **Store as 20-byte array**: Preserve the binary hash for use in protocol messages\n\nThe boundary location algorithm must parse the Bencode structure while tracking byte positions:\n\n1. Begin parsing at the root dictionary marker `d`\n2. Parse key-value pairs, tracking the byte offset of each key\n3. When encountering the key `\"info\"`, record the current byte position\n4. Parse the info dictionary value completely, recording the ending byte position\n5. Extract the substring from start position to end position inclusive of delimiters\n\n> **Decision: Original Bytes vs Re-encoding for Info Hash**\n> - **Context**: Need to compute SHA-1 hash of info dictionary for torrent identification\n> - **Options Considered**: Re-encode parsed data, track original bytes during parsing, separate parsing pass for hash calculation\n> - **Decision**: Track byte boundaries during initial parse to extract original info bytes\n> - **Rationale**: Guarantees hash consistency with torrent creator and other clients, avoids re-encoding complexity\n> - **Consequences**: Slightly more complex parser but ensures protocol compliance and interoperability\n\nThe implementation must handle the info dictionary as a contiguous byte slice from the original torrent file. This means our parser needs to either track byte positions during parsing or provide a method to locate dictionary boundaries after parsing is complete.\n\nA robust approach involves augmenting our Bencode decoder to track parsing positions:\n\n1. **Enhanced decoder state**: Modify the `Decoder` to track current byte position alongside the buffered reader\n2. **Boundary recording**: When parsing the root dictionary, record start and end positions for the info key's value\n3. **Byte extraction**: After successful parsing, extract the info dictionary bytes using recorded boundaries\n4. **Hash computation**: Apply SHA-1 to the extracted bytes and store the result in our `MetaInfo` structure\n\nThe info hash becomes the torrent's primary key throughout the BitTorrent protocol. It appears in tracker announce requests, peer handshake messages, and DHT queries. Every piece of communication about this torrent will reference this 20-byte identifier, making its correct calculation essential for protocol compatibility.\n\n### Common Parsing Pitfalls\n\nTorrent file parsing involves several subtle challenges that frequently trip up implementers. Understanding these pitfalls and their solutions is crucial for building a robust BitTorrent client that works correctly with real-world torrent files.\n\n⚠️ **Pitfall: Treating Bencode Strings as Text**\n\nMany developers assume Bencode strings contain UTF-8 text and attempt to decode them as such. This fails catastrophically with binary data like piece hashes, which contain arbitrary byte values that aren't valid UTF-8 sequences. The pieces field, for example, contains concatenated SHA-1 hashes that include null bytes, control characters, and invalid UTF-8 sequences.\n\n**Why it's wrong**: Bencode byte strings can contain any byte values from 0x00 to 0xFF. Attempting UTF-8 decoding will either fail with encoding errors or silently corrupt the binary data through replacement characters.\n\n**How to fix**: Always handle Bencode strings as raw byte slices (`[]byte` in Go). Only convert to text strings when you're certain the content is textual (like file names) and need to display it to users. For protocol fields like piece hashes and peer IDs, preserve the binary representation.\n\n⚠️ **Pitfall: Incorrect Info Dictionary Boundary Detection**\n\nComputing the info hash requires extracting the exact bytes of the info dictionary from the original torrent file. A common mistake is attempting to find these boundaries through string searching or regex matching, which fails when the info dictionary contains binary data that happens to include the search patterns.\n\n**Why it's wrong**: String-based searches can match content inside binary fields, leading to incorrect boundary detection. For example, searching for the byte sequence `\"e\"` to find the dictionary end might match a byte inside a piece hash.\n\n**How to fix**: Parse the Bencode structure properly while tracking byte positions. The parser understands the structure and can correctly identify where the info dictionary begins and ends, even when it contains arbitrary binary data.\n\n⚠️ **Pitfall: Ignoring Dictionary Key Ordering Requirements**\n\nBencode requires dictionary keys to appear in lexicographically sorted order. Some implementations skip this validation, accepting malformed torrent files that would be rejected by other clients. This can lead to info hash mismatches when different clients compute hashes from differently-ordered data.\n\n**Why it's wrong**: The Bencode specification mandates key ordering to ensure deterministic serialization. Accepting out-of-order keys means your client might compute different info hashes than other clients for the same logical content.\n\n**How to fix**: Validate key ordering during dictionary parsing. Maintain the previous key and ensure each new key is lexicographically greater. Reject torrent files with misordered keys as malformed.\n\n⚠️ **Pitfall: Integer Parsing Edge Cases**\n\nBencode integer parsing has several edge cases that naive implementations handle incorrectly. These include leading zeros (forbidden except for zero itself), empty integer fields, and very large numbers that exceed language-specific integer ranges.\n\n**Why it's wrong**: Incorrect integer parsing can lead to wrong file sizes, piece lengths, or creation dates. More critically, accepting malformed integers that other clients reject can cause protocol incompatibilities.\n\n**How to fix**: Implement strict integer validation:\n- Reject integers with leading zeros except for `i0e`\n- Reject empty integers like `ie`\n- Handle potential overflow for very large file sizes\n- Validate that integers are well-formed decimal numbers\n\n⚠️ **Pitfall: Path Traversal in Multi-File Torrents**\n\nMulti-file torrents specify file paths as arrays of path components. Malicious torrent files might include path components like `\"..\"` that could cause files to be written outside the intended download directory, potentially overwriting system files.\n\n**Why it's wrong**: Path traversal attacks can compromise the user's system by overwriting arbitrary files. A torrent containing a file path like `[\".\", \".\", \".\", \"etc\", \"passwd\"]` could overwrite `/etc/passwd` on Unix systems.\n\n**How to fix**: Validate all path components during metadata extraction:\n- Reject path components that are `\".\"` or `\"..\"`\n- Reject absolute paths that start with `/` or drive letters\n- Sanitize path components to remove dangerous characters\n- Construct file paths within a designated download directory\n\n⚠️ **Pitfall: Piece Hash Count Validation**\n\nThe pieces field contains concatenated SHA-1 hashes, so its length must be a multiple of 20 bytes. However, you also need to validate that the number of piece hashes matches the expected count based on total file size and piece length.\n\n**Why it's wrong**: Accepting torrents with incorrect piece counts can lead to downloads that can never complete (missing pieces) or buffer overruns when accessing piece hashes by index.\n\n**How to fix**: Calculate expected piece count and validate consistency:\n- Compute expected pieces as `ceil(total_file_size / piece_length)`\n- Verify that `len(pieces) / 20 == expected_piece_count`\n- Reject torrents where the piece hash count doesn't match the calculated requirement\n\n⚠️ **Pitfall: Memory Exhaustion on Large Torrents**\n\nVery large torrents can contain millions of pieces, each requiring a 20-byte hash. Loading all piece hashes into memory simultaneously might exhaust available RAM for torrents containing terabytes of data.\n\n**Why it's wrong**: Memory exhaustion can crash your client or make the system unresponsive. A 1TB torrent with 256KB pieces requires about 80MB just for piece hashes.\n\n**How to fix**: For very large torrents, consider streaming piece hash access rather than loading everything into memory. Implement lazy loading where piece hashes are read from the torrent file as needed, or use memory-mapped files for efficient access without full loading.\n\n### Implementation Guidance\n\nThis subsection provides the concrete Go implementation infrastructure needed to parse torrent files and extract metadata. The focus is on providing complete, working code for supporting components while leaving the core learning objectives as exercises for implementation.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| File I/O | `os.File` with `io.Reader` interface | Memory-mapped files with `golang.org/x/exp/mmap` |\n| Hash Computation | `crypto/sha1` standard library | Streaming hash computation for large files |\n| Error Handling | Basic `error` returns with wrapped context | Structured error types with error codes |\n| Testing | Table-driven tests with `testing` package | Property-based testing with `github.com/leanovate/gopter` |\n| Logging | Standard `log` package for debugging | Structured logging with `github.com/sirupsen/logrus` |\n\n#### Recommended File Structure\n\n```\nproject-root/\n├── cmd/\n│   └── torrent/\n│       └── main.go              ← CLI entry point for testing\n├── internal/\n│   ├── bencode/\n│   │   ├── decoder.go           ← Core bencode parsing logic\n│   │   ├── decoder_test.go      ← Unit tests for decoder\n│   │   └── types.go             ← Bencode type constants\n│   ├── torrent/\n│   │   ├── metainfo.go          ← Torrent metadata structures\n│   │   ├── parser.go            ← High-level torrent file parsing\n│   │   ├── parser_test.go       ← Integration tests with real torrents\n│   │   └── infohash.go          ← Info hash calculation utilities\n│   └── testdata/\n│       ├── single-file.torrent  ← Test torrent files\n│       ├── multi-file.torrent\n│       └── invalid-*.torrent    ← Malformed files for error testing\n└── go.mod\n```\n\n#### Infrastructure Starter Code\n\n**File: `internal/bencode/types.go` (Complete - Ready to Use)**\n\n```go\npackage bencode\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// BencodeType represents the four fundamental Bencode data types\ntype BencodeType int\n\nconst (\n\tTypeString BencodeType = iota\n\tTypeInteger\n\tTypeList\n\tTypeDictionary\n)\n\n// Common Bencode parsing errors\nvar (\n\tErrInvalidType       = errors.New(\"invalid bencode type marker\")\n\tErrUnexpectedEOF     = errors.New(\"unexpected end of input\")\n\tErrInvalidInteger    = errors.New(\"invalid integer format\")\n\tErrInvalidLength     = errors.New(\"invalid string length\")\n\tErrUnsortedKeys      = errors.New(\"dictionary keys not in sorted order\")\n\tErrNonStringKey      = errors.New(\"dictionary key is not a string\")\n\tErrInsufficientData  = errors.New(\"insufficient data for declared length\")\n)\n\n// ParseError wraps parsing errors with position information\ntype ParseError struct {\n\tOffset int\n\tErr    error\n}\n\nfunc (e *ParseError) Error() string {\n\treturn fmt.Sprintf(\"bencode parse error at offset %d: %v\", e.Offset, e.Err)\n}\n\nfunc (e *ParseError) Unwrap() error {\n\treturn e.Err\n}\n\n// IsValidInteger checks if a string represents a valid Bencode integer\nfunc IsValidInteger(s string) bool {\n\tif len(s) == 0 {\n\t\treturn false\n\t}\n\t\n\t// Handle negative numbers\n\tstart := 0\n\tif s[0] == '-' {\n\t\tif len(s) == 1 {\n\t\t\treturn false // Just \"-\" is invalid\n\t\t}\n\t\tstart = 1\n\t}\n\t\n\t// Check for leading zeros (forbidden except for \"0\" itself)\n\tif s[start] == '0' && len(s) > start+1 {\n\t\treturn false\n\t}\n\t\n\t// Verify all remaining characters are digits\n\tfor i := start; i < len(s); i++ {\n\t\tif s[i] < '0' || s[i] > '9' {\n\t\t\treturn false\n\t\t}\n\t}\n\t\n\treturn true\n}\n```\n\n**File: `internal/torrent/metainfo.go` (Complete - Ready to Use)**\n\n```go\npackage torrent\n\nimport (\n\t\"crypto/sha1\"\n\t\"time\"\n)\n\n// MetaInfo represents the complete torrent file metadata\ntype MetaInfo struct {\n\tAnnounce     string     `json:\"announce\"`\n\tAnnounceList [][]string `json:\"announce_list,omitempty\"`\n\tCreationDate time.Time  `json:\"creation_date,omitempty\"`\n\tComment      string     `json:\"comment,omitempty\"`\n\tCreatedBy    string     `json:\"created_by,omitempty\"`\n\tInfoHash     [20]byte   `json:\"info_hash\"`\n\tInfo         Info       `json:\"info\"`\n}\n\n// Info represents the info dictionary containing file and piece data\ntype Info struct {\n\tName        string `json:\"name\"`\n\tLength      int64  `json:\"length,omitempty\"`      // Single-file torrents only\n\tFiles       []File `json:\"files,omitempty\"`       // Multi-file torrents only\n\tPieceLength int64  `json:\"piece_length\"`\n\tPieces      []byte `json:\"pieces\"`                // Concatenated SHA-1 hashes\n}\n\n// File represents a single file in a multi-file torrent\ntype File struct {\n\tLength int64    `json:\"length\"`\n\tPath   []string `json:\"path\"`\n}\n\n// GetPieceHashes extracts individual piece hashes from the concatenated pieces field\nfunc (info *Info) GetPieceHashes() [][20]byte {\n\tconst PIECE_HASH_SIZE = 20\n\tnumPieces := len(info.Pieces) / PIECE_HASH_SIZE\n\thashes := make([][20]byte, numPieces)\n\t\n\tfor i := 0; i < numPieces; i++ {\n\t\tstart := i * PIECE_HASH_SIZE\n\t\tcopy(hashes[i][:], info.Pieces[start:start+PIECE_HASH_SIZE])\n\t}\n\t\n\treturn hashes\n}\n\n// TotalLength calculates the total size of all files in the torrent\nfunc (info *Info) TotalLength() int64 {\n\tif info.Length > 0 {\n\t\t// Single-file torrent\n\t\treturn info.Length\n\t}\n\t\n\t// Multi-file torrent - sum all file lengths\n\ttotal := int64(0)\n\tfor _, file := range info.Files {\n\t\ttotal += file.Length\n\t}\n\treturn total\n}\n\n// ExpectedPieceCount calculates how many pieces this torrent should have\nfunc (info *Info) ExpectedPieceCount() int {\n\ttotalLength := info.TotalLength()\n\treturn int((totalLength + info.PieceLength - 1) / info.PieceLength) // Ceiling division\n}\n\n// ValidatePieceHashes checks that the piece hash count matches expected\nfunc (info *Info) ValidatePieceHashes() error {\n\tconst PIECE_HASH_SIZE = 20\n\t\n\tif len(info.Pieces)%PIECE_HASH_SIZE != 0 {\n\t\treturn errors.New(\"pieces field length is not a multiple of 20\")\n\t}\n\t\n\tactualCount := len(info.Pieces) / PIECE_HASH_SIZE\n\texpectedCount := info.ExpectedPieceCount()\n\t\n\tif actualCount != expectedCount {\n\t\treturn fmt.Errorf(\"piece hash count mismatch: got %d, expected %d\", \n\t\t\tactualCount, expectedCount)\n\t}\n\t\n\treturn nil\n}\n```\n\n#### Core Logic Skeleton Code\n\n**File: `internal/bencode/decoder.go` (Skeleton - Implement the TODOs)**\n\n```go\npackage bencode\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"strconv\"\n)\n\n// Decoder handles parsing of Bencode data streams\ntype Decoder struct {\n\treader *bufio.Reader\n\toffset int // Track current byte position for error reporting\n}\n\n// NewDecoder creates a new Bencode decoder for the given reader\nfunc NewDecoder(r io.Reader) *Decoder {\n\treturn &Decoder{\n\t\treader: bufio.NewReader(r),\n\t\toffset: 0,\n\t}\n}\n\n// Decode parses the next Bencode value from the stream\n// Returns the parsed value as interface{} - caller must type assert\nfunc (d *Decoder) Decode() (interface{}, error) {\n\t// TODO 1: Peek at the next byte to determine value type\n\t// TODO 2: Dispatch to appropriate parsing method based on type:\n\t//         - '0'-'9': string (starts with length digits)\n\t//         - 'i': integer\n\t//         - 'l': list  \n\t//         - 'd': dictionary\n\t// TODO 3: Return ParseError with offset information for invalid types\n\t// Hint: Use d.reader.Peek(1) to look ahead without consuming\n\tpanic(\"implement me\")\n}\n\n// decodeString parses a Bencode string in format \"length:data\"\nfunc (d *Decoder) decodeString() ([]byte, error) {\n\t// TODO 1: Read decimal digits until hitting ':' character\n\t// TODO 2: Parse the accumulated digits as string length\n\t// TODO 3: Validate length is non-negative using IsValidInteger\n\t// TODO 4: Read exactly that many bytes as the string data\n\t// TODO 5: Return the raw bytes (don't convert to text)\n\t// Hint: Use d.readUntil(':') helper and strconv.Atoi for parsing\n\tpanic(\"implement me\")\n}\n\n// decodeInteger parses a Bencode integer in format \"i<number>e\"\nfunc (d *Decoder) decodeInteger() (int64, error) {\n\t// TODO 1: Verify next byte is 'i' and consume it\n\t// TODO 2: Read characters until 'e', accumulating the number string\n\t// TODO 3: Validate integer format using IsValidInteger (no leading zeros)\n\t// TODO 4: Parse as int64 and handle potential overflow\n\t// TODO 5: Consume the closing 'e' delimiter\n\t// Hint: Use d.readUntil('e') and strconv.ParseInt\n\tpanic(\"implement me\")\n}\n\n// decodeList parses a Bencode list in format \"l<items>e\"\nfunc (d *Decoder) decodeList() ([]interface{}, error) {\n\t// TODO 1: Verify next byte is 'l' and consume it\n\t// TODO 2: Initialize empty slice for accumulating items\n\t// TODO 3: Loop while next byte is not 'e':\n\t//         - Recursively call Decode() for each item\n\t//         - Append successful results to slice\n\t// TODO 4: Consume closing 'e' delimiter\n\t// TODO 5: Return completed slice\n\t// Hint: Check d.peekByte() != 'e' for loop condition\n\tpanic(\"implement me\")\n}\n\n// decodeDictionary parses a Bencode dictionary in format \"d<pairs>e\"\nfunc (d *Decoder) decodeDictionary() (map[string]interface{}, error) {\n\t// TODO 1: Verify next byte is 'd' and consume it\n\t// TODO 2: Initialize empty map and previousKey for sorting validation\n\t// TODO 3: Loop while next byte is not 'e':\n\t//         - Parse key (must be string type)\n\t//         - Validate key is lexicographically > previousKey\n\t//         - Parse value (recursive Decode() call)\n\t//         - Insert key-value pair into map\n\t// TODO 4: Consume closing 'e' delimiter\n\t// TODO 5: Return completed map\n\t// Hint: Use string comparison for key ordering validation\n\tpanic(\"implement me\")\n}\n\n// Helper methods (Complete - Ready to Use)\n\nfunc (d *Decoder) readByte() (byte, error) {\n\tb, err := d.reader.ReadByte()\n\tif err == nil {\n\t\td.offset++\n\t}\n\treturn b, err\n}\n\nfunc (d *Decoder) peekByte() (byte, error) {\n\tbytes, err := d.reader.Peek(1)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn bytes[0], nil\n}\n\nfunc (d *Decoder) readUntil(delimiter byte) (string, error) {\n\tvar result []byte\n\tfor {\n\t\tb, err := d.readByte()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif b == delimiter {\n\t\t\tbreak\n\t\t}\n\t\tresult = append(result, b)\n\t}\n\treturn string(result), nil\n}\n```\n\n**File: `internal/torrent/parser.go` (Skeleton - Implement the TODOs)**\n\n```go\npackage torrent\n\nimport (\n\t\"crypto/sha1\"\n\t\"os\"\n\t\"time\"\n\t\"your-project/internal/bencode\"\n)\n\n// ParseFromFile reads and parses a torrent file from disk\nfunc ParseFromFile(filepath string) (*MetaInfo, error) {\n\t// TODO 1: Open the torrent file for reading\n\t// TODO 2: Create a Bencode decoder for the file\n\t// TODO 3: Parse the complete Bencode structure\n\t// TODO 4: Extract metadata using extractMetaInfo\n\t// TODO 5: Calculate info hash from original file bytes\n\t// Hint: You'll need to re-read the file to get original info bytes\n\tpanic(\"implement me\")\n}\n\n// extractMetaInfo converts decoded Bencode data to MetaInfo struct\nfunc extractMetaInfo(decoded interface{}) (*MetaInfo, error) {\n\t// TODO 1: Type assert root as map[string]interface{}\n\t// TODO 2: Extract required 'announce' field as string\n\t// TODO 3: Extract required 'info' dictionary\n\t// TODO 4: Extract optional fields (announce-list, creation date, comment)\n\t// TODO 5: Parse the info dictionary using extractInfo\n\t// TODO 6: Validate extracted metadata for consistency\n\t// Hint: Use type assertion with ok pattern: value, ok := data.(string)\n\tpanic(\"implement me\")\n}\n\n// extractInfo converts decoded info dictionary to Info struct\nfunc extractInfo(infoDict interface{}) (Info, error) {\n\t// TODO 1: Type assert as map[string]interface{}\n\t// TODO 2: Extract required fields: name, piece length, pieces\n\t// TODO 3: Determine single-file vs multi-file by checking for 'files' field\n\t// TODO 4: For single-file: extract 'length' field\n\t// TODO 5: For multi-file: extract 'files' array and process each file\n\t// TODO 6: Validate piece length and pieces field format\n\t// TODO 7: Return populated Info struct\n\t// Hint: Check for 'files' field presence to determine torrent type\n\tpanic(\"implement me\")\n}\n\n// CalculateInfoHash computes SHA-1 hash of the info dictionary bytes\nfunc CalculateInfoHash(torrentData []byte) ([20]byte, error) {\n\t// TODO 1: Parse Bencode to find info dictionary boundaries\n\t// TODO 2: Extract exact bytes of info dict including 'd' and 'e' delimiters\n\t// TODO 3: Compute SHA-1 hash of those exact bytes\n\t// TODO 4: Return as 20-byte array\n\t// Hint: Need to track byte positions during parsing to extract original bytes\n\tpanic(\"implement me\")\n}\n```\n\n#### Language-Specific Hints\n\n**Go-Specific Implementation Tips:**\n\n- Use `bufio.Reader` for efficient parsing with lookahead capabilities via `Peek()`\n- Handle binary data with `[]byte` slices - never convert to `string` unless displaying to users\n- Use `strconv.ParseInt()` with base 10 for integer parsing with overflow detection\n- Implement error wrapping with `fmt.Errorf(\"context: %w\", originalError)` for better debugging\n- Use type assertions with the two-value form: `value, ok := data.(string)` to avoid panics\n- Apply `crypto/sha1.Sum()` for hash calculation - it returns `[20]byte` directly\n- Consider using `os.Open()` with `defer file.Close()` for proper resource management\n\n**Common Go Gotchas in This Context:**\n\n- String vs `[]byte` confusion: Bencode \"strings\" are binary data, use `[]byte`\n- Integer overflow: Use `int64` for all numeric fields to handle large files\n- Map iteration order: Go maps have random iteration order, but Bencode requires sorted keys during encoding\n- Error handling: Always check errors from I/O operations before using results\n- Type assertions: Failed type assertions panic unless using the two-value form\n\n#### Milestone Checkpoint\n\nAfter implementing the core parsing logic, verify your implementation with these tests:\n\n**Test Command:**\n```bash\ncd internal/bencode && go test -v\ncd ../torrent && go test -v\n```\n\n**Expected Behavior:**\n1. **Bencode decoder tests pass**: All four value types parse correctly, edge cases are handled\n2. **Torrent parsing integration test**: Parse a real torrent file and extract metadata\n3. **Info hash consistency**: Calculate same info hash as other BitTorrent clients for the same torrent\n\n**Manual Verification Steps:**\n1. Download a simple torrent file (like Ubuntu ISO) from a legitimate source\n2. Parse it with your implementation: `go run cmd/torrent/main.go parse ubuntu.torrent`\n3. Expected output should show:\n   - Announce URL (HTTP tracker)\n   - File name and size matching the actual ISO\n   - Piece count and piece length (typically 512KB to 4MB for large files)\n   - Valid 40-character hex info hash\n4. Compare info hash with another BitTorrent client - they should match exactly\n\n**Signs Something Is Wrong:**\n| Symptom | Likely Cause | How to Debug | Fix |\n|---------|--------------|--------------|-----|\n| Parse errors on valid torrents | Bencode decoder bugs | Test each type separately | Review string/integer parsing logic |\n| Info hash doesn't match other clients | Using re-encoded bytes instead of original | Print hash input bytes | Extract exact original info dict bytes |\n| Piece count validation fails | Incorrect total size calculation | Check multi-file length summing | Verify Files vs Length handling |\n| Panic on type assertions | Missing error handling | Add two-value type assertions | Use `value, ok := data.(type)` pattern |\n\n\n## Tracker Communication (Milestone 2)\n\n> **Milestone(s):** This section corresponds to Milestone 2 - Tracker Communication, implementing HTTP tracker protocol for peer discovery with proper URL encoding and response parsing.\n\nAfter successfully parsing a torrent file and extracting its metadata, our BitTorrent client faces a fundamental challenge: finding other peers who have the same file. Unlike a traditional client-server model where you simply connect to a known server, BitTorrent operates as a decentralized peer-to-peer network. The **tracker** serves as the coordination point that helps peers discover each other, acting as a matchmaker in the distributed file-sharing ecosystem.\n\n### Tracker as Matchmaking Service\n\nThink of a BitTorrent tracker as a sophisticated dating app for files. Just as a dating app helps people with similar interests find each other, a tracker helps peers interested in the same files discover and connect to one another. When you join a dating app, you create a profile describing yourself and what you're looking for. Similarly, when your BitTorrent client contacts a tracker, it announces its identity, what file it wants (identified by the info hash), and its current status (how much it has downloaded, uploaded, and how much is left).\n\nThe dating app doesn't store the actual conversations between matched users—it just facilitates the initial introduction. Likewise, the tracker doesn't participate in the actual file transfer. It simply maintains a registry of peers interested in each torrent and provides peer lists when requested. The tracker knows which peers are actively participating in a swarm (the collection of all peers sharing a particular torrent), their network addresses, and their current participation status.\n\nThis analogy extends to the periodic check-ins that both systems require. Dating apps might ask you to update your profile or confirm you're still active. Similarly, BitTorrent clients must periodically re-announce to the tracker, reporting their progress and confirming they're still participating in the swarm. This prevents the tracker from serving stale peer information and ensures an accurate view of swarm health.\n\nThe tracker protocol is intentionally lightweight and stateless. The tracker doesn't need to remember complex state about each peer—it simply maintains a current snapshot of who's interested in what files and their network coordinates. This simplicity allows trackers to serve thousands of concurrent torrents and handle massive swarms efficiently.\n\n### Announce Request Protocol\n\nThe **announce request** is the fundamental communication mechanism between BitTorrent clients and trackers. This HTTP GET request follows a specific format defined by the BitTorrent protocol specification, carrying essential information about the client's current state and requesting a list of peers participating in the same swarm.\n\nThe announce URL construction begins with the base tracker URL extracted from the torrent file's `announce` field. To this base URL, we append a query string containing several required parameters that inform the tracker about our client's current status and capabilities.\n\n| Parameter | Type | Description | Encoding Requirements |\n|-----------|------|-------------|----------------------|\n| `info_hash` | 20-byte binary | SHA-1 hash identifying the torrent | URL-encoded binary data |\n| `peer_id` | 20-byte binary | Unique identifier for our client instance | URL-encoded binary data |\n| `port` | Integer | TCP port our client listens on for peer connections | Decimal string |\n| `uploaded` | Integer | Total bytes uploaded to other peers | Decimal string |\n| `downloaded` | Integer | Total bytes downloaded from other peers | Decimal string |\n| `left` | Integer | Bytes remaining to complete the download | Decimal string |\n| `compact` | Integer | Request compact peer list format (always 1) | Literal \"1\" |\n| `event` | String | Current client state transition | \"started\", \"completed\", \"stopped\", or omitted |\n\nThe most critical aspect of announce request construction is proper URL encoding of binary parameters. The `info_hash` and `peer_id` are 20-byte binary values that must be percent-encoded for HTTP transmission. Each byte that is not a unreserved character (alphanumeric, hyphen, underscore, period, or tilde) must be represented as `%XX` where XX is the hexadecimal representation of the byte value.\n\n> **Decision: HTTP GET vs POST for Announce Requests**\n> - **Context**: The BitTorrent specification allows both GET and POST methods for announce requests, requiring implementers to choose an approach\n> - **Options Considered**: HTTP GET with query parameters, HTTP POST with form data, HTTP POST with request body\n> - **Decision**: Use HTTP GET with query parameters\n> - **Rationale**: GET requests are simpler to implement, debug, and cache. They're stateless and idempotent by nature, matching the tracker protocol's design. Most existing trackers expect GET requests, ensuring maximum compatibility\n> - **Consequences**: URL length limitations could theoretically be an issue with very long announce URLs, but in practice BitTorrent announce requests are well within browser and server URL limits\n\nThe `event` parameter deserves special attention as it communicates significant state changes to the tracker. When a client first starts downloading a torrent, it sends `event=started` to announce its entry into the swarm. Upon completing the download, it sends `event=completed` to indicate it's now seeding. When shutting down gracefully, it sends `event=stopped` to allow the tracker to remove it from the peer list immediately rather than waiting for a timeout.\n\nAnnounce requests also serve as a progress reporting mechanism. The `uploaded`, `downloaded`, and `left` fields allow the tracker to maintain statistics about swarm health and individual peer contribution. Some trackers use this information for ratio enforcement or to provide preferential treatment to peers who contribute more upload bandwidth.\n\nThe `compact` parameter requests that the tracker return peer information in a space-efficient binary format rather than a more verbose dictionary format. This compact format reduces bandwidth usage and parsing overhead, making it the preferred approach for production implementations.\n\nHere's the step-by-step process for constructing and sending an announce request:\n\n1. Extract the base announce URL from the torrent's `MetaInfo.Announce` field\n2. Generate a unique 20-byte `peer_id` for this client session (commonly using a prefix identifying the client software followed by random bytes)\n3. Calculate current progress values: bytes uploaded, downloaded, and remaining\n4. URL-encode the binary `info_hash` and `peer_id` values using percent-encoding\n5. Construct the query string by concatenating all parameters with proper separators\n6. Append the query string to the base URL and send an HTTP GET request\n7. Parse the response to extract peer information and tracker guidance\n\n### Peer List Response Parsing\n\nThe tracker's response to an announce request contains critical information for peer discovery and swarm coordination. This response is encoded using the same Bencode format used for torrent files, requiring our existing decoder to parse the structured data.\n\n| Response Field | Type | Description | Required |\n|----------------|------|-------------|----------|\n| `interval` | Integer | Seconds to wait before next announce | Yes |\n| `complete` | Integer | Number of peers with complete file (seeders) | No |\n| `incomplete` | Integer | Number of peers still downloading (leechers) | No |\n| `peers` | Binary String | Compact peer list in 6-byte format | Yes |\n| `failure reason` | String | Error message if request failed | Only on failure |\n\nThe most important field is the `peers` binary string, which contains a concatenated list of peer network addresses in compact format. Each peer is represented by exactly 6 bytes: 4 bytes for the IPv4 address followed by 2 bytes for the port number, both in network byte order (big-endian).\n\nParsing the compact peer list requires careful handling of binary data and endianness conversion:\n\n1. Verify the peers field length is a multiple of 6 bytes (each peer requires exactly 6 bytes)\n2. Iterate through the binary data in 6-byte chunks\n3. Extract bytes 0-3 as the IPv4 address in network byte order\n4. Extract bytes 4-5 as the port number in network byte order\n5. Convert the port from big-endian to host byte order\n6. Create a `PeerInfo` structure containing the IP address and port\n\nThe `interval` field specifies how long the client should wait before making the next announce request. This prevents clients from overwhelming the tracker with excessive requests while ensuring the tracker maintains reasonably current swarm information. Typical intervals range from 15 minutes to several hours, with shorter intervals used for more active torrents.\n\n> **Critical Implementation Detail**: The compact peer format uses network byte order (big-endian) for both IP addresses and port numbers. Many programming languages use host byte order internally, requiring explicit conversion using functions like `binary.BigEndian.Uint16()` in Go or `socket.ntohs()` in C. Failure to perform this conversion results in incorrect peer addresses and connection failures.\n\nThe `complete` and `incomplete` fields provide valuable swarm health information. `complete` indicates the number of seeders (peers with the complete file), while `incomplete` shows the number of leechers (peers still downloading). This information helps clients assess download viability—a torrent with no seeders cannot be completed, while one with many seeders typically offers faster download speeds.\n\n**Re-announce scheduling** is crucial for maintaining accurate peer lists and swarm participation. The client must track the time of the last announce and schedule the next one based on the tracker's `interval` response. This scheduling should account for network delays and provide some jitter to prevent all clients from announcing simultaneously.\n\nThe re-announce process follows this algorithm:\n\n1. Record the timestamp of the successful announce response\n2. Extract the `interval` value from the tracker response\n3. Schedule the next announce for `current_time + interval + random_jitter`\n4. Use a small random jitter (±10% of interval) to distribute load\n5. Include updated progress statistics in the next announce request\n6. Reset the schedule if any announce request fails, implementing exponential backoff\n\n### Tracker Error Handling\n\nRobust tracker communication requires comprehensive error handling to deal with network failures, server errors, and protocol violations. The distributed nature of BitTorrent means that tracker failures should not prevent file downloads—clients must gracefully degrade and continue operating with cached peer information.\n\n| Failure Mode | Detection Method | Recovery Strategy | Retry Timing |\n|--------------|------------------|-------------------|--------------|\n| Network timeout | HTTP request timeout | Exponential backoff retry | 30s, 60s, 120s, 300s |\n| HTTP error status | 4xx/5xx response codes | Check failure reason, retry with backoff | Based on status code |\n| Invalid response format | Bencode parsing failure | Log error, use cached peers | Next scheduled interval |\n| Tracker failure reason | \"failure reason\" field in response | Log reason, retry with backoff | 5min, 15min, 30min |\n| DNS resolution failure | Domain name lookup failure | Retry with exponential backoff | 60s, 300s, 900s |\n| Connection refused | TCP connection failure | Assume temporary failure, retry | 30s, 120s, 300s |\n\n**Network timeout handling** requires careful balance between responsiveness and resource usage. Tracker requests should have reasonable timeouts (typically 30-60 seconds) to detect unresponsive servers without blocking the client indefinitely. When timeouts occur, implement exponential backoff with jitter to avoid overwhelming recovering servers.\n\n**HTTP error response handling** depends on the specific status code received. 4xx errors typically indicate client-side issues (malformed requests, invalid info hashes) that won't resolve with retries, while 5xx errors suggest server-side problems that may be temporary. The client should distinguish between these cases and adjust retry behavior accordingly.\n\n**Malformed response handling** occurs when the tracker returns data that doesn't conform to the expected Bencode format or contains invalid peer information. Rather than crashing, the client should log the error details and continue operating with previously cached peer information. This allows downloads to continue even when trackers misbehave.\n\n> **Design Principle**: Graceful degradation is fundamental to BitTorrent's robustness. The protocol is designed to continue functioning even when central infrastructure (like trackers) fails. Clients should never become completely non-functional due to tracker issues.\n\n**Exponential backoff implementation** prevents clients from overwhelming failing trackers while still attempting recovery. The backoff algorithm should:\n\n1. Start with a base delay (e.g., 30 seconds) after the first failure\n2. Double the delay after each subsequent failure, up to a maximum (e.g., 30 minutes)\n3. Add random jitter (±25% of the delay) to prevent thundering herd effects\n4. Reset to the base delay after any successful request\n5. Continue attempting indefinitely, as trackers may recover after extended outages\n\n**Alternative tracker support** enhances reliability when torrents specify multiple tracker URLs in the `announce-list` field. The client should try trackers in order, falling back to alternatives when the primary tracker fails. This requires tracking the health of each tracker and implementing intelligent failover logic.\n\nThe failover algorithm proceeds as follows:\n\n1. Attempt to contact the primary tracker from `announce` field\n2. If the primary tracker fails, iterate through `announce-list` tiers\n3. Within each tier, try trackers in random order to distribute load\n4. Mark trackers as failed after multiple consecutive failures\n5. Periodically retry failed trackers to detect when they recover\n6. Prefer trackers that have recently provided successful responses\n\n### Implementation Guidance\n\nThis subsection provides concrete implementation details for the tracker communication system, including complete working code for HTTP transport and response parsing, plus detailed skeletons for the core tracker protocol logic.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| HTTP Client | `net/http.Client` with custom timeout | `net/http.Client` with retry middleware and connection pooling |\n| URL Encoding | `url.QueryEscape()` for individual parameters | Custom percent-encoding for binary data compliance |\n| Response Parsing | Reuse existing Bencode decoder | Streaming Bencode parser for large peer lists |\n| Concurrency | Single goroutine with timer-based scheduling | Worker pool with priority queue for multiple trackers |\n| Error Handling | Simple retry with fixed delays | Exponential backoff with jitter and circuit breaker |\n\n#### Recommended File Structure\n\n```\ninternal/tracker/\n  client.go              ← main tracker client implementation\n  client_test.go         ← unit tests for tracker communication\n  announce.go            ← announce request/response structures\n  peers.go               ← peer list parsing and management\n  errors.go              ← tracker-specific error types\ncmd/torrent-client/\n  main.go                ← integrates tracker client with overall application\n```\n\n#### Infrastructure Code: HTTP Client and URL Encoding\n\n```go\n// Package tracker provides BitTorrent tracker communication functionality\npackage tracker\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"net/url\"\n    \"time\"\n)\n\n// HTTPClient wraps net/http.Client with BitTorrent-specific configuration\ntype HTTPClient struct {\n    client *http.Client\n}\n\n// NewHTTPClient creates an HTTP client configured for tracker communication\nfunc NewHTTPClient() *HTTPClient {\n    return &HTTPClient{\n        client: &http.Client{\n            Timeout: 30 * time.Second,\n            Transport: &http.Transport{\n                MaxIdleConns:        10,\n                IdleConnTimeout:     30 * time.Second,\n                DisableCompression:  true, // Bencode responses don't compress well\n                MaxIdleConnsPerHost: 2,\n            },\n        },\n    }\n}\n\n// Get performs an HTTP GET request with proper error handling\nfunc (h *HTTPClient) Get(ctx context.Context, url string) ([]byte, error) {\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, fmt.Errorf(\"creating request: %w\", err)\n    }\n\n    // Set User-Agent to identify our BitTorrent client\n    req.Header.Set(\"User-Agent\", \"go-torrent-client/1.0\")\n\n    resp, err := h.client.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"executing request: %w\", err)\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"HTTP error: %d %s\", resp.StatusCode, resp.Status)\n    }\n\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return nil, fmt.Errorf(\"reading response body: %w\", err)\n    }\n\n    return body, nil\n}\n\n// URLEncodeBinary performs percent-encoding for binary data (info_hash and peer_id)\n// This is more strict than url.QueryEscape() to ensure BitTorrent compatibility\nfunc URLEncodeBinary(data []byte) string {\n    result := make([]byte, 0, len(data)*3) // Worst case: all bytes need encoding\n    \n    for _, b := range data {\n        // Unreserved characters: A-Z, a-z, 0-9, -, _, ., ~\n        if (b >= 'A' && b <= 'Z') || (b >= 'a' && b <= 'z') || \n           (b >= '0' && b <= '9') || b == '-' || b == '_' || \n           b == '.' || b == '~' {\n            result = append(result, b)\n        } else {\n            result = append(result, '%')\n            result = append(result, \"0123456789ABCDEF\"[b>>4])\n            result = append(result, \"0123456789ABCDEF\"[b&15])\n        }\n    }\n    \n    return string(result)\n}\n\n// BackoffScheduler implements exponential backoff for failed requests\ntype BackoffScheduler struct {\n    baseDelay    time.Duration\n    maxDelay     time.Duration\n    currentDelay time.Duration\n    failures     int\n}\n\n// NewBackoffScheduler creates a scheduler with sensible defaults for tracker communication\nfunc NewBackoffScheduler() *BackoffScheduler {\n    return &BackoffScheduler{\n        baseDelay:    30 * time.Second,\n        maxDelay:     30 * time.Minute,\n        currentDelay: 30 * time.Second,\n    }\n}\n\n// OnFailure records a failure and returns the next delay duration\nfunc (b *BackoffScheduler) OnFailure() time.Duration {\n    b.failures++\n    \n    // Exponential backoff with jitter\n    jitter := time.Duration(float64(b.currentDelay) * 0.1 * (2*rand.Float64() - 1))\n    delay := b.currentDelay + jitter\n    \n    // Double for next time, up to maximum\n    b.currentDelay *= 2\n    if b.currentDelay > b.maxDelay {\n        b.currentDelay = b.maxDelay\n    }\n    \n    return delay\n}\n\n// OnSuccess resets the backoff state after a successful request\nfunc (b *BackoffScheduler) OnSuccess() {\n    b.failures = 0\n    b.currentDelay = b.baseDelay\n}\n```\n\n#### Core Data Structures\n\n```go\n// AnnounceRequest represents the parameters sent to a BitTorrent tracker\ntype AnnounceRequest struct {\n    InfoHash   [20]byte // SHA-1 hash of the torrent's info dictionary\n    PeerID     [20]byte // Unique identifier for this client instance\n    Port       int      // TCP port this client listens on\n    Uploaded   int64    // Total bytes uploaded to other peers\n    Downloaded int64    // Total bytes downloaded from other peers\n    Left       int64    // Bytes remaining to complete download\n    Event      string   // \"started\", \"completed\", \"stopped\", or empty\n}\n\n// AnnounceResponse represents the tracker's response to an announce request\ntype AnnounceResponse struct {\n    Interval      int    // Seconds until next announce\n    Complete      int    // Number of seeders (peers with complete file)\n    Incomplete    int    // Number of leechers (peers downloading)\n    Peers         []byte // Compact peer list (6 bytes per peer)\n    FailureReason string // Error message if request failed\n}\n\n// PeerInfo represents a single peer's network address\ntype PeerInfo struct {\n    IP   [4]byte  // IPv4 address in network byte order\n    Port uint16   // TCP port in host byte order\n}\n\n// String returns a human-readable representation of the peer\nfunc (p PeerInfo) String() string {\n    return fmt.Sprintf(\"%d.%d.%d.%d:%d\", p.IP[0], p.IP[1], p.IP[2], p.IP[3], p.Port)\n}\n\n// Client manages communication with BitTorrent trackers\ntype Client struct {\n    httpClient *HTTPClient\n    backoff    *BackoffScheduler\n    \n    // Tracker state\n    announceURL   string\n    lastAnnounce  time.Time\n    nextAnnounce  time.Time\n    trackerID     string // Optional tracker-assigned ID\n}\n```\n\n#### Core Logic Skeleton: Tracker Client Implementation\n\n```go\n// NewClient creates a tracker client for the given torrent\nfunc NewClient(announceURL string) *Client {\n    return &Client{\n        httpClient:  NewHTTPClient(),\n        backoff:     NewBackoffScheduler(),\n        announceURL: announceURL,\n    }\n}\n\n// BuildAnnounceURL constructs the complete tracker URL with all required parameters\nfunc (c *Client) BuildAnnounceURL(req AnnounceRequest) string {\n    // TODO 1: Parse the base announce URL to separate base from existing query parameters\n    // TODO 2: URL-encode the binary info_hash using URLEncodeBinary function\n    // TODO 3: URL-encode the binary peer_id using URLEncodeBinary function  \n    // TODO 4: Build query parameter string with all required fields\n    // TODO 5: Handle optional event parameter (only include if not empty)\n    // TODO 6: Include tracker_id if we received one from previous response\n    // TODO 7: Add compact=1 to request compact peer format\n    // TODO 8: Combine base URL with query parameters\n    // Hint: Use url.Values{} to build query parameters safely\n    // Hint: Don't use url.QueryEscape for info_hash/peer_id - use URLEncodeBinary\n}\n\n// Announce sends an announce request to the tracker and parses the response\nfunc (c *Client) Announce(ctx context.Context, req AnnounceRequest) (*AnnounceResponse, error) {\n    // TODO 1: Build the complete announce URL using BuildAnnounceURL\n    // TODO 2: Send HTTP GET request using c.httpClient.Get with context\n    // TODO 3: Handle HTTP errors and network timeouts appropriately\n    // TODO 4: Parse the response body as Bencode using existing decoder\n    // TODO 5: Extract announce response fields from Bencode dictionary\n    // TODO 6: Check for \"failure reason\" field and return error if present\n    // TODO 7: Validate that required fields (interval, peers) are present\n    // TODO 8: Update c.lastAnnounce and c.nextAnnounce timestamps\n    // TODO 9: Store tracker_id if provided for future requests\n    // TODO 10: Reset backoff scheduler on successful response\n    // Hint: Reuse the Bencode decoder from milestone 1\n    // Hint: Return tracker errors (failure reason) as a distinct error type\n}\n\n// ParseCompactPeers converts the binary peer list into PeerInfo structures\nfunc ParseCompactPeers(compactPeers []byte) ([]PeerInfo, error) {\n    // TODO 1: Validate that peer list length is multiple of 6 bytes\n    // TODO 2: Calculate number of peers from total length\n    // TODO 3: Create slice to hold parsed peer information\n    // TODO 4: Iterate through compact peer data in 6-byte chunks\n    // TODO 5: Extract 4-byte IP address in network byte order\n    // TODO 6: Extract 2-byte port number in network byte order  \n    // TODO 7: Convert port from big-endian to host byte order\n    // TODO 8: Create PeerInfo struct and add to result slice\n    // TODO 9: Return completed peer list\n    // Hint: Use binary.BigEndian.Uint16() for port conversion\n    // Hint: IP address bytes can be copied directly (already in network order)\n}\n\n// ScheduleNextAnnounce determines when the next announce should occur\nfunc (c *Client) ScheduleNextAnnounce(interval int) time.Time {\n    // TODO 1: Calculate base next announce time as lastAnnounce + interval\n    // TODO 2: Add small random jitter (±10% of interval) to distribute load\n    // TODO 3: Ensure next announce is not in the past\n    // TODO 4: Update c.nextAnnounce field\n    // TODO 5: Return the scheduled time\n    // Hint: Use rand.Float64() for jitter calculation\n    // Hint: time.Now().Add() for time arithmetic\n}\n\n// ShouldAnnounce returns true if it's time to send another announce request\nfunc (c *Client) ShouldAnnounce() bool {\n    // TODO 1: Compare current time with c.nextAnnounce\n    // TODO 2: Return true if current time is after scheduled announce time\n    // TODO 3: Handle case where nextAnnounce is zero (first announce)\n}\n\n// OnAnnounceError handles announce request failures with backoff\nfunc (c *Client) OnAnnounceError(err error) time.Duration {\n    // TODO 1: Record the failure with backoff scheduler\n    // TODO 2: Get the next retry delay from backoff.OnFailure()\n    // TODO 3: Update nextAnnounce to current time + retry delay\n    // TODO 4: Log the error with appropriate detail level\n    // TODO 5: Return the retry delay for caller information\n    // Hint: Distinguish between different error types for logging\n    // Hint: Network errors vs tracker errors may need different handling\n}\n```\n\n#### Testing and Validation Checkpoints\n\nAfter implementing the tracker communication system, verify correct behavior with these checkpoints:\n\n**Unit Test Verification:**\n```bash\ngo test ./internal/tracker/... -v\n```\n\nExpected test coverage should include:\n- URL encoding of binary data (info_hash and peer_id)\n- Compact peer list parsing with various list sizes\n- Announce request parameter construction\n- Error handling for malformed tracker responses\n- Backoff scheduling behavior\n\n**Integration Test with Real Tracker:**\n1. Use a test torrent file with a known working tracker\n2. Send an announce request with `event=started`\n3. Verify you receive a valid peer list in the response\n4. Check that the `interval` field contains a reasonable value (300-1800 seconds)\n5. Confirm peer IP addresses and ports are correctly parsed\n\n**Manual Verification Steps:**\n1. Enable debug logging to see announce URLs being constructed\n2. Copy an announce URL and test it manually with `curl` - you should get Bencode response\n3. Verify that URL encoding produces valid HTTP URLs (no unescaped binary data)\n4. Check that periodic re-announce happens at the correct intervals\n5. Test error handling by using an invalid tracker URL\n\n**Common Issues and Debugging:**\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| \"Invalid info_hash\" error | Incorrect URL encoding of binary data | Use URLEncodeBinary, not url.QueryEscape |\n| Empty peer list returned | Torrent has no active peers, or announce parameters incorrect | Test with popular torrent, verify all required parameters |\n| Connection timeouts | Network issues or unresponsive tracker | Implement proper timeout handling and retry logic |\n| Parse errors on response | Tracker returned non-Bencode data | Add response format validation before parsing |\n\n![Complete Download Flow](./diagrams/download-sequence.svg)\n\nThe tracker communication implementation provides the foundation for peer discovery in our BitTorrent client. Once we can successfully retrieve peer lists from trackers, the next milestone will focus on establishing direct connections with those peers using the BitTorrent wire protocol.\n\n\n## Peer Wire Protocol (Milestone 3)\n\n> **Milestone(s):** This section corresponds to Milestone 3 - Peer Protocol, implementing the BitTorrent peer wire protocol including handshakes, message framing, and state machines.\n\nAfter establishing communication with the tracker and discovering peers in Milestone 2, we now face the core challenge of the BitTorrent protocol: establishing direct peer-to-peer connections and coordinating the actual transfer of file data. The peer wire protocol is BitTorrent's application-layer communication standard that governs how peers handshake, exchange availability information, negotiate transfers, and maintain fair sharing relationships.\n\nThe peer wire protocol operates over TCP connections and implements a sophisticated state machine that balances efficiency with fairness. Unlike simple client-server protocols, BitTorrent peers must simultaneously act as both clients (requesting data) and servers (providing data), while maintaining multiple concurrent connections and enforcing upload reciprocity through choking mechanisms.\n\n### Peer Protocol as Conversation Rules\n\nThink of the BitTorrent peer wire protocol like the formal conversation rules at a diplomatic dinner party. When diplomats from different countries meet, they follow established etiquette to ensure productive communication despite language barriers and cultural differences.\n\nThe **handshake** is like the formal introduction where diplomats present their credentials and verify they're attending the same event (same torrent). They exchange names (peer IDs) and confirm they're discussing the same topic (info hash verification).\n\nThe **bitfield exchange** is like each diplomat placing their briefcase contents on the table, showing what documents (pieces) they brought to share. This transparency allows everyone to see who has what information, enabling efficient negotiation.\n\nThe **choking and interest system** mirrors diplomatic negotiation protocols. A diplomat might be \"interested\" in another's documents but \"choked\" (denied access) until they offer something valuable in return. The \"unchoke\" decision represents granting access based on reciprocal value exchange.\n\n**Message framing** provides the structured communication format, like diplomatic protocols that specify how to format official communications with proper headers, lengths, and content organization to prevent misunderstandings.\n\nThis analogy captures the essential challenge: BitTorrent peers must coordinate complex multi-party exchanges while maintaining fairness and preventing exploitation, just as diplomatic protocols enable cooperation between self-interested parties.\n\n### Connection Handshake\n\nThe BitTorrent handshake serves as the authentication and compatibility verification phase that must complete successfully before any data transfer can begin. This 68-byte message exchange ensures both peers are speaking the same protocol version and participating in the same torrent swarm.\n\nThe handshake message format consists of five distinct components that provide comprehensive connection validation:\n\n| Field | Length | Type | Description |\n|-------|--------|------|-------------|\n| Protocol Length | 1 byte | uint8 | Always 19 (length of \"BitTorrent protocol\") |\n| Protocol String | 19 bytes | ASCII | Always \"BitTorrent protocol\" |\n| Reserved Bytes | 8 bytes | uint64 | Feature flags (all zeros for basic implementation) |\n| Info Hash | 20 bytes | [20]byte | SHA-1 hash identifying the specific torrent |\n| Peer ID | 20 bytes | [20]byte | Unique identifier for the connecting peer |\n\nThe handshake exchange follows a specific sequence that validates compatibility at each step:\n\n1. **Connection establishment**: The initiating peer opens a TCP connection to the remote peer's IP and port (discovered from tracker).\n\n2. **Handshake transmission**: The initiator immediately sends the complete 68-byte handshake message without waiting for any response.\n\n3. **Protocol validation**: The receiving peer reads the first 20 bytes and verifies the protocol length (19) and protocol string (\"BitTorrent protocol\") match expected values.\n\n4. **Torrent validation**: The receiving peer extracts the info hash from bytes 28-47 and confirms it matches a torrent they're actively sharing.\n\n5. **Response handshake**: If validation succeeds, the receiving peer sends back its own 68-byte handshake message with the same info hash but its own peer ID.\n\n6. **Mutual validation**: The initiating peer receives and validates the response handshake, confirming the info hash matches and noting the remote peer's ID.\n\n> **Decision: Immediate Handshake Transmission**\n> - **Context**: Handshake could wait for connection confirmation or send immediately after TCP establishment\n> - **Options Considered**: Wait for explicit ready signal vs. immediate transmission vs. HTTP-style request/response\n> - **Decision**: Send handshake immediately after TCP connection establishment\n> - **Rationale**: Reduces round-trip latency, matches BitTorrent specification exactly, and simplifies state machine (no waiting state needed)\n> - **Consequences**: Enables faster connection establishment but requires careful handling of partial reads during handshake parsing\n\nThe info hash validation is the critical security check that prevents peers from different torrents from establishing connections. Since the info hash is computed from the exact bencoded bytes of the torrent's info dictionary, it serves as both a unique identifier and a cryptographic commitment to the specific file contents and structure being shared.\n\nPeer ID validation serves multiple purposes beyond simple identification. Well-formed peer IDs follow conventions that identify the BitTorrent client software and version, enabling peers to implement client-specific optimizations or compatibility workarounds. Our implementation should generate a recognizable peer ID that identifies our client while remaining unique across instances.\n\nThe reserved bytes field provides extensibility for future protocol features like encryption, DHT support, or enhanced messaging. For a basic implementation, these bytes should be set to zero, but the field must be preserved during handshake forwarding to maintain protocol compatibility.\n\n**Handshake Error Conditions and Recovery:**\n\n| Error Condition | Detection Method | Recovery Action |\n|----------------|------------------|-----------------|\n| Wrong protocol string | String comparison mismatch | Close connection immediately |\n| Unknown info hash | Info hash not in active torrents | Send handshake with error info hash |\n| Connection timeout | No handshake received within 30s | Close connection and retry |\n| Partial handshake | TCP connection closed mid-handshake | Log error and attempt reconnection |\n| Duplicate peer ID | Same peer ID as local client | Close connection (connecting to self) |\n\n### Message Framing and Parsing\n\nAfter successful handshake completion, all subsequent communication uses the BitTorrent message framing format, which provides reliable message boundaries over the streaming TCP connection. This framing system must handle variable-length messages while maintaining parsing efficiency and error recovery capabilities.\n\nEvery BitTorrent message (except the handshake) follows a standardized format that begins with a length prefix to enable proper message boundary detection:\n\n| Field | Length | Type | Description |\n|-------|--------|------|-------------|\n| Message Length | 4 bytes | uint32 (big-endian) | Total bytes in message (0 for keep-alive) |\n| Message ID | 1 byte | uint8 | Message type identifier (omitted for keep-alive) |\n| Payload | Variable | bytes | Message-specific data (length = Message Length - 1) |\n\nThe message framing protocol defines nine standard message types that handle all peer communication needs:\n\n| Message ID | Name | Payload Length | Purpose |\n|------------|------|----------------|---------|\n| - | keep-alive | 0 bytes | Maintain connection (length = 0, no ID) |\n| 0 | choke | 0 bytes | Refuse to upload to peer |\n| 1 | unchoke | 0 bytes | Allow uploads to peer |\n| 2 | interested | 0 bytes | Want to download from peer |\n| 3 | not interested | 0 bytes | No longer want to download |\n| 4 | have | 4 bytes | Announce piece availability |\n| 5 | bitfield | Variable | Announce complete piece availability |\n| 6 | request | 12 bytes | Request specific block of data |\n| 7 | piece | 9 + block size | Deliver requested block data |\n| 8 | cancel | 12 bytes | Cancel previous block request |\n\nThe message parsing state machine must handle the streaming nature of TCP while maintaining message boundaries and providing robust error recovery:\n\n![Peer Message Parsing](./diagrams/message-parsing-flow.svg)\n\n**Message Parsing Algorithm:**\n\n1. **Length Reading State**: Read exactly 4 bytes from the TCP connection to get the message length field, handling partial reads by maintaining a read buffer.\n\n2. **Length Validation**: Verify the message length is reasonable (0 for keep-alive, 1-17 for standard messages, larger values only valid for bitfield and piece messages).\n\n3. **Keep-Alive Detection**: If length is 0, this is a keep-alive message. Reset connection timeout and return to length reading state.\n\n4. **Message ID Reading**: Read 1 byte for the message ID, validating it falls within the expected range (0-8 for standard protocol).\n\n5. **Payload Length Calculation**: Calculate payload length as (message length - 1) and validate it matches expected length for the message type.\n\n6. **Payload Reading**: Read exactly the calculated payload bytes, handling partial reads and maintaining progress state.\n\n7. **Message Dispatch**: Parse the complete message according to its type and dispatch to appropriate handler function.\n\n8. **State Reset**: Return to length reading state for the next message.\n\nThe parser must handle several challenging scenarios that arise from TCP's streaming nature and network reliability issues:\n\n> **Critical Insight: Partial Read Handling**\n> \n> TCP provides a byte stream, not message boundaries. A single `Read()` call might return part of a message, multiple complete messages, or a combination. The parser must accumulate bytes across multiple reads and only dispatch complete messages.\n\n**Message Parsing State Management:**\n\n| Parser State | Data Needed | Next State | Error Conditions |\n|-------------|-------------|------------|------------------|\n| ReadingLength | 4 bytes | ReadingMessage or KeepAlive | Connection closed, invalid length |\n| ReadingMessage | Message Length bytes | ReadingLength | Connection closed, timeout |\n| KeepAlive | 0 bytes | ReadingLength | N/A |\n\nThe message framer must maintain parsing state across multiple read operations, accumulating partial data until complete messages are available. This requires careful buffer management to avoid memory leaks while handling arbitrarily large messages (piece messages can be 16KB+).\n\n**Endianness Considerations:**\n\nAll multi-byte integers in BitTorrent messages use big-endian (network) byte order. The message length, piece indices, block offsets, and block lengths must be converted from network byte order to host byte order during parsing and vice versa during message construction.\n\n⚠️ **Pitfall: Partial Message Processing**\nMany implementations incorrectly assume that a single TCP read will return a complete message. This works during testing with local connections but fails under network stress or with slow peers. Always accumulate bytes until you have a complete message before processing.\n\n### Peer State Management\n\nBitTorrent peers maintain a four-flag state machine that governs upload and download permissions between connected peers. This state system implements the core game theory mechanism that incentivizes sharing and prevents freeloading by requiring reciprocal exchange.\n\nThe peer state consists of four independent boolean flags that capture the bidirectional nature of BitTorrent relationships:\n\n| State Flag | Direction | Meaning | Initial Value |\n|------------|-----------|---------|---------------|\n| am_choking | Local → Remote | We refuse to upload to peer | true |\n| am_interested | Local → Remote | We want to download from peer | false |\n| peer_choking | Remote → Local | Peer refuses to upload to us | true |\n| peer_interested | Remote → Local | Peer wants to download from us | false |\n\nThese flags combine to determine the actual data transfer permissions and drive the message exchange patterns between peers:\n\n![Peer Connection State Machine](./diagrams/peer-state-machine.svg)\n\n**State Transition Rules:**\n\nThe state machine transitions occur in response to specific message types and local decision-making algorithms:\n\n| Current State | Message/Event | New State | Action Taken |\n|---------------|---------------|-----------|--------------|\n| am_choking=true | Send unchoke | am_choking=false | Allow uploads to peer |\n| am_choking=false | Send choke | am_choking=true | Block uploads to peer |\n| am_interested=false | Local decision | am_interested=true | Send interested message |\n| am_interested=true | Local decision | am_interested=false | Send not interested |\n| peer_choking=true | Receive unchoke | peer_choking=false | Can send requests |\n| peer_choking=false | Receive choke | peer_choking=true | Cancel pending requests |\n| peer_interested=false | Receive interested | peer_interested=true | Consider unchoking |\n| peer_interested=true | Receive not interested | peer_interested=false | May choke peer |\n\nThe combination of these flags determines the operational mode of the peer relationship:\n\n**Operational Modes:**\n\n| Mode | Conditions | Upload Allowed | Download Allowed | Description |\n|------|------------|----------------|------------------|-------------|\n| Mutual Exchange | !am_choking && !peer_choking && am_interested && peer_interested | Yes | Yes | Optimal trading state |\n| Uploading Only | !am_choking && peer_choking && !am_interested && peer_interested | Yes | No | Seeding to downloader |\n| Downloading Only | am_choking && !peer_choking && am_interested && !peer_interested | No | Yes | Receiving from seeder |\n| Idle Connection | am_choking && peer_choking | No | No | Maintaining connection |\n\n> **Decision: Four-Flag State Model**\n> - **Context**: Need to track bidirectional choking and interest state between peers\n> - **Options Considered**: Single combined state enum vs. separate directional flags vs. simplified choke-only model\n> - **Decision**: Four independent boolean flags (am_choking, am_interested, peer_choking, peer_interested)\n> - **Rationale**: Matches BitTorrent specification exactly, enables independent state transitions, simplifies message handling logic\n> - **Consequences**: Requires careful synchronization but provides full protocol compliance and optimal flexibility\n\n**Interest Determination Algorithm:**\n\nThe `am_interested` flag should be updated whenever the peer's available pieces change or our local needs change:\n\n1. **Bitfield Analysis**: When receiving a peer's initial bitfield, check if they have any pieces we need.\n\n2. **Have Message Processing**: When peer announces a new piece via `have` message, check if we need that specific piece.\n\n3. **Local Completion**: When we complete a piece, check if we still need any pieces the peer has.\n\n4. **Interest Update**: Send `interested` or `not interested` message only when the interest state actually changes.\n\n**Choking Decision Algorithm:**\n\nThe choking decisions implement BitTorrent's incentive mechanism and should balance fairness with performance:\n\n1. **Reciprocity Analysis**: Prefer to unchoke peers who are uploading to us at good rates.\n\n2. **Optimistic Unchoking**: Periodically unchoke a random peer to discover better trading partners.\n\n3. **Seeding Strategy**: When seeding (we have all pieces), unchoke peers with the best download rates to maximize distribution efficiency.\n\n4. **Connection Limits**: Maintain reasonable limits on simultaneously unchoked peers (typically 4-5) to prevent connection overload.\n\nThe state machine must handle message ordering carefully, as network delays can cause messages to arrive out of expected sequence. For example, a peer might send a `request` message just before receiving our `choke` message, requiring graceful handling of this race condition.\n\n### Request Pipelining\n\nRequest pipelining allows BitTorrent clients to maintain multiple outstanding block requests simultaneously, dramatically improving download throughput by overlapping network round-trip times with data transmission. Without pipelining, the client would wait for each 16KB block to arrive before requesting the next one, severely limiting throughput on high-latency connections.\n\nThe pipelining system must carefully balance throughput optimization with resource management and fairness considerations. Too few outstanding requests waste bandwidth due to round-trip delays, while too many requests consume excessive memory and can overwhelm slower peers.\n\n**Request Pipeline Architecture:**\n\nEach peer connection maintains a request pipeline that tracks outstanding requests and manages the flow of new requests based on network conditions and peer capabilities:\n\n| Pipeline Component | Purpose | Typical Size |\n|--------------------|---------|--------------|\n| Outstanding Requests | Map of sent but not received requests | 5-10 requests |\n| Request Queue | Prepared requests waiting to send | 20-50 requests |\n| Receive Buffer | Arriving piece data being assembled | 16KB per request |\n| Timeout Tracker | Monitors request response times | Per-request timers |\n\n**Request Message Format:**\n\nEach request message specifies exactly which 16KB block is needed from a specific piece:\n\n| Field | Length | Type | Description |\n|-------|--------|------|-------------|\n| Piece Index | 4 bytes | uint32 | Which piece contains the desired block |\n| Block Offset | 4 bytes | uint32 | Byte offset within the piece |\n| Block Length | 4 bytes | uint32 | Number of bytes requested (typically 16384) |\n\nThe request pipelining algorithm coordinates multiple concurrent block downloads while maintaining proper flow control:\n\n**Pipeline Management Algorithm:**\n\n1. **Pipeline Capacity Check**: Determine how many additional requests can be sent based on current outstanding count and peer capacity.\n\n2. **Block Selection**: Choose the next needed blocks from the piece selection algorithm, prioritizing blocks from pieces that are already partially downloaded.\n\n3. **Request Transmission**: Send request messages for selected blocks, recording each request with timestamp and expected response size.\n\n4. **Response Processing**: When piece messages arrive, match them to outstanding requests, validate block data, and update pipeline state.\n\n5. **Timeout Handling**: Periodically check for requests that have exceeded reasonable response times and re-request from other peers.\n\n6. **Pipeline Refill**: Continuously add new requests to maintain optimal pipeline depth based on network conditions.\n\n> **Decision: Adaptive Pipeline Depth**\n> - **Context**: Need to optimize throughput while avoiding peer overload and memory exhaustion\n> - **Options Considered**: Fixed pipeline depth vs. adaptive sizing vs. unlimited pipelining\n> - **Decision**: Adaptive pipeline sizing based on peer performance and network conditions\n> - **Rationale**: Fixed depth wastes opportunities with fast peers and overloads slow peers; adaptive sizing maximizes efficiency\n> - **Consequences**: Requires performance monitoring and dynamic adjustment but provides optimal throughput across diverse network conditions\n\n**Pipeline Depth Calculation:**\n\nThe optimal pipeline depth depends on the bandwidth-delay product of the connection and the peer's processing capacity:\n\n1. **Bandwidth Estimation**: Monitor the peer's actual data delivery rate over recent time windows.\n\n2. **Latency Measurement**: Track round-trip times between request messages and corresponding piece messages.\n\n3. **Capacity Calculation**: Estimate how many blocks should be in-flight to maintain continuous data flow: `pipeline_depth = (bandwidth * round_trip_time) / block_size`.\n\n4. **Peer Limits**: Respect any peer-advertised limits on concurrent requests and avoid overwhelming slower peers.\n\n5. **Memory Constraints**: Cap pipeline depth based on available memory for buffering outstanding requests.\n\n**Request Timeout and Recovery:**\n\nNetwork issues and peer problems can cause some requests to be lost or delayed indefinitely. The pipeline must detect these situations and recover gracefully:\n\n| Timeout Condition | Detection Method | Recovery Action |\n|-------------------|------------------|-----------------|\n| Slow Response | Request age > 2 * average RTT | Mark as slow, reduce pipeline depth |\n| Lost Request | Request age > 60 seconds | Cancel and re-request from different peer |\n| Peer Disconnect | TCP connection closed | Cancel all requests, redistribute to other peers |\n| Invalid Response | Piece data fails validation | Re-request block, potential peer ban |\n\n**Endgame Mode Considerations:**\n\nWhen downloading the final pieces of a torrent, the standard rarest-first selection may result in only a few peers having the remaining pieces. In this situation, endgame mode modifies the pipelining strategy:\n\n1. **Redundant Requests**: Send requests for the same blocks to multiple peers to avoid stalling on slow responses.\n\n2. **Cancel Propagation**: When a block arrives, immediately send cancel messages to other peers for the same block to avoid wasted bandwidth.\n\n3. **Aggressive Timeouts**: Use shorter timeout periods since completion is prioritized over bandwidth efficiency.\n\n⚠️ **Pitfall: Memory Leaks in Pipeline Management**\nOutstanding request tracking must carefully manage memory allocation and cleanup. Failed to cancel requests on peer disconnection leads to memory leaks, while failed to remove completed requests causes unbounded memory growth.\n\n### Common Protocol Pitfalls\n\nThe BitTorrent peer wire protocol contains several subtle requirements and edge cases that frequently trip up implementers. These pitfalls often manifest as connection failures, poor performance, or protocol violations that cause other clients to disconnect.\n\n⚠️ **Pitfall: Endianness Confusion**\n\n**Problem**: All multi-byte integers in BitTorrent messages use big-endian (network) byte order, but many developers forget to convert between network and host byte order when parsing or constructing messages.\n\n**Symptoms**: Message parsing fails with apparently random values, piece indices seem impossibly large, or length fields cause buffer overruns.\n\n**Example**: A 4-byte piece index of `0x00000001` (piece 1) appears as `0x01000000` (piece 16777216) on little-endian systems without proper conversion.\n\n**Fix**: Always use proper byte order conversion functions (`binary.BigEndian` in Go) when reading or writing multi-byte fields in protocol messages.\n\n⚠️ **Pitfall: Partial TCP Read Handling**\n\n**Problem**: Assuming that a single TCP `read()` call returns a complete message. TCP is a stream protocol and may deliver data in arbitrary chunks unrelated to message boundaries.\n\n**Symptoms**: Messages appear truncated, parsing fails intermittently (especially under load), or the client works locally but fails with remote peers.\n\n**Example**: A 17KB piece message might arrive as three separate reads of 8KB, 8KB, and 1KB, requiring accumulation across multiple read operations.\n\n**Fix**: Always accumulate bytes until you have a complete message. Maintain parsing state across multiple read operations and only process complete messages.\n\n⚠️ **Pitfall: Blocking on Choked Peers**\n\n**Problem**: Sending request messages to peers who have choked us, or failing to cancel outstanding requests when a peer sends a choke message.\n\n**Symptoms**: Download stalls even though peers are connected, requests time out repeatedly, or peers disconnect due to protocol violations.\n\n**Example**: Peer sends choke message but client continues sending request messages, violating the protocol and causing the peer to close the connection.\n\n**Fix**: Immediately cancel all outstanding requests when receiving a choke message, and only send new requests to peers who are not choking us.\n\n⚠️ **Pitfall: Handshake Validation Ordering**\n\n**Problem**: Performing handshake validation checks in the wrong order or with incorrect byte ranges, leading to connection establishment failures.\n\n**Symptoms**: All incoming connections fail with protocol errors, connections work with some clients but not others, or info hash mismatches are reported.\n\n**Example**: Reading the info hash from bytes 20-39 instead of bytes 28-47, causing validation to fail against random data from the reserved bytes field.\n\n**Fix**: Follow the exact handshake format: 1 byte length + 19 bytes protocol string + 8 bytes reserved + 20 bytes info hash + 20 bytes peer ID.\n\n⚠️ **Pitfall: State Machine Synchronization Errors**\n\n**Problem**: Updating peer state flags inconsistently or failing to synchronize state changes with message transmission, leading to desynchronized state machines between peers.\n\n**Symptoms**: Peers appear to be in impossible states, upload/download permissions don't match message exchange, or connections deadlock.\n\n**Example**: Setting `am_choking = false` locally but forgetting to send the unchoke message, causing state desynchronization.\n\n**Fix**: Always update local state and send corresponding messages atomically. Never change state flags without sending appropriate protocol messages.\n\n⚠️ **Pitfall: Request Pipeline Memory Management**\n\n**Problem**: Failing to properly cleanup outstanding requests when peers disconnect, or not limiting pipeline depth based on available memory.\n\n**Symptoms**: Memory usage grows unboundedly during downloads, request timeouts don't trigger cleanup, or the client crashes with out-of-memory errors.\n\n**Example**: Peer disconnects with 50 outstanding 16KB requests, but the request tracking structures are never cleaned up, leaking 800KB per disconnection.\n\n**Fix**: Implement proper resource cleanup on peer disconnection and enforce reasonable limits on concurrent outstanding requests based on available memory.\n\n⚠️ **Pitfall: Keep-Alive Timing Issues**\n\n**Problem**: Not sending keep-alive messages during idle periods, or failing to reset connection timeouts when receiving keep-alive messages.\n\n**Symptoms**: Connections drop unexpectedly during periods of no data transfer, peers disconnect after exactly 2-3 minutes of inactivity.\n\n**Example**: During endgame phase when few requests are being sent, connections time out because no keep-alive messages are transmitted.\n\n**Fix**: Send keep-alive messages (zero-length messages) every 2 minutes when no other messages have been sent, and reset timeout timers when receiving any message including keep-alives.\n\n### Implementation Guidance\n\nThis subsection provides the practical foundation for implementing the BitTorrent peer wire protocol, focusing on TCP connection management, message parsing infrastructure, and state tracking systems that enable robust peer communication.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| TCP Networking | net.Conn with basic read/write | Custom connection pooling with bufio |\n| Message Parsing | Manual byte slicing | Protocol buffer style parser |\n| State Management | Simple struct with mutexes | Actor model with message channels |\n| Concurrency | One goroutine per peer | Worker pool with shared connections |\n| Error Handling | Basic error returns | Structured error types with recovery |\n\n**Recommended File Structure:**\n\nThe peer protocol implementation should be organized to separate networking concerns from protocol logic:\n\n```\ninternal/peer/\n  connection.go           ← TCP connection management and handshake\n  message.go             ← Message parsing and framing\n  protocol.go            ← Peer state machine and protocol logic\n  pipeline.go            ← Request pipelining and flow control\n  connection_test.go     ← Connection and handshake tests\n  message_test.go        ← Message parsing tests\n  protocol_test.go       ← State machine and integration tests\ninternal/wire/\n  messages.go            ← Message type definitions and constants\n  framer.go             ← Message framing utilities\n```\n\n**Core Infrastructure - Complete Message Framing System:**\n\n```go\npackage wire\n\nimport (\n    \"encoding/binary\"\n    \"fmt\"\n    \"io\"\n)\n\n// Message type constants\nconst (\n    MsgKeepAlive    = -1  // Special case for keep-alive (no ID)\n    MsgChoke        = 0\n    MsgUnchoke      = 1\n    MsgInterested   = 2\n    MsgNotInterested = 3\n    MsgHave         = 4\n    MsgBitfield     = 5\n    MsgRequest      = 6\n    MsgPiece        = 7\n    MsgCancel       = 8\n)\n\nconst (\n    HANDSHAKE_LENGTH = 68\n    PROTOCOL_STRING = \"BitTorrent protocol\"\n    BLOCK_SIZE = 16384\n    MAX_MESSAGE_LENGTH = BLOCK_SIZE + 13  // piece message with full block\n)\n\n// Message represents a parsed BitTorrent protocol message\ntype Message struct {\n    ID      int\n    Payload []byte\n}\n\n// MessageFramer handles reading and writing length-prefixed messages\ntype MessageFramer struct {\n    conn   io.ReadWriter\n    buffer []byte  // Reusable buffer for parsing\n}\n\n// NewMessageFramer creates a message framer for the given connection\nfunc NewMessageFramer(conn io.ReadWriter) *MessageFramer {\n    return &MessageFramer{\n        conn:   conn,\n        buffer: make([]byte, MAX_MESSAGE_LENGTH+4), // +4 for length prefix\n    }\n}\n\n// ReadMessage reads and parses the next message from the connection\nfunc (mf *MessageFramer) ReadMessage() (*Message, error) {\n    // Read 4-byte length prefix\n    if _, err := io.ReadFull(mf.conn, mf.buffer[:4]); err != nil {\n        return nil, fmt.Errorf(\"reading message length: %w\", err)\n    }\n    \n    length := binary.BigEndian.Uint32(mf.buffer[:4])\n    \n    // Handle keep-alive message (length = 0)\n    if length == 0 {\n        return &Message{ID: MsgKeepAlive, Payload: nil}, nil\n    }\n    \n    // Validate message length\n    if length > MAX_MESSAGE_LENGTH {\n        return nil, fmt.Errorf(\"message too large: %d bytes\", length)\n    }\n    \n    // Read message ID + payload\n    if _, err := io.ReadFull(mf.conn, mf.buffer[:length]); err != nil {\n        return nil, fmt.Errorf(\"reading message body: %w\", err)\n    }\n    \n    messageID := int(mf.buffer[0])\n    payload := make([]byte, length-1)\n    copy(payload, mf.buffer[1:length])\n    \n    return &Message{ID: messageID, Payload: payload}, nil\n}\n\n// WriteMessage writes a message to the connection with proper framing\nfunc (mf *MessageFramer) WriteMessage(msg *Message) error {\n    if msg.ID == MsgKeepAlive {\n        // Keep-alive: just write 4 zero bytes\n        binary.BigEndian.PutUint32(mf.buffer[:4], 0)\n        _, err := mf.conn.Write(mf.buffer[:4])\n        return err\n    }\n    \n    messageLength := uint32(len(msg.Payload) + 1) // +1 for message ID\n    binary.BigEndian.PutUint32(mf.buffer[:4], messageLength)\n    mf.buffer[4] = byte(msg.ID)\n    copy(mf.buffer[5:], msg.Payload)\n    \n    _, err := mf.conn.Write(mf.buffer[:4+messageLength])\n    return err\n}\n\n// Handshake represents the initial 68-byte handshake message\ntype Handshake struct {\n    InfoHash [20]byte\n    PeerID   [20]byte\n}\n\n// MarshalBinary serializes handshake to 68-byte wire format\nfunc (h *Handshake) MarshalBinary() []byte {\n    buf := make([]byte, HANDSHAKE_LENGTH)\n    buf[0] = 19  // Protocol string length\n    copy(buf[1:20], PROTOCOL_STRING)\n    // buf[20:28] reserved bytes (already zero)\n    copy(buf[28:48], h.InfoHash[:])\n    copy(buf[48:68], h.PeerID[:])\n    return buf\n}\n\n// UnmarshalBinary parses 68-byte handshake from wire format\nfunc (h *Handshake) UnmarshalBinary(data []byte) error {\n    if len(data) != HANDSHAKE_LENGTH {\n        return fmt.Errorf(\"invalid handshake length: %d\", len(data))\n    }\n    \n    if data[0] != 19 {\n        return fmt.Errorf(\"invalid protocol length: %d\", data[0])\n    }\n    \n    if string(data[1:20]) != PROTOCOL_STRING {\n        return fmt.Errorf(\"invalid protocol string: %s\", data[1:20])\n    }\n    \n    copy(h.InfoHash[:], data[28:48])\n    copy(h.PeerID[:], data[48:68])\n    return nil\n}\n```\n\n**Core Infrastructure - Bitfield Operations:**\n\n```go\npackage peer\n\n// BitfieldOps provides efficient operations on piece availability bitfields\ntype BitfieldOps struct {\n    bitfield  []byte\n    numPieces int\n}\n\n// NewBitfieldOps creates a bitfield for the specified number of pieces\nfunc NewBitfieldOps(numPieces int) *BitfieldOps {\n    byteCount := (numPieces + 7) / 8  // Round up to nearest byte\n    return &BitfieldOps{\n        bitfield:  make([]byte, byteCount),\n        numPieces: numPieces,\n    }\n}\n\n// SetPiece marks a piece as available\nfunc (bf *BitfieldOps) SetPiece(pieceIndex int) {\n    if pieceIndex >= bf.numPieces {\n        return\n    }\n    byteIndex := pieceIndex / 8\n    bitIndex := pieceIndex % 8\n    bf.bitfield[byteIndex] |= (0x80 >> bitIndex)\n}\n\n// HasPiece returns true if the specified piece is available\nfunc (bf *BitfieldOps) HasPiece(pieceIndex int) bool {\n    if pieceIndex >= bf.numPieces {\n        return false\n    }\n    byteIndex := pieceIndex / 8\n    bitIndex := pieceIndex % 8\n    return (bf.bitfield[byteIndex] & (0x80 >> bitIndex)) != 0\n}\n\n// CountAvailablePieces returns the number of pieces marked as available\nfunc (bf *BitfieldOps) CountAvailablePieces() int {\n    count := 0\n    for i := 0; i < bf.numPieces; i++ {\n        if bf.HasPiece(i) {\n            count++\n        }\n    }\n    return count\n}\n\n// Bytes returns the raw bitfield bytes for transmission\nfunc (bf *BitfieldOps) Bytes() []byte {\n    result := make([]byte, len(bf.bitfield))\n    copy(result, bf.bitfield)\n    return result\n}\n```\n\n**Core Logic Skeleton - Peer Connection Management:**\n\n```go\npackage peer\n\nimport (\n    \"net\"\n    \"sync\"\n    \"time\"\n    \"context\"\n)\n\n// Connection represents a single peer connection with full state tracking\ntype Connection struct {\n    conn     net.Conn\n    framer   *wire.MessageFramer\n    \n    // Peer identification\n    peerID   [20]byte\n    infoHash [20]byte\n    \n    // State machine flags\n    amChoking       bool\n    amInterested    bool\n    peerChoking     bool\n    peerInterested  bool\n    \n    // Piece availability\n    bitfield *BitfieldOps\n    \n    // Request pipeline\n    pendingRequests map[string]*PendingRequest\n    maxPipeline     int\n    \n    // Synchronization\n    mutex sync.RWMutex\n    \n    // Lifecycle\n    ctx    context.Context\n    cancel context.CancelFunc\n}\n\n// PendingRequest tracks an outstanding block request\ntype PendingRequest struct {\n    PieceIndex  int\n    Offset      int\n    Length      int\n    RequestTime time.Time\n}\n\n// NewConnection creates a new peer connection\nfunc NewConnection(conn net.Conn, infoHash [20]byte, peerID [20]byte) *Connection {\n    ctx, cancel := context.WithCancel(context.Background())\n    return &Connection{\n        conn:            conn,\n        framer:          wire.NewMessageFramer(conn),\n        infoHash:        infoHash,\n        peerID:          peerID,\n        amChoking:       true,   // Start choked\n        amInterested:    false,  // Start not interested\n        peerChoking:     true,   // Assume peer starts choked\n        peerInterested:  false,  // Assume peer starts not interested\n        pendingRequests: make(map[string]*PendingRequest),\n        maxPipeline:     5,      // Conservative initial pipeline depth\n        ctx:             ctx,\n        cancel:          cancel,\n    }\n}\n\n// PerformHandshake executes the BitTorrent handshake protocol\nfunc (c *Connection) PerformHandshake() error {\n    // TODO 1: Create handshake message with our info hash and peer ID\n    // TODO 2: Send handshake to peer using conn.Write()\n    // TODO 3: Read 68-byte response using io.ReadFull()\n    // TODO 4: Parse response handshake and validate protocol string\n    // TODO 5: Verify info hash matches our torrent\n    // TODO 6: Store peer's ID for future reference\n    // Hint: Use wire.Handshake struct and its marshal/unmarshal methods\n    panic(\"TODO: implement handshake\")\n}\n\n// UpdateInterest updates our interested state based on peer's available pieces\nfunc (c *Connection) UpdateInterest(neededPieces []int) error {\n    c.mutex.Lock()\n    defer c.mutex.Unlock()\n    \n    // TODO 1: Check if peer has any pieces we need using bitfield.HasPiece()\n    // TODO 2: Determine new interested state (true if any needed pieces available)\n    // TODO 3: If interest state changed, send appropriate message (interested/not interested)\n    // TODO 4: Update amInterested flag to match new state\n    // Hint: Only send message if state actually changes to avoid redundant traffic\n    panic(\"TODO: implement interest updating\")\n}\n\n// SendRequest sends a block request if peer is unchoked and pipeline has capacity\nfunc (c *Connection) SendRequest(pieceIndex, offset, length int) error {\n    c.mutex.Lock()\n    defer c.mutex.Unlock()\n    \n    // TODO 1: Check if peer is choking us (peer_choking flag)\n    // TODO 2: Check if we have pipeline capacity (len(pendingRequests) < maxPipeline)\n    // TODO 3: Create request message with piece index, offset, length\n    // TODO 4: Send request message using framer.WriteMessage()\n    // TODO 5: Add request to pendingRequests map for tracking\n    // TODO 6: Record request time for timeout detection\n    // Hint: Use fmt.Sprintf(\"%d-%d-%d\", pieceIndex, offset, length) as request key\n    panic(\"TODO: implement request sending\")\n}\n\n// ProcessMessage handles incoming messages from the peer\nfunc (c *Connection) ProcessMessage(msg *wire.Message) error {\n    switch msg.ID {\n    case wire.MsgChoke:\n        return c.handleChoke()\n    case wire.MsgUnchoke:\n        return c.handleUnchoke()\n    case wire.MsgInterested:\n        return c.handleInterested()\n    case wire.MsgNotInterested:\n        return c.handleNotInterested()\n    case wire.MsgHave:\n        return c.handleHave(msg.Payload)\n    case wire.MsgBitfield:\n        return c.handleBitfield(msg.Payload)\n    case wire.MsgRequest:\n        return c.handleRequest(msg.Payload)\n    case wire.MsgPiece:\n        return c.handlePiece(msg.Payload)\n    case wire.MsgCancel:\n        return c.handleCancel(msg.Payload)\n    default:\n        return fmt.Errorf(\"unknown message type: %d\", msg.ID)\n    }\n}\n\n// handleChoke processes incoming choke message\nfunc (c *Connection) handleChoke() error {\n    c.mutex.Lock()\n    defer c.mutex.Unlock()\n    \n    // TODO 1: Set peerChoking flag to true\n    // TODO 2: Cancel all pending requests (clear pendingRequests map)\n    // TODO 3: Notify piece manager that requests were cancelled\n    // Hint: Choking means peer won't fulfill our requests, so clean up pipeline\n    panic(\"TODO: implement choke handling\")\n}\n\n// handleUnchoke processes incoming unchoke message\nfunc (c *Connection) handleUnchoke() error {\n    c.mutex.Lock()\n    defer c.mutex.Unlock()\n    \n    // TODO 1: Set peerChoking flag to false\n    // TODO 2: Notify piece manager that we can now send requests\n    // Hint: Unchoking enables request sending, but don't automatically send requests here\n    panic(\"TODO: implement unchoke handling\")\n}\n\n// CanDownload returns true if we can request blocks from this peer\nfunc (c *Connection) CanDownload() bool {\n    c.mutex.RLock()\n    defer c.mutex.RUnlock()\n    \n    // TODO 1: Check that we're interested in peer's pieces (amInterested)\n    // TODO 2: Check that peer is not choking us (peerChoking == false)\n    // TODO 3: Return true only if both conditions are met\n    panic(\"TODO: implement download capability check\")\n}\n```\n\n**Language-Specific Hints:**\n\n- **TCP Connection Management**: Use `net.Dial()` for outgoing connections and `net.Listen()` for incoming connections. Set reasonable timeouts with `SetDeadline()` methods.\n\n- **Binary Protocol Parsing**: Use `encoding/binary` package with `binary.BigEndian` for all multi-byte integer conversions. Use `io.ReadFull()` to ensure complete reads.\n\n- **Concurrency**: Use separate goroutines for reading and writing messages. Protect shared state with `sync.RWMutex` - use read locks for queries and write locks for modifications.\n\n- **Error Handling**: Distinguish between recoverable errors (temporary network issues) and fatal errors (protocol violations). Use context cancellation for graceful shutdown.\n\n- **Memory Management**: Reuse message buffers where possible to reduce garbage collection pressure. Use buffer pools for frequently allocated/deallocated structures.\n\n**Milestone Checkpoint:**\n\nAfter implementing the peer wire protocol, verify the following behavior:\n\n1. **Handshake Verification**: \n   ```bash\n   go run cmd/client/main.go handshake <torrent-file> <peer-ip>:<peer-port>\n   # Should output: \"Handshake successful: peer ID <hex-encoded-peer-id>\"\n   ```\n\n2. **Message Exchange Test**:\n   - Connect to a peer and complete handshake\n   - Receive and parse bitfield message\n   - Send interested message if peer has needed pieces\n   - Verify state transitions occur correctly\n\n3. **Pipeline Test**:\n   - Send multiple request messages to an unchoked peer\n   - Verify requests are tracked in pending requests map\n   - Process incoming piece messages and match to requests\n   - Confirm pipeline refills automatically\n\n**Expected Output Examples:**\n```\nINFO: Connecting to peer 192.168.1.100:6881\nINFO: Handshake completed, peer ID: 2d5458333030302d787878787878787878\nINFO: Received bitfield: peer has 847/1000 pieces\nINFO: Sent interested message (peer has pieces we need)\nINFO: Received unchoke message, can now download\nINFO: Sent 5 requests, pipeline full\nINFO: Received piece 0 block 0 (16384 bytes)\nINFO: Pipeline refilled, sent request for piece 0 block 1\n```\n\n**Common Implementation Issues:**\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| Handshake always fails | Wrong byte offsets in parsing | Use exact offsets: info hash at 28-47, peer ID at 48-67 |\n| Messages appear corrupted | Missing endianness conversion | Use binary.BigEndian for all multi-byte fields |\n| Download stalls after start | Sending requests to choked peers | Check peerChoking flag before sending requests |\n| Memory usage grows continuously | Not cleaning up disconnected peers | Implement proper connection cleanup with context cancellation |\n| Connections drop frequently | Missing keep-alive messages | Send keep-alive every 2 minutes during idle periods |\n\n\n## Piece Management & Seeding (Milestone 4)\n\n> **Milestone(s):** This section corresponds to Milestone 4 - Piece Management & Seeding, implementing piece verification, download scheduling, and upload capabilities for complete BitTorrent functionality.\n\nThe final milestone transforms our BitTorrent client from a simple peer protocol implementation into a fully functional file-sharing system. This phase introduces the sophisticated orchestration layer that coordinates concurrent downloads, verifies data integrity, schedules piece requests efficiently, and serves data to other peers. The challenge lies in managing the complex interplay between multiple concurrent peer connections while ensuring data correctness and optimal download performance.\n\n### Piece Management as Jigsaw Puzzle\n\nThink of piece management as coordinating a massive **collaborative jigsaw puzzle** where multiple people work together to assemble a picture, but with several critical constraints. Each person (peer) has different puzzle pieces available, some pieces might be damaged and need replacement, and you want to prioritize the rarest pieces first to ensure the puzzle can be completed even if people leave.\n\nIn this analogy, each **piece** represents a fixed-size chunk of the file with a unique verification code (SHA1 hash) that proves it's the correct piece. The **puzzle box** (torrent metadata) tells you exactly what each completed piece should look like. **Multiple helpers** (peers) each have different subsets of pieces, and you need to coordinate requests so that you're not asking the same person for pieces they don't have, while ensuring you get the rarest pieces before common ones.\n\nThe key insight is that unlike a physical puzzle, digital pieces can be **copied** rather than moved, so successful completion helps everyone else by making pieces more available. However, pieces can also be **corrupted** in transit, requiring verification against the expected hash before acceptance.\n\nThis mental model captures the essential challenges: **availability tracking** (knowing who has which pieces), **request coordination** (avoiding duplicate work), **rarity-based prioritization** (getting scarce pieces first), **integrity verification** (ensuring pieces aren't corrupted), and **reciprocal sharing** (becoming a piece source for others).\n\n> **Decision: Piece-Centric vs Block-Centric Management**\n> - **Context**: BitTorrent transfers data in 16KB blocks, but verifies integrity at the piece level (typically 256KB-1MB). We must decide whether our primary abstraction tracks pieces or individual blocks.\n> - **Options Considered**: Block-centric tracking (fine-grained but complex), Piece-centric tracking (simpler but less granular), Hybrid approach (piece state with block progress)\n> - **Decision**: Piece-centric management with internal block tracking\n> - **Rationale**: Pieces are the unit of verification and sharing, making them the natural abstraction. Block-level details are implementation concerns within piece management.\n> - **Consequences**: Simpler state management and clear verification boundaries, but requires careful block coordination within pieces to avoid request conflicts.\n\n| Management Approach | Granularity | State Complexity | Verification Model | Request Coordination |\n|---------------------|-------------|------------------|--------------------|--------------------|\n| Block-Centric | 16KB blocks | High (thousands of states) | Deferred until piece complete | Complex inter-block dependencies |\n| Piece-Centric | 256KB-1MB pieces | Medium (hundreds of states) | Natural verification unit | Clear piece-level coordination |\n| Hybrid | Pieces with block progress | Medium-High | Piece-level verification | Block coordination within pieces |\n\n### Content Verification\n\nContent verification forms the **trust foundation** of the entire BitTorrent system. Unlike centralized downloads where you trust the server, peer-to-peer networks require cryptographic proof that received data hasn't been corrupted or maliciously altered. Every piece must pass SHA1 hash verification before being considered valid and available for sharing to other peers.\n\nThe verification process operates as a **cryptographic gatekeeper** where each completed piece undergoes mandatory hash computation and comparison against the expected value from the torrent metadata. This verification serves multiple purposes: detecting network transmission errors, identifying malicious peers sending corrupt data, ensuring file integrity across the distributed network, and preventing the propagation of corrupted data to other peers.\n\n**Verification Algorithm:**\n1. Accumulate all blocks belonging to a piece until the piece is complete (typically 16-64 blocks per piece)\n2. Concatenate the block data in correct offset order to reconstruct the complete piece\n3. Compute the SHA1 hash of the reconstructed piece data using a cryptographic hash function\n4. Compare the computed hash against the expected hash from the torrent's piece list\n5. If hashes match, mark the piece as verified and available for sharing; if they don't match, discard the piece data and re-request all blocks\n6. Update the local bitfield to reflect piece availability and notify connected peers of the new piece\n7. Write the verified piece data to the appropriate file offset on disk\n\n> The critical insight is that verification happens at piece boundaries, not block boundaries. Blocks are network transfer units, but pieces are integrity units. A single corrupted block invalidates the entire piece.\n\n**Hash Verification State Machine:**\n\n| Current State | Event | Next State | Actions Taken |\n|---------------|-------|------------|---------------|\n| Downloading | All blocks received | Verifying | Concatenate blocks, compute SHA1 |\n| Verifying | Hash matches expected | Complete | Write to disk, update bitfield, notify peers |\n| Verifying | Hash mismatch | Failed | Discard data, reset block states, ban peer |\n| Failed | Retry requested | Downloading | Clear piece state, re-request blocks |\n| Complete | Seed request received | Complete | Serve piece data from disk |\n\n⚠️ **Pitfall: Partial Piece Verification**\nMany implementations attempt to verify pieces before all blocks are received, or try to verify individual blocks. This is fundamentally wrong because SHA1 hashes are computed over complete pieces. Attempting early verification leads to false negatives and wasted computation. Always wait for complete piece assembly before verification.\n\n⚠️ **Pitfall: Memory vs Disk Trade-offs**\nHolding multiple complete pieces in memory during verification can consume significant RAM (megabytes per piece). However, writing unverified data to disk risks file corruption. The solution is careful memory management: verify pieces immediately upon completion and implement memory pressure handling by prioritizing verification of the oldest complete pieces first.\n\n**Corruption Handling Strategy:**\n\nWhen piece verification fails, the client must implement a sophisticated response that balances network efficiency with peer reputation management. The failure could indicate a transmission error (temporary) or a malicious peer (permanent). Our approach prioritizes data integrity while maintaining reasonable download performance.\n\n| Failure Scenario | Detection Method | Response Strategy | Peer Impact |\n|-------------------|------------------|-------------------|-------------|\n| Single block corruption | Hash mismatch | Re-request all piece blocks from different peers | Mark suspect peer, don't ban immediately |\n| Repeated failures from peer | Multiple hash failures | Ban peer, close connection | Add to peer blacklist |\n| Systematic corruption | Hash failures across multiple pieces | Re-request from different peer set | Evaluate peer selection algorithm |\n| Network transmission error | Occasional random failures | Retry with exponential backoff | No peer penalty |\n\n### Piece Selection Strategy\n\nPiece selection determines download efficiency and swarm health through sophisticated algorithms that balance individual download speed with overall network resilience. The primary strategy, **rarest-first selection**, prioritizes pieces held by the fewest peers, ensuring that scarce content remains available even as peers leave the swarm.\n\nThink of rarest-first as **digital archaeology** where you prioritize acquiring the most fragile artifacts first. If a piece is only held by one peer, losing that peer means the entire swarm loses access to that piece, potentially making the file incompletable. By prioritizing rare pieces, we improve overall swarm health while ensuring our own download can complete.\n\n**Rarest-First Algorithm:**\n1. For each connected peer, maintain a bitfield indicating which pieces they possess\n2. For each piece we still need, count how many connected peers possess it (availability count)\n3. Sort needed pieces by ascending availability count, breaking ties by piece index\n4. When selecting the next piece to request, choose the piece with the lowest availability count that we haven't started downloading\n5. If multiple pieces have the same (lowest) availability, prefer pieces closer to the beginning of the file for sequential access benefits\n6. Once a piece is selected, immediately begin requesting blocks from peers that have the piece\n\n> The fundamental insight is that rarest-first is an **insurance policy** for the swarm. By ensuring rare pieces get distributed quickly, we prevent scenarios where the swarm becomes incomplete due to peer departure.\n\n**Availability Tracking Data Structures:**\n\n| Data Structure | Purpose | Update Triggers | Performance Characteristics |\n|----------------|---------|-----------------|---------------------------|\n| Piece availability map | Maps piece index to peer count | Peer connect/disconnect, bitfield/have messages | O(1) lookup, O(n) update on peer change |\n| Needed piece priority queue | Sorted list of pieces by rarity | Piece completion, availability changes | O(log n) insertion, O(1) top access |\n| Peer piece bitfields | Which pieces each peer has | Initial bitfield, subsequent have messages | O(1) lookup per peer, O(m) storage per peer |\n| In-progress piece set | Pieces currently being downloaded | Piece selection, completion, failure | O(1) membership test, prevents duplicate requests |\n\n**Advanced Selection Strategies:**\n\nBeyond basic rarest-first, sophisticated clients implement additional strategies for different phases of the download process:\n\n**Random First Phase:** For the initial pieces, some clients use random selection rather than rarest-first. This provides faster startup by avoiding competition for the same rare pieces among new peers in the swarm. Random first typically applies to the first 4-8 pieces.\n\n**Endgame Mode:** When only a few pieces remain (typically less than 10% of total pieces), switch to endgame mode where all remaining blocks are requested from all available peers. This prevents the download from stalling on slow peers holding the last few pieces. Endgame mode requires careful duplicate request handling to avoid wasting bandwidth.\n\n**Sequential Mode:** For streaming applications, sequential selection downloads pieces in file order rather than rarity order. This enables playback of media files before download completion but can harm swarm health by reducing piece diversity.\n\n**Endgame Mode Algorithm:**\n1. Trigger when fewer than `MAX_ENDGAME_PIECES` (typically 10-20) pieces remain incomplete\n2. For each remaining block in any incomplete piece, send requests to ALL peers that have the corresponding piece\n3. When any peer sends a block, immediately send cancel messages to all other peers that were requested for the same block\n4. Continue until all pieces are complete, accepting the bandwidth overhead for guaranteed completion\n\n| Selection Strategy | Phase | Priority Metric | Benefits | Drawbacks |\n|--------------------|-------|-----------------|----------|-----------|\n| Random First | Startup (first ~5 pieces) | Random selection | Fast startup, reduced competition | Ignores rarity, may hurt swarm |\n| Rarest First | Main download | Ascending availability count | Improves swarm health, ensures completion | Can be slow for initial pieces |\n| Endgame | Final ~10 pieces | Request from all available peers | Prevents stalling, guaranteed completion | High bandwidth overhead |\n| Sequential | Streaming use cases | File offset order | Enables progressive playback | Poor swarm health, inefficient |\n\n⚠️ **Pitfall: Availability Count Staleness**\nAvailability counts can become stale when peers disconnect without notification or when bitfield updates are missed. Stale counts lead to poor piece selection decisions. The solution is periodic availability recalculation and timeout-based peer connection validation. Implement a background task that recalculates availability counts every 60-120 seconds.\n\n⚠️ **Pitfall: Endgame Mode Triggering**\nTriggering endgame mode too early wastes bandwidth through duplicate requests. Triggering too late causes stalling on slow peers. Monitor both the absolute number of remaining pieces AND the download rate. If download rate drops below a threshold AND few pieces remain, consider endgame mode even if the piece count hasn't reached the normal threshold.\n\n![Piece Selection Algorithm](./diagrams/piece-selection-flow.svg)\n\n### Concurrent Download Management\n\nConcurrent download management orchestrates multiple peer connections to maximize throughput while avoiding conflicts and ensuring efficient resource utilization. This involves coordinating piece requests across peers, managing block-level request pipelining, and handling the complex state synchronization required for safe concurrent access to shared data structures.\n\nThink of concurrent download management as conducting a **symphony orchestra** where each musician (peer connection) plays their part (downloads specific pieces) while following the conductor's coordination (piece manager) to create harmonious music (efficient file download). Each musician has different capabilities (bandwidth, piece availability) and may occasionally miss notes (network failures), requiring real-time adaptation and coordination.\n\nThe primary challenge is **request coordination** - ensuring that multiple peers don't waste bandwidth downloading the same blocks while maintaining sufficient request pipelining to keep connections busy. This requires sophisticated state tracking and communication between peer connection handlers and the central piece manager.\n\n**Concurrent Download Architecture:**\n\nThe system employs a **centralized coordination** model where a single `PieceManager` component orchestrates downloads across multiple `PeerConnection` instances. This design trades some efficiency for simplicity and correctness, avoiding the complex distributed coordination required in fully decentralized approaches.\n\n| Component | Responsibilities | Concurrency Model | State Management |\n|-----------|------------------|-------------------|------------------|\n| PieceManager | Piece selection, request coordination, verification | Single goroutine with channels | Centralized piece state, availability tracking |\n| PeerConnection | Block requests, message handling, peer state | One goroutine per peer | Local peer state, pending requests |\n| RequestCoordinator | Block assignment, duplicate prevention | Shared state with mutexes | Block reservation map, timeout tracking |\n| VerificationQueue | Hash computation, disk writes | Dedicated worker pool | Verification work queue, completion callbacks |\n\n**Request Coordination Protocol:**\n\nEffective request coordination prevents bandwidth waste while ensuring sufficient parallelism. The protocol operates through a reservation system where blocks are reserved before requests are sent, preventing duplicate downloads.\n\n**Block Request Algorithm:**\n1. `PeerConnection` requests work from `PieceManager` by sending a work request message\n2. `PieceManager` selects the highest-priority piece that the peer has and we need\n3. `PieceManager` identifies unreserved blocks within the selected piece (blocks not currently being downloaded by other peers)\n4. Reserve up to `MAX_PIPELINE_DEPTH` blocks for this peer, marking them as \"reserved\" with peer ID and timestamp\n5. Return block list to `PeerConnection` for immediate request transmission\n6. `PeerConnection` sends BitTorrent request messages to the peer for each reserved block\n7. Track pending requests with timeouts; if no response within `BLOCK_TIMEOUT`, return blocks to unreserved state\n8. When block data arrives, forward to `PieceManager` for assembly and potential verification\n\n| Request State | Meaning | Timeout | Transition Triggers |\n|---------------|---------|---------|-------------------|\n| Available | Block can be requested | N/A | New piece selected, block request timeout |\n| Reserved | Block assigned to peer | 30-60 seconds | Block request sent to peer |\n| Requested | Request sent to peer | 120-180 seconds | Block data received, peer disconnect |\n| Received | Data received, awaiting assembly | N/A | All piece blocks received |\n\n**Synchronization and Locking Strategy:**\n\nConcurrent access to shared piece state requires careful synchronization to prevent race conditions while maintaining performance. The design uses a combination of channels for coordination and fine-grained locking for shared data structures.\n\n> **Decision: Channel-Based vs Mutex-Based Coordination**\n> - **Context**: Multiple goroutines need coordinated access to piece state, request queues, and peer availability information.\n> - **Options Considered**: Pure channel-based CSP model, Pure mutex-based shared memory, Hybrid approach with channels for coordination and mutexes for data\n> - **Decision**: Hybrid approach with channels for major coordination and fine-grained mutexes for shared data structures\n> - **Rationale**: Channels provide clean coordination semantics for work distribution, while mutexes offer efficient access to frequently-read data like bitfields and availability maps.\n> - **Consequences**: Simpler reasoning about coordination flows but requires discipline to avoid deadlocks between channel operations and mutex acquisition.\n\n**Concurrency Synchronization Points:**\n\n| Shared Resource | Protection Mechanism | Access Pattern | Lock Granularity |\n|------------------|---------------------|----------------|------------------|\n| Piece availability map | Read-write mutex | Frequent reads, rare writes | Per-piece or global RWMutex |\n| Block reservation map | Mutex | Moderate read/write | Per-piece or global mutex |\n| Peer bitfields | Read-write mutex | Frequent reads during selection | Per-peer RWMutex |\n| Piece completion status | Atomic operations | High-frequency status checks | Lock-free with atomic.Bool |\n| Download statistics | Atomic operations | Frequent updates, periodic reads | Lock-free counters |\n\n⚠️ **Pitfall: Lock Ordering and Deadlocks**\nWhen multiple locks must be acquired, inconsistent ordering leads to deadlocks. Establish a clear lock hierarchy: always acquire piece-level locks before peer-level locks, and never hold a peer lock while waiting for a piece lock. Use timeouts on lock acquisition in critical paths to detect potential deadlocks.\n\n⚠️ **Pitfall: Request Pipeline Starvation**\nIf piece selection is too slow or block reservation contention is high, peer connections can starve for work, leading to underutilized bandwidth. Implement request pipeline depth monitoring and preemptive block reservation to ensure each peer connection always has 3-5 outstanding requests.\n\n![Multi-Peer Download Coordination](./diagrams/concurrent-download.svg)\n\n### Upload and Seeding\n\nUpload and seeding capabilities transform our client from a simple downloader into a full participant in the BitTorrent ecosystem. This involves serving piece data to other peers, implementing fair sharing policies, tracking upload statistics for tracker reporting, and maintaining connections specifically for seeding purposes.\n\nThink of seeding as **running a specialized library** where you've completed collecting a particular book series and now help other collectors find the volumes they need. You need to track which books you have, respond to requests efficiently, maintain fair lending policies (not always serving the same frequent borrower), and keep statistics on how much you've helped the community.\n\nThe seeding process requires **role reversal** from the downloading logic - instead of selecting pieces to request, you respond to incoming requests by serving data from your completed files. However, the underlying mechanisms (message handling, connection management, piece verification) remain largely the same.\n\n**Upload Request Handling:**\n\nWhen acting as a seeder, the client receives `MsgRequest` messages from peers asking for specific blocks. The upload handler must validate requests, check local piece availability, read data from disk, and respond with `MsgPiece` messages containing the requested data.\n\n**Upload Response Algorithm:**\n1. Receive `MsgRequest` message containing piece index, block offset, and block length\n2. Validate request parameters: piece index within torrent bounds, offset aligned to block boundaries, length not exceeding maximum block size\n3. Check local bitfield to confirm we have the requested piece (respond with rejection if not available)\n4. Verify peer is not choked - if choked, ignore the request (peer should not have sent it)\n5. Read requested data from the appropriate file offset on disk (piece_index × piece_length + block_offset)\n6. Construct `MsgPiece` response with piece index, block offset, and data payload\n7. Send response to peer and update upload statistics (bytes uploaded, pieces served)\n8. Apply bandwidth limiting if configured to prevent overwhelming network connection\n\n| Request Validation | Check | Failure Response | Security Implication |\n|-------------------|-------|------------------|---------------------|\n| Piece bounds | `0 ≤ piece_index < total_pieces` | Ignore request | Prevents buffer overruns |\n| Block offset alignment | `offset % BLOCK_SIZE == 0` | Ignore request | Ensures proper block boundaries |\n| Block length limits | `length ≤ BLOCK_SIZE` | Ignore request | Prevents excessive memory allocation |\n| Peer choke state | `!peer_choking` | Ignore request | Enforces BitTorrent protocol |\n| Local piece availability | `HasPiece(piece_index)` | Ignore or send rejection | Prevents serving unavailable data |\n\n**Choking and Unchoking Policy:**\n\nBitTorrent's choking mechanism implements **tit-for-tat reciprocity** where peers prioritize uploading to those who provide good download speeds in return. This creates incentives for mutual cooperation while preventing pure \"leeching\" behavior that would harm the swarm.\n\n**Standard Choking Algorithm:**\n1. Maintain upload rate statistics for each connected peer over the last 20-30 seconds\n2. Every 10 seconds (choking round), recalculate which peers to unchoke based on their download rates to us\n3. Unchoke the top 3-4 peers providing the best download rates (reciprocal unchoking)\n4. Additionally, unchoke one random peer every 30 seconds (optimistic unchoking) to discover new high-speed peers\n5. Send `MsgChoke` to peers being choked and `MsgUnchoke` to peers being unchoked\n6. Peers that are choked should not send requests; ignore any requests from choked peers\n\n| Choking Category | Selection Criteria | Update Frequency | Purpose |\n|------------------|-------------------|------------------|---------|\n| Reciprocal Unchoke | Top 3-4 peers by download rate to us | Every 10 seconds | Reward peers providing good service |\n| Optimistic Unchoke | Random peer selection | Every 30 seconds | Discover new high-speed peers |\n| Seed Optimistic | Random among interested peers | Every 30 seconds | Distribute pieces when we're seeding |\n| Anti-snubbing | Peers not choking us | When snubbed | Maintain reciprocity relationships |\n\n**Seeding-Specific Adaptations:**\n\nWhen seeding (upload-only mode after download completion), the choking algorithm adapts since there are no download rates to reciprocate. Seeding policies focus on **fairness** and **swarm health** rather than direct reciprocity.\n\n**Seeding Upload Policy:**\n1. Prefer peers with the lowest upload rates (helping slower peers)\n2. Rotate unchoked peers regularly to ensure fair access across the swarm\n3. Prioritize peers requesting rare pieces to improve swarm piece distribution\n4. Implement bandwidth limits to prevent seeding from overwhelming the connection\n5. Consider peer reputation and protocol compliance when making unchoking decisions\n\n⚠️ **Pitfall: Upload Without Download Tracking**\nWhen seeding, it's tempting to remove download rate tracking since we're not downloading. However, proper reciprocity tracking is essential for effective peer relationships. Maintain download statistics even while seeding - they inform which peers to prioritize and help identify protocol violations.\n\n⚠️ **Pitfall: Disk I/O Performance**\nServing upload requests requires frequent disk reads at random offsets, which can become a performance bottleneck with many concurrent requesters. Implement an LRU piece cache in memory to serve frequently requested pieces without disk access. Monitor disk I/O patterns and consider read-ahead strategies for sequential requests.\n\n**Upload Statistics and Tracker Reporting:**\n\nAccurate upload statistics are essential for tracker communication and monitoring seeding effectiveness. The client must track bytes uploaded, pieces served, and upload rates for both local monitoring and tracker reporting.\n\n| Upload Metric | Tracking Granularity | Reporting Frequency | Purpose |\n|---------------|---------------------|-------------------|---------|\n| Total bytes uploaded | Global counter | Every tracker announce | Tracker reporting, ratio monitoring |\n| Upload rate (current) | 30-second rolling average | Continuous | Choking decisions, bandwidth monitoring |\n| Pieces served | Per-piece counters | On piece completion | Swarm health analysis |\n| Peer upload rates | Per-peer statistics | 20-second windows | Reciprocity calculations |\n| Bandwidth utilization | Connection-level monitoring | Real-time | Bandwidth limiting, QoS |\n\n### Common Piece Management Pitfalls\n\nPiece management introduces complex state coordination and timing challenges that frequently trip up implementations. Understanding these common pitfalls helps avoid subtle bugs that can lead to download failures, data corruption, or poor performance.\n\n⚠️ **Pitfall: Race Conditions in Piece Completion**\nMultiple peer connections may simultaneously complete different blocks of the same piece, leading to race conditions during piece assembly and verification. The symptom is pieces being verified multiple times or verification failing due to incomplete piece data.\n\n**Problem:** Two peers send the final blocks of a piece simultaneously. Both connections detect piece completion and attempt verification concurrently, but one connection may start verification before the other's block is incorporated.\n\n**Solution:** Use atomic piece completion detection with compare-and-swap operations. Only allow one goroutine to transition a piece from \"downloading\" to \"verifying\" state. Implement piece-level mutexes for assembly operations.\n\n```go\n// Example of atomic piece completion\nif atomic.CompareAndSwapInt32(&piece.state, StateDownloading, StateVerifying) {\n    // Only one goroutine will execute this verification\n    go verifyPiece(piece)\n}\n```\n\n⚠️ **Pitfall: Memory Leaks from Uncompleted Pieces**\nPieces that never complete (due to peer disconnections or failures) can accumulate partial block data in memory indefinitely, leading to memory leaks in long-running clients.\n\n**Problem:** Peers disconnect while downloading pieces, leaving partially completed pieces with allocated block buffers that are never freed because the piece never enters the cleanup path.\n\n**Solution:** Implement periodic piece cleanup that identifies pieces stuck in downloading state for extended periods. Add reference counting for block data and timeout-based cleanup for abandoned pieces.\n\n⚠️ **Pitfall: Inefficient Piece Selection Updates**\nRecalculating piece priorities after every peer connection change or piece completion can become a performance bottleneck with large torrents and many peers.\n\n**Problem:** With 1000+ piece torrents and dozens of peers, naively recalculating the entire piece priority queue after each bitfield update results in O(n log n) operations that can consume significant CPU time.\n\n**Solution:** Implement incremental priority updates that only recalculate affected pieces. Use efficient data structures like priority queues that support decrease-key operations for targeted updates.\n\n⚠️ **Pitfall: Verification CPU Blocking**\nComputing SHA1 hashes for large pieces (1MB+) in the main goroutine blocks other operations, leading to poor responsiveness and connection timeouts.\n\n**Problem:** SHA1 computation for large pieces can take several milliseconds, during which the piece manager cannot respond to new requests or handle peer messages, causing apparent hangs.\n\n**Solution:** Perform verification in a dedicated worker pool. Use channels to queue verification work and return results asynchronously. Implement verification priority queues to prioritize pieces needed for immediate requests.\n\n⚠️ **Pitfall: Endgame Mode Bandwidth Waste**\nPoorly implemented endgame mode can waste enormous bandwidth by continuing to request blocks that have already been received from faster peers.\n\n**Problem:** Endgame mode sends duplicate requests to all available peers but fails to promptly cancel requests when blocks arrive, leading to multiple peers sending the same block data.\n\n**Solution:** Implement aggressive request cancellation in endgame mode. When any block arrives, immediately send cancel messages to all other peers that were sent requests for that block. Track which peers have been sent cancel messages to avoid redundant cancellations.\n\n⚠️ **Pitfall: Disk I/O Concurrency Issues**\nMultiple goroutines attempting to write different pieces to the same file simultaneously can lead to corruption or poor performance due to seek thrashing.\n\n**Problem:** Concurrent piece writes to random file offsets cause excessive disk seeking and potential data races if file operations aren't properly synchronized.\n\n**Solution:** Implement a disk I/O coordinator that serializes writes to the same file. Use file-level mutexes or dedicated I/O worker goroutines per file. Consider write coalescing for pieces that map to the same file regions.\n\n| Pitfall Category | Primary Symptom | Detection Method | Prevention Strategy |\n|------------------|-----------------|------------------|-------------------|\n| Race Conditions | Verification failures, corrupt pieces | Stress testing with many peers | Atomic state transitions, piece-level locking |\n| Memory Leaks | Growing memory usage | Memory profiling, leak detection | Timeout-based cleanup, reference counting |\n| Performance Issues | High CPU usage, slow response | CPU profiling, latency monitoring | Incremental updates, async operations |\n| Protocol Violations | Peer disconnections, bandwidth waste | Network traffic analysis | Strict protocol compliance, proper cancellation |\n\n### Implementation Guidance\n\nThis implementation guidance provides concrete Go code for building the piece management and seeding system. The focus is on providing complete infrastructure components and detailed skeletons for the core learning algorithms.\n\n**A. Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Hash Computation | `crypto/sha1` with `io.Copy` | Worker pool with `crypto/sha1` for parallelism |\n| Disk I/O | `os.File` with `Seek` and `Read/Write` | Memory-mapped files with `syscall.Mmap` |\n| Concurrency Coordination | Channels with `select` statements | `sync.WaitGroup` and `context.Context` trees |\n| State Management | Maps with `sync.RWMutex` | Lock-free structures with `sync/atomic` |\n| Priority Queues | `container/heap` with custom types | Third-party libraries like `github.com/emirpasic/gods` |\n\n**B. Recommended File Structure:**\n\n```\ninternal/\n  piece/\n    manager.go           ← PieceManager and coordination logic\n    state.go            ← PieceState and Block data structures  \n    verification.go     ← Hash verification worker pool\n    selection.go        ← Piece selection algorithms\n    upload.go           ← Upload handling and seeding logic\n    manager_test.go     ← Unit tests for piece management\n  download/\n    coordinator.go      ← Multi-peer download coordination\n    endgame.go         ← Endgame mode implementation\n    statistics.go      ← Upload/download statistics tracking\n```\n\n**C. Infrastructure Code - Verification Worker Pool:**\n\n```go\n// internal/piece/verification.go\npackage piece\n\nimport (\n    \"crypto/sha1\"\n    \"fmt\"\n    \"sync\"\n)\n\n// VerificationRequest represents a piece that needs hash verification\ntype VerificationRequest struct {\n    PieceIndex int\n    Data       []byte\n    ExpectedHash [20]byte\n    Callback   func(pieceIndex int, verified bool)\n}\n\n// VerificationPool manages concurrent piece verification\ntype VerificationPool struct {\n    workers    int\n    requests   chan VerificationRequest\n    wg         sync.WaitGroup\n    shutdown   chan struct{}\n}\n\n// NewVerificationPool creates a verification worker pool\nfunc NewVerificationPool(workers int) *VerificationPool {\n    pool := &VerificationPool{\n        workers:  workers,\n        requests: make(chan VerificationRequest, workers*2),\n        shutdown: make(chan struct{}),\n    }\n    \n    // Start worker goroutines\n    for i := 0; i < workers; i++ {\n        pool.wg.Add(1)\n        go pool.worker()\n    }\n    \n    return pool\n}\n\n// SubmitVerification queues a piece for verification\nfunc (p *VerificationPool) SubmitVerification(req VerificationRequest) {\n    select {\n    case p.requests <- req:\n        // Successfully queued\n    case <-p.shutdown:\n        // Pool is shutting down\n        req.Callback(req.PieceIndex, false)\n    }\n}\n\n// worker processes verification requests\nfunc (p *VerificationPool) worker() {\n    defer p.wg.Done()\n    \n    for {\n        select {\n        case req := <-p.requests:\n            verified := p.verifyPiece(req.Data, req.ExpectedHash)\n            req.Callback(req.PieceIndex, verified)\n        case <-p.shutdown:\n            return\n        }\n    }\n}\n\n// verifyPiece computes SHA1 and compares with expected hash\nfunc (p *VerificationPool) verifyPiece(data []byte, expected [20]byte) bool {\n    computed := sha1.Sum(data)\n    return computed == expected\n}\n\n// Shutdown gracefully stops the verification pool\nfunc (p *VerificationPool) Shutdown() {\n    close(p.shutdown)\n    p.wg.Wait()\n    close(p.requests)\n}\n```\n\n**D. Infrastructure Code - Priority Queue for Piece Selection:**\n\n```go\n// internal/piece/selection.go\npackage piece\n\nimport (\n    \"container/heap\"\n    \"sync\"\n)\n\n// PiecePriority represents a piece with its priority for selection\ntype PiecePriority struct {\n    Index        int\n    Availability int  // Lower is higher priority (rarest first)\n    Priority     int  // Manual priority adjustment\n}\n\n// PriorityQueue implements heap.Interface for piece selection\ntype PriorityQueue []*PiecePriority\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    // Primary: lowest availability (rarest first)\n    if pq[i].Availability != pq[j].Availability {\n        return pq[i].Availability < pq[j].Availability\n    }\n    // Secondary: manual priority\n    if pq[i].Priority != pq[j].Priority {\n        return pq[i].Priority > pq[j].Priority\n    }\n    // Tertiary: lowest index (sequential preference)\n    return pq[i].Index < pq[j].Index\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    *pq = append(*pq, x.(*PiecePriority))\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    *pq = old[0 : n-1]\n    return item\n}\n\n// PieceSelector manages piece selection with thread-safe priority queue\ntype PieceSelector struct {\n    queue     PriorityQueue\n    available map[int]int  // piece index -> availability count\n    needed    map[int]bool // pieces we still need\n    mutex     sync.RWMutex\n}\n\n// NewPieceSelector creates a piece selector for the given torrent\nfunc NewPieceSelector(totalPieces int) *PieceSelector {\n    return &PieceSelector{\n        queue:     make(PriorityQueue, 0),\n        available: make(map[int]int),\n        needed:    make(map[int]bool),\n    }\n}\n\n// UpdateAvailability updates piece availability from peer bitfields\nfunc (ps *PieceSelector) UpdateAvailability(pieceIndex int, available bool) {\n    ps.mutex.Lock()\n    defer ps.mutex.Unlock()\n    \n    if available {\n        ps.available[pieceIndex]++\n    } else {\n        ps.available[pieceIndex]--\n        if ps.available[pieceIndex] <= 0 {\n            delete(ps.available, pieceIndex)\n        }\n    }\n    \n    // Rebuild priority queue if needed\n    ps.rebuildQueue()\n}\n\n// SelectNextPiece returns the highest priority piece we need\nfunc (ps *PieceSelector) SelectNextPiece(peerBitfield *BitfieldOps) int {\n    ps.mutex.RLock()\n    defer ps.mutex.RUnlock()\n    \n    // Find highest priority piece that peer has and we need\n    for ps.queue.Len() > 0 {\n        piece := heap.Pop(&ps.queue).(*PiecePriority)\n        \n        if ps.needed[piece.Index] && peerBitfield.HasPiece(piece.Index) {\n            return piece.Index\n        }\n    }\n    \n    return -1 // No suitable piece found\n}\n\n// MarkComplete removes a piece from needed set\nfunc (ps *PieceSelector) MarkComplete(pieceIndex int) {\n    ps.mutex.Lock()\n    defer ps.mutex.Unlock()\n    \n    delete(ps.needed, pieceIndex)\n    ps.rebuildQueue()\n}\n\n// rebuildQueue reconstructs priority queue (call with mutex held)\nfunc (ps *PieceSelector) rebuildQueue() {\n    ps.queue = ps.queue[:0]\n    \n    for pieceIndex := range ps.needed {\n        availability := ps.available[pieceIndex]\n        piece := &PiecePriority{\n            Index:        pieceIndex,\n            Availability: availability,\n            Priority:     0, // Default priority\n        }\n        heap.Push(&ps.queue, piece)\n    }\n}\n```\n\n**E. Core Logic Skeleton - Piece Manager:**\n\n```go\n// internal/piece/manager.go\npackage piece\n\nimport (\n    \"context\"\n    \"sync\"\n    \"time\"\n)\n\n// PieceManager coordinates piece downloads, verification, and serving\ntype PieceManager struct {\n    metaInfo        *torrent.MetaInfo\n    pieces          map[int]*PieceState\n    selector        *PieceSelector\n    verificationPool *VerificationPool\n    statistics      *Statistics\n    mutex           sync.RWMutex\n    \n    // Channels for coordination\n    workRequests    chan WorkRequest\n    blockData       chan BlockData\n    verificationResults chan VerificationResult\n}\n\n// WorkRequest represents a peer asking for work\ntype WorkRequest struct {\n    PeerID    string\n    Bitfield  *BitfieldOps\n    Response  chan WorkResponse\n}\n\n// WorkResponse contains blocks assigned to a peer\ntype WorkResponse struct {\n    Blocks []BlockRequest\n    Error  error\n}\n\n// BlockRequest represents a specific block to download\ntype BlockRequest struct {\n    PieceIndex int\n    Offset     int\n    Length     int\n}\n\n// NewPieceManager creates a piece manager for the given torrent\nfunc NewPieceManager(metaInfo *torrent.MetaInfo) *PieceManager {\n    // TODO 1: Initialize piece state map with one PieceState per piece\n    // TODO 2: Create piece selector with total piece count\n    // TODO 3: Initialize verification pool with appropriate worker count\n    // TODO 4: Set up communication channels with proper buffer sizes\n    // TODO 5: Start main coordination goroutine\n    // Hint: Use len(metaInfo.Info.GetPieceHashes()) for piece count\n    panic(\"implement NewPieceManager\")\n}\n\n// RequestWork assigns blocks to a peer for downloading\nfunc (pm *PieceManager) RequestWork(peerID string, peerBitfield *BitfieldOps) ([]BlockRequest, error) {\n    // TODO 1: Create WorkRequest with peer information\n    // TODO 2: Send request on workRequests channel\n    // TODO 3: Wait for response on the response channel\n    // TODO 4: Return assigned blocks or error\n    // Hint: Use buffered response channel to avoid goroutine leaks\n    panic(\"implement RequestWork\")\n}\n\n// SubmitBlockData processes received block data\nfunc (pm *PieceManager) SubmitBlockData(peerID string, pieceIndex, offset int, data []byte) error {\n    // TODO 1: Validate block parameters (bounds checking)\n    // TODO 2: Create BlockData message\n    // TODO 3: Send on blockData channel for processing\n    // TODO 4: Update download statistics\n    // Hint: Validate offset + len(data) doesn't exceed piece bounds\n    panic(\"implement SubmitBlockData\")\n}\n\n// ServeUploadRequest handles requests from other peers\nfunc (pm *PieceManager) ServeUploadRequest(pieceIndex, offset, length int) ([]byte, error) {\n    // TODO 1: Validate request parameters\n    // TODO 2: Check if we have the requested piece\n    // TODO 3: Read data from disk at appropriate offset\n    // TODO 4: Update upload statistics\n    // TODO 5: Return requested data\n    // Hint: Calculate file offset as piece_index * piece_length + offset\n    panic(\"implement ServeUploadRequest\")\n}\n\n// coordinator is the main coordination goroutine\nfunc (pm *PieceManager) coordinator(ctx context.Context) {\n    for {\n        select {\n        case workReq := <-pm.workRequests:\n            // TODO 1: Use piece selector to find next piece for this peer\n            // TODO 2: Find unreserved blocks in the selected piece\n            // TODO 3: Reserve blocks for this peer with timeout\n            // TODO 4: Create BlockRequest list\n            // TODO 5: Send response on workReq.Response channel\n            // Hint: Limit blocks per peer to MAX_PIPELINE_DEPTH (5-10)\n            \n        case blockData := <-pm.blockData:\n            // TODO 1: Find the piece state for this block\n            // TODO 2: Add block data to piece assembly buffer\n            // TODO 3: Check if piece is now complete (all blocks received)\n            // TODO 4: If complete, submit for verification\n            // TODO 5: Update block reservation status\n            // Hint: Use atomic operations for piece completion detection\n            \n        case verifyResult := <-pm.verificationResults:\n            // TODO 1: Check verification result (hash match)\n            // TODO 2: If verified, mark piece complete and write to disk\n            // TODO 3: If failed, reset piece state for re-download\n            // TODO 4: Update bitfield and notify connected peers\n            // TODO 5: Update piece selector with completion status\n            // Hint: Send Have messages to all connected peers for verified pieces\n            \n        case <-ctx.Done():\n            return\n        }\n    }\n}\n\n// selectBlocksForPeer finds unreserved blocks in a piece for download\nfunc (pm *PieceManager) selectBlocksForPeer(pieceIndex int, maxBlocks int) []BlockRequest {\n    // TODO 1: Get piece state for the specified piece\n    // TODO 2: Iterate through blocks in the piece\n    // TODO 3: Find blocks that are not reserved or completed\n    // TODO 4: Reserve found blocks for this peer\n    // TODO 5: Create BlockRequest list up to maxBlocks limit\n    // Hint: Standard block size is 16KB except for the last block of a piece\n    panic(\"implement selectBlocksForPeer\")\n}\n\n// assemblePiece combines received blocks into complete piece data\nfunc (pm *PieceManager) assemblePiece(pieceIndex int) []byte {\n    // TODO 1: Get piece state and verify all blocks are present\n    // TODO 2: Calculate total piece size (may be less than piece_length for last piece)\n    // TODO 3: Create output buffer of appropriate size\n    // TODO 4: Copy each block's data to correct offset in output buffer\n    // TODO 5: Return assembled piece data\n    // Hint: Sort blocks by offset before assembly to ensure correct order\n    panic(\"implement assemblePiece\")\n}\n```\n\n**F. Core Logic Skeleton - Endgame Mode:**\n\n```go\n// internal/download/endgame.go\npackage download\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\n// EndgameManager handles aggressive downloading of final pieces\ntype EndgameManager struct {\n    pieceManager   *piece.PieceManager\n    connections    map[string]*peer.Connection\n    activeRequests map[BlockKey][]string  // block -> list of peers requested from\n    mutex          sync.RWMutex\n    enabled        bool\n}\n\n// BlockKey uniquely identifies a block\ntype BlockKey struct {\n    PieceIndex int\n    Offset     int\n}\n\n// NewEndgameManager creates endgame mode coordinator\nfunc NewEndgameManager(pm *piece.PieceManager) *EndgameManager {\n    return &EndgameManager{\n        pieceManager:   pm,\n        connections:    make(map[string]*peer.Connection),\n        activeRequests: make(map[BlockKey][]string),\n    }\n}\n\n// ShouldEnterEndgame determines if endgame mode should be activated\nfunc (em *EndgameManager) ShouldEnterEndgame() bool {\n    // TODO 1: Count remaining incomplete pieces\n    // TODO 2: Check current download rate trend\n    // TODO 3: Calculate percentage of completion\n    // TODO 4: Return true if conditions met for endgame\n    // Hint: Typical threshold is <20 pieces remaining and >95% complete\n    panic(\"implement ShouldEnterEndgame\")\n}\n\n// RequestAllRemaining sends requests for all incomplete blocks to all available peers\nfunc (em *EndgameManager) RequestAllRemaining() {\n    // TODO 1: Get list of all incomplete pieces\n    // TODO 2: For each piece, identify incomplete blocks\n    // TODO 3: For each block, send requests to all peers that have the piece\n    // TODO 4: Track all outstanding requests for cancellation\n    // TODO 5: Set timeouts for endgame requests (shorter than normal)\n    // Hint: Only request from peers that are not choking us\n    panic(\"implement RequestAllRemaining\")\n}\n\n// OnBlockReceived handles block completion in endgame mode\nfunc (em *EndgameManager) OnBlockReceived(pieceIndex, offset int, fromPeer string) {\n    // TODO 1: Create BlockKey for the received block\n    // TODO 2: Find all other peers that were sent requests for this block\n    // TODO 3: Send Cancel messages to those peers immediately\n    // TODO 4: Remove block from active requests tracking\n    // TODO 5: Update statistics for bandwidth saved by cancellation\n    // Hint: Send cancellation even if peer hasn't responded yet\n    panic(\"implement OnBlockReceived\")\n}\n```\n\n**G. Milestone Checkpoint:**\n\nAfter implementing piece management and seeding:\n\n1. **Basic Verification Test:**\n   ```bash\n   go test ./internal/piece/... -v\n   # Should pass all unit tests for piece management\n   ```\n\n2. **Integration Test with Real Torrent:**\n   ```bash\n   go run cmd/bittorrent/main.go download test.torrent output_file\n   # Should successfully download and verify a small torrent\n   ```\n\n3. **Expected Behavior Verification:**\n   - Piece selection should prioritize rarest pieces first\n   - Hash verification should reject corrupted pieces and re-request\n   - Multiple peer connections should coordinate without conflicts\n   - Seeding should respond to upload requests from other clients\n   - Download should enter endgame mode for final pieces\n\n4. **Performance Monitoring:**\n   - Monitor piece verification time (should be <100ms per piece)\n   - Check memory usage (should not grow unboundedly)\n   - Verify concurrent download efficiency (multiple active peers)\n   - Measure upload responsiveness (request handling latency)\n\n**H. Debugging Tips:**\n\n| Symptom | Likely Cause | Diagnosis Method | Fix |\n|---------|--------------|------------------|-----|\n| Download stalls at 99% | Endgame mode not triggered | Check remaining piece count | Implement proper endgame threshold |\n| Hash verification failures | Network corruption or malicious peer | Log piece hashes and peer sources | Add peer reputation tracking |\n| Memory usage grows constantly | Piece cleanup not working | Profile memory allocation | Implement timeout-based cleanup |\n| Poor download speed | Inefficient piece selection | Analyze piece request patterns | Optimize rarest-first algorithm |\n| Upload requests ignored | Choking logic errors | Check peer choke/unchoke states | Fix reciprocity algorithm |\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** This section integrates all four milestones (1-4) by showing how torrent parsing, tracker communication, peer protocols, and piece management work together during the complete download lifecycle.\n\nBuilding a BitTorrent client involves orchestrating multiple concurrent subsystems that must work together seamlessly. Think of this like conducting a symphony orchestra where each musician (component) has their own part to play, but the magic happens when they synchronize their timing and harmonize their contributions. The torrent parser provides the sheet music, the tracker acts as the concert program listing all performers, the peer connections are the individual instruments playing their parts, and the piece manager is the conductor ensuring everything comes together into a coherent performance.\n\nThis orchestration becomes particularly complex because BitTorrent operates in a highly concurrent, distributed environment where failures are common and coordination must happen without central control. Unlike a traditional client-server application where one component controls the flow, BitTorrent requires careful choreography between autonomous components that each maintain their own state and make independent decisions while contributing to the collective goal of file transfer.\n\nThe key architectural challenge is managing shared state and coordination points without introducing race conditions or deadlocks. Each component operates in its own goroutines with its own lifecycle, but they must coordinate access to shared data structures like piece availability maps, peer connection pools, and download progress tracking. This requires careful design of synchronization primitives and message passing patterns.\n\n### Complete Download Lifecycle\n\nThe BitTorrent download process follows a well-defined sequence that progresses through distinct phases, each building upon the previous phase's results. Think of this like planning and executing a complex heist where each step must be completed successfully before the next can begin, but once the operation is underway, multiple activities happen simultaneously while maintaining coordination.\n\n**Phase 1: Initialization and Metadata Extraction**\n\nThe lifecycle begins when a user provides a torrent file path to the client. The `TorrentParser` immediately takes control and begins the metadata extraction process. This phase is entirely synchronous and must complete successfully before any networking can begin.\n\nThe parser creates a `Decoder` instance and begins parsing the bencode structure. As it processes the torrent file, it extracts critical information including the announce URL, file information, piece length, and piece hashes. Most importantly, it calculates the info hash by taking the SHA-1 digest of the exact bencoded bytes of the info dictionary. This info hash becomes the unique identifier that ties together all subsequent operations.\n\nOnce parsing completes successfully, the system has a complete `MetaInfo` structure containing all the information needed to begin the download. At this point, the client calculates derived information like the total file size, expected number of pieces, and creates the initial piece state map where every piece is marked as needed and unavailable.\n\n> The info hash calculation during this phase is critical because it serves as the cryptographic fingerprint that ensures all peers are working on exactly the same file. Even a single byte difference in the original torrent would produce a completely different info hash, preventing any coordination.\n\n**Phase 2: Peer Discovery Through Tracker Communication**\n\nWith the torrent metadata successfully parsed, the system transitions to peer discovery. The `TrackerClient` takes the lead in this phase, using the announce URL and info hash from the metadata to contact the tracker and obtain a list of peers participating in the swarm.\n\nThe tracker client constructs an `AnnounceRequest` containing the info hash, a randomly generated peer ID, the port the client will listen on, and initial statistics (zero bytes uploaded/downloaded, total bytes left equal to file size). This request gets sent as an HTTP GET to the tracker's announce URL with proper URL encoding of binary fields.\n\nWhen the tracker responds with an `AnnounceResponse`, the system parses the compact peer list to extract IP addresses and ports of available peers. The tracker also provides an announce interval that determines when the client should next contact the tracker to update its status and refresh the peer list.\n\nThis phase typically completes quickly (within a few seconds) but establishes an ongoing relationship with the tracker. The client schedules periodic re-announces that will continue throughout the download to report progress and discover new peers joining the swarm.\n\n**Phase 3: Concurrent Peer Connection Establishment**\n\nOnce the system has a list of potential peers, it enters the most complex phase where multiple activities happen simultaneously. The `PeerManager` begins establishing TCP connections to multiple peers in parallel, typically limiting itself to around 50 concurrent connections to avoid overwhelming the network or the local system.\n\nFor each successful TCP connection, the peer manager creates a `Connection` instance that immediately begins the BitTorrent handshake process. The handshake involves sending a 68-byte message containing the protocol identifier, info hash, and the client's peer ID, then waiting for the peer to respond with their own handshake message.\n\nSuccessful handshakes are followed immediately by an exchange of bitfield messages where each peer announces which pieces they currently have available. This bitfield information gets stored in each connection's state and becomes crucial for piece selection decisions.\n\nDuring this phase, connections may fail for various reasons: peers may be unreachable, handshakes may fail due to mismatched info hashes, or peers may disconnect. The system handles these failures gracefully by maintaining a pool of connection attempts and replacing failed connections with new attempts to different peers.\n\n**Phase 4: Coordinated Multi-Peer Downloading**\n\nWith multiple peer connections established and bitfield information exchanged, the system enters the core downloading phase where the `PieceManager` coordinates piece requests across all available peers. This is where the orchestration becomes most complex because multiple components must work together while maintaining high throughput.\n\nThe piece manager implements a rarest-first selection strategy where it continuously monitors which pieces are available from which peers and prioritizes downloading pieces that are held by the fewest peers. This strategy helps ensure that rare pieces get downloaded early, preventing situations where the download stalls because only one peer has a needed piece and that peer becomes unavailable.\n\nFor each peer connection, the piece manager examines the peer's bitfield and selects appropriate pieces to request based on the rarest-first algorithm and the peer's choking state. When a peer is unchoked and interested, the connection begins sending block requests for 16KB chunks within selected pieces, maintaining a pipeline of several outstanding requests to maximize throughput.\n\nAs block data arrives from peers, the piece manager buffers the blocks until an entire piece is complete, then immediately verifies the piece by computing its SHA-1 hash and comparing it to the expected hash from the torrent metadata. Successfully verified pieces get written to disk at the correct file offset and the piece is marked as complete in the system's piece map.\n\nThis coordination requires careful synchronization because multiple peers may be downloading different pieces simultaneously, pieces must be assembled in the correct order in the output file, and the system must track which blocks have been requested from which peers to avoid duplicate requests and detect when re-requests are needed.\n\n**Phase 5: Endgame and Completion**\n\nAs the download nears completion, the system enters endgame mode when only a small number of pieces remain unfinished. During endgame, the piece selection strategy changes from rarest-first to a more aggressive approach where the remaining blocks are requested from all peers that have them, ensuring that the download doesn't stall waiting for a single slow peer.\n\nOnce the final piece is downloaded and verified, the system performs a final integrity check of the complete file and transitions into seeding mode where it can serve pieces to other peers in the swarm. The tracker client sends a final announce with the \"completed\" event to inform the tracker that this peer now has the complete file.\n\n### Inter-Component Communication\n\nThe BitTorrent client's components communicate through a carefully designed combination of direct method calls, channel-based message passing, and shared data structures protected by synchronization primitives. Think of this like a modern office building where different departments (components) need to coordinate their work through various communication channels: some use direct phone calls for urgent matters, others send memos through internal mail systems, and some share information through central bulletin boards that everyone can access.\n\n**Direct Method Invocation for Synchronous Operations**\n\nCertain operations require immediate, synchronous responses and use direct method calls between components. These typically involve configuration queries, state checks, and operations that must complete atomically.\n\nThe `PieceManager` directly calls methods on `Connection` objects when it needs to send requests or check peer state. When the piece manager determines that a peer should download a specific piece, it calls `SendRequest()` directly on the connection object with the piece index, block offset, and block length. This synchronous call allows the piece manager to immediately know whether the request was successfully queued for transmission.\n\nSimilarly, when connections receive incoming messages from peers, they make direct calls to piece manager methods to report received blocks or state changes. The connection calls `SubmitBlockData()` on the piece manager when a piece message arrives, providing the piece index, block offset, and data payload. This direct call allows the connection to immediately know if the block was accepted or if there was an error.\n\nThe torrent parser operates entirely through direct method calls since it provides a synchronous service to initialize the other components. The main client code calls `ParseFromFile()` and receives a complete `MetaInfo` structure that it then passes to other components during their initialization.\n\n**Channel-Based Message Passing for Asynchronous Coordination**\n\nFor operations that can be handled asynchronously or that involve coordination between multiple goroutines, the system uses Go channels to pass messages and work items between components. This approach prevents blocking and allows components to process work at their own pace while maintaining proper ordering.\n\nThe piece manager uses several channels to coordinate its internal operations:\n\n| Channel | Type | Purpose | Producer | Consumer |\n|---------|------|---------|----------|----------|\n| `workRequests` | `chan WorkRequest` | Assigns download work to peers | PieceManager main goroutine | Peer request handlers |\n| `blockData` | `chan BlockData` | Reports received block data | Connection goroutines | PieceManager verification |\n| `verificationResults` | `chan VerificationResult` | Reports piece verification outcomes | Verification pool workers | PieceManager state updates |\n| `peerEvents` | `chan PeerEvent` | Reports peer connection changes | PeerManager | PieceManager interest updates |\n\nThe tracker client uses channels to handle periodic announces without blocking other operations. It runs a background goroutine that waits on a timer channel and sends announce requests at the appropriate intervals, then sends results back through a response channel that other components can monitor.\n\n**Shared Data Structures with Synchronization**\n\nSome information must be accessible to multiple components simultaneously, requiring shared data structures protected by mutexes or other synchronization primitives. These structures serve as the \"single source of truth\" for critical state that affects coordination decisions.\n\nThe piece state map is the most important shared data structure, containing the current status of every piece in the torrent:\n\n| Field | Type | Access Pattern | Protection |\n|-------|------|----------------|------------|\n| `pieces` | `map[int]*PieceState` | Read: all components, Write: PieceManager only | `sync.RWMutex` |\n| `statistics` | `*Statistics` | Read: tracker client, Write: piece manager | `sync.RWMutex` |\n| `connections` | `map[string]*Connection` | Read: piece manager, Write: peer manager | `sync.RWMutex` |\n| `bitfields` | `map[string]*BitfieldOps` | Read: piece manager, Write: connections | Per-connection mutex |\n\nThe piece manager holds the write lock on the piece map when updating piece states after verification, but uses read locks when selecting pieces for download. This allows multiple peer connections to concurrently check piece availability without blocking each other, while ensuring consistency when pieces are completed.\n\nConnection state is managed through per-connection mutexes that protect the choking/interested flags and pending request maps. When a connection receives a choke message from a peer, it acquires its own mutex to update the `peerChoking` flag and clear any pending requests, then notifies the piece manager through a channel message.\n\n**Event-Driven State Updates**\n\nThe system uses an event-driven architecture where state changes in one component trigger notifications to other components that need to react to those changes. This decouples components and allows them to operate independently while maintaining system-wide consistency.\n\nWhen a peer connection completes its handshake and receives a bitfield, it generates a `PeerAvailable` event that gets sent to the piece manager. The piece manager responds by updating its peer availability map and potentially selecting new pieces to download from the newly available peer.\n\nSimilarly, when the piece manager completes verification of a downloaded piece, it generates events that notify the tracker client (to update upload/download statistics), the peer connections (to update interest states), and the file writer (to persist the piece data to disk).\n\nThe tracker client operates on a timer-driven event model where it generates `AnnounceNeeded` events based on the interval provided by the tracker, then sends `PeerListUpdate` events when announce responses are received with new peer information.\n\n> **Decision: Channel-Based vs Callback-Based Event System**\n> - **Context**: Components need to notify each other of state changes without tight coupling\n> - **Options Considered**: Direct callbacks, observer pattern, channel-based messaging\n> - **Decision**: Channel-based messaging with typed event structures\n> - **Rationale**: Channels provide natural backpressure, are type-safe, integrate well with Go's concurrency model, and allow easy testing by mocking channel interactions\n> - **Consequences**: Slightly more complex setup but much better testability, debuggability, and resilience to component failures\n\n### Concurrency Coordination\n\nManaging concurrency in a BitTorrent client presents unique challenges because the system must coordinate dozens of independent peer connections while maintaining consistency of shared state and avoiding race conditions. Think of this like managing a busy restaurant kitchen where multiple chefs (peer connections) are working on different dishes (pieces) simultaneously, sharing common ingredients (blocks) and equipment (network resources), while the head chef (piece manager) coordinates the timing so that complete meals (verified pieces) are delivered to customers (written to disk) in the correct order.\n\nThe complexity comes from the fact that BitTorrent operations are inherently asynchronous and distributed, with network delays, peer behavior, and piece availability constantly changing. The system must handle these dynamic conditions while ensuring that shared data structures remain consistent and that the download progresses efficiently.\n\n**Goroutine Architecture and Lifecycle Management**\n\nThe BitTorrent client uses a structured approach to goroutine management where each major component runs in its own goroutine or goroutine pool, with clearly defined lifecycles and shutdown procedures.\n\n| Component | Goroutines | Lifecycle | Shutdown Signal |\n|-----------|------------|-----------|-----------------|\n| `TrackerClient` | 1 announce goroutine | Starts with first announce, runs until completion | Context cancellation |\n| `PeerManager` | 1 connection manager + N connection handlers | Starts during peer discovery, connection handlers spawn/die with connections | Connection-specific contexts |\n| `PieceManager` | 1 coordinator + M verification workers | Starts immediately after metadata parsing, runs until completion | Completion detection |\n| `Connection` | 2 per connection (read/write) | Spawned when TCP connection established, dies on disconnect | Connection close |\n\nEach goroutine operates independently but coordinates through the message passing and shared state mechanisms described earlier. The key insight is that goroutines should own their local state and communicate changes rather than directly modifying shared state, reducing the need for fine-grained locking.\n\nThe main client goroutine acts as the lifecycle coordinator, starting and stopping component goroutines in the correct order and handling shutdown signals. When the user cancels the download or the download completes, the main goroutine cancels the root context, which cascades cancellation signals to all component contexts.\n\n**Shared State Synchronization Patterns**\n\nThe most critical synchronization challenge involves the piece state map, which must be accessed by multiple peer connections simultaneously for piece selection and progress tracking, while being updated by the piece manager when pieces are completed.\n\nThe system uses a read-write mutex pattern where the piece manager holds exclusive write access during state updates, but allows concurrent read access for piece selection:\n\n```\nReader Pattern (Piece Selection):\n1. Acquire read lock on piece map\n2. Examine piece states and peer bitfields\n3. Identify candidate pieces for download\n4. Release read lock\n5. Make download requests (no locks held)\n\nWriter Pattern (Piece Completion):\n1. Verify piece hash outside of any locks\n2. Acquire write lock on piece map\n3. Update piece state to completed\n4. Update statistics and availability maps\n5. Release write lock\n6. Notify other components via channels\n```\n\nThis pattern minimizes lock contention because piece selection (read operations) happens much more frequently than piece completion (write operations), and the read operations can proceed concurrently without interfering with each other.\n\nConnection state synchronization follows a different pattern because each connection's state is independent. Each `Connection` object has its own mutex that protects its local state (choking flags, pending requests, bitfield), eliminating contention between different peer connections.\n\n**Request Pipeline Coordination**\n\nOne of the most complex coordination challenges involves managing the request pipeline where multiple blocks within a piece may be requested from different peers, and the system must track which blocks have been requested, received, and verified while avoiding duplicate requests and handling peer failures.\n\nThe piece manager maintains a sophisticated state machine for each piece that tracks individual block states:\n\n| Block State | Meaning | Next States | Coordination Requirements |\n|-------------|---------|-------------|--------------------------|\n| `Needed` | Block not yet requested | `Requested` | None - initial state |\n| `Requested` | Block requested from specific peer | `Received`, `Needed` | Must track timeout and peer identity |\n| `Received` | Block data received and buffered | `Verified` | Must wait for all blocks in piece |\n| `Verified` | Part of completed, hash-verified piece | Final state | Must coordinate file write |\n\nThe coordination challenge comes from the fact that block requests may time out, peers may disconnect, or multiple peers may send the same block. The system handles these scenarios through careful state management:\n\nWhen a peer connection wants to request blocks, it calls `RequestWork()` on the piece manager with its peer ID and available piece bitfield. The piece manager examines its internal state, selects appropriate blocks that are in the `Needed` state, atomically transitions them to `Requested` with the requesting peer's ID, and returns the list of blocks to request.\n\nIf a peer disconnects or a request times out, the piece manager scans for blocks in the `Requested` state associated with that peer and transitions them back to `Needed` so they can be requested from other peers. This recovery process must be atomic to prevent blocks from being lost or double-requested.\n\n**Endgame Mode Coordination**\n\nThe endgame mode presents the most complex coordination challenge because the normal piece selection rules change and the system begins requesting the same blocks from multiple peers simultaneously. This requires careful coordination to avoid wasting bandwidth while ensuring the download completes quickly.\n\nThe `EndgameManager` monitors download progress and activates when fewer than `MAX_ENDGAME_PIECES` remain incomplete. Once activated, it changes the request strategy to send requests for remaining blocks to all peers that have the containing pieces, then cancels duplicate requests as soon as any peer provides the block.\n\nThis coordination requires tracking which peers have been sent requests for which blocks, and when a block is received, immediately sending cancel messages to all other peers that were sent requests for the same block. The timing is critical because cancel messages may not arrive before peers send the duplicate data, so the system must be prepared to receive and discard duplicate blocks.\n\n> **Decision: Optimistic vs Pessimistic Concurrency Control**\n> - **Context**: Multiple peers may attempt to download the same pieces simultaneously\n> - **Options Considered**: Pessimistic locking (reserve pieces), optimistic conflicts (detect and resolve), hybrid approach\n> - **Decision**: Optimistic with conflict detection for normal mode, pessimistic for endgame\n> - **Rationale**: Optimistic allows better parallelism when conflicts are rare, but endgame requires careful coordination to avoid waste\n> - **Consequences**: More complex state management but better performance and simpler deadlock avoidance\n\n**Graceful Shutdown Coordination**\n\nProperly shutting down a BitTorrent client requires careful coordination to ensure that in-flight operations complete cleanly and that the final state is reported to the tracker. The shutdown process follows a specific sequence that allows components to complete their work before terminating.\n\nWhen shutdown is initiated (either by user request or download completion), the main goroutine begins an orderly shutdown process. First, it signals the peer manager to stop accepting new connections and begin closing existing connections gracefully. Existing connections are allowed to complete any in-flight piece requests before closing.\n\nThe piece manager continues processing incoming block data and verification until all peer connections have closed, ensuring that any blocks received during shutdown are properly handled. Only after all peer connections have terminated does the piece manager shut down its verification workers.\n\nFinally, the tracker client sends a final announce to report the current statistics and indicate that the peer is leaving the swarm. This announce uses the \"stopped\" event type and helps other peers in the swarm understand that this peer is no longer available.\n\nThe entire shutdown process is coordinated through context cancellation that flows from the main goroutine to all component goroutines, with each component responsible for completing its cleanup tasks before the context deadline expires.\n\n![Complete Download Flow](./diagrams/download-sequence.svg)\n\n![BitTorrent Client Architecture](./diagrams/system-architecture.svg)\n\n![Multi-Peer Download Coordination](./diagrams/concurrent-download.svg)\n\n### Implementation Guidance\n\nThis section provides the infrastructure and coordination code needed to orchestrate the complete BitTorrent download lifecycle. The target is a clean, production-ready implementation that handles the complex interactions between components.\n\n**Technology Recommendations**\n\n| Coordination Aspect | Simple Approach | Advanced Approach |\n|---------------------|-----------------|-------------------|\n| Inter-component messaging | Go channels with struct types | Event bus with typed handlers |\n| State synchronization | `sync.RWMutex` on shared maps | Lock-free data structures with atomic operations |\n| Goroutine coordination | Context-based cancellation | Supervised goroutine trees with restart policies |\n| Error propagation | Error return values + logging | Structured error events with recovery strategies |\n| Progress tracking | Atomic counters + periodic reports | Real-time metrics with time-series storage |\n\nFor a learning implementation, stick with the simple approaches that use Go's built-in concurrency primitives effectively.\n\n**Recommended Module Structure**\n\n```\ninternal/\n  client/\n    client.go              ← Main orchestration logic\n    lifecycle.go           ← Download lifecycle management\n    events.go             ← Inter-component event types\n  coordination/\n    piece_coordinator.go   ← Piece request coordination\n    peer_coordinator.go    ← Peer connection coordination\n    state_manager.go       ← Shared state synchronization\n  statistics/\n    tracker.go            ← Download progress tracking\n    metrics.go            ← Performance metrics\n```\n\n**Event System Infrastructure (Complete)**\n\n```go\npackage client\n\nimport (\n    \"context\"\n    \"sync\"\n    \"time\"\n)\n\n// EventType represents the type of events that flow between components\ntype EventType int\n\nconst (\n    EventPeerConnected EventType = iota\n    EventPeerDisconnected\n    EventPieceCompleted\n    EventBlockReceived\n    EventTrackerResponse\n    EventDownloadComplete\n)\n\n// Event represents a coordination event between components\ntype Event struct {\n    Type      EventType\n    PeerID    string\n    Timestamp time.Time\n    Data      interface{}\n}\n\n// EventBus coordinates message passing between components\ntype EventBus struct {\n    subscribers map[EventType][]chan Event\n    mutex       sync.RWMutex\n    ctx         context.Context\n    cancel      context.CancelFunc\n}\n\n// NewEventBus creates a new event coordination system\nfunc NewEventBus(ctx context.Context) *EventBus {\n    busCtx, cancel := context.WithCancel(ctx)\n    return &EventBus{\n        subscribers: make(map[EventType][]chan Event),\n        ctx:         busCtx,\n        cancel:      cancel,\n    }\n}\n\n// Subscribe registers a channel to receive events of specified type\nfunc (eb *EventBus) Subscribe(eventType EventType, bufferSize int) <-chan Event {\n    eb.mutex.Lock()\n    defer eb.mutex.Unlock()\n    \n    ch := make(chan Event, bufferSize)\n    eb.subscribers[eventType] = append(eb.subscribers[eventType], ch)\n    return ch\n}\n\n// Publish sends an event to all subscribers of the event type\nfunc (eb *EventBus) Publish(event Event) {\n    eb.mutex.RLock()\n    subscribers := eb.subscribers[event.Type]\n    eb.mutex.RUnlock()\n    \n    event.Timestamp = time.Now()\n    \n    for _, ch := range subscribers {\n        select {\n        case ch <- event:\n            // Event delivered successfully\n        case <-eb.ctx.Done():\n            return\n        default:\n            // Subscriber's buffer is full, skip this subscriber\n            // In production, might want to log this condition\n        }\n    }\n}\n\n// Shutdown closes all subscriber channels and stops the event bus\nfunc (eb *EventBus) Shutdown() {\n    eb.cancel()\n    \n    eb.mutex.Lock()\n    defer eb.mutex.Unlock()\n    \n    for _, channels := range eb.subscribers {\n        for _, ch := range channels {\n            close(ch)\n        }\n    }\n    eb.subscribers = make(map[EventType][]chan Event)\n}\n```\n\n**State Synchronization Infrastructure (Complete)**\n\n```go\npackage coordination\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\n// SharedState manages synchronized access to global BitTorrent state\ntype SharedState struct {\n    pieces      map[int]*PieceState\n    connections map[string]*Connection\n    statistics  *Statistics\n    \n    pieceMutex      sync.RWMutex\n    connectionMutex sync.RWMutex\n    statsMutex      sync.RWMutex\n}\n\n// Statistics tracks download progress and performance metrics\ntype Statistics struct {\n    Downloaded    int64     // Bytes successfully downloaded and verified\n    Uploaded      int64     // Bytes uploaded to other peers\n    Left          int64     // Bytes remaining to download\n    StartTime     time.Time // When download began\n    CompletedPieces int     // Number of pieces completed\n    TotalPieces     int     // Total pieces in torrent\n    ConnectedPeers  int     // Currently connected peer count\n}\n\n// NewSharedState creates synchronized state manager\nfunc NewSharedState(totalPieces int, totalLength int64) *SharedState {\n    return &SharedState{\n        pieces:      make(map[int]*PieceState),\n        connections: make(map[string]*Connection),\n        statistics: &Statistics{\n            Left:        totalLength,\n            StartTime:   time.Now(),\n            TotalPieces: totalPieces,\n        },\n    }\n}\n\n// GetPieceState safely retrieves piece state for reading\nfunc (ss *SharedState) GetPieceState(pieceIndex int) *PieceState {\n    ss.pieceMutex.RLock()\n    defer ss.pieceMutex.RUnlock()\n    return ss.pieces[pieceIndex]\n}\n\n// UpdatePieceState safely updates piece state\nfunc (ss *SharedState) UpdatePieceState(pieceIndex int, state *PieceState) {\n    ss.pieceMutex.Lock()\n    defer ss.pieceMutex.Unlock()\n    ss.pieces[pieceIndex] = state\n}\n\n// GetAvailablePieces returns slice of piece indices that need downloading\nfunc (ss *SharedState) GetAvailablePieces() []int {\n    ss.pieceMutex.RLock()\n    defer ss.pieceMutex.RUnlock()\n    \n    var needed []int\n    for index, piece := range ss.pieces {\n        if piece.State == PieceStateNeeded {\n            needed = append(needed, index)\n        }\n    }\n    return needed\n}\n\n// AddConnection registers a new peer connection\nfunc (ss *SharedState) AddConnection(peerID string, conn *Connection) {\n    ss.connectionMutex.Lock()\n    defer ss.connectionMutex.Unlock()\n    ss.connections[peerID] = conn\n    \n    ss.statsMutex.Lock()\n    ss.statistics.ConnectedPeers++\n    ss.statsMutex.Unlock()\n}\n\n// RemoveConnection unregisters a peer connection\nfunc (ss *SharedState) RemoveConnection(peerID string) {\n    ss.connectionMutex.Lock()\n    defer ss.connectionMutex.Unlock()\n    delete(ss.connections, peerID)\n    \n    ss.statsMutex.Lock()\n    ss.statistics.ConnectedPeers--\n    ss.statsMutex.Unlock()\n}\n\n// GetConnections returns all active connections (copy for safety)\nfunc (ss *SharedState) GetConnections() map[string]*Connection {\n    ss.connectionMutex.RLock()\n    defer ss.connectionMutex.RUnlock()\n    \n    connections := make(map[string]*Connection)\n    for id, conn := range ss.connections {\n        connections[id] = conn\n    }\n    return connections\n}\n\n// UpdateStatistics safely updates download progress statistics\nfunc (ss *SharedState) UpdateStatistics(downloaded, uploaded int64, completedPieces int) {\n    ss.statsMutex.Lock()\n    defer ss.statsMutex.Unlock()\n    \n    ss.statistics.Downloaded = downloaded\n    ss.statistics.Uploaded = uploaded\n    ss.statistics.Left = ss.statistics.Left - (downloaded - ss.statistics.Downloaded)\n    ss.statistics.CompletedPieces = completedPieces\n}\n\n// GetStatistics returns current statistics (copy for safety)\nfunc (ss *SharedState) GetStatistics() Statistics {\n    ss.statsMutex.RLock()\n    defer ss.statsMutex.RUnlock()\n    return *ss.statistics // Return copy\n}\n```\n\n**Main Client Orchestration (Skeleton)**\n\n```go\npackage client\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n    \n    \"internal/coordination\"\n    \"internal/peer\"\n    \"internal/piece\"\n    \"internal/torrent\"\n    \"internal/tracker\"\n)\n\n// Client orchestrates the complete BitTorrent download process\ntype Client struct {\n    metaInfo     *torrent.MetaInfo\n    sharedState  *coordination.SharedState\n    eventBus     *EventBus\n    \n    trackerClient *tracker.Client\n    peerManager   *peer.Manager\n    pieceManager  *piece.PieceManager\n    \n    ctx    context.Context\n    cancel context.CancelFunc\n}\n\n// NewClient creates a BitTorrent client for the specified torrent\nfunc NewClient(torrentPath string) (*Client, error) {\n    // TODO 1: Parse torrent file using torrent.ParseFromFile()\n    // TODO 2: Calculate total file length and expected piece count\n    // TODO 3: Create shared state manager with piece count and file size\n    // TODO 4: Create event bus for component coordination\n    // TODO 5: Initialize tracker client with metainfo\n    // TODO 6: Initialize peer manager with event bus\n    // TODO 7: Initialize piece manager with metainfo and shared state\n    // TODO 8: Set up context for lifecycle management\n}\n\n// Download orchestrates the complete download lifecycle\nfunc (c *Client) Download(outputPath string) error {\n    // TODO 1: Start tracker communication to get initial peer list\n    // TODO 2: Subscribe to peer connection events from peer manager\n    // TODO 3: Subscribe to piece completion events from piece manager\n    // TODO 4: Start peer manager to begin connection attempts\n    // TODO 5: Start piece manager to coordinate downloads\n    // TODO 6: Monitor download progress and handle events\n    // TODO 7: Detect completion condition (all pieces verified)\n    // TODO 8: Send completion announce to tracker\n    // TODO 9: Begin seeding mode (serve pieces to other peers)\n    // Hint: Use select statement to handle multiple event channels\n    // Hint: Check for context cancellation to support early termination\n}\n\n// handlePeerEvent processes peer connection state changes\nfunc (c *Client) handlePeerEvent(event Event) {\n    // TODO 1: Extract peer ID and event type from event data\n    // TODO 2: Update shared state based on connection/disconnection\n    // TODO 3: For new connections, trigger interest state updates\n    // TODO 4: For disconnections, clean up pending requests\n    // TODO 5: Update connection count statistics\n}\n\n// handlePieceEvent processes piece completion and verification events\nfunc (c *Client) handlePieceEvent(event Event) {\n    // TODO 1: Extract piece index and verification result from event\n    // TODO 2: Update piece state in shared state manager\n    // TODO 3: Update download statistics (bytes downloaded, pieces completed)\n    // TODO 4: Check if download is complete (all pieces verified)\n    // TODO 5: Notify tracker client if significant progress made\n    // TODO 6: Update interest states for all peer connections\n}\n\n// Shutdown gracefully terminates all client operations\nfunc (c *Client) Shutdown() error {\n    // TODO 1: Cancel context to signal shutdown to all components\n    // TODO 2: Stop accepting new peer connections\n    // TODO 3: Allow in-flight piece requests to complete\n    // TODO 4: Send final statistics to tracker with \"stopped\" event\n    // TODO 5: Close all peer connections gracefully\n    // TODO 6: Shutdown event bus and clean up resources\n    // TODO 7: Wait for all goroutines to terminate with timeout\n}\n\n// isDownloadComplete checks if all pieces have been verified\nfunc (c *Client) isDownloadComplete() bool {\n    // TODO 1: Get current statistics from shared state\n    // TODO 2: Compare completed pieces to total expected pieces\n    // TODO 3: Return true only if all pieces completed and verified\n}\n```\n\n**Milestone Checkpoints**\n\nAfter implementing the coordination infrastructure, verify these behaviors:\n\n1. **Event Flow Verification**: Create a simple test that publishes events through the event bus and verifies that subscribers receive them in the correct order without blocking.\n\n2. **Concurrent State Access**: Run multiple goroutines that simultaneously read and write piece states through the shared state manager, ensuring no race conditions occur.\n\n3. **Lifecycle Coordination**: Start the full client with a small test torrent and verify that components start up in the correct order and shut down cleanly when cancelled.\n\n4. **Progress Reporting**: Monitor the statistics during a real download to ensure that progress is accurately tracked and reported to the tracker at appropriate intervals.\n\nExpected behavior: The client should successfully coordinate all components, handle peer connections and disconnections gracefully, maintain accurate download progress, and complete downloads without deadlocks or race conditions.\n\n**Common Integration Issues**\n\n⚠️ **Pitfall: Deadlocks in State Access**\nWhen multiple components need to access shared state simultaneously, incorrect lock ordering can cause deadlocks. Always acquire locks in a consistent order: pieces, then connections, then statistics.\n\n⚠️ **Pitfall: Event Channel Blocking**\nIf event subscribers don't process events quickly enough, the event bus can block publishers. Use buffered channels and handle the case where subscribers can't keep up by dropping events if necessary.\n\n⚠️ **Pitfall: Goroutine Leaks During Shutdown**\nComponents may not terminate cleanly if they're blocked on channel operations or waiting for network I/O. Always use context cancellation with timeouts to force termination if graceful shutdown fails.\n\n⚠️ **Pitfall: Race Conditions in Statistics**\nDownload statistics are accessed by multiple components simultaneously. Protect all statistics updates with mutexes and be careful about compound operations that read-modify-write multiple fields.\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** This section applies to all milestones (1-4) by establishing comprehensive error handling strategies that ensure robustness across torrent parsing, tracker communication, peer protocols, and piece management.\n\nBuilding a robust BitTorrent client requires anticipating and gracefully handling numerous failure scenarios that arise in distributed peer-to-peer systems. Unlike centralized systems where failures are localized and predictable, BitTorrent clients must operate in an adversarial environment where peers may misbehave, networks partition unpredictably, and data corruption occurs frequently. This section establishes comprehensive error handling strategies that transform a fragile prototype into a production-ready client capable of operating reliably in the chaotic world of peer-to-peer file sharing.\n\nThink of error handling in BitTorrent like designing a ship to navigate treacherous waters. Just as a well-designed vessel must handle storms, equipment failures, and unpredictable conditions while maintaining course toward its destination, a BitTorrent client must gracefully handle network failures, malicious peers, and data corruption while continuing to make progress toward completing the download. The key insight is that failures are not exceptional cases to be avoided, but normal operating conditions that must be anticipated and managed systematically.\n\n### System Failure Modes\n\nUnderstanding the complete catalog of potential failures is essential for building comprehensive error handling. BitTorrent clients operate in a complex distributed environment where failures can occur at every layer of the system stack, from low-level network connectivity to high-level protocol violations. Each failure mode requires specific detection mechanisms and recovery strategies.\n\n**Network-Level Failures**\n\nNetwork failures represent the most common category of issues encountered in peer-to-peer systems. These failures can occur at any point in the network stack and often manifest as timeouts, connection resets, or partial data transmission.\n\n| Failure Mode | Detection Mechanism | Symptoms | Recovery Strategy |\n|--------------|-------------------|----------|------------------|\n| Connection Timeout | Socket connect() timeout | TCP connection never establishes | Exponential backoff retry with peer blacklisting |\n| Connection Reset | ECONNRESET error | Existing connection drops unexpectedly | Immediate reconnection attempt with request replay |\n| Partial Read | Incomplete message framing | Message length prefix without payload | Buffer incomplete data, retry read with timeout |\n| DNS Resolution Failure | Resolver error for tracker hostname | Cannot resolve tracker announce URL | Try backup trackers, fallback to IP addresses |\n| Network Partition | Multiple connection failures | All peer connections timeout simultaneously | Pause operations, retry after exponential backoff |\n| Bandwidth Exhaustion | Slow transfer rates, timeouts | Block downloads taking excessive time | Reduce concurrent connections, implement rate limiting |\n\n**Tracker-Level Failures**\n\nTracker failures directly impact peer discovery, which is critical for maintaining a healthy swarm connection. These failures require sophisticated retry logic and fallback mechanisms to ensure the client can continue discovering peers even when primary trackers are unavailable.\n\n| Failure Mode | Detection Mechanism | Symptoms | Recovery Strategy |\n|--------------|-------------------|----------|------------------|\n| HTTP 4xx Client Error | HTTP response status code | 400-499 status in announce response | Validate request parameters, fix encoding issues |\n| HTTP 5xx Server Error | HTTP response status code | 500-599 status in announce response | Exponential backoff retry, try backup trackers |\n| Malformed Response | Bencode parsing error | Invalid bencode in tracker response | Skip response, mark tracker as unreliable |\n| Missing Required Fields | Field validation error | Response missing 'peers' or 'interval' | Use default values where possible, retry announce |\n| Tracker Timeout | HTTP request timeout | No response within configured timeout | Mark tracker as slow, increase timeout for retries |\n| Invalid Peer List | Compact peer parsing error | Malformed compact peer data | Skip invalid entries, use successfully parsed peers |\n\n**Peer Protocol Failures**\n\nPeer protocol failures occur during direct communication between BitTorrent clients and can range from simple message format errors to complex state machine violations. These failures require careful state management to prevent protocol deadlocks and ensure fair resource allocation.\n\n| Failure Mode | Detection Mechanism | Symptoms | Recovery Strategy |\n|--------------|-------------------|----------|------------------|\n| Handshake Mismatch | Info hash comparison | Peer reports different info hash | Immediately disconnect, blacklist peer |\n| Protocol Violation | State machine validation | Invalid message for current state | Send protocol error, attempt graceful disconnect |\n| Message Corruption | Length/checksum validation | Message length doesn't match payload | Request message retransmission, reset connection |\n| Peer Timeout | Keepalive timer expiration | No messages received within keepalive period | Send keepalive, disconnect if no response |\n| Request Queue Overflow | Pipeline depth tracking | Too many outstanding requests | Stop sending new requests, wait for completions |\n| Choke/Unchoke Cycling | State change frequency monitoring | Rapid choke/unchoke state changes | Implement choke state dampening, reduce request rate |\n\n**Data Integrity Failures**\n\nData integrity failures are particularly critical in BitTorrent because they can corrupt the downloaded file and waste significant bandwidth. These failures require immediate detection and recovery to prevent propagation of corrupt data.\n\n| Failure Mode | Detection Mechanism | Symptoms | Recovery Strategy |\n|--------------|-------------------|----------|------------------|\n| Piece Hash Mismatch | SHA1 verification | Downloaded piece hash doesn't match torrent | Discard piece, redownload from different peers |\n| Block Data Corruption | Piece assembly validation | Block doesn't fit expected piece structure | Request block retransmission, check peer reliability |\n| File System Errors | Write operation failures | Cannot write piece data to disk | Check disk space, permissions, retry with backoff |\n| Incomplete Piece Assembly | Block count validation | Missing blocks when piece should be complete | Request missing blocks, verify block tracking |\n| Size Mismatch | File length validation | Downloaded file size doesn't match torrent metadata | Verify piece boundaries, check for padding errors |\n| Write Permission Errors | File system error codes | Cannot create or modify output files | Check permissions, suggest alternative output paths |\n\n> **Critical Insight**: The key to robust error handling in BitTorrent is understanding that failures cascade through multiple layers. A network timeout doesn't just mean \"retry the connection\" – it means reassessing piece assignments, updating peer reliability scores, adjusting request pipeline depths, and potentially triggering tracker re-announce to find alternative peers.\n\n**State Consistency Failures**\n\nState consistency failures occur when different components of the BitTorrent client maintain conflicting views of system state. These failures are particularly dangerous because they can lead to subtle bugs that only manifest under specific timing conditions.\n\n| Failure Mode | Detection Mechanism | Symptoms | Recovery Strategy |\n|--------------|-------------------|----------|------------------|\n| Piece State Divergence | Cross-component validation | Different components report conflicting piece states | Rebuild state from authoritative source (disk) |\n| Peer State Desynchronization | Connection state validation | Local peer state doesn't match peer's reported state | Perform handshake renegotiation |\n| Request Tracking Mismatch | Pipeline validation | Outstanding requests don't match sent requests | Clear request queue, resend active requests |\n| Bitfield Inconsistency | Availability counting errors | Peer availability doesn't match bitfield data | Request fresh bitfield update |\n| Statistics Corruption | Counter validation | Downloaded/uploaded counters are inconsistent | Recalculate statistics from piece state |\n| Concurrent Modification | Lock validation failures | Multiple threads modify shared state simultaneously | Implement stricter locking, detect race conditions |\n\n### Recovery and Retry Logic\n\nEffective recovery from failures requires sophisticated retry logic that adapts to different types of failures and learns from past experiences. The key insight is that not all failures are equal – some indicate temporary network issues that resolve quickly, while others suggest fundamental problems requiring different recovery strategies.\n\n**Exponential Backoff Strategy**\n\nExponential backoff prevents overwhelming failed services with repeated requests while providing reasonable recovery times for transient failures. The strategy must be tailored to different failure types because network timeouts require different backoff parameters than tracker server errors.\n\nThe `BackoffScheduler` manages retry timing for different types of operations:\n\n| Operation Type | Base Delay | Max Delay | Multiplier | Jitter | Reset Condition |\n|---------------|------------|-----------|------------|---------|-----------------|\n| Tracker Announce | 30 seconds | 15 minutes | 2.0 | ±25% | Successful announce |\n| Peer Connection | 5 seconds | 5 minutes | 1.5 | ±20% | Successful handshake |\n| Block Request | 1 second | 30 seconds | 2.0 | ±10% | Successful block receipt |\n| File I/O Operation | 100ms | 10 seconds | 3.0 | ±15% | Successful write |\n| DNS Resolution | 2 seconds | 2 minutes | 2.0 | ±30% | Successful resolution |\n\nThe backoff algorithm follows this progression:\n1. Start with the base delay for the operation type\n2. After each failure, multiply the current delay by the multiplier\n3. Add random jitter to prevent thundering herd effects\n4. Cap the delay at the maximum value for the operation type\n5. Reset to base delay when the reset condition is met\n6. Track consecutive failures to implement circuit breaker patterns\n\n**Circuit Breaker Pattern**\n\nCircuit breakers prevent the client from repeatedly attempting operations that are likely to fail, providing fast failure responses and reducing resource waste. Different components require different circuit breaker configurations based on their failure characteristics and recovery patterns.\n\n| Component | Failure Threshold | Recovery Timeout | Half-Open Requests | Success Threshold |\n|-----------|------------------|------------------|-------------------|------------------|\n| Tracker Client | 5 consecutive failures | 5 minutes | 1 announce | 2 successes |\n| Peer Connection | 3 consecutive handshake failures | 2 minutes | 1 connection | 1 success |\n| File Writer | 10 consecutive write failures | 30 seconds | 1 write | 3 successes |\n| DNS Resolver | 3 consecutive resolution failures | 1 minute | 1 resolution | 1 success |\n\nThe circuit breaker state machine operates as follows:\n1. **Closed State**: Normal operation, all requests pass through\n2. **Open State**: All requests fail immediately without attempting the operation\n3. **Half-Open State**: Allow limited requests to test if the service has recovered\n4. **Recovery**: If half-open requests succeed, return to closed state\n\n**Peer Quality Scoring**\n\nPeer quality scoring helps the client prioritize reliable peers and avoid problematic ones. The scoring system tracks multiple metrics to build a comprehensive view of peer reliability and performance.\n\n| Metric | Weight | Positive Factors | Negative Factors | Decay Rate |\n|--------|---------|-----------------|------------------|------------|\n| Connection Reliability | 0.3 | Successful handshakes | Connection timeouts, resets | 0.95/hour |\n| Data Quality | 0.4 | Correct piece hashes | Hash mismatches, corruption | 0.9/hour |\n| Transfer Performance | 0.2 | Fast block transfers | Slow responses, timeouts | 0.98/hour |\n| Protocol Compliance | 0.1 | Proper message format | Protocol violations | 0.85/hour |\n\nThe scoring algorithm maintains a running average for each peer:\n1. Initialize all peers with a neutral score (0.5)\n2. Update scores based on observed behavior using weighted factors\n3. Apply time-based decay to prevent permanent peer blacklisting\n4. Use scores to prioritize connection attempts and request assignments\n5. Implement minimum score thresholds for different operations\n\n> **Decision: Peer Scoring vs. Simple Blacklisting**\n> - **Context**: Need to handle unreliable peers while maintaining adequate peer diversity\n> - **Options Considered**: Binary blacklisting, simple success/failure counters, comprehensive scoring system\n> - **Decision**: Comprehensive scoring system with time-based decay\n> - **Rationale**: Peers may become reliable over time, binary decisions lose valuable peer diversity, scoring provides fine-grained prioritization\n> - **Consequences**: More complex implementation but better peer utilization and fault tolerance\n\n**Request Recovery and Replay**\n\nWhen peer connections fail during active downloads, the client must recover in-flight requests and reassign them to other peers. This process requires careful coordination between the piece manager and peer connections to prevent data loss and duplicate work.\n\nThe request recovery process follows these steps:\n1. **Failure Detection**: Peer connection detects network failure or timeout\n2. **Request Inventory**: Catalog all outstanding requests for the failed peer\n3. **State Validation**: Verify which requests were actually in progress\n4. **Peer Notification**: Inform piece manager of the connection failure\n5. **Request Reassignment**: Piece manager reassigns requests to other available peers\n6. **Progress Preservation**: Maintain download progress statistics and piece state\n7. **Quality Update**: Update peer quality scores based on the failure\n\nThe reassignment algorithm prioritizes requests based on several factors:\n\n| Priority Factor | Weight | Rationale |\n|----------------|--------|-----------|\n| Piece Rarity | 0.4 | Rare pieces are harder to obtain from alternative peers |\n| Request Age | 0.3 | Older requests represent more invested effort |\n| Peer Availability | 0.2 | More available peers increase reassignment success probability |\n| Block Position | 0.1 | Later blocks in a piece represent more completion progress |\n\n### Protocol Edge Cases\n\nBitTorrent protocol edge cases arise from the interaction between the formal protocol specification and real-world implementation variations. These edge cases often involve timing issues, message ordering problems, and interpretation ambiguities that can cause interoperability failures between different BitTorrent clients.\n\n**Message Ordering and Timing Edge Cases**\n\nThe peer wire protocol assumes certain message ordering constraints, but network delays and concurrent processing can violate these assumptions. The client must handle out-of-order messages and timing-dependent protocol states gracefully.\n\n| Edge Case | Scenario | Detection | Recovery Strategy |\n|-----------|----------|-----------|------------------|\n| Bitfield After Pieces | Peer sends bitfield after piece messages | Message sequence validation | Merge bitfield with existing piece knowledge |\n| Request Before Unchoke | Request received while peer should be choked | Choke state validation | Queue request for when peer becomes unchoked |\n| Piece for Unrequested Block | Piece message for block we didn't request | Request tracking validation | Accept piece if needed, update request tracking |\n| Double Handshake | Multiple handshake messages on same connection | Handshake completion flag | Ignore duplicate handshake, continue normal protocol |\n| Stale Keep-Alive | Keep-alive messages after connection should be closed | Connection state tracking | Ignore keep-alive, proceed with connection cleanup |\n| Race Condition Choke | Choke message arrives after request sent | Message timestamp comparison | Honor choke, cancel in-flight requests |\n\n**Message Format Edge Cases**\n\nReal-world BitTorrent implementations sometimes generate messages that deviate from the strict protocol specification. The client must be liberal in what it accepts while maintaining security and correctness.\n\n| Edge Case | Violation | Tolerance Strategy | Security Consideration |\n|-----------|-----------|-------------------|------------------------|\n| Oversized Bitfield | Bitfield longer than expected piece count | Truncate to expected length | Validate against maximum torrent size |\n| Invalid Message Length | Length prefix doesn't match payload size | Attempt payload parsing with actual length | Limit maximum message size to prevent DoS |\n| Unknown Message Type | Message ID not in protocol specification | Log and ignore unknown messages | Track unknown message frequency per peer |\n| Missing Keep-Alive | No keep-alive within expected interval | Extend timeout, send our own keep-alive | Implement maximum silence period |\n| Zero-Length Request | Request with zero-byte length | Treat as invalid, send rejection | Prevent infinite loops in request handling |\n| Duplicate Have Messages | Multiple have messages for same piece | Ignore duplicates, update availability once | Track message frequency to detect spam |\n\n**State Machine Violations**\n\nPeer state machines can enter invalid states due to message loss, network partitions, or implementation bugs. The client must detect these violations and recover to a consistent state.\n\n| Violation Type | Invalid Transition | Detection Method | Recovery Action |\n|---------------|-------------------|------------------|-----------------|\n| Request While Choked | Sending request when peer is choking us | Outbound message validation | Buffer request until unchoked |\n| Interest Without Need | Claiming interest in peer with no needed pieces | Bitfield intersection check | Send not-interested message |\n| Choke Oscillation | Rapid choke/unchoke cycles | State change frequency tracking | Implement choke state dampening |\n| Stale Interested State | Remaining interested after obtaining all pieces | Periodic interest validation | Send not-interested and update state |\n| Request Pipeline Overflow | Too many outstanding requests | Pipeline depth tracking | Stop sending requests until pipeline drains |\n| Bitfield Desync | Peer's have messages inconsistent with bitfield | Cross-reference have messages with bitfield | Request fresh bitfield update |\n\n**Data Validation Edge Cases**\n\nData validation must handle various forms of corruption and malicious data while maintaining download progress. The challenge is distinguishing between innocent errors and malicious attacks.\n\n| Edge Case | Data Issue | Validation Approach | Response Strategy |\n|-----------|-------------|-------------------|------------------|\n| Partial Hash Match | Piece data partially correct | Block-level validation where possible | Re-request specific corrupt blocks |\n| Size Overflow | Piece larger than expected | Strict size limits before hash calculation | Reject oversized pieces, penalize peer |\n| Encoding Issues | Binary data in string fields | Validate data encoding expectations | Accept binary strings, log encoding mismatches |\n| Padding Bytes | Extra bytes in file pieces | Check against file boundary expectations | Handle padding according to torrent specification |\n| Timestamp Anomalies | Future or ancient timestamp in metadata | Timestamp range validation | Accept valid torrents with suspicious timestamps |\n| Unicode Issues | Non-UTF8 strings in text fields | Graceful encoding handling | Attempt common encodings, fallback to byte display |\n\n⚠️ **Pitfall: Treating All Protocol Violations as Attacks**\n\nMany developers implement overly strict protocol validation that disconnects peers for minor infractions. This approach reduces peer diversity and can prevent successful downloads. Instead, implement graduated responses: log minor violations, penalize moderate violations, and disconnect only for severe violations that threaten system integrity.\n\n**Concurrency and Race Condition Edge Cases**\n\nBitTorrent clients are inherently concurrent systems with multiple peer connections, piece management threads, and I/O operations running simultaneously. Race conditions and synchronization issues can lead to subtle bugs that only manifest under specific timing conditions.\n\n| Race Condition | Scenario | Detection | Prevention |\n|---------------|----------|-----------|------------|\n| Piece Completion Race | Multiple peers complete same piece simultaneously | Duplicate completion detection | Atomic piece state transitions |\n| Connection State Race | Peer state changes while processing messages | State consistency validation | Message processing serialization |\n| Request Assignment Race | Multiple threads assign same block | Request tracking validation | Centralized request coordination |\n| File Write Race | Concurrent writes to same file region | Write operation validation | Serialize writes per file region |\n| Statistics Update Race | Concurrent updates to download statistics | Counter inconsistency detection | Atomic counter operations |\n| Shutdown Race | Component shutdown during active operations | Operation completion tracking | Graceful shutdown coordination |\n\nThe key to preventing race conditions is implementing proper synchronization at the right granularity. Too coarse-grained locking reduces parallelism, while too fine-grained locking increases complexity and deadlock risk.\n\n> **Decision: Fine-Grained vs. Coarse-Grained Locking**\n> - **Context**: Need to balance concurrency performance with synchronization complexity\n> - **Options Considered**: Single global lock, per-component locks, fine-grained field-level locks\n> - **Decision**: Per-component locks with careful lock ordering\n> - **Rationale**: Provides good parallelism without excessive complexity, follows lock hierarchy to prevent deadlocks\n> - **Consequences**: Enables concurrent operations while maintaining predictable synchronization behavior\n\n### Implementation Guidance\n\nThe error handling implementation requires careful coordination between all system components to ensure consistent error recovery behavior. The key insight is building error handling into the system architecture from the beginning rather than adding it as an afterthought.\n\n**Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|--------------|-----------------|\n| Error Types | Standard Go errors with error wrapping | Custom error hierarchy with error codes and context |\n| Retry Logic | Simple exponential backoff timers | Configurable backoff strategies with circuit breakers |\n| Logging | Standard log package with structured fields | Structured logging with error correlation IDs |\n| Monitoring | Basic error counters and timing metrics | Comprehensive metrics with error categorization |\n| Recovery | Manual retry on specific error conditions | Automatic recovery with pluggable recovery strategies |\n\n**Recommended File/Module Structure:**\n\n```\ninternal/\n  errors/\n    types.go              ← Custom error types and error hierarchy\n    recovery.go           ← Retry and recovery logic implementations\n    circuit.go            ← Circuit breaker pattern implementation\n  coordinator/\n    errors.go             ← Component-specific error handling\n    recovery.go           ← Component recovery procedures\n  tracker/\n    errors.go             ← Tracker communication error handling\n    backoff.go            ← Tracker-specific retry logic\n  peer/\n    errors.go             ← Peer protocol error handling\n    validation.go         ← Message and state validation\n  piece/\n    errors.go             ← Piece management error handling\n    verification.go       ← Data integrity validation\n```\n\n**Infrastructure Starter Code:**\n\n```go\n// Package errors provides comprehensive error handling infrastructure\npackage errors\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// ErrorType categorizes different types of errors for appropriate handling\ntype ErrorType int\n\nconst (\n    ErrorTypeNetwork ErrorType = iota\n    ErrorTypeProtocol\n    ErrorTypeData\n    ErrorTypeTracker\n    ErrorTypeFileSystem\n    ErrorTypeConcurrency\n)\n\n// BitTorrentError wraps standard errors with additional context\ntype BitTorrentError struct {\n    Type      ErrorType\n    Component string\n    Operation string\n    Err       error\n    Context   map[string]interface{}\n    Timestamp time.Time\n}\n\nfunc (e *BitTorrentError) Error() string {\n    return fmt.Sprintf(\"[%s:%s] %s: %v\", e.Component, e.Operation, e.Type, e.Err)\n}\n\nfunc (e *BitTorrentError) Unwrap() error {\n    return e.Err\n}\n\n// BackoffScheduler implements exponential backoff with jitter\ntype BackoffScheduler struct {\n    baseDelay     time.Duration\n    maxDelay      time.Duration\n    multiplier    float64\n    jitterPercent int\n    currentDelay  time.Duration\n    failures      int\n    mutex         sync.RWMutex\n}\n\nfunc NewBackoffScheduler(base, max time.Duration, multiplier float64) *BackoffScheduler {\n    return &BackoffScheduler{\n        baseDelay:     base,\n        maxDelay:      max,\n        multiplier:    multiplier,\n        jitterPercent: 20,\n        currentDelay:  base,\n    }\n}\n\nfunc (b *BackoffScheduler) NextDelay() time.Duration {\n    b.mutex.Lock()\n    defer b.mutex.Unlock()\n    \n    delay := b.currentDelay\n    b.failures++\n    \n    // Calculate next delay with exponential backoff\n    next := time.Duration(float64(b.currentDelay) * b.multiplier)\n    if next > b.maxDelay {\n        next = b.maxDelay\n    }\n    b.currentDelay = next\n    \n    // Add jitter to prevent thundering herd\n    jitter := time.Duration(int64(delay) * int64(b.jitterPercent) / 100)\n    jitterAmount := time.Duration(rand.Int63n(int64(jitter*2))) - jitter\n    \n    return delay + jitterAmount\n}\n\nfunc (b *BackoffScheduler) Reset() {\n    b.mutex.Lock()\n    defer b.mutex.Unlock()\n    b.currentDelay = b.baseDelay\n    b.failures = 0\n}\n\n// CircuitBreaker implements circuit breaker pattern for fail-fast behavior\ntype CircuitBreaker struct {\n    name              string\n    failureThreshold  int\n    recoveryTimeout   time.Duration\n    successThreshold  int\n    state             CircuitState\n    failures          int\n    successes         int\n    lastFailureTime   time.Time\n    mutex             sync.RWMutex\n}\n\ntype CircuitState int\n\nconst (\n    CircuitClosed CircuitState = iota\n    CircuitOpen\n    CircuitHalfOpen\n)\n\nfunc NewCircuitBreaker(name string, failureThreshold int, recoveryTimeout time.Duration) *CircuitBreaker {\n    return &CircuitBreaker{\n        name:             name,\n        failureThreshold: failureThreshold,\n        recoveryTimeout:  recoveryTimeout,\n        successThreshold: 2,\n        state:           CircuitClosed,\n    }\n}\n\nfunc (cb *CircuitBreaker) Execute(ctx context.Context, operation func() error) error {\n    if !cb.canExecute() {\n        return &BitTorrentError{\n            Type:      ErrorTypeNetwork,\n            Component: \"circuit-breaker\",\n            Operation: cb.name,\n            Err:       fmt.Errorf(\"circuit breaker open\"),\n            Timestamp: time.Now(),\n        }\n    }\n    \n    err := operation()\n    cb.recordResult(err)\n    return err\n}\n\nfunc (cb *CircuitBreaker) canExecute() bool {\n    cb.mutex.RLock()\n    defer cb.mutex.RUnlock()\n    \n    switch cb.state {\n    case CircuitClosed:\n        return true\n    case CircuitOpen:\n        return time.Since(cb.lastFailureTime) >= cb.recoveryTimeout\n    case CircuitHalfOpen:\n        return true\n    default:\n        return false\n    }\n}\n\nfunc (cb *CircuitBreaker) recordResult(err error) {\n    cb.mutex.Lock()\n    defer cb.mutex.Unlock()\n    \n    if err != nil {\n        cb.failures++\n        cb.lastFailureTime = time.Now()\n        \n        if cb.failures >= cb.failureThreshold {\n            cb.state = CircuitOpen\n        }\n    } else {\n        cb.successes++\n        \n        if cb.state == CircuitHalfOpen && cb.successes >= cb.successThreshold {\n            cb.state = CircuitClosed\n            cb.failures = 0\n            cb.successes = 0\n        }\n    }\n}\n\n// PeerQualityScorer tracks peer reliability and performance metrics\ntype PeerQualityScorer struct {\n    scores map[string]*PeerScore\n    mutex  sync.RWMutex\n}\n\ntype PeerScore struct {\n    ConnectionReliability float64\n    DataQuality          float64\n    TransferPerformance  float64\n    ProtocolCompliance   float64\n    LastUpdate          time.Time\n}\n\nfunc NewPeerQualityScorer() *PeerQualityScorer {\n    return &PeerQualityScorer{\n        scores: make(map[string]*PeerScore),\n    }\n}\n\nfunc (pqs *PeerQualityScorer) UpdateScore(peerID string, metric string, value float64) {\n    pqs.mutex.Lock()\n    defer pqs.mutex.Unlock()\n    \n    score, exists := pqs.scores[peerID]\n    if !exists {\n        score = &PeerScore{\n            ConnectionReliability: 0.5,\n            DataQuality:          0.5,\n            TransferPerformance:  0.5,\n            ProtocolCompliance:   0.5,\n        }\n        pqs.scores[peerID] = score\n    }\n    \n    // Exponential moving average with time-based decay\n    alpha := 0.1\n    decay := pqs.calculateDecay(score.LastUpdate)\n    \n    switch metric {\n    case \"connection\":\n        score.ConnectionReliability = score.ConnectionReliability*decay + value*alpha\n    case \"data\":\n        score.DataQuality = score.DataQuality*decay + value*alpha\n    case \"performance\":\n        score.TransferPerformance = score.TransferPerformance*decay + value*alpha\n    case \"protocol\":\n        score.ProtocolCompliance = score.ProtocolCompliance*decay + value*alpha\n    }\n    \n    score.LastUpdate = time.Now()\n}\n\nfunc (pqs *PeerQualityScorer) calculateDecay(lastUpdate time.Time) float64 {\n    hoursSince := time.Since(lastUpdate).Hours()\n    return math.Pow(0.95, hoursSince) // 5% decay per hour\n}\n```\n\n**Core Logic Skeleton Code:**\n\n```go\n// ErrorHandler coordinates error recovery across all system components\ntype ErrorHandler struct {\n    backoffSchedulers map[string]*BackoffScheduler\n    circuitBreakers   map[string]*CircuitBreaker\n    qualityScorer     *PeerQualityScorer\n    recoveryStrategies map[ErrorType]RecoveryStrategy\n    eventBus          *EventBus\n    mutex             sync.RWMutex\n}\n\n// HandleError processes errors and determines appropriate recovery actions\nfunc (eh *ErrorHandler) HandleError(ctx context.Context, err error) RecoveryAction {\n    // TODO 1: Unwrap error to extract BitTorrentError with type and context\n    // TODO 2: Determine error severity and classification\n    // TODO 3: Check circuit breaker state for the failing component\n    // TODO 4: Calculate backoff delay based on error history\n    // TODO 5: Select appropriate recovery strategy based on error type\n    // TODO 6: Update peer quality scores if error involves specific peer\n    // TODO 7: Publish error event to event bus for component coordination\n    // TODO 8: Return recovery action with delay and retry parameters\n    // Hint: Use type assertion to extract BitTorrentError details\n}\n\n// RecoverFromFailure executes recovery procedures for different failure types\nfunc (eh *ErrorHandler) RecoverFromFailure(ctx context.Context, failureType ErrorType, component string) error {\n    // TODO 1: Look up recovery strategy for the specific failure type\n    // TODO 2: Check if circuit breaker allows recovery attempt\n    // TODO 3: Calculate appropriate backoff delay before retry\n    // TODO 4: Execute pre-recovery validation and cleanup\n    // TODO 5: Attempt recovery operation with timeout and context\n    // TODO 6: Update component state based on recovery success/failure\n    // TODO 7: Record recovery metrics and update error statistics\n    // TODO 8: Reset backoff scheduler on successful recovery\n    // Hint: Recovery strategies may involve reconnection, re-announce, or state reset\n}\n\n// ValidateMessageIntegrity checks peer protocol messages for correctness\nfunc ValidateMessageIntegrity(msg *Message, expectedType int, maxSize int) error {\n    // TODO 1: Validate message is not nil and has required fields\n    // TODO 2: Check message type matches expected type or is valid alternative\n    // TODO 3: Verify message payload size is within reasonable bounds\n    // TODO 4: Validate message-specific payload format and constraints\n    // TODO 5: Check for known malformed message patterns from misbehaving clients\n    // TODO 6: Return appropriate error type for different validation failures\n    // Hint: Different message types have different validation requirements\n}\n\n// HandlePieceVerificationFailure manages data integrity failures\nfunc (pm *PieceManager) HandlePieceVerificationFailure(pieceIndex int, peerID string, data []byte) error {\n    // TODO 1: Log piece verification failure with hash mismatch details\n    // TODO 2: Update peer quality score to reflect data integrity issue\n    // TODO 3: Mark piece as incomplete and remove corrupted data\n    // TODO 4: Cancel any outstanding requests for this piece from the same peer\n    // TODO 5: Add peer to temporary blacklist for this piece\n    // TODO 6: Request piece from alternative peers with higher quality scores\n    // TODO 7: Update piece availability tracking to reflect failed verification\n    // TODO 8: Notify statistics tracker of wasted bandwidth and retry\n    // Hint: Consider whether this is first failure or repeated failure from same peer\n}\n\n// HandleConnectionFailure manages peer connection loss and recovery\nfunc (pm *PeerManager) HandleConnectionFailure(peerID string, err error) error {\n    // TODO 1: Catalog all outstanding requests for the failed peer connection\n    // TODO 2: Update connection statistics and peer quality scores\n    // TODO 3: Notify piece manager to reassign outstanding requests\n    // TODO 4: Clean up connection state and release allocated resources\n    // TODO 5: Determine if connection should be retried or peer should be avoided\n    // TODO 6: Schedule reconnection attempt with appropriate backoff delay\n    // TODO 7: Update peer availability for piece selection algorithms\n    // TODO 8: Trigger tracker re-announce if too many connections have failed\n    // Hint: Different error types suggest different retry strategies\n}\n```\n\n**Language-Specific Hints:**\n\n- Use Go's error wrapping with `fmt.Errorf(\"context: %w\", err)` to maintain error chains for debugging\n- Implement custom error types with methods like `Temporary() bool` and `Timeout() bool` for classification\n- Use `context.WithTimeout()` for operations that need deadline-based failure detection\n- Leverage Go's `sync.RWMutex` for protecting shared error state while allowing concurrent reads\n- Use `time.NewTicker()` for implementing periodic error recovery attempts\n- Implement proper cleanup with `defer` statements to ensure resources are released on error paths\n\n**Milestone Checkpoint:**\n\nAfter implementing comprehensive error handling:\n\n1. **Test Network Failure Recovery**: Disconnect network during download, verify client recovers gracefully when connectivity returns\n2. **Verify Tracker Failover**: Stop primary tracker, confirm client switches to backup trackers automatically\n3. **Validate Data Corruption Handling**: Introduce corrupted piece data, verify client detects and recovers\n4. **Test Peer Protocol Violations**: Send malformed messages, confirm client handles gracefully without crashing\n5. **Monitor Error Metrics**: Verify error counters, backoff timers, and circuit breaker states update correctly\n6. **Check Concurrency Safety**: Run under race detector (`go test -race`) to detect synchronization issues\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Client hangs after errors | Deadlock in error recovery | Check goroutine stack traces | Review lock ordering, add timeouts |\n| Excessive retry attempts | Backoff not working | Log retry delays and counts | Verify backoff implementation, add circuit breakers |\n| Memory leaks during errors | Resources not cleaned up | Monitor memory usage over time | Add proper cleanup in error paths |\n| Inconsistent error handling | Missing error checks | Review error propagation | Add error wrapping and consistent handling |\n| Performance degradation | Too aggressive error recovery | Profile CPU and network usage | Tune backoff parameters, reduce retry frequency |\n| Error message confusion | Poor error context | Examine error message quality | Add structured error information and correlation IDs |\n\nThe comprehensive error handling system transforms a fragile BitTorrent prototype into a robust client capable of operating reliably in production environments. By anticipating failures, implementing graduated recovery strategies, and learning from past experiences, the client can maintain download progress even in challenging network conditions with unreliable peers.\n\n\n## Testing Strategy and Milestones\n\n> **Milestone(s):** This section provides comprehensive testing guidance for all milestones (1-4) by establishing verification strategies, test checkpoints, and debugging approaches that ensure correct implementation across torrent parsing, tracker communication, peer protocols, and piece management.\n\nBuilding a BitTorrent client involves complex interactions between multiple concurrent systems, making testing both crucial and challenging. Think of testing a BitTorrent client like **quality assurance for a busy restaurant kitchen** — you need to verify that individual stations (bencode parser, tracker client) work correctly in isolation, that the coordination between stations (peer manager talking to piece manager) flows smoothly, and that the entire kitchen can handle a full dinner rush (downloading a complete torrent with multiple peers) without breaking down. Just as a restaurant needs both ingredient quality checks and full service simulations, our BitTorrent client requires both unit tests for individual components and integration tests with real torrents and peer interactions.\n\nThe testing strategy must address several unique challenges in P2P systems: network failures can occur at any time, peers may behave unpredictably or maliciously, race conditions emerge from concurrent downloads, and timing-dependent behaviors make tests non-deterministic. Unlike traditional client-server applications where you control one endpoint, BitTorrent testing requires coordinating with external peers and trackers that may be unreliable or unavailable.\n\nOur testing approach follows a **pyramid structure** with three distinct layers, each serving different verification goals and catching different classes of bugs. The foundation consists of fast, deterministic unit tests that verify individual component logic without external dependencies. The middle layer includes integration tests that exercise component interactions using controlled environments and mock peers. The apex contains end-to-end tests that download real torrents from live networks, validating the complete system under realistic conditions.\n\n### Unit Testing Strategy\n\n**Unit testing** for BitTorrent components focuses on verifying the correctness of individual algorithms and data transformations without network dependencies or concurrency complications. Think of unit tests as **testing individual tools in a workshop** — you verify that each hammer swings correctly, each saw cuts accurately, and each measuring tape gives precise readings before attempting to build furniture. Each component must demonstrate correct behavior under various inputs, edge cases, and error conditions in isolation.\n\nThe bencode parsing component serves as an excellent example of comprehensive unit testing. Bencode parsing involves recursive data structure handling, binary string processing, and precise byte-level operations that are perfect candidates for deterministic unit tests. The parser must handle well-formed inputs correctly, detect malformed inputs gracefully, and maintain proper state across recursive calls.\n\n| Test Category | Test Cases | Expected Behavior | Validation Method |\n|---------------|------------|-------------------|-------------------|\n| Valid Bencode Strings | `4:spam`, `0:`, `10:helloworld` | Correct byte array extraction | Compare parsed bytes with expected values |\n| Valid Bencode Integers | `i42e`, `i-42e`, `i0e` | Correct integer conversion | Verify parsed integer matches expected value |\n| Valid Bencode Lists | `le`, `l4:spami42ee`, nested lists | Proper list structure and element parsing | Recursively validate list contents and types |\n| Valid Bencode Dictionaries | `de`, `d4:spami42ee`, nested dicts | Correct key-value mapping and ordering | Verify all keys present with correct values |\n| Malformed Input | `4:spa`, `i42`, `l4:spam`, incomplete structures | Appropriate error reporting | Verify specific error types and positions |\n| Edge Cases | Empty strings, zero integers, maximum values | Boundary condition handling | Test limits of integer ranges and string lengths |\n\nThe torrent metadata extraction component requires tests that verify correct field extraction, info hash calculation, and validation logic. These tests use pre-computed torrent files with known metadata values, allowing precise verification of parsing accuracy.\n\n| Component | Test Focus | Key Test Cases | Verification Strategy |\n|-----------|------------|----------------|----------------------|\n| `MetaInfo` Parsing | Field extraction accuracy | Single-file torrents, multi-file torrents, optional fields | Compare extracted fields with manually verified values |\n| Info Hash Calculation | SHA1 computation precision | Various info dictionaries, edge cases | Pre-compute expected hashes using reference implementations |\n| Piece Hash Extraction | Hash array processing | Different piece counts, hash validation | Verify individual piece hashes match expected values |\n| URL Validation | Announce URL processing | HTTP/HTTPS URLs, multi-tracker lists | Validate URL parsing and format requirements |\n\nTracker communication unit tests focus on URL construction, parameter encoding, and response parsing without making actual HTTP requests. Mock HTTP responses allow testing various tracker response formats and error conditions in a controlled environment.\n\n| Test Scenario | Input Data | Expected Output | Error Conditions |\n|---------------|------------|-----------------|------------------|\n| Announce URL Construction | `AnnounceRequest` with all fields | Properly encoded URL with all parameters | Missing required fields should cause validation errors |\n| Binary Data Encoding | Info hash with special bytes | Correct percent-encoding | Invalid byte sequences should be handled gracefully |\n| Compact Peer Parsing | 6-byte peer entries | `PeerInfo` structs with correct IP/port | Truncated or invalid peer data should trigger errors |\n| Response Validation | Tracker response dictionary | Extracted interval, peer list, counts | Missing required fields should be detected |\n\nThe peer wire protocol components benefit enormously from unit testing because the protocol involves precise byte-level message formatting, state machine transitions, and binary data handling. These operations are deterministic and perfect for fast, reliable unit tests.\n\n| Protocol Component | Test Categories | Critical Test Cases | Verification Approach |\n|-------------------|-----------------|--------------------|-----------------------|\n| `Handshake` Processing | Serialization/deserialization | Valid handshakes, wrong protocol, invalid lengths | Binary comparison with reference implementations |\n| `Message` Framing | Length-prefixed parsing | All message types, keep-alive, oversized messages | Verify correct message reconstruction from bytes |\n| `BitfieldOps` Operations | Bit manipulation | Set/get operations, edge piece indices, empty bitfields | Mathematical verification of bit operations |\n| Peer State Machine | State transitions | All valid transitions, invalid transition attempts | State verification after each message |\n\n⚠️ **Pitfall: Testing with Real Network Dependencies**\n\nA common mistake in BitTorrent testing is writing unit tests that make actual network requests to trackers or attempt to connect to live peers. This approach creates flaky tests that fail due to network conditions, tracker availability, or external peer behavior rather than code bugs. Unit tests must be **completely isolated** from external dependencies.\n\nInstead, use dependency injection to provide mock implementations during testing. The tracker client should accept an HTTP client interface that can be replaced with a mock during testing. Similarly, peer connections should use mock network connections that simulate various network conditions and peer behaviors without requiring actual TCP connections.\n\nThe piece management component presents unique unit testing challenges because it involves complex algorithms like rarest-first selection, concurrent request management, and content verification. However, these algorithms can be tested deterministically by providing controlled peer availability data and verifying piece selection decisions.\n\n| Algorithm | Test Focus | Input Scenarios | Expected Behaviors |\n|-----------|------------|-----------------|-------------------|\n| Rarest-First Selection | Piece prioritization | Various availability distributions | Pieces with lowest availability selected first |\n| Block Request Generation | Work distribution | Peer bitfields, pipeline limits | Correct block ranges, no overlapping requests |\n| Piece Verification | Content integrity | Valid pieces, corrupted pieces, hash mismatches | Accept valid pieces, reject corrupt pieces with specific errors |\n| Endgame Detection | Mode transition | Nearly complete downloads | Endgame activates at correct thresholds |\n\n### Integration Testing\n\n**Integration testing** verifies that BitTorrent components work correctly together, handling the complex interactions between concurrent subsystems without the unpredictability of live network conditions. Think of integration testing as **testing the entire restaurant service flow** — you verify that orders flow correctly from the front-of-house to the kitchen, that timing coordination works between different cooking stations, and that completed dishes reach the correct tables. Integration tests use controlled environments with mock peers and local trackers to simulate realistic BitTorrent interactions.\n\nThe key challenge in BitTorrent integration testing is managing the **concurrency and timing dependencies** that emerge when multiple components interact. The tracker client must coordinate with the peer manager to provide fresh peer lists, the peer manager must coordinate with the piece manager to request needed blocks, and the piece manager must coordinate with file I/O to assemble completed pieces. These interactions involve shared state, message passing, and timing-sensitive behaviors that require careful test orchestration.\n\nIntegration tests for BitTorrent use several **controlled environment techniques** to provide realistic interactions while maintaining test reliability and speed. Local tracker servers provide predictable peer discovery without external dependencies. Mock peer implementations simulate various peer behaviors including normal operation, slow responses, connection failures, and protocol violations. Dedicated test torrents with known content allow verification of complete download cycles with predictable outcomes.\n\n| Integration Test Level | Components Involved | Test Environment | Validation Focus |\n|-----------------------|-------------------|------------------|------------------|\n| Parser + Tracker | `TorrentParser`, `TrackerClient` | Local HTTP server | Torrent metadata flows correctly to tracker requests |\n| Tracker + Peer Manager | `TrackerClient`, `PeerManager` | Mock tracker with controlled peer lists | Peer discovery and connection establishment |\n| Peer + Piece Manager | `PeerManager`, `PieceManager` | Mock peers with controlled bitfields | Block request coordination and piece assembly |\n| Complete Download Flow | All components | Local tracker + mock peers + test torrent | End-to-end download with verification |\n\nThe **tracker integration tests** verify that the tracker client correctly processes torrent metadata to build announce requests and that the peer manager can establish connections with discovered peers. These tests use a local HTTP server that implements the tracker protocol, allowing precise control over tracker responses and timing.\n\n> **Design Insight: Test Torrent Creation**\n> Integration tests require specially crafted torrent files with predictable content and known piece hashes. Create test torrents from small text files with easily verifiable content (like \"Hello, World!\" repeated to fill exact piece boundaries). This allows tests to verify both the download mechanics and the final file content without requiring large data transfers.\n\n| Test Scenario | Mock Tracker Behavior | Expected Client Response | Validation Points |\n|---------------|----------------------|--------------------------|-------------------|\n| Successful Announce | Return peer list with 3 mock peers | Establish connections to all 3 peers | Verify connection count, handshake completion |\n| Tracker Error Response | Return failure reason | Implement backoff and retry | Verify exponential backoff timing |\n| Compact Peer Format | Return binary peer list | Parse IP/port correctly | Verify individual peer addresses |\n| Re-announce Timing | Specify announce interval | Re-announce at correct intervals | Verify timing and updated statistics |\n\n**Peer protocol integration tests** focus on the interaction between peer connections and the piece management system. These tests use mock peer implementations that simulate various peer behaviors and network conditions to verify that the peer manager correctly handles the protocol state machine and block transfer logic.\n\nThe mock peer implementation provides controlled responses to handshakes, bitfield exchanges, and piece requests. This allows testing various peer behaviors including immediate responses, delayed responses, connection drops, and protocol violations. The piece manager's reaction to these behaviors validates the robustness of the peer coordination logic.\n\n| Mock Peer Behavior | Test Purpose | Expected Client Reaction | Success Criteria |\n|-------------------|--------------|-------------------------|------------------|\n| Normal Operation | Happy path verification | Complete block downloads | All requested blocks received correctly |\n| Slow Responses | Timeout handling | Request retry or peer replacement | Download continues with other peers |\n| Connection Drop | Network failure resilience | Graceful connection cleanup | No resource leaks, request redistribution |\n| Invalid Messages | Protocol violation handling | Connection termination with error logging | Malformed messages don't crash client |\n| Choking Behavior | Upload permission changes | Pause requests when choked, resume when unchoked | Respect peer choking decisions |\n\n**Piece assembly integration tests** verify the coordination between downloading blocks from multiple peers and assembling them into complete, verified pieces. These tests use multiple mock peers, each providing different pieces or blocks, to simulate the parallel downloading that occurs in real BitTorrent swarms.\n\nThe test setup involves creating a small test torrent with 3-4 pieces, then using mock peers that each have different piece availability. The integration test verifies that the piece manager correctly coordinates block requests across peers, assembles received blocks into pieces, verifies piece hashes, and writes completed pieces to the output file.\n\n| Test Configuration | Peer Setup | Download Pattern | Validation Focus |\n|-------------------|------------|------------------|------------------|\n| Sequential Pieces | Each peer has consecutive pieces | Download pieces 0,1,2,3 in order | Basic piece assembly and file writing |\n| Interleaved Availability | Peers have overlapping piece sets | Rarest-first selection with multiple sources | Piece selection algorithm and peer coordination |\n| Partial Availability | Some pieces only available from one peer | Handle peer bottlenecks | Request distribution and peer management |\n| Corrupted Pieces | Mock peer sends invalid piece data | Hash verification and re-request | Content integrity and error recovery |\n\n### Milestone Verification Checkpoints\n\n**Milestone verification checkpoints** provide concrete, measurable criteria for determining whether each implementation phase is working correctly before proceeding to the next phase. Think of these checkpoints as **quality gates in a manufacturing process** — each stage must meet specific standards before the product moves to the next assembly station. These checkpoints catch integration issues early and ensure that each milestone provides a solid foundation for subsequent development.\n\nEach milestone checkpoint includes both **automated verification** through test execution and **manual verification** through observable behavior and output inspection. The automated tests provide rapid feedback on correctness, while manual verification ensures that the system exhibits expected behavior under realistic conditions.\n\n#### Milestone 1: Torrent File Parsing Checkpoints\n\nThe first milestone focuses on torrent file parsing and metadata extraction. Successful completion requires accurate bencode decoding, correct field extraction, and proper info hash calculation. The verification checkpoints ensure that parsing works correctly with various torrent file formats and edge cases.\n\n| Checkpoint | Verification Method | Expected Outcome | Troubleshooting |\n|------------|-------------------|------------------|-----------------|\n| Bencode Decoder | Unit test suite with 50+ test cases | All tests pass, handles all four bencode types | Check for off-by-one errors in length parsing |\n| Torrent Metadata | Parse real torrent files from various sources | Extract announce URL, file info, piece data correctly | Verify info dict boundaries using hex editor |\n| Info Hash Calculation | Compare with reference implementations | SHA1 hash matches expected values exactly | Ensure bencoding preserves exact byte sequences |\n| Edge Case Handling | Test with malformed and unusual torrents | Graceful error reporting with specific error types | Check error message clarity and debugging information |\n\n**Manual Verification for Milestone 1:**\n```bash\n# Test with a real torrent file\n./bittorrent parse ubuntu-20.04.3-desktop-amd64.iso.torrent\n\nExpected Output:\nAnnounce URL: http://torrent.ubuntu.com:6969/announce\nInfo Hash: a3b5c7e9f1d3e5a7b9c1f3e5a7b9c1d3e5a7b9c1\nFile Name: ubuntu-20.04.3-desktop-amd64.iso\nFile Size: 2,785,017,856 bytes\nPiece Length: 262,144 bytes\nPiece Count: 10,630 pieces\n```\n\n⚠️ **Pitfall: Info Hash Calculation Errors**\n\nThe most common error in Milestone 1 is incorrect info hash calculation due to improper handling of the bencoded info dictionary boundaries. The info hash must be calculated from the **exact bencoded bytes** of the info dictionary, not from a re-encoded version. Parse the torrent file, locate the start and end positions of the info dictionary in the original bytes, then calculate SHA1 from that exact byte slice.\n\n#### Milestone 2: Tracker Communication Checkpoints\n\nThe second milestone implements tracker communication for peer discovery. Successful completion requires proper URL construction, binary data encoding, HTTP request handling, and peer list parsing. The checkpoints verify that the client can successfully communicate with various tracker types and handle different response formats.\n\n| Checkpoint | Verification Method | Expected Outcome | Common Issues |\n|------------|-------------------|------------------|---------------|\n| Announce URL Construction | Unit tests with various parameter combinations | Correctly formatted URLs with proper encoding | Binary data encoding, parameter ordering |\n| HTTP Tracker Communication | Integration test with local tracker | Successful announce and peer list retrieval | URL encoding, content-type headers |\n| Compact Peer Parsing | Unit tests with known peer data | Correct IP/port extraction from binary format | Endianness, byte order interpretation |\n| Error Handling | Test with various tracker error responses | Appropriate error detection and reporting | HTTP status codes, tracker error messages |\n\n**Manual Verification for Milestone 2:**\n```bash\n# Test tracker communication\n./bittorrent announce ubuntu-20.04.3-desktop-amd64.iso.torrent\n\nExpected Output:\nAnnouncing to: http://torrent.ubuntu.com:6969/announce\nAnnounce Response:\n  Interval: 1800 seconds\n  Complete: 147 seeders\n  Incomplete: 23 leechers\n  Peers discovered: 50 peers\n  Sample peers:\n    91.189.89.123:51413\n    185.125.190.39:42000\n    ...\n```\n\nThe tracker communication checkpoint must verify that the client correctly handles both successful announcements and various error conditions. Test with multiple tracker URLs, including trackers that return errors, timeouts, and malformed responses.\n\n#### Milestone 3: Peer Wire Protocol Checkpoints\n\nThe third milestone implements the peer wire protocol including handshakes, message framing, and state management. The checkpoints verify correct protocol implementation, message parsing, and peer state coordination.\n\n| Checkpoint | Verification Method | Expected Outcome | Critical Validations |\n|------------|-------------------|------------------|---------------------|\n| Handshake Protocol | Integration test with mock peers | Successful handshake exchange | Protocol string, info hash verification |\n| Message Parsing | Unit tests with all message types | Correct message deserialization | Length framing, message ID handling |\n| Bitfield Exchange | Integration test with controlled peers | Accurate piece availability tracking | Bitfield size calculation, bit operations |\n| State Machine | Unit tests covering all transitions | Proper choking/interested state management | State transition validation, invalid state handling |\n| Request Pipeline | Integration test with mock peer responses | Multiple outstanding requests managed correctly | Pipeline depth limits, request/response correlation |\n\n**Manual Verification for Milestone 3:**\n```bash\n# Test peer protocol with verbose logging\n./bittorrent connect 91.189.89.123:51413 --info-hash=a3b5c7e9f1d3e5a7b9c1f3e5a7b9c1d3e5a7b9c1\n\nExpected Output:\nConnecting to peer 91.189.89.123:51413...\nSending handshake...\nReceived handshake response:\n  Protocol: BitTorrent protocol\n  Info Hash: a3b5c7e9f1d3e5a7b9c1f3e5a7b9c1d3e5a7b9c1 ✓\n  Peer ID: -UT355W-[random bytes]\nReceived bitfield message: 1,327 bytes\nPeer has 8,547 of 10,630 pieces (80.4%)\nSending interested message...\nPeer state: not choking, we are interested\n```\n\n⚠️ **Pitfall: Message Framing Errors**\n\nPeer protocol message framing errors are common and difficult to debug. Each message starts with a 4-byte big-endian length prefix followed by the message data. Partial reads from TCP connections can split messages across multiple read operations. Implement a message buffer that accumulates bytes until complete messages are available for processing.\n\n#### Milestone 4: Piece Management & Seeding Checkpoints\n\nThe final milestone implements piece downloading, verification, and seeding capabilities. The checkpoints verify complete download functionality, content integrity, and upload capabilities.\n\n| Checkpoint | Verification Method | Expected Outcome | Key Metrics |\n|------------|-------------------|------------------|-------------|\n| Piece Verification | Download test torrent with known content | All pieces pass SHA1 verification | Zero hash verification failures |\n| Download Completion | End-to-end test with small torrent | Complete file matches original exactly | File size and content hash verification |\n| Rarest-First Selection | Test with controlled peer availability | Pieces selected in order of increasing availability | Selection algorithm correctness |\n| Upload Capability | Test with requesting peers | Successfully serve piece data to other peers | Upload statistics and peer satisfaction |\n| Concurrent Downloads | Test with multiple simultaneous peers | Efficient bandwidth utilization across peers | Download rate and peer coordination |\n\n**Manual Verification for Milestone 4:**\n```bash\n# Complete download test\n./bittorrent download test-file.torrent --output=/tmp/downloaded\n\nExpected Output:\nParsing torrent file...\nContacting tracker...\nDiscovered 15 peers, connecting...\nConnected to 8 peers\nDownloading...\nProgress: [██████████████████████████████] 100% (1.2 MB/s)\nDownload complete: 2,785,017,856 bytes in 38m 42s\nVerifying final file hash... ✓\nStarting seeding mode...\nServing requests from 3 peers...\nUploaded 45.2 MB to other peers\n```\n\nThe final checkpoint must verify that the downloaded file is **byte-for-byte identical** to the original. Calculate the SHA1 hash of the completed file and compare it with the expected hash from the torrent metadata. Additionally, test that the client can successfully serve piece requests from other peers, demonstrating complete BitTorrent protocol implementation.\n\n> **Critical Success Criteria**\n> The ultimate test of Milestone 4 success is downloading a real torrent file from a live BitTorrent network. Choose a small, popular torrent (like a Linux distribution ISO) that has many seeders. Your client should successfully discover peers, download all pieces, verify content integrity, and produce a file that matches the original exactly. This demonstrates that your implementation is compatible with the broader BitTorrent ecosystem.\n\n### Implementation Guidance\n\nThe testing infrastructure for a BitTorrent client requires careful setup to provide reliable, fast feedback while covering the complex interactions between concurrent components. The testing strategy emphasizes **isolation** for unit tests, **controlled environments** for integration tests, and **realistic conditions** for milestone verification.\n\n#### Technology Recommendations\n\n| Testing Component | Simple Option | Advanced Option |\n|------------------|---------------|-----------------|\n| Unit Testing Framework | Go's built-in testing package (`testing`) | Ginkgo + Gomega for BDD-style tests |\n| Mock Generation | Manual mock interfaces | GoMock for automatic mock generation |\n| HTTP Mocking | httptest package for mock servers | WireMock for complex HTTP scenarios |\n| Binary Test Data | Embedded hex strings in test code | Binary test files with loading utilities |\n| Test Assertion Library | Basic Go assert functions | Testify for rich assertion methods |\n| Concurrent Testing | Go race detector (`go test -race`) | Stress testing with multiple goroutines |\n\n#### Recommended File Structure\n\nThe testing structure mirrors the main code organization while providing comprehensive coverage and easy test execution:\n\n```\nproject-root/\n  cmd/bittorrent/\n    main.go\n    main_test.go              ← CLI integration tests\n  internal/\n    torrent/\n      parser.go\n      parser_test.go          ← Bencode and metadata parsing tests\n      testdata/               ← Sample torrent files for testing\n        small.torrent\n        multi-file.torrent\n        malformed.torrent\n    tracker/\n      client.go\n      client_test.go          ← Tracker communication unit tests\n      mock_tracker_test.go    ← Local HTTP server for integration tests\n    peer/\n      connection.go\n      connection_test.go      ← Peer protocol unit tests\n      mock_peer_test.go       ← Mock peer implementations\n      protocol_test.go        ← Message framing and state machine tests\n    piece/\n      manager.go\n      manager_test.go         ← Piece selection and verification tests\n      integration_test.go     ← Multi-component integration tests\n  test/\n    fixtures/                 ← Test data and utilities\n      test_torrents/          ← Known good torrents for integration testing\n      mock_tracker.go         ← Reusable mock tracker implementation\n      mock_peer.go           ← Reusable mock peer implementation\n    integration/              ← End-to-end integration tests\n      download_test.go        ← Complete download cycle tests\n      seeding_test.go         ← Upload and seeding tests\n```\n\n#### Infrastructure Starter Code\n\n**Test Torrent Generator** (Complete implementation):\n\n```go\n// test/fixtures/torrent_generator.go\npackage fixtures\n\nimport (\n    \"crypto/sha1\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n    \n    \"github.com/yourusername/bittorrent/internal/torrent\"\n)\n\n// TestTorrentConfig defines parameters for generating test torrents\ntype TestTorrentConfig struct {\n    FileName     string\n    Content      []byte\n    PieceLength  int64\n    AnnounceURL  string\n}\n\n// GenerateTestTorrent creates a complete torrent file with known content\n// for testing download and verification logic\nfunc GenerateTestTorrent(config TestTorrentConfig) (*torrent.MetaInfo, error) {\n    // Calculate piece count and generate piece hashes\n    pieceCount := (int64(len(config.Content)) + config.PieceLength - 1) / config.PieceLength\n    var pieceHashes []byte\n    \n    for i := int64(0); i < pieceCount; i++ {\n        start := i * config.PieceLength\n        end := start + config.PieceLength\n        if end > int64(len(config.Content)) {\n            end = int64(len(config.Content))\n        }\n        \n        hash := sha1.Sum(config.Content[start:end])\n        pieceHashes = append(pieceHashes, hash[:]...)\n    }\n    \n    // Build info dictionary\n    info := torrent.Info{\n        Name:        config.FileName,\n        Length:      int64(len(config.Content)),\n        PieceLength: config.PieceLength,\n        Pieces:      pieceHashes,\n    }\n    \n    // Calculate info hash (would use actual bencode encoding)\n    infoHash := sha1.Sum([]byte(\"mock-info-dict\")) // TODO: Implement proper bencoding\n    \n    metaInfo := &torrent.MetaInfo{\n        Announce:     config.AnnounceURL,\n        CreationDate: time.Now(),\n        Comment:      \"Generated for testing\",\n        CreatedBy:    \"BitTorrent Test Suite\",\n        InfoHash:     infoHash,\n        Info:         info,\n    }\n    \n    return metaInfo, nil\n}\n\n// WriteTestFile creates the actual file content for a test torrent\nfunc WriteTestFile(path string, content []byte) error {\n    if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n        return err\n    }\n    return os.WriteFile(path, content, 0644)\n}\n\n// LoadTestTorrent loads a pre-built test torrent from the fixtures directory\nfunc LoadTestTorrent(name string) (*torrent.MetaInfo, error) {\n    path := filepath.Join(\"testdata\", name+\".torrent\")\n    return torrent.ParseFromFile(path)\n}\n```\n\n**Mock Tracker Implementation** (Complete HTTP server):\n\n```go\n// test/fixtures/mock_tracker.go\npackage fixtures\n\nimport (\n    \"encoding/binary\"\n    \"net\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"net/url\"\n    \"strconv\"\n    \"time\"\n)\n\n// MockTracker provides controlled tracker responses for testing\ntype MockTracker struct {\n    server    *httptest.Server\n    responses map[string]*TrackerResponse\n    requests  []*TrackerRequest\n}\n\ntype TrackerResponse struct {\n    Interval   int\n    Complete   int\n    Incomplete int\n    Peers      []MockPeer\n    Error      string\n}\n\ntype TrackerRequest struct {\n    InfoHash   string\n    PeerID     string\n    Port       int\n    Uploaded   int64\n    Downloaded int64\n    Left       int64\n    Event      string\n    Timestamp  time.Time\n}\n\ntype MockPeer struct {\n    IP   net.IP\n    Port uint16\n}\n\n// NewMockTracker creates a local HTTP server that implements tracker protocol\nfunc NewMockTracker() *MockTracker {\n    mt := &MockTracker{\n        responses: make(map[string]*TrackerResponse),\n        requests:  make([]*TrackerRequest, 0),\n    }\n    \n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/announce\", mt.handleAnnounce)\n    mt.server = httptest.NewServer(mux)\n    \n    return mt\n}\n\n// SetResponse configures the tracker response for a specific info hash\nfunc (mt *MockTracker) SetResponse(infoHash string, response *TrackerResponse) {\n    mt.responses[infoHash] = response\n}\n\n// GetRequests returns all announce requests received by the tracker\nfunc (mt *MockTracker) GetRequests() []*TrackerRequest {\n    return mt.requests\n}\n\n// URL returns the mock tracker's announce URL\nfunc (mt *MockTracker) URL() string {\n    return mt.server.URL + \"/announce\"\n}\n\n// Close shuts down the mock tracker server\nfunc (mt *MockTracker) Close() {\n    mt.server.Close()\n}\n\nfunc (mt *MockTracker) handleAnnounce(w http.ResponseWriter, r *http.Request) {\n    // Parse announce request parameters\n    query := r.URL.Query()\n    \n    request := &TrackerRequest{\n        InfoHash:   query.Get(\"info_hash\"),\n        PeerID:     query.Get(\"peer_id\"),\n        Event:      query.Get(\"event\"),\n        Timestamp:  time.Now(),\n    }\n    \n    // Parse numeric parameters with error handling\n    if port, err := strconv.Atoi(query.Get(\"port\")); err == nil {\n        request.Port = port\n    }\n    if uploaded, err := strconv.ParseInt(query.Get(\"uploaded\"), 10, 64); err == nil {\n        request.Uploaded = uploaded\n    }\n    if downloaded, err := strconv.ParseInt(query.Get(\"downloaded\"), 10, 64); err == nil {\n        request.Downloaded = downloaded\n    }\n    if left, err := strconv.ParseInt(query.Get(\"left\"), 10, 64); err == nil {\n        request.Left = left\n    }\n    \n    mt.requests = append(mt.requests, request)\n    \n    // Look up configured response\n    response, exists := mt.responses[request.InfoHash]\n    if !exists {\n        http.Error(w, \"Unknown torrent\", http.StatusNotFound)\n        return\n    }\n    \n    // Return error response if configured\n    if response.Error != \"\" {\n        w.Header().Set(\"Content-Type\", \"text/plain\")\n        w.WriteHeader(http.StatusInternalServerError)\n        w.Write([]byte(response.Error))\n        return\n    }\n    \n    // Build bencode response (simplified - would use proper bencode encoding)\n    compactPeers := make([]byte, len(response.Peers)*6)\n    for i, peer := range response.Peers {\n        copy(compactPeers[i*6:], peer.IP.To4())\n        binary.BigEndian.PutUint16(compactPeers[i*6+4:], peer.Port)\n    }\n    \n    // TODO: Implement proper bencode encoding for production use\n    w.Header().Set(\"Content-Type\", \"text/plain\")\n    w.Write([]byte(\"d8:intervali\" + strconv.Itoa(response.Interval) + \n                   \"e8:completei\" + strconv.Itoa(response.Complete) + \n                   \"e10:incompletei\" + strconv.Itoa(response.Incomplete) + \n                   \"e5:peers\" + strconv.Itoa(len(compactPeers)) + \":\"))\n    w.Write(compactPeers)\n    w.Write([]byte(\"e\"))\n}\n\n// DefaultPeers returns a standard set of mock peers for testing\nfunc DefaultPeers() []MockPeer {\n    return []MockPeer{\n        {IP: net.ParseIP(\"192.168.1.100\"), Port: 6881},\n        {IP: net.ParseIP(\"10.0.0.50\"), Port: 51413},\n        {IP: net.ParseIP(\"172.16.1.200\"), Port: 42000},\n    }\n}\n```\n\n#### Core Testing Logic Skeletons\n\n**Torrent Parsing Test Suite** (Structure with detailed TODOs):\n\n```go\n// internal/torrent/parser_test.go\npackage torrent\n\nimport (\n    \"testing\"\n    \"path/filepath\"\n)\n\nfunc TestBencodeDecoding(t *testing.T) {\n    // TODO 1: Test valid string decoding - create test cases for various string lengths\n    // TODO 2: Test valid integer decoding - include positive, negative, and zero values\n    // TODO 3: Test valid list decoding - include empty lists and nested structures\n    // TODO 4: Test valid dictionary decoding - include empty dicts and nested structures\n    // TODO 5: Test malformed input handling - verify specific error types and positions\n    // TODO 6: Test edge cases - empty strings, maximum integer values, deeply nested structures\n    // Hint: Use table-driven tests with input/expected output pairs\n}\n\nfunc TestTorrentMetadataExtraction(t *testing.T) {\n    // TODO 1: Load test torrent file from testdata directory\n    // TODO 2: Parse torrent file using ParseFromFile function\n    // TODO 3: Verify announce URL extraction matches expected value\n    // TODO 4: Verify file info extraction (name, length, piece length)\n    // TODO 5: Verify piece hash extraction and count\n    // TODO 6: Test with multi-file torrents and verify file list parsing\n    // Hint: Pre-compute expected values using a reference BitTorrent implementation\n}\n\nfunc TestInfoHashCalculation(t *testing.T) {\n    // TODO 1: Load torrent file and extract raw bencode bytes\n    // TODO 2: Locate info dictionary boundaries in the raw bytes\n    // TODO 3: Calculate SHA1 hash of exact info dictionary bytes\n    // TODO 4: Compare with expected hash from reference implementation\n    // TODO 5: Test with multiple torrent files to ensure consistency\n    // TODO 6: Verify that re-encoding doesn't change the hash\n    // Hint: Use hex.DecodeString to create expected hash values from known torrents\n}\n```\n\n**Integration Test Suite** (Structure with coordination logic):\n\n```go\n// test/integration/download_test.go\npackage integration\n\nimport (\n    \"context\"\n    \"testing\"\n    \"time\"\n    \n    \"github.com/yourusername/bittorrent/test/fixtures\"\n)\n\nfunc TestCompleteDownloadCycle(t *testing.T) {\n    // TODO 1: Create test torrent with known content using fixtures.GenerateTestTorrent\n    // TODO 2: Start mock tracker with configured peer list using fixtures.NewMockTracker\n    // TODO 3: Start mock peers that serve the test torrent content\n    // TODO 4: Create BitTorrent client and initiate download\n    // TODO 5: Monitor download progress and verify piece-by-piece completion\n    // TODO 6: Verify final file content matches original exactly\n    // TODO 7: Test seeding mode by having client serve requests from other mock peers\n    // Hint: Use timeouts to prevent test hangs, typical integration test takes 10-30 seconds\n}\n\nfunc TestMultiPeerCoordination(t *testing.T) {\n    ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)\n    defer cancel()\n    \n    // TODO 1: Create test torrent with multiple pieces (4-6 pieces)\n    // TODO 2: Configure 3 mock peers with different piece availability patterns\n    //         - Peer 1: has pieces 0, 2, 4\n    //         - Peer 2: has pieces 1, 3, 5\n    //         - Peer 3: has pieces 0, 1, 2 (overlapping)\n    // TODO 3: Verify client discovers all peers through mock tracker\n    // TODO 4: Monitor piece requests to ensure optimal distribution across peers\n    // TODO 5: Verify rarest-first selection algorithm chooses pieces correctly\n    // TODO 6: Simulate peer disconnection and verify client handles gracefully\n    // TODO 7: Verify download completes successfully using remaining peers\n    // Hint: Log all peer interactions to verify correct protocol behavior\n}\n```\n\n#### Milestone Checkpoint Scripts\n\n**Automated Verification Scripts**:\n\n```bash\n#!/bin/bash\n# scripts/verify-milestone-1.sh\n\necho \"=== Milestone 1: Torrent File Parsing Verification ===\"\n\n# Run unit tests\necho \"Running bencode parsing tests...\"\ngo test ./internal/torrent/... -v -run TestBencode\n\necho \"Running torrent metadata extraction tests...\"\ngo test ./internal/torrent/... -v -run TestMetadata\n\n# Test with real torrent file\necho \"Testing with real torrent file...\"\n./bittorrent parse test/fixtures/testdata/small.torrent > /tmp/parse_output.txt\n\n# Verify expected output format\nif grep -q \"Announce URL:\" /tmp/parse_output.txt && \\\n   grep -q \"Info Hash:\" /tmp/parse_output.txt && \\\n   grep -q \"File Name:\" /tmp/parse_output.txt; then\n    echo \"✓ Torrent parsing output format correct\"\nelse\n    echo \"✗ Torrent parsing output format incorrect\"\n    cat /tmp/parse_output.txt\n    exit 1\nfi\n\necho \"=== Milestone 1 Verification Complete ===\"\n```\n\nThe testing strategy provides a comprehensive foundation for building a robust BitTorrent client through systematic verification at multiple levels. Unit tests catch algorithmic errors and edge cases early, integration tests verify component interactions in controlled environments, and milestone checkpoints ensure each implementation phase meets quality standards before proceeding. This layered approach builds confidence that the final system will work correctly in the complex, unpredictable environment of real BitTorrent networks.\n\n\n## Debugging Guide\n\n> **Milestone(s):** This section provides essential debugging guidance for all milestones (1-4) by establishing systematic approaches to diagnose and fix common issues across torrent parsing, tracker communication, peer protocols, and piece management.\n\nBuilding a BitTorrent client involves multiple interacting systems: binary protocol parsing, concurrent networking, cryptographic verification, and complex state management. When things go wrong, the symptoms can be misleading and the root causes can be buried deep in protocol minutiae or race conditions. This debugging guide provides systematic approaches to diagnose and resolve the most common issues that learners encounter when implementing each milestone.\n\nThink of debugging a BitTorrent client like being a detective investigating a crime scene. Each symptom is a clue that points toward potential causes, but the evidence can be scattered across multiple components. A failed download might be caused by incorrect Bencode parsing, malformed tracker requests, peer protocol violations, or piece verification failures. The key is building a systematic methodology to collect evidence, form hypotheses, and test them methodically.\n\nThe debugging process follows a consistent pattern across all components: observe the symptoms, collect diagnostic data, form hypotheses about root causes, test the hypotheses with targeted experiments, and verify the fixes. This section provides specific guidance for each milestone's unique challenges while establishing common debugging practices that apply across the entire system.\n\n### Torrent Parsing Debug Guide\n\nTorrent file parsing forms the foundation of the entire BitTorrent client, and parsing errors can manifest as mysterious failures much later in the download process. The Bencode format, while simple in concept, has several edge cases that can trap unwary implementers. Understanding these pitfalls and their debugging approaches is crucial for building a robust foundation.\n\n#### Bencode Parsing Issues\n\nThe most common torrent parsing failures stem from incorrect Bencode decoding, which can produce subtly corrupted data that only manifests when used by other components. These issues require systematic diagnosis starting from the lowest level of byte interpretation.\n\n**Symptom-Cause-Fix Mapping for Bencode Parsing:**\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix |\n|---------|--------------|------------------|-----|\n| Parser crashes on \"invalid character\" | Treating binary data as UTF-8 string | Print raw bytes around error offset, check for non-printable characters | Use `[]byte` for all Bencode strings, not Go `string` type |\n| Info hash doesn't match tracker expectations | Including extra bytes in info dict boundaries | Log exact byte ranges used for hash calculation, compare with reference implementation | Parse info dict as complete bencoded value, not individual fields |\n| Piece count mismatch | Incorrect piece hash extraction from concatenated field | Verify pieces field length is multiple of 20, count extracted hashes | Extract 20-byte chunks sequentially, verify total length |\n| Random parsing failures on large files | Buffer overruns or incorrect offset tracking | Add offset logging to every parse step, verify buffer boundaries | Implement proper bounds checking in decoder |\n| Nested dictionary corruption | Stack overflow in recursive parsing | Monitor recursion depth, check for circular references | Add recursion depth limits and iterative parsing for deep nesting |\n\nThe most insidious Bencode parsing bug involves the treatment of binary strings. Many implementers assume Bencode strings contain text data and convert them to their language's native string type. However, Bencode strings frequently contain binary data (like piece hashes or info dictionaries), and any encoding conversion corrupts this data.\n\n> **Critical Insight**: Bencode strings are binary-safe byte sequences, not text strings. Always parse them as byte arrays and only convert to text when you know the content is actually textual (like file names or announce URLs).\n\n#### Info Hash Calculation Debugging\n\nThe info hash serves as the unique identifier for a torrent and must be calculated from the exact bencoded bytes of the info dictionary. Any deviation in these bytes produces a different hash, causing tracker and peer rejections. Info hash calculation errors are particularly difficult to debug because the hash looks \"correct\" but doesn't match what other clients compute.\n\n**Info Hash Validation Process:**\n\n1. **Isolate the exact info dictionary bytes**: The info hash must be computed from the exact bencoded representation of the info dictionary as it appears in the torrent file, not from a re-encoding of parsed data\n2. **Verify byte boundaries**: Log the start and end positions of the info dictionary within the torrent file and ensure no extra bytes are included\n3. **Cross-reference with known tools**: Use standard tools like `transmission-show` or online torrent analyzers to get the expected info hash for comparison\n4. **Validate the SHA1 calculation**: Ensure you're using SHA1 (not SHA256 or other hash functions) and computing it over the raw bytes\n5. **Check for encoding issues**: Verify that no character encoding conversion has occurred on the info dictionary bytes\n\nA common debugging technique is to export the exact bytes used for hash calculation to a file and compute the SHA1 manually using command-line tools to verify your calculation logic.\n\n#### Torrent Metadata Extraction Issues\n\nOnce Bencode parsing succeeds, extracting meaningful metadata from the parsed structures presents its own challenges. The BitTorrent specification has evolved over time, leading to multiple ways to represent the same information, and real-world torrent files often contain unexpected variations.\n\n**Metadata Extraction Debug Checklist:**\n\n| Component | Validation Check | Expected Behavior | Common Errors |\n|-----------|-----------------|-------------------|---------------|\n| Announce URL | URL format validation | Valid HTTP/HTTPS/UDP URL | Missing protocol, malformed URL encoding |\n| File Information | Single vs multi-file detection | Length field XOR files array present | Both or neither present, incorrect total size calculation |\n| Piece Information | Piece count calculation | `(pieces field length) / 20 == ceiling(total size / piece length)` | Off-by-one errors, integer division rounding |\n| Creation Date | Unix timestamp validation | Valid time within reasonable range | Negative timestamps, far-future dates |\n| Encoding Fields | Character set handling | UTF-8 for modern torrents, other encodings for legacy | Incorrect encoding assumptions |\n\nThe piece count validation deserves special attention because it involves multiple related calculations. The number of piece hashes in the pieces field should match the number of pieces required to cover the total file size given the piece length. Mismatches indicate either parsing errors or corrupted torrent files.\n\n### Network Protocol Debugging\n\nNetwork protocol debugging requires understanding both the HTTP tracker protocol and the BitTorrent peer wire protocol. Network issues can manifest as connection failures, timeouts, protocol violations, or data corruption. The key to effective network debugging is systematic observation of the actual bytes sent and received, not just the application-level interpretation of those bytes.\n\n#### Tracker Communication Issues\n\nTracker communication failures are often the first network-related problems encountered during implementation. These issues typically stem from incorrect URL encoding, missing parameters, or mishandling of the tracker response format.\n\n**Tracker Debug Investigation Process:**\n\n1. **Capture the exact HTTP request**: Log the complete URL with all parameters to verify proper construction\n2. **Verify URL encoding**: Ensure binary data (like info hash) is percent-encoded correctly for URLs\n3. **Check parameter completeness**: Confirm all required parameters (info_hash, peer_id, port, uploaded, downloaded, left) are present\n4. **Validate response parsing**: Log the raw tracker response before attempting to parse it\n5. **Handle error responses**: Check for error messages in tracker responses before assuming success\n\nThe most frequent tracker communication bug involves incorrect URL encoding of the info hash. The 20-byte SHA1 hash contains binary data that must be percent-encoded for inclusion in HTTP URLs, but many implementers use incorrect encoding methods.\n\n**Tracker Communication Debug Table:**\n\n| Symptom | Diagnostic Command | Expected Result | Common Fix |\n|---------|-------------------|-----------------|------------|\n| \"Invalid info_hash\" error | `curl -v \"tracker_url\"` with parameters | HTTP 200 with peer list | Correct URL encoding of binary info hash |\n| Empty peer list | Check `left` parameter value | Should be > 0 for incomplete downloads | Set `left` to remaining bytes, not total bytes |\n| Tracker timeouts | Network connectivity test to tracker | Successful connection | Implement proper timeout handling and retries |\n| Malformed peer data | Hex dump of peers field in response | 6-byte entries (4 bytes IP + 2 bytes port) | Handle compact peer format correctly |\n| Authentication failures | Verify announce URL from torrent | URL should match exactly | Use announce URL from torrent, not guessed URL |\n\n#### Peer Wire Protocol Debugging\n\nThe BitTorrent peer wire protocol is more complex than HTTP tracker communication, involving stateful connections, message framing, and binary protocol adherence. Peer protocol debugging requires understanding the exact message formats and state machine transitions.\n\n**Peer Protocol Debug Strategy:**\n\nThe peer protocol debugging process follows a layered approach, starting from the lowest level (TCP connection) and working up through handshakes, message framing, and application logic.\n\n**Connection Establishment Debug Steps:**\n\n1. **TCP connection verification**: Confirm that TCP connections to peers can be established successfully\n2. **Handshake exchange validation**: Verify that both sides of the handshake follow the exact 68-byte format\n3. **Protocol string matching**: Ensure the 19-byte protocol identifier matches exactly\n4. **Info hash verification**: Confirm that handshake info hashes match the torrent being downloaded\n5. **Peer ID exchange**: Validate that peer IDs are exchanged correctly and stored for connection tracking\n\n**Message Framing Debug Process:**\n\nMessage framing errors are particularly insidious because they can cause the entire connection to become unsynchronized, leading to cascading parsing failures for subsequent messages.\n\n| Framing Issue | Symptoms | Debug Approach | Solution |\n|---------------|----------|----------------|----------|\n| Length prefix errors | Messages appear corrupted or truncated | Log raw bytes of length prefix, verify network byte order | Use `binary.BigEndian` for 4-byte length prefix |\n| Partial message reads | Parser hangs or fails randomly | Implement complete message buffering before parsing | Read exact message length bytes before processing |\n| Message type confusion | Unexpected message type errors | Log message ID byte after length prefix | Verify message ID matches expected protocol values |\n| Keep-alive handling | Connection timeouts or unexpected closes | Monitor for zero-length messages | Handle keep-alive messages (length 0) without message ID |\n| Buffer boundary errors | Corruption at message boundaries | Validate buffer management between messages | Reset buffers properly between message reads |\n\n#### State Machine Debugging\n\nThe peer protocol involves a complex state machine governing when requests can be sent and received. State machine violations can cause peers to disconnect or refuse to serve data.\n\n**Peer State Machine Debug Matrix:**\n\n| Current State | Attempted Action | Expected Behavior | Debug Check |\n|---------------|------------------|-------------------|-------------|\n| `peer_choking = true` | Send request message | Should be rejected/ignored | Verify choke state before sending requests |\n| `am_interested = false` | Expect piece messages | Peer should not send data | Send interested message before expecting data |\n| `bitfield` not received | Send requests for pieces | Should fail or be ignored | Wait for bitfield after handshake |\n| Connection just established | Send requests immediately | Should fail | Complete handshake and bitfield exchange first |\n| Multiple pending requests | Connection suddenly closes | Likely protocol violation | Check request pipelining limits |\n\n### Concurrency and State Issues\n\nBitTorrent clients are inherently concurrent systems, managing multiple peer connections, piece downloads, and verification processes simultaneously. Concurrency bugs are among the most challenging to debug because they often involve race conditions that only manifest under specific timing conditions or high load.\n\n#### Race Condition Identification\n\nRace conditions in BitTorrent clients typically occur around shared data structures like piece state, peer connection management, and download progress tracking. These bugs are notoriously difficult to reproduce and debug because they depend on specific timing of concurrent operations.\n\n**Common Race Condition Patterns:**\n\n| Race Condition Type | Manifestation | Detection Method | Prevention Strategy |\n|---------------------|---------------|------------------|---------------------|\n| Piece state corruption | Same piece downloaded multiple times or verification failures | Log all piece state changes with timestamps and goroutine IDs | Use mutex protection around piece state updates |\n| Connection map corruption | Peer connections appear/disappear randomly | Monitor connection map size and detect unexpected changes | Synchronize all connection map access with read-write locks |\n| Download statistics inconsistency | Progress reporting jumps or decreases | Validate statistics consistency at regular intervals | Use atomic operations for counter updates |\n| Request duplication | Multiple requests for same block sent to different peers | Log all outgoing requests with peer identification | Coordinate block requests through central manager |\n| Verification race | Piece verification runs on partially downloaded data | Check for incomplete pieces entering verification | Ensure atomic piece completion before verification |\n\n#### Deadlock Detection and Prevention\n\nDeadlocks can occur when multiple goroutines wait for locks held by each other, typically involving the piece manager, peer connections, and shared state coordination. Deadlock detection requires understanding the lock acquisition order across different components.\n\n**Deadlock Prevention Strategy:**\n\n1. **Establish lock ordering**: Define a consistent order for acquiring multiple locks across all components\n2. **Minimize lock scope**: Hold locks for the shortest possible duration to reduce contention\n3. **Use timeouts**: Implement timeout-based lock acquisition to detect potential deadlocks\n4. **Monitor lock contention**: Log lock acquisition and release events during debugging\n5. **Separate read and write operations**: Use read-write locks to allow concurrent reads when possible\n\n#### State Synchronization Issues\n\nThe BitTorrent client maintains complex shared state across multiple concurrent operations, and synchronization failures can lead to inconsistent views of download progress, peer availability, and piece completion status.\n\n**State Synchronization Debug Approach:**\n\n| Component | Shared State | Synchronization Mechanism | Common Issues |\n|-----------|--------------|---------------------------|---------------|\n| PieceManager | Piece completion status | Read-write mutex on piece map | Pieces marked complete before verification |\n| PeerManager | Connection status and capabilities | Connection map mutex | Stale connection references |\n| Statistics | Download/upload counters | Atomic operations | Inconsistent progress reporting |\n| BitfieldOps | Available piece tracking | Bitfield-level locking | Race between bitfield updates and reads |\n| EventBus | Event distribution | Channel-based message passing | Blocked subscribers causing deadlocks |\n\n#### Memory Leak Detection\n\nLong-running BitTorrent clients can develop memory leaks through accumulated goroutines, unclosed connections, or retained data structures. Memory leak debugging requires systematic monitoring of resource usage patterns.\n\n**Memory Leak Investigation Process:**\n\n1. **Monitor goroutine count**: Use `runtime.NumGoroutine()` to detect goroutine leaks\n2. **Track connection lifecycle**: Ensure all network connections are properly closed\n3. **Validate buffer management**: Check for growing buffers that are never reset\n4. **Monitor piece data retention**: Ensure completed pieces don't retain unnecessary data\n5. **Check event subscriber cleanup**: Verify event bus subscribers are unregistered properly\n\n### Debugging Tools and Techniques\n\nEffective BitTorrent debugging requires a combination of logging strategies, network monitoring tools, and systematic testing approaches. The distributed and concurrent nature of BitTorrent makes traditional debugging approaches insufficient.\n\n#### Logging Strategy\n\nA comprehensive logging strategy is essential for BitTorrent debugging because many issues only become apparent through analysis of event sequences across multiple components and connections.\n\n**Structured Logging Framework:**\n\n| Log Level | Component | Event Types | Example Information |\n|-----------|-----------|-------------|-------------------|\n| DEBUG | Bencode Parser | Parse events, offset tracking | \"Parsing dictionary at offset 1234, found 5 keys\" |\n| INFO | Tracker Client | Announce requests/responses | \"Announce successful: 25 peers returned, interval 1800s\" |\n| INFO | Peer Manager | Connection lifecycle | \"Connected to peer 192.168.1.5:6881, capabilities: extension protocol\" |\n| INFO | Piece Manager | Piece completion | \"Piece 42 verified successfully, 847/1000 pieces complete\" |\n| WARN | Protocol Handler | Protocol violations | \"Peer 192.168.1.5 sent request while choked, ignoring\" |\n| ERROR | All Components | Error conditions | \"Failed to verify piece 15: hash mismatch, requesting from different peer\" |\n\n#### Network Traffic Analysis\n\nNetwork-level debugging provides ground truth about what data is actually being sent and received, independent of application-level interpretation.\n\n**Network Analysis Tools:**\n\n| Tool | Use Case | Command Example | Interpretation |\n|------|---------|-----------------|----------------|\n| Wireshark | Complete protocol analysis | GUI-based capture and filtering | Examine exact bytes, timing, TCP behavior |\n| tcpdump | Command-line packet capture | `tcpdump -i eth0 -s 0 host tracker.example.com` | Verify tracker communication |\n| netstat | Connection state monitoring | `netstat -an \\| grep :6881` | Check peer connection status |\n| ss | Modern connection analysis | `ss -tuln` | Monitor listening sockets and connections |\n| curl | Manual HTTP testing | `curl -v \"http://tracker/announce?info_hash=...\"` | Test tracker requests manually |\n\n#### State Inspection Techniques\n\nBitTorrent clients maintain complex internal state that changes rapidly during operation. Effective debugging requires the ability to snapshot and analyze this state at key points.\n\n**State Inspection Methods:**\n\n1. **Component state dumps**: Implement methods to export complete component state in human-readable format\n2. **Periodic state snapshots**: Capture state at regular intervals to identify trends and anomalies\n3. **Event correlation**: Link state changes to specific events across component boundaries  \n4. **Consistency validation**: Implement invariant checking to detect state corruption early\n5. **Interactive debugging interfaces**: Provide runtime access to internal state for investigation\n\n#### Test Environment Setup\n\nDebugging BitTorrent clients requires controlled test environments that can simulate various network conditions, peer behaviors, and failure scenarios.\n\n**Controlled Testing Environment Components:**\n\n| Component | Purpose | Implementation | Benefits |\n|-----------|---------|----------------|----------|\n| Mock Tracker | Simulate tracker responses | Local HTTP server with configurable responses | Test tracker error handling, peer list variations |\n| Mock Peers | Simulate peer behavior | TCP servers implementing peer protocol | Test protocol edge cases, malformed messages |\n| Network Simulation | Control network conditions | Traffic shaping, packet loss injection | Test timeout handling, connection recovery |\n| Test Torrents | Known content validation | Generated torrents with predictable data | Verify piece assembly, hash calculation |\n| Load Testing | Concurrent connection handling | Multiple simultaneous peer connections | Identify race conditions, resource leaks |\n\n#### Performance Profiling\n\nBitTorrent clients involve significant CPU usage for cryptographic operations, network I/O, and concurrent coordination. Performance profiling helps identify bottlenecks that might not cause functional failures but impact user experience.\n\n**Profiling Strategy:**\n\n1. **CPU profiling**: Identify hot spots in piece verification, protocol parsing, and coordination logic\n2. **Memory profiling**: Track allocation patterns and identify potential leaks\n3. **Goroutine profiling**: Monitor concurrent operation patterns and identify coordination bottlenecks  \n4. **Network I/O profiling**: Measure throughput and identify network-related performance issues\n5. **Lock contention analysis**: Identify synchronization bottlenecks that limit concurrency\n\n#### Systematic Bug Reproduction\n\nBitTorrent bugs often involve complex interactions between multiple components, making them difficult to reproduce reliably. Systematic reproduction techniques help isolate the root causes.\n\n**Bug Reproduction Methodology:**\n\n| Step | Approach | Tools | Documentation |\n|------|---------|-------|---------------|\n| Minimal reproduction case | Reduce to simplest failing scenario | Small test torrents, single peers | Record exact steps and environment |\n| Environment isolation | Eliminate external variables | Local network, controlled peers | Document all dependencies |\n| Timing manipulation | Control concurrent execution | Artificial delays, single-threaded mode | Identify timing-sensitive bugs |\n| Input variation | Systematically vary inputs | Different torrent files, peer behaviors | Map failure boundaries |\n| State injection | Start from known problematic states | Save/restore component state | Test specific scenarios |\n\n#### Debug Output Organization\n\nThe volume of debug information in a BitTorrent client can be overwhelming without proper organization and filtering strategies.\n\n**Debug Output Management:**\n\n1. **Component-based filtering**: Enable/disable debugging for specific components\n2. **Severity-based filtering**: Control output volume through log level selection\n3. **Context correlation**: Tag all log messages with operation context (torrent ID, peer ID, piece index)\n4. **Timeline reconstruction**: Ensure all debug output includes precise timestamps\n5. **Cross-component tracing**: Use correlation IDs to track operations across component boundaries\n\n### Implementation Guidance\n\nThis subsection provides practical debugging tools and techniques specifically tailored for Go implementation, along with complete infrastructure code for debugging support.\n\n#### Technology Recommendations Table\n\n| Debugging Aspect | Simple Option | Advanced Option |\n|------------------|---------------|-----------------|\n| Logging Framework | Standard `log` package with custom formatting | `github.com/sirupsen/logrus` or `go.uber.org/zap` |\n| Network Analysis | `tcpdump` command-line tool | Wireshark GUI with BitTorrent protocol dissectors |\n| Profiling | Built-in `go tool pprof` with `net/http/pprof` | Continuous profiling with `github.com/pyroscope-io/pyroscope` |\n| Test Environment | Manual mock servers | `github.com/jarcoal/httpmock` for HTTP, custom TCP mocks |\n| State Inspection | JSON marshal of structs | Custom debug HTTP endpoints with live state |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  cmd/\n    bittorrent-debug/\n      main.go                 ← debug CLI tool\n  internal/\n    debug/\n      logger.go              ← structured logging infrastructure\n      profiler.go            ← performance profiling utilities\n      state_inspector.go     ← runtime state inspection\n      mock_tracker.go        ← test tracker implementation\n      mock_peer.go           ← test peer implementation\n    torrent/\n      parser_debug.go        ← torrent parsing debug utilities\n    tracker/\n      client_debug.go        ← tracker communication debugging\n    peer/\n      connection_debug.go    ← peer protocol debugging\n    piece/\n      manager_debug.go       ← piece management debugging\n  test/\n    fixtures/\n      test_torrents/         ← known test torrent files\n      expected_outputs/      ← expected parsing results\n```\n\n#### Complete Debugging Infrastructure Code\n\n**Structured Logging System (`internal/debug/logger.go`):**\n\n```go\npackage debug\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n    \"runtime\"\n    \"strings\"\n    \"sync\"\n    \"time\"\n)\n\n// LogLevel represents logging severity levels\ntype LogLevel int\n\nconst (\n    DEBUG LogLevel = iota\n    INFO\n    WARN\n    ERROR\n)\n\nvar levelNames = map[LogLevel]string{\n    DEBUG: \"DEBUG\",\n    INFO:  \"INFO\",\n    WARN:  \"WARN\",\n    ERROR: \"ERROR\",\n}\n\n// ComponentLogger provides structured logging with component identification\ntype ComponentLogger struct {\n    component string\n    level     LogLevel\n    output    io.Writer\n    mutex     sync.RWMutex\n}\n\n// BitTorrentLogger manages logging across all components\ntype BitTorrentLogger struct {\n    loggers map[string]*ComponentLogger\n    mutex   sync.RWMutex\n}\n\nvar globalLogger = &BitTorrentLogger{\n    loggers: make(map[string]*ComponentLogger),\n}\n\n// NewComponentLogger creates a logger for a specific component\nfunc NewComponentLogger(component string) *ComponentLogger {\n    globalLogger.mutex.Lock()\n    defer globalLogger.mutex.Unlock()\n    \n    if logger, exists := globalLogger.loggers[component]; exists {\n        return logger\n    }\n    \n    logger := &ComponentLogger{\n        component: component,\n        level:     INFO, // Default level\n        output:    os.Stdout,\n    }\n    \n    globalLogger.loggers[component] = logger\n    return logger\n}\n\n// SetLevel configures the minimum log level for this component\nfunc (l *ComponentLogger) SetLevel(level LogLevel) {\n    l.mutex.Lock()\n    defer l.mutex.Unlock()\n    l.level = level\n}\n\n// Debug logs debug-level messages with detailed context\nfunc (l *ComponentLogger) Debug(format string, args ...interface{}) {\n    l.logf(DEBUG, format, args...)\n}\n\n// Info logs informational messages\nfunc (l *ComponentLogger) Info(format string, args ...interface{}) {\n    l.logf(INFO, format, args...)\n}\n\n// Warn logs warning messages\nfunc (l *ComponentLogger) Warn(format string, args ...interface{}) {\n    l.logf(WARN, format, args...)\n}\n\n// Error logs error messages\nfunc (l *ComponentLogger) Error(format string, args ...interface{}) {\n    l.logf(ERROR, format, args...)\n}\n\nfunc (l *ComponentLogger) logf(level LogLevel, format string, args ...interface{}) {\n    l.mutex.RLock()\n    if level < l.level {\n        l.mutex.RUnlock()\n        return\n    }\n    output := l.output\n    component := l.component\n    l.mutex.RUnlock()\n    \n    // Get caller information for debugging\n    _, file, line, ok := runtime.Caller(2)\n    var caller string\n    if ok {\n        parts := strings.Split(file, \"/\")\n        if len(parts) > 0 {\n            caller = fmt.Sprintf(\"%s:%d\", parts[len(parts)-1], line)\n        }\n    }\n    \n    timestamp := time.Now().Format(\"2006-01-02 15:04:05.000\")\n    levelName := levelNames[level]\n    \n    message := fmt.Sprintf(format, args...)\n    logLine := fmt.Sprintf(\"[%s] %s [%s] %s: %s\\n\", \n        timestamp, levelName, component, caller, message)\n    \n    fmt.Fprint(output, logLine)\n}\n\n// SetGlobalLevel sets the log level for all components\nfunc SetGlobalLevel(level LogLevel) {\n    globalLogger.mutex.Lock()\n    defer globalLogger.mutex.Unlock()\n    \n    for _, logger := range globalLogger.loggers {\n        logger.SetLevel(level)\n    }\n}\n```\n\n**State Inspector (`internal/debug/state_inspector.go`):**\n\n```go\npackage debug\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"runtime\"\n    \"sync\"\n    \"time\"\n)\n\n// StateInspector provides runtime inspection of component state\ntype StateInspector struct {\n    components map[string]StateProvider\n    mutex      sync.RWMutex\n    server     *http.Server\n}\n\n// StateProvider interface allows components to expose their state\ntype StateProvider interface {\n    GetState() interface{}\n    GetStatistics() map[string]interface{}\n}\n\n// SystemStats provides system-level debugging information\ntype SystemStats struct {\n    Goroutines    int           `json:\"goroutines\"`\n    MemoryUsage   MemoryStats   `json:\"memory\"`\n    Uptime        time.Duration `json:\"uptime\"`\n    Timestamp     time.Time     `json:\"timestamp\"`\n}\n\ntype MemoryStats struct {\n    Allocated   uint64 `json:\"allocated\"`\n    TotalAlloc  uint64 `json:\"total_alloc\"`\n    SystemMem   uint64 `json:\"system_mem\"`\n    NumGC       uint32 `json:\"num_gc\"`\n}\n\nvar globalInspector = &StateInspector{\n    components: make(map[string]StateProvider),\n}\n\nvar startTime = time.Now()\n\n// RegisterComponent adds a component for state inspection\nfunc RegisterComponent(name string, provider StateProvider) {\n    globalInspector.mutex.Lock()\n    defer globalInspector.mutex.Unlock()\n    globalInspector.components[name] = provider\n}\n\n// StartDebugServer launches HTTP server for state inspection\nfunc StartDebugServer(port int) error {\n    mux := http.NewServeMux()\n    \n    // System state endpoint\n    mux.HandleFunc(\"/debug/system\", handleSystemState)\n    \n    // Component state endpoints\n    mux.HandleFunc(\"/debug/components\", handleComponentList)\n    mux.HandleFunc(\"/debug/component/\", handleComponentState)\n    \n    // Memory and goroutine debugging\n    mux.HandleFunc(\"/debug/goroutines\", handleGoroutineDebug)\n    \n    globalInspector.server = &http.Server{\n        Addr:    fmt.Sprintf(\":%d\", port),\n        Handler: mux,\n    }\n    \n    return globalInspector.server.ListenAndServe()\n}\n\nfunc handleSystemState(w http.ResponseWriter, r *http.Request) {\n    var memStats runtime.MemStats\n    runtime.ReadMemStats(&memStats)\n    \n    stats := SystemStats{\n        Goroutines: runtime.NumGoroutine(),\n        MemoryUsage: MemoryStats{\n            Allocated:  memStats.Alloc,\n            TotalAlloc: memStats.TotalAlloc,\n            SystemMem:  memStats.Sys,\n            NumGC:      memStats.NumGC,\n        },\n        Uptime:    time.Since(startTime),\n        Timestamp: time.Now(),\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(stats)\n}\n\nfunc handleComponentList(w http.ResponseWriter, r *http.Request) {\n    globalInspector.mutex.RLock()\n    defer globalInspector.mutex.RUnlock()\n    \n    components := make([]string, 0, len(globalInspector.components))\n    for name := range globalInspector.components {\n        components = append(components, name)\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(map[string]interface{}{\n        \"components\": components,\n        \"count\":      len(components),\n    })\n}\n\nfunc handleComponentState(w http.ResponseWriter, r *http.Request) {\n    componentName := r.URL.Path[len(\"/debug/component/\"):]\n    \n    globalInspector.mutex.RLock()\n    provider, exists := globalInspector.components[componentName]\n    globalInspector.mutex.RUnlock()\n    \n    if !exists {\n        http.Error(w, \"Component not found\", http.StatusNotFound)\n        return\n    }\n    \n    state := map[string]interface{}{\n        \"component\":  componentName,\n        \"state\":      provider.GetState(),\n        \"statistics\": provider.GetStatistics(),\n        \"timestamp\":  time.Now(),\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(state)\n}\n\nfunc handleGoroutineDebug(w http.ResponseWriter, r *http.Request) {\n    // This would typically use pprof for detailed goroutine analysis\n    count := runtime.NumGoroutine()\n    \n    response := map[string]interface{}{\n        \"goroutine_count\": count,\n        \"timestamp\":       time.Now(),\n        \"warning\":         \"Use 'go tool pprof http://localhost:port/debug/pprof/goroutine' for detailed analysis\",\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(response)\n}\n```\n\n#### Core Logic Debugging Skeleton\n\n**Bencode Parser Debugging (`internal/torrent/parser_debug.go`):**\n\n```go\npackage torrent\n\n// DebugDecoder wraps the standard decoder with extensive logging\ntype DebugDecoder struct {\n    *Decoder\n    logger *debug.ComponentLogger\n}\n\n// NewDebugDecoder creates a decoder with comprehensive debugging\nfunc NewDebugDecoder(r io.Reader) *DebugDecoder {\n    return &DebugDecoder{\n        Decoder: NewDecoder(r),\n        logger:  debug.NewComponentLogger(\"BencodeParser\"),\n    }\n}\n\n// DebugDecode parses with extensive logging of parse state\nfunc (d *DebugDecoder) DebugDecode() (interface{}, error) {\n    // TODO 1: Log initial parser state (offset, buffer size)\n    // TODO 2: Call standard Decode() method\n    // TODO 3: Log final state and parsed value type\n    // TODO 4: If error occurs, log exact position and surrounding bytes\n    // TODO 5: For successful parses, validate the parsed structure\n    // Hint: Use d.logger.Debug() for detailed parse steps\n    panic(\"implement DebugDecode\")\n}\n\n// ValidateInfoHash compares calculated hash with expected value\nfunc ValidateInfoHash(metaInfo *MetaInfo, expectedHex string) error {\n    // TODO 1: Convert expected hex string to byte array\n    // TODO 2: Compare with metaInfo.InfoHash using bytes.Equal\n    // TODO 3: If mismatch, log both hashes in hex format for comparison\n    // TODO 4: Return descriptive error with both hash values\n    // Hint: Use fmt.Sprintf(\"%x\", hash) for hex formatting\n    panic(\"implement ValidateInfoHash\")\n}\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 - Torrent Parsing:**\n```bash\n# Verify Bencode parsing with debug output\ngo run cmd/debug/main.go parse test/fixtures/ubuntu.torrent\n\n# Expected output should include:\n# - All torrent metadata fields correctly extracted\n# - Info hash matching standard tools: transmission-show ubuntu.torrent\n# - Piece count calculation: total_size/piece_length (rounded up)\n# - No parsing errors or warnings\n\n# Manual verification:\ntransmission-show test/fixtures/ubuntu.torrent | grep \"Hash:\"\n# Compare with your parser output\n```\n\n**After Milestone 2 - Tracker Communication:**\n```bash\n# Test tracker communication with debug logging\ngo run cmd/debug/main.go tracker test/fixtures/ubuntu.torrent\n\n# Expected behavior:\n# - HTTP GET request logged with all parameters\n# - Successful response with peer list\n# - Compact peer format correctly decoded to IP:port pairs\n# - No URL encoding errors\n\n# Manual verification:\ncurl -v \"http://tracker-url/announce?info_hash=...\" \n# Should return bencoded response with peer list\n```\n\n**After Milestone 3 - Peer Protocol:**\n```bash\n# Test peer connections with protocol debugging\ngo run cmd/debug/main.go peer test/fixtures/ubuntu.torrent\n\n# Expected behavior:\n# - TCP connections established to multiple peers\n# - Handshake exchange completed successfully\n# - Bitfield messages received and parsed\n# - State machine transitions logged correctly\n\n# Check debug server:\ncurl http://localhost:8080/debug/component/PeerManager\n# Should show connected peers and their states\n```\n\n**After Milestone 4 - Complete Download:**\n```bash\n# Full download with comprehensive debugging\ngo run cmd/debug/main.go download test/fixtures/ubuntu.torrent output/\n\n# Expected behavior:\n# - All pieces downloaded and verified successfully\n# - No hash verification failures\n# - Multiple concurrent peer connections\n# - Final file matches expected checksum\n\n# Verify file integrity:\nsha1sum output/ubuntu-file.iso\n# Should match published hash\n```\n\n#### Debugging Tips Table\n\n| Symptom | Likely Cause | Diagnosis Command | Fix |\n|---------|--------------|------------------|-----|\n| \"Connection refused\" to peers | Firewall blocking, wrong port | `telnet peer-ip peer-port` | Check firewall, verify port from tracker |\n| Handshake timeout | Protocol mismatch, wrong info hash | Wireshark capture of handshake | Verify 68-byte format, check info hash |\n| No piece requests sent | Peer choking, not interested | Debug peer state machine | Send interested message, wait for unchoke |\n| Piece verification fails | Data corruption, wrong hash | Compare downloaded vs expected hash | Re-request piece, check hash calculation |\n| Download stalls | All peers choking | Monitor choke/unchoke messages | Implement optimistic unchoking |\n| Memory leak during download | Goroutines not cleaned up | `curl localhost:8080/debug/system` | Ensure connection cleanup on errors |\n| Race condition crashes | Concurrent access to shared state | Run with `go run -race` | Add proper mutex protection |\n| Tracker \"Invalid request\" | Missing/wrong parameters | Log complete URL before request | Check parameter encoding, completeness |\n\n\n## Future Extensions\n\n> **Milestone(s):** This section builds upon all four milestones (1-4) by outlining advanced BitTorrent features and optimizations that can be added to the core implementation, showing how the current architecture accommodates extensibility.\n\nBuilding a complete BitTorrent client following the four core milestones creates a solid foundation, but the BitTorrent ecosystem offers many advanced features that can significantly enhance functionality, performance, and user experience. This section explores how our carefully designed architecture can accommodate these extensions without requiring fundamental rewrites.\n\nThink of our current BitTorrent client as a reliable bicycle that gets you from point A to point B. The future extensions described here are like upgrading to an electric bike with GPS navigation, anti-theft systems, and performance monitoring. The core mechanics remain the same - you still pedal, steer, and brake - but the enhanced features make the journey faster, safer, and more enjoyable. Similarly, our core architecture of torrent parsing, tracker communication, peer protocols, and piece management remains intact while we layer on sophisticated enhancements.\n\nThe extensibility of our design stems from several architectural decisions made throughout the previous sections. The modular component structure with well-defined interfaces, the event bus for loose coupling between components, the shared state management system, and the pluggable error handling framework all contribute to making extensions straightforward to implement without disrupting existing functionality.\n\n### Advanced Protocol Features\n\nThe BitTorrent protocol has evolved significantly since its inception, with numerous BitTorrent Enhancement Proposals (BEPs) adding powerful features for peer discovery, security, and convenience. Our current architecture provides excellent hooks for integrating these advanced protocol features.\n\n#### Distributed Hash Table (DHT) Integration\n\nThe most significant limitation of our current tracker-based approach is the single point of failure represented by centralized trackers. **Distributed Hash Table (DHT)** technology, specifically the Kademlia-based Mainline DHT used by BitTorrent, eliminates this dependency by creating a decentralized peer discovery network.\n\nThink of DHT as transforming our library network from one that relies on a central catalog service to a system where every library maintains connections to a few neighboring libraries and can find any book by asking neighbors, who ask their neighbors, creating a web of knowledge that requires no central authority. Each peer becomes both a user and a provider of the peer discovery service.\n\nThe DHT protocol involves several key components that integrate naturally with our existing architecture:\n\n| DHT Component | Purpose | Integration Point | Data Structures |\n|---------------|---------|------------------|-----------------|\n| Node ID | 160-bit identifier for DHT participation | New field in `PeerInfo` | `NodeID [20]byte` |\n| Routing Table | Maintains k-closest nodes in each bucket | New `DHTClient` component | `RoutingTable` with buckets |\n| Query Engine | Implements find_node and get_peers queries | Extends `TrackerClient` interface | `DHTQuery` and `DHTResponse` types |\n| Announce Protocol | Announces presence for info hashes | Parallel to HTTP announces | `DHTAnnounce` message type |\n\n> **Decision: DHT as Tracker Fallback**\n> - **Context**: Our current design relies solely on HTTP/UDP trackers which can become unavailable or censored\n> - **Options Considered**: \n>   1. Replace tracker system entirely with DHT\n>   2. Implement DHT as primary with tracker fallback  \n>   3. Implement DHT as tracker fallback with gradual promotion\n> - **Decision**: Implement DHT as tracker fallback that can be promoted to primary\n> - **Rationale**: This approach maintains backward compatibility while providing resilience, and allows users to choose their preferred discovery method\n> - **Consequences**: Requires dual peer discovery pipelines but provides maximum flexibility and fault tolerance\n\nThe DHT integration extends our existing `TrackerClient` interface by implementing a `DHTClient` that conforms to the same announce/response pattern. This allows the `PeerManager` to treat DHT and HTTP trackers uniformly, trying DHT when HTTP trackers fail or supplementing HTTP results with DHT peers for better swarm connectivity.\n\nThe technical implementation involves UDP message handling for the DHT protocol, maintaining a routing table of nearby nodes, and implementing the iterative query algorithm that contacts progressively closer nodes until finding peers for a specific info hash. The routing table requires periodic maintenance to remove stale nodes and discover new ones, which integrates well with our existing event bus system for coordinating background maintenance tasks.\n\n#### Magnet Link Support\n\n**Magnet links** represent a paradigm shift from torrent files to pure metadata URLs that enable instant sharing without distributing actual torrent files. Think of magnet links as GPS coordinates that lead you to a treasure location - instead of carrying a detailed treasure map (torrent file), you have just enough information to find other treasure hunters who can share their maps with you.\n\nA typical magnet link contains:\n- **Info hash**: The 20-byte SHA1 identifier for the torrent\n- **Display name**: Human-readable file or torrent name  \n- **Tracker URLs**: Optional list of backup trackers\n- **File size**: Optional hint about total download size\n\n| Magnet Component | Format | Purpose | Integration |\n|------------------|--------|---------|-------------|\n| Info Hash | `xt=urn:btih:[40-char-hex]` | Unique torrent identifier | Directly usable by DHT queries |\n| Display Name | `dn=[url-encoded-name]` | User interface display | Temporary `MetaInfo.Info.Name` |\n| Trackers | `tr=[url-encoded-tracker]` | Fallback peer discovery | Added to `MetaInfo.AnnounceList` |\n| Exact Length | `xl=[byte-count]` | Progress tracking hint | Temporary `MetaInfo.Info.Length` |\n\nThe magnet link workflow requires significant extensions to our torrent parsing pipeline. Instead of starting with a complete `MetaInfo` structure parsed from a torrent file, magnet links provide only partial metadata. Our client must:\n\n1. **Parse the magnet URL** to extract the info hash and optional metadata\n2. **Create a skeleton MetaInfo** with the known information and placeholder values\n3. **Query DHT and trackers** using the info hash to find peers\n4. **Request metadata from peers** using the Extension Protocol (BEP 9)\n5. **Reconstruct the complete MetaInfo** once metadata is received from peers\n6. **Validate the reconstructed info hash** matches the original magnet link\n7. **Proceed with normal download** using the complete metadata\n\nThis workflow integrates naturally with our existing architecture by extending the `ParseFromFile` function to also accept magnet URLs, creating a new `MetadataFetcher` component that requests missing information from peers, and using the event bus to coordinate the transition from partial to complete metadata.\n\n#### Protocol Encryption and Obfuscation\n\nNetwork-level protocol encryption addresses ISP throttling and deep packet inspection by making BitTorrent traffic appear as generic encrypted data rather than recognizable P2P patterns. **Message Stream Encryption (MSE)**, defined in BEP 3, provides this capability through a negotiated encryption layer.\n\nThink of protocol encryption as having a conversation in a crowded restaurant where network monitors represent eavesdroppers. Without encryption, your BitTorrent conversation is clearly audible to anyone listening. With encryption, your conversation appears as meaningless whispers that reveal neither the topic (file being shared) nor the participants (peer IP addresses in piece requests).\n\nThe encryption negotiation occurs during the connection handshake phase, making it a natural extension to our existing `Connection.PerformHandshake()` method:\n\n| Encryption Phase | Purpose | Data Exchanged | Integration Point |\n|------------------|---------|----------------|------------------|\n| Diffie-Hellman | Establish shared secret | Public keys (96-768 bytes) | Before protocol handshake |\n| Method Selection | Choose encryption level | Plaintext/RC4/AES preference | Extends handshake options |\n| Verification | Confirm successful setup | Encrypted hash verification | After key establishment |\n| Stream Mode | Ongoing message protection | All subsequent messages | Wraps `MessageFramer` |\n\nThe implementation requires cryptographic libraries for Diffie-Hellman key exchange and stream ciphers, but integrates cleanly by creating an `EncryptedConnection` wrapper around our existing `Connection` type. The `MessageFramer` operates identically but reads/writes through the encryption layer instead of directly to the TCP connection.\n\n#### Multi-Tracker and Tracker Tiers\n\nModern torrents often specify multiple trackers organized in tiers for redundancy and load balancing. **Multi-tracker support** ensures download success even when some trackers are unavailable and distributes the announce load across multiple servers.\n\nThink of multi-tracker support as having multiple weather services for planning outdoor activities. Instead of relying on a single meteorologist who might be unavailable or incorrect, you consult several services simultaneously and use the best available information from all sources combined.\n\nThe tracker tier system works hierarchically:\n\n| Tier Level | Behavior | Failure Handling | Success Criteria |\n|------------|----------|------------------|------------------|\n| Tier 0 (Primary) | Try all trackers simultaneously | Move to Tier 1 if all fail | Any tracker responds successfully |\n| Tier 1+ (Backup) | Try after primary tier fails | Move to next tier if all fail | Continue with any working tracker |\n| Cross-Tier | Periodically retry failed tiers | Promote working trackers | Maintain best available service |\n\nThis extends our `TrackerClient` to manage multiple tracker instances, implementing a `TrackerPool` that coordinates announces across tiers and aggregates peer lists from multiple sources. The event bus facilitates coordination between tracker instances, allowing successful responses from any tracker to update the global peer list while failed trackers are relegated to lower priority.\n\n### Performance Optimizations\n\nWhile our core implementation focuses on correctness and protocol compliance, real-world BitTorrent usage demands sophisticated optimizations for bandwidth efficiency, connection management, and intelligent piece selection that goes far beyond basic rarest-first algorithms.\n\n#### Advanced Piece Selection Strategies\n\nThe **rarest-first algorithm** implemented in Milestone 4 provides a solid foundation, but production BitTorrent clients employ much more sophisticated piece selection that adapts to network conditions, peer behavior, and download progress phases.\n\nThink of advanced piece selection as evolving from a simple \"buy the least common baseball card first\" strategy to a sophisticated trading algorithm that considers card condition, trader reliability, geographic proximity, and market trends. The goal remains completing your collection, but the strategy adapts to complex real-world conditions.\n\nAdvanced selection strategies include multiple complementary algorithms:\n\n| Selection Strategy | Use Case | Algorithm | Benefits |\n|-------------------|----------|-----------|----------|\n| Random First Piece | Cold start with no pieces | Random selection from available | Immediate participation in swarm |\n| Strict Priority | Important files first | User-defined file ordering | Critical content downloaded first |\n| Availability-Based | Rare piece prioritization | Enhanced rarest-first with scoring | Better swarm health maintenance |\n| Locality-Aware | Network topology optimization | Prefer peers with low latency | Reduced bandwidth costs |\n| Completion Clustering | Sequential reading support | Group adjacent pieces | Enables streaming playback |\n\nThe implementation extends our existing `PieceSelector` with a strategy pattern that dynamically chooses algorithms based on download state:\n\n```\nDownload Phase → Strategy Selection:\n- Bootstrap (0-5% complete): Random first piece to join swarm quickly  \n- Ramp-up (5-90% complete): Availability-based rarest-first for efficiency\n- Endgame (90-100% complete): Multi-source requesting for final pieces\n- Streaming mode: Completion clustering for sequential piece availability\n```\n\n**Locality-aware selection** optimizes for network topology by preferring peers that are geographically or topologically close. This reduces internet transit costs and improves download speeds by utilizing high-bandwidth local connections. The implementation maintains peer latency statistics and factors proximity into piece assignment decisions.\n\n**Completion clustering** groups piece requests to enable streaming playback of media files. Instead of downloading pieces purely by rarity, the algorithm identifies the current playback position and ensures a buffer of sequential pieces ahead of the playback cursor. This enables video streaming while the file is still downloading.\n\n#### Bandwidth Management and Traffic Shaping\n\nEffective bandwidth management ensures BitTorrent activity doesn't overwhelm network connections while maximizing throughput within specified limits. **Adaptive bandwidth allocation** monitors network conditions and adjusts transfer rates dynamically.\n\nThink of bandwidth management as managing water flow through a complex irrigation system. You have a fixed amount of water (bandwidth) that must be distributed among many fields (connections) while ensuring no field is flooded (connection overwhelmed) or drought-stricken (connection starved), and the distribution must adapt to changing weather conditions (network congestion).\n\nThe bandwidth management system operates at multiple levels:\n\n| Management Level | Scope | Controls | Adaptation Triggers |\n|------------------|-------|----------|---------------------|\n| Global Limits | Entire client | Total upload/download caps | User configuration |\n| Per-Torrent | Individual torrents | Torrent priority weighting | Progress-based adjustment |\n| Per-Peer | Individual connections | Fair share allocation | Peer performance metrics |\n| Congestion Control | Network conditions | Dynamic rate adjustment | RTT and loss detection |\n\n**Token bucket algorithms** provide smooth rate limiting by allowing brief bursts above the average rate while maintaining long-term compliance with bandwidth limits. Each connection receives tokens at a controlled rate and consumes tokens for data transfer, preventing sustained overconsumption while accommodating natural traffic patterns.\n\n**Congestion detection** monitors round-trip times and packet loss indicators to detect network congestion early and reduce transmission rates before connections timeout. This maintains higher overall throughput by avoiding the dramatic rate reductions that occur when TCP connections detect congestion through timeouts.\n\nThe implementation creates a `BandwidthManager` component that integrates with our existing `Connection` objects by intercepting read/write operations and applying rate limiting. The manager maintains token buckets per connection and globally, coordinating through the event bus to redistribute unused bandwidth allocation from idle connections to active transfers.\n\n#### Connection Optimization and Pooling\n\nEfficient connection management maximizes throughput while minimizing resource consumption through intelligent peer selection, connection reuse, and protocol optimizations.\n\n**Connection pooling** maintains pools of established connections that can be quickly reassigned between torrents sharing the same peers. Think of this as maintaining relationships with reliable trading partners across multiple card collections - instead of introducing yourself repeatedly for each new collection, you leverage existing trust relationships for faster transactions.\n\nThe connection optimization strategies include:\n\n| Optimization | Mechanism | Benefits | Implementation |\n|--------------|-----------|----------|----------------|\n| Keep-Alive | Maintain idle connections | Reduced handshake overhead | Extended connection timeouts |\n| Multiplexing | Multiple torrents per connection | Better resource utilization | Protocol extension negotiation |\n| Fast Extensions | Optimized message flow | Reduced round-trip delays | Fast peer and allowed fast messages |\n| Pipelining Tuning | Dynamic pipeline depth | Optimal throughput/latency | RTT-based pipeline adjustment |\n\n**Fast Extension Protocol** (BEP 6) reduces the time from connection establishment to active data transfer by allowing peers to immediately request pieces without waiting for complete bitfield exchange. This is particularly beneficial for peers that reconnect frequently or have high-latency connections.\n\n**Dynamic pipeline tuning** adjusts the number of outstanding block requests based on measured round-trip times and bandwidth-delay product. High-latency connections benefit from deeper pipelines that keep the network path saturated, while low-latency connections require shallower pipelines to maintain responsiveness.\n\nThe optimization integrates with our existing `Connection` and `PeerManager` by adding connection lifecycle management, peer performance tracking, and protocol capability negotiation. The event bus coordinates connection reallocation between torrents and communicates performance metrics for optimization decisions.\n\n### User Interface Integration\n\nOur carefully designed core architecture provides excellent separation between the BitTorrent protocol engine and user interface concerns, enabling integration with diverse interface paradigms from command-line tools to sophisticated graphical applications.\n\n#### API Design for GUI Integration\n\nThe key to successful GUI integration lies in designing clean APIs that expose BitTorrent functionality through well-defined interfaces while hiding protocol complexity from interface developers.\n\nThink of the API design as creating a car dashboard for BitTorrent - the dashboard shows speed, fuel level, and engine temperature without requiring the driver to understand internal combustion, fuel injection timing, or cooling system pressure. Similarly, GUI developers need download progress, peer counts, and transfer rates without needing to understand Bencode parsing, piece verification, or message framing protocols.\n\nThe API architecture follows a layered approach:\n\n| API Layer | Purpose | Interface Style | Data Format |\n|-----------|---------|----------------|-------------|\n| Core Engine | Protocol implementation | Internal Go interfaces | Native Go types |\n| Service Layer | Business logic abstraction | Method calls with callbacks | Structured events |\n| Transport Layer | External communication | REST/gRPC/WebSockets | JSON/Protocol Buffers |\n| Client SDKs | Language-specific bindings | Native language idioms | Language-native types |\n\n**Event-driven architecture** provides the foundation for responsive user interfaces by exposing BitTorrent state changes through structured events rather than requiring interfaces to poll for status updates. Our existing event bus naturally extends to external consumers:\n\n```\nInternal Event → API Event Translation:\n- EventPieceCompleted → {type: \"progress\", torrent: \"abc123\", percent: 45.2}\n- EventPeerConnected → {type: \"peer_update\", torrent: \"abc123\", peers: 12}  \n- EventDownloadComplete → {type: \"complete\", torrent: \"abc123\", path: \"/downloads/file.mp4\"}\n```\n\n**REST API design** provides HTTP-based access for web interfaces and cross-platform compatibility. The API follows RESTful principles while accommodating BitTorrent-specific operations:\n\n| Endpoint | Method | Purpose | Response |\n|----------|---------|---------|----------|\n| `/torrents` | GET | List all active torrents | Torrent summary array |\n| `/torrents` | POST | Add new torrent | Created torrent details |\n| `/torrents/{id}` | GET | Detailed torrent status | Complete torrent state |\n| `/torrents/{id}/pause` | POST | Pause/resume torrent | Operation result |\n| `/torrents/{id}/files` | GET | File list and priorities | File details array |\n| `/events` | WebSocket | Real-time updates | Event stream |\n\n#### Real-time Status Updates\n\nModern BitTorrent interfaces require real-time updates for download progress, peer connectivity, and transfer statistics. **WebSocket-based event streaming** provides efficient real-time communication without the overhead of continuous HTTP polling.\n\nThink of real-time updates as the difference between checking your mailbox every few minutes versus having a notification system that immediately alerts you when mail arrives. WebSocket connections maintain persistent communication channels that deliver updates instantly as they occur within the BitTorrent engine.\n\nThe real-time update system streams multiple categories of information:\n\n| Update Category | Frequency | Data Elements | Use Cases |\n|----------------|-----------|---------------|-----------|\n| Progress Updates | Per piece completion | Percentage, ETA, speed | Progress bars, statistics |\n| Peer Information | Connection changes | Count, locations, quality | Network visualization |\n| Transfer Metrics | Every few seconds | Rates, totals, ratios | Performance monitoring |\n| System Events | As they occur | Errors, completions, alerts | User notifications |\n\n**Update aggregation and throttling** prevents overwhelming clients with excessive messages during high-activity periods. The system batches related updates and applies rate limiting to maintain responsive interfaces without message flooding:\n\n```\nAggregation Strategy:\n- Progress updates: Maximum once per second per torrent\n- Peer updates: Batch connection changes every 5 seconds  \n- Transfer metrics: Smooth using exponential moving averages\n- Critical events: Send immediately without throttling\n```\n\nThe implementation extends our event bus with external subscription capabilities, WebSocket connection management, and update aggregation logic. The system maintains separate update channels for different client types, allowing mobile apps to receive minimal updates while desktop applications get comprehensive information.\n\n#### Web-based Dashboard Implementation\n\nA **web-based dashboard** provides universal access to BitTorrent functionality through standard web browsers, eliminating the need for platform-specific client installation while providing rich interactive capabilities.\n\nThink of the web dashboard as transforming BitTorrent from a desktop application into a web service similar to how email evolved from desktop clients to Gmail - the core functionality remains the same, but web access provides universal availability, easy updates, and consistent cross-platform experience.\n\nThe web dashboard architecture separates concerns cleanly:\n\n| Component | Technology | Responsibility | Integration |\n|-----------|------------|----------------|-------------|\n| Backend API | Go HTTP server | Protocol engine interface | Wraps our core components |\n| Frontend SPA | React/Vue/Angular | User interface logic | Consumes REST API |\n| Real-time Updates | WebSockets | Live data streaming | Event bus integration |\n| Authentication | JWT/OAuth | Access control | Optional security layer |\n\n**Single Page Application (SPA) design** provides responsive user experience through client-side rendering and AJAX communication. The SPA maintains application state locally and synchronizes with the BitTorrent engine through API calls and WebSocket events.\n\n**Responsive design principles** ensure the dashboard works effectively across device sizes from smartphones to desktop monitors. The interface adapts layout, information density, and interaction patterns based on screen size and input capabilities.\n\nKey dashboard features include:\n\n- **Torrent management**: Add, remove, pause, and prioritize torrents\n- **Progress monitoring**: Real-time download progress with speed charts\n- **Peer visualization**: Geographic and network maps of peer connections  \n- **File management**: Individual file priorities and selective downloading\n- **Statistics dashboard**: Historical transfer rates and ratio tracking\n- **Settings configuration**: Bandwidth limits, port configuration, and preferences\n\nThe web dashboard integrates with our core architecture by running the BitTorrent engine as a background service with HTTP API endpoints. The separation allows the protocol engine to operate independently while providing multiple interface options - web dashboard, desktop GUI, mobile app, or command-line interface - all accessing the same underlying functionality.\n\n**Security considerations** for web interfaces include CSRF protection, input validation, and optional authentication systems. Since BitTorrent clients often run on local networks, the security model balances ease of use with protection against unauthorized access.\n\nThe implementation creates a new `cmd/web-server/` directory containing the HTTP server, API handlers, and web assets. The server embeds the frontend assets using Go's embed functionality for single-binary deployment while supporting development mode with external asset serving.\n\n> **Key Design Insight**: The extensive use of interfaces and event-driven architecture in our core implementation makes these extensions possible without fundamental architectural changes. Each extension builds upon existing abstractions rather than requiring rewrites, demonstrating the value of thoughtful initial design.\n\nThese future extensions transform our functional BitTorrent client into a production-ready system capable of competing with commercial clients. The extensions maintain the educational value of the core implementation while showcasing how proper architecture enables sophisticated functionality through incremental enhancement rather than replacement.\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing the advanced features described above, focusing on architectural integration points and technology choices that build upon our existing Go-based BitTorrent client.\n\n#### Technology Recommendations\n\n| Extension Category | Simple Approach | Advanced Approach |\n|--------------------|----------------|-------------------|\n| DHT Implementation | Basic Kademlia with UDP sockets | Full BEP 5 with routing table optimization |\n| Magnet Link Parsing | Regular expressions + URL parsing | Dedicated parser with validation |\n| Protocol Encryption | RC4 stream cipher | AES with multiple cipher support |\n| Web API | Standard library HTTP + JSON | Gin/Echo framework + Protocol Buffers |\n| Real-time Updates | Server-Sent Events | WebSocket with message queues |\n| Frontend Framework | Vanilla JavaScript + HTMX | React/Vue with TypeScript |\n\n#### Recommended Project Structure\n\nThe extensions integrate into our existing project structure while maintaining clear separation of concerns:\n\n```\nproject-root/\n  cmd/\n    torrent-client/main.go    ← original CLI client\n    web-server/main.go        ← new web dashboard server\n  internal/\n    torrent/                  ← core components (unchanged)\n    tracker/                  ← existing tracker client\n    peer/                     ← existing peer protocol\n    piece/                    ← existing piece management\n    dht/                      ← new DHT implementation\n      client.go\n      routing_table.go\n      protocol.go\n    magnet/                   ← new magnet link support\n      parser.go\n      metadata_fetcher.go\n    encryption/               ← new protocol encryption\n      mse.go\n      cipher.go\n    api/                      ← new web API\n      handlers.go\n      websocket.go\n      models.go\n    dashboard/                ← new web frontend\n      static/\n      templates/\n  web/                        ← frontend assets\n    src/\n    dist/\n  pkg/\n    extensions/               ← reusable extension interfaces\n```\n\n#### DHT Implementation Starter Code\n\nThe DHT implementation extends our existing tracker interface pattern:\n\n```go\n// Package dht implements Distributed Hash Table peer discovery\npackage dht\n\nimport (\n    \"context\"\n    \"net\"\n    \"time\"\n    \"your-project/internal/tracker\"\n)\n\n// Client implements tracker.Client interface for DHT-based peer discovery\ntype Client struct {\n    nodeID     [20]byte\n    conn       *net.UDPConn\n    routingTable *RoutingTable\n    queries    map[string]*PendingQuery\n    eventBus   *EventBus\n    ctx        context.Context\n    cancel     context.CancelFunc\n}\n\n// RoutingTable maintains k-closest nodes for DHT queries\ntype RoutingTable struct {\n    nodeID  [20]byte\n    buckets []Bucket\n    mutex   sync.RWMutex\n}\n\n// Bucket contains up to K nodes with similar node IDs\ntype Bucket struct {\n    nodes     []NodeInfo\n    lastSeen  time.Time\n    mutex     sync.RWMutex\n}\n\n// NodeInfo represents a DHT node\ntype NodeInfo struct {\n    ID       [20]byte\n    Addr     *net.UDPAddr\n    LastSeen time.Time\n}\n\n// NewDHTClient creates a DHT client that implements tracker.Client interface\nfunc NewDHTClient(port int) (*Client, error) {\n    // TODO: Initialize UDP socket on specified port\n    // TODO: Generate random 160-bit node ID\n    // TODO: Create routing table with 160 buckets\n    // TODO: Start maintenance goroutines for routing table\n    // TODO: Bootstrap from well-known DHT nodes\n    return nil, nil\n}\n\n// Announce implements tracker.Client.Announce for DHT peer discovery\nfunc (c *Client) Announce(ctx context.Context, req tracker.AnnounceRequest) (*tracker.AnnounceResponse, error) {\n    // TODO: Perform get_peers query for req.InfoHash\n    // TODO: If no peers found, perform announce_peer to store our info\n    // TODO: Aggregate peers from all responding nodes\n    // TODO: Return tracker.AnnounceResponse with discovered peers\n    // Hint: Use iterative deepening to find closest nodes\n    return nil, nil\n}\n```\n\n#### Magnet Link Support Implementation\n\nMagnet link support extends our torrent parsing pipeline:\n\n```go\n// Package magnet handles magnet link parsing and metadata fetching\npackage magnet\n\nimport (\n    \"context\"\n    \"net/url\"\n    \"your-project/internal/torrent\"\n    \"your-project/internal/peer\"\n)\n\n// MagnetLink represents parsed magnet URI components\ntype MagnetLink struct {\n    InfoHash    [20]byte\n    DisplayName string\n    Trackers    []string\n    ExactLength int64\n}\n\n// MetadataFetcher retrieves missing torrent metadata from peers\ntype MetadataFetcher struct {\n    infoHash     [20]byte\n    peerManager  *peer.Manager\n    eventBus     *EventBus\n    ctx          context.Context\n}\n\n// ParseMagnetLink extracts components from magnet URI\nfunc ParseMagnetLink(magnetURI string) (*MagnetLink, error) {\n    // TODO: Parse URL and validate magnet: scheme\n    // TODO: Extract xt parameter and decode info hash\n    // TODO: Extract dn parameter for display name\n    // TODO: Extract tr parameters for tracker URLs\n    // TODO: Extract xl parameter for exact length\n    // Hint: Use net/url.ParseQuery for parameter extraction\n    return nil, nil\n}\n\n// FetchMetadata retrieves complete torrent metadata from peers\nfunc (f *MetadataFetcher) FetchMetadata() (*torrent.MetaInfo, error) {\n    // TODO: Connect to peers using DHT/tracker discovery\n    // TODO: Send metadata extension handshake (BEP 9)\n    // TODO: Request metadata pieces from multiple peers\n    // TODO: Verify metadata integrity against info hash\n    // TODO: Construct complete MetaInfo structure\n    // Hint: Use Extension Protocol with ut_metadata message type\n    return nil, nil\n}\n```\n\n#### Web API Infrastructure\n\nThe web API provides HTTP and WebSocket endpoints for external client integration:\n\n```go\n// Package api provides HTTP API for external client integration\npackage api\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n    \"github.com/gorilla/websocket\"\n    \"your-project/internal/coordination\"\n)\n\n// Server provides HTTP API and WebSocket endpoints\ntype Server struct {\n    client    *Client\n    eventBus  *EventBus\n    upgrader  websocket.Upgrader\n    wsClients map[*websocket.Conn]bool\n    mutex     sync.RWMutex\n}\n\n// TorrentStatus represents API torrent information\ntype TorrentStatus struct {\n    InfoHash     string  `json:\"info_hash\"`\n    Name         string  `json:\"name\"`\n    Size         int64   `json:\"size\"`\n    Downloaded   int64   `json:\"downloaded\"`\n    Uploaded     int64   `json:\"uploaded\"`\n    Progress     float64 `json:\"progress\"`\n    DownloadRate float64 `json:\"download_rate\"`\n    UploadRate   float64 `json:\"upload_rate\"`\n    Peers        int     `json:\"peers\"`\n    Status       string  `json:\"status\"`\n}\n\n// NewAPIServer creates HTTP server with REST and WebSocket endpoints\nfunc NewAPIServer(client *Client, port int) *Server {\n    // TODO: Initialize HTTP server with CORS middleware\n    // TODO: Register REST endpoint handlers\n    // TODO: Configure WebSocket upgrader\n    // TODO: Subscribe to client event bus\n    // TODO: Start WebSocket broadcast goroutine\n    return nil\n}\n\n// HandleTorrents provides GET /torrents endpoint\nfunc (s *Server) HandleTorrents(w http.ResponseWriter, r *http.Request) {\n    // TODO: Collect status from all active torrents\n    // TODO: Transform internal state to API format\n    // TODO: Return JSON array of torrent status\n    // Hint: Use json.NewEncoder for response formatting\n}\n\n// HandleWebSocket upgrades HTTP to WebSocket for real-time updates\nfunc (s *Server) HandleWebSocket(w http.ResponseWriter, r *http.Request) {\n    // TODO: Upgrade HTTP connection to WebSocket\n    // TODO: Register client for event broadcasts\n    // TODO: Handle client disconnection cleanup\n    // TODO: Send periodic keep-alive pings\n    // Hint: Use gorilla/websocket for protocol handling\n}\n```\n\n#### Milestone Checkpoints\n\n**DHT Integration Checkpoint:**\nAfter implementing basic DHT support, verify functionality:\n- Start client with DHT enabled: `./torrent-client --enable-dht example.torrent`\n- Check logs for DHT bootstrap messages and routing table population\n- Verify peer discovery works without HTTP trackers\n- Expected: \"DHT discovered 15 peers for torrent\" log messages\n\n**Magnet Link Checkpoint:**  \nAfter implementing magnet link parsing and metadata fetching:\n- Add magnet link: `./torrent-client \"magnet:?xt=urn:btih:abcd1234...\"`\n- Verify metadata fetching from peers: watch for \"Fetching metadata from peer\" logs\n- Check that download proceeds normally after metadata retrieval\n- Expected: Complete download from magnet link without original torrent file\n\n**Web API Checkpoint:**\nAfter implementing HTTP API and WebSocket updates:\n- Start web server: `./web-server --port 8080`\n- Test REST endpoints: `curl http://localhost:8080/torrents`\n- Connect WebSocket client and verify real-time updates\n- Expected: JSON responses and live progress updates via WebSocket\n\n#### Performance Testing and Optimization\n\nAdvanced features require performance validation to ensure they enhance rather than degrade the client experience:\n\n| Feature | Performance Metric | Testing Method | Target |\n|---------|-------------------|----------------|--------|\n| DHT Integration | Query response time | Measure average get_peers latency | < 2 seconds |\n| Magnet Links | Metadata fetch time | Time from magnet to first piece | < 30 seconds |\n| API Throughput | Requests per second | HTTP load testing with concurrent clients | > 100 RPS |\n| WebSocket Updates | Message latency | Measure event to client delivery time | < 100ms |\n\nUse Go's built-in benchmarking for performance testing:\n\n```go\nfunc BenchmarkDHTQuery(b *testing.B) {\n    client := setupTestDHTClient()\n    infoHash := [20]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}\n    \n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        peers, err := client.FindPeers(infoHash)\n        if err != nil {\n            b.Fatal(err)\n        }\n        if len(peers) == 0 {\n            b.Error(\"No peers found\")\n        }\n    }\n}\n```\n\nThe future extensions described in this section demonstrate how thoughtful architectural design enables sophisticated functionality through incremental enhancement. Each extension builds upon existing interfaces and patterns, proving that well-designed systems can evolve gracefully to meet new requirements without fundamental rewrites.\n\n\n## Glossary\n\n> **Milestone(s):** This glossary supports all milestones (1-4) by providing comprehensive definitions of BitTorrent-specific terms, protocols, and technical concepts used throughout the implementation.\n\nThis glossary serves as a comprehensive reference for all BitTorrent-specific terminology, protocol concepts, and technical terms used throughout the design document. Understanding these terms is essential for implementing a correct BitTorrent client, as the protocol has many domain-specific concepts that differ from general networking or file transfer protocols.\n\nThe terms are organized alphabetically within conceptual categories to help developers quickly locate definitions while working on specific components. Each definition includes not only the meaning but also the context in which the term is used and its relationship to other BitTorrent concepts.\n\n### BitTorrent Protocol Core Concepts\n\n**announce**: An HTTP request sent by a BitTorrent client to a tracker server to report the client's current status (uploaded, downloaded, left) and request a list of other peers sharing the same torrent. The announce request includes the info hash, peer ID, port number, and progress statistics. Announces are sent periodically at intervals specified by the tracker, typically every 30 minutes, and also when the client starts downloading, completes downloading, or stops.\n\n**bencode**: A binary encoding format used exclusively by BitTorrent for serializing structured data in torrent files and some protocol messages. Bencode supports four data types: byte strings (length:content), integers (i<number>e), lists (l<items>e), and dictionaries (d<key><value>e). Unlike JSON, bencode preserves exact byte representation, which is crucial for calculating consistent info hashes across different implementations.\n\n**bitfield**: A compact bitmap data structure where each bit represents whether a peer has a specific piece of the torrent. The bitfield is typically sent immediately after the handshake to inform the remote peer about piece availability. Bitfields allow efficient communication of piece availability using minimal bandwidth - for a torrent with 1000 pieces, the bitfield requires only 125 bytes compared to 4000 bytes if piece numbers were sent individually.\n\n**block**: A 16KB (16,384 byte) subdivision of pieces used as the unit of network transfer between peers. While pieces are the unit of verification (each has a SHA-1 hash), blocks are the unit of network requests to optimize pipeline efficiency and reduce memory usage. A typical piece of 256KB contains 16 blocks. Peers request specific blocks within pieces rather than entire pieces to enable concurrent downloads from multiple peers.\n\n**choking**: A flow control mechanism where a peer refuses to upload data to another peer, even if that peer is interested in downloading. Choking prevents peers from being overwhelmed by too many simultaneous upload requests and implements BitTorrent's reciprocal sharing incentive - peers typically unchoke others who are uploading to them. The choking state is communicated via choke/unchoke messages in the peer wire protocol.\n\n**compact peer format**: A space-efficient binary encoding for peer information in tracker responses, where each peer is represented as 6 bytes: 4 bytes for IPv4 address and 2 bytes for port number in network byte order. This format reduces tracker response size compared to the dictionary format and is now the standard format used by most trackers and clients.\n\n**endgame mode**: An aggressive downloading strategy activated when only a few pieces remain to complete a torrent. In endgame mode, the client requests all remaining blocks from all available peers simultaneously to avoid stalling on slow peers. Once a block is received from any peer, requests to other peers for that block are canceled. This prevents the common scenario where the last few percent of a download becomes very slow.\n\n**handshake**: The initial 68-byte message exchanged between BitTorrent peers to establish a connection. The handshake contains the protocol string (\"BitTorrent protocol\"), info hash of the torrent, and the sender's peer ID. Both peers must send handshakes, and each must verify that the remote peer's info hash matches the expected torrent. The handshake serves as authentication that both peers are participating in the same torrent swarm.\n\n**info hash**: A 20-byte SHA-1 cryptographic hash of the bencoded info dictionary from a torrent file. The info hash serves as the unique identifier for a torrent across the BitTorrent network - all peers sharing the same torrent will have identical info hashes. The info hash is used in tracker announces, peer handshakes, and DHT operations. Calculating the info hash correctly requires hashing the exact bencoded bytes of the info dictionary, not a re-encoded version.\n\n**message framing**: The protocol mechanism for parsing variable-length messages from a TCP byte stream. BitTorrent messages use a length-prefix framing format: 4 bytes for message length in network byte order, followed by 1 byte for message type, followed by the message payload. Proper message framing prevents protocol desynchronization and enables reliable parsing of message boundaries in the TCP stream.\n\n**peer**: An individual computer or BitTorrent client participating in the sharing of a specific torrent. Peers can be in various states: seeders (have complete file), leechers (downloading), or partial seeders (have some pieces). Each peer is identified by a unique peer ID and can simultaneously connect to multiple other peers to exchange pieces. The collection of all peers sharing a torrent is called a swarm.\n\n**piece**: A fixed-size chunk of the torrent's data that serves as the unit of verification and availability tracking. Each piece has a SHA-1 hash specified in the torrent metadata, allowing peers to verify data integrity after downloading. Piece sizes are typically powers of 2 (64KB, 128KB, 256KB, 512KB) and are chosen to balance verification granularity with metadata overhead. Pieces are subdivided into 16KB blocks for network transfer.\n\n**pipeline**: The practice of maintaining multiple outstanding block requests to a peer simultaneously, rather than waiting for each request to complete before sending the next. Pipelining dramatically improves download throughput by keeping the network connection saturated and reducing the impact of network round-trip time. Most clients maintain 5-10 outstanding requests per peer, though the optimal depth depends on network conditions.\n\n**rarest-first**: A piece selection algorithm that prioritizes downloading pieces that are held by the fewest number of connected peers. This strategy increases the overall availability of pieces in the swarm by ensuring that rare pieces are duplicated quickly, reducing the risk of pieces becoming unavailable if peers leave. Rarest-first is crucial for swarm health but is typically disabled for the first few pieces to enable quick startup.\n\n**seeding**: The process of uploading complete pieces to other peers after finishing the download. Seeders are essential for torrent health as they ensure availability of all pieces. The seeding process involves responding to piece requests from other peers by reading data from the completed file and sending it via piece messages. Many BitTorrent clients implement seeding ratios to encourage users to seed for extended periods.\n\n**swarm**: The complete collection of peers participating in the sharing of a specific torrent, identified by the same info hash. A healthy swarm contains multiple seeders and maintains good piece availability across all participants. Swarm dynamics involve peers joining (downloading), completing (becoming seeders), and leaving, with the tracker coordinating peer discovery within the swarm.\n\n**tracker**: A server that maintains lists of peers participating in torrents and coordinates peer discovery. Trackers do not store or transfer file data - they only facilitate peer connections by providing lists of active peers for each torrent. Clients communicate with trackers via HTTP announce requests at regular intervals to report status and discover new peers. Modern BitTorrent also supports trackerless operation using Distributed Hash Tables (DHT).\n\n**torrent file**: A metadata file with a .torrent extension containing all information needed to download and verify a file or set of files. Torrent files are bencoded dictionaries containing the tracker URL, file information (names, sizes, directory structure), piece size, and SHA-1 hashes of all pieces. The torrent file serves as the authoritative specification for what constitutes the complete, correct version of the shared content.\n\n### Protocol Message Types\n\n**choke message**: A peer wire protocol message (ID 0) sent to inform a remote peer that no data will be uploaded to them, regardless of requests. Choking is BitTorrent's primary flow control and incentive mechanism. A peer typically chokes others when bandwidth is limited or when implementing tit-for-tat reciprocal sharing strategies. The choke state persists until an explicit unchoke message is sent.\n\n**have message**: A peer wire protocol message (ID 4) announcing that the sender has successfully downloaded and verified a specific piece. Have messages enable peers to maintain accurate bitfields of what pieces their connected peers possess. These messages are broadcast to all connected peers immediately after successful piece verification, allowing the swarm to quickly learn about new piece availability.\n\n**interested message**: A peer wire protocol message (ID 2) indicating that the sender wants to download data from the recipient. A peer becomes interested when it needs pieces that the remote peer has available. The interested state is a prerequisite for receiving data - choked but interested peers will be unchoked when bandwidth becomes available, while uninterested peers remain choked regardless of their upload contribution.\n\n**piece message**: A peer wire protocol message (ID 7) containing actual file data in response to a request. Piece messages include the piece index, byte offset within the piece, and the block data. These are typically the largest messages in the protocol, carrying 16KB blocks of content. Piece messages are only sent to unchoked peers and represent the core data transfer mechanism of BitTorrent.\n\n**request message**: A peer wire protocol message (ID 6) asking for a specific 16KB block within a piece. Requests specify the piece index, byte offset within the piece, and block length (usually 16KB). Peers can pipeline multiple requests for efficiency, but must not request from choked peers. Request messages drive the actual data transfer process in BitTorrent.\n\n**unchoke message**: A peer wire protocol message (ID 1) indicating that the sender is willing to upload data to the recipient in response to requests. Unchoking typically occurs as part of reciprocal sharing algorithms - peers unchoke others who are uploading to them. The number of simultaneous unchokes is usually limited (typically 4-8) to prevent upload bandwidth from being spread too thin across many peers.\n\n### Data Structures and Technical Terms\n\n**AnnounceRequest**: A data structure containing all parameters needed for a tracker announce request, including info hash, peer ID, port, uploaded/downloaded/left byte counts, and event type. This structure is serialized into HTTP GET parameters when communicating with trackers. Proper construction of announce requests is critical for tracker communication and peer discovery.\n\n**AnnounceResponse**: A data structure representing the tracker's response to an announce request, containing the announce interval, swarm statistics (complete/incomplete peer counts), and the compact peer list. Trackers may also return failure reasons for invalid requests. Parsing announce responses correctly is essential for extracting peer information and scheduling future announces.\n\n**BitfieldOps**: A data structure and associated operations for managing piece availability bitmaps efficiently. Provides methods to set/clear/test individual bits, count available pieces, and serialize bitfields for transmission. Bitfield operations must handle bit-level manipulation correctly, including proper byte boundary handling for piece counts that aren't multiples of 8.\n\n**Connection**: A data structure representing an active TCP connection to another BitTorrent peer, including socket, message framer, peer state flags (choking/interested), bitfield, and pending request queues. Connection objects manage the complete lifecycle of peer communication, from handshake through message exchange to cleanup. Proper connection state management is crucial for protocol correctness.\n\n**Decoder**: A bencode decoder implementation that can parse the four bencode data types from a byte stream. The decoder uses recursive descent parsing to handle nested structures like lists and dictionaries. Decoder state includes current position in the stream and error handling for malformed bencode data. Correct bencode parsing is fundamental to torrent file processing.\n\n**Info**: A data structure representing the info dictionary from a torrent file, containing file names, lengths, piece length, and concatenated piece hashes. The info dictionary describes the actual content being shared and is used to calculate the info hash that identifies the torrent. All torrent metadata validation and file construction depends on correct Info parsing.\n\n**MetaInfo**: The complete data structure representing a parsed torrent file, including tracker URLs, creation metadata, and the info dictionary. MetaInfo serves as the authoritative source of torrent configuration throughout the client's operation. Proper MetaInfo construction from bencode data enables all subsequent BitTorrent operations.\n\n**PieceState**: A data structure tracking the download progress and verification status of an individual piece, including block completion status, hash verification results, and piece priority. Piece state management coordinates concurrent downloads from multiple peers and ensures data integrity through hash verification.\n\n### Networking and Concurrency Concepts\n\n**circuit breaker**: A software pattern that prevents repeated failures by automatically failing fast when error rates exceed thresholds. In BitTorrent contexts, circuit breakers protect against misbehaving peers or trackers by temporarily avoiding connection attempts after repeated failures, then gradually allowing test connections to detect recovery.\n\n**event bus**: An asynchronous messaging system enabling loose coupling between BitTorrent client components. Components publish events (peer connected, piece completed, tracker response) and subscribe to events they need to handle. Event buses simplify coordination between components like piece managers, peer managers, and user interfaces without tight coupling.\n\n**exponential backoff**: A retry strategy where the delay between retry attempts increases exponentially after each failure, often with random jitter to prevent synchronized retries across multiple clients. BitTorrent clients use exponential backoff for tracker announces, peer connections, and piece requests to avoid overwhelming struggling resources.\n\n**graceful shutdown**: A shutdown procedure that allows in-flight operations to complete before terminating the program. For BitTorrent clients, graceful shutdown includes completing piece verifications, sending final tracker announces, closing peer connections cleanly, and flushing any buffered file writes. Proper shutdown prevents data corruption and maintains good network citizenship.\n\n**message framing**: The protocol mechanism for parsing variable-length messages from TCP byte streams using length prefixes. BitTorrent's framing uses 4-byte length headers followed by message payloads. Correct framing implementation prevents protocol desynchronization and enables reliable message parsing even with partial TCP reads.\n\n**shared state**: Data structures accessible by multiple concurrent goroutines or threads, requiring synchronization mechanisms like mutexes to prevent race conditions. In BitTorrent clients, shared state includes piece availability maps, peer connection lists, and download statistics that multiple components access concurrently.\n\n**state machine**: A computational model defining system behavior through states, transitions, and events. BitTorrent peer connections implement state machines tracking choking/unchoking and interested/uninterested states, with message-driven transitions between states. Proper state machine implementation ensures protocol correctness and prevents invalid state combinations.\n\n### File and Data Management\n\n**piece verification**: The process of computing SHA-1 hashes of downloaded pieces and comparing them against the expected hashes from the torrent metadata. Verification ensures data integrity and detects corruption or malicious peers. Failed verification requires re-downloading the piece from different peers. Verification typically occurs immediately after completing a piece download.\n\n**rarest-first selection**: A piece selection algorithm that prioritizes pieces held by the fewest connected peers, increasing overall swarm health by duplicating rare pieces quickly. The algorithm maintains availability counts for all pieces across connected peers and selects pieces with minimum availability. This strategy prevents pieces from becoming unavailable when peers leave the swarm.\n\n### Advanced BitTorrent Features\n\n**Distributed Hash Table (DHT)**: A decentralized peer discovery mechanism that eliminates dependence on central tracker servers. DHT networks store peer information distributed across participating nodes, allowing torrent clients to find peers without tracker access. DHT implementation involves the Kademlia distributed hash table protocol with peer routing tables and distributed key-value storage.\n\n**magnet link**: A URI scheme for identifying torrents using their info hash rather than torrent files. Magnet links enable instant sharing without distributing torrent files, with the complete metadata fetched from peers after connection. Magnet links typically include the info hash, display name, and tracker URLs, enabling clients to join swarms and download metadata on-demand.\n\n**Message Stream Encryption (MSE)**: A protocol extension providing encryption for BitTorrent communications to prevent ISP throttling and deep packet inspection. MSE encrypts the peer wire protocol after handshake completion while maintaining protocol compatibility. Implementation involves cryptographic key exchange and stream cipher encryption of subsequent messages.\n\n### Error Handling and Quality Assurance\n\n**failure cascade**: A failure mode where one component failure triggers additional failures in dependent components, potentially leading to system-wide problems. BitTorrent clients must implement circuit breakers, timeouts, and isolation mechanisms to prevent tracker failures from affecting peer communications or piece verification failures from disrupting other downloads.\n\n**peer quality scoring**: A system for evaluating and ranking peer reliability based on metrics like connection stability, data transfer rates, protocol compliance, and data integrity. Quality scores influence peer selection decisions, connection priorities, and choking algorithms to optimize overall download performance by preferring high-quality peers.\n\n**protocol violation**: Deviation from the BitTorrent wire protocol specification that can cause interoperability problems or security vulnerabilities. Common violations include incorrect message formatting, invalid state transitions, or sending data to choked peers. Robust clients must detect and handle protocol violations gracefully while maintaining compatibility with compliant peers.\n\n### Testing and Development\n\n**integration testing**: Testing approach that verifies component interactions using controlled environments like mock trackers and test torrents with known content. Integration tests validate complete workflows like announce → peer discovery → handshake → piece download → verification, ensuring all components work together correctly.\n\n**mock tracker**: A test implementation of the tracker protocol using local HTTP servers to provide predictable responses for testing. Mock trackers enable controlled testing of announce requests, error handling, peer list parsing, and retry logic without depending on external tracker infrastructure or network conditions.\n\n**test torrent**: A specially crafted torrent file with known content, piece boundaries, and expected hashes for verification during testing. Test torrents enable automated verification of parsing, downloading, and verification logic by providing predictable inputs and expected outputs for test cases.\n\n**unit testing**: Testing individual components in isolation without external dependencies like network connections or file systems. Unit tests verify specific functionality like bencode parsing, piece hash calculation, bitfield operations, and message serialization using controlled inputs and expected outputs.\n\n### Performance and Optimization\n\n**bandwidth management**: Techniques for controlling upload and download rates to optimize performance and comply with user-configured limits. Implementation involves token bucket algorithms, rate limiting, connection prioritization, and adaptive adjustment based on network conditions and peer performance.\n\n**connection pooling**: Maintaining reusable network connections across multiple torrents or operations to reduce connection establishment overhead. Connection pools must handle connection lifetime management, error recovery, and resource cleanup while maintaining protocol compliance and security boundaries.\n\n**token bucket algorithm**: A rate limiting algorithm that allows controlled bursts while maintaining average rate limits over time. Token buckets accumulate tokens at a fixed rate up to a maximum capacity, with each operation consuming tokens. This enables BitTorrent clients to achieve smooth bandwidth utilization while respecting rate limits.\n\n### User Interface and API\n\n**Single Page Application (SPA)**: A web application architecture where client-side JavaScript handles user interface updates and communicates with server APIs via AJAX. SPA BitTorrent interfaces provide responsive user experiences with real-time torrent status updates, file browsing, and download management without page refreshes.\n\n**WebSocket**: A persistent bidirectional communication protocol enabling real-time updates between web browsers and servers. BitTorrent web interfaces use WebSocket connections to push live status updates, peer statistics, and download progress to user interfaces without polling overhead.\n\n### Security and Network\n\n**DHT bootstrap**: The process of joining a Distributed Hash Table network by connecting to well-known bootstrap nodes that provide initial routing table entries. Bootstrap nodes help new clients discover other DHT participants and begin participating in distributed peer discovery operations.\n\n**metadata fetching**: The process of retrieving complete torrent metadata from peers using the Extension Protocol when only an info hash is available (such as from magnet links). Metadata fetching involves requesting metadata pieces from peers who have the complete torrent information.\n"}