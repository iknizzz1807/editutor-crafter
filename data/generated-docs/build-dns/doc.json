{"html":"<h1 id=\"dns-server-design-document\">DNS Server: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>A recursive DNS server that resolves domain names by implementing the DNS protocol, following referrals from root servers through the DNS hierarchy, and caching responses for performance. The key architectural challenge is managing stateful recursive resolution while handling concurrent queries and maintaining cache consistency with TTL-based expiration.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundational understanding for all milestones (1-4)</p>\n</blockquote>\n<p>The Domain Name System (DNS) serves as the internet&#39;s address book, translating human-readable domain names like <code>google.com</code> into IP addresses like <code>142.250.191.14</code> that computers use to communicate. While this translation might seem straightforward, the underlying challenge involves creating a distributed, hierarchical system that can handle billions of queries per day with sub-second response times. Building a DNS server requires understanding not just the protocol mechanics, but the fundamental approaches to name resolution and the architectural trade-offs each approach entails.</p>\n<h3 id=\"mental-model-dns-as-a-postal-system\">Mental Model: DNS as a Postal System</h3>\n<p>Think of DNS resolution as navigating a vast postal system where you need to deliver a letter but only have a partial address. Imagine you have a letter addressed to &quot;John Smith, Apartment 42, Oak Street, Springfield&quot; but you don&#39;t know which state Springfield is in, or even which country. The DNS hierarchy works exactly like a postal routing system with multiple levels of knowledge and authority.</p>\n<p>At the top level, you have <strong>root mail sorters</strong> (DNS root servers) who don&#39;t know about every address in the world, but they know which regional postal centers handle which top-level regions. When you ask a root sorter about &quot;Springfield,&quot; they can&#39;t give you John Smith&#39;s exact location, but they can tell you &quot;all &#39;.com&#39; addresses go to the Commercial Postal Region&quot; and give you the address of that regional center.</p>\n<p>The <strong>regional postal centers</strong> (DNS TLD servers) know about all the major districts in their region. When you ask the Commercial Postal Region about &quot;google.com,&quot; they can&#39;t tell you about specific departments within Google, but they know &quot;all google.com mail goes to Google&#39;s corporate mail center&quot; and provide you with that center&#39;s address.</p>\n<p>Finally, the <strong>local mail centers</strong> (authoritative DNS servers) have complete knowledge of their specific district. When you reach Google&#39;s mail center asking about &quot;<a href=\"http://www.google.com\">www.google.com</a>,&quot; they have authoritative knowledge and can give you the exact building address (IP address) where that service is located.</p>\n<p>The key insight is that <strong>no single entity knows everything</strong>, but each level of the hierarchy knows exactly who to ask next. Root servers know about TLD servers, TLD servers know about domain-specific servers, and authoritative servers know about the actual hosts. This distributed knowledge creates a system that scales to billions of domains without any single point of knowledge becoming a bottleneck.</p>\n<p>The <strong>caching mechanism</strong> works like a mail carrier&#39;s local knowledge. After delivering mail to Springfield several times, the carrier remembers the route and doesn&#39;t need to ask the regional center every time. However, this knowledge has an expiration date (TTL) because addresses can change, and the carrier needs to refresh their knowledge periodically.</p>\n<h3 id=\"resolution-approaches-comparison\">Resolution Approaches Comparison</h3>\n<p>DNS servers can operate using three fundamentally different approaches to name resolution, each with distinct architectural implications and use cases. Understanding these approaches is crucial because the choice affects every aspect of your server&#39;s design, from data storage patterns to network communication flows.</p>\n<h4 id=\"authoritative-only-servers\">Authoritative-Only Servers</h4>\n<p><strong>Authoritative DNS servers</strong> are like local post offices that have complete, definitive knowledge about addresses in their specific district, but no knowledge about addresses outside their jurisdiction. When someone asks about an address in their district, they provide the definitive answer. When asked about anywhere else, they essentially respond &quot;I don&#39;t know, and I&#39;m not going to find out for you.&quot;</p>\n<p>An authoritative server loads <strong>zone data</strong> from configuration files (zone files) that contain the complete mapping of domain names to IP addresses for domains under its authority. For example, Google&#39;s authoritative servers know that <code>www.google.com</code> points to specific IP addresses, but they have no information about <code>facebook.com</code> and will not attempt to resolve it.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Authoritative Server Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Data Source</strong></td>\n<td>Zone files containing domain-to-IP mappings for owned domains</td>\n</tr>\n<tr>\n<td><strong>Query Scope</strong></td>\n<td>Only answers queries for domains in its configured zones</td>\n</tr>\n<tr>\n<td><strong>Response Behavior</strong></td>\n<td>Provides definitive answers for owned domains, rejects others</td>\n</tr>\n<tr>\n<td><strong>Caching Requirements</strong></td>\n<td>No caching needed (always has authoritative data)</td>\n</tr>\n<tr>\n<td><strong>Network Dependencies</strong></td>\n<td>None (operates entirely from local zone data)</td>\n</tr>\n<tr>\n<td><strong>Primary Use Case</strong></td>\n<td>Hosting DNS records for specific domain owners</td>\n</tr>\n</tbody></table>\n<p>The architecture of an authoritative server is relatively straightforward because it never needs to contact other servers. It parses incoming queries, checks if the requested domain exists in its zone data, and either provides the authoritative answer or returns an &quot;I don&#39;t handle that domain&quot; response.</p>\n<h4 id=\"forwarding-servers\">Forwarding Servers</h4>\n<p><strong>Forwarding DNS servers</strong> operate like mail forwarding services. They don&#39;t have knowledge of addresses themselves, and they don&#39;t do the detective work of tracking down unknown addresses. Instead, they simply pass every query to another DNS server (the forwarder) and relay the response back to the client.</p>\n<p>Think of a forwarding server as a receptionist at a small office who doesn&#39;t know anyone&#39;s direct phone numbers, but always transfers calls to the main corporate directory service. The receptionist adds no knowledge to the process but provides a consistent interface and potentially some local benefits like access control or logging.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Forwarding Server Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Data Source</strong></td>\n<td>No local DNS data; relies entirely on upstream forwarder</td>\n</tr>\n<tr>\n<td><strong>Query Scope</strong></td>\n<td>Forwards all queries to configured upstream server</td>\n</tr>\n<tr>\n<td><strong>Response Behavior</strong></td>\n<td>Relays responses from upstream server without modification</td>\n</tr>\n<tr>\n<td><strong>Caching Requirements</strong></td>\n<td>Optional local caching to improve response times</td>\n</tr>\n<tr>\n<td><strong>Network Dependencies</strong></td>\n<td>Complete dependency on upstream forwarder availability</td>\n</tr>\n<tr>\n<td><strong>Primary Use Case</strong></td>\n<td>Corporate networks, ISPs providing simple DNS service</td>\n</tr>\n</tbody></table>\n<p>Forwarding servers are often used in corporate environments where network policies require all DNS traffic to go through specific servers, or by ISPs who want to provide DNS service without the complexity of running a full recursive resolver.</p>\n<h4 id=\"recursive-resolvers\">Recursive Resolvers</h4>\n<p><strong>Recursive DNS servers</strong> are like detective agencies that will track down any address you ask them about, no matter where in the world it might be. When you ask a recursive resolver about an address it doesn&#39;t know, it doesn&#39;t just give up or forward the question elsewhere. Instead, it starts its own investigation, following the postal system hierarchy from the top down until it finds the definitive answer.</p>\n<p>The recursive resolver implements the <strong>iterative resolution process</strong>: it starts by asking root servers, follows their referrals to TLD servers, then follows those referrals to authoritative servers, and finally returns the authoritative answer to the original client. From the client&#39;s perspective, they asked one question and got one complete answer, even though the resolver may have performed dozens of queries behind the scenes.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Recursive Resolver Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Data Source</strong></td>\n<td>No authoritative data; builds knowledge through iterative queries</td>\n</tr>\n<tr>\n<td><strong>Query Scope</strong></td>\n<td>Resolves any domain name in the global DNS namespace</td>\n</tr>\n<tr>\n<td><strong>Response Behavior</strong></td>\n<td>Performs complete resolution and returns final answer</td>\n</tr>\n<tr>\n<td><strong>Caching Requirements</strong></td>\n<td>Extensive caching essential for performance and reduced network load</td>\n</tr>\n<tr>\n<td><strong>Network Dependencies</strong></td>\n<td>Must be able to reach root servers and arbitrary authoritative servers</td>\n</tr>\n<tr>\n<td><strong>Primary Use Case</strong></td>\n<td>ISP DNS servers, public resolvers (8.8.8.8, 1.1.1.1), enterprise DNS</td>\n</tr>\n</tbody></table>\n<p>The architecture of a recursive resolver is significantly more complex because it must manage <strong>stateful resolution processes</strong>. When a client asks about <code>www.example.com</code>, the resolver might need to:</p>\n<ol>\n<li>Query a root server to learn about <code>.com</code> TLD servers</li>\n<li>Query a <code>.com</code> TLD server to learn about <code>example.com</code>&#39;s authoritative servers</li>\n<li>Query <code>example.com</code>&#39;s authoritative server to get the final answer for <code>www.example.com</code></li>\n<li>Return the complete answer to the original client</li>\n</ol>\n<p>Each step may involve network timeouts, retries, and following additional referrals, all while maintaining the context of the original query.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"DNS Server System Components\"></p>\n<h4 id=\"architecture-decision-resolution-approach-selection\">Architecture Decision: Resolution Approach Selection</h4>\n<blockquote>\n<p><strong>Decision: Implement Recursive Resolver Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Building an educational DNS server that demonstrates core DNS concepts and protocols while providing practical functionality for learning network programming and distributed systems concepts.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Authoritative-only server (simpler implementation, limited scope)</li>\n<li>Forwarding server (minimal complexity, limited learning value)</li>\n<li>Recursive resolver (complex but comprehensive learning experience)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement a recursive resolver with caching capabilities</li>\n<li><strong>Rationale</strong>: Recursive resolution demonstrates the complete DNS protocol stack, including binary protocol parsing, network programming, hierarchical distributed systems, caching strategies, and concurrent programming. While more complex, it provides the richest learning experience and produces a server that can resolve any domain name, making it immediately useful.</li>\n<li><strong>Consequences</strong>: Requires implementing iterative resolution logic, robust caching with TTL management, concurrent query handling, and comprehensive error handling. The complexity enables learning advanced systems programming concepts but increases implementation time and debugging complexity.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Resolution Approach</th>\n<th>Implementation Complexity</th>\n<th>Learning Value</th>\n<th>Practical Utility</th>\n<th>Network Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Authoritative Only</strong></td>\n<td>Low</td>\n<td>Medium</td>\n<td>Limited to owned domains</td>\n<td>None</td>\n</tr>\n<tr>\n<td><strong>Forwarding</strong></td>\n<td>Very Low</td>\n<td>Low</td>\n<td>Dependent on upstream</td>\n<td>Single upstream server</td>\n</tr>\n<tr>\n<td><strong>Recursive</strong> ✓</td>\n<td>High</td>\n<td>Very High</td>\n<td>Universal DNS resolution</td>\n<td>Root server access</td>\n</tr>\n</tbody></table>\n<p>The recursive resolver approach aligns with the project&#39;s educational goals because it requires implementing every layer of the DNS system: binary protocol parsing, network communication, distributed algorithms, caching strategies, and concurrent programming. Students gain experience with real-world systems programming challenges while building something immediately useful.</p>\n<h4 id=\"hybrid-approaches-and-operational-considerations\">Hybrid Approaches and Operational Considerations</h4>\n<p>Real-world DNS servers often implement <strong>hybrid approaches</strong> that combine multiple resolution strategies based on the query context. For example, a DNS server might:</p>\n<ul>\n<li>Act as an authoritative server for domains it owns (responding from zone data)</li>\n<li>Perform recursive resolution for client queries about external domains</li>\n<li>Forward specific types of queries to specialized servers (like threat intelligence feeds)</li>\n<li>Implement <strong>conditional forwarding</strong> where certain domain patterns are forwarded to specific servers</li>\n</ul>\n<p>Our educational implementation focuses on the recursive resolver core, but the architecture we design will support adding authoritative capabilities in future extensions. This design choice reflects real-world DNS server architecture, where flexibility and extensibility are crucial operational requirements.</p>\n<p>The <strong>performance characteristics</strong> of each approach differ significantly:</p>\n<table>\n<thead>\n<tr>\n<th>Performance Aspect</th>\n<th>Authoritative</th>\n<th>Forwarding</th>\n<th>Recursive</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Query Latency</strong></td>\n<td>~1ms (memory lookup)</td>\n<td>~10-50ms (single upstream query)</td>\n<td>~100-500ms (multiple iterative queries)</td>\n</tr>\n<tr>\n<td><strong>Cache Hit Ratio Impact</strong></td>\n<td>N/A</td>\n<td>Medium (reduces upstream load)</td>\n<td>Critical (dramatically affects latency)</td>\n</tr>\n<tr>\n<td><strong>Scalability Bottleneck</strong></td>\n<td>Memory for zone data</td>\n<td>Upstream server capacity</td>\n<td>Network I/O and cache size</td>\n</tr>\n<tr>\n<td><strong>Resource Usage</strong></td>\n<td>Low CPU, moderate memory</td>\n<td>Very low CPU/memory</td>\n<td>High CPU, high memory</td>\n</tr>\n</tbody></table>\n<p>For our educational implementation, we prioritize learning value over absolute performance, but we&#39;ll implement caching and concurrent query handling to demonstrate how production DNS servers achieve the performance characteristics required for real-world deployment.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides the foundational code structure and decision framework for building a recursive DNS server in Go. The approach emphasizes modularity and testability while maintaining educational clarity.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>UDP Server</strong></td>\n<td><code>net.PacketConn</code> with goroutine-per-query</td>\n<td><code>golang.org/x/net/ipv4</code> with connection pooling</td>\n</tr>\n<tr>\n<td><strong>DNS Parsing</strong></td>\n<td>Manual byte parsing with <code>binary.BigEndian</code></td>\n<td><code>miekg/dns</code> library (reduces learning but simplifies)</td>\n</tr>\n<tr>\n<td><strong>Caching</strong></td>\n<td><code>sync.Map</code> with TTL goroutine cleanup</td>\n<td><code>patrickmn/go-cache</code> or <code>golang-lru/v2</code></td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>YAML files with <code>gopkg.in/yaml.v3</code></td>\n<td>Environment variables with <code>kelseyhightower/envconfig</code></td>\n</tr>\n<tr>\n<td><strong>Logging</strong></td>\n<td>Standard <code>log</code> package with levels</td>\n<td><code>sirupsen/logrus</code> or <code>uber-go/zap</code></td>\n</tr>\n<tr>\n<td><strong>Testing</strong></td>\n<td>Standard <code>testing</code> package</td>\n<td><code>stretchr/testify</code> for assertions and mocks</td>\n</tr>\n</tbody></table>\n<p><strong>Recommendation</strong>: Use simple options for core DNS functionality (parsing, resolution) to maximize learning, but use advanced options for infrastructure concerns (logging, configuration) to focus effort on DNS-specific challenges.</p>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>dns-server/\n├── cmd/\n│   ├── dns-server/\n│   │   └── main.go              ← Server entry point and CLI\n│   └── dns-client/\n│       └── main.go              ← Testing client for validation\n├── internal/\n│   ├── server/\n│   │   ├── server.go            ← UDP server and request routing\n│   │   └── server_test.go       \n│   ├── parser/\n│   │   ├── message.go           ← DNS message parsing (Milestone 1)\n│   │   ├── compression.go       ← Name compression handling\n│   │   └── parser_test.go       \n│   ├── resolver/\n│   │   ├── recursive.go         ← Iterative resolution (Milestone 3)\n│   │   ├── authority.go         ← Authoritative responses (Milestone 2)\n│   │   └── resolver_test.go     \n│   ├── cache/\n│   │   ├── cache.go             ← TTL-based caching (Milestone 4)\n│   │   └── cache_test.go        \n│   └── zone/\n│       ├── loader.go            ← Zone file parsing (Milestone 2)\n│       └── zone_test.go         \n├── configs/\n│   ├── root-hints.txt           ← Root server IP addresses\n│   └── example-zone.txt         ← Sample zone file for testing\n├── testdata/\n│   ├── dns-messages/            ← Binary DNS message samples\n│   └── zone-files/              ← Test zone files\n└── go.mod</code></pre></div>\n\n<p>This structure separates concerns clearly: <code>server</code> handles network I/O, <code>parser</code> handles protocol details, <code>resolver</code> implements DNS logic, <code>cache</code> manages performance, and <code>zone</code> handles authoritative data. Each package can be developed and tested independently.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>UDP Server Foundation</strong> (<code>internal/server/server.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Server</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn     </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PacketConn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resolver </span><span style=\"color:#B392F0\">Resolver</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handler  </span><span style=\"color:#B392F0\">MessageHandler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Resolver</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Resolve</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">question</span><span style=\"color:#B392F0\"> Question</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageHandler</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ParseQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BuildResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">records</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewServer creates a DNS server that listens on the specified address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">resolver</span><span style=\"color:#B392F0\"> Resolver</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#B392F0\"> MessageHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        addr:     addr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resolver: resolver,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handler:  handler,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins listening for DNS queries and blocks until context is cancelled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implementation provided - this is infrastructure, not core learning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> net.</span><span style=\"color:#B392F0\">ListenPacket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"udp\"</span><span style=\"color:#E1E4E8\">, s.addr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to bind UDP socket: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> conn.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.conn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> conn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DNS server listening on </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, s.addr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// DNS messages limited to 512 bytes over UDP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Set read timeout to prevent blocking indefinitely</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            conn.</span><span style=\"color:#B392F0\">SetReadDeadline</span><span style=\"color:#E1E4E8\">(time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            n, clientAddr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> conn.</span><span style=\"color:#B392F0\">ReadFrom</span><span style=\"color:#E1E4E8\">(buffer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> netErr, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> err.(</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">); ok </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> netErr.</span><span style=\"color:#B392F0\">Timeout</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span><span style=\"color:#6A737D\"> // Timeout is expected, check context and continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Error reading UDP packet: </span><span style=\"color:#79B8FF\">%v\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Handle each query in a separate goroutine for concurrency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            go</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">handleQuery</span><span style=\"color:#E1E4E8\">(buffer[:n], clientAddr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">queryData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">clientAddr</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Students implement this - core learning component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This method should:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Parse the DNS query using s.handler.ParseQuery()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Extract the question from the parsed message  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Resolve the question using s.resolver.Resolve()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Build a response using s.handler.BuildResponse()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Send the response back to clientAddr using s.conn.WriteTo()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Handle errors appropriately (malformed queries, resolution failures, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Configuration Management</strong> (<code>internal/server/config.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">gopkg.in/yaml.v3</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Server </span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#9ECBFF\"> `yaml:\"server\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cache  </span><span style=\"color:#B392F0\">CacheConfig</span><span style=\"color:#9ECBFF\">  `yaml:\"cache\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Zones  []</span><span style=\"color:#B392F0\">ZoneConfig</span><span style=\"color:#9ECBFF\"> `yaml:\"zones\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServerConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ListenAddr </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"listen_addr\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timeout    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxSize    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `yaml:\"max_size\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DefaultTTL </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"default_ttl\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ZoneConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Domain </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"domain\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    File   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"file\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filepath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Complete implementation provided - infrastructure component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(filepath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read config file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#B392F0\">Config</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> yaml.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">config); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to parse config YAML: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set reasonable defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.Server.ListenAddr </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.Server.ListenAddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \":53\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.Server.Timeout </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.Server.Timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"5s\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.Cache.MaxSize </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.Cache.MaxSize </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">config, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeletons\">Core Logic Skeletons</h4>\n<p><strong>DNS Message Parser</strong> (<code>internal/parser/message.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> parser</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DNSMessage represents a complete DNS message with header and sections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DNSMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Header      </span><span style=\"color:#B392F0\">Header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Questions   []</span><span style=\"color:#B392F0\">Question</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Answers     []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authority   []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Additional  []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Header represents the 12-byte DNS message header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Header</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID                </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueryResponse     </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // QR bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Opcode           </span><span style=\"color:#F97583\">uint8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authoritative    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // AA bit  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Truncated        </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // TC bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursionDesired </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // RD bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursionAvail   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // RA bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponseCode     </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">  // RCODE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QuestionCount    </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // QDCOUNT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AnswerCount      </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // ANCOUNT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuthorityCount   </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // NSCOUNT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdditionalCount  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // ARCOUNT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseMessage parses a complete DNS message from wire format bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate minimum message length (12 bytes for header)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse the 12-byte header using parseHeader()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize message structure with parsed header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse Questions section (header.QuestionCount questions)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Parse Answer section (header.AnswerCount resource records)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Parse Authority section (header.AuthorityCount resource records)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Parse Additional section (header.AdditionalCount resource records)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return complete DNSMessage structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use a position tracker to advance through the byte slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Each parse function should return (parsed_data, bytes_consumed, error)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseHeader extracts the 12-byte header from the beginning of a DNS message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseHeader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate data length is at least 12 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Extract ID (bytes 0-1) using binary.BigEndian.Uint16()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Extract flags (bytes 2-3) and decode individual bits:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         QR=bit15, Opcode=bits14-11, AA=bit10, TC=bit9, RD=bit8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         RA=bit7, RCODE=bits3-0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Extract section counts (bytes 4-11, four 16-bit values)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return populated Header struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use bit masking and shifting to extract flag bits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: All multi-byte values are in network (big-endian) byte order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Go-Specific DNS Implementation Tips</strong>:</p>\n<ul>\n<li>Use <code>binary.BigEndian.Uint16()</code> and <code>binary.BigEndian.Uint32()</code> for parsing multi-byte network values</li>\n<li>DNS names are case-insensitive; use <code>strings.ToLower()</code> for consistent comparisons  </li>\n<li>UDP messages are limited to 512 bytes; larger responses require TCP (not implemented in basic version)</li>\n<li>Use <code>context.WithTimeout()</code> for network operations to prevent hanging on unresponsive servers</li>\n<li>The <code>net.LookupNS()</code> function can validate your recursive resolution against system resolver</li>\n<li>Use <code>sync.Map</code> or <code>sync.RWMutex</code> for concurrent cache access from multiple goroutines</li>\n<li>Time-based operations should use <code>time.Now().Unix()</code> for TTL calculations (avoids timezone issues)</li>\n</ul>\n<p><strong>Common Go Pitfalls in DNS Implementation</strong>:</p>\n<ul>\n<li>Forgetting to handle name compression in DNS messages leads to incorrect parsing</li>\n<li>Using signed integers for TTL values causes problems when TTL exceeds 2^31 seconds  </li>\n<li>Not setting timeouts on network operations can cause goroutines to leak indefinitely</li>\n<li>Case-sensitive domain name comparisons fail for real-world DNS queries</li>\n<li>Modifying slices passed to goroutines creates data races without proper synchronization</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After completing foundation setup</strong>:</p>\n<ol>\n<li><strong>Verify UDP server startup</strong>: Run <code>go run cmd/dns-server/main.go</code> - should print &quot;DNS server listening on :53&quot;</li>\n<li><strong>Test basic connectivity</strong>: Use <code>dig @127.0.0.1 google.com</code> - should receive a response (may be error, but connection works)  </li>\n<li><strong>Validate message parsing</strong>: Create unit tests that parse known-good DNS messages from <code>testdata/</code></li>\n<li><strong>Check configuration loading</strong>: Verify server loads <code>configs/dns-server.yaml</code> without panicking</li>\n</ol>\n<p><strong>Expected behavior after foundation</strong>:</p>\n<ul>\n<li>Server starts without errors and binds to UDP port</li>\n<li>Incoming queries trigger <code>handleQuery()</code> function calls</li>\n<li>Message parsing attempts occur (may fail until Milestone 1 complete)</li>\n<li>Clean shutdown when interrupted with Ctrl+C</li>\n</ul>\n<p><strong>Signs something is wrong</strong>:</p>\n<ul>\n<li>&quot;Permission denied&quot; when binding port 53 → Run as root or use port 5353 for testing</li>\n<li>&quot;Address already in use&quot; → Another DNS server is running, change port or stop competing service</li>\n<li>Panic on startup → Check configuration file syntax and required directories exist</li>\n<li>No response to <code>dig</code> queries → Verify firewall allows UDP traffic on chosen port</li>\n</ul>\n<p>This foundation provides the infrastructure framework while leaving the core DNS protocol implementation as the primary learning challenge. Students can focus on understanding DNS message formats, resolution algorithms, and caching strategies rather than UDP socket programming details.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundational understanding for all milestones (1-4)</p>\n</blockquote>\n<p>The DNS server project aims to build a comprehensive recursive DNS resolver that demonstrates mastery of network protocols, distributed systems concepts, and performance optimization techniques. This section establishes clear boundaries around what the implementation will and will not include, ensuring focused development while maintaining educational value.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>Understanding the functional requirements for a DNS server requires thinking about the different roles DNS servers play in the internet infrastructure. Think of DNS servers as specialized librarians in a vast distributed library system. Some librarians are <strong>reference specialists</strong> who have authoritative knowledge about specific collections (authoritative servers), others are <strong>research assistants</strong> who know how to track down any book by following leads through the entire library system (recursive resolvers), and still others are <strong>information brokers</strong> who simply forward requests to their trusted colleagues upstream (forwarding servers).</p>\n<p>Our DNS server implementation will function as both a reference specialist and research assistant, capable of serving authoritative responses for configured domains while also performing complete recursive resolution for any domain on the internet. This dual capability provides comprehensive learning opportunities across all aspects of DNS server operation.</p>\n<h4 id=\"core-protocol-implementation\">Core Protocol Implementation</h4>\n<p>The foundation of any DNS server lies in its ability to correctly implement the DNS wire protocol as specified in RFC 1035. This involves handling the binary message format that carries DNS queries and responses across UDP (and potentially TCP) connections.</p>\n<table>\n<thead>\n<tr>\n<th>Protocol Feature</th>\n<th>Implementation Requirement</th>\n<th>Learning Objective</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DNS Message Format</td>\n<td>Parse and construct complete DNS messages with header, question, answer, authority, and additional sections</td>\n<td>Understanding binary protocol parsing and network byte order</td>\n</tr>\n<tr>\n<td>Name Compression</td>\n<td>Decode and encode DNS name compression using pointer labels to reduce message size</td>\n<td>Handling complex binary data structures with internal references</td>\n</tr>\n<tr>\n<td>Resource Record Types</td>\n<td>Support A, AAAA, CNAME, MX, NS, SOA, and TXT record types with proper RDATA parsing</td>\n<td>Learning diverse data encoding formats within a single protocol</td>\n</tr>\n<tr>\n<td>UDP Transport</td>\n<td>Handle DNS queries over UDP with proper packet size limits and truncation handling</td>\n<td>Network programming fundamentals and datagram protocols</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Generate appropriate DNS response codes (NXDOMAIN, SERVFAIL, FORMERR) for various error conditions</td>\n<td>Protocol-level error communication and client experience</td>\n</tr>\n</tbody></table>\n<p>The message parsing implementation must handle the complexity of DNS name compression, where domain names can reference earlier occurrences in the same message to save space. This creates a challenge similar to managing pointers in binary data—the parser must maintain state about previously encountered names while avoiding infinite loops from malicious compression chains.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: DNS message parsing represents one of the most complex binary protocol parsing challenges developers encounter. The combination of variable-length encoded names, compression pointers, and multiple record types with different RDATA formats requires careful buffer management and state tracking. Mastering this provides transferable skills for any network protocol implementation.</p>\n</blockquote>\n<h4 id=\"authoritative-dns-service\">Authoritative DNS Service</h4>\n<p>The authoritative server component transforms our DNS server into a reference specialist for specific domains. Think of this as becoming the official record keeper for a particular section of the internet&#39;s namespace—when someone asks about domains we&#39;re authoritative for, we provide the definitive answer rather than looking it up elsewhere.</p>\n<table>\n<thead>\n<tr>\n<th>Authoritative Feature</th>\n<th>Implementation Requirement</th>\n<th>Learning Objective</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zone File Parsing</td>\n<td>Read BIND-format zone files and load records into queryable data structures</td>\n<td>File format parsing and data structure design</td>\n</tr>\n<tr>\n<td>Query Matching</td>\n<td>Find the best matching records for a given domain name and record type</td>\n<td>String matching algorithms and hierarchical data organization</td>\n</tr>\n<tr>\n<td>Response Construction</td>\n<td>Populate answer, authority, and additional sections according to DNS standards</td>\n<td>Understanding multi-section response semantics</td>\n</tr>\n<tr>\n<td>Delegation Handling</td>\n<td>Properly delegate subdomains with NS records and glue records</td>\n<td>Hierarchical namespace management and circular dependency resolution</td>\n</tr>\n<tr>\n<td>Negative Responses</td>\n<td>Generate NXDOMAIN and NODATA responses with proper SOA records</td>\n<td>Error case handling in distributed systems</td>\n</tr>\n</tbody></table>\n<p>The zone file parsing component must handle the standard BIND zone file format, which includes features like <code>$ORIGIN</code> directives, relative domain names, and various record type syntaxes. This parsing challenge teaches important lessons about configuration file design and the trade-offs between human readability and machine parseability.</p>\n<p>Query matching in an authoritative server involves finding the most specific match for a given domain name within the zone data. This is more complex than simple string matching because of DNS&#39;s hierarchical structure—a query for <code>www.example.com</code> might match a wildcard record <code>*.example.com</code> if no more specific record exists.</p>\n<blockquote>\n<p><strong>Decision: Zone Data Storage Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Authoritative servers need efficient data structures for storing and querying zone records</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Hash map with full domain names as keys</li>\n<li>Trie structure mirroring DNS hierarchy</li>\n<li>Sorted slice with binary search</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Hash map with normalized domain names as keys</li>\n<li><strong>Rationale</strong>: Provides O(1) lookup performance for exact matches and simplifies implementation compared to trie structures, while sorted slices would require O(log n) search time</li>\n<li><strong>Consequences</strong>: Excellent performance for exact matches but requires additional logic for wildcard matching and closest encloser finding</li>\n</ul>\n</blockquote>\n<h4 id=\"recursive-resolution-engine\">Recursive Resolution Engine</h4>\n<p>The recursive resolver component transforms our DNS server into a research assistant capable of tracking down any domain name by following the DNS hierarchy from root servers down to authoritative nameservers. This represents the most intellectually challenging aspect of DNS server implementation.</p>\n<p>Think of recursive resolution as detective work where each clue (referral) leads you closer to the final answer. You start with a broad lead (the root servers know about top-level domains), follow it to get a more specific lead (TLD servers know about second-level domains), and continue until you find the authoritative source with the definitive answer.</p>\n<table>\n<thead>\n<tr>\n<th>Resolution Feature</th>\n<th>Implementation Requirement</th>\n<th>Learning Objective</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Root Hints Bootstrap</td>\n<td>Use root hints file to initialize resolution with root server IP addresses</td>\n<td>Understanding DNS hierarchy bootstrap process</td>\n</tr>\n<tr>\n<td>Iterative Queries</td>\n<td>Follow NS referrals from root through TLD to authoritative servers</td>\n<td>Implementing stateful multi-step distributed algorithms</td>\n</tr>\n<tr>\n<td>CNAME Following</td>\n<td>Transparently resolve CNAME chains to final target records</td>\n<td>Handling indirection and alias resolution in distributed systems</td>\n</tr>\n<tr>\n<td>Glue Record Processing</td>\n<td>Use A records from additional section to avoid circular dependencies</td>\n<td>Understanding and resolving circular dependencies in distributed lookups</td>\n</tr>\n<tr>\n<td>Loop Detection</td>\n<td>Detect and prevent infinite referral loops and CNAME chains</td>\n<td>Implementing cycle detection in distributed graph traversal</td>\n</tr>\n</tbody></table>\n<p>The iterative resolution algorithm maintains state about the current query while following a chain of referrals. Each step involves sending a query to a nameserver, processing the response, and deciding whether to return an answer or follow another referral. This state management teaches valuable lessons about distributed algorithms and error recovery.</p>\n<p>Glue records solve a fundamental bootstrapping problem in DNS: if <code>ns1.example.com</code> is the nameserver for <code>example.com</code>, how do you find the IP address of <code>ns1.example.com</code> without already knowing it? The parent zone (<code>com</code> in this case) provides glue records—A records for nameservers within the zone they serve—to break this circular dependency.</p>\n<blockquote>\n<p><strong>Decision: Resolution State Management</strong></p>\n<ul>\n<li><strong>Context</strong>: Recursive resolution requires tracking state across multiple network round-trips</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Single-threaded state machine with explicit state variables</li>\n<li>Recursive function calls with stack-based state</li>\n<li>Goroutines with channel communication for each resolution step</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Iterative approach with explicit state tracking in a resolution context structure</li>\n<li><strong>Rationale</strong>: Provides better control over timeout handling and resource management compared to recursive calls, while being simpler to debug than multi-goroutine approaches</li>\n<li><strong>Consequences</strong>: More explicit code that clearly shows resolution steps, but requires careful state management and cleanup</li>\n</ul>\n</blockquote>\n<h4 id=\"caching-and-performance-optimization\">Caching and Performance Optimization</h4>\n<p>The caching layer transforms our DNS server from a research assistant who looks up everything from scratch into an experienced librarian who remembers recent answers and can respond immediately to repeated questions. DNS caching is crucial for internet performance—without it, every web page load would require dozens of DNS lookups starting from the root servers.</p>\n<table>\n<thead>\n<tr>\n<th>Caching Feature</th>\n<th>Implementation Requirement</th>\n<th>Learning Objective</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TTL-Based Expiration</td>\n<td>Store cached records with automatic expiration based on their time-to-live values</td>\n<td>Understanding distributed cache consistency and temporal data management</td>\n</tr>\n<tr>\n<td>Negative Caching</td>\n<td>Cache NXDOMAIN and NODATA responses to avoid repeated failed queries</td>\n<td>Caching negative results and handling cache invalidation</td>\n</tr>\n<tr>\n<td>Cache Validation</td>\n<td>Prevent cache poisoning by validating response records match queries</td>\n<td>Security considerations in caching systems</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Implement cache size limits and eviction policies to prevent memory exhaustion</td>\n<td>Resource management and cache replacement algorithms</td>\n</tr>\n<tr>\n<td>Concurrent Access</td>\n<td>Handle multiple simultaneous queries with thread-safe cache operations</td>\n<td>Concurrent data structure design and locking strategies</td>\n</tr>\n</tbody></table>\n<p>TTL-based caching requires careful time management—each cached record has an independent expiration time that must be tracked and enforced. The cache must continuously expire old records while serving fresh ones, creating a time-based data management challenge.</p>\n<p>Negative caching stores the absence of records, which is philosophically different from caching positive data. When a domain doesn&#39;t exist (NXDOMAIN), we want to remember that fact temporarily to avoid repeated expensive lookups, but we must be careful about the cache duration since domains can be created at any time.</p>\n<blockquote>\n<p><strong>Decision: Cache Implementation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS cache needs to handle thousands of records with different TTL values and concurrent access</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Simple map with periodic cleanup goroutine</li>\n<li>Time-ordered priority queue with exact expiration</li>\n<li>Lazy expiration on access with background cleanup</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Lazy expiration on access with periodic background cleanup</li>\n<li><strong>Rationale</strong>: Reduces timer overhead compared to exact expiration while providing reasonable cleanup guarantees, and simplifies concurrent access patterns</li>\n<li><strong>Consequences</strong>: Some expired records may persist briefly in memory, but implementation is more robust and performant under high load</li>\n</ul>\n</blockquote>\n<h3 id=\"non-goals\">Non-Goals</h3>\n<p>Defining what the DNS server will not implement is as important as defining what it will implement. These exclusions focus development effort on core learning objectives while avoiding advanced topics that would significantly increase complexity without proportional educational benefit.</p>\n<h4 id=\"security-and-cryptographic-features\">Security and Cryptographic Features</h4>\n<p>Modern DNS includes sophisticated security extensions (DNSSEC) that provide cryptographic validation of DNS responses. However, implementing DNSSEC would require deep cryptographic knowledge and significantly complicate the core DNS learning objectives.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Security Feature</th>\n<th>Rationale for Exclusion</th>\n<th>Alternative Learning Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DNSSEC Validation</td>\n<td>Cryptographic signature verification requires extensive PKI knowledge beyond DNS fundamentals</td>\n<td>Study DNSSEC as a separate cryptography project after mastering basic DNS</td>\n</tr>\n<tr>\n<td>DNS-over-HTTPS (DoH)</td>\n<td>HTTPS transport adds TLS complexity that distracts from DNS protocol learning</td>\n<td>Implement DoH as an extension after completing basic UDP/TCP DNS</td>\n</tr>\n<tr>\n<td>DNS-over-TLS (DoT)</td>\n<td>TLS implementation complexity overshadows DNS-specific learning objectives</td>\n<td>Focus on transport-layer security in a dedicated TLS project</td>\n</tr>\n<tr>\n<td>Query Logging Security</td>\n<td>Secure audit logging requires additional infrastructure and privacy considerations</td>\n<td>Add comprehensive logging as an operational extension</td>\n</tr>\n<tr>\n<td>Rate Limiting</td>\n<td>DDoS protection mechanisms are important but distinct from core DNS functionality</td>\n<td>Implement rate limiting as a separate network security exercise</td>\n</tr>\n</tbody></table>\n<p>The exclusion of security features doesn&#39;t mean ignoring security entirely—the implementation will include basic validation to prevent cache poisoning and malformed message handling. However, advanced cryptographic features represent separate learning domains that would dilute focus on DNS fundamentals.</p>\n<h4 id=\"advanced-protocol-extensions\">Advanced Protocol Extensions</h4>\n<p>The DNS protocol has evolved significantly since RFC 1035, with numerous extensions that add functionality for specific use cases. While these extensions are important in production systems, they add complexity that can obscure the fundamental DNS concepts this project aims to teach.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Protocol Feature</th>\n<th>Rationale for Exclusion</th>\n<th>Core DNS Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EDNS0 Extensions</td>\n<td>Extended DNS features like larger UDP payloads add protocol complexity without fundamental learning value</td>\n<td>Focus on standard 512-byte UDP limit handling</td>\n</tr>\n<tr>\n<td>Dynamic Updates (RFC 2136)</td>\n<td>DNS UPDATE mechanism is rarely used and adds significant state management complexity</td>\n<td>Static zone files provide sufficient learning about authoritative data</td>\n</tr>\n<tr>\n<td>Zone Transfers (AXFR/IXFR)</td>\n<td>Zone synchronization between servers is an operational concern separate from query resolution</td>\n<td>Single-server deployment eliminates zone transfer needs</td>\n</tr>\n<tr>\n<td>Multicast DNS (mDNS)</td>\n<td>Local network discovery uses different semantics from internet DNS</td>\n<td>Standard DNS hierarchy provides better learning foundation</td>\n</tr>\n<tr>\n<td>DNS Service Discovery</td>\n<td>Service location records require additional protocol understanding</td>\n<td>Focus on basic record types (A, AAAA, CNAME, MX, NS)</td>\n</tr>\n</tbody></table>\n<p>These protocol extensions represent evolutionary additions to DNS that address specific operational requirements. Excluding them allows deeper focus on the core resolution algorithm and caching behavior that form the foundation for understanding all DNS implementations.</p>\n<h4 id=\"production-operational-features\">Production Operational Features</h4>\n<p>Production DNS servers require extensive operational features for monitoring, configuration management, and high availability. While these features are crucial for real-world deployment, they represent systems administration and DevOps concerns rather than fundamental computer science concepts.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Operational Feature</th>\n<th>Rationale for Exclusion</th>\n<th>Learning Focus Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Configuration Hot Reloading</td>\n<td>Dynamic configuration adds complexity without teaching core DNS concepts</td>\n<td>Static configuration files provide sufficient flexibility for learning</td>\n</tr>\n<tr>\n<td>Prometheus Metrics</td>\n<td>Monitoring integration is important operationally but distinct from DNS algorithm implementation</td>\n<td>Focus on correct DNS behavior rather than observability</td>\n</tr>\n<tr>\n<td>High Availability Clustering</td>\n<td>Multi-server coordination requires distributed systems concepts beyond DNS scope</td>\n<td>Single-server implementation demonstrates all DNS concepts</td>\n</tr>\n<tr>\n<td>Administrative APIs</td>\n<td>REST APIs for server management add web development complexity</td>\n<td>Command-line tools and configuration files provide sufficient control</td>\n</tr>\n<tr>\n<td>Logging Frameworks</td>\n<td>Structured logging systems are operational concerns separate from DNS functionality</td>\n<td>Simple logging to stdout/stderr adequate for debugging and learning</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Principle</strong>: Educational DNS Implementation Focus</p>\n<p>This DNS server prioritizes deep understanding of DNS fundamentals over production readiness. Every included feature directly teaches core concepts like protocol parsing, hierarchical resolution, caching strategies, or distributed systems patterns. Excluded features, while valuable in production systems, would add implementation complexity without proportional learning benefit in these foundational areas.</p>\n</blockquote>\n<p>The non-goals serve as guard rails to prevent scope creep while ensuring the implementation remains focused on its educational mission. Students who complete this project will have mastered the essential DNS concepts and can tackle any of the excluded features as follow-on projects with a solid foundation.</p>\n<h4 id=\"performance-and-scale-limitations\">Performance and Scale Limitations</h4>\n<p>While the DNS server will implement caching and basic performance optimizations, it explicitly avoids the extreme performance engineering required for high-scale production DNS servers that handle millions of queries per second.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Limitation</th>\n<th>Acceptable Trade-off</th>\n<th>Learning Priority</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single-threaded query processing</td>\n<td>Simpler debugging and state management</td>\n<td>Understanding DNS resolution algorithm correctness</td>\n</tr>\n<tr>\n<td>In-memory cache only</td>\n<td>No persistence complexity</td>\n<td>Focus on cache consistency and TTL management</td>\n</tr>\n<tr>\n<td>Basic eviction policies</td>\n<td>LRU or random eviction sufficient</td>\n<td>Understanding cache behavior principles</td>\n</tr>\n<tr>\n<td>No query pipelining</td>\n<td>One query at a time per connection</td>\n<td>Clear separation of query processing steps</td>\n</tr>\n<tr>\n<td>Limited concurrent connections</td>\n<td>Handles dozens, not thousands of clients</td>\n<td>Network programming fundamentals</td>\n</tr>\n</tbody></table>\n<p>These performance limitations are intentional design choices that trade maximum throughput for implementation clarity and debugging simplicity. Students learning DNS benefit more from understanding correct resolution behavior than from optimizing for high-scale performance scenarios they&#39;re unlikely to encounter in educational environments.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: The distinction between educational and production systems lies not in correctness—both must implement the DNS protocol correctly—but in optimization priorities. Educational implementations prioritize understanding and debuggability, while production systems prioritize performance, reliability, and operational features. This DNS server aims for complete correctness with sufficient performance for learning and experimentation.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The functional goals and non-goals establish the scope for a comprehensive DNS server implementation that balances educational value with practical functionality. The following guidance helps translate these goals into concrete implementation decisions.</p>\n<h4 id=\"technology-stack-recommendations\">Technology Stack Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommended for Learning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Transport</td>\n<td><code>net</code> package UDP sockets</td>\n<td>Custom packet processing with <code>golang.org/x/net</code></td>\n<td><code>net.PacketConn</code> for simplicity</td>\n</tr>\n<tr>\n<td>Binary Parsing</td>\n<td>Manual byte slicing with <code>binary</code> package</td>\n<td>Code generation from protocol definitions</td>\n<td>Manual parsing to understand wire format</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>YAML files with <code>gopkg.in/yaml.v3</code></td>\n<td>TOML or JSON with validation schemas</td>\n<td>YAML for human readability</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard <code>log</code> package</td>\n<td>Structured logging with <code>logrus</code> or <code>zap</code></td>\n<td>Standard <code>log</code> package to avoid dependencies</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Standard <code>testing</code> package</td>\n<td>BDD frameworks like <code>ginkgo</code></td>\n<td>Standard <code>testing</code> with table-driven tests</td>\n</tr>\n<tr>\n<td>Time Management</td>\n<td><code>time.Time</code> and <code>time.Duration</code></td>\n<td>Custom time abstraction for testing</td>\n<td>Standard <code>time</code> package with mock interfaces for tests</td>\n</tr>\n</tbody></table>\n<p>The technology choices prioritize Go standard library packages to minimize external dependencies and focus attention on DNS-specific implementation challenges rather than framework learning.</p>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<p>Organizing the DNS server code into logical packages helps separate concerns and makes the implementation more maintainable and testable.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>dns-server/\n├── cmd/\n│   └── dns-server/\n│       └── main.go                    # Entry point, configuration loading\n├── internal/\n│   ├── server/\n│   │   ├── server.go                  # UDP server and query dispatch\n│   │   └── server_test.go             # Server integration tests\n│   ├── protocol/\n│   │   ├── message.go                 # DNS message parsing and construction\n│   │   ├── compression.go             # Name compression handling\n│   │   └── protocol_test.go           # Protocol parsing tests\n│   ├── resolver/\n│   │   ├── recursive.go               # Recursive resolution logic\n│   │   ├── authoritative.go           # Zone data query handling\n│   │   └── resolver_test.go           # Resolution algorithm tests\n│   ├── cache/\n│   │   ├── cache.go                   # TTL-based caching implementation\n│   │   └── cache_test.go              # Cache behavior tests\n│   └── zone/\n│       ├── parser.go                  # Zone file parsing\n│       ├── records.go                 # Resource record data structures\n│       └── zone_test.go               # Zone parsing tests\n├── testdata/\n│   ├── zones/                         # Sample zone files for testing\n│   └── queries/                       # Test DNS messages\n├── configs/\n│   └── server.yaml                    # Server configuration\n└── go.mod</code></pre></div>\n\n<p>This structure separates protocol-level concerns (<code>protocol</code> package) from application logic (<code>resolver</code>, <code>cache</code>, <code>zone</code> packages) and provides clear testing boundaries for each component.</p>\n<h4 id=\"core-data-structure-definitions\">Core Data Structure Definitions</h4>\n<p>The DNS server implementation centers around several key data structures that must be defined consistently across all components.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package: internal/protocol</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DNSMessage represents a complete DNS message as defined in RFC 1035</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DNSMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Header     </span><span style=\"color:#B392F0\">Header</span><span style=\"color:#6A737D\">            // 12-byte fixed header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Questions  []</span><span style=\"color:#B392F0\">Question</span><span style=\"color:#6A737D\">        // Query section (usually one question)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Answers    []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#6A737D\">  // Answer resource records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authority  []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#6A737D\">  // Authority section (NS records, SOA for negative responses)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Additional []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#6A737D\">  // Additional section (glue records, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Header represents the 12-byte DNS message header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Header</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID              </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Query identifier for matching requests/responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueryResponse   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // false for query, true for response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Opcode          </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">   // Query type (0 = standard query)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authoritative   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if responding server is authoritative</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Truncated       </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if message was truncated due to size limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursionDesired </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // true if client requests recursive resolution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursionAvail  </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if server supports recursive resolution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponseCode    </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">   // Response code (0 = no error, 3 = NXDOMAIN, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Section counts (derived from slice lengths, not stored separately)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QuestionCount   </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Number of questions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AnswerCount     </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Number of answer records  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuthorityCount  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Number of authority records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdditionalCount </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Number of additional records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Question represents a DNS query question</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Question</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Domain name being queried (e.g., \"www.example.com\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // Record type (1 = A, 28 = AAAA, 5 = CNAME, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Class </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // Query class (1 = IN for Internet)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceRecord represents any DNS resource record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Domain name this record applies to</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // Record type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Class </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // Record class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TTL   </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\"> // Time-to-live in seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Data  []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\"> // Type-specific RDATA (parsed separately by type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"server-configuration-structure\">Server Configuration Structure</h4>\n<p>The server requires configuration for network settings, zone files, and caching parameters.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package: internal/server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Config represents complete server configuration loaded from YAML</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Server </span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#9ECBFF\"> `yaml:\"server\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cache  </span><span style=\"color:#B392F0\">CacheConfig</span><span style=\"color:#9ECBFF\">  `yaml:\"cache\"`</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Zones  []</span><span style=\"color:#B392F0\">ZoneConfig</span><span style=\"color:#9ECBFF\"> `yaml:\"zones\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServerConfig contains network and protocol settings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServerConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ListenAddr </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"listen_addr\"`</span><span style=\"color:#6A737D\"> // \"127.0.0.1:5353\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timeout    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"timeout\"`</span><span style=\"color:#6A737D\">     // \"5s\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CacheConfig controls caching behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxSize    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `yaml:\"max_size\"`</span><span style=\"color:#6A737D\">     // Maximum cached records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DefaultTTL </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"default_ttl\"`</span><span style=\"color:#6A737D\"> // \"300s\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ZoneConfig specifies an authoritative zone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ZoneConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Domain </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"domain\"`</span><span style=\"color:#6A737D\"> // \"example.com\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    File   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"file\"`</span><span style=\"color:#6A737D\">   // \"zones/example.com.zone\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-implementation-checkpoints\">Milestone Implementation Checkpoints</h4>\n<p>Each milestone builds toward the complete DNS server implementation with specific verification steps.</p>\n<p><strong>Milestone 1 Checkpoint - DNS Message Parsing:</strong>\nAfter implementing the protocol parsing, verify functionality with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/protocol/...</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>Expected behavior: Parse a captured DNS query message, extract the question for &quot;<a href=\"http://www.example.com\">www.example.com</a>&quot;, and reconstruct the message to identical bytes. The test should validate name compression handling by parsing a response with multiple domain names sharing suffixes.</p>\n<p><strong>Milestone 2 Checkpoint - Authoritative Server:</strong>\nAfter implementing zone file parsing and authoritative responses:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start server with test zone</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/dns-server/main.go</span><span style=\"color:#79B8FF\"> -config</span><span style=\"color:#9ECBFF\"> configs/test.yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Query the authoritative server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @127.0.0.1</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 5353</span><span style=\"color:#9ECBFF\"> www.example.com</span><span style=\"color:#9ECBFF\"> A</span></span></code></pre></div>\n\n<p>Expected behavior: Return an A record from the loaded zone file with the authoritative flag set. Verify NS records appear in the authority section and glue records in the additional section.</p>\n<p><strong>Milestone 3 Checkpoint - Recursive Resolution:</strong>\nAfter implementing recursive resolution:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Query for external domain (not in local zones)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @127.0.0.1</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 5353</span><span style=\"color:#9ECBFF\"> www.google.com</span><span style=\"color:#9ECBFF\"> A</span></span></code></pre></div>\n\n<p>Expected behavior: Follow iterative queries from root servers through TLD to authoritative servers, returning the final A record. Verify the recursion available flag is set in responses.</p>\n<p><strong>Milestone 4 Checkpoint - Caching:</strong>\nAfter implementing caching:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># First query (cache miss)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time</span><span style=\"color:#E1E4E8\"> dig @127.0.0.1 -p 5353 www.github.com A</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Second query (cache hit)  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time</span><span style=\"color:#E1E4E8\"> dig @127.0.0.1 -p 5353 www.github.com A</span></span></code></pre></div>\n\n<p>Expected behavior: Second query should return significantly faster (under 1ms) indicating cache hit. Verify cached records expire after their TTL by waiting and observing cache miss behavior.</p>\n<h4 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Network Byte Order Confusion</strong>\nDNS uses network byte order (big-endian) for multi-byte integers, but Go&#39;s default byte operations assume host byte order. Use <code>binary.BigEndian.Uint16()</code> and <code>binary.BigEndian.PutUint16()</code> for all DNS header fields. Symptoms include header fields with seemingly random values or queries failing to match responses.</p>\n<p>⚠️ <strong>Pitfall: Name Compression Infinite Loops</strong>\nMalicious or malformed DNS messages can contain compression pointer loops that cause infinite recursion during name parsing. Always track visited pointer offsets and abort parsing if a pointer is encountered twice. Implement a maximum pointer chain length (suggested: 63 hops) to prevent resource exhaustion.</p>\n<p>⚠️ <strong>Pitfall: Case Sensitivity in Domain Names</strong>\nDNS domain names are case-insensitive, but Go string comparisons are case-sensitive. Always normalize domain names to lowercase before comparison or use <code>strings.EqualFold()</code> for DNS name matching. This affects zone lookups, cache keys, and compression pointer matching.</p>\n<p>⚠️ <strong>Pitfall: TTL Arithmetic Underflow</strong>\nWhen caching records, calculate remaining TTL by subtracting elapsed time from original TTL. If elapsed time exceeds original TTL, the record has expired—don&#39;t return it with a negative or zero TTL. Use <code>time.Now()</code> consistently to avoid clock skew issues in TTL calculations.</p>\n<p>⚠️ <strong>Pitfall: UDP Message Size Limits</strong>\nStandard DNS over UDP has a 512-byte message size limit. If a response exceeds this limit, set the truncated flag and consider implementing TCP fallback. Large zone responses or many additional records can easily exceed UDP limits, causing client resolution failures.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundational understanding for all milestones (1-4)</p>\n</blockquote>\n<p>Building a DNS server requires orchestrating multiple specialized components that work together to receive queries, parse protocol messages, resolve domain names, and return responses. Think of this architecture like a <strong>well-organized library system</strong>: the UDP server acts as the front desk receiving requests, the message parser translates between different &quot;languages&quot; (binary protocol vs. internal structures), the resolver acts as a research librarian following leads to find information, the cache serves as recent memory for frequently requested items, and the zone data manager maintains the library&#39;s own collection of authoritative books.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"DNS Server System Components\"></p>\n<p>The DNS server architecture balances several competing concerns: protocol correctness, performance through caching, concurrent request handling, and extensibility for different resolution modes (authoritative vs. recursive). The modular design allows each component to focus on its specific responsibility while maintaining clean interfaces between components. This separation enables independent testing, easier debugging, and the flexibility to swap implementations (for example, using different caching strategies or storage backends) without affecting other components.</p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>The DNS server consists of five major components, each with distinct responsibilities and well-defined interfaces. These components form a pipeline that transforms incoming UDP packets into DNS responses, with caching and recursive resolution providing the intelligence needed for a complete DNS implementation.</p>\n<h4 id=\"udp-server-component\">UDP Server Component</h4>\n<p>The <strong>UDP Server</strong> serves as the network interface and coordination hub for the entire DNS server. Think of it as the <strong>receptionist at a busy office</strong> - it greets every visitor (incoming DNS query), ensures they&#39;re directed to the right department (message parsing and resolution), and makes sure they receive a proper response before leaving.</p>\n<p>The UDP server&#39;s primary responsibilities include binding to the DNS port (typically 53), receiving incoming packets from clients, spawning concurrent handlers for each query, and transmitting responses back to the correct client address. It also manages server lifecycle operations like graceful shutdown and connection error handling.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Binding</td>\n<td>Bind to UDP port 53 and listen for incoming packets</td>\n<td>Retry binding with exponential backoff, log fatal error if port unavailable</td>\n</tr>\n<tr>\n<td>Packet Reception</td>\n<td>Read UDP packets from network and extract client address</td>\n<td>Log malformed packets, continue serving other clients</td>\n</tr>\n<tr>\n<td>Concurrency Management</td>\n<td>Spawn goroutines for concurrent query processing</td>\n<td>Limit concurrent goroutines to prevent resource exhaustion</td>\n</tr>\n<tr>\n<td>Response Transmission</td>\n<td>Send DNS response packets back to querying clients</td>\n<td>Retry transmission once, log delivery failures</td>\n</tr>\n<tr>\n<td>Lifecycle Management</td>\n<td>Handle server startup, graceful shutdown, and cleanup</td>\n<td>Ensure in-flight queries complete before shutdown</td>\n</tr>\n</tbody></table>\n<p>The server maintains minimal state - primarily the network connection and configuration parameters. It delegates all DNS-specific processing to other components, maintaining a clean separation between network concerns and protocol logic.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The UDP server should be stateless regarding DNS queries themselves. All query-specific state lives in the handlers it spawns, allowing the server to scale horizontally and recover cleanly from individual query failures without affecting other concurrent requests.</p>\n</blockquote>\n<h4 id=\"message-parser-component\">Message Parser Component</h4>\n<p>The <strong>Message Parser</strong> handles the complex task of translating between the binary DNS wire format and internal Go data structures. Think of it as a <strong>skilled translator at the United Nations</strong> - it must perfectly understand both the formal binary &quot;language&quot; of DNS packets and the structured &quot;language&quot; of internal application data, ensuring nothing is lost or corrupted in translation.</p>\n<p>DNS messages follow the RFC 1035 specification with a fixed 12-byte header followed by variable-length sections. The parser must handle intricate details like network byte order conversion, DNS name compression using pointer labels, and validation of message structure constraints.</p>\n<table>\n<thead>\n<tr>\n<th>Component Function</th>\n<th>Input</th>\n<th>Output</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Parsing</td>\n<td>Raw UDP packet bytes</td>\n<td><code>DNSMessage</code> struct</td>\n<td>Truncated packet, invalid header, compression loops</td>\n</tr>\n<tr>\n<td>Header Extraction</td>\n<td>First 12 bytes of packet</td>\n<td><code>Header</code> struct with all flags</td>\n<td>Packet too short, reserved bits set</td>\n</tr>\n<tr>\n<td>Question Parsing</td>\n<td>Question section bytes</td>\n<td><code>[]Question</code> slice</td>\n<td>Invalid domain name, unsupported QTYPE</td>\n</tr>\n<tr>\n<td>Resource Record Parsing</td>\n<td>RR section bytes</td>\n<td><code>[]ResourceRecord</code> slice</td>\n<td>Invalid TTL, malformed RDATA, unknown type</td>\n</tr>\n<tr>\n<td>Message Construction</td>\n<td><code>DNSMessage</code> struct</td>\n<td>Wire format bytes</td>\n<td>Message too large, compression failure</td>\n</tr>\n</tbody></table>\n<p>The parser implements DNS name compression, a critical optimization where repeated domain names in a message use pointer labels (starting with bytes 0xC0) to reference earlier occurrences. This compression can reduce message size significantly but introduces complexity around validation and loop detection.</p>\n<blockquote>\n<p><strong>Critical Security Consideration</strong>: The parser must validate all compression pointers to prevent infinite loops and buffer overflows. A malicious packet with circular compression pointers could crash the server or enable memory corruption attacks.</p>\n</blockquote>\n<h4 id=\"recursive-resolver-component\">Recursive Resolver Component</h4>\n<p>The <strong>Recursive Resolver</strong> implements the core DNS resolution algorithm, transforming domain name queries into authoritative answers by following the DNS hierarchy. Think of it as a <strong>detective following clues</strong> - it starts with a basic question (&quot;What&#39;s the IP address of <a href=\"http://www.example.com\">www.example.com</a>?&quot;), follows a chain of evidence from root servers through TLD servers to authoritative servers, and assembles the final answer from multiple sources.</p>\n<p>The resolver maintains the complex state machine of iterative resolution: tracking which servers to query next, following NS referrals, handling CNAME chains, and assembling the final response. It must handle various edge cases like missing glue records, server timeouts, and delegation loops while maintaining the semantic correctness required by the DNS protocol.</p>\n<table>\n<thead>\n<tr>\n<th>Resolution Phase</th>\n<th>Action Taken</th>\n<th>Data Sources</th>\n<th>Failure Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Root Query</td>\n<td>Query root server for TLD NS records</td>\n<td>Root hints file</td>\n<td>Try alternate root servers</td>\n</tr>\n<tr>\n<td>TLD Query</td>\n<td>Query TLD server for domain NS records</td>\n<td>Root response referrals</td>\n<td>Follow additional TLD servers</td>\n</tr>\n<tr>\n<td>Authoritative Query</td>\n<td>Query domain&#39;s nameserver for final answer</td>\n<td>TLD response referrals</td>\n<td>Query alternate authoritative servers</td>\n</tr>\n<tr>\n<td>CNAME Following</td>\n<td>Resolve CNAME target recursively</td>\n<td>Authoritative server response</td>\n<td>Detect and break CNAME loops</td>\n</tr>\n<tr>\n<td>Response Assembly</td>\n<td>Combine results into final DNS message</td>\n<td>All resolution phases</td>\n<td>Return best partial answer available</td>\n</tr>\n</tbody></table>\n<p>The resolver integrates closely with both the cache (to avoid repeated queries) and the zone data manager (for authoritative responses). It must decide whether to perform recursive resolution, return cached results, or consult local zone data based on the query and server configuration.</p>\n<blockquote>\n<p><strong>Performance Insight</strong>: Recursive resolution can involve 3-10 network round-trips per query. Effective caching and glue record utilization are essential for acceptable performance. The resolver should also implement query pipelining and parallel resolution for independent subqueries.</p>\n</blockquote>\n<h4 id=\"cache-manager-component\">Cache Manager Component</h4>\n<p>The <strong>Cache Manager</strong> provides intelligent storage and retrieval of DNS records with TTL-based expiration and negative caching. Think of it as the <strong>librarian&#39;s short-term memory</strong> - it remembers recently looked-up information to avoid repeating expensive research, but it also knows when that information becomes stale and needs refreshing.</p>\n<p>The cache stores both positive responses (successful resolutions) and negative responses (NXDOMAIN and NODATA) with their appropriate TTL values. It must handle concurrent access from multiple query handlers while maintaining cache consistency and preventing memory exhaustion through intelligent eviction policies.</p>\n<table>\n<thead>\n<tr>\n<th>Cache Operation</th>\n<th>Input</th>\n<th>Output</th>\n<th>Side Effects</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache Lookup</td>\n<td>Domain name, record type</td>\n<td>Cached record or miss</td>\n<td>Update access time for LRU</td>\n</tr>\n<tr>\n<td>Cache Storage</td>\n<td>Resolved record with TTL</td>\n<td>Success/failure</td>\n<td>Evict expired or LRU entries</td>\n</tr>\n<tr>\n<td>TTL Management</td>\n<td>Timer events</td>\n<td>Expired entry removal</td>\n<td>Free memory, update statistics</td>\n</tr>\n<tr>\n<td>Negative Caching</td>\n<td>NXDOMAIN response</td>\n<td>Negative cache entry</td>\n<td>Prevent repeated failed queries</td>\n</tr>\n<tr>\n<td>Cache Invalidation</td>\n<td>Domain name pattern</td>\n<td>Removed entries</td>\n<td>Force fresh resolution</td>\n</tr>\n</tbody></table>\n<p>The cache implements several important optimizations: it respects the minimum TTL from SOA records for negative caching, it can perform cache warming by proactively refreshing popular entries before expiration, and it maintains statistics for cache hit rates and memory usage monitoring.</p>\n<blockquote>\n<p><strong>Security Consideration</strong>: The cache must validate that cached entries match the original query to prevent cache poisoning attacks. Records returned from recursive resolution should only be cached if they&#39;re &quot;in-bailiwick&quot; (within the expected domain hierarchy).</p>\n</blockquote>\n<h4 id=\"zone-data-manager-component\">Zone Data Manager Component</h4>\n<p>The <strong>Zone Data Manager</strong> handles authoritative DNS data loaded from zone files, providing the server&#39;s &quot;official&quot; knowledge about domains it&#39;s configured to serve. Think of it as the <strong>library&#39;s reference collection</strong> - these are the authoritative books the library owns and maintains, as opposed to information borrowed from other sources.</p>\n<p>The zone manager parses standard BIND-format zone files, validates record consistency, and provides efficient lookup capabilities for authoritative responses. It handles SOA records that define zone parameters, NS records that delegate subdomains, and various resource records (A, AAAA, CNAME, MX, etc.) that contain the actual zone data.</p>\n<table>\n<thead>\n<tr>\n<th>Zone Management Task</th>\n<th>Responsibilities</th>\n<th>Data Validation</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zone File Parsing</td>\n<td>Read BIND-format files into memory structures</td>\n<td>Check SOA presence, validate record syntax</td>\n<td>Log parse errors, skip invalid records</td>\n</tr>\n<tr>\n<td>Record Indexing</td>\n<td>Build efficient lookup structures by name and type</td>\n<td>Ensure CNAME exclusivity, validate delegations</td>\n<td>Warn about conflicts, apply precedence rules</td>\n</tr>\n<tr>\n<td>Authoritative Lookup</td>\n<td>Find matching records for queries</td>\n<td>Verify query is within zone&#39;s authority</td>\n<td>Return NXDOMAIN or referral as appropriate</td>\n</tr>\n<tr>\n<td>Zone Transfer Support</td>\n<td>Serialize zone data for AXFR/IXFR</td>\n<td>Maintain zone serial numbers and timestamps</td>\n<td>Handle concurrent transfer and update requests</td>\n</tr>\n<tr>\n<td>Dynamic Updates</td>\n<td>Process DNS UPDATE messages</td>\n<td>Validate update authorization and consistency</td>\n<td>Roll back failed multi-record updates</td>\n</tr>\n</tbody></table>\n<p>The zone manager must determine the appropriate response for queries: returning answer records for exact matches, authority records for delegations, and SOA records for negative responses. It also handles wildcard matching according to RFC 1034 specifications.</p>\n<blockquote>\n<p><strong>Operational Insight</strong>: Zone data should be reloadable without restarting the server. Implement a file watcher or periodic reload mechanism to pick up zone file changes, with careful coordination to avoid serving partial updates during reload operations.</p>\n</blockquote>\n<h3 id=\"architecture-decisions-for-component-design\">Architecture Decisions for Component Design</h3>\n<p>Several critical decisions shaped the component architecture, each involving trade-offs between performance, complexity, and maintainability.</p>\n<blockquote>\n<p><strong>Decision: Separate Parser from Network Layer</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS messages require complex binary parsing with validation, while network handling needs different error recovery and concurrency patterns</li>\n<li><strong>Options Considered</strong>: Combined network+parsing component, separate parser, streaming parser interface</li>\n<li><strong>Decision</strong>: Separate message parser component with complete message parsing</li>\n<li><strong>Rationale</strong>: Parsing errors should not affect network stability; different components can be optimized and tested independently; parser can be reused for zone file processing</li>\n<li><strong>Consequences</strong>: Enables clean unit testing of parsing logic; requires copying packet data between components; allows future optimization like message validation in separate goroutines</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Combined Network+Parser</td>\n<td>Fewer data copies, simpler interfaces</td>\n<td>Mixed concerns, harder testing, parsing errors affect network</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Separate Parser</td>\n<td>Clean separation, independent optimization</td>\n<td>Data copying overhead, more interfaces</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Streaming Parser</td>\n<td>Memory efficient for large messages</td>\n<td>Complex state management, harder error recovery</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Unified Resolver vs. Separate Authoritative/Recursive Components</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS servers can operate in authoritative-only, recursive-only, or hybrid modes with different resolution logic</li>\n<li><strong>Options Considered</strong>: Single resolver with mode flags, separate authoritative and recursive resolvers, resolver interface with multiple implementations</li>\n<li><strong>Decision</strong>: Single resolver component with pluggable strategies for authoritative vs. recursive resolution</li>\n<li><strong>Rationale</strong>: Many queries require both authoritative lookup (checking local zones) and recursive resolution (external queries); unified component can optimize the decision logic and share common code</li>\n<li><strong>Consequences</strong>: Enables hybrid operation modes; resolver component becomes more complex; easier to implement forwarding and conditional resolution policies</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: In-Memory Cache vs. External Cache Service</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS queries have high frequency and low latency requirements; cache needs TTL management and concurrent access</li>\n<li><strong>Options Considered</strong>: In-memory map with mutex, external Redis/Memcached, embedded database like SQLite</li>\n<li><strong>Decision</strong>: In-memory cache with TTL-based expiration and LRU eviction</li>\n<li><strong>Rationale</strong>: DNS query latency is critical (sub-millisecond cache lookups required); external cache adds network overhead; most DNS servers handle moderate cache sizes (1M+ records) in memory comfortably</li>\n<li><strong>Consequences</strong>: Enables microsecond cache lookups; cache lost on server restart; memory usage must be carefully managed; requires implementing TTL and eviction logic</li>\n</ul>\n</blockquote>\n<h3 id=\"component-interface-contracts\">Component Interface Contracts</h3>\n<p>The components communicate through well-defined interfaces that enable independent testing and future extensibility. These contracts specify the data formats, method signatures, and behavioral expectations for component interactions.</p>\n<h4 id=\"core-data-exchange-types\">Core Data Exchange Types</h4>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Fields</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DNSMessage</code></td>\n<td><code>Header Header, Questions []Question, Answers []ResourceRecord, Authority []ResourceRecord, Additional []ResourceRecord</code></td>\n<td>Complete DNS message representation for inter-component communication</td>\n</tr>\n<tr>\n<td><code>Header</code></td>\n<td><code>ID uint16, QueryResponse bool, Opcode uint8, Authoritative bool, Truncated bool, RecursionDesired bool, RecursionAvail bool, ResponseCode uint8, QuestionCount uint16, AnswerCount uint16, AuthorityCount uint16, AdditionalCount uint16</code></td>\n<td>DNS header with all flags and section counts</td>\n</tr>\n<tr>\n<td><code>Question</code></td>\n<td><code>Name string, Type uint16, Class uint16</code></td>\n<td>DNS query question specifying what record is requested</td>\n</tr>\n<tr>\n<td><code>ResourceRecord</code></td>\n<td><code>Name string, Type uint16, Class uint16, TTL uint32, Data []byte</code></td>\n<td>DNS resource record with type-specific data payload</td>\n</tr>\n<tr>\n<td><code>ResolverConfig</code></td>\n<td><code>RootHints []string, Timeout time.Duration, MaxDepth int, EnableRecursion bool</code></td>\n<td>Configuration parameters for resolver behavior</td>\n</tr>\n</tbody></table>\n<h4 id=\"message-parser-interface\">Message Parser Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ParseMessage</code></td>\n<td><code>data []byte</code></td>\n<td><code>*DNSMessage, error</code></td>\n<td>Parse complete DNS message from wire format bytes</td>\n</tr>\n<tr>\n<td><code>SerializeMessage</code></td>\n<td><code>msg *DNSMessage</code></td>\n<td><code>[]byte, error</code></td>\n<td>Convert DNS message to wire format for network transmission</td>\n</tr>\n<tr>\n<td><code>parseHeader</code></td>\n<td><code>data []byte</code></td>\n<td><code>Header, error</code></td>\n<td>Extract 12-byte header structure with validation</td>\n</tr>\n<tr>\n<td><code>parseName</code></td>\n<td><code>data []byte, offset int</code></td>\n<td><code>string, int, error</code></td>\n<td>Parse DNS name with compression support, returns name and new offset</td>\n</tr>\n<tr>\n<td><code>ValidateMessage</code></td>\n<td><code>msg *DNSMessage</code></td>\n<td><code>error</code></td>\n<td>Verify message structure and field consistency</td>\n</tr>\n</tbody></table>\n<h4 id=\"resolver-interface\">Resolver Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ResolveQuery</code></td>\n<td><code>ctx context.Context, question Question</code></td>\n<td><code>*DNSMessage, error</code></td>\n<td>Perform complete resolution for a DNS question</td>\n</tr>\n<tr>\n<td><code>LookupAuthoritative</code></td>\n<td><code>question Question</code></td>\n<td><code>[]ResourceRecord, error</code></td>\n<td>Check local zone data for authoritative answer</td>\n</tr>\n<tr>\n<td><code>LookupCache</code></td>\n<td><code>name string, recordType uint16</code></td>\n<td><code>*CacheEntry, bool</code></td>\n<td>Retrieve cached record if present and not expired</td>\n</tr>\n<tr>\n<td><code>PerformRecursion</code></td>\n<td><code>ctx context.Context, question Question</code></td>\n<td><code>*DNSMessage, error</code></td>\n<td>Execute iterative resolution from root servers</td>\n</tr>\n<tr>\n<td><code>FollowCNAME</code></td>\n<td><code>ctx context.Context, cname string, originalType uint16</code></td>\n<td><code>[]ResourceRecord, error</code></td>\n<td>Resolve CNAME chain to final target records</td>\n</tr>\n</tbody></table>\n<h4 id=\"cache-manager-interface\">Cache Manager Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Get</code></td>\n<td><code>key CacheKey</code></td>\n<td><code>*CacheEntry, bool</code></td>\n<td>Retrieve cache entry if present and valid</td>\n</tr>\n<tr>\n<td><code>Put</code></td>\n<td><code>key CacheKey, records []ResourceRecord, ttl uint32</code></td>\n<td><code>error</code></td>\n<td>Store records with TTL-based expiration</td>\n</tr>\n<tr>\n<td><code>PutNegative</code></td>\n<td><code>key CacheKey, soaRecord ResourceRecord</code></td>\n<td><code>error</code></td>\n<td>Cache negative response with SOA-derived TTL</td>\n</tr>\n<tr>\n<td><code>Evict</code></td>\n<td><code>key CacheKey</code></td>\n<td><code>bool</code></td>\n<td>Remove specific entry from cache</td>\n</tr>\n<tr>\n<td><code>Cleanup</code></td>\n<td></td>\n<td><code>int</code></td>\n<td>Remove expired entries and return count freed</td>\n</tr>\n<tr>\n<td><code>Stats</code></td>\n<td></td>\n<td><code>CacheStats</code></td>\n<td>Return cache hit rate, size, and memory usage statistics</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-component-pitfalls\">Common Component Pitfalls</h3>\n<p>Understanding these common mistakes helps avoid architectural problems that can be difficult to fix later in the implementation.</p>\n<p>⚠️ <strong>Pitfall: Blocking Network Operations in Parser</strong>\nDNS message parsing should never perform network I/O or other blocking operations. The parser component should be a pure function that transforms bytes to structures and back. Including network calls (like recursive lookups triggered by parsing) creates tight coupling and makes the parser impossible to unit test reliably. Instead, parsing should only validate message structure and extract data, leaving all network operations to the resolver component.</p>\n<p>⚠️ <strong>Pitfall: Shared Mutable State Between Components</strong>\nAvoid sharing mutable data structures directly between components, especially the cache and resolver. For example, if the resolver modifies a <code>ResourceRecord</code> slice returned by the cache, it can corrupt cached data for future queries. Instead, components should return copies of data or use immutable structures. The cache should clone records before returning them, and the resolver should never modify records in place.</p>\n<p>⚠️ <strong>Pitfall: Ignoring DNS Message Size Limits</strong>\nUDP DNS messages are limited to 512 bytes unless EDNS is negotiated. The message serializer must check message size during construction and set the truncation flag if the response doesn&#39;t fit. A common mistake is building the complete response in memory and then discovering it&#39;s too large, requiring expensive reconstruction. Instead, track message size during construction and truncate gracefully when approaching limits.</p>\n<p>⚠️ <strong>Pitfall: Cache Inconsistency During Concurrent Updates</strong>\nThe cache manager must handle concurrent reads and writes carefully. A naive implementation might have race conditions where a cache entry is partially updated during TTL expiration, leading to corrupted responses. Use appropriate locking (typically a read-write mutex) and ensure that cache operations are atomic. Consider implementing a copy-on-write strategy for cache entries that are being read by multiple goroutines.</p>\n<p>⚠️ <strong>Pitfall: Resource Leaks in Concurrent Query Handling</strong>\nEach incoming DNS query spawns a goroutine for handling, but without proper resource management, this can lead to goroutine leaks and memory exhaustion under high load. Implement a semaphore or worker pool to limit concurrent queries, and ensure that all goroutines terminate properly even when network errors or timeouts occur. Use context cancellation to clean up abandoned queries.</p>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>The DNS server should be organized into a modular package structure that reflects the component architecture while following Go conventions for project layout. This organization enables independent development and testing of components while maintaining clear dependency relationships.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>dns-server/\n├── cmd/\n│   └── dns-server/\n│       └── main.go                 # Server entry point and configuration loading\n├── internal/\n│   ├── server/\n│   │   ├── server.go              # UDP server component with concurrent query handling\n│   │   ├── handler.go             # Query processing pipeline coordination\n│   │   └── server_test.go         # Integration tests for server component\n│   ├── parser/\n│   │   ├── message.go             # DNS message parsing and serialization\n│   │   ├── compression.go         # DNS name compression implementation\n│   │   ├── types.go               # DNS message data structures\n│   │   └── parser_test.go         # Comprehensive parsing validation tests\n│   ├── resolver/\n│   │   ├── resolver.go            # Main resolver logic and query coordination\n│   │   ├── recursive.go           # Iterative resolution algorithm\n│   │   ├── authoritative.go       # Zone data lookup and authoritative responses\n│   │   ├── root_hints.go          # Root server bootstrap data\n│   │   └── resolver_test.go       # Resolution algorithm tests\n│   ├── cache/\n│   │   ├── cache.go               # TTL-based caching with concurrent access\n│   │   ├── entry.go               # Cache entry data structures and TTL management\n│   │   ├── negative.go            # Negative caching for NXDOMAIN responses\n│   │   └── cache_test.go          # Cache behavior and eviction tests\n│   ├── zones/\n│   │   ├── manager.go             # Zone data loading and management\n│   │   ├── parser.go              # BIND zone file parsing\n│   │   ├── lookup.go              # Efficient zone data lookup algorithms\n│   │   └── zones_test.go          # Zone loading and lookup tests\n│   └── config/\n│       ├── config.go              # Configuration data structures and loading\n│       ├── validation.go          # Configuration validation and defaults\n│       └── config_test.go         # Configuration loading tests\n├── pkg/\n│   └── dns/\n│       ├── constants.go           # DNS protocol constants and record types\n│       ├── errors.go              # DNS-specific error types and handling\n│       └── utils.go               # Common DNS utility functions\n├── test/\n│   ├── integration/\n│   │   ├── server_test.go         # End-to-end server testing\n│   │   └── testdata/              # Sample zone files and test queries\n│   └── fixtures/\n│       ├── messages/              # Binary DNS message test cases\n│       └── zones/                 # Sample zone files for testing\n├── configs/\n│   ├── server.yaml                # Example server configuration\n│   ├── root-hints.txt             # Root server IP addresses\n│   └── example.com.zone           # Example zone file\n└── docs/\n    ├── setup.md                   # Installation and setup instructions\n    └── configuration.md           # Configuration reference</code></pre></div>\n\n<p>The <code>internal/</code> directory contains the core server implementation with each component in its own package. This prevents external packages from importing internal implementation details while enabling clean interfaces between components. The <code>pkg/dns/</code> directory provides reusable DNS utilities that could potentially be used by external packages.</p>\n<p>Test organization separates unit tests (alongside their components), integration tests (in <code>test/integration/</code>), and test fixtures (binary data and zone files). This structure supports both fast unit testing during development and comprehensive integration testing for release validation.</p>\n<p>Configuration files are separated from code to enable deployment-time customization without rebuilding. The <code>configs/</code> directory provides templates and examples that can be copied and modified for specific deployment environments.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Implementation</th>\n<th>Advanced Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UDP Server</td>\n<td><code>net.PacketConn</code> with <code>go handleQuery()</code> per request</td>\n<td>Worker pool with <code>golang.org/x/sync/semaphore</code> for rate limiting</td>\n</tr>\n<tr>\n<td>Message Parser</td>\n<td>Manual byte slicing with <code>binary</code> package</td>\n<td>Code generation from DNS schema definitions</td>\n</tr>\n<tr>\n<td>Cache Storage</td>\n<td><code>sync.Map</code> with TTL cleanup goroutine</td>\n<td><code>github.com/patrickmn/go-cache</code> with LRU and metrics</td>\n</tr>\n<tr>\n<td>Zone File Parsing</td>\n<td>Custom parser with <code>bufio.Scanner</code></td>\n<td><code>github.com/miekg/dns</code> zone parser library</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td><code>gopkg.in/yaml.v3</code> for YAML config files</td>\n<td><code>github.com/spf13/viper</code> with multiple format support</td>\n</tr>\n</tbody></table>\n<p>For the initial implementation, prioritize the simple options to focus on learning DNS protocol concepts. The advanced options can be adopted later for production deployments or performance optimization.</p>\n<h4 id=\"core-server-infrastructure\">Core Server Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package server provides the UDP DNS server implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">dns-server/internal/parser</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">dns-server/internal/resolver</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Server represents a DNS server instance with UDP networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Server</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn     </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PacketConn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resolver </span><span style=\"color:#B392F0\">resolver</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Resolver</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handler  </span><span style=\"color:#B392F0\">MessageHandler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    readTimeout  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    writeTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxWorkers   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Runtime state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    workers </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}  </span><span style=\"color:#6A737D\">// Semaphore for limiting concurrent queries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shutdown </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MessageHandler defines the interface for processing DNS queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageHandler</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HandleQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">parser</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">clientAddr</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Addr</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">parser</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewServer creates a DNS server instance ready for listening</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">resolver</span><span style=\"color:#B392F0\"> resolver</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Resolver</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#B392F0\"> MessageHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize server struct with provided parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set reasonable default timeouts (5s read, 2s write)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize worker semaphore with maxWorkers capacity (default 100)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create shutdown channel for graceful termination</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\">  // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins listening for DNS queries and handling them concurrently</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create UDP listener on configured address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Store connection in s.conn for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start main receive loop with context cancellation support</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each received packet, acquire worker semaphore and spawn handleQuery goroutine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle shutdown signal and close connection gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use net.ListenPacket(\"udp\", addr) and conn.ReadFrom for packet reception</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"dns-message-data-structures\">DNS Message Data Structures</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package parser provides DNS message parsing and serialization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> parser</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DNSMessage represents a complete DNS message with all sections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DNSMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Header     </span><span style=\"color:#B392F0\">Header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Questions  []</span><span style=\"color:#B392F0\">Question</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Answers    []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authority  []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Additional []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Header represents the 12-byte DNS message header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Header</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID              </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueryResponse   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // false for query, true for response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Opcode          </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">   // usually 0 for standard query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authoritative   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if authoritative answer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Truncated       </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if message was truncated</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursionDesired </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // true if recursion requested</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursionAvail   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // true if recursion available</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponseCode     </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">  // 0 for success, 1 for format error, 3 for NXDOMAIN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Section counts (set automatically during serialization)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QuestionCount   </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AnswerCount     </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuthorityCount  </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdditionalCount </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Question represents a DNS query question</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Question</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Domain name being queried (e.g., \"example.com\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Record type (1 for A, 28 for AAAA, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Class </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Usually 1 for Internet class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceRecord represents any DNS resource record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Domain name this record belongs to</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Record type (matches Question.Type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Class </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Usually 1 for Internet class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TTL   </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Time-to-live in seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Data  []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // Type-specific record data (IP address, domain name, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseMessage converts wire-format DNS message bytes into structured data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate minimum message size (12 bytes for header)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse header using parseHeader function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Parse question section based on header.QuestionCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse answer section based on header.AnswerCount  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Parse authority section based on header.AuthorityCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Parse additional section based on header.AdditionalCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate that all bytes were consumed (no trailing data)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Keep track of current offset as you parse each section</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"basic-cache-interface\">Basic Cache Interface</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package cache provides TTL-based DNS record caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cache</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">dns-server/internal/parser</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cache provides concurrent-safe DNS record caching with TTL expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Cache</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entries </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">CacheKey</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex   </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxSize    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    defaultTTL </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanup    </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CacheKey uniquely identifies a cached DNS record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Domain name (normalized to lowercase)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // DNS record type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Class </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // DNS class (usually 1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CacheEntry represents a cached DNS record with expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Records   []</span><span style=\"color:#B392F0\">parser</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExpiresAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Negative  </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // true for NXDOMAIN/NODATA responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCache creates a cache with specified configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCache</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxSize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">defaultTTL</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cache</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize cache struct with empty entries map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start background cleanup goroutine (runs every minute)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set configuration parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get retrieves a cached entry if present and not expired</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire read lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Look up entry in map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if entry has expired (time.Now().After(entry.ExpiresAt))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return copy of entry (don't return pointer to internal data)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Always return copies to prevent callers from modifying cache data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone 1 Checkpoint: Message Parsing</strong>\nAfter implementing the parser component, verify correct behavior:</p>\n<ul>\n<li>Run <code>go test ./internal/parser/...</code> - all parsing tests should pass</li>\n<li>Test with sample DNS query: <code>dig @127.0.0.1 -p 8053 example.com</code> </li>\n<li>Expected: Server receives packet, parses header correctly, extracts question</li>\n<li>Debug: Add logging to see parsed header fields and question details</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint: Basic Server</strong>\nAfter implementing UDP server and basic response handling:</p>\n<ul>\n<li>Run <code>go run cmd/dns-server/main.go</code> to start server</li>\n<li>Test with <code>dig @127.0.0.1 -p 8053 test.local</code></li>\n<li>Expected: Server responds with basic DNS response (even if empty)</li>\n<li>Debug: Use Wireshark to capture packets and verify response format</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint: Component Integration</strong>\nAfter connecting all components:</p>\n<ul>\n<li>Test authoritative responses for local zones</li>\n<li>Test recursive resolution for external domains  </li>\n<li>Expected: Different response types based on query and configuration</li>\n<li>Debug: Add logging at component boundaries to trace query flow</li>\n</ul>\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>Go-Specific DNS Implementation Guidance:</strong></p>\n<ul>\n<li>Use <code>binary.BigEndian</code> for all DNS header field parsing - DNS uses network byte order</li>\n<li>Implement <code>String()</code> methods on DNS types for debugging - extremely helpful for tracing message flow</li>\n<li>Use <code>context.WithTimeout()</code> for all network operations to prevent hanging on unresponsive servers</li>\n<li>The <code>net</code> package&#39;s <code>SplitHostPort()</code> handles IPv6 addresses correctly for client address parsing</li>\n<li>Use <code>sync.RWMutex</code> for cache access - many concurrent reads, fewer writes</li>\n<li>Implement graceful shutdown with <code>context.CancelFunc</code> and proper connection cleanup</li>\n<li>Use buffered channels for the worker semaphore to prevent goroutine blocking</li>\n</ul>\n<p><strong>Testing and Debugging:</strong></p>\n<ul>\n<li>Install <code>dig</code> for manual DNS testing: <code>apt-get install dnsutils</code> or <code>brew install bind</code></li>\n<li>Use <code>go run -race</code> to detect concurrent access bugs in cache and server components  </li>\n<li>Wireshark with DNS filter helps debug protocol-level issues</li>\n<li>Add structured logging with request IDs to trace queries through components</li>\n</ul>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1 (DNS Message Parsing), 2 (Authoritative Server), 3 (Recursive Resolver), 4 (Caching &amp; Performance)</p>\n</blockquote>\n<h3 id=\"mental-model-dns-data-as-structured-documents\">Mental Model: DNS Data as Structured Documents</h3>\n<p>Think of DNS data structures as organized filing systems in a large corporation. The <strong>DNS message</strong> is like an inter-office memo with a standard header containing routing information (sender, recipient, message type) followed by structured sections for questions, answers, and supporting documents. The <strong>resource records</strong> are like individual file folders, each labeled with a name, category, and expiration date, containing specific information about network resources. The <strong>cache</strong> functions like a secretary&#39;s desk drawer of frequently referenced documents, automatically discarding outdated papers when their expiration dates pass. Finally, <strong>zone data</strong> resembles the authoritative filing cabinets maintained by each department, containing the definitive records for their area of responsibility.</p>\n<p>This mental model helps understand why DNS parsing requires careful attention to structure—just as a misfiled memo can disrupt business operations, a malformed DNS message can break name resolution. The binary wire format is like using a standardized inter-office mail system where every memo follows identical formatting rules for reliable delivery across different departments and buildings.</p>\n<p>The DNS protocol&#39;s design reflects the need for efficient transmission over unreliable networks, similar to how corporate memos use concise, structured formats to ensure clear communication even when photocopied or faxed multiple times. Name compression in DNS messages is analogous to using departmental abbreviations and reference numbers to keep memos short while maintaining all necessary information.</p>\n<h3 id=\"dns-message-format\">DNS Message Format</h3>\n<p>The DNS message structure forms the foundation of all communication in the DNS protocol, serving as the container for queries and responses flowing between clients and servers. Understanding this format in detail is crucial because every DNS operation—from simple lookups to complex recursive resolution—relies on correctly parsing and constructing these binary messages.</p>\n<p>The complete DNS message consists of five distinct sections that must be processed in order: the fixed-length header containing metadata and section counts, the question section describing what information is being requested, and three variable-length resource record sections containing the actual DNS data. This hierarchical structure allows DNS messages to carry complex information while maintaining backward compatibility and efficient network transmission.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: DNS messages use a binary wire format optimized for network transmission, not human readability. Every field has a precise byte layout and endianness requirement that must be followed exactly for interoperability with other DNS implementations.</p>\n</blockquote>\n<h4 id=\"dns-message-structure-overview\">DNS Message Structure Overview</h4>\n<table>\n<thead>\n<tr>\n<th>Section</th>\n<th>Purpose</th>\n<th>Count Field</th>\n<th>Content</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Header</td>\n<td>Message metadata and flags</td>\n<td>Fixed 12 bytes</td>\n<td>ID, flags, section counts</td>\n</tr>\n<tr>\n<td>Questions</td>\n<td>Query specifications</td>\n<td><code>QuestionCount</code></td>\n<td>Domain name, record type, class</td>\n</tr>\n<tr>\n<td>Answers</td>\n<td>Direct responses to questions</td>\n<td><code>AnswerCount</code></td>\n<td>Resource records matching query</td>\n</tr>\n<tr>\n<td>Authority</td>\n<td>Authoritative information</td>\n<td><code>AuthorityCount</code></td>\n<td>NS records or SOA for delegation</td>\n</tr>\n<tr>\n<td>Additional</td>\n<td>Supporting information</td>\n<td><code>AdditionalCount</code></td>\n<td>Glue records, additional data</td>\n</tr>\n</tbody></table>\n<h4 id=\"header-structure-details\">Header Structure Details</h4>\n<p>The DNS header occupies exactly 12 bytes and contains all the metadata necessary for message routing, type identification, and response correlation. Every field in the header serves a specific purpose in the DNS protocol state machine, from matching responses to queries through the ID field to indicating whether recursion is desired or available.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Bits</th>\n<th>Purpose</th>\n<th>Values</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>uint16</code></td>\n<td>16</td>\n<td>Query/response correlation</td>\n<td>0-65535, client chosen</td>\n</tr>\n<tr>\n<td><code>QueryResponse</code></td>\n<td><code>bool</code></td>\n<td>1</td>\n<td>Message type indicator</td>\n<td>false=query, true=response</td>\n</tr>\n<tr>\n<td><code>Opcode</code></td>\n<td><code>uint8</code></td>\n<td>4</td>\n<td>Operation type</td>\n<td>0=query, 1=inverse query, 2=status</td>\n</tr>\n<tr>\n<td><code>Authoritative</code></td>\n<td><code>bool</code></td>\n<td>1</td>\n<td>Authoritative answer flag</td>\n<td>true if server is authoritative</td>\n</tr>\n<tr>\n<td><code>Truncated</code></td>\n<td><code>bool</code></td>\n<td>1</td>\n<td>Message truncation flag</td>\n<td>true if message was truncated</td>\n</tr>\n<tr>\n<td><code>RecursionDesired</code></td>\n<td><code>bool</code></td>\n<td>1</td>\n<td>Client recursion request</td>\n<td>true if client wants recursion</td>\n</tr>\n<tr>\n<td><code>RecursionAvail</code></td>\n<td><code>bool</code></td>\n<td>1</td>\n<td>Server recursion capability</td>\n<td>true if server supports recursion</td>\n</tr>\n<tr>\n<td><code>Reserved</code></td>\n<td><code>uint8</code></td>\n<td>3</td>\n<td>Reserved for future use</td>\n<td>Must be zero</td>\n</tr>\n<tr>\n<td><code>ResponseCode</code></td>\n<td><code>uint8</code></td>\n<td>4</td>\n<td>Response status</td>\n<td>0=no error, 3=NXDOMAIN, etc.</td>\n</tr>\n<tr>\n<td><code>QuestionCount</code></td>\n<td><code>uint16</code></td>\n<td>16</td>\n<td>Number of questions</td>\n<td>Usually 1 for standard queries</td>\n</tr>\n<tr>\n<td><code>AnswerCount</code></td>\n<td><code>uint16</code></td>\n<td>16</td>\n<td>Number of answer records</td>\n<td>Set by responding server</td>\n</tr>\n<tr>\n<td><code>AuthorityCount</code></td>\n<td><code>uint16</code></td>\n<td>16</td>\n<td>Number of authority records</td>\n<td>NS or SOA records</td>\n</tr>\n<tr>\n<td><code>AdditionalCount</code></td>\n<td><code>uint16</code></td>\n<td>16</td>\n<td>Number of additional records</td>\n<td>Glue records, OPT records</td>\n</tr>\n</tbody></table>\n<p>The header flags encode critical protocol state information that determines how both clients and servers process the message. The <code>QueryResponse</code> bit distinguishes between queries flowing from client to server and responses flowing back. The <code>Authoritative</code> bit indicates whether the responding server has definitive knowledge of the requested domain, which affects caching behavior and trust decisions.</p>\n<p>The recursion flags (<code>RecursionDesired</code> and <code>RecursionAvail</code>) establish a contract between client and server about resolution responsibility. When a client sets <code>RecursionDesired</code> to true, it&#39;s asking the server to perform complete resolution rather than just returning referrals. The server indicates its willingness to perform recursion through the <code>RecursionAvail</code> flag in its responses.</p>\n<blockquote>\n<p><strong>Decision: 16-bit Network Byte Order for All Multi-byte Fields</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS messages traverse networks with different endianness architectures</li>\n<li><strong>Options Considered</strong>: Host byte order, network byte order, little-endian</li>\n<li><strong>Decision</strong>: Use network byte order (big-endian) for all multi-byte fields</li>\n<li><strong>Rationale</strong>: RFC 1035 mandates network byte order for DNS wire format; ensures interoperability across all platforms and network equipment</li>\n<li><strong>Consequences</strong>: Requires explicit byte order conversion on little-endian systems but guarantees protocol compliance</li>\n</ul>\n</blockquote>\n<h4 id=\"question-section-structure\">Question Section Structure</h4>\n<p>The question section specifies what information the client is requesting from the DNS server. Each question contains three components: the domain name being queried, the type of resource record requested, and the protocol class (almost always Internet class). While the DNS protocol technically supports multiple questions in a single message, standard practice uses exactly one question per message to avoid implementation complexity and ambiguity in responses.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Format</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>DNS name encoding</td>\n<td>Domain name being queried</td>\n</tr>\n<tr>\n<td><code>Type</code></td>\n<td><code>uint16</code></td>\n<td>Network byte order</td>\n<td>Resource record type (A, AAAA, CNAME, etc.)</td>\n</tr>\n<tr>\n<td><code>Class</code></td>\n<td><code>uint16</code></td>\n<td>Network byte order</td>\n<td>Protocol class (1=Internet, others deprecated)</td>\n</tr>\n</tbody></table>\n<p>The domain name encoding follows DNS label format where each label is prefixed by its length as a single byte, with the entire name terminated by a zero-length label. This format allows efficient parsing while supporting name compression through pointer labels that reference previously occurring names in the same message.</p>\n<p>Common record types include A (IPv4 address), AAAA (IPv6 address), CNAME (canonical name alias), MX (mail exchange), NS (name server), SOA (start of authority), and TXT (text data). The numeric values for these types are standardized across all DNS implementations, ensuring consistent interpretation regardless of software vendor or platform.</p>\n<h4 id=\"resource-record-structure\">Resource Record Structure</h4>\n<p>Resource records carry the actual DNS data in the answer, authority, and additional sections of DNS messages. Each resource record follows an identical header format containing the name, type, class, and TTL, followed by variable-length data specific to the record type. This consistent structure allows generic parsing code to handle all record types while delegating type-specific interpretation to specialized handlers.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n<th>Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Domain name this record describes</td>\n<td>DNS name format, compression allowed</td>\n</tr>\n<tr>\n<td><code>Type</code></td>\n<td><code>uint16</code></td>\n<td>Resource record type</td>\n<td>Standard IANA registry values</td>\n</tr>\n<tr>\n<td><code>Class</code></td>\n<td><code>uint16</code></td>\n<td>Protocol class</td>\n<td>1 for Internet class</td>\n</tr>\n<tr>\n<td><code>TTL</code></td>\n<td><code>uint32</code></td>\n<td>Time-to-live in seconds</td>\n<td>0 to 2^31-1, cache expiration time</td>\n</tr>\n<tr>\n<td><code>DataLength</code></td>\n<td><code>uint16</code></td>\n<td>Length of data field in bytes</td>\n<td>Wire format only, not in internal representation</td>\n</tr>\n<tr>\n<td><code>Data</code></td>\n<td><code>[]byte</code></td>\n<td>Type-specific resource data</td>\n<td>Format depends on record type</td>\n</tr>\n</tbody></table>\n<p>The TTL field serves dual purposes: it indicates how long the record remains valid for caching purposes, and it provides a mechanism for zone administrators to control cache behavior across the internet. Short TTL values allow rapid updates but increase query load, while long TTL values reduce load but slow propagation of changes.</p>\n<blockquote>\n<p><strong>Decision: Raw Bytes for Resource Record Data Storage</strong></p>\n<ul>\n<li><strong>Context</strong>: Different record types have vastly different data formats and parsing requirements</li>\n<li><strong>Options Considered</strong>: Type-specific structs, interface{} with type switching, raw byte storage</li>\n<li><strong>Decision</strong>: Store resource record data as raw bytes with type-specific parsing on demand</li>\n<li><strong>Rationale</strong>: Avoids complex type hierarchies; enables efficient message forwarding without re-parsing; supports unknown record types for future extensibility</li>\n<li><strong>Consequences</strong>: Requires type-specific parsing functions but simplifies core message handling and storage</li>\n</ul>\n</blockquote>\n<h4 id=\"name-compression-algorithm\">Name Compression Algorithm</h4>\n<p>DNS name compression reduces message size by replacing repeated domain names with pointers to earlier occurrences in the same message. This optimization is crucial for DNS performance because many messages contain multiple references to the same domain names, particularly in authority and additional sections where NS records and their corresponding A records appear together.</p>\n<p>The compression mechanism uses a special label format where the first two bits are set to 11 (binary), indicating a pointer label rather than a regular length-prefixed label. The remaining 14 bits contain an offset from the beginning of the DNS message to the location where the full name appears. This allows names to be referenced without duplication while maintaining the ability to parse names without lookahead.</p>\n<p><strong>Compression Parsing Algorithm:</strong></p>\n<ol>\n<li><strong>Initialize</strong> parsing state with current position and empty name buffer</li>\n<li><strong>Read label length byte</strong> from current position in message</li>\n<li><strong>Check label type</strong> using the top two bits of the length byte</li>\n<li><strong>If regular label</strong> (bits 00): read specified number of characters, append to name with dot separator, advance position</li>\n<li><strong>If compression pointer</strong> (bits 11): extract 14-bit offset, validate it points earlier in message, recursively parse name at offset location</li>\n<li><strong>If end of name</strong> (length 0): terminate parsing and return complete name</li>\n<li><strong>Repeat</strong> from step 2 until name termination or pointer resolution</li>\n</ol>\n<p>The compression algorithm must include cycle detection to prevent infinite loops when malformed messages contain circular pointer references. A robust implementation tracks visited positions during pointer following and rejects messages that revisit any position during name parsing.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Compression Pointer Loops</strong>\nMalicious or corrupted messages may contain compression pointers that create cycles, causing parsers to loop infinitely. Always track visited positions during pointer following and reject messages that revisit any position during name resolution. Set a maximum recursion depth (typically 255) to bound worst-case parsing time even without explicit cycle detection.</p>\n</blockquote>\n<h4 id=\"message-size-and-truncation-handling\">Message Size and Truncation Handling</h4>\n<p>DNS messages over UDP are limited to 512 bytes by default, reflecting historical limitations of early internet infrastructure. When a complete response exceeds this limit, servers set the truncated flag in the header and client implementations must retry the query over TCP to receive the complete answer. This size constraint significantly influences DNS message design and caching strategies.</p>\n<p>Modern DNS extensions like EDNS0 allow clients to advertise support for larger UDP messages, but implementations must still handle the 512-byte baseline for compatibility. The truncation mechanism provides a graceful fallback that maintains functionality while encouraging the use of more efficient UDP transport for typical queries.</p>\n<p><strong>Message Size Considerations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Typical Size</th>\n<th>Maximum Size</th>\n<th>Impact on Design</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Header</td>\n<td>12 bytes</td>\n<td>12 bytes</td>\n<td>Fixed overhead for all messages</td>\n</tr>\n<tr>\n<td>Question</td>\n<td>20-50 bytes</td>\n<td>255 bytes</td>\n<td>Domain name length dominates</td>\n</tr>\n<tr>\n<td>A Record</td>\n<td>16 bytes</td>\n<td>16 bytes</td>\n<td>Fixed size, efficient packing</td>\n</tr>\n<tr>\n<td>AAAA Record</td>\n<td>28 bytes</td>\n<td>28 bytes</td>\n<td>Larger than A, affects message capacity</td>\n</tr>\n<tr>\n<td>CNAME Record</td>\n<td>20-100 bytes</td>\n<td>Variable</td>\n<td>Name length dependent</td>\n</tr>\n<tr>\n<td>MX Record</td>\n<td>25-75 bytes</td>\n<td>Variable</td>\n<td>Priority + name length</td>\n</tr>\n</tbody></table>\n<p>The size constraints encourage DNS architects to design zones with shorter domain names and to use caching aggressively to minimize query repetition. Server implementations must carefully manage response construction to prioritize the most important information when approaching size limits.</p>\n<h3 id=\"cache-and-zone-data-structures\">Cache and Zone Data Structures</h3>\n<p>The internal data structures for caching and zone storage form the performance-critical foundation of the DNS server, directly impacting query response times and memory efficiency. These structures must balance fast lookup performance with efficient memory usage while supporting the complex expiration and validation requirements of the DNS protocol.</p>\n<p>Cache and zone data serve fundamentally different purposes within the DNS server architecture. Zone data represents authoritative information loaded from configuration files, providing definitive answers for domains under the server&#39;s authority. Cache data stores temporary copies of records obtained through recursive resolution, with automatic expiration based on TTL values and validation requirements to prevent cache poisoning attacks.</p>\n<h4 id=\"cache-key-and-entry-structure\">Cache Key and Entry Structure</h4>\n<p>The cache system uses a composite key structure that uniquely identifies DNS records for storage and retrieval while supporting efficient lookup operations. The key combines the domain name, record type, and class into a single lookup identifier that handles case-insensitivity requirements and supports negative caching for non-existent domains.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n<th>Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Domain name (normalized)</td>\n<td>Lowercase, fully qualified</td>\n</tr>\n<tr>\n<td><code>Type</code></td>\n<td><code>uint16</code></td>\n<td>Resource record type</td>\n<td>Standard IANA values</td>\n</tr>\n<tr>\n<td><code>Class</code></td>\n<td><code>uint16</code></td>\n<td>Protocol class</td>\n<td>Always 1 for Internet</td>\n</tr>\n</tbody></table>\n<p><strong>Cache Entry Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n<th>Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Records</code></td>\n<td><code>[]ResourceRecord</code></td>\n<td>Cached resource records</td>\n<td>Empty for negative cache entries</td>\n</tr>\n<tr>\n<td><code>ExpiresAt</code></td>\n<td><code>time.Time</code></td>\n<td>Absolute expiration time</td>\n<td>Calculated from TTL at insert time</td>\n</tr>\n<tr>\n<td><code>Negative</code></td>\n<td><code>bool</code></td>\n<td>Indicates NXDOMAIN/NODATA</td>\n<td>True for negative cache entries</td>\n</tr>\n<tr>\n<td><code>SOARecord</code></td>\n<td><code>ResourceRecord</code></td>\n<td>Authority for negative entries</td>\n<td>Required for negative caching</td>\n</tr>\n<tr>\n<td><code>InsertTime</code></td>\n<td><code>time.Time</code></td>\n<td>When entry was cached</td>\n<td>For cache statistics and debugging</td>\n</tr>\n</tbody></table>\n<p>The cache entry structure supports both positive caching (storing actual resource records) and negative caching (remembering that a domain or record type doesn&#39;t exist). Negative caching prevents repeated queries for non-existent domains, significantly reducing recursive resolution load for typos and malicious domain queries.</p>\n<blockquote>\n<p><strong>Decision: Absolute Expiration Times vs. TTL Storage</strong></p>\n<ul>\n<li><strong>Context</strong>: Cache entries need expiration tracking for TTL compliance</li>\n<li><strong>Options Considered</strong>: Store original TTL and calculate age, store absolute expiration time, hybrid approach</li>\n<li><strong>Decision</strong>: Store absolute expiration time calculated at insertion</li>\n<li><strong>Rationale</strong>: Eliminates repeated time calculations during cache lookups; simplifies expiration checking; avoids clock skew issues during long-running operations</li>\n<li><strong>Consequences</strong>: Requires time zone consistency but provides faster cache operations and simpler expiration logic</li>\n</ul>\n</blockquote>\n<h4 id=\"zone-data-organization\">Zone Data Organization</h4>\n<p>Zone data represents the authoritative DNS records loaded from configuration files, organized for efficient querying by domain name and record type. The zone structure must support wildcard matching, delegation detection, and SOA record management while providing fast lookup performance for authoritative queries.</p>\n<p><strong>Zone Configuration Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Domain</code></td>\n<td><code>string</code></td>\n<td>Zone apex domain</td>\n<td>&quot;example.com.&quot;</td>\n</tr>\n<tr>\n<td><code>File</code></td>\n<td><code>string</code></td>\n<td>Zone file path</td>\n<td>&quot;/etc/dns/example.com.zone&quot;</td>\n</tr>\n<tr>\n<td><code>SOA</code></td>\n<td><code>ResourceRecord</code></td>\n<td>Start of authority record</td>\n<td>Contains refresh, retry, expire timers</td>\n</tr>\n<tr>\n<td><code>Records</code></td>\n<td><code>map[string][]ResourceRecord</code></td>\n<td>Name to record mapping</td>\n<td>Indexed by fully qualified domain name</td>\n</tr>\n<tr>\n<td><code>Delegations</code></td>\n<td><code>map[string][]ResourceRecord</code></td>\n<td>Subdomain delegations</td>\n<td>NS records for delegated subzones</td>\n</tr>\n</tbody></table>\n<p><strong>Zone Record Index Structure:</strong></p>\n<p>The zone record storage uses a hierarchical map structure that enables efficient exact match lookups while supporting wildcard resolution and closest encloser identification for NXDOMAIN responses with proper authority sections.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Records map structure:\n  &quot;example.com.&quot; → [SOA, NS, A, AAAA records]\n  &quot;www.example.com.&quot; → [A, AAAA records]\n  &quot;mail.example.com.&quot; → [A, MX records]\n  &quot;*.example.com.&quot; → [A records for wildcard]\n  &quot;sub.example.com.&quot; → [NS records for delegation]</code></pre></div>\n\n<p>The zone data structure must handle several DNS-specific requirements that distinguish it from simple key-value storage. Wildcard records apply to any non-existent subdomain within their scope, requiring special matching logic during query processing. Delegation points mark where authority transfers to other name servers, requiring careful handling of glue records and referral construction.</p>\n<blockquote>\n<p><strong>Decision: In-Memory Zone Storage with Periodic Reload</strong></p>\n<ul>\n<li><strong>Context</strong>: Zone data needs fast access during query processing but may change through file updates</li>\n<li><strong>Options Considered</strong>: File-based lookup, full in-memory storage, hybrid caching approach</li>\n<li><strong>Decision</strong>: Load complete zone data into memory with periodic reload detection</li>\n<li><strong>Rationale</strong>: DNS queries are latency-sensitive; file I/O during query processing creates unacceptable delays; memory usage is bounded by zone size</li>\n<li><strong>Consequences</strong>: Higher memory usage but predictable query performance; requires file change detection for dynamic updates</li>\n</ul>\n</blockquote>\n<h4 id=\"cache-operations-and-ttl-management\">Cache Operations and TTL Management</h4>\n<p>The cache system implements TTL-based expiration with automatic cleanup and size-based eviction to maintain bounded memory usage while maximizing cache hit rates. The cache operations must be thread-safe to support concurrent query processing while providing efficient lookup and insertion performance.</p>\n<p><strong>Core Cache Operations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Get</code></td>\n<td><code>CacheKey</code></td>\n<td><code>*CacheEntry, bool</code></td>\n<td>Retrieve valid cache entry</td>\n</tr>\n<tr>\n<td><code>Put</code></td>\n<td><code>CacheKey, []ResourceRecord, uint32</code></td>\n<td><code>error</code></td>\n<td>Store records with TTL</td>\n</tr>\n<tr>\n<td><code>PutNegative</code></td>\n<td><code>CacheKey, ResourceRecord</code></td>\n<td><code>error</code></td>\n<td>Store negative response</td>\n</tr>\n<tr>\n<td><code>Evict</code></td>\n<td><code>CacheKey</code></td>\n<td><code>bool</code></td>\n<td>Remove specific entry</td>\n</tr>\n<tr>\n<td><code>Cleanup</code></td>\n<td>none</td>\n<td><code>int</code></td>\n<td>Remove expired entries</td>\n</tr>\n<tr>\n<td><code>Stats</code></td>\n<td>none</td>\n<td><code>CacheStats</code></td>\n<td>Return usage statistics</td>\n</tr>\n</tbody></table>\n<p>The TTL management system calculates absolute expiration times during cache insertion, enabling efficient expiration checking without repeated time arithmetic. The cleanup operation runs periodically to reclaim memory from expired entries, while size-based eviction removes least recently used entries when the cache approaches configured limits.</p>\n<p><strong>Cache Statistics Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>HitRate</code></td>\n<td><code>float64</code></td>\n<td>Percentage of queries served from cache</td>\n</tr>\n<tr>\n<td><code>TotalQueries</code></td>\n<td><code>uint64</code></td>\n<td>Total number of cache lookups</td>\n</tr>\n<tr>\n<td><code>CacheHits</code></td>\n<td><code>uint64</code></td>\n<td>Number of successful cache lookups</td>\n</tr>\n<tr>\n<td><code>CacheMisses</code></td>\n<td><code>uint64</code></td>\n<td>Number of failed cache lookups</td>\n</tr>\n<tr>\n<td><code>EntryCount</code></td>\n<td><code>int</code></td>\n<td>Current number of cached entries</td>\n</tr>\n<tr>\n<td><code>MemoryUsage</code></td>\n<td><code>int64</code></td>\n<td>Estimated memory usage in bytes</td>\n</tr>\n<tr>\n<td><code>EvictionCount</code></td>\n<td><code>uint64</code></td>\n<td>Number of entries evicted for space</td>\n</tr>\n</tbody></table>\n<h4 id=\"negative-caching-implementation\">Negative Caching Implementation</h4>\n<p>Negative caching stores information about non-existent domains and record types to prevent repeated recursive resolution attempts for invalid queries. This optimization significantly reduces server load when handling typos, scan attempts, and other queries for non-existent resources.</p>\n<p><strong>Negative Cache Entry Types:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Description</th>\n<th>TTL Source</th>\n<th>Cache Key</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NXDOMAIN</td>\n<td>Domain doesn&#39;t exist</td>\n<td>SOA minimum TTL</td>\n<td>Name=domain, Type=any</td>\n</tr>\n<tr>\n<td>NODATA</td>\n<td>Domain exists, record type doesn&#39;t</td>\n<td>SOA minimum TTL</td>\n<td>Name=domain, Type=specific</td>\n</tr>\n<tr>\n<td>NXRRSET</td>\n<td>No records of requested type</td>\n<td>Original query TTL</td>\n<td>Name=domain, Type=specific</td>\n</tr>\n</tbody></table>\n<p>Negative caching requires careful TTL management because negative responses don&#39;t contain explicit TTL values. Instead, the TTL for negative cache entries derives from the minimum TTL field in the SOA record of the zone that provided the negative response. This ensures that negative cache entries expire appropriately when zone data changes.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Negative Cache TTL Confusion</strong>\nNegative cache entries must use the SOA minimum TTL from the authority section, not the TTL of the SOA record itself. The SOA minimum field specifically controls negative caching duration, while the SOA record TTL controls how long the SOA record itself should be cached. Using the wrong TTL can cause negative entries to persist too long or expire too quickly.</p>\n</blockquote>\n<h4 id=\"thread-safety-and-concurrent-access\">Thread Safety and Concurrent Access</h4>\n<p>The cache and zone data structures must support concurrent access from multiple goroutines processing DNS queries simultaneously. This requires careful synchronization to prevent race conditions while maintaining high performance for read-heavy workloads typical of DNS servers.</p>\n<p><strong>Concurrency Design Considerations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Frequency</th>\n<th>Synchronization Strategy</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache lookups</td>\n<td>Very high</td>\n<td>Read-write mutex (read lock)</td>\n<td>Minimal contention</td>\n</tr>\n<tr>\n<td>Cache insertions</td>\n<td>Moderate</td>\n<td>Read-write mutex (write lock)</td>\n<td>Brief blocking</td>\n</tr>\n<tr>\n<td>Zone lookups</td>\n<td>High</td>\n<td>Read-only after loading</td>\n<td>No contention</td>\n</tr>\n<tr>\n<td>Zone reloading</td>\n<td>Very low</td>\n<td>Replace entire structure</td>\n<td>Brief interruption</td>\n</tr>\n<tr>\n<td>Cache cleanup</td>\n<td>Low</td>\n<td>Background goroutine</td>\n<td>Minimal impact</td>\n</tr>\n</tbody></table>\n<p>The synchronization strategy uses read-write mutexes for cache operations, allowing multiple concurrent readers while ensuring exclusive access for writers. Zone data loading creates new data structures atomically and replaces pointers, minimizing the critical section duration during zone updates.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides concrete Go code structures and patterns for building the DNS message parsing and data management components. The focus is on creating robust, efficient data structures that handle the binary DNS protocol correctly while providing clean interfaces for higher-level components.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binary Parsing</td>\n<td><code>encoding/binary</code> with byte slices</td>\n<td>Custom bit manipulation with unsafe</td>\n</tr>\n<tr>\n<td>Name Storage</td>\n<td><code>strings</code> with normalization</td>\n<td>Interned string table for memory efficiency</td>\n</tr>\n<tr>\n<td>Cache Backend</td>\n<td><code>sync.Map</code> with cleanup goroutine</td>\n<td>Custom hash table with LRU eviction</td>\n</tr>\n<tr>\n<td>Time Management</td>\n<td><code>time.Time</code> with periodic cleanup</td>\n<td>Time wheel for efficient TTL tracking</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td><code>sync.RWMutex</code> for cache protection</td>\n<td>Lock-free structures with atomic operations</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── internal/dns/\n│   ├── message.go           ← DNSMessage, Header, Question, ResourceRecord types\n│   ├── message_test.go      ← Message parsing and serialization tests\n│   ├── parser.go            ← ParseMessage, parseHeader, parseName functions\n│   ├── parser_test.go       ← Parser unit tests with sample messages\n│   ├── compression.go       ← Name compression implementation\n│   └── constants.go         ← DNS protocol constants and record types\n├── internal/cache/\n│   ├── cache.go             ← Cache interface and implementation\n│   ├── cache_test.go        ← Cache behavior tests\n│   ├── entry.go             ← CacheEntry and CacheKey types\n│   └── stats.go             ← CacheStats tracking\n├── internal/zone/\n│   ├── zone.go              ← Zone data structures and loading\n│   ├── zone_test.go         ← Zone file parsing tests\n│   ├── parser.go            ← Zone file format parser\n│   └── testdata/            ← Sample zone files for testing\n└── testdata/\n    ├── sample_queries/       ← Binary DNS message samples\n    └── zone_files/          ← Example zone file formats</code></pre></div>\n\n<h4 id=\"dns-message-infrastructure-code\">DNS Message Infrastructure Code</h4>\n<p><strong>Core Message Types</strong> (<code>internal/dns/message.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> dns</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DNS protocol constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tDNS_HEADER_SIZE</span><span style=\"color:#F97583\">  =</span><span style=\"color:#79B8FF\"> 12</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tDNS_UDP_MAX_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 512</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tDEFAULT_PORT</span><span style=\"color:#F97583\">     =</span><span style=\"color:#79B8FF\"> 53</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// DNS message flags</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFLAG_QR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#6A737D\">  // Query/Response</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFLAG_AA</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#6A737D\">  // Authoritative Answer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFLAG_TC</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#6A737D\">   // Truncated</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFLAG_RD</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#6A737D\">   // Recursion Desired</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFLAG_RA</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#6A737D\">   // Recursion Available</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// DNS record types</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTYPE_A</span><span style=\"color:#F97583\">     =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTYPE_NS</span><span style=\"color:#F97583\">    =</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTYPE_CNAME</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTYPE_SOA</span><span style=\"color:#F97583\">   =</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTYPE_MX</span><span style=\"color:#F97583\">    =</span><span style=\"color:#79B8FF\"> 15</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTYPE_TXT</span><span style=\"color:#F97583\">   =</span><span style=\"color:#79B8FF\"> 16</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tTYPE_AAAA</span><span style=\"color:#F97583\">  =</span><span style=\"color:#79B8FF\"> 28</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// DNS response codes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tRCODE_NOERROR</span><span style=\"color:#F97583\">  =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tRCODE_FORMERR</span><span style=\"color:#F97583\">  =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tRCODE_SERVFAIL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tRCODE_NXDOMAIN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DNSMessage represents a complete DNS message with all sections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DNSMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tHeader     </span><span style=\"color:#B392F0\">Header</span><span style=\"color:#9ECBFF\">           `json:\"header\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tQuestions  []</span><span style=\"color:#B392F0\">Question</span><span style=\"color:#9ECBFF\">       `json:\"questions\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAnswers    []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#9ECBFF\"> `json:\"answers\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAuthority  []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#9ECBFF\"> `json:\"authority\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAdditional []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#9ECBFF\"> `json:\"additional\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Header contains DNS message header fields per RFC 1035</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Header</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tID              </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tQueryResponse   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">   `json:\"query_response\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tOpcode          </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#9ECBFF\">  `json:\"opcode\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAuthoritative   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">   `json:\"authoritative\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTruncated       </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">   `json:\"truncated\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tRecursionDesired </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">   `json:\"recursion_desired\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tRecursionAvail   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">   `json:\"recursion_available\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tResponseCode     </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#9ECBFF\">  `json:\"response_code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tQuestionCount    </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"question_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAnswerCount      </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"answer_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAuthorityCount   </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"authority_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAdditionalCount  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"additional_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Question represents a DNS question section entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Question</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tType  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tClass </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"class\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceRecord represents any DNS resource record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tType  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tClass </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"class\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTTL   </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#9ECBFF\"> `json:\"ttl\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tData  []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\"> `json:\"data\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validation helper methods</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsQuery</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">h.QueryResponse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsResponse</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> h.QueryResponse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsExpired</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">now</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">insertTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> now.</span><span style=\"color:#B392F0\">Sub</span><span style=\"color:#E1E4E8\">(insertTime) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(rr.TTL)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cache Infrastructure</strong> (<code>internal/cache/cache.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cache</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/yourproject/internal/dns</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CacheKey uniquely identifies a cached DNS record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tType  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tClass </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#9ECBFF\"> `json:\"class\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CacheEntry stores cached DNS data with expiration information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tRecords    []</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#9ECBFF\"> `json:\"records\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tExpiresAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">           `json:\"expires_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tNegative   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">                `json:\"negative\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSOARecord  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#9ECBFF\">  `json:\"soa_record,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tInsertTime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">           `json:\"insert_time\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CacheStats provides cache performance metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheStats</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tHitRate       </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\"> `json:\"hit_rate\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTotalQueries  </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\">  `json:\"total_queries\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCacheHits     </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\">  `json:\"cache_hits\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCacheMisses   </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\">  `json:\"cache_misses\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tEntryCount    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">     `json:\"entry_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMemoryUsage   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">   `json:\"memory_usage\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tEvictionCount </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\">  `json:\"eviction_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cache provides thread-safe DNS record caching with TTL expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Cache</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu      </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tentries </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">CacheKey</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstats   </span><span style=\"color:#B392F0\">CacheStats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmaxSize </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCache creates a new DNS cache with the specified maximum size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCache</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxSize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cache</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Cache</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tentries: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">CacheKey</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tmaxSize: maxSize,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get retrieves a cache entry if present and not expired</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Acquire read lock for concurrent access safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Look up entry in the entries map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Check if entry exists and is not expired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Update cache hit/miss statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Return entry and existence boolean</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use time.Now() to check expiration against ExpiresAt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Put stores DNS records in the cache with TTL-based expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">records</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Calculate absolute expiration time from TTL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create new CacheEntry with records and expiration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Acquire write lock for modification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Check if cache is at maximum size and evict if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Store entry in the entries map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Update cache statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use time.Now().Add(time.Duration(ttl) * time.Second) for expiration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PutNegative stores a negative cache entry for NXDOMAIN/NODATA responses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PutNegative</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">soaRecord</span><span style=\"color:#B392F0\"> dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Extract minimum TTL from SOA record data for negative caching duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create CacheEntry with Negative=true and empty Records slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Include SOA record for authority information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Store entry using the same logic as Put() but mark as negative</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: SOA minimum TTL is at bytes 16-20 in SOA record data</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Methods for eviction, cleanup, and statistics...</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Message Parser</strong> (<code>internal/dns/parser.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> dns</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseMessage parses a complete DNS message from wire format bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Validate minimum message length (at least header size)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Parse the 12-byte header using parseHeader()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Initialize message with parsed header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Parse question section based on QuestionCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Parse answer section based on AnswerCount  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Parse authority section based on AuthorityCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Parse additional section based on AdditionalCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Validate that all bytes were consumed (no trailing data)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Keep track of current offset as you parse each section</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseHeader extracts DNS header from the first 12 bytes of a message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseHeader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Verify data is at least DNS_HEADER_SIZE bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Extract ID from bytes 0-1 using binary.BigEndian</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Extract and decode flags from bytes 2-3 into individual boolean fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Extract section counts from remaining header bytes (4-11)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Return populated Header struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use bit operations to extract individual flags from the 16-bit flags field</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseName extracts a DNS name from message data with compression support</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Initialize name buffer and current position tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Track visited positions to detect compression loops</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Read label length byte at current position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Handle regular labels (length 1-63): read characters, append to name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Handle compression pointers (bits 11): extract offset, jump to referenced position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Handle name termination (length 0): finalize and return name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Validate all label lengths and pointer offsets are within bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Return complete name, final offset, and any parsing error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use a map[int]bool to track visited positions during pointer following</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SerializeMessage converts a DNS message to wire format for network transmission</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SerializeMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Calculate total message size needed for pre-allocation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Serialize header with section counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Serialize questions section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Serialize answer resource records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Serialize authority resource records  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Serialize additional resource records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Apply name compression where beneficial</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Validate final message size is within limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Build a compression table as you serialize to track name positions</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"zone-data-management\">Zone Data Management</h4>\n<p><strong>Zone Loading</strong> (<code>internal/zone/zone.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> zone</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/yourproject/internal/dns</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Zone represents authoritative DNS data for a domain</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Zone</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDomain      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                              `json:\"domain\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSOA         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#9ECBFF\">                 `json:\"soa\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tRecords     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#9ECBFF\">     `json:\"records\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDelegations </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#9ECBFF\">     `json:\"delegations\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span><span style=\"color:#9ECBFF\">                        `json:\"-\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadZone reads a BIND-format zone file and returns a Zone structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadZone</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">domain</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Zone</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Open zone file and create buffered reader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Initialize zone structure with domain name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Parse zone file line by line, handling comments and continuations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Parse SOA record and store as zone authority</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Parse NS records and identify delegations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Parse A, AAAA, CNAME, MX, TXT records into records map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Validate zone has required SOA and NS records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Return fully populated zone structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Use strings.Fields() to split zone file lines into components</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LookupAuthoritative finds records in the zone for a given question</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">z </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Zone</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LookupAuthoritative</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">question</span><span style=\"color:#B392F0\"> dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Question</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Acquire read lock for concurrent access protection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Normalize the question name to lowercase FQDN format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Check for exact match in records map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: If no exact match, check for wildcard matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: If no match found, return appropriate NXDOMAIN/NODATA response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Handle CNAME records with special processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Return matching records with proper authority section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: Wildcard matching requires checking parent domains for \"*\" labels</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone 1 - DNS Message Parsing:</strong></p>\n<ul>\n<li>Run: <code>go test ./internal/dns/...</code> </li>\n<li>Expected: All parsing tests pass, including compression and edge cases</li>\n<li>Manual test: Create a simple program that parses a real DNS query packet</li>\n<li>Signs of problems: Panic on malformed input, incorrect flag parsing, name compression failures</li>\n</ul>\n<p><strong>Milestone 2 - Zone Data Loading:</strong></p>\n<ul>\n<li>Run: <code>go test ./internal/zone/...</code></li>\n<li>Expected: Zone file parser handles BIND format correctly</li>\n<li>Manual test: Load a zone file and query for different record types</li>\n<li>Signs of problems: Missing records, incorrect TTL values, delegation handling errors</li>\n</ul>\n<p><strong>Milestone 3 - Cache Operations:</strong></p>\n<ul>\n<li>Run: <code>go test ./internal/cache/...</code></li>\n<li>Expected: Cache stores and retrieves records, handles TTL expiration</li>\n<li>Manual test: Store records, wait for TTL expiration, verify automatic cleanup</li>\n<li>Signs of problems: Memory leaks from expired entries, race conditions, incorrect TTL calculations</li>\n</ul>\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>Binary Parsing in Go:</strong></p>\n<ul>\n<li>Use <code>encoding/binary.BigEndian.Uint16()</code> for network byte order conversion</li>\n<li>Validate slice bounds before accessing to prevent panics</li>\n<li>Use <code>bytes.Buffer</code> for efficient message construction during serialization</li>\n</ul>\n<p><strong>Concurrency Patterns:</strong></p>\n<ul>\n<li>Use <code>sync.RWMutex</code> for read-heavy cache workloads</li>\n<li>Implement atomic operations with <code>sync/atomic</code> for statistics counters  </li>\n<li>Use <code>context.Context</code> for timeout handling in network operations</li>\n</ul>\n<p><strong>Memory Management:</strong></p>\n<ul>\n<li>Pre-allocate slices with known capacity to reduce garbage collection</li>\n<li>Use string interning for repeated domain names to save memory</li>\n<li>Implement periodic cleanup goroutines with <code>time.Ticker</code> for expired entries</li>\n</ul>\n<p><strong>Testing Strategies:</strong></p>\n<ul>\n<li>Create test helper functions for generating valid DNS messages</li>\n<li>Use table-driven tests for comprehensive edge case coverage</li>\n<li>Test with real DNS message captures from network traffic for validation</li>\n</ul>\n<h2 id=\"dns-message-parsing-milestone-1\">DNS Message Parsing (Milestone 1)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1 (DNS Message Parsing)</p>\n</blockquote>\n<p>The foundation of any DNS server lies in its ability to parse and construct DNS messages in their binary wire format. DNS messages are not human-readable text like HTTP requests—they are carefully structured binary documents that pack maximum information into minimum bytes for efficient network transmission. Understanding this binary protocol is essential before implementing any higher-level DNS functionality.</p>\n<h3 id=\"mental-model-dns-as-structured-binary-documents\">Mental Model: DNS as Structured Binary Documents</h3>\n<p>Think of DNS messages like highly structured legal documents with a rigid format. Just as a legal contract has specific sections (header information, parties involved, terms, signatures) that must appear in a particular order, DNS messages have exactly four sections that must be parsed in sequence: the header, questions, answers, and authority/additional records.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fdns-message-structure.svg\" alt=\"DNS Message Data Structure\"></p>\n<p>However, unlike text documents, DNS messages are binary data where every bit has meaning. Imagine trying to read a document where the first 12 bytes contain metadata about the document (like the number of pages, document type, and status flags), followed by variable-length sections where you must count bytes carefully to know where one section ends and another begins. This is exactly how DNS message parsing works—there are no delimiters or whitespace to guide you, only precise byte counting and format knowledge.</p>\n<p>The parsing challenge becomes more complex due to <strong>name compression</strong>, DNS&#39;s clever optimization technique. Think of name compression like legal document references—instead of writing out &quot;The State of California&quot; every time it appears, the document might write it fully once and then use &quot;said State&quot; for subsequent references. DNS does something similar but with byte-level pointers: when &quot;example.com&quot; appears multiple times in a message, it&#39;s written out fully once, and subsequent occurrences are replaced with 2-byte pointers to the original location.</p>\n<h3 id=\"name-compression-algorithm\">Name Compression Algorithm</h3>\n<p>DNS name compression exists because domain names frequently share common suffixes. In a single DNS response, you might see &quot;<a href=\"http://www.example.com\">www.example.com</a>&quot;, &quot;mail.example.com&quot;, and &quot;ns1.example.com&quot;—all sharing the &quot;.example.com&quot; suffix. Rather than repeat these bytes, DNS compression stores the suffix once and uses pointers for subsequent references.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fname-compression-example.svg\" alt=\"DNS Name Compression Example\"></p>\n<p>The compression algorithm works through <strong>pointer labels</strong> that begin with the bit pattern <code>11</code> (which corresponds to bytes starting with <code>0xC0</code> or higher). When the parser encounters such a byte, it knows the next byte forms a 14-bit offset pointing backward into the message where the actual name data resides.</p>\n<p>Here&#39;s how the name compression algorithm operates:</p>\n<ol>\n<li><strong>Initialize parsing state</strong>: Start with an empty name buffer and the current parsing offset</li>\n<li><strong>Read label length byte</strong>: This tells you how many characters follow in this label component</li>\n<li><strong>Check for compression pointer</strong>: If the length byte has its top two bits set (≥ 0xC0), this is a pointer</li>\n<li><strong>Handle normal labels</strong>: If not a pointer, read the specified number of characters and add them to the name</li>\n<li><strong>Follow compression pointers</strong>: Extract the 14-bit offset from the pointer bytes and jump to that location</li>\n<li><strong>Continue parsing at pointer target</strong>: Resume normal label parsing from the referenced location</li>\n<li><strong>Detect completion</strong>: Names end with a zero-length label (null terminator)</li>\n<li><strong>Return final name and next parse position</strong>: Provide the complete domain name and where parsing should continue</li>\n</ol>\n<p>The compression algorithm must handle several edge cases. <strong>Nested compression</strong> occurs when a pointer target itself contains pointers—the parser must follow these chains to their conclusion. <strong>Loop detection</strong> is critical because malicious or corrupted messages might create circular pointer references that would cause infinite loops. Most implementations limit pointer following to a maximum depth or maintain a visited-offset list.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: Name compression creates a trade-off between message size reduction and parsing complexity. While compression can reduce message sizes by 20-30% in typical responses, it requires parsers to maintain additional state and perform bounds checking carefully.</p>\n</blockquote>\n<h3 id=\"architecture-decisions-for-parsing\">Architecture Decisions for Parsing</h3>\n<p>Several architectural decisions fundamentally shape how DNS message parsing is implemented. Each decision involves trade-offs between performance, memory usage, safety, and code complexity.</p>\n<blockquote>\n<p><strong>Decision: Message Parsing Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS messages must be parsed from raw UDP packets into structured data for processing</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single-pass streaming parser that extracts data on-demand</li>\n<li>Two-pass parser that validates structure first, then extracts data</li>\n<li>Full message parser that loads everything into memory structures immediately</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Full message parser with immediate structure loading</li>\n<li><strong>Rationale</strong>: DNS messages are small (≤512 bytes for UDP), so memory usage is minimal. Having all data immediately available simplifies resolver logic and error handling. Validation can happen during parsing rather than requiring separate passes.</li>\n<li><strong>Consequences</strong>: Higher memory usage per message (acceptable due to small message sizes), but simpler downstream code and better error locality.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Parsing Strategy</th>\n<th>Memory Usage</th>\n<th>Error Detection</th>\n<th>Implementation Complexity</th>\n<th>Performance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Streaming</td>\n<td>Minimal</td>\n<td>Delayed</td>\n<td>High</td>\n<td>Best</td>\n</tr>\n<tr>\n<td>Two-pass</td>\n<td>Moderate</td>\n<td>Early</td>\n<td>Moderate</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Full load</td>\n<td>Higher</td>\n<td>Immediate</td>\n<td>Low</td>\n<td>Good</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Name Compression Validation</strong></p>\n<ul>\n<li><strong>Context</strong>: Name compression pointers could reference invalid offsets or create infinite loops</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Trust all pointers and follow them without validation</li>\n<li>Validate pointer targets are within message bounds but allow loops</li>\n<li>Full validation with bounds checking and loop detection</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Full validation with bounds checking and loop detection</li>\n<li><strong>Rationale</strong>: Security is paramount for DNS servers. Invalid pointer following could lead to buffer overruns or infinite loops that enable denial-of-service attacks. The performance cost is minimal compared to the security benefits.</li>\n<li><strong>Consequences</strong>: Slightly more complex parsing code and minor performance overhead, but protection against malformed messages and potential security vulnerabilities.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Validation Level</th>\n<th>Security</th>\n<th>Performance</th>\n<th>Implementation</th>\n<th>Attack Surface</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No validation</td>\n<td>Poor</td>\n<td>Best</td>\n<td>Simplest</td>\n<td>Large</td>\n</tr>\n<tr>\n<td>Bounds only</td>\n<td>Fair</td>\n<td>Good</td>\n<td>Moderate</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Full validation</td>\n<td>Excellent</td>\n<td>Good</td>\n<td>Complex</td>\n<td>Minimal</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Byte Order Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS messages use network byte order (big-endian) but most modern processors are little-endian</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Manual byte swapping with bitwise operations</li>\n<li>Platform-specific intrinsics for byte order conversion</li>\n<li>Standard library functions for network-to-host conversion</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Standard library functions for network-to-host conversion</li>\n<li><strong>Rationale</strong>: Using established functions like <code>binary.BigEndian</code> in Go reduces bugs and improves code readability. These functions are optimized by compiler and runtime teams.</li>\n<li><strong>Consequences</strong>: Cleaner code with fewer byte-manipulation bugs, but slight abstraction overhead (typically optimized away by compilers).</li>\n</ul>\n</blockquote>\n<p>The parser must also decide how to handle <strong>buffer management</strong>. DNS messages arrive as byte slices from UDP packets, and the parser must track its position while extracting multi-byte values and variable-length strings. The chosen approach uses a parsing cursor that advances through the buffer while maintaining bounds checking at each step.</p>\n<p><strong>Error propagation strategy</strong> affects how parsing failures are handled. The parser uses Go&#39;s idiomatic error return pattern, where each parsing function returns both its result and an error. This allows precise error reporting with context about which field failed parsing and why, rather than generic &quot;parse failed&quot; messages.</p>\n<h3 id=\"common-parsing-pitfalls\">Common Parsing Pitfalls</h3>\n<p>DNS message parsing involves numerous subtle challenges that frequently trip up implementers. Understanding these pitfalls is crucial for building robust parsers.</p>\n<p>⚠️ <strong>Pitfall: Compression Pointer Loops</strong></p>\n<p>The most dangerous parsing bug involves following compression pointers that form loops. Consider a malicious message where a pointer at offset 50 references offset 20, and a pointer at offset 20 references offset 50. A naive parser will follow this loop indefinitely, consuming CPU and potentially hanging the server.</p>\n<p><strong>Why it&#39;s wrong</strong>: Infinite loops in DNS parsing can enable denial-of-service attacks and violate the expectation that parsing completes in bounded time.</p>\n<p><strong>Detection</strong>: Implement loop detection by tracking visited offsets during name parsing or limiting the maximum number of pointer follows to a reasonable bound (typically 5-10).</p>\n<p><strong>Fix</strong>: Maintain a set of visited offsets during name parsing, or use a simpler counter-based approach:</p>\n<table>\n<thead>\n<tr>\n<th>Detection Method</th>\n<th>Memory Usage</th>\n<th>Complexity</th>\n<th>Effectiveness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Visited set</td>\n<td>Higher</td>\n<td>Moderate</td>\n<td>Perfect</td>\n</tr>\n<tr>\n<td>Counter limit</td>\n<td>Minimal</td>\n<td>Low</td>\n<td>Good enough</td>\n</tr>\n<tr>\n<td>Recursion depth</td>\n<td>Minimal</td>\n<td>Low</td>\n<td>Good enough</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Endianness Confusion</strong></p>\n<p>DNS multi-byte values use network byte order (big-endian), but most development platforms are little-endian. Forgetting to convert byte order results in wildly incorrect values—a message ID of <code>0x1234</code> becomes <code>0x3412</code> when read incorrectly.</p>\n<p><strong>Why it&#39;s wrong</strong>: Incorrect byte order causes message correlation failures, wrong record counts, and invalid resource record parsing.</p>\n<p><strong>Detection</strong>: Values appear scrambled or impossibly large. A question count of 13,568 (0x3500) likely should be 0x0035 (53 questions).</p>\n<p><strong>Fix</strong>: Always use network-to-host conversion functions when reading multi-byte values from DNS messages. Never access multi-byte values directly from byte buffers.</p>\n<p>⚠️ <strong>Pitfall: Buffer Overflow in Name Parsing</strong></p>\n<p>Domain name parsing involves reading length-prefixed labels, but malicious messages might contain label lengths that exceed remaining buffer space. Reading beyond buffer bounds can cause crashes or security vulnerabilities.</p>\n<p><strong>Why it&#39;s wrong</strong>: Buffer overruns can lead to crashes, memory corruption, or security exploits where attackers control program execution.</p>\n<p><strong>Detection</strong>: Implement bounds checking before every buffer read. Verify that <code>current_offset + label_length &lt; buffer_size</code> before reading label data.</p>\n<p><strong>Fix</strong>: Always validate buffer bounds before reading:</p>\n<table>\n<thead>\n<tr>\n<th>Check Type</th>\n<th>When to Apply</th>\n<th>Protection Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Label length vs remaining buffer</td>\n<td>Before reading each label</td>\n<td>Essential</td>\n</tr>\n<tr>\n<td>Total name length accumulation</td>\n<td>Throughout name parsing</td>\n<td>Good practice</td>\n</tr>\n<tr>\n<td>Maximum name length limit</td>\n<td>At name completion</td>\n<td>Defense in depth</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Incomplete Message Validation</strong></p>\n<p>Parsers sometimes validate the header but skip validating that section counts match actual section contents. A message claiming 3 answers but containing only 1 answer record can cause array access errors or incomplete processing.</p>\n<p><strong>Why it&#39;s wrong</strong>: Mismatched counts can lead to accessing non-existent records or stopping parsing before all data is processed.</p>\n<p><strong>Detection</strong>: Count actual parsed records and compare against header-declared counts after parsing each section.</p>\n<p><strong>Fix</strong>: Implement comprehensive validation that verifies consistency between header counts and actual parsed content:</p>\n<table>\n<thead>\n<tr>\n<th>Validation Point</th>\n<th>Check Performed</th>\n<th>Error Type if Failed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>After questions</td>\n<td>Count matches QuestionCount</td>\n<td>Structure mismatch</td>\n</tr>\n<tr>\n<td>After answers</td>\n<td>Count matches AnswerCount</td>\n<td>Structure mismatch</td>\n</tr>\n<tr>\n<td>After authority</td>\n<td>Count matches AuthorityCount</td>\n<td>Structure mismatch</td>\n</tr>\n<tr>\n<td>After additional</td>\n<td>Count matches AdditionalCount</td>\n<td>Structure mismatch</td>\n</tr>\n<tr>\n<td>End of message</td>\n<td>No trailing data remains</td>\n<td>Extra data error</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Name Compression Target Validation</strong></p>\n<p>Compression pointers might reference valid offsets that don&#39;t contain valid name data. A pointer could reference the middle of a previous resource record&#39;s data field, leading to garbage name parsing.</p>\n<p><strong>Why it&#39;s wrong</strong>: Invalid compression targets produce malformed domain names that can cause lookup failures or security issues.</p>\n<p><strong>Detection</strong>: Compression targets should only reference the beginning of name fields, not arbitrary message locations.</p>\n<p><strong>Fix</strong>: Maintain a map of valid compression targets (offsets where names begin) during parsing and validate that all pointers reference these known-good locations.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The DNS message parsing implementation requires careful attention to binary data handling, error management, and security considerations. This guidance provides both foundational infrastructure and detailed skeleton code for the core parsing logic.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binary parsing</td>\n<td>Manual byte slicing with bounds checks</td>\n<td>Binary reader with automatic advancement</td>\n</tr>\n<tr>\n<td>Error handling</td>\n<td>Return error on first parse failure</td>\n<td>Collect multiple errors with detailed context</td>\n</tr>\n<tr>\n<td>Name compression</td>\n<td>Simple offset tracking with loop counter</td>\n<td>Full validation with visited offset sets</td>\n</tr>\n<tr>\n<td>Message validation</td>\n<td>Basic field presence checks</td>\n<td>Comprehensive structural validation</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Manual test cases with hex literals</td>\n<td>Property-based testing with random messages</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The parsing implementation should be organized to separate concerns and enable thorough testing:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>dns-server/\n  internal/protocol/\n    message.go           ← DNSMessage, Header, Question, ResourceRecord types\n    parser.go            ← ParseMessage, parseHeader, parseName functions  \n    parser_test.go       ← Comprehensive parsing tests with malformed inputs\n    serializer.go        ← SerializeMessage for response construction\n    constants.go         ← DNS_HEADER_SIZE, TYPE_A, RCODE_NXDOMAIN\n  internal/server/\n    server.go            ← Main server that uses protocol package\n  cmd/dns-server/\n    main.go              ← Entry point</code></pre></div>\n\n<p>This structure isolates protocol handling from server logic, making both easier to test and maintain.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Here&#39;s the complete message structure and basic parsing infrastructure. This code is fully functional and handles the complex byte order and buffer management details:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> protocol</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/binary</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DNS message structure as defined in RFC 1035</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DNSMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Header     </span><span style=\"color:#B392F0\">Header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Questions  []</span><span style=\"color:#B392F0\">Question</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Answers    []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authority  []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Additional []</span><span style=\"color:#B392F0\">ResourceRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Header</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID               </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueryResponse    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // false = query, true = response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Opcode           </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">   // usually 0 for standard query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authoritative    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if answering server is authoritative</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Truncated        </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if message was truncated</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursionDesired </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if client wants recursive resolution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursionAvail   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">    // true if server supports recursion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponseCode     </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">   // 0 = no error, 3 = NXDOMAIN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QuestionCount    </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AnswerCount      </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuthorityCount   </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdditionalCount  </span><span style=\"color:#F97583\">uint16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Question</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // domain name like \"example.com\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // record type (1 = A, 28 = AAAA, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Class </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // usually 1 for Internet class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // domain name this record applies to</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // record type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Class </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // record class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TTL   </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // time to live in seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Data  []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // type-specific data (A record = 4-byte IP)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DNS protocol constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DNS_HEADER_SIZE</span><span style=\"color:#F97583\">   =</span><span style=\"color:#79B8FF\"> 12</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DNS_UDP_MAX_SIZE</span><span style=\"color:#F97583\">  =</span><span style=\"color:#79B8FF\"> 512</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_PORT</span><span style=\"color:#F97583\">      =</span><span style=\"color:#79B8FF\"> 53</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TYPE_A</span><span style=\"color:#F97583\">            =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TYPE_AAAA</span><span style=\"color:#F97583\">         =</span><span style=\"color:#79B8FF\"> 28</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TYPE_CNAME</span><span style=\"color:#F97583\">        =</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RCODE_NXDOMAIN</span><span style=\"color:#F97583\">    =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parser state for tracking position and preventing infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> parseState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data      []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    visited   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // for compression loop detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jumpCount </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // limit compression pointer follows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create new parser state for a message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> newParseState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data:    data,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset:  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        visited: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if enough bytes remain for reading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">canRead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bytes</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">bytes </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(p.data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read single byte and advance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readByte</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">p.</span><span style=\"color:#B392F0\">canRead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected end of message\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.data[p.offset]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.offset</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> b, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read 16-bit value in network byte order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readUint16</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">p.</span><span style=\"color:#B392F0\">canRead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected end of message reading uint16\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[p.offset:])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read 32-bit value in network byte order  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readUint32</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">p.</span><span style=\"color:#B392F0\">canRead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected end of message reading uint32\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(p.data[p.offset:])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read specified number of bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readBytes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">count</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">p.</span><span style=\"color:#B392F0\">canRead</span><span style=\"color:#E1E4E8\">(count) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected end of message reading </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">, count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, count)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(bytes, p.data[p.offset:p.offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">count])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bytes, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>Here are the main parsing functions that learners should implement. The TODOs map directly to the algorithm steps described in the design section:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ParseMessage parses a complete DNS message from wire format bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is the main entry point that coordinates parsing of all message sections.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate minimum message size (must be at least DNS_HEADER_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create parse state and initialize message structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Parse header using parseHeader function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse questions section (QuestionCount times)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Parse answers section (AnswerCount times) </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Parse authority section (AuthorityCount times)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Parse additional section (AdditionalCount times)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Validate no trailing data remains in message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Return completed message structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Each section parsing should validate the count matches actual parsed records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseHeader extracts the 12-byte DNS header from the beginning of the message.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The header contains flags, counts, and metadata about the message structure.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseHeader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read 16-bit message ID </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read 16-bit flags field and extract individual flag bits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Flags format: QR(1) | Opcode(4) | AA(1) | TC(1) | RD(1) | RA(1) | Z(3) | RCODE(4)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read QuestionCount (16-bit)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Read AnswerCount (16-bit)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Read AuthorityCount (16-bit)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Read AdditionalCount (16-bit)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Extract individual flags from the flags field using bit operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return populated Header struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use bitwise AND to extract individual flags: (flags &#x26; 0x8000) != 0 for QR bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseName extracts a domain name from the DNS message, handling compression pointers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the complete domain name and the next parsing position.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize name parts slice and starting position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for compression loop detection (track visited offsets)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read label length byte</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if this is a compression pointer (top 2 bits set: >= 0xC0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For compression pointers:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Extract 14-bit offset from pointer bytes  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Validate offset is within message bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Jump to referenced location and continue parsing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Track visited offsets to prevent infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: For normal labels:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Read specified number of characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Add label to name parts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Continue until null terminator (zero-length label)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Join name parts with dots and return complete name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Limit compression pointer follows to prevent infinite loops (max 10 jumps)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseQuestion extracts a single question from the questions section.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Questions contain the domain name being queried and the requested record type.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseQuestion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Question</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse domain name using parseName function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read 16-bit query type (A, AAAA, CNAME, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read 16-bit query class (usually 1 for Internet)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return populated Question struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Most queries use class 1 (Internet), other classes are rare</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseResourceRecord extracts a single resource record from answer/authority/additional sections.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resource records contain the actual DNS data being returned.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseResourceRecord</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse domain name using parseName function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read 16-bit record type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read 16-bit record class  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Read 32-bit TTL (time to live)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Read 16-bit data length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Read data bytes (length specified in previous step)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return populated ResourceRecord struct with raw data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Don't parse data contents here - leave as raw bytes for type-specific handling later</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateMessage performs comprehensive validation of parsed message structure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Checks for consistency between header counts and actual section contents.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate question count matches actual questions parsed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate answer count matches actual answers parsed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate authority count matches actual authority records parsed  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate additional count matches actual additional records parsed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate all domain names contain only valid characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate record types are known values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return error with specific details if any validation fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Create detailed error messages that specify which field failed validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Go-Specific Implementation Details:</strong></p>\n<ul>\n<li>Use <code>binary.BigEndian.Uint16()</code> and <code>binary.BigEndian.Uint32()</code> for network byte order conversion</li>\n<li>Implement bounds checking with slice length comparisons: <code>offset + size &lt;= len(data)</code></li>\n<li>Use <code>strings.Join(labels, &quot;.&quot;)</code> to construct domain names from parsed labels</li>\n<li>Handle UTF-8 properly in domain names, though DNS traditionally uses ASCII</li>\n<li>Use <code>make([]byte, length)</code> followed by <code>copy()</code> for safe byte slice extraction</li>\n<li>Implement error wrapping with <code>fmt.Errorf(&quot;context: %w&quot;, err)</code> for better error context</li>\n</ul>\n<p><strong>Memory Management:</strong></p>\n<ul>\n<li>Avoid excessive allocations during parsing by reusing slices where possible</li>\n<li>Consider using <code>sync.Pool</code> for parser state objects if processing high message volumes</li>\n<li>Be careful with slice sharing—use <code>copy()</code> when extracting data that outlives the original buffer</li>\n</ul>\n<p><strong>Concurrency Considerations:</strong></p>\n<ul>\n<li>Make parsing functions stateless except for the <code>parseState</code> parameter</li>\n<li>Don&#39;t share <code>parseState</code> objects between goroutines</li>\n<li>Consider parsing messages in parallel if processing batch operations</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing DNS message parsing, verify the implementation with these specific tests:</p>\n<p><strong>Basic Parsing Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/protocol</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestParseBasicMessage</span></span></code></pre></div>\n\n<p>Expected behavior: Parse a simple A record query and response successfully, with correct header flags, question domain name, and answer data extraction.</p>\n<p><strong>Compression Handling Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/protocol</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestParseCompressedNames</span></span></code></pre></div>\n\n<p>Expected behavior: Correctly parse messages with name compression pointers, producing the same domain names as uncompressed equivalents.</p>\n<p><strong>Malformed Message Tests:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/protocol</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestParseErrors</span></span></code></pre></div>\n\n<p>Expected behavior: Reject messages with invalid compression pointers, insufficient data, wrong counts, and other malformation with specific error messages.</p>\n<p><strong>Manual Verification:</strong></p>\n<p>Create a test program that parses real DNS responses:</p>\n<ol>\n<li>Use <code>dig +noedns example.com A</code> to generate a simple query  </li>\n<li>Capture the response with a packet analyzer or programmatically</li>\n<li>Parse the captured bytes and verify the output matches expected values</li>\n<li>Test with multiple record types and compressed names</li>\n</ol>\n<p><strong>Signs of Problems:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Check</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Domain names contain garbage characters</td>\n<td>Compression pointer following error</td>\n<td>Verify pointer offset calculation</td>\n</tr>\n<tr>\n<td>Parse fails on valid messages</td>\n<td>Byte order problems</td>\n<td>Check endianness conversion</td>\n</tr>\n<tr>\n<td>Infinite loop during parsing</td>\n<td>Compression pointer loop</td>\n<td>Verify loop detection logic</td>\n</tr>\n<tr>\n<td>Wrong record counts</td>\n<td>Header parsing errors</td>\n<td>Verify flag bit extraction</td>\n</tr>\n</tbody></table>\n<p>The parsing implementation forms the foundation for all subsequent DNS server functionality. Robust error handling and thorough validation at this stage prevent subtle bugs from propagating through the resolver and cache components.</p>\n<h2 id=\"authoritative-server-milestone-2\">Authoritative Server (Milestone 2)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 2 (Authoritative Server)</p>\n</blockquote>\n<p>An authoritative DNS server serves as the definitive source of truth for specific domains, responding to queries with records from its zone files rather than performing recursive resolution. This milestone transforms our DNS message parser into a functioning authoritative server that can load zone data, match queries against its configured domains, and construct proper DNS responses with populated answer, authority, and additional sections.</p>\n<h3 id=\"mental-model-zones-as-local-phone-books\">Mental Model: Zones as Local Phone Books</h3>\n<p>Think of DNS zones as specialized phone books, where each phone book covers a specific geographic region or organization. Just as a local phone book contains authoritative listings for businesses and residents in a particular city, a DNS zone contains authoritative resource records for a specific domain and its subdomains.</p>\n<p>When someone calls directory assistance asking for &quot;John Smith&#39;s number in Springfield,&quot; the operator first determines which phone book to consult based on the location. Similarly, when a DNS query arrives asking for &quot;mail.example.com,&quot; an authoritative server first checks whether it has authoritative data for the &quot;example.com&quot; zone. If it does, it becomes the definitive source for that information—no need to call other directories or perform further lookups.</p>\n<p>The phone book analogy extends to the structure of DNS responses. A complete directory assistance response might include the requested phone number (answer section), information about the phone company serving that area (authority section), and related numbers like the main switchboard (additional section). DNS responses follow the same pattern, providing not just the requested record but also supporting information that helps clients understand the authoritative structure and potentially avoid additional queries.</p>\n<p>Unlike a phone book that covers an entire city uniformly, DNS zones can have complex delegation patterns. A zone might contain complete information for some subdomains while delegating others to different nameservers, similar to how a regional phone directory might include full listings for some neighborhoods but refer to specialized business directories for commercial districts.</p>\n<h3 id=\"zone-file-parsing-algorithm\">Zone File Parsing Algorithm</h3>\n<p>Zone files follow the BIND format established by RFC 1035, representing DNS resource records in a human-readable text format that must be parsed into queryable in-memory data structures. The parsing process handles multiple record types, origin directives, TTL inheritance, and domain name expansion to build a comprehensive zone database.</p>\n<p><strong>Zone File Structure and Components</strong></p>\n<p>Zone files begin with administrative records that define the zone&#39;s properties and delegation information. The Start of Authority (SOA) record establishes the zone&#39;s primary nameserver, responsible party contact, and timing parameters for zone transfers and caching. Name Server (NS) records define which servers are authoritative for the zone, creating the delegation chain that recursive resolvers follow.</p>\n<table>\n<thead>\n<tr>\n<th>Zone Directive</th>\n<th>Purpose</th>\n<th>Example</th>\n<th>Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$ORIGIN</td>\n<td>Set default domain suffix</td>\n<td><code>$ORIGIN example.com.</code></td>\n<td>All relative names append this suffix</td>\n</tr>\n<tr>\n<td>$TTL</td>\n<td>Set default time-to-live</td>\n<td><code>$TTL 3600</code></td>\n<td>Records without TTL use this value</td>\n</tr>\n<tr>\n<td>@ symbol</td>\n<td>Reference to origin domain</td>\n<td><code>@ IN SOA ...</code></td>\n<td>Expands to current $ORIGIN value</td>\n</tr>\n<tr>\n<td>Relative names</td>\n<td>Names without trailing dot</td>\n<td><code>mail IN A 192.0.2.1</code></td>\n<td>Become <code>mail.example.com.</code></td>\n</tr>\n<tr>\n<td>Absolute names</td>\n<td>Names with trailing dot</td>\n<td><code>ns1.example.org.</code></td>\n<td>Used exactly as written</td>\n</tr>\n</tbody></table>\n<p><strong>Resource Record Parsing Process</strong></p>\n<p>The zone file parser processes records line by line, handling continuation characters, comments, and various record formats. Each line potentially contains multiple pieces of information that must be extracted and validated according to DNS protocol specifications.</p>\n<ol>\n<li><p><strong>Tokenization and Line Processing</strong>: The parser splits each line into tokens while respecting quoted strings that may contain spaces. Comments beginning with semicolons are stripped, and backslash continuation characters allow records to span multiple lines for readability.</p>\n</li>\n<li><p><strong>Name Field Resolution</strong>: Record names can be specified as relative (requiring origin expansion), absolute (ending with a dot), or omitted entirely (inheriting from the previous record). The parser maintains context about the current record name to handle implicit repetition.</p>\n</li>\n<li><p><strong>Class and TTL Handling</strong>: These optional fields can appear in either order and may be omitted if defaults are established. The parser must distinguish between numeric TTL values and symbolic class identifiers like &quot;IN&quot; for Internet.</p>\n</li>\n<li><p><strong>Type-Specific Data Parsing</strong>: Each record type has unique data format requirements. A records contain IPv4 addresses, AAAA records contain IPv6 addresses, CNAME records contain domain names, and MX records contain priority values followed by domain names.</p>\n</li>\n<li><p><strong>Domain Name Canonicalization</strong>: All domain names are converted to canonical lowercase form with trailing dots to ensure consistent matching during query processing. This normalization eliminates case sensitivity issues and ambiguity about absolute versus relative names.</p>\n</li>\n</ol>\n<p><strong>Zone Data Storage Structure</strong></p>\n<p>The parsed zone data requires efficient storage for query matching, supporting both exact name lookups and wildcard matching patterns. The data structure must accommodate multiple record types for each domain name while preserving TTL values and maintaining the hierarchical relationships between parent and child domains.</p>\n<table>\n<thead>\n<tr>\n<th>Storage Component</th>\n<th>Data Type</th>\n<th>Purpose</th>\n<th>Key Features</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zone name map</td>\n<td><code>map[string]*DomainNode</code></td>\n<td>Primary lookup structure</td>\n<td>Keys are canonical domain names</td>\n</tr>\n<tr>\n<td>Domain nodes</td>\n<td><code>*DomainNode</code></td>\n<td>Per-domain record storage</td>\n<td>Contains record sets by type</td>\n</tr>\n<tr>\n<td>Record sets</td>\n<td><code>map[uint16][]ResourceRecord</code></td>\n<td>Type-grouped records</td>\n<td>Indexed by DNS type constants</td>\n</tr>\n<tr>\n<td>Wildcard patterns</td>\n<td><code>[]WildcardPattern</code></td>\n<td>Wildcard matching rules</td>\n<td>Ordered by specificity</td>\n</tr>\n<tr>\n<td>Delegation points</td>\n<td><code>map[string]bool</code></td>\n<td>Subdomain delegations</td>\n<td>Identifies zone cuts</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Hierarchical Storage vs. Flat Map</strong></p>\n<ul>\n<li><strong>Context</strong>: Zone data can be stored as a flat map of domain names or as a hierarchical tree reflecting DNS structure</li>\n<li><strong>Options Considered</strong>: Flat hash map, Hierarchical tree with parent pointers, Hybrid approach with delegation awareness</li>\n<li><strong>Decision</strong>: Flat map with explicit delegation tracking</li>\n<li><strong>Rationale</strong>: Simpler implementation with O(1) exact lookups, while delegation map provides necessary hierarchy information for authority section population</li>\n<li><strong>Consequences</strong>: Enables efficient exact matching but requires additional logic for wildcard resolution and closest enclosing authority determination</li>\n</ul>\n</blockquote>\n<h3 id=\"query-matching-and-response-construction\">Query Matching and Response Construction</h3>\n<p>Query processing for authoritative servers involves determining whether the server has authoritative data for the requested domain, finding the most specific matching records, and constructing a complete DNS response with properly populated answer, authority, and additional sections.</p>\n<p><strong>Authoritative Determination Process</strong></p>\n<p>Before processing any query, the server must determine its authority relationship to the requested domain. This involves checking whether the queried name falls within any configured zone and identifying the most specific zone that applies.</p>\n<ol>\n<li><p><strong>Zone Boundary Detection</strong>: The server examines each configured zone to determine if the queried domain is within its authority. For a query about &quot;mail.sales.example.com&quot;, zones for &quot;example.com&quot;, &quot;sales.example.com&quot;, and &quot;com&quot; would all claim authority, but &quot;sales.example.com&quot; provides the most specific match.</p>\n</li>\n<li><p><strong>Delegation Checking</strong>: Even within an authoritative zone, subdomains may be delegated to other nameservers. The server must check for NS records that delegate authority for the queried domain or any parent domain, as delegated zones fall outside the server&#39;s authority.</p>\n</li>\n<li><p><strong>Authority Classification</strong>: Based on this analysis, the server classifies each query as authoritative (server has definitive data), delegated (authority transferred to other nameservers), or non-authoritative (domain falls outside configured zones).</p>\n</li>\n</ol>\n<p><strong>Record Matching Algorithm</strong></p>\n<p>For queries within the server&#39;s authority, the matching algorithm finds the most appropriate records to include in the response, handling exact matches, wildcard patterns, and various DNS edge cases.</p>\n<p>The matching process follows a specific precedence order designed to provide the most useful information while respecting DNS protocol semantics:</p>\n<ol>\n<li><p><strong>Exact Domain Match</strong>: Check if the queried domain name exists exactly in the zone data. If found, examine the available record types to determine the appropriate response.</p>\n</li>\n<li><p><strong>Type-Specific Matching</strong>: If the domain exists, check for records matching the requested type. A successful match populates the answer section with all records of that type for the domain.</p>\n</li>\n<li><p><strong>CNAME Resolution</strong>: If no records match the requested type but a CNAME record exists for the domain, the CNAME provides an alias that should be followed. However, CNAME records cannot coexist with other types for the same domain name.</p>\n</li>\n<li><p><strong>Wildcard Matching</strong>: If no exact domain match exists, search for applicable wildcard patterns. Wildcards match any subdomain at the specified level but cannot match across delegation boundaries.</p>\n</li>\n<li><p><strong>Negative Response Generation</strong>: If no positive match is found, generate an appropriate negative response (NXDOMAIN for non-existent domains or NODATA for existing domains without requested record types).</p>\n</li>\n</ol>\n<p><strong>Response Section Population</strong></p>\n<p>DNS responses contain four sections that serve different purposes in conveying information to clients. Proper population of each section follows specific rules that help clients understand the authoritative structure and optimize future queries.</p>\n<table>\n<thead>\n<tr>\n<th>Response Section</th>\n<th>Content Rules</th>\n<th>Population Logic</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Answer</td>\n<td>Records matching query exactly</td>\n<td>Direct matches for query name/type</td>\n<td>Provides requested information</td>\n</tr>\n<tr>\n<td>Authority</td>\n<td>SOA or NS records establishing authority</td>\n<td>Current zone&#39;s NS records or SOA for negative responses</td>\n<td>Proves authoritative source</td>\n</tr>\n<tr>\n<td>Additional</td>\n<td>Supporting records for names in other sections</td>\n<td>A/AAAA records for NS names, MX targets, etc.</td>\n<td>Reduces follow-up queries</td>\n</tr>\n<tr>\n<td>Header flags</td>\n<td>AA bit, RCODE values</td>\n<td>Set AA=1 for authoritative responses</td>\n<td>Indicates response authority level</td>\n</tr>\n</tbody></table>\n<p><strong>Answer Section Construction</strong>: When records match the query exactly, all records of the requested type are included in the answer section. For CNAME records, both the CNAME and the records it points to may be included if the target is within the same zone.</p>\n<p><strong>Authority Section Logic</strong>: For positive responses, the authority section contains NS records for the zone containing the answer, establishing which nameservers are authoritative for this data. For negative responses, the SOA record provides caching parameters and proves the server&#39;s authority to make negative assertions.</p>\n<p><strong>Additional Section Optimization</strong>: The additional section includes records that clients are likely to need next, based on names appearing in other sections. For NS records in the authority section, corresponding A or AAAA records (glue records) help clients contact those nameservers without additional queries.</p>\n<p><strong>CNAME Handling Complexity</strong></p>\n<p>CNAME records introduce special processing requirements because they create aliases that must be resolved transparently to clients while respecting zone boundaries and avoiding infinite loops.</p>\n<p>When a query matches a CNAME record, the authoritative server has several response options depending on whether the CNAME target falls within its authority:</p>\n<ul>\n<li><strong>In-zone targets</strong>: If the CNAME points to another name within the same zone, the server can include both the CNAME and the target records in a single response, providing complete resolution.</li>\n<li><strong>Out-of-zone targets</strong>: If the CNAME points outside the server&#39;s authority, only the CNAME record is returned, leaving target resolution to the client or recursive resolver.</li>\n<li><strong>CNAME chains</strong>: Multiple CNAME records can form chains that require iterative following while detecting loops and respecting zone boundaries.</li>\n</ul>\n<blockquote>\n<p><strong>Critical insight</strong>: CNAME processing must balance completeness (providing as much information as possible) with authority boundaries (not making assertions about domains outside the server&#39;s control).</p>\n</blockquote>\n<h3 id=\"architecture-decisions-for-authority\">Architecture Decisions for Authority</h3>\n<p>Several key architectural decisions shape how the authoritative server handles edge cases, ensures correctness, and optimizes performance. These decisions involve trade-offs between simplicity and functionality, affecting both implementation complexity and operational behavior.</p>\n<blockquote>\n<p><strong>Decision: Case Sensitivity Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS names are case-insensitive by protocol definition, but file systems and programming languages may be case-sensitive</li>\n<li><strong>Options Considered</strong>: Store names in original case with case-insensitive matching, normalize all names to lowercase on input, mixed approach with case preservation for display</li>\n<li><strong>Decision</strong>: Normalize all domain names to lowercase during parsing and storage</li>\n<li><strong>Rationale</strong>: Eliminates case-related bugs in matching logic, simplifies string comparisons, and ensures consistent behavior across different platforms</li>\n<li><strong>Consequences</strong>: Faster query matching with simple string equality, but loses original case information for response formatting (acceptable trade-off for correctness)</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Case Handling Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Preserve original case</td>\n<td>Maintains zone file formatting</td>\n<td>Requires case-insensitive matching logic</td>\n<td>High - custom comparison functions</td>\n</tr>\n<tr>\n<td>Normalize to lowercase</td>\n<td>Simple string equality matching</td>\n<td>Loses cosmetic case information</td>\n<td>Low - standard string operations</td>\n</tr>\n<tr>\n<td>Case-insensitive map keys</td>\n<td>Balanced approach</td>\n<td>Complex key hashing requirements</td>\n<td>Medium - custom map implementation</td>\n</tr>\n</tbody></table>\n<p><strong>Wildcard Matching Strategy</strong></p>\n<p>Wildcard records in DNS zones use asterisk labels to match arbitrary subdomains, but the matching rules have subtle complexities that affect both correctness and performance.</p>\n<blockquote>\n<p><strong>Decision: Wildcard Matching Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS wildcards match subdomains but have specific precedence rules and delegation boundaries that must be respected</li>\n<li><strong>Options Considered</strong>: Pre-compile wildcard patterns into regular expressions, implement custom matching logic with explicit rules, use suffix-based matching with validation</li>\n<li><strong>Decision</strong>: Custom matching logic following RFC 1034 rules exactly</li>\n<li><strong>Rationale</strong>: DNS wildcard semantics don&#39;t map cleanly to regular expressions, and custom logic provides better control over edge cases and performance</li>\n<li><strong>Consequences</strong>: More implementation effort but guaranteed correctness and predictable performance characteristics</li>\n</ul>\n</blockquote>\n<p>The wildcard matching algorithm must handle several edge cases that distinguish DNS wildcards from general pattern matching:</p>\n<ol>\n<li><p><strong>Delegation Boundaries</strong>: Wildcards cannot match across zone delegation points, even if the parent zone contains the wildcard pattern. This prevents wildcard records from inadvertently claiming authority over delegated subdomains.</p>\n</li>\n<li><p><strong>Exact Match Precedence</strong>: Explicit records always take precedence over wildcard matches. If both &quot;host.example.com&quot; and &quot;*.example.com&quot; exist in a zone, queries for &quot;host.example.com&quot; must return the explicit record.</p>\n</li>\n<li><p><strong>Single-Label Matching</strong>: The asterisk label matches exactly one label in the domain name hierarchy. &quot;*.example.com&quot; matches &quot;host.example.com&quot; but not &quot;web.host.example.com&quot;.</p>\n</li>\n<li><p><strong>Empty Non-Terminal Handling</strong>: Wildcard matches must respect the DNS tree structure, avoiding matches that would create inconsistencies with the hierarchical naming system.</p>\n</li>\n</ol>\n<p><strong>Resource Record TTL Management</strong></p>\n<p>Time-to-live values control how long clients and resolvers may cache DNS records, affecting both performance and the speed of DNS changes propagation. The authoritative server must handle TTL inheritance, minimum values, and response consistency.</p>\n<blockquote>\n<p><strong>Decision: TTL Inheritance and Override Rules</strong></p>\n<ul>\n<li><strong>Context</strong>: Zone files can specify TTLs at multiple levels (zone default, record-specific, type-specific), requiring a clear precedence hierarchy</li>\n<li><strong>Options Considered</strong>: Record-level TTL only with required specification, hierarchical inheritance with zone/record defaults, dynamic TTL calculation based on record type</li>\n<li><strong>Decision</strong>: Hierarchical inheritance: record-specific TTL &gt; zone $TTL directive &gt; server default TTL</li>\n<li><strong>Rationale</strong>: Provides flexibility for zone administrators while ensuring all records have valid TTL values without requiring explicit specification</li>\n<li><strong>Consequences</strong>: Simplifies zone file management but requires careful TTL inheritance tracking during parsing</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>TTL Source</th>\n<th>Precedence Level</th>\n<th>Scope</th>\n<th>Override Capability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Record-specific TTL</td>\n<td>1 (highest)</td>\n<td>Individual record</td>\n<td>Overrides all defaults</td>\n</tr>\n<tr>\n<td>Zone $TTL directive</td>\n<td>2</td>\n<td>Entire zone file</td>\n<td>Overrides server defaults</td>\n</tr>\n<tr>\n<td>Server default TTL</td>\n<td>3 (lowest)</td>\n<td>Global fallback</td>\n<td>Used when no other TTL specified</td>\n</tr>\n<tr>\n<td>SOA minimum TTL</td>\n<td>Special</td>\n<td>Negative caching</td>\n<td>Controls NXDOMAIN cache time</td>\n</tr>\n</tbody></table>\n<p><strong>Error Response Generation</strong></p>\n<p>Authoritative servers must generate appropriate error responses for various failure conditions, ensuring clients receive useful information about why queries cannot be satisfied.</p>\n<p>The server distinguishes between several categories of query failures, each requiring different response codes and additional information:</p>\n<ul>\n<li><p><strong>NXDOMAIN (Name Error)</strong>: The queried domain name does not exist within the zone. The response includes the zone&#39;s SOA record in the authority section to provide negative caching parameters and prove the server&#39;s authority to make this assertion.</p>\n</li>\n<li><p><strong>NODATA (No Error, No Data)</strong>: The queried domain name exists but has no records of the requested type. The response has an empty answer section but includes NS records in the authority section to confirm the server&#39;s authoritative status.</p>\n</li>\n<li><p><strong>Delegation (Referral)</strong>: The queried domain falls within a subdomain that has been delegated to other nameservers. The response includes NS records for the delegation in the authority section and any available glue records in the additional section.</p>\n</li>\n<li><p><strong>Format Error</strong>: The query message is malformed or contains unsupported options. The response uses the FORMERR response code and typically includes minimal additional information.</p>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incomplete Authority Section Population</strong>\nMany implementations forget to populate the authority section for negative responses, making it difficult for clients to cache negative results effectively. The SOA record in the authority section provides the minimum TTL value that determines how long the negative result should be cached, and its absence can cause inefficient repeated queries for non-existent domains.</p>\n<p><strong>Glue Record Handling</strong></p>\n<p>Glue records solve circular dependency problems that arise when nameserver names fall within the domains they serve. Without glue records, resolvers would need the very nameservers they&#39;re trying to find in order to resolve those nameservers&#39; addresses.</p>\n<p>The authoritative server must identify when glue records are necessary and include appropriate A or AAAA records in the additional section of responses containing NS records:</p>\n<ol>\n<li><p><strong>In-Bailiwick Detection</strong>: Determine when NS record targets fall within the zone being served, creating potential circular dependencies for resolvers.</p>\n</li>\n<li><p><strong>Glue Record Lookup</strong>: Find corresponding A or AAAA records for nameserver names that require glue, ensuring resolvers can contact those nameservers without additional queries.</p>\n</li>\n<li><p><strong>Additional Section Population</strong>: Include glue records in the additional section of responses, but only when they&#39;re necessary to avoid circular dependencies.</p>\n</li>\n<li><p><strong>Glue Validation</strong>: Ensure glue records are consistent with authoritative data and don&#39;t introduce security vulnerabilities through inappropriate out-of-zone data.</p>\n</li>\n</ol>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Case-Sensitive Domain Name Matching</strong>\nImplementing domain name comparisons using standard string equality without case normalization leads to failed matches when clients send queries with different capitalization than the zone file. DNS names are explicitly case-insensitive, so &quot;Example.com&quot;, &quot;EXAMPLE.COM&quot;, and &quot;example.com&quot; must all match the same zone data. The fix involves normalizing all domain names to lowercase during both parsing and query processing.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Wildcard Precedence</strong>\nReturning wildcard matches when explicit records exist violates DNS semantics and can cause unexpected behavior for clients. For example, if a zone contains both &quot;host.example.com A 192.0.2.1&quot; and &quot;*.example.com A 192.0.2.100&quot;, queries for &quot;host.example.com&quot; must return the explicit record, not the wildcard. Implement wildcard matching only after confirming no exact match exists.</p>\n<p>⚠️ <strong>Pitfall: Missing SOA in Negative Responses</strong>\nOmitting the SOA record from NXDOMAIN responses prevents proper negative caching and makes it impossible for clients to determine appropriate cache timeouts. The SOA record&#39;s minimum TTL field specifically controls negative caching duration, and its absence in the authority section violates RFC requirements. Always include the zone&#39;s SOA record in the authority section for negative responses.</p>\n<p>⚠️ <strong>Pitfall: Incomplete CNAME Chain Resolution</strong>\nStopping CNAME resolution at the first alias instead of following chains to their final targets can leave clients with incomplete answers. However, CNAME following must respect zone boundaries—don&#39;t attempt to resolve targets outside your authoritative zones. Include CNAME records in the answer section and add target records only if they fall within your authority.</p>\n<p>⚠️ <strong>Pitfall: Improper TTL Inheritance</strong>\nUsing inconsistent or missing TTL values causes unpredictable caching behavior and potential performance problems. Establish clear TTL inheritance rules (record-level TTL overrides zone default, which overrides server default) and ensure every response includes valid TTL values. Never send records with zero TTL unless specifically intended for no-cache behavior.</p>\n<p>⚠️ <strong>Pitfall: Authority Section Confusion</strong>\nIncorrectly populating the authority section with the wrong NS records or omitting it entirely makes it difficult for clients to understand the authoritative structure. For positive responses within your zones, include your zone&#39;s NS records in the authority section. For delegations, include the delegation&#39;s NS records. For negative responses, include the SOA record to prove your authority to make negative assertions.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fzone-data-model.svg\" alt=\"Zone Data and Resource Record Model\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing an authoritative DNS server in Go, including complete zone file parsing infrastructure and skeletal code for the core query processing logic.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zone File Parsing</td>\n<td>Text scanner with line-by-line processing</td>\n<td>Full RFC-compliant parser with error recovery</td>\n</tr>\n<tr>\n<td>Data Storage</td>\n<td>In-memory maps with periodic reload</td>\n<td>Database backend with change notifications</td>\n</tr>\n<tr>\n<td>Record Matching</td>\n<td>Linear search with case normalization</td>\n<td>Trie-based matching with compression</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>YAML files with manual reload</td>\n<td>Dynamic configuration with validation</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard library log package</td>\n<td>Structured logging with log levels</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>dns-server/\n  cmd/authserver/\n    main.go                    ← Authoritative server entry point\n  internal/auth/\n    server.go                  ← Authoritative server implementation\n    server_test.go            ← Server tests\n    query.go                  ← Query processing logic\n    zone.go                   ← Zone data management\n    zone_parser.go            ← BIND format zone file parser\n    zone_parser_test.go       ← Parser tests with sample zone files\n  internal/dns/\n    message.go                ← DNS message structures (from Milestone 1)\n    parser.go                 ← Wire format parsing (from Milestone 1)\n  configs/\n    zones/\n      example.com.zone        ← Sample zone files for testing\n      test.zone              ← Test zone data\n    server.yaml              ← Server configuration\n  testdata/\n    zone-files/              ← Test zone files for unit tests\n    queries/                 ← Sample query files for integration tests</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-zone-file-parser\">Infrastructure Starter Code: Zone File Parser</h4>\n<p>Complete zone file parsing implementation that handles BIND format files with proper error handling and validation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/auth/zone_parser.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> auth</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ZoneData represents parsed zone file contents</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ZoneData</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Origin      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">                           // Zone origin domain</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DefaultTTL  </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">                          // Default TTL from $TTL directive</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SOA         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#6A737D\">                  // Start of Authority record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Records     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#6A737D\"> // Domain -> Type -> Records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NSRecords   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#6A737D\">      // NS records for delegation detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ZoneParser handles BIND-format zone file parsing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ZoneParser</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    origin     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    defaultTTL </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastDomain </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lineNum    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseZoneFile reads and parses a complete zone file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseZoneFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">reader</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">origin</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ZoneData</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ZoneParser</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        origin:     </span><span style=\"color:#B392F0\">canonicalizeName</span><span style=\"color:#E1E4E8\">(origin),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        defaultTTL: </span><span style=\"color:#79B8FF\">3600</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Default 1 hour TTL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zone </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ZoneData</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Origin:    parser.origin,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Records:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        NSRecords: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scanner </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bufio.</span><span style=\"color:#B392F0\">NewScanner</span><span style=\"color:#E1E4E8\">(reader)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> currentRecord </span><span style=\"color:#B392F0\">strings</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Builder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> scanner.</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parser.lineNum</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        line </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">TrimSpace</span><span style=\"color:#E1E4E8\">(scanner.</span><span style=\"color:#B392F0\">Text</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Handle line continuation with backslash</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">HasSuffix</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            currentRecord.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(strings.</span><span style=\"color:#B392F0\">TrimSuffix</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentRecord.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fullLine </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> currentRecord.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentRecord.</span><span style=\"color:#B392F0\">Reset</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> parser.</span><span style=\"color:#B392F0\">parseLine</span><span style=\"color:#E1E4E8\">(zone, fullLine); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"line </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, parser.lineNum, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> scanner.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reading zone file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zone.DefaultTTL </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parser.defaultTTL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> zone, parser.</span><span style=\"color:#B392F0\">validateZone</span><span style=\"color:#E1E4E8\">(zone)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseLine processes a single logical line from the zone file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ZoneParser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseLine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">zone</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ZoneData</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">line</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove comments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\";\"</span><span style=\"color:#E1E4E8\">); idx </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line[:idx]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">TrimSpace</span><span style=\"color:#E1E4E8\">(line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">HasPrefix</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"$\"</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseDirective</span><span style=\"color:#E1E4E8\">(line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse resource record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseResourceRecord</span><span style=\"color:#E1E4E8\">(zone, line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseDirective handles $ORIGIN and $TTL directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ZoneParser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseDirective</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fields </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Fields</span><span style=\"color:#E1E4E8\">(line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(fields) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid directive: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">ToUpper</span><span style=\"color:#E1E4E8\">(fields[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"$ORIGIN\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.origin </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> canonicalizeName</span><span style=\"color:#E1E4E8\">(fields[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"$TTL\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ttl, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseTTL</span><span style=\"color:#E1E4E8\">(fields[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid TTL in $TTL directive: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.defaultTTL </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ttl</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unknown directive: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, fields[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// canonicalizeName converts domain names to canonical lowercase form with trailing dot</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> canonicalizeName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">ToLower</span><span style=\"color:#E1E4E8\">(strings.</span><span style=\"color:#B392F0\">TrimSpace</span><span style=\"color:#E1E4E8\">(name))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"@\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#6A737D\">  // Will be replaced with origin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">strings.</span><span style=\"color:#B392F0\">HasSuffix</span><span style=\"color:#E1E4E8\">(name, </span><span style=\"color:#9ECBFF\">\".\"</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name </span><span style=\"color:#F97583\">+=</span><span style=\"color:#9ECBFF\"> \".\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseTTL converts TTL strings to seconds, supporting time unit suffixes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseTTL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ttlStr</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ttlStr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">ToLower</span><span style=\"color:#E1E4E8\">(strings.</span><span style=\"color:#B392F0\">TrimSpace</span><span style=\"color:#E1E4E8\">(ttlStr))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle unit suffixes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    multiplier </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(ttlStr) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> ttlStr[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ttlStr)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">s</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ttlStr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ttlStr[:</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ttlStr)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            multiplier </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">m</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// minutes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ttlStr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ttlStr[:</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ttlStr)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            multiplier </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 60</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">h</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// hours</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ttlStr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ttlStr[:</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ttlStr)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            multiplier </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3600</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">d</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// days</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ttlStr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ttlStr[:</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ttlStr)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            multiplier </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 86400</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">w</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// weeks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ttlStr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ttlStr[:</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ttlStr)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            multiplier </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 604800</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseUint</span><span style=\"color:#E1E4E8\">(ttlStr, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid TTL value: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ttlStr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(value) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> multiplier, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-query-processing\">Core Logic Skeleton: Query Processing</h4>\n<p>Skeletal implementation for authoritative query processing with detailed TODOs mapping to the algorithms described in the design section:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/auth/query.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> auth</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">dns-server/internal/dns</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AuthoritativeServer handles queries for configured zones</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuthoritativeServer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zones </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ZoneData</span><span style=\"color:#6A737D\">  // Domain -> Zone data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuthConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AuthConfig holds authoritative server configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuthConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ZoneFiles    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Domain -> file path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DefaultTTL   </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SOARefresh   </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SOARetry     </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SOAExpire    </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SOAMinimum   </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessQuery handles an incoming DNS query for authoritative data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuthoritativeServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(query.Questions) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Return FORMERR for queries with != 1 question</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use dns.ResponseCode = 1 for format error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    question </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> query.Questions[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    canonicalName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> canonicalizeName</span><span style=\"color:#E1E4E8\">(question.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Determine if this server is authoritative for the queried domain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check s.zones map for the most specific zone that contains canonicalName</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Example: for \"mail.sales.example.com\", prefer \"sales.example.com\" over \"example.com\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zone, authoritative </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">findAuthoritativeZone</span><span style=\"color:#E1E4E8\">(canonicalName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">authoritative {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return REFUSED for non-authoritative queries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Set response code to dns.RCODE_REFUSED (5) and empty sections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">buildRefusedResponse</span><span style=\"color:#E1E4E8\">(query), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check for delegation within the authoritative zone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Look for NS records that delegate this specific domain to other nameservers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If delegation exists, return referral response with NS records in authority section</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Perform record matching within the zone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call s.matchRecords(zone, canonicalName, question.Type) to find answers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    records, matchType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">matchRecords</span><span style=\"color:#E1E4E8\">(zone, canonicalName, question.Type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Construct response based on match results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // matchType can be: \"exact\", \"cname\", \"wildcard\", \"nxdomain\", \"nodata\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">buildResponse</span><span style=\"color:#E1E4E8\">(query, zone, records, matchType)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Populate authority and additional sections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add NS records for positive responses, SOA for negative responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Include glue records in additional section for any NS records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.</span><span style=\"color:#B392F0\">populateAuthoritySections</span><span style=\"color:#E1E4E8\">(response, zone, matchType, question.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> response, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// findAuthoritativeZone determines which zone (if any) is authoritative for a domain</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuthoritativeServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">findAuthoritativeZone</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">domain</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ZoneData</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through s.zones to find the most specific match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Example: for \"mail.example.com\", check \"mail.example.com\", \"example.com\", \"com\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return the zone with the longest matching suffix and true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If no zone matches, return nil and false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use strings.HasSuffix() for suffix matching</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// matchRecords finds the best matching records for a query within a zone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuthoritativeServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">matchRecords</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">zone</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ZoneData</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">domain</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">qtype</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check for exact domain match in zone.Records[domain]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If domain exists, proceed to type matching</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for exact type match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If zone.Records[domain][qtype] exists, return those records with \"exact\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for CNAME record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If zone.Records[domain][dns.TYPE_CNAME] exists, return CNAME with \"cname\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: CNAME cannot coexist with other record types for the same name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If domain doesn't exist, check for wildcard matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Look for \"*.parent-domain\" patterns that could match this domain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wildcard matching rules: single label replacement, no delegation crossing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Determine negative response type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If domain exists but no matching type: return empty slice with \"nodata\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If domain doesn't exist and no wildcard: return empty slice with \"nxdomain\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"nxdomain\"</span><span style=\"color:#6A737D\">  // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// buildResponse constructs the basic DNS response message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuthoritativeServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">buildResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">zone</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ZoneData</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">records</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">matchType</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Header: </span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ID: query.Header.ID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            QueryResponse: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Opcode: query.Header.Opcode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Authoritative: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// We are authoritative for this zone</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            RecursionDesired: query.Header.RecursionDesired,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            RecursionAvail: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Authoritative servers don't do recursion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Questions: query.Questions,  </span><span style=\"color:#6A737D\">// Echo the question</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set appropriate response code based on matchType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // \"exact\", \"cname\", \"wildcard\" -> RCODE 0 (NOERROR)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // \"nxdomain\" -> RCODE 3 (NXDOMAIN) </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // \"nodata\" -> RCODE 0 (NOERROR) with empty answer section</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Populate answer section for positive responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add records to response.Answers for exact, cname, and wildcard matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Leave answer section empty for negative responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle CNAME chain resolution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If matchType is \"cname\", check if CNAME target is also in this zone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If so, add target records to answer section as well</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// populateAuthoritySections adds authority and additional section records</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuthoritativeServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">populateAuthoritySections</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">response</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">zone</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ZoneData</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">matchType</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">queryName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Add authority section for positive responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Include NS records for the zone in response.Authority</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use zone.NSRecords to find NS records for the zone origin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add SOA record for negative responses  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For \"nxdomain\" and \"nodata\" responses, add zone.SOA to response.Authority</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SOA record proves authority to make negative assertions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add glue records to additional section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For each NS record in authority section, check if NS hostname is in-zone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If so, add corresponding A/AAAA records to response.Additional</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This prevents circular dependencies in resolution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update header counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set response.Header.AnswerCount = len(response.Answers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set response.Header.AuthorityCount = len(response.Authority)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set response.Header.AdditionalCount = len(response.Additional)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-go\">Language-Specific Hints for Go</h4>\n<ul>\n<li><strong>Zone File Reading</strong>: Use <code>os.Open()</code> with <code>bufio.Scanner</code> for efficient line-by-line processing of large zone files</li>\n<li><strong>String Comparison</strong>: Use <code>strings.EqualFold()</code> for case-insensitive comparison, or <code>strings.ToLower()</code> for normalization</li>\n<li><strong>Map Initialization</strong>: Initialize nested maps with <code>make()</code> before assignment: <code>zone.Records[domain] = make(map[uint16][]ResourceRecord)</code></li>\n<li><strong>IP Address Parsing</strong>: Use <code>net.ParseIP()</code> to validate IPv4/IPv6 addresses in A and AAAA record data</li>\n<li><strong>TTL Parsing</strong>: Handle time unit suffixes (s, m, h, d, w) with <code>strings.HasSuffix()</code> and conversion multipliers</li>\n<li><strong>Error Wrapping</strong>: Use <code>fmt.Errorf(&quot;context: %w&quot;, err)</code> to maintain error chains for debugging zone file parse errors</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing this milestone, verify authoritative server functionality with these steps:</p>\n<p><strong>Test Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run unit tests for zone parsing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/auth/...</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start authoritative server on localhost:5353  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/authserver/main.go</span><span style=\"color:#79B8FF\"> -port</span><span style=\"color:#79B8FF\"> 5353</span><span style=\"color:#79B8FF\"> -config</span><span style=\"color:#9ECBFF\"> configs/server.yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Query for A record (should return authoritative answer)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @127.0.0.1</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 5353</span><span style=\"color:#9ECBFF\"> example.com</span><span style=\"color:#9ECBFF\"> A</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Query for non-existent domain (should return NXDOMAIN with SOA in authority)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @127.0.0.1</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 5353</span><span style=\"color:#9ECBFF\"> nonexistent.example.com</span><span style=\"color:#9ECBFF\"> A</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Query for existing domain with non-existent type (should return NODATA)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @127.0.0.1</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 5353</span><span style=\"color:#9ECBFF\"> example.com</span><span style=\"color:#9ECBFF\"> AAAA</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>Zone file parser successfully loads BIND-format files with SOA, NS, A, AAAA, CNAME, and MX records</li>\n<li>Queries for existing records return authoritative responses (AA bit set) with populated answer section</li>\n<li>NXDOMAIN responses include SOA record in authority section with appropriate TTL values</li>\n<li>NODATA responses have empty answer section but NS records in authority section  </li>\n<li>Response header counts match the actual number of records in each section</li>\n</ul>\n<p><strong>Troubleshooting Signs:</strong></p>\n<ul>\n<li>Parse errors usually indicate malformed zone file syntax or unsupported record types</li>\n<li>Missing AA (Authoritative Answer) flag means the server doesn&#39;t recognize its authority for the queried domain</li>\n<li>Empty authority sections in negative responses prevent proper client-side negative caching</li>\n<li>Incorrect response codes (REFUSED vs NXDOMAIN vs NOERROR) indicate query classification bugs</li>\n</ul>\n<h2 id=\"recursive-resolver-milestone-3\">Recursive Resolver (Milestone 3)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 3 (Recursive Resolver)</p>\n</blockquote>\n<p>The recursive resolver represents the heart of a full-featured DNS server, implementing the complex dance of iterative resolution that follows the DNS hierarchy from root servers down to authoritative nameservers. Unlike authoritative servers that simply answer from local zone data, or forwarding servers that delegate all work to upstream resolvers, a recursive resolver takes complete responsibility for finding answers by systematically querying the distributed DNS infrastructure.</p>\n<p>This milestone transforms your DNS server from a simple authoritative responder into a sophisticated resolver capable of answering queries for any domain on the internet. The implementation challenges center around managing the stateful resolution process, handling referrals correctly, avoiding circular dependencies through glue records, and maintaining robustness in the face of network failures and malformed responses.</p>\n<h3 id=\"mental-model-recursive-resolution-as-detective-work\">Mental Model: Recursive Resolution as Detective Work</h3>\n<p>Think of recursive DNS resolution as detective work investigating a missing person case across multiple jurisdictions. When someone asks &quot;Where is John Smith?&quot;, you don&#39;t immediately know the answer, but you know the systematic process to find out.</p>\n<p>You start at the highest authority - like contacting the federal government, which might say &quot;John Smith? That name suggests he&#39;s probably in the United States. Try asking the state of California - here&#39;s their contact information.&quot; The federal authority doesn&#39;t know John Smith personally, but they know who has jurisdiction over California addresses.</p>\n<p>So you contact California, who says &quot;John Smith in California? That&#39;s a common name, but based on the specific details you&#39;re looking for, try the city of San Francisco - here&#39;s how to reach them.&quot; Again, California doesn&#39;t know John Smith directly, but they know which local authority would have that information.</p>\n<p>Finally, you contact San Francisco&#39;s city hall, who says &quot;Yes! John Smith lives at 123 Main Street. Here&#39;s his current address and phone number.&quot; San Francisco is the <strong>authoritative source</strong> for information about San Francisco residents - they maintain the definitive records.</p>\n<p>In DNS terms, your recursive resolver plays the detective role. When a client asks for <code>www.example.com</code>, you start by asking the <strong>root servers</strong> (the federal government equivalent), who refer you to the <code>.com</code> <strong>Top-Level Domain (TLD) servers</strong> (state level). The <code>.com</code> servers then refer you to the <strong>authoritative nameservers</strong> for <code>example.com</code> (city level), who finally provide the definitive answer.</p>\n<p>The key insight is that each level of authority knows about the level below it, but not the specific details two levels down. Root servers know about TLD servers, TLD servers know about authoritative nameservers for domains, but root servers don&#39;t directly know about specific hostnames within domains. This hierarchical referral system distributes the massive namespace across thousands of servers while ensuring every query can eventually reach the authoritative source.</p>\n<p>Just like a detective must follow leads methodically and avoid being sent in circles by false information, your recursive resolver must follow referrals carefully, validate responses, and guard against malicious servers trying to redirect queries inappropriately.</p>\n<h3 id=\"iterative-resolution-algorithm\">Iterative Resolution Algorithm</h3>\n<p>The iterative resolution process follows a systematic sequence that mirrors the hierarchical structure of the DNS namespace. Understanding this algorithm is crucial because it represents the core logic that transforms your server from a simple message parser into a full-featured resolver.</p>\n<p>The resolution process begins when your server receives a query from a client. Unlike a forwarding resolver that would immediately pass this query to an upstream server, your recursive resolver takes personal responsibility for finding the answer through the following systematic approach:</p>\n<p><strong>Phase 1: Query Preparation and Cache Check</strong></p>\n<p>The resolver first examines the incoming question to understand what information is being requested. It extracts the domain name, record type (A, AAAA, CNAME, etc.), and class (almost always IN for internet) from the question section. Before initiating any network queries, the resolver checks its local cache to see if it already knows the answer. This cache lookup uses the combination of domain name, record type, and class as the cache key, following the same <code>CacheKey</code> structure established in previous milestones.</p>\n<p>If a valid, non-expired cache entry exists, the resolver constructs a response immediately and returns it to the client. This represents the fastest possible resolution path and dramatically reduces load on upstream servers. However, if the cache misses or contains only expired entries, the resolver proceeds to active resolution.</p>\n<p><strong>Phase 2: Root Server Bootstrap</strong></p>\n<p>The resolver initializes its search at the top of the DNS hierarchy by selecting a root server from its configured root hints. The <strong>root hints</strong> are a predefined list of IP addresses for the 13 logical root servers (a.root-servers.net through m.root-servers.net) that form the foundation of the global DNS system. These addresses are typically hardcoded in the resolver configuration or loaded from a root hints file.</p>\n<p>The resolver constructs a DNS query message identical to the original client query and sends it via UDP to the selected root server. The query asks for the same domain name and record type that the client requested. For example, if the client asked for the A record of <code>www.example.com</code>, the resolver asks the root server for the A record of <code>www.example.com</code>.</p>\n<p><strong>Phase 3: Root Server Response Processing</strong></p>\n<p>The root server typically responds with a referral rather than a direct answer. The response contains no answer records but includes NS records in the authority section pointing to the TLD servers responsible for the domain&#39;s top-level domain. For a query about <code>www.example.com</code>, the root server returns NS records pointing to the <code>.com</code> TLD servers.</p>\n<p>Critically, the root server also includes <strong>glue records</strong> in the additional section. These are A and AAAA records providing the IP addresses of the TLD nameservers mentioned in the NS records. Without these glue records, the resolver would face a circular dependency: to resolve <code>www.example.com</code>, it needs to contact the <code>.com</code> TLD servers, but to find the <code>.com</code> TLD servers, it would need to resolve their domain names, which would require contacting the <code>.com</code> TLD servers.</p>\n<p>The resolver extracts both the NS records (indicating where to go next) and the glue records (providing the IP addresses needed to get there) from the response. It validates that these records are within the proper <strong>bailiwick</strong> - meaning the root server only provides information it&#39;s authoritative for and doesn&#39;t inject unrelated records that could be used for cache poisoning attacks.</p>\n<p><strong>Phase 4: TLD Server Query</strong></p>\n<p>Using the IP addresses from the glue records, the resolver selects one of the TLD servers and sends the same query. The TLD server for <code>.com</code> knows about all the authoritative nameservers for domains within the <code>.com</code> zone but doesn&#39;t know about specific hostnames within those domains.</p>\n<p>The TLD server responds with another referral, this time providing NS records pointing to the authoritative nameservers for <code>example.com</code>. Again, it includes glue records in the additional section with the IP addresses of these authoritative nameservers. The resolver processes this response identically to the root server response, extracting NS records and glue records while validating bailiwick.</p>\n<p><strong>Phase 5: Authoritative Server Query</strong></p>\n<p>Finally, the resolver queries one of the authoritative nameservers for <code>example.com</code>. This server is responsible for maintaining the definitive records for the <code>example.com</code> zone and can provide a final answer rather than another referral.</p>\n<p>The authoritative server responds with the requested records in the answer section. For an A record query, this would be one or more A records containing IPv4 addresses. The resolver validates that these answer records match the original question (same domain name and record type) and that they come from an authoritative source.</p>\n<p><strong>Phase 6: Response Construction and Caching</strong></p>\n<p>The resolver constructs a response message for the original client, copying the answer records from the authoritative server&#39;s response. Before sending this response, it stores all received records in its cache with their respective TTL values. This includes not just the final answer records but also the NS and glue records received during the referral process, as these may be useful for future queries.</p>\n<p>The resolver sends the completed response back to the original client, fulfilling the recursive query. From the client&#39;s perspective, the resolver provided a direct answer, hiding the complexity of the multi-step resolution process.</p>\n<p>Here&#39;s the detailed algorithmic breakdown:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Action</th>\n<th>Input</th>\n<th>Output</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Parse client query</td>\n<td>UDP packet</td>\n<td><code>Question</code> struct</td>\n<td>Return FORMERR for malformed messages</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Check cache lookup</td>\n<td><code>CacheKey{Name, Type, Class}</code></td>\n<td><code>CacheEntry</code> or miss</td>\n<td>Continue on cache miss</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Select root server</td>\n<td>Root hints list</td>\n<td>Root server IP</td>\n<td>Try next server on timeout</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Send query to root</td>\n<td><code>DNSMessage</code> + root IP</td>\n<td>Root response</td>\n<td>Retry with different root on failure</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Process root referral</td>\n<td>Root response</td>\n<td>TLD NS records + glue</td>\n<td>Return SERVFAIL on invalid response</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Select TLD server</td>\n<td>Glue records</td>\n<td>TLD server IP</td>\n<td>Try next TLD server on failure</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Send query to TLD</td>\n<td>Same query + TLD IP</td>\n<td>TLD response</td>\n<td>Retry with different TLD server</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Process TLD referral</td>\n<td>TLD response</td>\n<td>Auth NS records + glue</td>\n<td>Return SERVFAIL on invalid response</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Select auth server</td>\n<td>Auth glue records</td>\n<td>Auth server IP</td>\n<td>Try next auth server on failure</td>\n</tr>\n<tr>\n<td>10</td>\n<td>Send query to auth</td>\n<td>Same query + auth IP</td>\n<td>Final answer</td>\n<td>Return SERVFAIL on all failures</td>\n</tr>\n<tr>\n<td>11</td>\n<td>Validate answer</td>\n<td>Auth response</td>\n<td>Validated records</td>\n<td>Return SERVFAIL on validation failure</td>\n</tr>\n<tr>\n<td>12</td>\n<td>Cache all records</td>\n<td>All RRs from resolution</td>\n<td>Updated cache</td>\n<td>Log cache errors but continue</td>\n</tr>\n<tr>\n<td>13</td>\n<td>Construct response</td>\n<td>Answer records</td>\n<td>Client response</td>\n<td>Return SERVFAIL on construction failure</td>\n</tr>\n<tr>\n<td>14</td>\n<td>Send to client</td>\n<td>Response + client addr</td>\n<td>UDP transmission</td>\n<td>Log transmission errors</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The iterative resolution algorithm is stateless from the perspective of the servers being queried. Each server (root, TLD, authoritative) receives a complete question and provides a complete response. The resolver maintains all the state needed to follow the referral chain and construct the final answer.</p>\n</blockquote>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Frecursive-resolution-flow.svg\" alt=\"Recursive Resolution Sequence\"></p>\n<h3 id=\"glue-records-and-circular-dependencies\">Glue Records and Circular Dependencies</h3>\n<p>One of the most critical aspects of DNS resolution involves understanding and properly handling glue records. These records solve a fundamental bootstrapping problem that would otherwise create unsolvable circular dependencies in the DNS system.</p>\n<p><strong>The Circular Dependency Problem</strong></p>\n<p>Consider the domain <code>example.com</code> whose authoritative nameservers are <code>ns1.example.com</code> and <code>ns2.example.com</code>. When a resolver queries the <code>.com</code> TLD servers asking &quot;What are the nameservers for example.com?&quot;, it receives NS records pointing to <code>ns1.example.com</code> and <code>ns2.example.com</code>. However, to contact these nameservers, the resolver needs their IP addresses, which requires resolving <code>ns1.example.com</code> and <code>ns2.example.com</code>. But to resolve those names, the resolver needs to ask... the authoritative nameservers for <code>example.com</code>, which are <code>ns1.example.com</code> and <code>ns2.example.com</code>.</p>\n<p>This creates an infinite loop: to resolve <code>example.com</code>, you need to contact its nameservers, but to contact its nameservers, you need to resolve <code>example.com</code>. Without a mechanism to break this cycle, resolution would be impossible for any domain whose nameservers are within the same domain.</p>\n<p><strong>Glue Records as the Solution</strong></p>\n<p>Glue records solve this problem by providing the IP addresses of nameservers when the nameserver names fall within the same domain they&#39;re authoritative for. When the <code>.com</code> TLD servers respond with NS records pointing to <code>ns1.example.com</code> and <code>ns2.example.com</code>, they also include A records in the additional section providing the IP addresses of these nameservers:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>;; AUTHORITY SECTION:\nexample.com.    172800  IN  NS  ns1.example.com.\nexample.com.    172800  IN  NS  ns2.example.com.\n\n;; ADDITIONAL SECTION:\nns1.example.com.    172800  IN  A   192.0.2.1\nns2.example.com.    172800  IN  A   192.0.2.2</code></pre></div>\n\n<p>These A records in the additional section are the glue records. They&#39;re called &quot;glue&quot; because they glue together the referral chain, providing the essential information needed to continue resolution.</p>\n<p><strong>Bailiwick Validation for Glue Records</strong></p>\n<p>Your resolver must carefully validate glue records to prevent cache poisoning attacks. The concept of <strong>bailiwick</strong> determines which glue records a server is allowed to provide. A server can only provide glue records for nameserver names that fall within the domain it&#39;s authoritative for.</p>\n<p>For example, the <code>.com</code> TLD servers can provide glue records for <code>ns1.example.com</code> because <code>ns1.example.com</code> is within the <code>.com</code> domain that the TLD servers are authoritative for. However, if the NS records pointed to <code>ns1.otherdomain.net</code>, the <code>.com</code> TLD servers should NOT provide glue records for that name, because <code>.net</code> names are outside their bailiwick.</p>\n<p>The bailiwick validation algorithm works as follows:</p>\n<table>\n<thead>\n<tr>\n<th>Nameserver Name</th>\n<th>Authoritative Zone</th>\n<th>Glue Allowed?</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ns1.example.com</code></td>\n<td><code>.com</code> TLD</td>\n<td>Yes</td>\n<td>Nameserver is within .com domain</td>\n</tr>\n<tr>\n<td><code>ns2.example.com</code></td>\n<td><code>.com</code> TLD</td>\n<td>Yes</td>\n<td>Nameserver is within .com domain</td>\n</tr>\n<tr>\n<td><code>ns1.otherdomain.net</code></td>\n<td><code>.com</code> TLD</td>\n<td>No</td>\n<td>Nameserver is in .net, outside bailiwick</td>\n</tr>\n<tr>\n<td><code>external.nameserver.org</code></td>\n<td><code>example.com</code> zone</td>\n<td>No</td>\n<td>Nameserver is outside example.com domain</td>\n</tr>\n<tr>\n<td><code>internal.example.com</code></td>\n<td><code>example.com</code> zone</td>\n<td>Yes</td>\n<td>Nameserver is within example.com domain</td>\n</tr>\n</tbody></table>\n<p><strong>Processing Glue Records in Resolution</strong></p>\n<p>When your resolver receives a referral response, it must extract and process glue records correctly. The algorithm follows these steps:</p>\n<ol>\n<li><p><strong>Extract NS Records</strong>: Parse the authority section to identify the nameservers for the next level of resolution.</p>\n</li>\n<li><p><strong>Extract Glue Records</strong>: Parse the additional section to find A and AAAA records that correspond to the nameserver names from step 1.</p>\n</li>\n<li><p><strong>Validate Bailiwick</strong>: Verify that each glue record is within the authoritative scope of the server that provided it.</p>\n</li>\n<li><p><strong>Build Nameserver List</strong>: Create a list of nameservers with their associated IP addresses, using glue records where available.</p>\n</li>\n<li><p><strong>Handle Missing Glue</strong>: For nameservers that don&#39;t have glue records, note that their IP addresses must be resolved separately before they can be contacted.</p>\n</li>\n</ol>\n<p><strong>Cache Management for Glue Records</strong></p>\n<p>Glue records present interesting cache management challenges because they serve dual purposes. A glue record for <code>ns1.example.com</code> functions both as a nameserver address for resolving <code>example.com</code> queries and as a regular A record that could answer direct queries for <code>ns1.example.com</code>.</p>\n<p>Your cache should store glue records with their full TTL values, allowing them to be reused for future resolutions. However, you must be careful about the authority of cached glue records. A glue record provided by the <code>.com</code> TLD servers should not be considered authoritative for direct queries about <code>ns1.example.com</code> - only the <code>example.com</code> authoritative servers can provide authoritative answers for names within their zone.</p>\n<p><strong>Error Handling Without Glue</strong></p>\n<p>When glue records are missing for in-bailiwick nameservers, your resolver faces a bootstrapping challenge. The proper approach is to temporarily set aside the current resolution and initiate a separate recursive resolution for the nameserver&#39;s IP address. This creates a recursive resolution within recursive resolution:</p>\n<ol>\n<li>Main resolution for <code>www.example.com</code> encounters NS records for <code>ns1.example.com</code></li>\n<li>No glue records provided for <code>ns1.example.com</code></li>\n<li>Initiate separate resolution for <code>ns1.example.com A record</code></li>\n<li>Once <code>ns1.example.com</code> resolves to an IP address, resume main resolution</li>\n<li>Continue with original query to the now-known nameserver IP</li>\n</ol>\n<p>This approach requires careful state management to avoid infinite recursion and to detect genuine circular dependencies that cannot be resolved.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Trusting Out-of-Bailiwick Glue</strong></p>\n<p>A common security vulnerability occurs when resolvers blindly trust glue records that fall outside the providing server&#39;s bailiwick. For example, if a <code>.com</code> TLD server provides a glue record for <code>ns1.evil.net</code>, your resolver should ignore this record because <code>.net</code> names are outside the <code>.com</code> server&#39;s authority. Accepting such records can lead to cache poisoning attacks where malicious servers redirect your queries to attacker-controlled IP addresses.</p>\n</blockquote>\n<h3 id=\"architecture-decisions-for-recursion\">Architecture Decisions for Recursion</h3>\n<p>The recursive resolver implementation involves several critical architectural decisions that significantly impact the server&#39;s performance, reliability, and security characteristics. Each decision represents a trade-off between competing concerns, and understanding the rationale behind these choices is essential for building a robust resolver.</p>\n<blockquote>\n<p><strong>Decision: Loop Detection Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Recursive resolution can encounter infinite loops due to misconfigured DNS zones, malicious servers providing circular referrals, or bugs in the resolver logic. Without proper loop detection, the resolver could consume unbounded resources and never return a response to the client.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Maximum iteration count limiting total queries per resolution</li>\n<li>Visited nameserver tracking to detect cycles in server queries  </li>\n<li>Query depth limiting based on DNS hierarchy levels</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement maximum iteration count with a reasonable limit (typically 10-15 queries per resolution)</li>\n<li><strong>Rationale</strong>: Maximum iteration count provides the strongest protection against all types of loops while being simple to implement and reason about. Most legitimate DNS resolutions require fewer than 10 queries (root → TLD → authoritative, plus possible CNAME following), so a limit of 15 provides safety margin without impacting normal operation.</li>\n<li><strong>Consequences</strong>: Enables robust operation in hostile network environments but may fail to resolve extremely deep or complex DNS configurations. Requires careful tuning of the limit value.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Loop Detection Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Maximum iteration count</td>\n<td>Simple, comprehensive protection</td>\n<td>May block legitimate deep recursions</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Visited server tracking</td>\n<td>Precise cycle detection</td>\n<td>Complex state management, memory overhead</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Query depth limiting</td>\n<td>Maps to DNS hierarchy</td>\n<td>Doesn&#39;t prevent horizontal loops</td>\n<td>Low</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Timeout and Retry Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS queries over UDP can be lost due to network congestion, server overload, or routing failures. The resolver must balance responsiveness (returning answers quickly) with reliability (finding answers despite transient failures).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Single query with fixed timeout per server</li>\n<li>Exponential backoff with multiple retries per server</li>\n<li>Parallel queries to multiple servers with first-response wins</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement single query with 2-second timeout, try all available servers before giving up</li>\n<li><strong>Rationale</strong>: DNS queries should typically complete within 1-2 seconds under normal conditions. Rather than spending time on retries to unresponsive servers, it&#39;s more effective to try alternative servers immediately. This provides better user experience and more effectively handles server-specific failures.</li>\n<li><strong>Consequences</strong>: Provides good balance of speed and reliability while keeping implementation simple. May not handle transient network glitches as well as retry-based approaches.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Timeout Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>User Experience</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fixed timeout, try all servers</td>\n<td>Fast failure detection, simple</td>\n<td>Less resilient to transient failures</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Exponential backoff retries</td>\n<td>Handles transient issues well</td>\n<td>Slower response times</td>\n<td>Poor</td>\n</tr>\n<tr>\n<td>Parallel queries</td>\n<td>Fastest response</td>\n<td>Higher bandwidth usage, server load</td>\n<td>Excellent</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: CNAME Following Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: CNAME records create aliases that point from one domain name to another. When a resolver encounters a CNAME, it must follow the chain to the final target to find the requested record type. CNAME chains can be complex, involving multiple hops and crossing zone boundaries.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Recursive CNAME following with separate resolution for each target</li>\n<li>Iterative CNAME following within the same resolution context</li>\n<li>CNAME chain limit with immediate error on cycles</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement iterative CNAME following with a chain length limit of 10 and cycle detection</li>\n<li><strong>Rationale</strong>: Iterative following within the same resolution context is more efficient and maintains better cache coherency. The chain limit prevents infinite loops while accommodating legitimate multi-hop CNAME configurations. Cycle detection provides additional safety against misconfigured zones.</li>\n<li><strong>Consequences</strong>: Provides robust CNAME handling with good performance characteristics. Chain limit may be too restrictive for some complex configurations but prevents abuse.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>CNAME Handling Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Recursive resolution</td>\n<td>Clean separation of concerns</td>\n<td>Higher latency, cache fragmentation</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Iterative following</td>\n<td>Better performance, cache coherency</td>\n<td>More complex state management</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Immediate error on CNAME</td>\n<td>Simple, fast</td>\n<td>Breaks many legitimate configurations</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Concurrent Query Processing</strong></p>\n<ul>\n<li><strong>Context</strong>: A recursive resolver may receive multiple queries simultaneously and should handle them efficiently without blocking. Each recursive resolution may involve multiple network round-trips, creating opportunities for parallelism.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Goroutine per client query with shared cache</li>\n<li>Worker pool processing queries from a queue</li>\n<li>Single-threaded event loop with async I/O</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use goroutine per client query with carefully synchronized cache access</li>\n<li><strong>Rationale</strong>: Go&#39;s goroutines provide excellent concurrency primitives with low overhead. Each client query involves multiple network operations that benefit from parallel execution. Shared cache maximizes efficiency by allowing concurrent queries to benefit from each other&#39;s resolution work.</li>\n<li><strong>Consequences</strong>: Excellent performance and scalability with straightforward implementation. Requires careful synchronization of shared state but Go&#39;s sync package provides good primitives for this.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Concurrency Model</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Scalability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Goroutine per query</td>\n<td>Simple, excellent parallelism</td>\n<td>Requires synchronization</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td>Worker pool</td>\n<td>Bounded resource usage</td>\n<td>More complex, potential queuing delays</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Single-threaded async</td>\n<td>No synchronization needed</td>\n<td>Complex state machines</td>\n<td>Limited</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Response Validation Strictness</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS responses from remote servers may contain malformed data, out-of-bailiwick records, or potentially malicious content. The resolver must balance security (rejecting invalid responses) with interoperability (working with imperfect server implementations).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Strict validation rejecting any protocol violations</li>\n<li>Permissive validation accepting common protocol deviations</li>\n<li>Configurable validation with security/compatibility modes</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement strict validation for security-critical aspects (bailiwick, record matching) but permissive for formatting issues</li>\n<li><strong>Rationale</strong>: Security violations like out-of-bailiwick records can enable cache poisoning attacks and must be rejected. However, minor formatting issues in responses are common in real-world DNS and shouldn&#39;t break resolution. This approach maximizes both security and interoperability.</li>\n<li><strong>Consequences</strong>: Provides strong security guarantees while maintaining compatibility with the existing DNS ecosystem. May require ongoing tuning as new edge cases are discovered.</li>\n</ul>\n</blockquote>\n<p>The resolver maintains several critical data structures to support these architectural decisions:</p>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Purpose</th>\n<th>Key Fields</th>\n<th>Synchronization</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ResolverConfig</code></td>\n<td>Resolution behavior parameters</td>\n<td><code>RootHints</code>, <code>Timeout</code>, <code>MaxDepth</code></td>\n<td>Read-only after initialization</td>\n</tr>\n<tr>\n<td><code>ResolutionState</code></td>\n<td>Per-query resolution tracking</td>\n<td><code>QueryCount</code>, <code>VisitedServers</code>, <code>CNAMEChain</code></td>\n<td>Per-goroutine, no synchronization needed</td>\n</tr>\n<tr>\n<td><code>CacheManager</code></td>\n<td>Shared resolution cache</td>\n<td><code>entries map[CacheKey]CacheEntry</code></td>\n<td>Mutex-protected for concurrent access</td>\n</tr>\n<tr>\n<td><code>NetworkClient</code></td>\n<td>UDP query/response handling</td>\n<td><code>conn net.PacketConn</code>, <code>timeout time.Duration</code></td>\n<td>Thread-safe through net package</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Infinite CNAME Loops</strong></p>\n<p>CNAME records can create infinite loops where domain A points to domain B, which points back to domain A. Without proper cycle detection, your resolver will follow this loop forever, eventually hitting the query count limit and returning SERVFAIL. Implement explicit CNAME cycle detection by maintaining a set of visited names during CNAME following. If you encounter a name you&#39;ve already visited in the current chain, immediately return SERVFAIL with an appropriate error message.</p>\n</blockquote>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Cache Poisoning Through Glue Records</strong></p>\n<p>Malicious authoritative servers might try to poison your cache by providing glue records for domains outside their authority. For example, a server authoritative for <code>evil.com</code> might try to provide a glue record claiming that <code>www.google.com</code> resolves to an IP address they control. Always validate that glue records fall within the bailiwick of the server providing them, and never cache or use glue records that fall outside this scope.</p>\n</blockquote>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Unbounded Resource Consumption</strong></p>\n<p>Without proper limits, recursive resolution can consume unbounded memory and network resources. A single malicious query could trigger thousands of recursive lookups, exhausting server resources. Implement strict limits on query count per resolution, CNAME chain length, concurrent resolutions per client, and cache memory usage. These limits should be generous enough for legitimate use but strict enough to prevent abuse.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The recursive resolver represents the most complex component of your DNS server, requiring careful orchestration of network operations, state management, and error handling. This implementation guidance provides the complete foundation and skeleton code needed to build a robust recursive resolver.</p>\n<p><strong>A. Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Transport</td>\n<td><code>net.Dial()</code> with manual UDP</td>\n<td><code>golang.org/x/net/dns</code> package</td>\n</tr>\n<tr>\n<td>Concurrent Processing</td>\n<td>Goroutines with <code>sync.Mutex</code></td>\n<td>Worker pools with channels</td>\n</tr>\n<tr>\n<td>Timeout Management</td>\n<td><code>context.WithTimeout()</code></td>\n<td>Custom timeout manager</td>\n</tr>\n<tr>\n<td>DNS Message Construction</td>\n<td>Manual serialization</td>\n<td>Third-party DNS library</td>\n</tr>\n<tr>\n<td>Root Hints Storage</td>\n<td>Hardcoded slice</td>\n<td>External hints file</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/resolver/\n├── resolver.go              ← Main recursive resolver logic\n├── resolver_test.go         ← Comprehensive resolver tests  \n├── iterative.go            ← Iterative resolution algorithm\n├── glue.go                 ← Glue record handling\n├── cname.go                ← CNAME following logic\n├── validation.go           ← Response validation\n├── roothints.go            ← Root server bootstrap data\n└── testdata/\n    ├── root-hints.txt      ← Root server IP addresses\n    └── test-responses/     ← Canned DNS responses for testing</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<p>Here&#39;s the complete root hints management system that handles bootstrapping resolution:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> resolver</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RootHints manages the IP addresses of DNS root servers for bootstrap resolution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RootHints</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    servers []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DefaultRootHints returns hardcoded root server IP addresses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// These are the actual IP addresses of the DNS root servers as of 2024</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DefaultRootHints</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RootHints</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RootHints</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        servers: []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"198.41.0.4\"</span><span style=\"color:#E1E4E8\">,     </span><span style=\"color:#6A737D\">// a.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"170.247.170.2\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// b.root-servers.net  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"192.33.4.12\"</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\">// c.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"199.7.91.13\"</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\">// d.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"192.203.230.10\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// e.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"192.5.5.241\"</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\">// f.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"192.112.36.4\"</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\">// g.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"198.97.190.53\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// h.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"192.36.148.17\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// i.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"192.58.128.30\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// j.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"193.0.14.129\"</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\">// k.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"199.7.83.42\"</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\">// l.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"202.12.27.33\"</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\">// m.root-servers.net</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NextServer returns the next root server IP to try, cycling through all servers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rh </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RootHints</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NextServer</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(rh.servers) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rh.servers[rh.current]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rh.current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (rh.current </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(rh.servers)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AllServers returns all root server IPs for parallel querying</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rh </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RootHints</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AllServers</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">), rh.servers</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkClient handles UDP DNS query/response operations with timeout support</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkClient</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn    </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PacketConn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewNetworkClient creates a UDP client for DNS queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewNetworkClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkClient</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> net.</span><span style=\"color:#B392F0\">ListenPacket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"udp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\":0\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create UDP socket: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">NetworkClient</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        conn:    conn,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timeout: timeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// QueryServer sends a DNS query to the specified server and returns the response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">nc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">QueryServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">query</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">serverIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> net.</span><span style=\"color:#B392F0\">ResolveUDPAddr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"udp\"</span><span style=\"color:#E1E4E8\">, serverIP</span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\">\":53\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid server address </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, serverIP, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set deadline based on context timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deadline, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Deadline</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ok {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nc.conn.</span><span style=\"color:#B392F0\">SetWriteDeadline</span><span style=\"color:#E1E4E8\">(deadline)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nc.conn.</span><span style=\"color:#B392F0\">WriteTo</span><span style=\"color:#E1E4E8\">(query, addr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to send query to </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, serverIP, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Receive response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, DNS_UDP_MAX_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ok {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nc.conn.</span><span style=\"color:#B392F0\">SetReadDeadline</span><span style=\"color:#E1E4E8\">(deadline)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n, _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> nc.conn.</span><span style=\"color:#B392F0\">ReadFrom</span><span style=\"color:#E1E4E8\">(buffer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to receive response from </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, serverIP, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buffer[:n], </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close releases the UDP socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">nc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> nc.conn.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<p>Here&#39;s the main recursive resolver structure with detailed TODO comments mapping to the algorithm steps:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// RecursiveResolver implements iterative DNS resolution following the DNS hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RecursiveResolver</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResolverConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkClient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootHints   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RootHints</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span><span style=\"color:#6A737D\"> // Protects resolver statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queryCount  </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failedCount </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResolverConfig contains configuration parameters for recursive resolution behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResolverConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RootHints      []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">      // IP addresses of root servers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timeout        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#6A737D\"> // Per-query timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxDepth       </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">          // Maximum referral depth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnableRecursion </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">         // Whether to perform recursive resolution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxCNAMEChain  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">          // Maximum CNAME chain length</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResolutionState tracks the state of a single recursive resolution operation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResolutionState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    originalQuestion </span><span style=\"color:#B392F0\">Question</span><span style=\"color:#6A737D\">           // The client's original question</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentQuestion  </span><span style=\"color:#B392F0\">Question</span><span style=\"color:#6A737D\">           // Current question being resolved (may differ due to CNAME)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queryCount      </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">               // Number of queries made so far</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    visitedServers  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // Servers already queried to detect loops</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cnameChain      []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">          // CNAME chain being followed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx            </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#6A737D\">    // Cancellation and timeout context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewRecursiveResolver creates a new recursive resolver with the given configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewRecursiveResolver</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ResolverConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cache</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecursiveResolver</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewNetworkClient</span><span style=\"color:#E1E4E8\">(config.Timeout)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create network client: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootHints </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DefaultRootHints</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(config.RootHints) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rootHints </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RootHints</span><span style=\"color:#E1E4E8\">{servers: config.RootHints}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RecursiveResolver</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config:    config,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache:     cache,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        client:    client,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rootHints: rootHints,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResolveQuery performs complete recursive resolution for the given question</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecursiveResolver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ResolveQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">question</span><span style=\"color:#B392F0\"> Question</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create resolution state to track this query's progress</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Initialize ResolutionState with original question</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set up visited servers map and CNAME chain tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Create context with timeout from config</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check cache for existing answer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Build CacheKey from question name, type, class  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call cache.Get() to check for cached entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If cache hit and not expired, construct response and return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Log cache hit for debugging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Perform iterative resolution starting from root servers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call PerformIterativeResolution with resolution state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Handle case where no answer is found (return NXDOMAIN)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Handle network errors and timeouts appropriately</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Process final answer and handle CNAME chains</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If answer contains CNAME records, call FollowCNAME</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Validate that final answer matches original question type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Cache all records received during resolution with their TTLs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Construct final response message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Create DNSMessage with same ID as original query</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set appropriate flags (QR=1, RA=1, AA=0 for recursive)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Copy question section from original query</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Add answer records to answer section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return completed response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PerformIterativeResolution follows DNS hierarchy from root to authoritative servers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecursiveResolver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PerformIterativeResolution</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ResolutionState</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize current nameserver list with root servers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Get all root server IPs from rootHints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Create nameserver list with IPs and port 53</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set current zone to root zone (\"\")</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Begin iterative resolution loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Loop while we have nameservers to query and haven't exceeded maxDepth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check query count against MaxDepth limit on each iteration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Select next nameserver from current nameserver list</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send query to current nameserver</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Serialize current question into wire format using SerializeMessage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use NetworkClient.QueryServer to send query with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Parse response using ParseMessage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Validate response ID matches query ID</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Process response based on type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If response has answer records: validate and return them</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If response has authority section: extract NS records and continue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If response is NXDOMAIN: cache negative response and return error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If response is malformed: try next nameserver</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Extract referral information from authority section  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Parse NS records to get next level nameservers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Validate NS records are within proper bailiwick</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Extract glue records from additional section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Build new nameserver list for next iteration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle missing glue records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For each NS record without corresponding glue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If NS name is in-bailiwick, recursively resolve its A record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Add resolved IP addresses to nameserver list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Detect circular dependencies and handle gracefully</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update resolution state for next iteration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Add current server to visitedServers map  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Increment query count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Update current zone to the zone we're now querying</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Continue loop with new nameserver list</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return empty slice and appropriate error if resolution fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"resolution failed after </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> queries\"</span><span style=\"color:#E1E4E8\">, state.queryCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FollowCNAME resolves CNAME chains to find the final target records</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecursiveResolver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FollowCNAME</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cnameTarget</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">originalType</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ResolutionState</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate CNAME chain length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check len(state.cnameChain) against MaxCNAMEChain limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return error if chain is too long to prevent infinite loops</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Detect CNAME cycles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check if cnameTarget is already in state.cnameChain  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return error if cycle detected to prevent infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Add cnameTarget to cnameChain for tracking</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create new question for CNAME target</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Build Question with cnameTarget as name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use originalType as the desired record type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Preserve class from original question</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Recursively resolve the CNAME target</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call PerformIterativeResolution with new question</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Handle case where CNAME target also returns CNAME (recursive following)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Cache intermediate CNAME records with their TTLs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return final resolved records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Validate final records match original requested type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Include original CNAME record in answer along with final records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return combined record set to caller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// validateResponse checks DNS response for correctness and security issues</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecursiveResolver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">validateResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">response</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">serverIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate basic response structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check that response.Header.ID matches query.Header.ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify QR flag is set (this is a response, not a query)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check that question section matches original query</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Validate response code is not malformed</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate bailiwick for all records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For each record in answer, authority, and additional sections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Determine the authoritative zone being queried</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify record names fall within expected bailiwick</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Reject out-of-bailiwick records that could poison cache</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate glue records specifically  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Extract NS records from authority section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For each corresponding A/AAAA record in additional section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify the A/AAAA record name matches an NS record target</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify the NS target name is within the delegated zone</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate record data integrity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check that A records contain valid IPv4 addresses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check that AAAA records contain valid IPv6 addresses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Verify TTL values are reasonable (not negative, not excessive)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Validate CNAME records don't coexist with other record types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li>Use <code>context.WithTimeout()</code> for per-query timeouts and cancellation</li>\n<li><code>sync.Map</code> can provide better performance than <code>map</code> with <code>sync.RWMutex</code> for cache</li>\n<li><code>net.SplitHostPort()</code> helps parse server addresses with ports</li>\n<li><code>time.Now().Add(time.Duration(ttl) * time.Second)</code> for TTL expiration times</li>\n<li><code>strings.ToLower()</code> for case-insensitive domain name comparisons</li>\n<li><code>binary.BigEndian</code> for network byte order in manual message parsing</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p>After implementing the recursive resolver, verify correct behavior:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic recursive resolution</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/resolver/</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestRecursiveResolution</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test with real DNS queries</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/dns-server/main.go</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 8053</span><span style=\"color:#9ECBFF\"> www.google.com</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output: Answer section with A records for www.google.com</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Response should have RA flag set indicating recursion available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Query should complete in under 5 seconds for cached results</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test CNAME following</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 8053</span><span style=\"color:#9ECBFF\"> www.github.com</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should follow CNAME chain and return final A records</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test error handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 8053</span><span style=\"color:#9ECBFF\"> nonexistent.invalid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should return NXDOMAIN response code</span></span></code></pre></div>\n\n<p><strong>Signs of correct implementation:</strong></p>\n<ul>\n<li>Queries for popular domains (google.com, cloudflare.com) resolve successfully</li>\n<li>Second query for same domain returns much faster (cache hit)</li>\n<li>NXDOMAIN responses are returned for nonexistent domains</li>\n<li>Server doesn&#39;t crash or hang on malformed queries</li>\n<li>Memory usage remains stable over time</li>\n</ul>\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li>All queries timeout → Check network client setup and root hints</li>\n<li>Queries never complete → Look for infinite loops in iterative resolution</li>\n<li>Cache poisoning warnings → Verify bailiwick validation logic</li>\n<li>Memory usage grows unbounded → Check for cache size limits and cleanup</li>\n</ul>\n<h2 id=\"caching-and-performance-milestone-4\">Caching and Performance (Milestone 4)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 4 (Caching &amp; Performance)</p>\n</blockquote>\n<p>A DNS server without caching is like a librarian who forgets every book&#39;s location the moment they help a patron. Every query would require walking through the entire resolution process from root servers, creating unbearable latency and overwhelming upstream servers with redundant requests. Milestone 4 transforms our recursive resolver from a forgetful librarian into one with excellent short-term memory, dramatically improving performance through intelligent caching while maintaining correctness through TTL-based expiration.</p>\n<p>The caching layer serves multiple critical functions beyond simple performance optimization. It acts as a buffer against network failures, provides consistent response times for popular domains, and implements negative caching to avoid repeatedly querying for non-existent domains. However, caching introduces complexity around cache consistency, security validation, and concurrent access patterns that require careful architectural decisions.</p>\n<h3 id=\"mental-model-cache-as-recent-memory\">Mental Model: Cache as Recent Memory</h3>\n<p>Think of the DNS cache as human short-term memory with automatic forgetting. When you meet someone new, you remember their name for a while, but if you don&#39;t use that information, it gradually fades until you&#39;ve completely forgotten it. The DNS cache works similarly—when the resolver learns a domain&#39;s IP address, it remembers that mapping for a specific duration (the TTL), but automatically forgets it when that time expires.</p>\n<p>This memory analogy extends to capacity limits and prioritization. Just as human memory has finite capacity and prioritizes recent or frequently accessed information, the DNS cache must make decisions about what to remember when storage becomes limited. The cache evicts older or less frequently accessed entries to make room for new information, similar to how we naturally forget unused details over time.</p>\n<p>The automatic forgetting aspect is crucial for correctness. Unlike human memory, which fades gradually and unreliably, DNS cache expiration is precise and mandatory. Each cached entry has an exact expiration time, ensuring that stale information is never served beyond its intended lifetime. This precision prevents the cache from becoming a source of incorrect data when domain configurations change.</p>\n<p>Negative caching adds another dimension to this memory model—remembering that something doesn&#39;t exist. When you ask someone about a person they&#39;ve never heard of, you might remember that this person doesn&#39;t exist in their social circle, avoiding the need to ask again soon. DNS negative caching works similarly, remembering that specific domains or record types don&#39;t exist to avoid repeated failed queries.</p>\n<h3 id=\"ttl-based-cache-management\">TTL-Based Cache Management</h3>\n<p>The Time-To-Live (TTL) system forms the foundation of DNS cache management, providing a distributed mechanism for controlling cache consistency across the internet. Each resource record includes a TTL value specified by the authoritative server, representing the maximum number of seconds that record may be cached before it must be refreshed. This creates a contract between authoritative servers and caches—the authoritative server promises not to change the record for at least the TTL duration, while caches promise not to serve the record beyond that time.</p>\n<p>Cache storage involves creating entries that combine the resource records with expiration timestamps calculated from the current time plus the TTL value. The cache key consists of the domain name, record type, and class, ensuring that different query types for the same domain are cached separately. When storing records, the cache must handle cases where multiple records of the same type exist for a domain, such as multiple A records for load balancing.</p>\n<table>\n<thead>\n<tr>\n<th>Cache Entry Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Records</td>\n<td>[]ResourceRecord</td>\n<td>The actual DNS records being cached</td>\n</tr>\n<tr>\n<td>ExpiresAt</td>\n<td>time.Time</td>\n<td>Absolute expiration timestamp calculated from current time + TTL</td>\n</tr>\n<tr>\n<td>Negative</td>\n<td>bool</td>\n<td>True if this entry represents a negative response (NXDOMAIN/NODATA)</td>\n</tr>\n<tr>\n<td>SOARecord</td>\n<td>*ResourceRecord</td>\n<td>SOA record for negative entries to determine negative cache TTL</td>\n</tr>\n<tr>\n<td>HitCount</td>\n<td>uint64</td>\n<td>Number of times this entry has been accessed (for LRU eviction)</td>\n</tr>\n<tr>\n<td>Size</td>\n<td>int</td>\n<td>Memory usage of this entry for cache size management</td>\n</tr>\n</tbody></table>\n<p>Cache lookup involves checking for the existence of a key and validating that the cached entry hasn&#39;t expired. The lookup process must be atomic to prevent race conditions in concurrent environments. If an entry exists but has expired, it should be treated as a cache miss and removed during the lookup operation to prevent serving stale data.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: TTL countdown should be calculated using absolute expiration times rather than decrementing counters. This approach is more robust against system clock adjustments and simplifies the expiration checking logic.</p>\n</blockquote>\n<p>Cache expiration requires periodic cleanup to remove expired entries and reclaim memory. A background cleanup process runs at regular intervals, scanning all cache entries and removing those whose expiration time has passed. This proactive cleanup prevents the cache from growing unbounded with expired entries and maintains accurate memory usage statistics.</p>\n<p>The cache must handle TTL edge cases carefully. When multiple resource records for the same cache key have different TTL values, the cache should use the minimum TTL to ensure all records remain valid. For negative responses, the TTL is derived from the SOA record&#39;s minimum field rather than from the non-existent records themselves.</p>\n<blockquote>\n<p><strong>Decision: Absolute Expiration Times vs. TTL Countdown</strong></p>\n<ul>\n<li><strong>Context</strong>: Cache entries need expiration tracking to ensure stale data isn&#39;t served</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Store original TTL and decrement periodically</li>\n<li>Calculate absolute expiration time at storage</li>\n<li>Hybrid approach with both TTL and expiration time</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Store absolute expiration time calculated at storage</li>\n<li><strong>Rationale</strong>: Absolute times are immune to system clock adjustments, eliminate the need for periodic TTL decrements, and simplify expiration checking to a single timestamp comparison</li>\n<li><strong>Consequences</strong>: Enables efficient expiration checking and eliminates TTL underflow bugs, but requires accurate system clock for correctness</li>\n</ul>\n</blockquote>\n<h3 id=\"negative-caching-strategy\">Negative Caching Strategy</h3>\n<p>Negative caching prevents the cache from becoming a performance bottleneck when clients repeatedly query for non-existent domains or record types. Without negative caching, each query for a non-existent domain would trigger a full recursive resolution, consuming network resources and adding latency. Negative caching transforms these expensive operations into fast cache hits, dramatically improving performance for common error scenarios.</p>\n<p>DNS defines two types of negative responses that should be cached differently. NXDOMAIN responses indicate that the queried domain name does not exist at all, while NODATA responses indicate that the domain exists but has no records of the requested type. Both response types should be cached, but they have different implications for future queries and different TTL calculation methods.</p>\n<p>The TTL for negative cache entries is derived from the SOA record&#39;s minimum field, which appears in the authority section of negative responses. This SOA minimum value represents the negative cache TTL as specified by the authoritative server, providing a mechanism for domain administrators to control how long negative responses should be cached.</p>\n<table>\n<thead>\n<tr>\n<th>Negative Cache Type</th>\n<th>Response Code</th>\n<th>Meaning</th>\n<th>TTL Source</th>\n<th>Cache Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NXDOMAIN</td>\n<td>3</td>\n<td>Domain does not exist</td>\n<td>SOA minimum field</td>\n<td>Cache for exact domain name, all types</td>\n</tr>\n<tr>\n<td>NODATA</td>\n<td>0</td>\n<td>Domain exists, no records of this type</td>\n<td>SOA minimum field</td>\n<td>Cache for specific domain/type combination</td>\n</tr>\n</tbody></table>\n<p>Negative cache storage requires careful key management to ensure that negative responses don&#39;t interfere with positive responses. A negative cache entry for a specific domain and record type should only prevent queries for that exact combination, not for other record types that might exist for the same domain.</p>\n<p>The negative cache must handle query patterns intelligently. When a client queries for multiple record types for the same domain, a negative cache hit for one type shouldn&#39;t prevent checking for other types unless it&#39;s an NXDOMAIN response, which indicates the entire domain is non-existent.</p>\n<blockquote>\n<p><strong>Decision: Separate Negative Cache vs. Unified Cache with Flags</strong></p>\n<ul>\n<li><strong>Context</strong>: Negative responses need caching but have different semantics than positive responses</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Separate data structure for negative cache entries</li>\n<li>Unified cache with boolean flag to indicate negative entries</li>\n<li>Special sentinel values in the main cache</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Unified cache with Negative boolean field in CacheEntry</li>\n<li><strong>Rationale</strong>: Simplifies cache management logic, enables unified TTL handling and eviction policies, and reduces code duplication while maintaining semantic clarity</li>\n<li><strong>Consequences</strong>: Slightly more complex cache entry structure, but unified expiration and size management across positive and negative entries</li>\n</ul>\n</blockquote>\n<p>Cache poisoning prevention becomes critical when implementing negative caching. Malicious responses could attempt to inject negative cache entries for legitimate domains, causing denial of service. The cache must validate that negative responses come from authoritative sources and that the SOA record in the authority section matches the queried domain&#39;s zone.</p>\n<h3 id=\"concurrent-query-processing\">Concurrent Query Processing</h3>\n<p>DNS servers must handle multiple simultaneous queries without blocking, as real-world DNS traffic consists of concurrent requests from many clients. A blocking approach where each query waits for the previous one to complete would create unacceptable latency and poor throughput. Concurrent processing transforms the DNS server from a single-threaded bottleneck into a responsive service capable of handling realistic traffic loads.</p>\n<p>The primary concurrency challenge involves shared access to the cache data structure. Multiple goroutines will simultaneously read from and write to the cache, requiring synchronization to prevent data races and corruption. The cache must support high-concurrency read access (cache hits) while serializing write access (cache updates) to maintain consistency.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fconcurrent-query-handling.svg\" alt=\"Concurrent Query Processing Architecture\"></p>\n<p>Read-write mutex locking provides an efficient solution for cache concurrency. Read operations (cache lookups) can proceed concurrently using read locks, while write operations (cache updates, expiration) require exclusive write locks. This approach maximizes throughput for the common case (cache hits) while ensuring safety for cache modifications.</p>\n<table>\n<thead>\n<tr>\n<th>Concurrency Pattern</th>\n<th>Lock Type</th>\n<th>Use Case</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache Lookup</td>\n<td>Read Lock</td>\n<td>Multiple concurrent cache hits</td>\n<td>High throughput, low contention</td>\n</tr>\n<tr>\n<td>Cache Insert</td>\n<td>Write Lock</td>\n<td>Adding new cache entries</td>\n<td>Exclusive access, brief contention</td>\n</tr>\n<tr>\n<td>Cache Cleanup</td>\n<td>Write Lock</td>\n<td>Removing expired entries</td>\n<td>Exclusive access, periodic operation</td>\n</tr>\n<tr>\n<td>Cache Statistics</td>\n<td>Read Lock</td>\n<td>Monitoring cache state</td>\n<td>Concurrent with lookups</td>\n</tr>\n</tbody></table>\n<p>Query processing pipelines can be implemented using goroutines, where each incoming UDP packet spawns a new goroutine to handle the query independently. This approach provides natural isolation between queries and allows the Go runtime to efficiently schedule work across available CPU cores.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Goroutine-per-query pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">queryData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">clientAddr</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#B392F0\"> recover</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#6A737D\">// Handle panics gracefully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> server.</span><span style=\"color:#B392F0\">handleQuery</span><span style=\"color:#E1E4E8\">(queryData, clientAddr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server.</span><span style=\"color:#B392F0\">sendResponse</span><span style=\"color:#E1E4E8\">(response, clientAddr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}(data, addr)</span></span></code></pre></div>\n\n<p>Resource management becomes important with goroutine-per-query patterns to prevent resource exhaustion under high load. The server should implement goroutine pooling or rate limiting to cap the maximum number of concurrent queries. Additionally, each query should have a timeout to prevent goroutines from hanging indefinitely on network operations.</p>\n<p>Connection sharing for upstream queries requires careful coordination. When multiple concurrent queries need to resolve the same domain, they should share the recursive resolution work rather than each starting independent resolution processes. This requires query coalescing logic that detects duplicate in-flight queries and allows multiple local queries to wait for a single upstream resolution.</p>\n<blockquote>\n<p><strong>Decision: Goroutine-Per-Query vs. Worker Pool Pattern</strong></p>\n<ul>\n<li><strong>Context</strong>: Server must handle multiple concurrent DNS queries efficiently</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Goroutine spawned for each incoming query</li>\n<li>Fixed pool of worker goroutines processing query queue</li>\n<li>Adaptive worker pool that scales with load</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Goroutine-per-query with resource limits</li>\n<li><strong>Rationale</strong>: Go&#39;s goroutines are lightweight and the runtime handles scheduling efficiently, query processing is naturally isolated, and implementation is simpler than worker pool management</li>\n<li><strong>Consequences</strong>: Excellent performance under normal load with simple implementation, but requires rate limiting to prevent resource exhaustion under extreme load</li>\n</ul>\n</blockquote>\n<h3 id=\"architecture-decisions-for-caching\">Architecture Decisions for Caching</h3>\n<p>Cache size management requires balancing memory usage against performance benefits. The cache should implement both entry count limits and memory usage limits to prevent unbounded growth. When limits are reached, the cache must evict entries using a policy that maximizes hit rate while maintaining fairness across different query patterns.</p>\n<p>Least Recently Used (LRU) eviction provides a good balance between implementation complexity and cache effectiveness. The cache tracks access times for entries and evicts the least recently accessed entries when space is needed. This policy tends to keep frequently accessed entries while removing entries that are no longer actively used.</p>\n<table>\n<thead>\n<tr>\n<th>Eviction Policy</th>\n<th>Implementation Complexity</th>\n<th>Hit Rate Performance</th>\n<th>Memory Overhead</th>\n<th>Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>FIFO (First In, First Out)</td>\n<td>Low</td>\n<td>Poor for temporal locality</td>\n<td>Low</td>\n<td>No</td>\n</tr>\n<tr>\n<td>LRU (Least Recently Used)</td>\n<td>Medium</td>\n<td>Good for most workloads</td>\n<td>Medium</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>LFU (Least Frequently Used)</td>\n<td>High</td>\n<td>Good for stable workloads</td>\n<td>High</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Random Replacement</td>\n<td>Very Low</td>\n<td>Unpredictable</td>\n<td>Very Low</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>Cache security validation prevents cache poisoning attacks where malicious responses attempt to inject false information into the cache. The cache must validate that response records match the original query and that the responding server has authority for the returned data. This validation is particularly important for negative caching, where false negative responses could cause denial of service.</p>\n<p>Bailiwick checking ensures that cache entries only contain records that the responding server has authority to provide. For example, a response from a .com nameserver should only contain records for domains within the .com zone, not for arbitrary domains like .org. This prevents cache poisoning through out-of-bailiwick data injection.</p>\n<blockquote>\n<p><strong>Decision: Cache Size Limits - Entry Count vs. Memory Usage</strong></p>\n<ul>\n<li><strong>Context</strong>: Cache needs bounds to prevent memory exhaustion</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Limit by number of cache entries only</li>\n<li>Limit by total memory usage only  </li>\n<li>Dual limits with both entry count and memory usage</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Dual limits with both maximum entries and maximum memory</li>\n<li><strong>Rationale</strong>: Entry count limits provide predictable behavior and simple implementation, while memory limits prevent large records from bypassing entry limits and consuming excessive memory</li>\n<li><strong>Consequences</strong>: More complex cache management logic, but better protection against both memory exhaustion and cache flooding attacks</li>\n</ul>\n</blockquote>\n<p>Cache statistics collection enables monitoring and performance tuning of the cache system. The cache should track hit rates, memory usage, eviction rates, and other metrics that help operators understand cache behavior and identify performance bottlenecks.</p>\n<table>\n<thead>\n<tr>\n<th>Cache Metric</th>\n<th>Purpose</th>\n<th>Collection Method</th>\n<th>Impact on Performance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hit Rate</td>\n<td>Measure cache effectiveness</td>\n<td>Increment counters on hit/miss</td>\n<td>Minimal</td>\n</tr>\n<tr>\n<td>Memory Usage</td>\n<td>Monitor resource consumption</td>\n<td>Track entry sizes</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Eviction Count</td>\n<td>Detect cache pressure</td>\n<td>Increment on eviction</td>\n<td>Minimal</td>\n</tr>\n<tr>\n<td>Average TTL</td>\n<td>Understand cache lifetime patterns</td>\n<td>Calculate during insertion</td>\n<td>Low</td>\n</tr>\n</tbody></table>\n<p>Thread safety for cache statistics requires atomic operations or separate locks to prevent corruption while maintaining performance. The statistics collection should not significantly impact cache operation performance, suggesting the use of atomic counters rather than mutex-protected counters for frequently updated metrics.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fcache-state-machine.svg\" alt=\"Cache Entry State Machine\"></p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: TTL Underflow in Countdown Systems</strong></p>\n<p>Many implementations attempt to store the original TTL and decrement it periodically, leading to integer underflow bugs when the decrement operation occurs after the TTL should have expired. This can cause entries to appear to have very large TTL values (due to unsigned integer wraparound) and remain cached indefinitely. The fix is to use absolute expiration timestamps calculated at cache insertion time.</p>\n<p>⚠️ <strong>Pitfall: Cache Poisoning Through Out-of-Bailiwick Records</strong></p>\n<p>Accepting and caching records that are outside the authority of the responding server creates a cache poisoning vulnerability. For example, caching an A record for google.com from a response by a .edu nameserver. Always validate that cached records fall within the responding server&#39;s zone of authority, and reject out-of-bailiwick records even if they appear in otherwise legitimate responses.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in Concurrent Cache Access</strong></p>\n<p>Reading cache entries while they&#39;re being modified by concurrent goroutines can lead to corrupted data or panics. This often manifests as intermittent crashes or incorrect responses under load. Implement proper read-write mutex locking around all cache operations, ensuring that cache lookups use read locks and cache modifications use write locks.</p>\n<p>⚠️ <strong>Pitfall: Memory Leaks from Unbounded Cache Growth</strong></p>\n<p>Without proper size limits and eviction policies, the cache can grow indefinitely and consume all available memory. This is particularly problematic when handling queries for many different domains or when under attack from cache flooding attempts. Implement both entry count and memory usage limits with LRU eviction to bound cache size.</p>\n<p>⚠️ <strong>Pitfall: Serving Expired Cache Entries</strong></p>\n<p>Forgetting to check expiration times during cache lookup can result in serving stale data beyond its intended lifetime. This violates DNS protocol requirements and can cause incorrect resolution. Always verify that <code>time.Now().Before(entry.ExpiresAt)</code> before returning cache entries, and remove expired entries during lookup operations.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Negative Cache TTL Calculation</strong></p>\n<p>Using the wrong TTL source for negative cache entries can result in caching negative responses for inappropriate durations. Negative cache TTL should come from the SOA record&#39;s minimum field in the authority section, not from the query&#39;s requested record type or arbitrary default values. Missing or incorrectly parsed SOA records should result in shorter default negative cache durations.</p>\n<p>⚠️ <strong>Pitfall: Query Coalescing Race Conditions</strong></p>\n<p>When multiple concurrent queries for the same domain attempt to share resolution work, race conditions can occur where multiple recursive resolutions start simultaneously, or where query responses are delivered to the wrong waiting queries. Implement proper synchronization using channels or condition variables to coordinate query sharing and response distribution.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The caching layer requires careful coordination between concurrent access patterns, memory management, and expiration handling. The implementation should prioritize correctness over performance optimizations, as cache corruption bugs are difficult to debug and can cause widespread DNS resolution failures.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache Storage</td>\n<td><code>sync.RWMutex</code> + <code>map[CacheKey]*CacheEntry</code></td>\n<td>Concurrent hash map with lock striping</td>\n</tr>\n<tr>\n<td>Expiration Cleanup</td>\n<td>Periodic <code>time.Ticker</code> goroutine</td>\n<td>Lazy expiration on access + background cleanup</td>\n</tr>\n<tr>\n<td>Memory Tracking</td>\n<td>Manual size calculation and summation</td>\n<td>Memory profiling integration with pprof</td>\n</tr>\n<tr>\n<td>Concurrency Model</td>\n<td>Goroutine per query with shared cache</td>\n<td>Worker pool with per-worker cache shards</td>\n</tr>\n<tr>\n<td>Statistics Collection</td>\n<td>Atomic counters (<code>sync/atomic</code>)</td>\n<td>Metrics framework like Prometheus</td>\n</tr>\n</tbody></table>\n<h4 id=\"cache-manager-implementation\">Cache Manager Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cache</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync/atomic</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CacheManager implements TTL-based caching with concurrent access support.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It provides both positive and negative caching with LRU eviction policy.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Core cache storage protected by RWMutex for concurrent access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu    </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">CacheKey</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration and limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxEntries </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxMemory  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Statistics tracked with atomic operations for thread safety</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#B392F0\">CacheStats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Background cleanup management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanupTicker </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Ticker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stopCleanup   </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCacheManager creates a cache manager with specified limits.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// maxEntries controls the maximum number of cache entries.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// maxMemory limits total memory usage in bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cleanupInterval determines how often expired entries are removed.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCacheManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxEntries</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">maxMemory</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cleanupInterval</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache:      </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">CacheKey</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxEntries: maxEntries,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxMemory:  maxMemory,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stopCleanup: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start background cleanup goroutine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.cleanupTicker </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(cleanupInterval)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#E1E4E8\"> cm.</span><span style=\"color:#B392F0\">backgroundCleanup</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cm</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get retrieves a cache entry if it exists and hasn't expired.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the entry and true if found and valid, nil and false otherwise.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire read lock for concurrent access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Look up key in cache map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if entry exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify entry hasn't expired using time.Now().Before(entry.ExpiresAt)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If expired, remove entry and return cache miss</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update hit count for LRU tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Increment cache hit statistics atomically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return entry copy to prevent external modification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement cache lookup with expiration checking\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Put stores records in the cache with TTL-based expiration.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Records with TTL 0 are not cached. Handles cache size limits with LRU eviction.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">records</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate TTL is greater than 0 (don't cache zero TTL records)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate absolute expiration time from current time + TTL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create CacheEntry with records, expiration, and metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Acquire write lock for exclusive access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check if adding entry would exceed size limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If over limits, run LRU eviction to free space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Insert entry into cache map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Update memory usage and entry count statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Return nil on success</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement cache insertion with size management\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PutNegative caches a negative response (NXDOMAIN or NODATA).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Uses SOA minimum field for TTL calculation.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PutNegative</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">soaRecord</span><span style=\"color:#B392F0\"> ResourceRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract TTL from SOA record's minimum field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create negative CacheEntry with Negative flag set to true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Store SOA record for negative cache TTL validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Use same insertion logic as Put() but mark as negative</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Negative entries contain the SOA record instead of answer records</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement negative caching with SOA TTL\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// backgroundCleanup runs periodically to remove expired entries.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This prevents the cache from growing with expired entries between lookups.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">backgroundCleanup</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">cm.cleanupTicker.C:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Acquire write lock for cleanup operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Iterate through all cache entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Check each entry's expiration time against current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Remove expired entries from map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Update memory usage and entry count statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 6: Track number of entries cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">cm.stopCleanup:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Stats returns current cache performance and usage statistics.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Safe for concurrent access using atomic operations.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Stats</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">CacheStats</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read atomic counters for hits, misses, queries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate hit rate as hits / total queries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Get current entry count and memory usage with read lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return populated CacheStats struct</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement statistics collection\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"concurrent-query-handler\">Concurrent Query Handler</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// QueryCoalescer prevents duplicate concurrent queries for the same domain.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Multiple clients querying the same domain will share one recursive resolution.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> QueryCoalescer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inFlight </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">CacheKey</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewQueryCoalescer creates a coalescer for sharing resolution work.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewQueryCoalescer</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryCoalescer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">QueryCoalescer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inFlight: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">CacheKey</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CoalesceQuery checks if the same query is already being resolved.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If yes, waits for the existing resolution. If no, starts a new resolution.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">qc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryCoalescer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CoalesceQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">resolveFunc</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Lock the in-flight map for exclusive access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if this query key is already being resolved</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If yes, wait on the existing channel for the result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If no, create a new channel and add to in-flight map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Release lock and call resolveFunc to perform resolution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Send result to all waiting goroutines via the channel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Remove completed query from in-flight map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Handle context cancellation and timeouts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement query coalescing\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Server handles concurrent DNS queries with caching and coalescing.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleConcurrentQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">queryData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">clientAddr</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse incoming DNS message from queryData</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Extract question to create cache key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check cache for existing valid entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If cache hit, construct response and send immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If cache miss, use QueryCoalescer to avoid duplicate work</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Perform recursive resolution if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Cache the resolution result with appropriate TTL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Construct and send response to client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Handle any errors gracefully and send error responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use timeout context to prevent hanging queries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithTimeout</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TODO: implement concurrent query handling\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"file-structure-organization\">File Structure Organization</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>dns-server/\n├── cmd/dns-server/\n│   └── main.go                    ← Entry point, configuration loading\n├── internal/cache/\n│   ├── manager.go                 ← CacheManager implementation\n│   ├── manager_test.go            ← Cache functionality tests\n│   ├── stats.go                   ← Statistics collection and reporting\n│   └── types.go                   ← CacheKey, CacheEntry, CacheStats definitions\n├── internal/server/\n│   ├── server.go                  ← Main server with concurrent handling\n│   ├── coalesce.go                ← Query coalescing implementation\n│   └── handlers.go                ← Query processing pipeline\n├── internal/resolver/\n│   ├── recursive.go               ← RecursiveResolver from Milestone 3\n│   └── validation.go              ← Response validation and security checks\n└── internal/protocol/\n    ├── message.go                 ← DNS message parsing from Milestone 1\n    └── types.go                   ← DNS protocol type definitions</code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing Milestone 4, your DNS server should demonstrate significant performance improvements and handle concurrent load effectively:</p>\n<p><strong>Testing Cache Functionality:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic caching - first query should be slow, second should be fast</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time</span><span style=\"color:#E1E4E8\"> dig @localhost -p 5053 google.com A</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time</span><span style=\"color:#E1E4E8\"> dig @localhost -p 5053 google.com A  </span><span style=\"color:#6A737D\"># Should be much faster</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test negative caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time</span><span style=\"color:#E1E4E8\"> dig @localhost -p 5053 nonexistent.example.com A</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time</span><span style=\"color:#E1E4E8\"> dig @localhost -p 5053 nonexistent.example.com A  </span><span style=\"color:#6A737D\"># Should be fast</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test concurrent queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span><span style=\"color:#B392F0\"> dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 5053</span><span style=\"color:#9ECBFF\"> facebook.com</span><span style=\"color:#9ECBFF\"> A</span><span style=\"color:#E1E4E8\"> &#x26; </span><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#6A737D\">  # All queries should complete without errors</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>First query to a domain takes 100-500ms (recursive resolution time)</li>\n<li>Subsequent queries to cached domains complete in &lt;10ms</li>\n<li>Negative queries for non-existent domains are cached and return quickly</li>\n<li>Server handles 10+ concurrent queries without blocking</li>\n<li>Cache statistics show reasonable hit rates (&gt;50% after some usage)</li>\n</ul>\n<p><strong>Performance Verification:</strong></p>\n<ul>\n<li>Monitor cache hit rate via statistics endpoint or logs</li>\n<li>Verify memory usage stays within configured limits</li>\n<li>Check that expired entries are cleaned up automatically</li>\n<li>Confirm that cache poisoning attempts are rejected</li>\n</ul>\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li>Memory usage grows indefinitely → missing eviction policy or cleanup</li>\n<li>Intermittent crashes under load → race conditions in cache access</li>\n<li>Stale data served after TTL expiration → expiration checking bugs</li>\n<li>Poor cache hit rates → incorrect cache key generation or premature eviction</li>\n</ul>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - Understanding component interactions is essential for implementing each milestone&#39;s functionality</p>\n</blockquote>\n<p>The architecture of a DNS server comes alive through the intricate dance of data flowing between its components. Like a well-orchestrated symphony where each musician knows their part and cues, the DNS server components must seamlessly pass messages, coordinate state changes, and maintain consistency while handling concurrent requests. Understanding these interactions is crucial because DNS servers must process hundreds or thousands of queries per second while maintaining correctness and performance.</p>\n<h3 id=\"mental-model-dns-server-as-a-restaurant-kitchen\">Mental Model: DNS Server as a Restaurant Kitchen</h3>\n<p>Think of the DNS server as a high-end restaurant kitchen during dinner rush. The <strong>UDP Server</strong> acts as the expediter, receiving orders (queries) from customers (clients) and routing them to the appropriate stations. The <strong>Message Parser</strong> is like the prep cook who breaks down complex orders into understandable ingredients and instructions. The <strong>Recursive Resolver</strong> functions as the head chef who coordinates with multiple vendors (root servers, TLD servers) to source special ingredients (authoritative answers) when they&#39;re not in stock. The <strong>Cache Manager</strong> serves as the walk-in cooler, storing frequently used ingredients (cached records) so they&#39;re immediately available without ordering from suppliers. Finally, the <strong>Zone Data Manager</strong> acts as the pantry containing house-made items (authoritative zone data) that the restaurant produces itself.</p>\n<p>Just as kitchen stations must communicate timing, share resources, and coordinate handoffs without dropping orders or serving cold food, DNS components must pass messages efficiently, share cached data safely across concurrent operations, and maintain response times that meet client expectations.</p>\n<h2 id=\"query-processing-flow\">Query Processing Flow</h2>\n<p>The end-to-end flow of a DNS query through the server represents the primary workflow that ties all components together. This flow must handle multiple query types, error conditions, and performance optimizations while maintaining protocol correctness.</p>\n<h3 id=\"inbound-query-processing-pipeline\">Inbound Query Processing Pipeline</h3>\n<p>When a UDP packet arrives at the DNS server, it triggers a carefully orchestrated sequence of operations that involves every major component. The processing pipeline follows a consistent pattern regardless of whether the query can be answered authoritatively, from cache, or requires recursive resolution.</p>\n<p>The pipeline begins with <strong>packet reception</strong> at the UDP server layer. The server receives a raw byte array from the network along with the client&#39;s address information. This raw data must be immediately validated for basic sanity checks - minimum packet size, proper DNS header structure, and message length consistency. Invalid packets are dropped silently to prevent resource exhaustion from malformed requests or potential attacks.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fquery-processing-flow.svg\" alt=\"Query Processing Flowchart\"></p>\n<p>Once basic validation passes, the <strong>message parsing</strong> phase begins. The <code>MessageParser</code> component takes the raw bytes and constructs a structured <code>DNSMessage</code> object. This parsing must handle name compression, validate field relationships (like question counts matching actual questions), and detect malformed sections that could indicate protocol violations or corruption. Parse failures result in immediate FORMERR responses to inform clients of malformed queries.</p>\n<p>The <strong>query classification</strong> step determines how to route the parsed message through the rest of the system. The server examines the question section to determine if it holds authoritative data for the queried domain, whether cached data might satisfy the request, or if recursive resolution is needed. This decision point fundamentally changes the processing path and involves consulting the zone configuration and cache state.</p>\n<table>\n<thead>\n<tr>\n<th>Processing Phase</th>\n<th>Component Responsible</th>\n<th>Input</th>\n<th>Output</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Packet Reception</td>\n<td>UDP Server</td>\n<td>Raw bytes + client address</td>\n<td>Validated byte array</td>\n<td>Packet too small, network errors</td>\n</tr>\n<tr>\n<td>Message Parsing</td>\n<td>Message Parser</td>\n<td>Raw DNS bytes</td>\n<td><code>DNSMessage</code> struct</td>\n<td>Malformed header, compression loops</td>\n</tr>\n<tr>\n<td>Query Classification</td>\n<td>Message Handler</td>\n<td>Parsed DNS message</td>\n<td>Processing decision</td>\n<td>Invalid question section</td>\n</tr>\n<tr>\n<td>Authority Check</td>\n<td>Zone Data Manager</td>\n<td>Domain name + question</td>\n<td>Zone match result</td>\n<td>Zone file corruption</td>\n</tr>\n<tr>\n<td>Cache Lookup</td>\n<td>Cache Manager</td>\n<td>Cache key</td>\n<td>Cache entry or miss</td>\n<td>Cache corruption</td>\n</tr>\n<tr>\n<td>Response Construction</td>\n<td>Message Handler</td>\n<td>Answer records</td>\n<td><code>DNSMessage</code> response</td>\n<td>Serialization failure</td>\n</tr>\n<tr>\n<td>Response Transmission</td>\n<td>UDP Server</td>\n<td>Response message + client</td>\n<td>Network transmission</td>\n<td>Client unreachable</td>\n</tr>\n</tbody></table>\n<h3 id=\"authoritative-query-path\">Authoritative Query Path</h3>\n<p>When the DNS server determines it holds authoritative data for a queried domain, the processing follows a streamlined path through the zone data manager. The server first validates that the questioned domain falls within one of its configured zones, considering the DNS hierarchy and longest-match principles.</p>\n<p>The <strong>zone matching</strong> process examines the question&#39;s domain name against all configured zone origins, finding the most specific zone that encompasses the query. For example, a query for <code>mail.example.com</code> would match a zone for <code>example.com</code> rather than a zone for <code>com</code>, following DNS delegation principles. This matching must handle edge cases like empty non-terminal nodes and wildcard records.</p>\n<p>Once the appropriate zone is identified, <strong>record matching</strong> searches the zone&#39;s data structures for records that satisfy the query. The matching algorithm considers the exact domain name, record type, and class, but must also handle special cases like CNAME resolution, wildcard expansion, and delegation responses for subdomains.</p>\n<p>The <strong>response construction</strong> phase assembles answer, authority, and additional sections according to DNS protocol requirements. Answer sections contain the requested records, authority sections include SOA or NS records as appropriate, and additional sections provide glue records for NS responses to enable resolution continuation.</p>\n<h3 id=\"recursive-query-path\">Recursive Query Path</h3>\n<p>Recursive queries follow a more complex path that may involve multiple external network requests and cache interactions. The recursive resolver must maintain resolution state across multiple round trips while avoiding infinite loops and handling various error conditions.</p>\n<p>The <strong>cache consultation</strong> happens first, where the resolver checks if a valid, non-expired cache entry exists for the exact question. Cache hits allow immediate response construction, while cache misses trigger the full recursive resolution process. Negative cache entries (for NXDOMAIN responses) are also consulted to avoid repeated queries for non-existent domains.</p>\n<p>When cache misses occur, <strong>iterative resolution</strong> begins by consulting root hints and following NS referrals down the DNS hierarchy. The resolver maintains a <code>ResolutionState</code> object that tracks the current question, visited servers, CNAME chains, and query depth to prevent loops and limit resource consumption.</p>\n<p>Each iteration of the resolution process involves <strong>server selection</strong> from the current set of nameservers, <strong>query transmission</strong> over UDP with timeout handling, <strong>response validation</strong> to prevent cache poisoning, and <strong>referral following</strong> to continue down the hierarchy. The resolver must handle glue records, out-of-bailiwick data filtering, and CNAME chain resolution.</p>\n<h3 id=\"error-handling-flow\">Error Handling Flow</h3>\n<p>Error conditions can arise at every stage of query processing, and the server must handle them gracefully while providing meaningful responses to clients. The error handling strategy varies based on the error type, processing stage, and whether recovery is possible.</p>\n<p><strong>Parse errors</strong> during message processing result in FORMERR responses when the error can be detected early enough to construct a valid response header. However, severe parsing failures that prevent header extraction result in silent packet drops to avoid amplification attacks.</p>\n<p><strong>Resolution timeout errors</strong> during recursive queries trigger retry logic with exponential backoff, but ultimately result in SERVFAIL responses if no authoritative answer can be obtained. The resolver must balance persistence in following referrals against response time requirements.</p>\n<p><strong>Cache corruption</strong> or <strong>zone file errors</strong> represent more serious conditions that may require administrative intervention. These errors are logged extensively but typically result in SERVFAIL responses rather than server crashes.</p>\n<blockquote>\n<p><strong>Architecture Decision: Error Response Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS servers must handle various error conditions while maintaining availability and preventing abuse</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Always respond with error codes</li>\n<li>Drop malformed packets silently</li>\n<li>Hybrid approach based on error severity</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use hybrid error handling with silent drops for severe parse errors and proper error codes for recoverable failures</li>\n<li><strong>Rationale</strong>: Silent drops prevent amplification attacks and resource exhaustion while proper error codes help legitimate clients diagnose issues</li>\n<li><strong>Consequences</strong>: Requires careful classification of error severity and comprehensive logging for debugging</li>\n</ul>\n</blockquote>\n<h2 id=\"component-interface-contracts\">Component Interface Contracts</h2>\n<p>The interfaces between DNS server components define the contracts that enable loose coupling while ensuring correct behavior. These interfaces must be precisely specified to handle concurrent access, error propagation, and resource management across component boundaries.</p>\n<h3 id=\"server-to-message-handler-interface\">Server to Message Handler Interface</h3>\n<p>The UDP server interacts with message handlers through a well-defined interface that abstracts the specific resolution logic from network concerns. This separation allows different handler implementations (authoritative-only, recursive, forwarding) to be plugged into the same server infrastructure.</p>\n<table>\n<thead>\n<tr>\n<th>Method Signature</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ProcessQuery(ctx context.Context, query *DNSMessage) (*DNSMessage, error)</code></td>\n<td>Context for cancellation, parsed query message</td>\n<td>Response message or error</td>\n<td>Main entry point for query processing</td>\n</tr>\n<tr>\n<td><code>ValidateQuery(query *DNSMessage) error</code></td>\n<td>Parsed query message</td>\n<td>Error if invalid</td>\n<td>Validates query structure and requirements</td>\n</tr>\n<tr>\n<td><code>GetServerCapabilities() ServerCapabilities</code></td>\n<td>None</td>\n<td>Server capability flags</td>\n<td>Returns supported features (recursion, DNSSEC, etc.)</td>\n</tr>\n<tr>\n<td><code>GetStatistics() HandlerStats</code></td>\n<td>None</td>\n<td>Statistical counters</td>\n<td>Returns query counts, error rates, response times</td>\n</tr>\n</tbody></table>\n<p>The <code>ProcessQuery</code> method serves as the primary interface contract between the server and handler layers. The handler receives a fully parsed DNS message and context for timeout/cancellation control, and must return either a valid response message or an error that the server can convert to an appropriate DNS error code.</p>\n<p><strong>Context handling</strong> is critical for this interface, as DNS queries have strict timeout requirements (typically 5-10 seconds maximum). The handler must respect context cancellation and avoid blocking indefinitely on network operations or lock acquisition. Context propagation continues through all downstream operations including cache lookups and recursive resolution.</p>\n<p><strong>Error semantics</strong> follow a specific pattern where different error types map to DNS response codes. Network timeouts become SERVFAIL responses, parse errors become FORMERR responses, and policy violations (like recursion disabled) become appropriate refused responses.</p>\n<h3 id=\"message-handler-to-resolver-interface\">Message Handler to Resolver Interface</h3>\n<p>The message handler coordinates between authoritative lookup, cache consultation, and recursive resolution through well-defined resolver interfaces. This abstraction allows testing with mock resolvers and supports different resolution strategies.</p>\n<table>\n<thead>\n<tr>\n<th>Method Signature</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ResolveQuery(ctx context.Context, question Question) (*DNSMessage, error)</code></td>\n<td>Context and DNS question</td>\n<td>Complete DNS response</td>\n<td>Performs full resolution (cache + recursion)</td>\n</tr>\n<tr>\n<td><code>LookupAuthoritative(question Question) ([]ResourceRecord, error)</code></td>\n<td>DNS question</td>\n<td>Matching authoritative records</td>\n<td>Queries local zone data only</td>\n</tr>\n<tr>\n<td><code>LookupCache(key CacheKey) (*CacheEntry, bool)</code></td>\n<td>Cache lookup key</td>\n<td>Cache entry and found flag</td>\n<td>Retrieves cached records if present/valid</td>\n</tr>\n<tr>\n<td><code>PerformRecursion(ctx context.Context, question Question) (*DNSMessage, error)</code></td>\n<td>Context and question</td>\n<td>Resolved response</td>\n<td>Executes full recursive resolution</td>\n</tr>\n</tbody></table>\n<p>The resolver interface separates concerns between different types of DNS resolution. <code>LookupAuthoritative</code> handles queries for domains where the server is authoritative, consulting only local zone data. <code>LookupCache</code> provides fast access to previously resolved queries. <code>PerformRecursion</code> handles the complex iterative resolution process for cache misses.</p>\n<p><strong>Resolution priority</strong> follows a specific order: authoritative data takes precedence over cached data, which takes precedence over recursive resolution. This priority ensures that authoritative servers provide definitive answers for their zones while still benefiting from caching for delegation responses.</p>\n<p><strong>State isolation</strong> between resolution attempts prevents interference between concurrent queries. Each resolution maintains its own <code>ResolutionState</code> object with separate CNAME chains, server lists, and loop detection state.</p>\n<h3 id=\"cache-manager-interface-contracts\">Cache Manager Interface Contracts</h3>\n<p>The cache manager provides thread-safe access to cached DNS records with TTL-based expiration and memory management. The interface must support concurrent readers and writers while maintaining cache consistency and preventing memory exhaustion.</p>\n<table>\n<thead>\n<tr>\n<th>Method Signature</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Get(key CacheKey) (*CacheEntry, bool)</code></td>\n<td>Cache key (name, type, class)</td>\n<td>Entry and found flag</td>\n<td>Thread-safe cache lookup</td>\n</tr>\n<tr>\n<td><code>Put(key CacheKey, records []ResourceRecord, ttl uint32) error</code></td>\n<td>Key, records, TTL</td>\n<td>Error if storage failed</td>\n<td>Stores positive cache entry</td>\n</tr>\n<tr>\n<td><code>PutNegative(key CacheKey, soaRecord ResourceRecord) error</code></td>\n<td>Key and SOA record</td>\n<td>Error if storage failed</td>\n<td>Stores negative (NXDOMAIN) entry</td>\n</tr>\n<tr>\n<td><code>Evict(key CacheKey) bool</code></td>\n<td>Cache key</td>\n<td>True if entry existed</td>\n<td>Removes specific cache entry</td>\n</tr>\n<tr>\n<td><code>Cleanup() int</code></td>\n<td>None</td>\n<td>Count of expired entries</td>\n<td>Removes expired entries, returns count</td>\n</tr>\n<tr>\n<td><code>Stats() CacheStats</code></td>\n<td>None</td>\n<td>Cache statistics</td>\n<td>Hit rate, memory usage, entry counts</td>\n</tr>\n</tbody></table>\n<p>The cache interface emphasizes <strong>thread safety</strong> through internal locking rather than requiring callers to coordinate access. The <code>CacheManager</code> uses read-write mutexes to allow concurrent cache lookups while serializing cache updates and cleanup operations.</p>\n<p><strong>TTL handling</strong> occurs automatically within the cache manager. The <code>Get</code> method checks expiration timestamps and treats expired entries as cache misses, while background cleanup removes expired entries periodically to prevent memory leaks.</p>\n<p><strong>Memory management</strong> involves both entry count limits and total memory consumption limits. The cache tracks the serialized size of stored records and implements LRU eviction when limits are approached.</p>\n<blockquote>\n<p><strong>Decision: Cache Interface Design</strong></p>\n<ul>\n<li><strong>Context</strong>: Cache must support concurrent access while maintaining consistency and performance</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>External locking with simple map interface</li>\n<li>Internal locking with Get/Put methods</li>\n<li>Lock-free implementation with atomic operations</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Internal locking with comprehensive cache management</li>\n<li><strong>Rationale</strong>: Simplifies caller code, enables sophisticated cache policies, and provides better encapsulation of cache internals</li>\n<li><strong>Consequences</strong>: Slightly higher memory overhead but much simpler usage and better testability</li>\n</ul>\n</blockquote>\n<h3 id=\"zone-data-manager-interface\">Zone Data Manager Interface</h3>\n<p>The zone data manager provides access to authoritative DNS records loaded from zone files. The interface must support efficient lookups while handling zone reloading and configuration changes.</p>\n<table>\n<thead>\n<tr>\n<th>Method Signature</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LoadZone(config ZoneConfig) error</code></td>\n<td>Zone configuration</td>\n<td>Error if load failed</td>\n<td>Loads zone file into memory</td>\n</tr>\n<tr>\n<td><code>FindZone(domain string) (*ZoneData, bool)</code></td>\n<td>Domain name</td>\n<td>Zone data and found flag</td>\n<td>Finds authoritative zone for domain</td>\n</tr>\n<tr>\n<td><code>LookupRecords(zone *ZoneData, name string, qtype uint16) ([]ResourceRecord, error)</code></td>\n<td>Zone, name, type</td>\n<td>Matching records</td>\n<td>Finds records in zone</td>\n</tr>\n<tr>\n<td><code>ReloadZone(domain string) error</code></td>\n<td>Zone domain name</td>\n<td>Error if reload failed</td>\n<td>Hot-reloads zone from file</td>\n</tr>\n<tr>\n<td><code>GetZoneStats(domain string) ZoneStats</code></td>\n<td>Zone domain</td>\n<td>Zone statistics</td>\n<td>Query counts, record counts</td>\n</tr>\n</tbody></table>\n<p><strong>Zone matching</strong> uses longest-prefix matching to find the most specific zone that contains a queried domain. For example, <code>mail.example.com</code> would match zone <code>example.com</code> rather than zone <code>com</code> if both were configured.</p>\n<p><strong>Record lookup</strong> within zones uses efficient data structures (typically hash maps keyed by domain name and record type) to minimize search time. Wildcard matching and empty non-terminal handling add complexity that must be hidden behind the interface.</p>\n<p><strong>Hot reloading</strong> allows zone file updates without server restart. The implementation must handle file locking, parse error recovery, and atomic replacement of zone data to prevent partial updates during active queries.</p>\n<h3 id=\"network-client-interface\">Network Client Interface</h3>\n<p>The network client abstracts UDP DNS communication for recursive resolution, providing timeout handling, retry logic, and response correlation across multiple outstanding queries.</p>\n<table>\n<thead>\n<tr>\n<th>Method Signature</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>QueryServer(ctx context.Context, query []byte, serverIP string) ([]byte, error)</code></td>\n<td>Context, query bytes, server IP</td>\n<td>Response bytes</td>\n<td>Sends DNS query via UDP</td>\n</tr>\n<tr>\n<td><code>QueryWithRetry(ctx context.Context, query []byte, servers []string) ([]byte, error)</code></td>\n<td>Context, query, server list</td>\n<td>Response bytes</td>\n<td>Tries multiple servers</td>\n</tr>\n<tr>\n<td><code>SetTimeout(timeout time.Duration)</code></td>\n<td>Timeout duration</td>\n<td>None</td>\n<td>Configures query timeout</td>\n</tr>\n<tr>\n<td><code>GetStats() NetworkStats</code></td>\n<td>None</td>\n<td>Network statistics</td>\n<td>Timeout rates, RTT measurements</td>\n</tr>\n</tbody></table>\n<p><strong>Connection management</strong> involves maintaining UDP sockets for outbound queries while handling connection errors and server unreachability. The client may use a single shared socket or create dedicated sockets per query depending on performance requirements.</p>\n<p><strong>Timeout handling</strong> must balance responsiveness against reliability. Short timeouts improve user experience but may abandon slow but valid responses, while long timeouts can tie up resolution threads and delay error responses.</p>\n<p><strong>Retry strategies</strong> help handle temporary network issues and server overload. The client typically tries each server once before moving to the next, but may implement more sophisticated backoff algorithms for persistent failures.</p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"System Components\"></p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Frecursive-resolution-flow.svg\" alt=\"Recursive Resolution Sequence\"></p>\n<p><img src=\"/api/project/build-dns/architecture-doc/asset?path=diagrams%2Fconcurrent-query-handling.svg\" alt=\"Concurrent Query Processing Architecture\"></p>\n<h3 id=\"data-exchange-formats\">Data Exchange Formats</h3>\n<p>The components exchange several standardized data structures that must maintain consistency across component boundaries. These formats define the contracts for data integrity and enable component testing and validation.</p>\n<h4 id=\"dns-message-exchange-format\">DNS Message Exchange Format</h4>\n<p>All components that handle DNS messages use the standardized <code>DNSMessage</code> structure, but different components may populate different sections based on their responsibilities.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Populates Sections</th>\n<th>Validates Sections</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Parser</td>\n<td>All sections from wire format</td>\n<td>Header and basic structure</td>\n<td>Convert wire format to internal representation</td>\n</tr>\n<tr>\n<td>Authoritative Server</td>\n<td>Answer, Authority, Additional</td>\n<td>Question section</td>\n<td>Provide definitive answers for local zones</td>\n</tr>\n<tr>\n<td>Recursive Resolver</td>\n<td>Answer section primarily</td>\n<td>All sections for security</td>\n<td>Resolve queries via hierarchy traversal</td>\n</tr>\n<tr>\n<td>Cache Manager</td>\n<td>Not applicable</td>\n<td>Answer section for storage</td>\n<td>Store and retrieve resolved records</td>\n</tr>\n</tbody></table>\n<p><strong>Section ownership</strong> determines which component is responsible for populating each part of DNS responses. The authoritative server owns authority section content for its zones, while recursive resolvers focus primarily on answer section population.</p>\n<p><strong>Validation responsibilities</strong> are distributed across components with each component validating the data it receives and uses. Parsers validate wire format compliance, resolvers validate response security properties, and caches validate record consistency.</p>\n<h4 id=\"cache-entry-exchange\">Cache Entry Exchange</h4>\n<p>Cache entries contain additional metadata beyond basic DNS records to support TTL management, negative caching, and cache statistics.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Populated By</th>\n<th>Used By</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Records</code></td>\n<td><code>[]ResourceRecord</code></td>\n<td>Resolver</td>\n<td>All components</td>\n<td>The actual DNS records</td>\n</tr>\n<tr>\n<td><code>ExpiresAt</code></td>\n<td><code>time.Time</code></td>\n<td>Cache Manager</td>\n<td>Cache Manager</td>\n<td>Absolute expiration time</td>\n</tr>\n<tr>\n<td><code>Negative</code></td>\n<td><code>bool</code></td>\n<td>Resolver</td>\n<td>Query processors</td>\n<td>Indicates NXDOMAIN/NODATA response</td>\n</tr>\n<tr>\n<td><code>SOARecord</code></td>\n<td><code>*ResourceRecord</code></td>\n<td>Resolver</td>\n<td>Response construction</td>\n<td>SOA for negative responses</td>\n</tr>\n<tr>\n<td><code>HitCount</code></td>\n<td><code>uint64</code></td>\n<td>Cache Manager</td>\n<td>Statistics</td>\n<td>Track cache entry popularity</td>\n</tr>\n</tbody></table>\n<p><strong>Expiration semantics</strong> use absolute timestamps rather than relative TTL values to avoid timing issues with cache entry age calculation. The cache manager converts TTL values to expiration timestamps when storing entries.</p>\n<p><strong>Negative cache entries</strong> require special handling because they represent the absence of records rather than the presence of specific records. The associated SOA record provides the appropriate TTL and authority information for negative responses.</p>\n<h3 id=\"common-pitfalls-in-component-interactions\">Common Pitfalls in Component Interactions</h3>\n<p>Several categories of errors frequently occur in DNS server implementations related to component interactions and data flow management.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in Cache Access</strong></p>\n<p>Multiple goroutines accessing cache entries simultaneously can lead to data races, especially during cache updates and TTL expiration. Reading cache entries while they&#39;re being modified can return partial or inconsistent data.</p>\n<p>The cache manager must use appropriate synchronization primitives (read-write mutexes) to coordinate access between readers and writers. Cache lookups should hold read locks only for the duration of entry location and validation, not for the entire query processing.</p>\n<p>⚠️ <strong>Pitfall: Context Cancellation Propagation</strong></p>\n<p>Failure to properly propagate context cancellation through component interfaces can lead to goroutine leaks and resource exhaustion. Long-running recursive queries may continue consuming resources after clients have disconnected or timed out.</p>\n<p>Every component interface that performs I/O operations or blocking calls must accept and respect context cancellation. Network operations, cache operations, and resolution steps must check context state and abort cleanly when cancellation occurs.</p>\n<p>⚠️ <strong>Pitfall: Error Semantic Mismatches</strong></p>\n<p>Different components may interpret the same error condition differently, leading to inappropriate responses or recovery actions. For example, a temporary network timeout might be treated as a permanent failure if error types aren&#39;t properly distinguished.</p>\n<p>Component interfaces should define specific error types for different failure conditions (temporary vs permanent, recoverable vs fatal) and document the expected handling behavior for each error category.</p>\n<p>⚠️ <strong>Pitfall: Memory Ownership Confusion</strong></p>\n<p>When components share references to DNS messages or resource records, unclear ownership semantics can lead to concurrent modification or premature garbage collection. Modifying shared data structures can corrupt other components&#39; state.</p>\n<p>Component interfaces should clearly specify whether returned data structures are read-only views, private copies, or shared references with specific modification constraints. Defensive copying may be necessary when multiple components need to modify the same base data.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The component interactions and data flow implementation requires careful attention to concurrency, error handling, and resource management. The following guidance provides practical approaches for implementing these critical aspects.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Concurrency</td>\n<td>Basic goroutines with mutexes</td>\n<td>Worker pools with channels</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Direct error returns</td>\n<td>Structured error types with context</td>\n</tr>\n<tr>\n<td>Metrics</td>\n<td>Simple counters</td>\n<td>Prometheus metrics</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard log package</td>\n<td>Structured logging (logrus/zap)</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>YAML files</td>\n<td>Dynamic configuration with watchers</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  server/\n    server.go              ← UDP server and main coordination\n    handler.go             ← MessageHandler implementation\n    handler_test.go\n  parser/\n    parser.go              ← DNS message parsing\n    compression.go         ← Name compression handling\n  resolver/\n    recursive.go           ← RecursiveResolver implementation\n    authoritative.go       ← AuthoritativeServer implementation\n    client.go              ← NetworkClient for upstream queries\n  cache/\n    manager.go             ← CacheManager implementation\n    entry.go               ← Cache entry management\n    cleanup.go             ← Background cleanup routines\n  zones/\n    loader.go              ← Zone file parsing and loading\n    data.go                ← Zone data structures and lookup</code></pre></div>\n\n<h4 id=\"core-data-flow-coordination\">Core Data Flow Coordination</h4>\n<p>The main server coordination logic manages the interaction between all components while handling concurrency and error conditions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Server coordinates all DNS server components and manages query processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Server</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn        </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PacketConn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">parser</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MessageParser</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handler     </span><span style=\"color:#B392F0\">MessageHandler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shutdown    </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wg          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">WaitGroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleQuery processes a single DNS query through the component pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">queryData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">clientAddr</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse the incoming DNS message using MessageParser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate the parsed message structure and question section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create context with timeout for query processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call MessageHandler.ProcessQuery with parsed message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Serialize the response message back to wire format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Send response packet to client address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Handle and log any errors at each step</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use defer for cleanup and always respond to avoid client timeouts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"component-interface-implementation\">Component Interface Implementation</h4>\n<p>The <code>MessageHandler</code> interface coordinates between authoritative lookup, caching, and recursive resolution:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// MessageHandler processes DNS queries using appropriate resolution strategy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageHandler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    zones      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">zones</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cache</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resolver   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">resolver</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RecursiveResolver</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    authoritative </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">resolver</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuthoritativeServer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessQuery implements the main query processing workflow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract question from query message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if we have authoritative data for the question domain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If authoritative, use AuthoritativeServer.ProcessQuery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If not authoritative, check cache with CacheManager.Get</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If cache miss, use RecursiveResolver.ResolveQuery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store successful recursive results in cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Construct appropriate response message with answer/authority sections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Always set response header flags correctly (QR, RA, AA)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"cache-integration-pattern\">Cache Integration Pattern</h4>\n<p>Cache integration requires careful handling of concurrent access and TTL management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// CacheManager provides thread-safe DNS record caching with TTL expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CacheManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">CacheKey</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxEntries  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats       </span><span style=\"color:#B392F0\">CacheStats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanup     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Ticker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get retrieves a cache entry if present and not expired</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire read lock for thread-safe access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Look up cache entry in internal map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if entry exists and is not expired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update hit statistics atomically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return deep copy of entry to prevent modification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use time.Now().After(entry.ExpiresAt) to check expiration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Put stores records in cache with TTL-based expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">records</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ResourceRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock for thread-safe modification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create CacheEntry with expiration timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if adding entry would exceed size limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Evict LRU entries if necessary to make space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store entry in cache map and update statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use time.Now().Add(time.Duration(ttl) * time.Second) for expiration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"error-handling-patterns\">Error Handling Patterns</h4>\n<p>DNS-specific error handling requires mapping internal errors to appropriate DNS response codes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// DNSError represents DNS-specific errors with response codes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DNSError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code    </span><span style=\"color:#F97583\">uint8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cause   </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MapErrorToResponseCode converts internal errors to DNS response codes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> MapErrorToResponseCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Handle context timeout/cancellation as SERVFAIL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle parse errors as FORMERR</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle resolution failures as SERVFAIL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle policy violations as REFUSED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle unknown domains as NXDOMAIN (from authoritative only)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use type assertions to check for specific error types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing component interactions:</p>\n<ol>\n<li><strong>Basic Flow Test</strong>: Run <code>go test ./internal/server/...</code> - should show successful query parsing and response construction</li>\n<li><strong>Integration Test</strong>: Start server with <code>go run cmd/server/main.go</code>, query with <code>dig @localhost -p 8053 example.com</code> - should receive valid response</li>\n<li><strong>Concurrency Test</strong>: Run multiple concurrent dig commands - should handle without blocking or errors</li>\n<li><strong>Cache Verification</strong>: Enable debug logging and verify cache hits/misses appear in logs for repeated queries</li>\n<li><strong>Error Handling</strong>: Send malformed DNS packets and verify appropriate error responses or silent drops</li>\n</ol>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server hangs on startup</td>\n<td>UDP bind failure</td>\n<td>Check <code>netstat -ulnp | grep :53</code></td>\n<td>Use different port or check permissions</td>\n</tr>\n<tr>\n<td>Responses always SERVFAIL</td>\n<td>Component interface errors</td>\n<td>Add logging to each interface call</td>\n<td>Fix error handling in component chain</td>\n</tr>\n<tr>\n<td>Cache never hits</td>\n<td>Key generation issues</td>\n<td>Log cache keys during Get/Put</td>\n<td>Ensure consistent key generation</td>\n</tr>\n<tr>\n<td>Memory usage grows unbounded</td>\n<td>Cache not evicting entries</td>\n<td>Check cleanup goroutine and TTL handling</td>\n<td>Implement proper cache size limits</td>\n</tr>\n<tr>\n<td>Concurrent queries interfere</td>\n<td>Data race in shared state</td>\n<td>Run with <code>go run -race</code></td>\n<td>Add proper synchronization primitives</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - Error handling is critical throughout DNS message parsing, authoritative responses, recursive resolution, and caching operations</p>\n</blockquote>\n<p>Building a robust DNS server requires comprehensive error handling that gracefully manages the myriad of failure modes inherent in distributed network systems. DNS operates in an environment where partial failures, malformed data, and network timeouts are not exceptional cases but routine occurrences that must be handled transparently. The challenge lies in distinguishing between recoverable errors that should trigger retry logic and fatal errors that require immediate failure responses, while maintaining the strict timing requirements that DNS clients expect.</p>\n<h3 id=\"mental-model-error-handling-as-immune-system-response\">Mental Model: Error Handling as Immune System Response</h3>\n<p>Think of DNS error handling like a biological immune system responding to various threats. Just as your immune system has different responses for different types of infections—quarantining viruses, attacking bacteria, or triggering inflammation—a DNS server must have tailored responses for different error categories. Parse errors are like toxins that must be immediately rejected, network failures are like temporary blockages that require alternate pathways, and malformed queries are like foreign substances that need careful classification before response. The key insight is that not all errors are created equal, and the response must be proportional and appropriate to maintain system health while continuing to serve legitimate requests.</p>\n<p>The DNS protocol itself provides structured error signaling through response codes (<code>RCODE</code> values), but the server must also handle the vast space of errors that occur before a proper DNS response can be constructed. This dual-layer error handling—internal error management and protocol-level error signaling—requires careful coordination to ensure that clients receive meaningful feedback while protecting the server from cascading failures.</p>\n<h3 id=\"error-categories-and-recovery\">Error Categories and Recovery</h3>\n<p>DNS server error handling can be systematically organized into distinct categories, each requiring different detection mechanisms, recovery strategies, and client communication approaches. Understanding these categories allows developers to implement appropriate error boundaries and recovery logic that maintains service availability while providing meaningful feedback to clients.</p>\n<h4 id=\"parse-and-protocol-errors\">Parse and Protocol Errors</h4>\n<p>Parse errors represent the first line of defense against malformed or malicious DNS messages. These errors occur during the binary-to-structure conversion process and must be detected before any business logic processes potentially invalid data. The challenge with parse errors is that they often leave the parser in an undefined state, making error recovery particularly critical for preventing memory corruption or infinite loops.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>DNS Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Insufficient Buffer</td>\n<td><code>len(data) &lt; expectedSize</code> check</td>\n<td>Reject entire message, log source</td>\n<td><code>RCODE_FORMERR</code></td>\n</tr>\n<tr>\n<td>Invalid Compression Pointer</td>\n<td>Pointer target validation during <code>parseName</code></td>\n<td>Skip malformed name, continue parsing</td>\n<td><code>RCODE_FORMERR</code></td>\n</tr>\n<tr>\n<td>Compression Loop</td>\n<td>Loop detection in <code>parseState.visited</code></td>\n<td>Break loop, return partial name</td>\n<td><code>RCODE_FORMERR</code></td>\n</tr>\n<tr>\n<td>Unknown Record Type</td>\n<td>Type field validation in <code>parseResourceRecord</code></td>\n<td>Skip unknown RR, continue parsing</td>\n<td>Continue processing</td>\n</tr>\n<tr>\n<td>Truncated Header</td>\n<td>Header size validation</td>\n<td>Reject message immediately</td>\n<td>No response</td>\n</tr>\n<tr>\n<td>Invalid Section Count</td>\n<td>Count vs actual records mismatch</td>\n<td>Process available records, ignore excess</td>\n<td>Continue processing</td>\n</tr>\n</tbody></table>\n<p>The most critical aspect of parse error handling is maintaining parser state integrity. When a parse error occurs mid-message, the parser must either complete processing with degraded results or cleanly abort without corrupting shared state. This is particularly important for the <code>parseState</code> structure that tracks compression pointer locations and parsing offsets.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Parse errors should never cause server crashes or memory corruption. The DNS protocol&#39;s robustness depends on servers gracefully rejecting malformed messages while continuing to serve legitimate requests.</p>\n</blockquote>\n<p><strong>Decision: Parse Error Isolation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Parse errors can occur at any point during message processing, potentially leaving the parser in an inconsistent state</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Fail fast on first parse error</li>\n<li>Skip malformed sections and continue processing</li>\n<li>Attempt error correction and recovery</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Fail fast for structural errors, skip individual malformed records</li>\n<li><strong>Rationale</strong>: DNS clients expect predictable responses, and partial parsing can lead to security vulnerabilities</li>\n<li><strong>Consequences</strong>: Higher reliability at the cost of reduced fault tolerance for slightly malformed messages</li>\n</ul>\n<h4 id=\"network-and-transport-errors\">Network and Transport Errors</h4>\n<p>Network errors encompass the broad category of failures that occur during DNS message transmission and reception. Unlike parse errors, network errors often represent transient conditions that may resolve with retry logic or alternative approaches. The challenge is distinguishing between temporary network congestion and persistent connectivity failures.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Symptoms</th>\n<th>Recovery Strategy</th>\n<th>Timeout Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UDP Socket Timeout</td>\n<td><code>net.PacketConn</code> read timeout</td>\n<td>Retry with exponential backoff</td>\n<td>Start at 1s, max 8s</td>\n</tr>\n<tr>\n<td>Connection Refused</td>\n<td><code>ECONNREFUSED</code> on socket operations</td>\n<td>Try next server in list</td>\n<td>Immediate failover</td>\n</tr>\n<tr>\n<td>Network Unreachable</td>\n<td><code>EHOSTUNREACH</code> or <code>ENETUNREACH</code></td>\n<td>Mark server as down, use alternate</td>\n<td>30s cooldown period</td>\n</tr>\n<tr>\n<td>DNS Response Timeout</td>\n<td>No response within query timeout</td>\n<td>Retry different server</td>\n<td>2s initial, double up to 8s</td>\n</tr>\n<tr>\n<td>Server Overload</td>\n<td><code>RCODE_SERVFAIL</code> responses</td>\n<td>Reduce query rate, try alternate</td>\n<td>Exponential backoff</td>\n</tr>\n<tr>\n<td>Malformed Response</td>\n<td>Parse failure on received data</td>\n<td>Treat as server failure</td>\n<td>Try next available server</td>\n</tr>\n</tbody></table>\n<p>Network error recovery requires careful balance between responsiveness and resource consumption. Aggressive retry logic can amplify network congestion during outages, while conservative retry logic can unnecessarily degrade user experience during transient failures. The key is implementing adaptive timeouts that adjust based on observed network conditions.</p>\n<p>The recursive resolver component bears primary responsibility for network error handling, as it must manage connections to multiple upstream servers while maintaining query performance expectations. When a network error occurs during recursive resolution, the resolver must decide whether to retry the same server, try an alternate server, or return a failure response to the client.</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: Network errors should trigger alternate resolution paths before failing queries. DNS&#39;s distributed architecture provides multiple resolution paths that should be exhausted before returning <code>RCODE_SERVFAIL</code>.</p>\n</blockquote>\n<h4 id=\"resolution-and-logic-errors\">Resolution and Logic Errors</h4>\n<p>Resolution errors occur during the business logic phases of DNS processing—when the server successfully parses a query but encounters problems during authoritative lookup, recursive resolution, or cache management. These errors often indicate configuration problems, resource exhaustion, or logical inconsistencies in DNS data.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Specific Errors</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zone Configuration</td>\n<td>Missing SOA, invalid delegations</td>\n<td>Zone validation at startup</td>\n<td>Return <code>RCODE_SERVFAIL</code>, log error</td>\n</tr>\n<tr>\n<td>Recursive Loops</td>\n<td>CNAME chains, NS referral cycles</td>\n<td>Loop detection counters</td>\n<td>Break loop, return available data</td>\n</tr>\n<tr>\n<td>Cache Corruption</td>\n<td>Expired entries, invalid data</td>\n<td>TTL validation, data integrity checks</td>\n<td>Evict corrupted entries, query upstream</td>\n</tr>\n<tr>\n<td>Resource Exhaustion</td>\n<td>Memory limits, connection pools</td>\n<td>Resource monitoring, threshold checks</td>\n<td>Shed load, return <code>RCODE_SERVFAIL</code></td>\n</tr>\n<tr>\n<td>Authority Conflicts</td>\n<td>Multiple zones claiming authority</td>\n<td>Zone overlap detection</td>\n<td>Prefer most specific zone match</td>\n</tr>\n<tr>\n<td>Upstream Failures</td>\n<td>All recursive servers unavailable</td>\n<td>Health monitoring, retry logic</td>\n<td>Return cached data if available</td>\n</tr>\n</tbody></table>\n<p>Resolution errors require sophisticated handling because they often indicate systemic problems rather than transient failures. For example, a CNAME loop in zone data represents a configuration error that won&#39;t resolve with retry logic, while upstream server failures may require falling back to cached data or alternative resolution strategies.</p>\n<p>The challenge with resolution errors is maintaining consistency across the distributed DNS infrastructure. When an authoritative server detects invalid zone data, it must decide whether to refuse queries entirely or serve partial data. Similarly, recursive resolvers must balance freshness requirements against availability when upstream failures prevent cache refresh.</p>\n<p><strong>Decision: Resolution Error Handling Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Resolution errors can indicate either transient network issues or persistent configuration problems</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Always fail fast on resolution errors</li>\n<li>Implement aggressive fallback to cached data</li>\n<li>Differentiate between error types with targeted recovery</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Differentiate error types with targeted recovery strategies per error category</li>\n<li><strong>Rationale</strong>: Different resolution errors require different handling—loops should be broken, network failures should trigger retries, and configuration errors should be logged for operator attention</li>\n<li><strong>Consequences</strong>: More complex error handling logic but better service availability and easier troubleshooting</li>\n</ul>\n<h3 id=\"dns-protocol-edge-cases\">DNS Protocol Edge Cases</h3>\n<p>Beyond standard error conditions, DNS servers must handle numerous protocol edge cases that arise from the evolution of DNS over decades, interoperability requirements across diverse implementations, and the security considerations introduced by malicious actors. These edge cases often involve technically valid but unusual message patterns that can expose vulnerabilities or trigger unexpected behavior in naive implementations.</p>\n<h4 id=\"malformed-query-handling\">Malformed Query Handling</h4>\n<p>Malformed queries represent a particularly challenging class of edge cases because they often exploit ambiguities in the DNS specification or test boundary conditions in parser implementations. A robust DNS server must handle these queries without compromising security or stability while providing meaningful error responses where appropriate.</p>\n<p>The most common malformed query patterns include oversized messages that exceed the 512-byte UDP limit, queries with invalid question counts, malformed domain names that violate length restrictions, and queries that attempt to exploit compression pointer vulnerabilities. Each pattern requires specific detection and handling logic.</p>\n<table>\n<thead>\n<tr>\n<th>Malformed Query Type</th>\n<th>Detection Criteria</th>\n<th>Response Strategy</th>\n<th>Security Consideration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Oversized UDP Query</td>\n<td><code>len(message) &gt; DNS_UDP_MAX_SIZE</code></td>\n<td>Return truncated response with TC bit</td>\n<td>Potential amplification attack</td>\n</tr>\n<tr>\n<td>Invalid Question Count</td>\n<td><code>header.QuestionCount != 1</code> for standard queries</td>\n<td>Return <code>RCODE_FORMERR</code></td>\n<td>Protocol violation</td>\n</tr>\n<tr>\n<td>Label Length Violation</td>\n<td>Any label &gt; 63 bytes or name &gt; 255 bytes</td>\n<td>Return <code>RCODE_FORMERR</code></td>\n<td>Buffer overflow attempt</td>\n</tr>\n<tr>\n<td>Invalid Character Set</td>\n<td>Non-ASCII characters in domain names</td>\n<td>Return <code>RCODE_FORMERR</code> unless IDNA encoded</td>\n<td>Protocol compliance</td>\n</tr>\n<tr>\n<td>Compression Bomb</td>\n<td>Excessive pointer indirection depth</td>\n<td>Limit recursion depth, return <code>RCODE_FORMERR</code></td>\n<td>DoS attack vector</td>\n</tr>\n<tr>\n<td>Reserved Bit Manipulation</td>\n<td>Non-zero reserved header bits</td>\n<td>Ignore reserved bits, process normally</td>\n<td>Future compatibility</td>\n</tr>\n</tbody></table>\n<p>The key principle for malformed query handling is failing securely while maintaining protocol compliance. When a query cannot be processed safely, the server should return an appropriate error response rather than silently dropping the query or attempting unsafe processing that could compromise security.</p>\n<p>Compression-related attacks deserve special attention because they can exploit the recursive nature of pointer following to consume excessive server resources. A malicious query might construct compression pointers that create deep recursive chains or circular references that could cause stack overflow or infinite loops in naive implementations.</p>\n<blockquote>\n<p><strong>Security Principle</strong>: Never trust client-provided data structures. All parsing operations must include bounds checking, recursion limits, and loop detection to prevent exploitation of parser vulnerabilities.</p>\n</blockquote>\n<h4 id=\"oversized-response-management\">Oversized Response Management</h4>\n<p>DNS responses can legitimately exceed the 512-byte UDP limit when they contain numerous resource records or long text records. The protocol handles this through the truncation mechanism, where the server sets the TC (truncation) bit and returns partial data, expecting the client to retry over TCP for the complete response. However, implementing this correctly requires careful consideration of which records to include in the truncated response.</p>\n<p>The truncation algorithm must prioritize response sections to maximize utility while respecting size constraints. Generally, the answer section takes highest priority, followed by authority section records that enable the client to find authoritative servers, and finally additional section records that provide convenience data like glue records.</p>\n<table>\n<thead>\n<tr>\n<th>Response Section</th>\n<th>Truncation Priority</th>\n<th>Inclusion Strategy</th>\n<th>Size Estimation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Header</td>\n<td>Always included</td>\n<td>Complete 12-byte header</td>\n<td>Fixed 12 bytes</td>\n</tr>\n<tr>\n<td>Question Section</td>\n<td>Always included</td>\n<td>Copy original question</td>\n<td>Variable, usually small</td>\n</tr>\n<tr>\n<td>Answer Section</td>\n<td>Highest priority</td>\n<td>Include all if possible, truncate if necessary</td>\n<td>Sum of RR sizes</td>\n</tr>\n<tr>\n<td>Authority Section</td>\n<td>Medium priority</td>\n<td>Include NS records for referrals</td>\n<td>Critical for delegation</td>\n</tr>\n<tr>\n<td>Additional Section</td>\n<td>Lowest priority</td>\n<td>Include glue records for delegation</td>\n<td>Optional optimization</td>\n</tr>\n</tbody></table>\n<p>The implementation challenge lies in accurately predicting serialized message size before committing to specific records. Since DNS name compression can significantly reduce message size, but compression effectiveness depends on name overlap patterns, the server must either implement conservative size estimation or perform trial serialization to determine optimal record selection.</p>\n<p>When truncation is necessary, the server must decide whether to include partial record sets or complete record sets with some sections omitted. The protocol strongly favors complete record sets to avoid confusing clients that might interpret partial data as authoritative negative responses.</p>\n<p><strong>Decision: Truncation Strategy for Oversized Responses</strong></p>\n<ul>\n<li><strong>Context</strong>: UDP responses exceeding 512 bytes must be truncated with TC bit set</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Simple truncation at byte boundary regardless of record boundaries</li>\n<li>Intelligent truncation preserving complete resource records</li>\n<li>Dynamic TCP fallback for all large responses</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Intelligent truncation preserving complete resource records with section priority ordering</li>\n<li><strong>Rationale</strong>: Partial resource records confuse clients and violate protocol semantics; complete records in priority order maximize client utility</li>\n<li><strong>Consequences</strong>: More complex truncation logic but better client compatibility and protocol compliance</li>\n</ul>\n<h4 id=\"protocol-violation-recovery\">Protocol Violation Recovery</h4>\n<p>Real-world DNS implementations often deviate from strict RFC compliance due to implementation bugs, configuration errors, or deliberate protocol extensions. A robust DNS server must handle these protocol violations gracefully while maintaining its own compliance standards. This creates a tension between strict protocol adherence and operational compatibility.</p>\n<p>Common protocol violations include responses with mismatched question sections, resource records in unexpected sections, invalid TTL values, and responses that don&#39;t properly implement compression. Each violation type requires careful analysis to determine whether it represents a benign compatibility issue or a potential security threat.</p>\n<p>The challenge is implementing liberal parsing policies that accept minor deviations while rejecting dangerous violations. For example, a response that omits the question section might be acceptable if the answer section clearly identifies the queried name, but a response with compressed pointers that reference invalid offsets should be rejected entirely.</p>\n<table>\n<thead>\n<tr>\n<th>Violation Type</th>\n<th>Severity Level</th>\n<th>Handling Strategy</th>\n<th>Compatibility Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing Question Echo</td>\n<td>Minor</td>\n<td>Accept if answer section is clear</td>\n<td>High compatibility gain</td>\n</tr>\n<tr>\n<td>Invalid Compression</td>\n<td>Critical</td>\n<td>Reject response, try next server</td>\n<td>Security protection</td>\n</tr>\n<tr>\n<td>Wrong Section Placement</td>\n<td>Minor</td>\n<td>Process records regardless of section</td>\n<td>Operational flexibility</td>\n</tr>\n<tr>\n<td>Invalid TTL Values</td>\n<td>Minor</td>\n<td>Clamp to reasonable ranges</td>\n<td>Cache consistency</td>\n</tr>\n<tr>\n<td>Malformed RDATA</td>\n<td>Moderate</td>\n<td>Skip record, continue processing</td>\n<td>Partial data preservation</td>\n</tr>\n<tr>\n<td>Response/Query Mismatch</td>\n<td>Critical</td>\n<td>Reject response, potential cache poisoning</td>\n<td>Security protection</td>\n</tr>\n</tbody></table>\n<p>The recursive resolver must be particularly careful about protocol violations in upstream responses, as accepting invalid data could propagate errors to clients or compromise cache integrity. The principle is to be liberal in parsing but conservative in trusting, validating all critical security properties while accommodating minor formatting deviations.</p>\n<blockquote>\n<p><strong>Operational Insight</strong>: Real-world DNS infrastructure contains numerous implementations with minor protocol violations. Strict compliance can reduce interoperability, but security-critical validations must never be relaxed.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation of comprehensive error handling in a DNS server requires careful attention to error boundaries, recovery strategies, and security validation. The following guidance provides concrete approaches for implementing robust error handling that maintains service availability while protecting against malicious input.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Logging</td>\n<td>Standard log package with structured logging</td>\n<td>Structured logging with log levels (logrus/zap)</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Simple counters and timers</td>\n<td>Prometheus metrics with alerting</td>\n</tr>\n<tr>\n<td>Circuit Breaking</td>\n<td>Basic retry with exponential backoff</td>\n<td>Circuit breaker pattern (hystrix-go)</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>Manual memory/connection tracking</td>\n<td>Runtime metrics with automatic limits</td>\n</tr>\n<tr>\n<td>Configuration Validation</td>\n<td>Startup validation with error exit</td>\n<td>Hot reload with validation and rollback</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-error-handling-structure\">Recommended Error Handling Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  errors/\n    dns_errors.go           ← DNS-specific error types and codes\n    error_handler.go        ← Central error processing and logging\n    recovery.go             ← Error recovery strategies\n  parser/\n    parse_errors.go         ← Parse-specific error handling\n    validation.go           ← Message validation and sanitization\n  resolver/\n    resolution_errors.go    ← Resolution failure handling\n    retry_logic.go          ← Network retry and backoff logic\n  server/\n    error_responses.go      ← DNS error response construction\n    request_validation.go   ← Request validation and filtering</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete DNS Error Types (dns_errors.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DNSError represents DNS-specific errors with response codes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DNSError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code        </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">     // DNS RCODE value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message     </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Human-readable error description</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Underlying  </span><span style=\"color:#F97583\">error</span><span style=\"color:#6A737D\">     // Wrapped underlying error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\"> // When error occurred</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Source      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Component that generated error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DNS </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> error: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Source, e.Message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Unwrap</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> e.Underlying</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common DNS error constructors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewFormatError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Code:       </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// RCODE_FORMERR</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Message:    msg,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Underlying: err,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp:  time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Source:     </span><span style=\"color:#9ECBFF\">\"parser\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewServerFailure</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Code:       </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// RCODE_SERVFAIL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Message:    msg,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Underlying: err,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp:  time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Source:     </span><span style=\"color:#9ECBFF\">\"resolver\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewNameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Code:       </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// RCODE_NXDOMAIN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Message:    msg,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Underlying: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp:  time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Source:     </span><span style=\"color:#9ECBFF\">\"authoritative\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RetryableError indicates errors that should trigger retry logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RetryableError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Underlying </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RetryAfter </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Attempts   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RetryableError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"retryable error (attempt </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Attempts, e.Underlying)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RetryableError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Unwrap</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> e.Underlying</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkError represents network-related failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ServerAddr </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operation  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Underlying </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timeout    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"failed\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> e.Timeout {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"timed out\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"network </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> to </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Operation, e.ServerAddr, status, e.Underlying)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Error Response Builder (error_responses.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">dns-server/internal/errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ErrorResponseBuilder constructs DNS error responses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ErrorResponseBuilder</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewErrorResponseBuilder</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">logger</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ErrorResponseBuilder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ErrorResponseBuilder</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger: logger,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BuildErrorResponse creates a DNS response for various error conditions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ErrorResponseBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BuildErrorResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Header: </span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ID:              query.Header.ID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            QueryResponse:   </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Opcode:          query.Header.Opcode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Authoritative:   </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Truncated:       </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            RecursionDesired: query.Header.RecursionDesired,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            RecursionAvail:  </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ResponseCode:    e.</span><span style=\"color:#B392F0\">determineResponseCode</span><span style=\"color:#E1E4E8\">(err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            QuestionCount:   query.Header.QuestionCount,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            AnswerCount:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            AuthorityCount:  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            AdditionalCount: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Questions:  query.Questions, </span><span style=\"color:#6A737D\">// Echo original questions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Answers:    </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Authority:  </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Additional: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Log error for monitoring and debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    e.</span><span style=\"color:#B392F0\">logError</span><span style=\"color:#E1E4E8\">(query, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ErrorResponseBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">determineResponseCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> dnsErr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> err.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DNSError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> dnsErr.Code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NetworkError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\"> // RCODE_SERVFAIL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RetryableError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\"> // RCODE_SERVFAIL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\"> // RCODE_SERVFAIL for unknown errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ErrorResponseBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">logError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queryName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"unknown\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(query.Questions) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queryName </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> query.Questions[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    e.logger.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DNS Error - Query: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, ID: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, Error: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queryName, query.Header.ID, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Parse Error Handler (parse_errors.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> parser</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateMessage performs comprehensive DNS message validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate header fields are within acceptable ranges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that Opcode is standard query (0) or supported value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify section counts don't exceed reasonable limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Ensure reserved bits are zero for strict compliance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate question section consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify QuestionCount matches actual Questions slice length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that all question names are valid DNS labels</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Validate QTYPE and QCLASS values are known or acceptable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate resource record sections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that record counts match slice lengths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify all names in records are properly formatted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Validate TTL values are reasonable (not negative when cast)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate message size constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Ensure total message size would not exceed UDP limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that name compression is used efficiently</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify no resource records have oversized RDATA</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Security validation checks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Ensure no compression loops exist in any names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Validate that all compression pointers reference valid offsets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check for potential buffer overflow conditions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecoverFromParseError attempts to recover parsing after encountering an error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RecoverFromParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">parseState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Classify the parse error type and severity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Determine if error is recoverable or should abort parsing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check if error indicates malicious input that should be rejected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Evaluate whether partial parsing results are safe to use</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Reset parser state to known good position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Clear any corrupted state from failed parsing attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Reset compression pointer tracking to prevent loops</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Advance parsing position past corrupted data if possible</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Implement recovery strategies based on error type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - For truncated data: return partial results with appropriate flags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - For compression errors: skip problematic name and continue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - For section errors: process available sections, mark others empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log recovery action for monitoring and debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Record what recovery action was taken and why</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Include enough context for operators to diagnose problems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Track recovery success/failure rates for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Network Error Handler (retry_logic.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> resolver</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RetryConfig controls retry behavior for network operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxAttempts    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InitialDelay   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxDelay       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BackoffFactor  </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RetryableErrors </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkRetryHandler manages retry logic for DNS network operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkRetryHandler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#B392F0\">RetryConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewNetworkRetryHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkRetryHandler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">NetworkRetryHandler</span><span style=\"color:#E1E4E8\">{config: config}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecuteWithRetry performs DNS network operation with intelligent retry logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkRetryHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteWithRetry</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    operation</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize retry state and timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Set up attempt counter starting from 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Calculate initial delay based on config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Prepare context timeout monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute operation with retry loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Call operation function and capture result/error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check if error is retryable using config.RetryableErrors map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If non-retryable, return error immediately without retry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Implement exponential backoff delay</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Calculate next delay = current delay * BackoffFactor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Cap delay at config.MaxDelay to prevent excessive waits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Use time.Sleep or context-aware waiting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check retry limits and context cancellation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Stop retrying if MaxAttempts reached</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check ctx.Done() to respect client timeouts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Log retry attempts for debugging and monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle final failure after all retries exhausted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Wrap error with retry context (attempts, total time)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Return most informative error from retry attempts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Update metrics for retry success/failure rates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsRetryableError determines if an error should trigger retry logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkRetryHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsRetryableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check for network timeout errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Look for context.DeadlineExceeded or net timeout errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - These usually indicate temporary network congestion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for connection refused/unreachable errors  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - ECONNREFUSED might indicate server restart</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - EHOSTUNREACH might be temporary routing issue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for DNS protocol errors that might be temporary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - RCODE_SERVFAIL could indicate temporary server overload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Parse errors might indicate network corruption</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Avoid retrying on permanent failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - RCODE_NXDOMAIN is authoritative negative response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - RCODE_REFUSED indicates policy rejection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Authentication failures should not be retried</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing parse error handling:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test malformed message handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./internal/parser/</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestMalformedMessages</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All malformed message tests pass without panics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Error responses have appropriate RCODE values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: No memory leaks or goroutine leaks during error conditions</span></span></code></pre></div>\n\n<p><strong>After implementing network error handling:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test network failure scenarios</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./internal/resolver/</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestNetworkErrors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Retry logic triggers on appropriate errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Exponential backoff timing is correct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: Context cancellation stops retries promptly</span></span></code></pre></div>\n\n<p><strong>After implementing protocol edge case handling:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test with real-world malformed queries</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 8053</span><span style=\"color:#9ECBFF\"> malformed-compression-test.example.com</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Server responds with FORMERR without crashing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Logs show specific error classification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: Server continues processing subsequent queries normally</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server crashes on malformed queries</td>\n<td>Missing bounds checking in parser</td>\n<td>Enable panic recovery, examine stack trace</td>\n<td>Add buffer length validation before all reads</td>\n</tr>\n<tr>\n<td>Infinite loop during name parsing</td>\n<td>Compression pointer cycle</td>\n<td>Check parse state logs, look for repeated offsets</td>\n<td>Implement visited offset tracking in parseState</td>\n</tr>\n<tr>\n<td>Memory usage grows continuously</td>\n<td>Parse errors not cleaning up resources</td>\n<td>Monitor heap growth, check goroutine count</td>\n<td>Ensure all parse failures call cleanup functions</td>\n</tr>\n<tr>\n<td>Network timeouts not retrying</td>\n<td>Error classification incorrect</td>\n<td>Log error types, check IsRetryableError logic</td>\n<td>Update retryable error detection for specific error types</td>\n</tr>\n<tr>\n<td>Responses have wrong error codes</td>\n<td>Error mapping incomplete</td>\n<td>Compare expected vs actual RCODE values</td>\n<td>Review error type to RCODE mapping in BuildErrorResponse</td>\n</tr>\n<tr>\n<td>Cache corruption after parse errors</td>\n<td>Partial data stored despite errors</td>\n<td>Examine cache contents after error conditions</td>\n<td>Validate data completely before cache storage</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - Testing strategies are essential for verifying correct behavior at each stage of DNS server implementation</p>\n</blockquote>\n<h3 id=\"mental-model-testing-as-safety-nets\">Mental Model: Testing as Safety Nets</h3>\n<p>Think of DNS server testing like building safety nets for acrobats performing increasingly complex routines. Each unit test is like a small safety net positioned under specific moves—if the parser fails to handle name compression correctly, the test catches that specific failure immediately. Integration tests are like larger nets that catch interactions between components—ensuring the resolver and cache work together properly. Milestone checkpoints are like full dress rehearsals where the entire performance is evaluated before moving to more challenging routines.</p>\n<p>Just as acrobats practice individual moves before attempting complex sequences, DNS server development requires testing individual components (parsers, resolvers, cache) before integrating them into a complete system. The safety nets must be positioned at every level—from validating single function behavior to ensuring the entire query processing pipeline works correctly under various network conditions.</p>\n<p>DNS servers operate in an inherently unreliable environment where network failures, malformed packets, and timing issues are common. Without comprehensive testing at each level, subtle bugs can cascade through the system, causing failures that are difficult to diagnose in production. The testing strategy must account for both the deterministic aspects (message parsing, zone data lookup) and the non-deterministic challenges (network timeouts, concurrent queries, cache eviction timing).</p>\n<h3 id=\"unit-testing-approach\">Unit Testing Approach</h3>\n<p>The DNS server&#39;s modular architecture enables focused unit testing where each component can be tested in isolation before integration. This approach builds confidence incrementally—ensuring foundational components like message parsing work correctly before testing higher-level functionality like recursive resolution that depends on those foundations.</p>\n<h4 id=\"message-parsing-test-strategy\">Message Parsing Test Strategy</h4>\n<p>DNS message parsing forms the foundation of all DNS operations, making it critical to test exhaustively. The binary nature of DNS messages means that small errors in byte manipulation can cause complete parsing failures or subtle data corruption that surfaces much later in the processing pipeline.</p>\n<p><strong>Message Parsing Test Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Focus Area</th>\n<th>Test Count</th>\n<th>Critical Edge Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Header Parsing</td>\n<td>12-byte header extraction</td>\n<td>15+ tests</td>\n<td>Bit flag combinations, invalid opcodes</td>\n</tr>\n<tr>\n<td>Name Parsing</td>\n<td>Domain name extraction with compression</td>\n<td>25+ tests</td>\n<td>Compression loops, malformed pointers</td>\n</tr>\n<tr>\n<td>Question Parsing</td>\n<td>Query section extraction</td>\n<td>10+ tests</td>\n<td>Invalid record types, truncated data</td>\n</tr>\n<tr>\n<td>Resource Record Parsing</td>\n<td>Answer/Authority/Additional sections</td>\n<td>30+ tests</td>\n<td>All record types, invalid RDATA</td>\n</tr>\n<tr>\n<td>Message Construction</td>\n<td>Wire format serialization</td>\n<td>20+ tests</td>\n<td>Maximum message size, compression efficiency</td>\n</tr>\n<tr>\n<td>Validation Logic</td>\n<td>Protocol compliance checking</td>\n<td>15+ tests</td>\n<td>Circular dependencies, out-of-bailiwick data</td>\n</tr>\n</tbody></table>\n<p>The message parsing tests must cover both valid protocol usage and malicious or malformed inputs. Real-world DNS traffic includes packets from buggy implementations, network corruption, and potential security attacks. Each test should verify not just that parsing succeeds for valid input, but that it fails gracefully for invalid input without crashing or corrupting internal state.</p>\n<p><strong>Name Compression Testing Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Compression Scenario</th>\n<th>Test Validation</th>\n<th>Potential Failure Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No compression</td>\n<td>Direct label parsing</td>\n<td>Basic functionality</td>\n</tr>\n<tr>\n<td>Simple compression</td>\n<td>Single pointer reference</td>\n<td>Pointer calculation errors</td>\n</tr>\n<tr>\n<td>Nested compression</td>\n<td>Pointers to compressed names</td>\n<td>Chain resolution bugs</td>\n</tr>\n<tr>\n<td>Circular references</td>\n<td>Loop detection triggers</td>\n<td>Infinite loop crashes</td>\n</tr>\n<tr>\n<td>Invalid pointers</td>\n<td>Out-of-bounds references</td>\n<td>Buffer overflow vulnerabilities</td>\n</tr>\n<tr>\n<td>Maximum depth</td>\n<td>Deep compression chains</td>\n<td>Stack overflow in recursion</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Testing Insight:</strong> DNS name compression is where most parsing bugs occur because it requires maintaining state across multiple parsing operations while validating pointer references don&#39;t create infinite loops.</p>\n</blockquote>\n<h4 id=\"authoritative-server-test-strategy\">Authoritative Server Test Strategy</h4>\n<p>The authoritative server component requires testing both the zone data management and the query matching logic. Unlike message parsing which deals with binary protocols, authoritative server testing focuses on business logic correctness and data integrity.</p>\n<p><strong>Zone Data Test Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Focus Area</th>\n<th>Test Count</th>\n<th>Critical Scenarios</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zone File Parsing</td>\n<td>BIND format interpretation</td>\n<td>20+ tests</td>\n<td>All record types, directives, edge cases</td>\n</tr>\n<tr>\n<td>Query Matching</td>\n<td>Record lookup by name/type</td>\n<td>25+ tests</td>\n<td>Exact matches, wildcards, case insensitivity</td>\n</tr>\n<tr>\n<td>Response Construction</td>\n<td>DNS message assembly</td>\n<td>15+ tests</td>\n<td>Authority sections, additional records, glue</td>\n</tr>\n<tr>\n<td>CNAME Handling</td>\n<td>Alias resolution</td>\n<td>10+ tests</td>\n<td>CNAME chains, loops, mixed record types</td>\n</tr>\n<tr>\n<td>Negative Responses</td>\n<td>NXDOMAIN and NODATA</td>\n<td>12+ tests</td>\n<td>SOA records, authority section population</td>\n</tr>\n<tr>\n<td>Zone Updates</td>\n<td>Dynamic record modification</td>\n<td>8+ tests</td>\n<td>Consistency during concurrent access</td>\n</tr>\n</tbody></table>\n<p>The zone data tests must verify that the in-memory representation accurately reflects the zone file contents and that queries return exactly the records specified in the DNS standards. Case sensitivity handling is particularly important since DNS names are case-insensitive but implementations often make mistakes in normalization.</p>\n<p><strong>Query Response Validation Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Query Type</th>\n<th>Expected Response Sections</th>\n<th>Validation Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A record exists</td>\n<td>Answer: A records</td>\n<td>Correct IP addresses returned</td>\n</tr>\n<tr>\n<td>AAAA record exists</td>\n<td>Answer: AAAA records</td>\n<td>IPv6 format validation</td>\n</tr>\n<tr>\n<td>CNAME record</td>\n<td>Answer: CNAME, target records</td>\n<td>Chain resolution completeness</td>\n</tr>\n<tr>\n<td>NS delegation</td>\n<td>Authority: NS records, Additional: glue</td>\n<td>Proper referral construction</td>\n</tr>\n<tr>\n<td>NXDOMAIN</td>\n<td>Authority: SOA record</td>\n<td>Negative cache TTL from SOA minimum</td>\n</tr>\n<tr>\n<td>No record of type</td>\n<td>Authority: SOA record</td>\n<td>NODATA vs NXDOMAIN distinction</td>\n</tr>\n</tbody></table>\n<h4 id=\"recursive-resolver-test-strategy\">Recursive Resolver Test Strategy</h4>\n<p>Testing the recursive resolver requires simulating network interactions and handling the complexity of iterative resolution across multiple servers. This component has the most challenging testing requirements because it involves both deterministic logic (following referrals) and non-deterministic networking (timeouts, server availability).</p>\n<p><strong>Recursive Resolution Test Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Focus Area</th>\n<th>Test Count</th>\n<th>Critical Scenarios</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Iterative Query Logic</td>\n<td>Root to authoritative traversal</td>\n<td>15+ tests</td>\n<td>Normal resolution paths, deep hierarchies</td>\n</tr>\n<tr>\n<td>Network Error Handling</td>\n<td>Timeout and failure recovery</td>\n<td>20+ tests</td>\n<td>Server unavailability, partial responses</td>\n</tr>\n<tr>\n<td>CNAME Following</td>\n<td>Cross-domain alias resolution</td>\n<td>12+ tests</td>\n<td>Multi-hop CNAMEs, circular references</td>\n</tr>\n<tr>\n<td>Security Validation</td>\n<td>Response verification</td>\n<td>18+ tests</td>\n<td>Cache poisoning prevention, bailiwick checking</td>\n</tr>\n<tr>\n<td>Concurrent Resolution</td>\n<td>Multiple simultaneous queries</td>\n<td>10+ tests</td>\n<td>Race conditions, resource sharing</td>\n</tr>\n<tr>\n<td>Loop Detection</td>\n<td>Infinite referral prevention</td>\n<td>8+ tests</td>\n<td>Circular NS dependencies, malicious responses</td>\n</tr>\n</tbody></table>\n<p>The recursive resolver tests require mock network infrastructure to simulate different server behaviors without depending on external DNS infrastructure. This enables testing error conditions like server timeouts and malformed responses that would be difficult to reproduce reliably with real DNS servers.</p>\n<p><strong>Mock Server Response Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Mock Scenario</th>\n<th>Server Behavior</th>\n<th>Test Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal Resolution</td>\n<td>Root → TLD → Auth chain</td>\n<td>Complete answer returned</td>\n</tr>\n<tr>\n<td>Server Timeout</td>\n<td>No response from TLD</td>\n<td>Fallback to next TLD server</td>\n</tr>\n<tr>\n<td>Malformed Response</td>\n<td>Invalid message format</td>\n<td>Error handling without crash</td>\n</tr>\n<tr>\n<td>NXDOMAIN Response</td>\n<td>Authoritative negative answer</td>\n<td>Proper negative caching</td>\n</tr>\n<tr>\n<td>Referral Loop</td>\n<td>Circular NS references</td>\n<td>Loop detection triggers</td>\n</tr>\n<tr>\n<td>Cache Poisoning Attempt</td>\n<td>Out-of-bailiwick records</td>\n<td>Malicious data rejected</td>\n</tr>\n</tbody></table>\n<h4 id=\"cache-manager-test-strategy\">Cache Manager Test Strategy</h4>\n<p>The cache manager requires testing both the correctness of TTL-based expiration and the performance characteristics under concurrent access. Cache bugs can be particularly subtle because they often manifest as incorrect data being returned minutes or hours after the initial caching operation.</p>\n<p><strong>Cache Management Test Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Focus Area</th>\n<th>Test Count</th>\n<th>Critical Scenarios</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TTL Expiration</td>\n<td>Time-based entry eviction</td>\n<td>15+ tests</td>\n<td>Various TTL values, clock manipulation</td>\n</tr>\n<tr>\n<td>Negative Caching</td>\n<td>NXDOMAIN/NODATA storage</td>\n<td>10+ tests</td>\n<td>SOA-derived TTLs, proper invalidation</td>\n</tr>\n<tr>\n<td>Concurrent Access</td>\n<td>Thread safety validation</td>\n<td>20+ tests</td>\n<td>Read-write conflicts, atomic operations</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Entry size limits and eviction</td>\n<td>12+ tests</td>\n<td>LRU policies, memory pressure handling</td>\n</tr>\n<tr>\n<td>Cache Invalidation</td>\n<td>Entry removal and updates</td>\n<td>8+ tests</td>\n<td>Zone changes, administrative purging</td>\n</tr>\n<tr>\n<td>Statistics Tracking</td>\n<td>Hit rates and performance metrics</td>\n<td>6+ tests</td>\n<td>Counter accuracy, thread-safe updates</td>\n</tr>\n</tbody></table>\n<p>Cache testing requires careful control of time to verify TTL expiration behavior. Mock clocks or time manipulation techniques enable testing cache expiration without waiting for real time to pass. This is essential for validating that entries expire at exactly the right moment and that expired entries are properly cleaned up.</p>\n<p><strong>Cache Concurrency Test Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Concurrency Scenario</th>\n<th>Thread Pattern</th>\n<th>Validation Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multiple Readers</td>\n<td>Concurrent cache lookups</td>\n<td>No data corruption</td>\n</tr>\n<tr>\n<td>Reader-Writer Conflict</td>\n<td>Lookup during cache update</td>\n<td>Consistent view returned</td>\n</tr>\n<tr>\n<td>Multiple Writers</td>\n<td>Concurrent cache insertions</td>\n<td>Proper serialization</td>\n</tr>\n<tr>\n<td>Cleanup During Access</td>\n<td>Background eviction + lookup</td>\n<td>No use-after-free bugs</td>\n</tr>\n<tr>\n<td>Statistics Updates</td>\n<td>Concurrent counter increments</td>\n<td>Accurate final counts</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-testing-pitfalls\">Common Testing Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Testing Only Happy Path Scenarios</strong></p>\n<p>Many developers focus exclusively on testing correct DNS protocol usage without validating error handling and edge cases. DNS servers must handle malformed packets, network failures, and potentially malicious traffic robustly. A parser that works perfectly with valid messages but crashes on malformed input will fail quickly in production.</p>\n<p>The fix requires systematic error injection testing. For every parsing function, create tests with truncated data, invalid field values, and out-of-bounds references. For every network operation, test timeout scenarios and connection failures. This defensive testing approach builds resilience into the DNS server.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Timing Dependencies in Cache Tests</strong></p>\n<p>Cache behavior is inherently time-dependent, but many tests fail to properly control time progression. Tests that rely on <code>time.Sleep()</code> to wait for TTL expiration are fragile and slow. They may pass during development but fail in CI environments with different timing characteristics.</p>\n<p>The solution involves injectable time sources or mock clock implementations. Instead of waiting for real time, tests can advance a mock clock to trigger TTL expiration immediately. This makes tests both faster and more reliable while ensuring TTL logic is properly validated.</p>\n<p>⚠️ <strong>Pitfall: Testing Components in Complete Isolation</strong></p>\n<p>While unit testing individual components is valuable, DNS server components have important integration points that pure isolation testing misses. For example, testing the cache manager separately from the resolver doesn&#39;t validate that TTL values are properly propagated or that negative caching interacts correctly with recursive resolution.</p>\n<p>Integration tests that combine 2-3 components help catch interface mismatches and data flow problems. These tests should focus on the boundaries between components—ensuring data passes correctly from parser to resolver to cache and back.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Concurrent Testing</strong></p>\n<p>DNS servers handle multiple simultaneous queries, but many test suites only validate single-threaded behavior. Race conditions and deadlocks may not surface until the server experiences production load levels. These bugs are particularly dangerous because they can cause complete server hangs.</p>\n<p>Concurrent testing requires spawning multiple goroutines that exercise the same code paths simultaneously. Tools like Go&#39;s race detector can help identify data races, but tests must also verify logical correctness under concurrent access—ensuring cache updates don&#39;t interfere with ongoing lookups.</p>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone represents a significant functional increment in DNS server capability. The checkpoint system provides concrete verification steps that confirm implementation correctness before proceeding to more complex features that depend on earlier milestones.</p>\n<h4 id=\"milestone-1-dns-message-parsing-checkpoint\">Milestone 1: DNS Message Parsing Checkpoint</h4>\n<p>The first milestone establishes the foundation for all DNS operations by implementing robust message parsing and construction. Success at this checkpoint means the server can correctly interpret binary DNS messages and construct valid responses.</p>\n<p><strong>Parsing Verification Steps:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Verification Step</th>\n<th>Test Command</th>\n<th>Expected Outcome</th>\n<th>Failure Indicators</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic Header Parsing</td>\n<td><code>go test -v ./internal/parser/</code></td>\n<td>All header tests pass</td>\n<td>Flag bit extraction errors</td>\n</tr>\n<tr>\n<td>Name Compression</td>\n<td><code>dig @localhost test.example.com</code></td>\n<td>Compressed names decoded</td>\n<td>Truncated domain names</td>\n</tr>\n<tr>\n<td>Record Type Support</td>\n<td>Test suite with A/AAAA/CNAME/MX/NS records</td>\n<td>All record types parsed</td>\n<td>Unknown record type errors</td>\n</tr>\n<tr>\n<td>Message Construction</td>\n<td>Round-trip parse + serialize test</td>\n<td>Identical binary output</td>\n<td>Byte order or length errors</td>\n</tr>\n<tr>\n<td>Malformed Input Handling</td>\n<td>Fuzzing with invalid packets</td>\n<td>Graceful error returns</td>\n<td>Crashes or infinite loops</td>\n</tr>\n<tr>\n<td>Performance Validation</td>\n<td>Parse 1000 messages/second</td>\n<td>Sub-millisecond average latency</td>\n<td>Memory leaks or excessive allocation</td>\n</tr>\n</tbody></table>\n<p>The parsing checkpoint requires both automated testing and manual verification using standard DNS tools. Running <code>dig</code> against the developing server helps identify integration issues that pure unit tests might miss.</p>\n<p><strong>Manual Testing Protocol:</strong></p>\n<ol>\n<li>Start the DNS server in a test mode that only echoes parsed message contents</li>\n<li>Send queries using <code>dig</code> with various record types: <code>dig @127.0.0.1 -p 5353 example.com A</code></li>\n<li>Verify the server correctly logs all fields from the incoming query message</li>\n<li>Send malformed packets using <code>nc</code> or custom test tools</li>\n<li>Confirm the server handles errors gracefully without crashing</li>\n<li>Monitor memory usage during sustained query load to detect parsing leaks</li>\n</ol>\n<h4 id=\"milestone-2-authoritative-server-checkpoint\">Milestone 2: Authoritative Server Checkpoint</h4>\n<p>The authoritative server milestone adds zone data management and query response capabilities. This checkpoint validates that the server can act as an authoritative nameserver for configured domains.</p>\n<p><strong>Authority Verification Steps:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Verification Step</th>\n<th>Test Command</th>\n<th>Expected Outcome</th>\n<th>Failure Indicators</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zone File Loading</td>\n<td><code>go test -v ./internal/authority/</code></td>\n<td>Zone data populated correctly</td>\n<td>Parse errors or missing records</td>\n</tr>\n<tr>\n<td>A Record Queries</td>\n<td><code>dig @localhost example.com A</code></td>\n<td>Correct IP addresses returned</td>\n<td>Wrong IPs or SERVFAIL responses</td>\n</tr>\n<tr>\n<td>NS Delegation</td>\n<td><code>dig @localhost subdomain.example.com NS</code></td>\n<td>Proper referral with glue records</td>\n<td>Missing authority sections</td>\n</tr>\n<tr>\n<td>NXDOMAIN Handling</td>\n<td><code>dig @localhost nonexistent.example.com A</code></td>\n<td>NXDOMAIN with SOA record</td>\n<td>Wrong response code</td>\n</tr>\n<tr>\n<td>CNAME Resolution</td>\n<td><code>dig @localhost alias.example.com A</code></td>\n<td>Target record returned</td>\n<td>Incomplete CNAME following</td>\n</tr>\n<tr>\n<td>Zone Reload</td>\n<td>Update zone file and send SIGHUP</td>\n<td>New records served</td>\n<td>Stale data or reload failures</td>\n</tr>\n</tbody></table>\n<p><strong>Zone File Test Configuration:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>$ORIGIN example.com.\n$TTL 3600\n\n@       IN  SOA ns1.example.com. admin.example.com. (\n            2023010101 ; serial\n            3600       ; refresh\n            1800       ; retry\n            604800     ; expire\n            86400      ; minimum\n        )\n\n        IN  NS  ns1.example.com.\n        IN  NS  ns2.example.com.\n\nns1     IN  A   192.0.2.1\nns2     IN  A   192.0.2.2\nwww     IN  A   192.0.2.10\nmail    IN  A   192.0.2.20\nalias   IN  CNAME www.example.com.\n\nsubdomain IN NS ns1.subdomain.example.com.\nns1.subdomain IN A 192.0.2.30</code></pre></div>\n\n<p>This test zone file provides comprehensive coverage of DNS record types and delegation scenarios needed to validate authoritative server functionality.</p>\n<h4 id=\"milestone-3-recursive-resolver-checkpoint\">Milestone 3: Recursive Resolver Checkpoint</h4>\n<p>The recursive resolver milestone implements the complex iterative resolution process that follows referrals from root servers to authoritative servers. This checkpoint confirms the server can resolve arbitrary domain names.</p>\n<p><strong>Recursion Verification Steps:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Verification Step</th>\n<th>Test Command</th>\n<th>Expected Outcome</th>\n<th>Failure Indicators</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Root Server Bootstrap</td>\n<td>Monitor initial root queries</td>\n<td>Successful root server contact</td>\n<td>Network timeouts or resolution failures</td>\n</tr>\n<tr>\n<td>Iterative Resolution</td>\n<td><code>dig @localhost google.com A</code></td>\n<td>External domain resolved</td>\n<td>SERVFAIL or timeout responses</td>\n</tr>\n<tr>\n<td>CNAME Following</td>\n<td><code>dig @localhost www.github.com A</code></td>\n<td>Final A record returned</td>\n<td>Incomplete alias resolution</td>\n</tr>\n<tr>\n<td>NS Referral Handling</td>\n<td>Trace resolution of deep subdomain</td>\n<td>Proper referral following</td>\n<td>Stuck in referral loops</td>\n</tr>\n<tr>\n<td>Timeout Recovery</td>\n<td>Block authoritative server</td>\n<td>Fallback to alternate servers</td>\n<td>Complete resolution failures</td>\n</tr>\n<tr>\n<td>Concurrent Queries</td>\n<td>Multiple simultaneous resolutions</td>\n<td>All queries complete successfully</td>\n<td>Deadlocks or resource conflicts</td>\n</tr>\n</tbody></table>\n<p><strong>Resolution Tracing Example:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Enable query tracing to validate iterative resolution</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#9ECBFF\"> +trace</span><span style=\"color:#9ECBFF\"> example.org</span><span style=\"color:#9ECBFF\"> A</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output shows:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. Query to root server (.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Referral to .org TLD servers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Query to .org server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. Referral to example.org authoritative servers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 5. Query to authoritative server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 6. Final answer returned</span></span></code></pre></div>\n\n<p>The trace output allows manual verification that the recursive resolver follows the correct DNS hierarchy path and doesn&#39;t skip levels or create loops.</p>\n<h4 id=\"milestone-4-caching-and-performance-checkpoint\">Milestone 4: Caching and Performance Checkpoint</h4>\n<p>The caching milestone adds TTL-based response caching and optimizes performance for high query loads. This checkpoint validates both correctness of cache behavior and performance under concurrent load.</p>\n<p><strong>Cache Verification Steps:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Verification Step</th>\n<th>Test Command</th>\n<th>Expected Outcome</th>\n<th>Failure Indicators</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache Population</td>\n<td>Resolve domain, check cache stats</td>\n<td>Cache hit count increases</td>\n<td>Cache misses on repeated queries</td>\n</tr>\n<tr>\n<td>TTL Expiration</td>\n<td>Wait for TTL + 1 second, re-query</td>\n<td>Fresh resolution performed</td>\n<td>Stale data returned</td>\n</tr>\n<tr>\n<td>Negative Caching</td>\n<td>Query non-existent domain twice</td>\n<td>Second query cached</td>\n<td>Repeated resolution attempts</td>\n</tr>\n<tr>\n<td>Cache Statistics</td>\n<td><code>/stats</code> endpoint or admin command</td>\n<td>Accurate hit/miss ratios</td>\n<td>Counter inconsistencies</td>\n</tr>\n<tr>\n<td>Performance Load</td>\n<td>1000 concurrent queries</td>\n<td>Sub-10ms average response</td>\n<td>High latency or timeouts</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Sustained high query rate</td>\n<td>Stable memory usage</td>\n<td>Unbounded memory growth</td>\n</tr>\n</tbody></table>\n<p><strong>Performance Benchmarking Script:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Generate concurrent load to validate caching performance</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Starting DNS performance test...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">start_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Launch 100 concurrent query batches</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..100}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> domain </span><span style=\"color:#F97583\">in</span><span style=\"color:#9ECBFF\"> google.com</span><span style=\"color:#9ECBFF\"> facebook.com</span><span style=\"color:#9ECBFF\"> github.com</span><span style=\"color:#9ECBFF\"> stackoverflow.com</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#E1E4E8\"> $domain </span><span style=\"color:#9ECBFF\">A</span><span style=\"color:#9ECBFF\"> +short</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\">/dev/null</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#6A737D\">  # Wait for all background jobs to complete</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">end_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">duration</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">end_time</span><span style=\"color:#9ECBFF\"> -</span><span style=\"color:#9ECBFF\"> start_time</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Completed 400 queries in ${</span><span style=\"color:#E1E4E8\">duration</span><span style=\"color:#9ECBFF\">} seconds\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check cache statistics</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> localhost:8080/stats</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> '.cache.hit_rate'</span></span></code></pre></div>\n\n<p>This performance test validates both the caching effectiveness and the server&#39;s ability to handle concurrent query load without performance degradation.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td>Go standard <code>testing</code> package</td>\n<td>Testify with assertions and mocks</td>\n</tr>\n<tr>\n<td>Mock Networks</td>\n<td>Custom UDP listener simulation</td>\n<td>Gomock generated mocks</td>\n</tr>\n<tr>\n<td>Time Control</td>\n<td>Manual time injection</td>\n<td>Clockwork time mocking library</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td>Simple bash scripts with <code>dig</code></td>\n<td>Custom Go benchmark harness</td>\n</tr>\n<tr>\n<td>Coverage Analysis</td>\n<td><code>go test -cover</code></td>\n<td>Codecov integration with CI</td>\n</tr>\n</tbody></table>\n<h4 id=\"test-file-structure\">Test File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>dns-server/\n  internal/\n    parser/\n      parser.go\n      parser_test.go          ← Unit tests for message parsing\n      testdata/               ← Binary DNS message test files\n        valid_query.bin\n        compressed_names.bin\n        malformed_header.bin\n    authority/\n      authority.go\n      authority_test.go       ← Unit tests for authoritative server\n      testdata/               ← Zone file test cases\n        example.com.zone\n        delegated.zone\n    resolver/\n      resolver.go\n      resolver_test.go        ← Unit tests for recursive resolution\n      mock_client.go          ← Mock network client for testing\n    cache/\n      cache.go\n      cache_test.go           ← Unit tests for caching logic\n  test/\n    integration/              ← Integration tests\n      query_processing_test.go\n      concurrent_queries_test.go\n    fixtures/                 ← Shared test data\n      root_hints.txt\n      test_zones/\n    benchmarks/               ← Performance tests\n      resolution_bench_test.go\n      cache_performance_test.go</code></pre></div>\n\n<h4 id=\"mock-network-client-infrastructure\">Mock Network Client Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// MockNetworkClient simulates DNS server responses for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MockNetworkClient</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    responses </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // Query pattern to response mapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    delays    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    errors    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMockNetworkClient</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockNetworkClient</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MockNetworkClient</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        responses: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        delays:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errors:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddResponse configures mock to return specific response for query pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockNetworkClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pattern</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">response</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.responses[pattern] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddDelay simulates network latency for specific servers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockNetworkClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddDelay</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">serverIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">delay</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.delays[serverIP] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> delay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddError simulates network failures for testing error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockNetworkClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">serverIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.errors[serverIP] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// QueryServer simulates DNS query with configured responses/errors/delays</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockNetworkClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">QueryServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">query</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">serverIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check for configured error for this server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Apply configured delay with time.Sleep()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Find matching response pattern and return configured response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return network timeout error if no response configured</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"test-data-generation-utilities\">Test Data Generation Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TestMessageBuilder helps construct DNS messages for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TestMessageBuilder</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    msg </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTestMessage</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestMessageBuilder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TestMessageBuilder</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        msg: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Header: </span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                ID: </span><span style=\"color:#79B8FF\">12345</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                QueryResponse: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                RecursionDesired: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddQuestion adds question to test message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestMessageBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddQuestion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">qtype</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestMessageBuilder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Append Question{Name: name, Type: qtype, Class: 1} to msg.Questions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update Header.QuestionCount</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> b</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddAnswer adds resource record to answer section</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestMessageBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddAnswer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rtype</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestMessageBuilder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Append ResourceRecord to msg.Answers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update Header.AnswerCount</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> b</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Build returns constructed DNS message ready for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestMessageBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Build</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> b.msg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ToWireFormat serializes test message to binary format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestMessageBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ToWireFormat</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeMessage</span><span style=\"color:#E1E4E8\">(b.msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"parser-testing-skeleton\">Parser Testing Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestParseHeader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data     []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#B392F0\">Header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wantErr  </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            name: </span><span style=\"color:#9ECBFF\">\"valid header with all flags set\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            data: []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">34</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">81</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                ID: </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">1234</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                QueryResponse: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Authoritative: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Fill in all expected header fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            wantErr: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Add test cases for:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Header with no flags set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Invalid opcode values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Maximum section counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Truncated header (less than 12 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, tt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tests {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(tt.name, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseHeader</span><span style=\"color:#E1E4E8\">(tt.data)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify error handling matches wantErr</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Compare all header fields with expected values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Use reflect.DeepEqual or manual field comparison</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestNameCompression</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create test message with compressed names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify parser correctly follows compression pointers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test compression loop detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test invalid pointer references (out of bounds)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test maximum compression depth limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"cache-testing-skeleton\">Cache Testing Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCacheExpiration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create mock clock for controlling time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mockClock </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MockClock</span><span style=\"color:#E1E4E8\">{current: time.</span><span style=\"color:#B392F0\">Unix</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewCacheManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">, time.Minute)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache.</span><span style=\"color:#B392F0\">SetClock</span><span style=\"color:#E1E4E8\">(mockClock)  </span><span style=\"color:#6A737D\">// Inject mock clock</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Store entry with 30-second TTL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Advance mock clock by 29 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify entry still exists and is returned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Advance mock clock by 2 more seconds (total 31)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify entry is expired and not returned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify cleanup removes expired entry from memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestConcurrentCacheAccess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewCacheManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">, time.Minute)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> wg </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">WaitGroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Launch concurrent readers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wg.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            defer</span><span style=\"color:#E1E4E8\"> wg.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Perform 100 cache lookups for various keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify no panics or data corruption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Track hit/miss ratios</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Launch concurrent writers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wg.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            defer</span><span style=\"color:#E1E4E8\"> wg.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Insert 50 cache entries with various TTLs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Update existing entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify thread-safe insertion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wg.</span><span style=\"color:#B392F0\">Wait</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify cache statistics are consistent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify no memory leaks occurred</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify cache size limits were respected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"integration-test-framework\">Integration Test Framework</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestEndToEndQueryProcessing</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Setup test DNS server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Server: </span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#E1E4E8\">{ListenAddr: </span><span style=\"color:#9ECBFF\">\"127.0.0.1:0\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Cache: </span><span style=\"color:#B392F0\">CacheConfig</span><span style=\"color:#E1E4E8\">{MaxSize: </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, DefaultTTL: </span><span style=\"color:#9ECBFF\">\"5m\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewTestServer</span><span style=\"color:#E1E4E8\">(config)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> server.</span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure mock upstream servers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mockRoot </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDNSServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"192.0.2.1:53\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mockTLD </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDNSServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"192.0.2.2:53\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mockAuth </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDNSServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"192.0.2.3:53\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Configure mock responses for root → TLD → authoritative chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Start test server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send DNS query using real UDP socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify correct response received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify cache populated with results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send identical query and verify cache hit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestRecursiveResolutionWithFailures</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Configure some upstream servers to timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Configure some servers to return SERVFAIL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify resolver retries with different servers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify eventual successful resolution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify appropriate error handling when all servers fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-automation\">Milestone Checkpoint Automation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// MilestoneChecker provides automated verification for each milestone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MilestoneChecker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serverAddr </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">dns</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#6A737D\">  // Third-party DNS client library</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MilestoneChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckMilestone1</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send various DNS queries to test parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify server doesn't crash on malformed input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check response message format correctness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate name compression handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MilestoneChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckMilestone2</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Query for A records in configured zone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Query for non-existent domains (expect NXDOMAIN)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Query for delegated subdomains (expect NS referral)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify SOA records in authority section</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MilestoneChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckMilestone3</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Query for external domains not in local zones</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify iterative resolution from root servers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test CNAME following across different domains</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify proper error handling for resolution failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MilestoneChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckMilestone4</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Measure query performance before and after caching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify cache hit rate improves with repeated queries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test TTL expiration behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify concurrent query handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - Debugging skills are essential throughout DNS message parsing, authoritative responses, recursive resolution, and caching operations</p>\n</blockquote>\n<h3 id=\"mental-model-dns-debugging-as-medical-diagnosis\">Mental Model: DNS Debugging as Medical Diagnosis</h3>\n<p>Think of debugging a DNS server like diagnosing a patient in a hospital. Just as a doctor follows a systematic approach—observing symptoms, running diagnostic tests, forming hypotheses, and applying treatments—DNS debugging requires methodical investigation of symptoms using specialized tools to identify root causes and apply targeted fixes.</p>\n<p>Like medical diagnosis, DNS debugging benefits from pattern recognition. Experienced DNS engineers recognize common symptom patterns just as doctors recognize disease presentations. A query timeout combined with specific log patterns suggests network connectivity issues, while parsing failures with certain byte sequences indicate compression loop problems. Building this diagnostic intuition requires understanding both the common failure modes and the tools available to investigate them.</p>\n<p>The DNS protocol&#39;s layered nature—from binary message parsing through recursive resolution to caching—means that symptoms at one layer often originate from problems at another layer. A &quot;server failure&quot; response might stem from a parsing error, a network timeout, or cache corruption. Effective debugging requires tracing symptoms through these layers to identify the true root cause.</p>\n<h3 id=\"common-bug-patterns\">Common Bug Patterns</h3>\n<p>DNS server implementations exhibit predictable failure patterns that map to specific implementation mistakes. Understanding these patterns enables rapid diagnosis and targeted fixes rather than lengthy debugging sessions.</p>\n<h4 id=\"parsing-and-message-construction-bugs\">Parsing and Message Construction Bugs</h4>\n<p><strong>Binary Protocol Parsing Errors</strong> represent the most common category of DNS server bugs, stemming from the complexity of handling variable-length binary data with compression and strict formatting requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Compression Loop</td>\n<td>Server crashes with stack overflow or hangs indefinitely</td>\n<td>Circular references in DNS pointer labels create infinite loops</td>\n<td>Check parse state for repeated offsets, trace compression jumps</td>\n<td>Implement jump counting and visited offset tracking in <code>parseName</code></td>\n</tr>\n<tr>\n<td>Endianness Error</td>\n<td>All numeric values appear incorrect, query IDs don&#39;t match responses</td>\n<td>Using little-endian instead of network byte order</td>\n<td>Compare raw bytes with expected values, check if values are byte-swapped</td>\n<td>Use <code>binary.BigEndian</code> consistently in <code>readUint16</code> and <code>readUint32</code></td>\n</tr>\n<tr>\n<td>Buffer Overflow</td>\n<td>Parsing crashes with slice bounds errors</td>\n<td>Reading beyond available data without bounds checking</td>\n<td>Log buffer length and current offset before each read operation</td>\n<td>Implement <code>canRead</code> validation before all buffer access</td>\n</tr>\n<tr>\n<td>Name Truncation</td>\n<td>Domain names missing characters or appearing corrupted</td>\n<td>Improper null termination or length calculation in name parsing</td>\n<td>Compare parsed names with expected values, check label length encoding</td>\n<td>Ensure proper string building and null byte handling in <code>parseName</code></td>\n</tr>\n<tr>\n<td>Resource Record Corruption</td>\n<td>RDATA appears scrambled or causes parsing failures</td>\n<td>Incorrect RDLENGTH calculation or improper data type handling</td>\n<td>Hexdump raw RDATA bytes and compare with expected format</td>\n<td>Validate RDLENGTH matches actual data consumption</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Compression Pointer Validation</strong>\nMany implementations fail to detect malicious or malformed compression pointers that could cause crashes or infinite loops. The DNS message format allows compression pointers to reference any previous location in the message, but implementations must guard against circular references where pointer A points to pointer B which points back to A. This creates an infinite loop during name parsing that can crash the server or consume excessive CPU resources.</p>\n<p>The fix requires maintaining a <code>visited</code> map in the <code>parseState</code> structure that tracks which message offsets have been encountered during name parsing. Before following any compression pointer, check if the target offset exists in the visited map. Additionally, implement a maximum jump count (typically 16) to prevent excessively long compression chains even without circular references.</p>\n<h4 id=\"recursive-resolution-logic-bugs\">Recursive Resolution Logic Bugs</h4>\n<p><strong>Resolution State Management Errors</strong> occur when the complex state tracking required for iterative DNS resolution becomes inconsistent or corrupted during the resolution process.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Infinite Referral Loops</td>\n<td>Queries never complete, excessive network traffic</td>\n<td>Following NS referrals that point back to previously visited servers</td>\n<td>Log all visited servers in <code>ResolutionState</code>, check for cycles</td>\n<td>Maintain <code>visitedServers</code> map and detect cycles before queries</td>\n</tr>\n<tr>\n<td>CNAME Chain Explosion</td>\n<td>Resolution takes excessive time, network amplification</td>\n<td>Following CNAME records without limiting chain depth</td>\n<td>Count CNAME hops during resolution, trace chain path</td>\n<td>Implement maximum CNAME chain length (typically 16)</td>\n</tr>\n<tr>\n<td>Glue Record Blindness</td>\n<td>Resolution fails for domains that should work</td>\n<td>Ignoring A records in additional section when NS targets are in-bailiwick</td>\n<td>Check if glue records are being extracted and used</td>\n<td>Parse additional section for A/AAAA records matching NS targets</td>\n</tr>\n<tr>\n<td>Root Server Exhaustion</td>\n<td>All queries fail after initial period</td>\n<td>Cycling through root servers without reset mechanism</td>\n<td>Monitor root server rotation and success/failure patterns</td>\n<td>Implement root server health tracking and recovery</td>\n</tr>\n<tr>\n<td>Authority Validation Bypass</td>\n<td>Cache poisoning or incorrect responses accepted</td>\n<td>Accepting out-of-bailiwick records without validation</td>\n<td>Log response validation decisions for each received record</td>\n<td>Implement strict bailiwick checking in <code>validateResponse</code></td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Resolution State Corruption</strong>\nThe <code>ResolutionState</code> structure maintains critical state during iterative resolution, including the current question, visited servers, and CNAME chain. If this state becomes corrupted—for example, if the current question is modified incorrectly during CNAME following—subsequent resolution steps operate on invalid data, leading to incorrect queries or resolution failures.</p>\n<p>This commonly occurs when implementations modify the original question directly instead of creating new question instances for each resolution step. The fix requires treating the <code>originalQuestion</code> as immutable and creating new <code>currentQuestion</code> instances when following CNAMEs or referrals.</p>\n<h4 id=\"caching-and-concurrency-bugs\">Caching and Concurrency Bugs</h4>\n<p><strong>Cache Consistency Errors</strong> arise from improper synchronization in concurrent environments or incorrect TTL handling that leads to stale or corrupted cache data.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Race Condition Corruption</td>\n<td>Cache returns inconsistent data, occasional panics</td>\n<td>Multiple goroutines modifying cache without proper locking</td>\n<td>Run with race detector, log all cache operations with goroutine IDs</td>\n<td>Use <code>sync.RWMutex</code> consistently, minimize critical sections</td>\n</tr>\n<tr>\n<td>TTL Underflow</td>\n<td>Cache entries never expire or expire immediately</td>\n<td>Incorrect TTL arithmetic causing wraparound</td>\n<td>Monitor TTL values and expiration timestamps in cache</td>\n<td>Use proper time arithmetic with <code>time.Time</code> and <code>time.Duration</code></td>\n</tr>\n<tr>\n<td>Memory Leak Growth</td>\n<td>Memory usage grows continuously without bounds</td>\n<td>Cache entries not being evicted despite expiration</td>\n<td>Profile memory usage, check cleanup goroutine activity</td>\n<td>Implement periodic cleanup and LRU eviction in <code>backgroundCleanup</code></td>\n</tr>\n<tr>\n<td>Thundering Herd</td>\n<td>Massive duplicate queries during cache misses</td>\n<td>Multiple concurrent queries for same record causing resolution storms</td>\n<td>Monitor query coalescing effectiveness and duplicate resolution</td>\n<td>Implement query coalescing with <code>QueryCoalescer</code></td>\n</tr>\n<tr>\n<td>Negative Cache Pollution</td>\n<td>Legitimate queries return NXDOMAIN incorrectly</td>\n<td>Negative cache entries with incorrect keys or excessive TTL</td>\n<td>Check negative cache entries and their expiration times</td>\n<td>Validate negative cache keys and use SOA minimum for TTL</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Cache Key Collisions</strong>\nThe <code>CacheKey</code> structure uses domain name, type, and class to uniquely identify cached records. However, DNS name comparison is case-insensitive, meaning &quot;Example.com&quot; and &quot;EXAMPLE.COM&quot; represent the same domain. If cache key construction doesn&#39;t normalize domain names to a consistent case, the cache may treat these as different entries, reducing cache hit rates and potentially causing consistency issues.</p>\n<p>The fix requires implementing <code>canonicalizeName</code> to convert all domain names to lowercase with trailing dots before constructing cache keys. This ensures consistent cache behavior regardless of the case used in incoming queries.</p>\n<h4 id=\"network-and-protocol-handling-bugs\">Network and Protocol Handling Bugs</h4>\n<p><strong>Network Communication Errors</strong> stem from improper handling of UDP communication characteristics, timeout management, or protocol violation scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UDP Packet Truncation</td>\n<td>Large responses appear incomplete</td>\n<td>Sending responses larger than UDP maximum without truncation bit</td>\n<td>Check response sizes and truncation bit setting</td>\n<td>Implement proper truncation handling in <code>SerializeMessage</code></td>\n</tr>\n<tr>\n<td>Socket Resource Exhaustion</td>\n<td>Server stops responding, connection errors</td>\n<td>Creating new sockets without proper cleanup</td>\n<td>Monitor file descriptor usage and socket lifecycle</td>\n<td>Reuse UDP connections, implement proper resource management</td>\n</tr>\n<tr>\n<td>Timeout Cascade Failures</td>\n<td>All queries start failing simultaneously</td>\n<td>Short timeouts causing cascading failures during high load</td>\n<td>Analyze timeout patterns and success/failure correlation</td>\n<td>Implement adaptive timeouts and circuit breaker patterns</td>\n</tr>\n<tr>\n<td>Response ID Mismatch</td>\n<td>Clients reject responses as invalid</td>\n<td>Reusing query IDs or incorrect ID assignment</td>\n<td>Compare query and response IDs in network traces</td>\n<td>Generate unique IDs per query and validate responses</td>\n</tr>\n<tr>\n<td>Protocol Violation Handling</td>\n<td>Server crashes on malformed queries</td>\n<td>Insufficient validation of incoming message format</td>\n<td>Test with malformed queries, check validation paths</td>\n<td>Implement comprehensive message validation in <code>ValidateMessage</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"zone-data-and-configuration-bugs\">Zone Data and Configuration Bugs</h4>\n<p><strong>Authoritative Data Errors</strong> result from incorrect zone file parsing, improper record handling, or configuration inconsistencies that affect authoritative responses.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zone File Parse Failures</td>\n<td>Server starts but returns SERVFAIL for authoritative domains</td>\n<td>Syntax errors or unsupported directives in zone files</td>\n<td>Parse zone files manually, check parser error logs</td>\n<td>Implement robust zone file parsing with error reporting</td>\n</tr>\n<tr>\n<td>SOA Record Mishandling</td>\n<td>Authority section missing or incorrect for negative responses</td>\n<td>Improper SOA record construction or missing authority population</td>\n<td>Check authority section in NXDOMAIN responses</td>\n<td>Ensure SOA records are included in authority section</td>\n</tr>\n<tr>\n<td>Case Sensitivity Bugs</td>\n<td>Queries fail intermittently based on case</td>\n<td>Domain name comparison not following DNS case insensitivity rules</td>\n<td>Test queries with mixed case domain names</td>\n<td>Implement case-insensitive domain name comparison</td>\n</tr>\n<tr>\n<td>Wildcard Record Confusion</td>\n<td>Wildcard records match incorrectly or don&#39;t match when they should</td>\n<td>Complex wildcard matching logic with edge cases</td>\n<td>Test various wildcard scenarios and matching patterns</td>\n<td>Implement RFC-compliant wildcard matching</td>\n</tr>\n<tr>\n<td>Glue Record Generation</td>\n<td>Delegation responses missing required glue records</td>\n<td>Failing to include A/AAAA records for in-bailiwick NS targets</td>\n<td>Check additional section of delegation responses</td>\n<td>Generate glue records for NS targets within zone</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-tools-and-techniques\">Debugging Tools and Techniques</h3>\n<p>Effective DNS debugging requires a combination of specialized DNS tools, network analysis capabilities, and systematic logging strategies. Understanding when and how to use each tool accelerates problem diagnosis and resolution.</p>\n<h4 id=\"command-line-dns-tools\">Command-Line DNS Tools</h4>\n<p>The <code>dig</code> command serves as the primary DNS debugging tool, providing detailed query and response information with extensive formatting options for different diagnostic scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Tool Usage</th>\n<th>Purpose</th>\n<th>Key Options</th>\n<th>Example Output Analysis</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dig @server domain A</code></td>\n<td>Basic query testing</td>\n<td><code>+short</code>, <code>+noall +answer</code></td>\n<td>Verify basic resolution functionality</td>\n</tr>\n<tr>\n<td><code>dig @server domain A +trace</code></td>\n<td>Full resolution path</td>\n<td><code>+dnssec</code>, <code>+additional</code></td>\n<td>Trace iterative resolution steps</td>\n</tr>\n<tr>\n<td><code>dig @server domain A +bufsize=4096</code></td>\n<td>Large response handling</td>\n<td><code>+edns=0</code>, <code>+ignore</code></td>\n<td>Test EDNS and truncation behavior</td>\n</tr>\n<tr>\n<td><code>dig @server domain A +tcp</code></td>\n<td>TCP fallback testing</td>\n<td><code>+vc</code>, <code>+time=30</code></td>\n<td>Verify TCP implementation</td>\n</tr>\n<tr>\n<td><code>dig @server -x IP</code></td>\n<td>Reverse DNS testing</td>\n<td><code>+short</code>, <code>+trace</code></td>\n<td>Test PTR record resolution</td>\n</tr>\n</tbody></table>\n<p><strong>Advanced dig Techniques</strong> for specific debugging scenarios:</p>\n<table>\n<thead>\n<tr>\n<th>Debugging Scenario</th>\n<th>Command</th>\n<th>What It Reveals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache behavior testing</td>\n<td><code>dig @server domain A; sleep 5; dig @server domain A</code></td>\n<td>Whether responses are cached (consistent timing)</td>\n</tr>\n<tr>\n<td>TTL countdown verification</td>\n<td><code>dig @server domain A +ttlid</code></td>\n<td>TTL decreasing over time indicates proper caching</td>\n</tr>\n<tr>\n<td>Authority vs recursive</td>\n<td><code>dig @server domain A +norec</code></td>\n<td>Whether server handles authoritative vs recursive queries</td>\n</tr>\n<tr>\n<td>DNSSEC validation</td>\n<td><code>dig @server domain A +dnssec +cd</code></td>\n<td>DNSSEC signature handling</td>\n</tr>\n<tr>\n<td>Response size analysis</td>\n<td><code>dig @server domain ANY +bufsize=512</code></td>\n<td>Truncation and EDNS behavior</td>\n</tr>\n</tbody></table>\n<p>The <code>nslookup</code> tool provides an alternative interface with interactive capabilities, while <code>host</code> offers simplified output for scripted testing scenarios.</p>\n<h4 id=\"network-traffic-analysis\">Network Traffic Analysis</h4>\n<p><strong>Wireshark</strong> provides comprehensive DNS packet analysis capabilities essential for diagnosing protocol-level issues and network communication problems.</p>\n<table>\n<thead>\n<tr>\n<th>Analysis Task</th>\n<th>Wireshark Filter</th>\n<th>Purpose</th>\n<th>Key Fields to Examine</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DNS traffic isolation</td>\n<td><code>dns</code></td>\n<td>Focus on DNS packets only</td>\n<td>Query ID, response codes, flags</td>\n</tr>\n<tr>\n<td>Server communication</td>\n<td><code>ip.addr == server_ip and dns</code></td>\n<td>Traffic to/from specific server</td>\n<td>Source/destination, timing</td>\n</tr>\n<tr>\n<td>Query/response matching</td>\n<td><code>dns.id == 0x1234</code></td>\n<td>Track specific query through system</td>\n<td>Transaction ID consistency</td>\n</tr>\n<tr>\n<td>Error response analysis</td>\n<td><code>dns.flags.rcode != 0</code></td>\n<td>Focus on error conditions</td>\n<td>Response code, authority section</td>\n</tr>\n<tr>\n<td>Large response tracking</td>\n<td><code>dns.flags.truncated == 1</code></td>\n<td>Truncation and TCP fallback</td>\n<td>TC bit, subsequent TCP connection</td>\n</tr>\n</tbody></table>\n<p><strong>Packet Analysis Techniques</strong> for specific DNS debugging scenarios:</p>\n<ol>\n<li><p><strong>Message Format Validation</strong>: Examine raw bytes in packet details to verify correct wire format encoding. Look for proper header structure, correct section counts, and valid compression pointer usage.</p>\n</li>\n<li><p><strong>Timing Analysis</strong>: Use Wireshark&#39;s time delta features to measure query response times, identify network delays, and detect timeout conditions.</p>\n</li>\n<li><p><strong>Sequence Tracking</strong>: Follow complete resolution sequences to identify where failures occur in multi-step recursive resolution processes.</p>\n</li>\n<li><p><strong>Compression Analysis</strong>: Examine name compression usage to identify compression loops or inefficient encoding that could cause parsing failures.</p>\n</li>\n</ol>\n<h4 id=\"logging-and-monitoring-strategies\">Logging and Monitoring Strategies</h4>\n<p><strong>Structured Logging</strong> provides essential visibility into DNS server internal operations, enabling rapid diagnosis of complex issues spanning multiple components.</p>\n<table>\n<thead>\n<tr>\n<th>Log Level</th>\n<th>Information Captured</th>\n<th>Example Format</th>\n<th>When to Use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ERROR</td>\n<td>Critical failures, parsing errors</td>\n<td><code>{&quot;level&quot;:&quot;error&quot;,&quot;component&quot;:&quot;parser&quot;,&quot;error&quot;:&quot;compression loop detected&quot;,&quot;offset&quot;:42}</code></td>\n<td>Always enabled</td>\n</tr>\n<tr>\n<td>WARN</td>\n<td>Recoverable issues, protocol violations</td>\n<td><code>{&quot;level&quot;:&quot;warn&quot;,&quot;component&quot;:&quot;resolver&quot;,&quot;msg&quot;:&quot;malformed response ignored&quot;,&quot;server&quot;:&quot;8.8.8.8&quot;}</code></td>\n<td>Production monitoring</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>Query processing, cache events</td>\n<td><code>{&quot;level&quot;:&quot;info&quot;,&quot;component&quot;:&quot;cache&quot;,&quot;action&quot;:&quot;miss&quot;,&quot;key&quot;:&quot;example.com/A&quot;,&quot;ttl&quot;:300}</code></td>\n<td>Performance analysis</td>\n</tr>\n<tr>\n<td>DEBUG</td>\n<td>Detailed operation tracing</td>\n<td><code>{&quot;level&quot;:&quot;debug&quot;,&quot;component&quot;:&quot;parser&quot;,&quot;msg&quot;:&quot;parsing name&quot;,&quot;offset&quot;:12,&quot;length&quot;:7}</code></td>\n<td>Development debugging</td>\n</tr>\n</tbody></table>\n<p><strong>Component-Specific Logging</strong> focuses on capturing the most diagnostic information for each major component:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Key Metrics</th>\n<th>Critical Events</th>\n<th>Performance Indicators</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Parser</td>\n<td>Parse success/failure rate, compression usage</td>\n<td>Malformed messages, validation failures</td>\n<td>Parse time per message</td>\n</tr>\n<tr>\n<td>Recursive Resolver</td>\n<td>Resolution success rate, query count per resolution</td>\n<td>Timeout failures, referral loops</td>\n<td>Time per resolution</td>\n</tr>\n<tr>\n<td>Cache Manager</td>\n<td>Hit rate, eviction count, memory usage</td>\n<td>TTL expiration events, cleanup cycles</td>\n<td>Cache lookup time</td>\n</tr>\n<tr>\n<td>Authoritative Server</td>\n<td>Query match rate, zone load status</td>\n<td>Zone parsing errors, missing records</td>\n<td>Response construction time</td>\n</tr>\n<tr>\n<td>Network Handler</td>\n<td>Query rate, response size distribution</td>\n<td>Socket errors, truncation events</td>\n<td>Network round-trip time</td>\n</tr>\n</tbody></table>\n<p><strong>Metrics Collection</strong> enables trend analysis and performance monitoring essential for production DNS servers:</p>\n<table>\n<thead>\n<tr>\n<th>Metric Category</th>\n<th>Key Measurements</th>\n<th>Collection Method</th>\n<th>Alerting Thresholds</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Throughput</td>\n<td>Queries per second, responses per second</td>\n<td>Counter increments</td>\n<td>Drop below baseline</td>\n</tr>\n<tr>\n<td>Latency</td>\n<td>Average/median/p95 response time</td>\n<td>Histogram tracking</td>\n<td>Exceed SLA targets</td>\n</tr>\n<tr>\n<td>Error Rates</td>\n<td>Parse failures, resolution timeouts, cache misses</td>\n<td>Error counters with categorization</td>\n<td>Exceed 1% of total</td>\n</tr>\n<tr>\n<td>Resource Usage</td>\n<td>Memory consumption, CPU utilization, socket count</td>\n<td>System resource monitoring</td>\n<td>Approach capacity limits</td>\n</tr>\n</tbody></table>\n<h4 id=\"systematic-debugging-methodology\">Systematic Debugging Methodology</h4>\n<p><strong>Root Cause Analysis</strong> follows a structured approach to efficiently identify and resolve DNS server issues:</p>\n<ol>\n<li><p><strong>Symptom Collection</strong>: Gather complete information about the observed problem, including error messages, affected domains, timing patterns, and environmental conditions.</p>\n</li>\n<li><p><strong>Hypothesis Formation</strong>: Based on symptoms and common bug patterns, form specific hypotheses about potential root causes, prioritizing the most likely candidates.</p>\n</li>\n<li><p><strong>Targeted Testing</strong>: Design specific tests to validate or eliminate each hypothesis, using appropriate tools and techniques for the suspected component.</p>\n</li>\n<li><p><strong>Isolation and Reproduction</strong>: Create minimal test cases that reliably reproduce the issue, enabling focused analysis and fix validation.</p>\n</li>\n<li><p><strong>Fix Implementation</strong>: Apply targeted fixes based on confirmed root causes, ensuring changes don&#39;t introduce new issues.</p>\n</li>\n<li><p><strong>Verification and Monitoring</strong>: Confirm fix effectiveness through comprehensive testing and ongoing monitoring to prevent regression.</p>\n</li>\n</ol>\n<p><strong>Environment-Specific Debugging</strong> accounts for different deployment scenarios and their unique challenges:</p>\n<table>\n<thead>\n<tr>\n<th>Environment</th>\n<th>Common Issues</th>\n<th>Debugging Approaches</th>\n<th>Special Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Development</td>\n<td>Parse errors, logic bugs</td>\n<td>Unit tests, debugger</td>\n<td>Full logging enabled</td>\n</tr>\n<tr>\n<td>Integration Testing</td>\n<td>Component interaction issues</td>\n<td>End-to-end traces</td>\n<td>Mock external services</td>\n</tr>\n<tr>\n<td>Staging</td>\n<td>Configuration problems, performance issues</td>\n<td>Load testing, monitoring</td>\n<td>Production-like data</td>\n</tr>\n<tr>\n<td>Production</td>\n<td>Scale issues, network problems</td>\n<td>Minimal impact diagnosis</td>\n<td>Service availability priority</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The debugging capabilities of a DNS server must be built into the architecture from the beginning rather than added as an afterthought. Effective debugging requires structured logging, comprehensive error handling, and diagnostic tools integrated into each component.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging</td>\n<td>Standard library <code>log</code> with structured formatting</td>\n<td><code>logrus</code> or <code>zap</code> for structured JSON logging</td>\n</tr>\n<tr>\n<td>Metrics</td>\n<td>Manual counters with periodic output</td>\n<td>Prometheus metrics with Grafana dashboards</td>\n</tr>\n<tr>\n<td>Tracing</td>\n<td>Request ID propagation through context</td>\n<td>Distributed tracing with Jaeger or Zipkin</td>\n</tr>\n<tr>\n<td>Profiling</td>\n<td>Built-in Go <code>pprof</code> endpoint</td>\n<td>Continuous profiling with dedicated tools</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>File-based log analysis</td>\n<td>Centralized logging with ELK stack</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-debugging-infrastructure\">Recommended Debugging Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Debugging infrastructure starter code - copy and use directly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">net/http/pprof</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync/atomic</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Metrics provides DNS server operational metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Metrics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueriesReceived   </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"queries_received\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponsesSent     </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"responses_sent\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParseErrors       </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"parse_errors\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResolutionErrors  </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"resolution_errors\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheHits         </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"cache_hits\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheMisses       </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"cache_misses\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecursiveQueries  </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"recursive_queries\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuthoritativeHits </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"authoritative_hits\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Logger provides structured logging with component context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Logger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    enabled   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">component</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        component: component,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        enabled: </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"ERROR\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"WARN\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"INFO\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"DEBUG\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Enable for development</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ERROR\"</span><span style=\"color:#E1E4E8\">, msg, fields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"WARN\"</span><span style=\"color:#E1E4E8\">, msg, fields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INFO\"</span><span style=\"color:#E1E4E8\">, msg, fields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DEBUG\"</span><span style=\"color:#E1E4E8\">, msg, fields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Logger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">l.enabled[level] {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UTC</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(time.RFC3339),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"level\"</span><span style=\"color:#E1E4E8\">:     level,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"component\"</span><span style=\"color:#E1E4E8\">: l.component,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"message\"</span><span style=\"color:#E1E4E8\">:   msg,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> k, v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> fields {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry[k] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> v</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(entry)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(data))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetricsCollector provides thread-safe metrics collection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricsCollector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metrics </span><span style=\"color:#B392F0\">Metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMetricsCollector</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IncrementQueriesReceived</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.QueriesReceived, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IncrementResponsesSent</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.ResponsesSent, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IncrementParseErrors</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.ParseErrors, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IncrementCacheHits</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.CacheHits, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IncrementCacheMisses</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.CacheMisses, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetMetrics</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Metrics</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Metrics</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        QueriesReceived:   atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.QueriesReceived),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ResponsesSent:     atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.ResponsesSent),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ParseErrors:       atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.ParseErrors),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ResolutionErrors:  atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.ResolutionErrors),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CacheHits:         atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.CacheHits),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CacheMisses:       atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.CacheMisses),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RecursiveQueries:  atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.RecursiveQueries),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        AuthoritativeHits: atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.metrics.AuthoritativeHits),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DebugServer provides HTTP endpoints for debugging and monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DebugServer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metrics </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDebugServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">metrics</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugServer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DebugServer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metrics: metrics,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger:  </span><span style=\"color:#B392F0\">NewLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"debug-server\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    http.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/metrics\"</span><span style=\"color:#E1E4E8\">, d.handleMetrics)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    http.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/health\"</span><span style=\"color:#E1E4E8\">, d.handleHealth)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    d.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting debug server\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"address\"</span><span style=\"color:#E1E4E8\">: addr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">(addr, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleMetrics</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metrics </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> d.metrics.</span><span style=\"color:#B392F0\">GetMetrics</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(metrics)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-debugging-integration-points\">Core Debugging Integration Points</h4>\n<p>The following debugging hooks should be integrated into each DNS server component. These provide essential diagnostic visibility without the complete implementation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Parser debugging integration - add to your parser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ParseMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"parser\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting message parse\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"message_size\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(data),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create parseState with visited tracking for compression loops</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse header section with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Parse questions section with name compression support</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse answer/authority/additional sections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate message structure and compression usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Message parsed successfully\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"questions\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(msg.Questions),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"answers\"</span><span style=\"color:#E1E4E8\">:   </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(msg.Answers),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> msg, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resolver debugging integration - add to your resolver</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecursiveResolver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ResolveQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">question</span><span style=\"color:#B392F0\"> Question</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"resolver\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    requestID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting recursive resolution\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"request_id\"</span><span style=\"color:#E1E4E8\">: requestID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"domain\"</span><span style=\"color:#E1E4E8\">:     question.Name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"type\"</span><span style=\"color:#E1E4E8\">:       question.Type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check cache for existing answer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize resolution state with visited server tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Perform iterative resolution from root servers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Follow CNAME chains with loop detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Cache final result with appropriate TTL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Resolution completed\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"request_id\"</span><span style=\"color:#E1E4E8\">:    requestID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"answer_count\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(response.Answers),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"query_count\"</span><span style=\"color:#E1E4E8\">:   state.queryCount,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> response, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cache debugging integration - add to your cache</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#B392F0\"> CacheKey</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cache\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.cache[key]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> exists </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Before</span><span style=\"color:#E1E4E8\">(entry.ExpiresAt) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cache hit\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"key\"</span><span style=\"color:#E1E4E8\">:        fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, key.Name, key.Type),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"expires_at\"</span><span style=\"color:#E1E4E8\">: entry.ExpiresAt.</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(time.RFC3339),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.stats.CacheHits, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> entry, </span><span style=\"color:#79B8FF\">true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cache miss\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"key\"</span><span style=\"color:#E1E4E8\">:     fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, key.Name, key.Type),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"exists\"</span><span style=\"color:#E1E4E8\">:  exists,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"expired\"</span><span style=\"color:#E1E4E8\">: exists </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(entry.ExpiresAt),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.stats.CacheMisses, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-debugging-checkpoints\">Milestone Debugging Checkpoints</h4>\n<p>Each milestone should include specific debugging verification steps to ensure proper implementation:</p>\n<p><strong>Milestone 1 - Message Parsing Debugging</strong>:</p>\n<ol>\n<li>Enable debug logging and parse a simple A record query</li>\n<li>Verify header fields are correctly extracted: <code>dig @localhost example.com A</code></li>\n<li>Test compression parsing with: <code>dig @localhost long.domain.name.example.com A</code></li>\n<li>Expected: Debug logs showing offset progression, no compression loop errors</li>\n<li>Red flag: Stack overflow, endless loops, or incorrect field values</li>\n</ol>\n<p><strong>Milestone 2 - Authoritative Server Debugging</strong>:</p>\n<ol>\n<li>Load a zone file and query for existing records</li>\n<li>Test NXDOMAIN responses: <code>dig @localhost nonexistent.example.com A</code></li>\n<li>Verify SOA records appear in authority section for negative responses</li>\n<li>Expected: Structured logs showing zone lookups and authority section population</li>\n<li>Red flag: Missing SOA records, case sensitivity failures, or wildcard issues</li>\n</ol>\n<p><strong>Milestone 3 - Recursive Resolution Debugging</strong>:</p>\n<ol>\n<li>Enable resolution tracing and query for external domain</li>\n<li>Follow resolution path: <code>dig @localhost google.com A +trace</code></li>\n<li>Monitor visited servers and referral following</li>\n<li>Expected: Logs showing iterative queries from root to authoritative</li>\n<li>Red flag: Infinite referral loops, missing glue records, or timeout cascades</li>\n</ol>\n<p><strong>Milestone 4 - Caching Performance Debugging</strong>:</p>\n<ol>\n<li>Query same domain twice and verify cache hit on second query</li>\n<li>Wait for TTL expiration and verify cache miss</li>\n<li>Monitor concurrent query handling under load</li>\n<li>Expected: Cache hit/miss ratios, TTL countdown, and cleanup cycles</li>\n<li>Red flag: Race conditions, memory leaks, or thundering herd scenarios</li>\n</ol>\n<h4 id=\"language-specific-debugging-hints\">Language-Specific Debugging Hints</h4>\n<p><strong>Go-Specific Debugging Techniques</strong>:</p>\n<ul>\n<li>Use <code>go run -race</code> to detect concurrency issues in cache and resolver components</li>\n<li>Enable pprof endpoints with <code>import _ &quot;net/http/pprof&quot;</code> for performance analysis</li>\n<li>Use <code>go test -v -run TestSpecificCase</code> for focused test debugging</li>\n<li>Leverage <code>context.WithTimeout</code> for resolution timeout debugging</li>\n<li>Use <code>defer func() { recover() }()</code> carefully to handle parser panics gracefully</li>\n</ul>\n<p><strong>Common Go DNS Pitfalls</strong>:</p>\n<ul>\n<li>Slice bounds: Always check <code>len(data) &gt;= offset + size</code> before reading</li>\n<li>Goroutine leaks: Ensure all resolution goroutines have proper timeout contexts</li>\n<li>Memory alignment: Use <code>binary.BigEndian</code> for consistent multi-byte integer parsing</li>\n<li>String building: Use <code>strings.Builder</code> for efficient name construction in parsing</li>\n<li>Time arithmetic: Use <code>time.Time</code> and <code>time.Duration</code> instead of manual calculations</li>\n</ul>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Beyond core implementation (post-milestone 4) - Advanced DNS server features and operational considerations</p>\n</blockquote>\n<h3 id=\"mental-model-dns-server-evolution-as-infrastructure-maturation\">Mental Model: DNS Server Evolution as Infrastructure Maturation</h3>\n<p>Think of DNS server evolution like building infrastructure in a growing city. Your basic DNS server from milestones 1-4 is like the initial road network and traffic signals—it handles the fundamental need for navigation and traffic flow. But as the city grows and faces new challenges, you need additional infrastructure layers: security systems (DNSSEC), modern transportation options (DNS-over-HTTPS), advanced traffic management (intelligent caching), monitoring systems (metrics and alerting), and operational frameworks (configuration management and deployment automation).</p>\n<p>Each extension builds upon the solid foundation of your core DNS server while addressing specific operational, security, or performance concerns that emerge in production environments. The key insight is that these extensions don&#39;t replace your core functionality—they enhance it with additional capabilities that become increasingly important as your DNS server scales and faces real-world operational demands.</p>\n<blockquote>\n<p><strong>Design Principle</strong>: Extensions should integrate seamlessly with existing components rather than requiring architectural overhauls. The modular design established in milestones 1-4 provides extension points where new functionality can be layered on without disrupting core DNS processing logic.</p>\n</blockquote>\n<h2 id=\"protocol-extensions\">Protocol Extensions</h2>\n<h3 id=\"mental-model-protocol-extensions-as-language-dialects\">Mental Model: Protocol Extensions as Language Dialects</h3>\n<p>Consider DNS protocol extensions like regional dialects of a shared language. Your basic DNS implementation speaks &quot;Standard DNS&quot; fluently, but modern networks require additional &quot;dialects&quot; like DNSSEC (the security-aware dialect), EDNS (the extended capabilities dialect), and encrypted transports (the privacy-conscious dialects). Each extension maintains compatibility with the core language while adding specialized vocabulary and grammar rules for specific use cases.</p>\n<p>The architectural challenge lies in supporting multiple dialects simultaneously without creating a &quot;tower of babel&quot; where components can&#39;t communicate effectively. The solution involves designing protocol abstraction layers that can negotiate capabilities and translate between different DNS dialects as needed.</p>\n<h3 id=\"dnssec-dns-security-extensions\">DNSSEC (DNS Security Extensions)</h3>\n<p>DNSSEC represents the most significant protocol extension for DNS servers, adding cryptographic authentication to DNS responses. Think of DNSSEC as adding a notarization system to DNS—every authoritative response gets digitally signed, and recursive resolvers verify these signatures to detect tampering or spoofing attempts.</p>\n<p><strong>DNSSEC Architecture Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Purpose</th>\n<th>Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DNSSECValidator</code></td>\n<td>Validates DNSSEC signatures and chains</td>\n<td>Integrates with <code>RecursiveResolver</code> before caching responses</td>\n</tr>\n<tr>\n<td><code>ZoneSigner</code></td>\n<td>Signs authoritative zone data with private keys</td>\n<td>Extends <code>AuthoritativeServer</code> to add RRSIG records</td>\n</tr>\n<tr>\n<td><code>KeyManager</code></td>\n<td>Manages DNSSEC key lifecycle and rotation</td>\n<td>Standalone component with file-based or HSM backends</td>\n</tr>\n<tr>\n<td><code>TrustAnchorStore</code></td>\n<td>Maintains root and DLV trust anchors</td>\n<td>Used by validator to bootstrap signature verification</td>\n</tr>\n</tbody></table>\n<p>The DNSSEC validation process extends the recursive resolution algorithm with additional cryptographic verification steps. After receiving a DNS response but before caching it, the validator must verify the signature chain from the response back to a trusted anchor (typically the root zone&#39;s key).</p>\n<p><strong>DNSSEC Resource Record Types:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Record Type</th>\n<th>Purpose</th>\n<th>Data Format</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RRSIG</code></td>\n<td>Contains cryptographic signature for an RRset</td>\n<td>Algorithm, labels, original TTL, signature expiration/inception, key tag, signer name, signature</td>\n</tr>\n<tr>\n<td><code>DNSKEY</code></td>\n<td>Contains public key for zone</td>\n<td>Flags, protocol, algorithm, public key data</td>\n</tr>\n<tr>\n<td><code>DS</code></td>\n<td>Contains hash of child zone&#39;s key</td>\n<td>Key tag, algorithm, digest type, digest</td>\n</tr>\n<tr>\n<td><code>NSEC/NSEC3</code></td>\n<td>Proves non-existence of records</td>\n<td>Next domain name and type bitmap (NSEC) or hashed names (NSEC3)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: DNSSEC Implementation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: DNSSEC adds significant complexity to both authoritative and recursive functionality</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Full DNSSEC implementation with signing and validation</li>\n<li>Validation-only recursive resolver</li>\n<li>Hybrid approach with pluggable DNSSEC backend</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Validation-only recursive resolver with external signing tools</li>\n<li><strong>Rationale</strong>: Key management and zone signing require specialized security practices beyond the scope of a DNS server implementation project. Validation provides the primary security benefit for recursive resolvers.</li>\n<li><strong>Consequences</strong>: Enables DNSSEC-aware recursive resolution while avoiding the complexity of cryptographic key management and zone signing workflows.</li>\n</ul>\n</blockquote>\n<h3 id=\"edns-extension-mechanisms-for-dns\">EDNS (Extension Mechanisms for DNS)</h3>\n<p>EDNS extends the basic DNS protocol to support larger message sizes, additional flags, and option codes for protocol extensions. Think of EDNS as adding a &quot;capabilities negotiation&quot; layer to DNS—it allows clients and servers to advertise and utilize enhanced DNS features beyond the original 512-byte UDP limit.</p>\n<p><strong>EDNS Implementation Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Extension Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>EDNSProcessor</code></td>\n<td>Handles EDNS option parsing and generation</td>\n<td>Extends <code>MessageHandler</code> processing pipeline</td>\n</tr>\n<tr>\n<td><code>UDPSizeNegotiator</code></td>\n<td>Manages UDP payload size negotiation</td>\n<td>Integrates with <code>Server</code> transport layer</td>\n</tr>\n<tr>\n<td><code>OptionCodeHandler</code></td>\n<td>Processes specific EDNS option types</td>\n<td>Pluggable handlers for different option codes</td>\n</tr>\n</tbody></table>\n<p><strong>EDNS Option Codes:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option Code</th>\n<th>Name</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3</td>\n<td>NSID</td>\n<td>Name Server Identifier for debugging</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DAU/DHU/N3U</td>\n<td>DNSSEC algorithm understanding</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Client Subnet</td>\n<td>Geographic location hints for CDN optimization</td>\n</tr>\n<tr>\n<td>9</td>\n<td>EXPIRE</td>\n<td>SOA EXPIRE value in responses</td>\n</tr>\n<tr>\n<td>10</td>\n<td>COOKIE</td>\n<td>DNS cookies for security and performance</td>\n</tr>\n<tr>\n<td>12</td>\n<td>PADDING</td>\n<td>Message padding for privacy</td>\n</tr>\n</tbody></table>\n<p>EDNS fundamentally changes how your DNS server handles message size limitations. Instead of the hard 512-byte UDP limit, EDNS allows negotiation of much larger UDP payloads (typically 1232 bytes to avoid IP fragmentation). This requires modifications to your UDP transport layer to handle variable-sized buffers and fragmentation detection.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: EDNS options provide a standardized extension mechanism that avoids the need for new DNS message formats. Each option code represents a mini-protocol that can be independently implemented and deployed.</p>\n</blockquote>\n<h3 id=\"dns-over-https-doh-and-dns-over-tls-dot\">DNS-over-HTTPS (DoH) and DNS-over-TLS (DoT)</h3>\n<p>Encrypted DNS transports address privacy concerns by encrypting DNS queries and responses. DoT wraps standard DNS queries in TLS connections, while DoH embeds DNS messages in HTTP/2 requests. Think of these as &quot;secure tunnels&quot; for DNS traffic—the core DNS message processing remains unchanged, but the transport layer provides encryption and authentication.</p>\n<p><strong>Encrypted Transport Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Transport</th>\n<th>Protocol Stack</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DNS-over-TLS</td>\n<td>DNS/TLS/TCP</td>\n<td>TLS server with DNS message framing</td>\n</tr>\n<tr>\n<td>DNS-over-HTTPS</td>\n<td>DNS/HTTP/2/TLS/TCP</td>\n<td>HTTP/2 server with DNS message encoding</td>\n</tr>\n<tr>\n<td>DNS-over-QUIC</td>\n<td>DNS/QUIC/UDP</td>\n<td>QUIC connection with DNS message streams</td>\n</tr>\n</tbody></table>\n<p>The key architectural insight is that encrypted transports require minimal changes to your core DNS processing logic. The <code>MessageHandler</code>, <code>RecursiveResolver</code>, and <code>CacheManager</code> components remain unchanged—only the transport layer needs modification to handle TLS handshakes, HTTP request parsing, and connection management.</p>\n<blockquote>\n<p><strong>Decision: Transport Layer Abstraction</strong></p>\n<ul>\n<li><strong>Context</strong>: Supporting multiple transports (UDP, TCP, TLS, HTTPS) without duplicating DNS processing logic</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Separate server implementations for each transport</li>\n<li>Transport abstraction with common DNS processing pipeline</li>\n<li>Protocol-specific forks of core components</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Transport abstraction with unified message processing</li>\n<li><strong>Rationale</strong>: DNS message semantics remain identical across transports—only framing and security differ. A transport abstraction allows code reuse while supporting multiple protocols.</li>\n<li><strong>Consequences</strong>: Enables easy addition of new transports without modifying core DNS logic, but requires careful abstraction design to handle transport-specific features like connection state.</li>\n</ul>\n</blockquote>\n<p><strong>Common Protocol Extension Pitfalls:</strong></p>\n<p>⚠️ <strong>Pitfall: Version Proliferation</strong>\nAdding protocol extensions often leads to combinatorial explosion of supported feature combinations. For example, supporting both DNSSEC and EDNS requires testing every EDNS option with and without DNSSEC validation. Create feature matrices to track supported combinations and use feature flags to enable/disable extensions independently during testing.</p>\n<p>⚠️ <strong>Pitfall: Backward Compatibility Breakage</strong>\nProtocol extensions must remain compatible with clients that don&#39;t support the extension. Always implement graceful fallback—if a client doesn&#39;t support EDNS, respond with standard 512-byte messages. If DNSSEC validation fails, log the failure but still provide the response (with appropriate flags) rather than returning SERVFAIL.</p>\n<p>⚠️ <strong>Pitfall: Security Regression</strong>\nAdding new protocol features often introduces security vulnerabilities if not carefully implemented. DNSSEC validation bugs can disable security entirely, and encrypted transport implementations may be vulnerable to downgrade attacks. Implement security extensions in separate, well-tested modules with comprehensive failure mode analysis.</p>\n<h2 id=\"operational-features\">Operational Features</h2>\n<h3 id=\"mental-model-dns-operations-as-service-management\">Mental Model: DNS Operations as Service Management</h3>\n<p>Think of operational features as the difference between running a personal vehicle and managing a commercial fleet. Your core DNS server from milestones 1-4 is like a well-functioning car—it gets you from point A to point B reliably. But operating DNS infrastructure in production requires fleet management capabilities: monitoring dashboards to track performance across multiple servers, centralized configuration management to update policies consistently, automated deployment pipelines to roll out changes safely, and comprehensive logging to diagnose issues quickly.</p>\n<p>The operational layer sits &quot;around&quot; your DNS server rather than &quot;inside&quot; it. These features observe, configure, and manage your DNS server without changing its core resolution logic. The architectural challenge is designing clean integration points that provide operational visibility without compromising DNS processing performance.</p>\n<h3 id=\"metrics-and-monitoring\">Metrics and Monitoring</h3>\n<p>Production DNS servers require comprehensive metrics collection to track performance, detect anomalies, and guide capacity planning. Think of metrics as the &quot;vital signs&quot; of your DNS server—just as medical monitors track heart rate, blood pressure, and temperature, DNS metrics track query rates, resolution latencies, cache hit rates, and error frequencies.</p>\n<p><strong>DNS Metrics Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Key Metrics</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Traffic</td>\n<td><code>queries_per_second</code>, <code>responses_per_second</code>, <code>bytes_in</code>, <code>bytes_out</code></td>\n<td>Capacity planning and traffic analysis</td>\n</tr>\n<tr>\n<td>Performance</td>\n<td><code>resolution_latency_p50</code>, <code>resolution_latency_p99</code>, <code>cache_hit_rate</code></td>\n<td>Performance optimization and SLA monitoring</td>\n</tr>\n<tr>\n<td>Reliability</td>\n<td><code>servfail_rate</code>, <code>nxdomain_rate</code>, <code>timeout_rate</code>, <code>uptime_percentage</code></td>\n<td>Service health and error analysis</td>\n</tr>\n<tr>\n<td>Resources</td>\n<td><code>memory_usage</code>, <code>cpu_utilization</code>, <code>cache_memory_bytes</code>, <code>goroutine_count</code></td>\n<td>Resource monitoring and leak detection</td>\n</tr>\n</tbody></table>\n<p><strong>Metrics Collection Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Integration Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MetricsCollector</code></td>\n<td>Aggregates counters and histograms</td>\n<td>Embedded in each major component (resolver, cache, handler)</td>\n</tr>\n<tr>\n<td><code>MetricsExporter</code></td>\n<td>Exports metrics in Prometheus format</td>\n<td>HTTP endpoint at <code>/metrics</code> for scraping</td>\n</tr>\n<tr>\n<td><code>HealthChecker</code></td>\n<td>Provides service health endpoints</td>\n<td>HTTP endpoint at <code>/health</code> with dependency checks</td>\n</tr>\n<tr>\n<td><code>AlertManager</code></td>\n<td>Defines alert rules and thresholds</td>\n<td>External configuration with metric threshold rules</td>\n</tr>\n</tbody></table>\n<p>The metrics collection pattern involves embedding metric collection points throughout your DNS server components without impacting the critical path. Use atomic counters for high-frequency events (query counts) and sampling for expensive metrics (detailed latency histograms).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example metrics integration pattern:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricsCollector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queriesReceived     </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cacheHits          </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resolutionLatency  </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Histogram</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordQuery</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">m.queriesReceived, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>Decision: Metrics Collection Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Need comprehensive observability without impacting DNS resolution performance</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Synchronous metrics collection on every operation</li>\n<li>Asynchronous metrics aggregation with periodic export</li>\n<li>Sampling-based metrics with statistical extrapolation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Atomic counters for high-frequency metrics with periodic aggregation</li>\n<li><strong>Rationale</strong>: Atomic operations provide accurate counts with minimal performance overhead. Periodic aggregation reduces export overhead while maintaining near-real-time visibility.</li>\n<li><strong>Consequences</strong>: Provides accurate, low-overhead metrics collection suitable for high-query-rate DNS servers.</li>\n</ul>\n</blockquote>\n<h3 id=\"configuration-management\">Configuration Management</h3>\n<p>Production DNS servers require dynamic configuration management to update policies, zone data, and operational parameters without service restarts. Think of configuration management as the &quot;control panel&quot; for your DNS server—it allows operators to adjust server behavior in response to changing requirements, security threats, or performance issues.</p>\n<p><strong>Configuration Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Configuration Type</th>\n<th>Examples</th>\n<th>Update Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server Configuration</td>\n<td><code>listen_addresses</code>, <code>timeout_values</code>, <code>thread_pools</code></td>\n<td>File-based with hot reload</td>\n</tr>\n<tr>\n<td>Zone Configuration</td>\n<td><code>zone_files</code>, <code>zone_transfers</code>, <code>delegation_points</code></td>\n<td>Dynamic zone loading</td>\n</tr>\n<tr>\n<td>Policy Configuration</td>\n<td><code>rate_limits</code>, <code>access_controls</code>, <code>filtering_rules</code></td>\n<td>API-based updates</td>\n</tr>\n<tr>\n<td>Cache Configuration</td>\n<td><code>cache_size</code>, <code>ttl_overrides</code>, <code>negative_cache_ttl</code></td>\n<td>Runtime parameter updates</td>\n</tr>\n</tbody></table>\n<p><strong>Configuration Management Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Purpose</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ConfigLoader</code></td>\n<td>Loads configuration from files and APIs</td>\n<td>YAML/JSON parsing with validation</td>\n</tr>\n<tr>\n<td><code>ConfigWatcher</code></td>\n<td>Detects configuration file changes</td>\n<td>Filesystem watching with inotify/polling</td>\n</tr>\n<tr>\n<td><code>ConfigValidator</code></td>\n<td>Validates configuration syntax and semantics</td>\n<td>Schema validation with dependency checking</td>\n</tr>\n<tr>\n<td><code>ConfigApplier</code></td>\n<td>Applies configuration changes to running server</td>\n<td>Component-specific update handlers</td>\n</tr>\n</tbody></table>\n<p>Configuration management requires careful handling of update atomicity and rollback scenarios. Configuration changes should be validated before application, and the server should maintain the ability to revert to a known-good configuration if updates cause operational issues.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Configuration hot reloading is essential for DNS servers because restart-based configuration updates cause query interruption and cache loss. Design your configuration system with incremental updates that preserve server state wherever possible.</p>\n</blockquote>\n<h3 id=\"deployment-and-scaling\">Deployment and Scaling</h3>\n<p>DNS infrastructure requires deployment strategies that ensure continuous availability during updates and provide horizontal scaling capabilities for high-query loads. Think of DNS deployment like air traffic control system updates—you can&#39;t take the system offline for maintenance, so you need rolling update strategies that maintain service continuity.</p>\n<p><strong>Deployment Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Blue-Green Deployment</td>\n<td>Two identical environments with traffic switching</td>\n<td>Major version updates with quick rollback</td>\n</tr>\n<tr>\n<td>Rolling Updates</td>\n<td>Gradual replacement of servers in a cluster</td>\n<td>Minor updates with zero downtime</td>\n</tr>\n<tr>\n<td>Canary Deployment</td>\n<td>Small percentage of traffic to new version</td>\n<td>Testing updates with limited blast radius</td>\n</tr>\n<tr>\n<td>A/B Testing</td>\n<td>Split traffic between configuration variants</td>\n<td>Performance testing and optimization</td>\n</tr>\n</tbody></table>\n<p><strong>Scaling Architectures:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Architecture</th>\n<th>Benefits</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Load Balancer + Multiple Resolvers</td>\n<td>Simple horizontal scaling</td>\n<td>Shared cache warming and coordination complexity</td>\n</tr>\n<tr>\n<td>Anycast DNS with Geographic Distribution</td>\n<td>Geographic latency optimization</td>\n<td>Complex routing and failure handling</td>\n</tr>\n<tr>\n<td>Hierarchical Resolver Chains</td>\n<td>Specialized resolver roles</td>\n<td>Additional network hops and complexity</td>\n</tr>\n</tbody></table>\n<p>Production DNS deployment requires careful consideration of state management during updates. Your <code>CacheManager</code> contains valuable cached data that provides significant performance benefits. Deployment strategies should preserve cache state when possible or implement cache warming procedures to minimize performance impact during server replacement.</p>\n<blockquote>\n<p><strong>Decision: Deployment State Management</strong></p>\n<ul>\n<li><strong>Context</strong>: DNS server updates should minimize performance impact from cache loss</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Stateless deployment with cache rebuilding after updates</li>\n<li>Cache persistence with state restoration during updates  </li>\n<li>Cache sharing between old and new server instances</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Gradual traffic shifting with cache warming period</li>\n<li><strong>Rationale</strong>: Allows new instances to warm their caches gradually while maintaining performance. Avoids complexity of cache persistence while minimizing performance impact.</li>\n<li><strong>Consequences</strong>: Requires load balancer support for gradual traffic shifting but provides best balance of simplicity and performance.</li>\n</ul>\n</blockquote>\n<p><strong>Operational Features Common Pitfalls:</strong></p>\n<p>⚠️ <strong>Pitfall: Metrics Overhead</strong>\nComprehensive metrics collection can introduce significant performance overhead if implemented poorly. Avoid string concatenation in metric names, use pre-allocated metric objects, and batch metric exports. Monitor the overhead of your monitoring system itself—metrics collection should consume less than 5% of total server resources.</p>\n<p>⚠️ <strong>Pitfall: Configuration Validation Gaps</strong>\nInvalid configurations that pass initial validation but cause runtime failures are particularly dangerous in DNS servers. Implement multi-layer validation: syntax validation at load time, semantic validation before application, and runtime health checks after application. Always maintain a rollback path to the previous known-good configuration.</p>\n<p>⚠️ <strong>Pitfall: Deployment Race Conditions</strong>\nDNS server deployments can suffer from race conditions where configuration updates, zone data changes, and software updates interfere with each other. Implement deployment coordination mechanisms that serialize conflicting operations and provide clear rollback procedures when deployments fail partially.</p>\n<h3 id=\"logging-and-audit-trail\">Logging and Audit Trail</h3>\n<p>Production DNS servers require comprehensive logging for security analysis, performance debugging, and compliance requirements. Think of DNS logging as creating a &quot;flight recorder&quot; for your DNS server—it captures enough detail to reconstruct what happened during incidents, security events, or performance anomalies without creating excessive storage overhead.</p>\n<p><strong>Logging Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Log Type</th>\n<th>Content</th>\n<th>Retention Policy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Query Logs</td>\n<td>Client IP, query name/type, response code, latency</td>\n<td>7-30 days (high volume)</td>\n</tr>\n<tr>\n<td>Security Logs</td>\n<td>Failed validation, rate limiting, suspicious patterns</td>\n<td>90+ days (compliance)</td>\n</tr>\n<tr>\n<td>Performance Logs</td>\n<td>Slow queries, cache misses, upstream failures</td>\n<td>30 days (analysis)</td>\n</tr>\n<tr>\n<td>Audit Logs</td>\n<td>Configuration changes, administrative actions</td>\n<td>1+ years (compliance)</td>\n</tr>\n</tbody></table>\n<p>DNS logging must balance comprehensive coverage with storage costs and privacy requirements. High-volume query logs require efficient compression and rotation strategies, while security and audit logs need longer retention with tamper-evident storage.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Metrics Collection</td>\n<td>Expvar + JSON export</td>\n<td>Prometheus + Grafana</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>YAML files + file watching</td>\n<td>Consul + dynamic updates</td>\n</tr>\n<tr>\n<td>Deployment</td>\n<td>Docker + shell scripts</td>\n<td>Kubernetes + Helm charts</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard library + log rotation</td>\n<td>Structured logging + ELK stack</td>\n</tr>\n<tr>\n<td>Transport Security</td>\n<td>Go TLS + certificate files</td>\n<td>cert-manager + automatic rotation</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>dns-server/\n  cmd/\n    dns-server/main.go          ← main server entry point\n    config-validator/main.go    ← configuration validation tool\n  internal/\n    metrics/\n      collector.go              ← metrics collection interface\n      prometheus.go             ← Prometheus exporter implementation\n      health.go                 ← health check endpoints\n    config/\n      loader.go                 ← configuration loading and validation\n      watcher.go                ← configuration change detection\n      schema.go                 ← configuration schema definitions\n    transport/\n      udp.go                    ← standard UDP transport\n      tls.go                    ← DNS-over-TLS implementation\n      https.go                  ← DNS-over-HTTPS implementation\n    extensions/\n      dnssec/                   ← DNSSEC validation components\n      edns/                     ← EDNS option handling\n  configs/\n    server.yaml                 ← server configuration template\n    zones/                      ← zone file directory\n  deploy/\n    docker/                     ← container deployment files\n    k8s/                        ← Kubernetes manifests\n  scripts/\n    deploy.sh                   ← deployment automation\n    backup.sh                   ← backup procedures</code></pre></div>\n\n<p><strong>Infrastructure Starter Code:</strong></p>\n<p><strong>Metrics Collection Framework:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package metrics provides DNS server metrics collection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> metrics</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync/atomic</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Collector aggregates DNS server metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Collector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Query counters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queriesReceived </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    responsesSent   </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Error counters  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parseErrors      </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resolutionErrors </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Performance metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cacheHits        </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cacheMisses      </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Latency tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalLatency     </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queryCount       </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCollector creates a metrics collector instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCollector</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordQuery increments the queries received counter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordQuery</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.queriesReceived, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordResponse increments the responses sent counter  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordResponse</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.responsesSent, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordLatency adds query latency to running average</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordLatency</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">duration</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    latencyMs </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">(duration.</span><span style=\"color:#B392F0\">Nanoseconds</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.totalLatency, latencyMs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic.</span><span style=\"color:#B392F0\">AddUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.queryCount, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetStats returns current metrics snapshot</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetStats</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queries </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.queriesReceived)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    responses </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.responsesSent)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hits </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.cacheHits)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    misses </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.cacheMisses)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalLat </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.totalLatency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atomic.</span><span style=\"color:#B392F0\">LoadUint64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.queryCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"queries_received\"</span><span style=\"color:#E1E4E8\">:  queries,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"responses_sent\"</span><span style=\"color:#E1E4E8\">:    responses,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"cache_hits\"</span><span style=\"color:#E1E4E8\">:        hits,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"cache_misses\"</span><span style=\"color:#E1E4E8\">:      misses,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"cache_hit_rate\"</span><span style=\"color:#E1E4E8\">:    </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(hits) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(hits</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">misses),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats[</span><span style=\"color:#9ECBFF\">\"avg_latency_ms\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(totalLat) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServeHTTP provides HTTP metrics endpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement Prometheus format export</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add histogram buckets for latency distribution  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Include server metadata and build info</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Configuration Management Framework:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package config provides dynamic configuration management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> config</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io/ioutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">gopkg.in/yaml.v2</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServerConfig defines DNS server configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServerConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ListenAddr    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `yaml:\"listen_addr\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timeout       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxGoroutines </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `yaml:\"max_goroutines\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cache </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MaxSize     </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `yaml:\"max_size\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        DefaultTTL  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"default_ttl\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CleanupInt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"cleanup_interval\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#9ECBFF\">`yaml:\"cache\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Zones []</span><span style=\"color:#B392F0\">ZoneConfig</span><span style=\"color:#9ECBFF\"> `yaml:\"zones\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metrics </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Enabled </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">   `yaml:\"enabled\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Port    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `yaml:\"port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Path    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#9ECBFF\">`yaml:\"metrics\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ZoneConfig defines authoritative zone configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ZoneConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Domain </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"domain\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    File   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"file\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"type\"`</span><span style=\"color:#6A737D\"> // \"master\" or \"slave\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Loader manages configuration loading and reloading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Loader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configPath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ServerConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    watchers   []</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewLoader creates a configuration loader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewLoader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Loader</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Loader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        configPath: configPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        watchers:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">ServerConfig), </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Load reads and parses configuration file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Loader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Load</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(l.configPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reading config file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#B392F0\">ServerConfig</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> yaml.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">config); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"parsing config YAML: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> l.</span><span style=\"color:#B392F0\">validate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">config); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"validating config: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">notifyWatchers</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// validate performs semantic validation of configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Loader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">validate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate listen address format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check zone file paths exist and are readable  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate timeout and size parameters are reasonable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check for conflicting zone domains</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Watch registers callback for configuration changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Loader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Watch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.watchers </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(l.watchers, callback)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// notifyWatchers calls all registered change callbacks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Loader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">notifyWatchers</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, watcher </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> l.watchers {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#B392F0\"> watcher</span><span style=\"color:#E1E4E8\">(l.current) </span><span style=\"color:#6A737D\">// Non-blocking notification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartWatching begins monitoring config file for changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Loader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartWatching</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement file system watching with inotify/polling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Debounce rapid file changes </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle file deletion and recreation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Reload configuration when changes detected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<p><strong>DNSSEC Validator Interface:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ValidateResponse performs DNSSEC validation on DNS response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DNSSECValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">response</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DNSMessage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">question</span><span style=\"color:#B392F0\"> Question</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if response requires DNSSEC validation (AD bit or DO bit set)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Extract RRSIG records from answer, authority, and additional sections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify each RRSIG against its corresponding RRset using DNSKEY records  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Build trust chain from response back to configured trust anchor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate signature timestamps (inception/expiration) against current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for NSEC/NSEC3 records to validate negative responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Set AD (Authenticated Data) bit in response if validation succeeds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use crypto/rsa or crypto/ecdsa for signature verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement recursive trust chain building for multi-level domains</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Transport Abstraction Interface:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// HandleConnection processes DNS queries over encrypted transport</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TLSServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">conn</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Conn</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Perform TLS handshake and certificate validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read DNS message length prefix (2 bytes, network order)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read DNS message data based on length prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse DNS message using existing ParseMessage function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Process query using existing MessageHandler </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Serialize response using existing SerializeMessage function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Write length prefix and response data to connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Handle connection errors and cleanup resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: DNS over TCP/TLS uses 2-byte length prefixes unlike UDP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Reuse existing UDP message processing pipeline unchanged</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Metrics Export Endpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ExportPrometheusMetrics formats metrics in Prometheus exposition format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExportPrometheusMetrics</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get current metrics snapshot from atomic counters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Format counter metrics with Prometheus naming conventions  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate derived metrics like cache hit rate percentages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Include metric metadata (HELP and TYPE comments)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add server identification labels (version, instance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Format histogram buckets for latency distributions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return complete Prometheus exposition format string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Follow Prometheus metric naming: dns_queries_total, dns_cache_hits_total</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Include timestamp for each metric sample</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<ul>\n<li><strong>Metrics Collection</strong>: Use <code>sync/atomic</code> for counters, <code>sync.RWMutex</code> for histograms, avoid string concatenation in hot paths</li>\n<li><strong>Configuration Management</strong>: Use <code>gopkg.in/yaml.v2</code> for YAML parsing, <code>github.com/fsnotify/fsnotify</code> for file watching  </li>\n<li><strong>TLS Implementation</strong>: Use <code>crypto/tls</code> with <code>tls.Config</code> for certificate management, handle TLS handshake errors gracefully</li>\n<li><strong>HTTP/2 for DoH</strong>: Use <code>golang.org/x/net/http2</code> package, handle HTTP/2 stream multiplexing correctly</li>\n<li><strong>DNSSEC Cryptography</strong>: Use <code>github.com/miekg/dns</code> package for DNSSEC record parsing, <code>crypto/rsa</code> and <code>crypto/ecdsa</code> for validation</li>\n</ul>\n<p><strong>Milestone Checkpoints:</strong></p>\n<p><strong>Protocol Extensions Checkpoint:</strong></p>\n<ul>\n<li>Verify EDNS support: <code>dig @localhost -p 5353 +edns=0 +bufsize=4096 example.com</code> should return larger UDP responses</li>\n<li>Test DNSSEC validation: Configure trust anchor and verify DNSSEC-signed domains return validated responses</li>\n<li>Validate DoT/DoH: Connect using TLS/HTTPS clients and verify standard DNS responses over encrypted transports</li>\n</ul>\n<p><strong>Operational Features Checkpoint:</strong></p>\n<ul>\n<li>Access metrics endpoint: <code>curl http://localhost:8080/metrics</code> should return Prometheus-format metrics</li>\n<li>Test configuration reload: Modify configuration file and verify changes applied without restart</li>\n<li>Monitor health endpoint: <code>curl http://localhost:8080/health</code> should return service status and dependency checks</li>\n</ul>\n<p><strong>Performance Validation:</strong></p>\n<ul>\n<li>Load test with metrics: Run high query rate load test while monitoring metrics export overhead</li>\n<li>Configuration change impact: Measure query latency during configuration reload operations  </li>\n<li>Memory usage tracking: Monitor memory growth over time with comprehensive metrics collection enabled</li>\n</ul>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - Terminology reference for DNS server implementation concepts and technical terms</p>\n</blockquote>\n<h3 id=\"mental-model-technical-glossary-as-a-shared-language-dictionary\">Mental Model: Technical Glossary as a Shared Language Dictionary</h3>\n<p>Think of this glossary as the shared vocabulary that enables effective communication between DNS engineers. Just as lawyers have precise definitions for legal terms like &quot;tort&quot; or &quot;jurisdiction,&quot; DNS engineers need precise definitions for concepts like &quot;bailiwick&quot; or &quot;glue records.&quot; Without this shared language, discussions about DNS server behavior become ambiguous and error-prone. This glossary serves as the authoritative reference for all technical terms used throughout the DNS server implementation, ensuring consistent understanding across different components and development phases.</p>\n<p>The glossary is organized into logical categories that mirror the DNS server&#39;s architectural layers: protocol fundamentals, message structure, resolution processes, caching mechanisms, implementation concepts, and operational terminology. Each definition provides not just the meaning, but context about when and why the term is important in DNS server implementation.</p>\n<h3 id=\"dns-protocol-fundamentals\">DNS Protocol Fundamentals</h3>\n<p>These terms form the foundation of DNS understanding and appear throughout all milestones of the implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DNS (Domain Name System)</strong></td>\n<td>Distributed hierarchical naming system that translates domain names to IP addresses and other resource data</td>\n<td>Core protocol that the entire server implements</td>\n</tr>\n<tr>\n<td><strong>recursive resolver</strong></td>\n<td>DNS server that performs complete domain name resolution by following referrals from root servers through the DNS hierarchy until reaching authoritative servers</td>\n<td>Primary server type implemented in Milestone 3</td>\n</tr>\n<tr>\n<td><strong>authoritative server</strong></td>\n<td>DNS server that holds definitive, original DNS records for specific domains and can provide authoritative answers</td>\n<td>Server type implemented in Milestone 2</td>\n</tr>\n<tr>\n<td><strong>forwarding server</strong></td>\n<td>DNS server that relays all queries to upstream DNS servers without performing resolution itself</td>\n<td>Alternative architecture not implemented in this project</td>\n</tr>\n<tr>\n<td><strong>iterative resolution</strong></td>\n<td>Process where a DNS resolver follows referrals from root servers through TLD servers to authoritative servers, making separate queries at each level</td>\n<td>Core algorithm implemented in recursive resolver</td>\n</tr>\n<tr>\n<td><strong>zone</strong></td>\n<td>Administrative unit of DNS namespace for which a single authoritative server is responsible</td>\n<td>Organizational concept used in authoritative server implementation</td>\n</tr>\n<tr>\n<td><strong>zone data</strong></td>\n<td>Collection of authoritative DNS records loaded from configuration files for domains under server authority</td>\n<td>Data structure managed by authoritative server</td>\n</tr>\n<tr>\n<td><strong>root servers</strong></td>\n<td>Thirteen DNS servers that form the top of the DNS hierarchy, knowing the authoritative servers for all top-level domains</td>\n<td>Starting point for recursive resolution</td>\n</tr>\n<tr>\n<td><strong>root hints</strong></td>\n<td>Configuration file containing IP addresses of DNS root servers used to bootstrap recursive resolution</td>\n<td>Required configuration for recursive resolver</td>\n</tr>\n</tbody></table>\n<h3 id=\"dns-message-structure-and-protocol-details\">DNS Message Structure and Protocol Details</h3>\n<p>These terms describe the binary protocol format and message components that are central to Milestone 1 (DNS Message Parsing).</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>wire format</strong></td>\n<td>Binary representation of DNS messages as transmitted over the network, following RFC 1035 specification</td>\n<td>Target format for message serialization and source for parsing</td>\n</tr>\n<tr>\n<td><strong>DNS message</strong></td>\n<td>Complete DNS protocol data unit containing header, questions, and resource record sections</td>\n<td>Primary data structure processed by all server components</td>\n</tr>\n<tr>\n<td><strong>resource record</strong></td>\n<td>DNS data entry containing name, type, class, TTL, and type-specific data fields</td>\n<td>Fundamental unit of DNS information</td>\n</tr>\n<tr>\n<td><strong>TTL (Time To Live)</strong></td>\n<td>Numeric value in seconds indicating how long a DNS record can be cached before expiration</td>\n<td>Critical for cache management in Milestone 4</td>\n</tr>\n<tr>\n<td><strong>network byte order</strong></td>\n<td>Big-endian byte ordering used in DNS messages where most significant byte comes first</td>\n<td>Required for correct binary message parsing</td>\n</tr>\n<tr>\n<td><strong>label length encoding</strong></td>\n<td>DNS name representation where each component is prefixed with a length byte</td>\n<td>Core parsing algorithm for domain names</td>\n</tr>\n<tr>\n<td><strong>name compression</strong></td>\n<td>DNS optimization technique using pointer labels to reference previously encoded domain names within the same message</td>\n<td>Essential for efficient message parsing and construction</td>\n</tr>\n<tr>\n<td><strong>compression pointer</strong></td>\n<td>Two-byte reference (starting with 0xC0) that points to another location in the DNS message containing a domain name</td>\n<td>Implementation detail for name compression</td>\n</tr>\n<tr>\n<td><strong>pointer labels</strong></td>\n<td>DNS name components beginning with bits 11 (0xC0) that reference other message locations instead of containing literal text</td>\n<td>Specific type of label requiring special parsing logic</td>\n</tr>\n</tbody></table>\n<h3 id=\"dns-record-types-and-classes\">DNS Record Types and Classes</h3>\n<p>These terms define the types of DNS data that servers handle throughout all milestones.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>A record</strong></td>\n<td>DNS resource record type 1 containing 32-bit IPv4 address</td>\n<td>Most common record type processed by all server components</td>\n</tr>\n<tr>\n<td><strong>AAAA record</strong></td>\n<td>DNS resource record type 28 containing 128-bit IPv6 address</td>\n<td>IPv6 equivalent of A records</td>\n</tr>\n<tr>\n<td><strong>CNAME record</strong></td>\n<td>DNS resource record type 5 containing canonical name alias pointing to another domain</td>\n<td>Requires special handling during resolution</td>\n</tr>\n<tr>\n<td><strong>MX record</strong></td>\n<td>DNS resource record type 15 containing mail exchange server information with priority</td>\n<td>Email routing records handled by authoritative server</td>\n</tr>\n<tr>\n<td><strong>NS record</strong></td>\n<td>DNS resource record type 2 containing authoritative nameserver for a domain</td>\n<td>Critical for delegation and referrals in recursive resolution</td>\n</tr>\n<tr>\n<td><strong>SOA record</strong></td>\n<td>DNS resource record type 6 containing Start of Authority information for a zone</td>\n<td>Required for authoritative responses and negative caching</td>\n</tr>\n<tr>\n<td><strong>TXT record</strong></td>\n<td>DNS resource record type 16 containing arbitrary text data</td>\n<td>General-purpose record type for various applications</td>\n</tr>\n<tr>\n<td><strong>glue records</strong></td>\n<td>A or AAAA records for nameservers within their own delegated zone, preventing circular dependencies</td>\n<td>Essential for resolving delegation loops in recursive resolution</td>\n</tr>\n</tbody></table>\n<h3 id=\"caching-and-performance-concepts\">Caching and Performance Concepts</h3>\n<p>These terms are central to Milestone 4 (Caching &amp; Performance) and performance optimization throughout the implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>negative caching</strong></td>\n<td>Caching NXDOMAIN and NODATA responses to avoid repeated queries for non-existent domains</td>\n<td>Performance optimization preventing unnecessary repeated resolution attempts</td>\n</tr>\n<tr>\n<td><strong>cache poisoning</strong></td>\n<td>Security attack where false DNS data is injected into resolver cache</td>\n<td>Security concern addressed by response validation</td>\n</tr>\n<tr>\n<td><strong>bailiwick</strong></td>\n<td>Domain hierarchy validation ensuring DNS responses only contain records within the queried domain&#39;s authority</td>\n<td>Security mechanism preventing cache poisoning</td>\n</tr>\n<tr>\n<td><strong>TTL expiration</strong></td>\n<td>Process where cached DNS records become invalid after their time-to-live countdown reaches zero</td>\n<td>Automatic cache management maintaining data freshness</td>\n</tr>\n<tr>\n<td><strong>cache hit rate</strong></td>\n<td>Percentage of DNS queries served from cache without requiring resolution</td>\n<td>Key performance metric for cache effectiveness</td>\n</tr>\n<tr>\n<td><strong>LRU eviction</strong></td>\n<td>Least Recently Used cache replacement policy removing oldest entries when cache reaches capacity limits</td>\n<td>Memory management strategy for bounded cache size</td>\n</tr>\n<tr>\n<td><strong>query coalescing</strong></td>\n<td>Optimization technique sharing resolution work between concurrent identical queries</td>\n<td>Performance optimization preventing duplicate resolution work</td>\n</tr>\n<tr>\n<td><strong>thundering herd</strong></td>\n<td>Performance problem where many concurrent clients make identical requests during cache misses</td>\n<td>Problem addressed by query coalescing</td>\n</tr>\n</tbody></table>\n<h3 id=\"resolution-process-and-state-management\">Resolution Process and State Management</h3>\n<p>These terms describe the complex stateful processes involved in DNS resolution, particularly relevant to Milestone 3.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>resolution state</strong></td>\n<td>Data structure tracking current progress through recursive resolution including visited servers and CNAME chains</td>\n<td>State management for complex resolution processes</td>\n</tr>\n<tr>\n<td><strong>CNAME following</strong></td>\n<td>Process of resolving alias chains to final target records by making additional queries</td>\n<td>Algorithm required during recursive resolution</td>\n</tr>\n<tr>\n<td><strong>circular dependency</strong></td>\n<td>Situation where nameserver resolution requires querying the nameserver itself</td>\n<td>Problem solved by glue records</td>\n</tr>\n<tr>\n<td><strong>referral</strong></td>\n<td>NS records in authority section directing resolver to query different nameservers</td>\n<td>Core mechanism of iterative resolution</td>\n</tr>\n<tr>\n<td><strong>delegation</strong></td>\n<td>Assignment of authority for subdomain to different nameservers using NS records</td>\n<td>Organizational mechanism enabling distributed DNS</td>\n</tr>\n<tr>\n<td><strong>loop detection</strong></td>\n<td>Algorithm preventing infinite loops during recursive resolution or CNAME following</td>\n<td>Safety mechanism preventing resolver hang</td>\n</tr>\n<tr>\n<td><strong>compression loops</strong></td>\n<td>Circular references in DNS name compression pointers creating infinite parsing loops</td>\n<td>Parsing error requiring detection and recovery</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-protocol-compliance\">Error Handling and Protocol Compliance</h3>\n<p>These terms relate to error conditions, edge cases, and protocol compliance across all milestones.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>RCODE</strong></td>\n<td>Response code field in DNS header indicating query outcome (NOERROR, NXDOMAIN, SERVFAIL, etc.)</td>\n<td>Status communication in DNS protocol</td>\n</tr>\n<tr>\n<td><strong>NXDOMAIN</strong></td>\n<td>DNS response code indicating queried domain name does not exist</td>\n<td>Common negative response requiring special caching</td>\n</tr>\n<tr>\n<td><strong>SERVFAIL</strong></td>\n<td>DNS response code indicating server encountered error processing query</td>\n<td>Generic error response for internal failures</td>\n</tr>\n<tr>\n<td><strong>FORMERR</strong></td>\n<td>DNS response code indicating query contained format errors</td>\n<td>Response to malformed incoming queries</td>\n</tr>\n<tr>\n<td><strong>protocol violations</strong></td>\n<td>DNS messages that deviate from RFC 1035 specifications</td>\n<td>Error category requiring detection and appropriate responses</td>\n</tr>\n<tr>\n<td><strong>malformed queries</strong></td>\n<td>DNS queries with invalid structure, incorrect lengths, or missing required fields</td>\n<td>Input validation concern across all query processing</td>\n</tr>\n<tr>\n<td><strong>bounds checking</strong></td>\n<td>Validation ensuring parsing operations don&#39;t read beyond buffer limits</td>\n<td>Essential safety mechanism in binary protocol parsing</td>\n</tr>\n<tr>\n<td><strong>parse errors</strong></td>\n<td>Failures during conversion of binary DNS messages to internal data structures</td>\n<td>Error category specific to message parsing</td>\n</tr>\n<tr>\n<td><strong>truncation</strong></td>\n<td>DNS mechanism indicating UDP response was too large and client should retry over TCP</td>\n<td>Protocol feature for handling oversized responses</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-and-architecture-concepts\">Implementation and Architecture Concepts</h3>\n<p>These terms describe the internal architecture and implementation patterns used throughout the DNS server.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>parse state</strong></td>\n<td>Data structure tracking current position and context during DNS message parsing</td>\n<td>Implementation pattern for stateful parsing</td>\n</tr>\n<tr>\n<td><strong>message handler</strong></td>\n<td>Component interface responsible for coordinating query processing between different resolution strategies</td>\n<td>Architectural pattern for component integration</td>\n</tr>\n<tr>\n<td><strong>cache manager</strong></td>\n<td>Component responsible for TTL-based caching, eviction, and memory management</td>\n<td>Core component implementing caching functionality</td>\n</tr>\n<tr>\n<td><strong>zone data manager</strong></td>\n<td>Component managing authoritative DNS records loaded from zone files</td>\n<td>Core component for authoritative server functionality</td>\n</tr>\n<tr>\n<td><strong>query processing pipeline</strong></td>\n<td>Sequence of operations from UDP packet receipt through parsing, resolution, and response transmission</td>\n<td>Architectural pattern organizing request processing</td>\n</tr>\n<tr>\n<td><strong>component interface contracts</strong></td>\n<td>Method signatures and data exchange formats between major system components</td>\n<td>Design pattern ensuring loose coupling</td>\n</tr>\n<tr>\n<td><strong>context propagation</strong></td>\n<td>Passing timeout and cancellation signals through component method calls</td>\n<td>Concurrency pattern for request lifecycle management</td>\n</tr>\n<tr>\n<td><strong>concurrent query handling</strong></td>\n<td>Processing multiple DNS requests simultaneously using goroutines or threads</td>\n<td>Performance requirement for production DNS servers</td>\n</tr>\n<tr>\n<td><strong>atomic operations</strong></td>\n<td>Thread-safe operations for updating statistics without explicit locking</td>\n<td>Concurrency pattern for shared counter management</td>\n</tr>\n<tr>\n<td><strong>read-write mutex</strong></td>\n<td>Synchronization primitive allowing concurrent reads but exclusive writes to shared data</td>\n<td>Concurrency pattern for cache access</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-development-concepts\">Testing and Development Concepts</h3>\n<p>These terms relate to testing strategies, debugging techniques, and development practices across all milestones.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>milestone checkpoints</strong></td>\n<td>Verification steps confirming correct behavior after completing each development phase</td>\n<td>Development methodology ensuring incremental progress</td>\n</tr>\n<tr>\n<td><strong>unit testing</strong></td>\n<td>Testing individual components in isolation with mock dependencies</td>\n<td>Testing strategy for component verification</td>\n</tr>\n<tr>\n<td><strong>integration testing</strong></td>\n<td>Testing interactions between components with real dependencies</td>\n<td>Testing strategy for system behavior verification</td>\n</tr>\n<tr>\n<td><strong>mock network client</strong></td>\n<td>Simulated network infrastructure for testing without external dependencies</td>\n<td>Testing utility for controlled environment testing</td>\n</tr>\n<tr>\n<td><strong>race conditions</strong></td>\n<td>Timing-dependent bugs in concurrent code where outcome depends on execution order</td>\n<td>Common bug pattern in concurrent DNS server implementation</td>\n</tr>\n<tr>\n<td><strong>concurrent testing</strong></td>\n<td>Validation of thread-safe behavior under concurrent load</td>\n<td>Testing strategy for concurrency correctness</td>\n</tr>\n<tr>\n<td><strong>compression loop</strong></td>\n<td>Specific bug where DNS pointer labels create circular references causing infinite parsing loops</td>\n<td>Common parsing implementation bug</td>\n</tr>\n<tr>\n<td><strong>cache integration</strong></td>\n<td>Thread-safe access to cached records with proper TTL management and synchronization</td>\n<td>Implementation pattern for cache component usage</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-dns-concepts-and-extensions\">Advanced DNS Concepts and Extensions</h3>\n<p>These terms relate to advanced DNS features and potential future enhancements beyond the core implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DNSSEC</strong></td>\n<td>DNS Security Extensions providing cryptographic authentication of DNS responses</td>\n<td>Advanced security feature for future implementation</td>\n</tr>\n<tr>\n<td><strong>EDNS</strong></td>\n<td>Extension Mechanisms for DNS allowing larger messages, additional flags, and protocol extensions</td>\n<td>Protocol extension for enhanced functionality</td>\n</tr>\n<tr>\n<td><strong>DNS-over-TLS (DoT)</strong></td>\n<td>Encrypted DNS transport layer providing privacy and security</td>\n<td>Modern DNS transport option</td>\n</tr>\n<tr>\n<td><strong>DNS-over-HTTPS (DoH)</strong></td>\n<td>DNS queries embedded in HTTP/2 requests for privacy and firewall traversal</td>\n<td>Alternative encrypted DNS transport</td>\n</tr>\n<tr>\n<td><strong>trust anchor</strong></td>\n<td>Cryptographic root of trust for DNSSEC validation chain</td>\n<td>Security concept for authenticated DNS</td>\n</tr>\n</tbody></table>\n<h3 id=\"operational-and-performance-terms\">Operational and Performance Terms</h3>\n<p>These terms describe operational aspects, monitoring, and production deployment considerations.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>metrics collection</strong></td>\n<td>Gathering performance statistics, query counts, and operational health indicators</td>\n<td>Production readiness feature for monitoring</td>\n</tr>\n<tr>\n<td><strong>cache warming</strong></td>\n<td>Preloading cache with frequently accessed records to minimize cold start performance impact</td>\n<td>Operational optimization technique</td>\n</tr>\n<tr>\n<td><strong>configuration management</strong></td>\n<td>Dynamic server configuration updates without requiring restart</td>\n<td>Operational requirement for production deployment</td>\n</tr>\n<tr>\n<td><strong>circuit breaking</strong></td>\n<td>Pattern preventing cascading failures by stopping requests to consistently failing upstream services</td>\n<td>Resilience pattern for production stability</td>\n</tr>\n<tr>\n<td><strong>exponential backoff</strong></td>\n<td>Retry delay strategy that increases wait time after each failure attempt</td>\n<td>Common retry pattern for network operations</td>\n</tr>\n<tr>\n<td><strong>blue-green deployment</strong></td>\n<td>Deployment pattern using two identical environments for zero-downtime updates</td>\n<td>Production deployment strategy</td>\n</tr>\n</tbody></table>\n<h3 id=\"wire-protocol-and-binary-parsing-terms\">Wire Protocol and Binary Parsing Terms</h3>\n<p>These terms describe low-level binary protocol handling essential for Milestone 1 implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DNS_HEADER_SIZE</strong></td>\n<td>Constant value 12 representing fixed size of DNS message header in bytes</td>\n<td>Binary protocol constant</td>\n</tr>\n<tr>\n<td><strong>DNS_UDP_MAX_SIZE</strong></td>\n<td>Constant value 512 representing maximum DNS message size for UDP transport</td>\n<td>Protocol limitation requiring truncation handling</td>\n</tr>\n<tr>\n<td><strong>endianness</strong></td>\n<td>Byte order used in multi-byte values, with DNS using big-endian network byte order</td>\n<td>Binary parsing consideration</td>\n</tr>\n<tr>\n<td><strong>null termination</strong></td>\n<td>DNS name encoding requirement where domain names end with zero-length label</td>\n<td>Protocol requirement for name parsing</td>\n</tr>\n<tr>\n<td><strong>type codes</strong></td>\n<td>Numeric identifiers for DNS record types (A=1, AAAA=28, CNAME=5, etc.)</td>\n<td>Protocol constants for record type identification</td>\n</tr>\n<tr>\n<td><strong>class codes</strong></td>\n<td>Numeric identifiers for DNS classes, typically IN=1 for Internet class</td>\n<td>Protocol constants rarely used beyond Internet class</td>\n</tr>\n</tbody></table>\n<h3 id=\"state-machine-and-process-control-terms\">State Machine and Process Control Terms</h3>\n<p>These terms describe the state-driven aspects of DNS server operation and control flow.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>query lifecycle</strong></td>\n<td>Complete sequence of states from query receipt through parsing, resolution, caching, and response</td>\n<td>Process model for understanding query handling</td>\n</tr>\n<tr>\n<td><strong>resolution priority</strong></td>\n<td>Order of attempting authoritative lookup, cache lookup, and recursive resolution</td>\n<td>Algorithm decision tree for query processing</td>\n</tr>\n<tr>\n<td><strong>error boundaries</strong></td>\n<td>Isolation points preventing error propagation between system components</td>\n<td>Architectural pattern for fault isolation</td>\n</tr>\n<tr>\n<td><strong>retry logic</strong></td>\n<td>Automated mechanisms for recovering from transient network or server failures</td>\n<td>Resilience pattern for unreliable network conditions</td>\n</tr>\n<tr>\n<td><strong>timeout handling</strong></td>\n<td>Mechanisms for abandoning operations that exceed time limits</td>\n<td>Essential for preventing hung requests</td>\n</tr>\n<tr>\n<td><strong>backpressure</strong></td>\n<td>Flow control mechanism preventing overwhelming of downstream components</td>\n<td>Performance pattern for load management</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight: Terminology Precision Enables Clear Communication</strong></p>\n<p>The precision of these definitions directly impacts implementation success. When developers share exact meanings for terms like &quot;bailiwick validation&quot; or &quot;query coalescing,&quot; they can communicate complex architectural decisions unambiguously. Conversely, loose terminology leads to misunderstood requirements and subtle bugs.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This glossary serves as the canonical reference for all technical terms throughout the DNS server implementation. When encountering unfamiliar terminology in code reviews, documentation, or debugging sessions, developers should refer to these definitions for authoritative understanding.</p>\n<p>The terms are organized to support the milestone-driven development approach:</p>\n<ul>\n<li><strong>Milestone 1 terms</strong> focus on binary protocol parsing, message structure, and wire format concepts</li>\n<li><strong>Milestone 2 terms</strong> emphasize authoritative server concepts, zone data, and response construction</li>\n<li><strong>Milestone 3 terms</strong> center on recursive resolution, iterative queries, and DNS hierarchy traversal</li>\n<li><strong>Milestone 4 terms</strong> concentrate on caching strategies, performance optimization, and concurrent operations</li>\n</ul>\n<p>Each definition includes context about when and why the term is important, helping developers understand not just what concepts mean, but how they fit into the broader DNS server architecture. This contextual understanding proves invaluable when making implementation decisions or diagnosing system behavior.</p>\n","toc":[{"level":1,"text":"DNS Server: Design Document","id":"dns-server-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: DNS as a Postal System","id":"mental-model-dns-as-a-postal-system"},{"level":3,"text":"Resolution Approaches Comparison","id":"resolution-approaches-comparison"},{"level":4,"text":"Authoritative-Only Servers","id":"authoritative-only-servers"},{"level":4,"text":"Forwarding Servers","id":"forwarding-servers"},{"level":4,"text":"Recursive Resolvers","id":"recursive-resolvers"},{"level":4,"text":"Architecture Decision: Resolution Approach Selection","id":"architecture-decision-resolution-approach-selection"},{"level":4,"text":"Hybrid Approaches and Operational Considerations","id":"hybrid-approaches-and-operational-considerations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeletons","id":"core-logic-skeletons"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":4,"text":"Core Protocol Implementation","id":"core-protocol-implementation"},{"level":4,"text":"Authoritative DNS Service","id":"authoritative-dns-service"},{"level":4,"text":"Recursive Resolution Engine","id":"recursive-resolution-engine"},{"level":4,"text":"Caching and Performance Optimization","id":"caching-and-performance-optimization"},{"level":3,"text":"Non-Goals","id":"non-goals"},{"level":4,"text":"Security and Cryptographic Features","id":"security-and-cryptographic-features"},{"level":4,"text":"Advanced Protocol Extensions","id":"advanced-protocol-extensions"},{"level":4,"text":"Production Operational Features","id":"production-operational-features"},{"level":4,"text":"Performance and Scale Limitations","id":"performance-and-scale-limitations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Stack Recommendations","id":"technology-stack-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Core Data Structure Definitions","id":"core-data-structure-definitions"},{"level":4,"text":"Server Configuration Structure","id":"server-configuration-structure"},{"level":4,"text":"Milestone Implementation Checkpoints","id":"milestone-implementation-checkpoints"},{"level":4,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"UDP Server Component","id":"udp-server-component"},{"level":4,"text":"Message Parser Component","id":"message-parser-component"},{"level":4,"text":"Recursive Resolver Component","id":"recursive-resolver-component"},{"level":4,"text":"Cache Manager Component","id":"cache-manager-component"},{"level":4,"text":"Zone Data Manager Component","id":"zone-data-manager-component"},{"level":3,"text":"Architecture Decisions for Component Design","id":"architecture-decisions-for-component-design"},{"level":3,"text":"Component Interface Contracts","id":"component-interface-contracts"},{"level":4,"text":"Core Data Exchange Types","id":"core-data-exchange-types"},{"level":4,"text":"Message Parser Interface","id":"message-parser-interface"},{"level":4,"text":"Resolver Interface","id":"resolver-interface"},{"level":4,"text":"Cache Manager Interface","id":"cache-manager-interface"},{"level":3,"text":"Common Component Pitfalls","id":"common-component-pitfalls"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Core Server Infrastructure","id":"core-server-infrastructure"},{"level":4,"text":"DNS Message Data Structures","id":"dns-message-data-structures"},{"level":4,"text":"Basic Cache Interface","id":"basic-cache-interface"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Mental Model: DNS Data as Structured Documents","id":"mental-model-dns-data-as-structured-documents"},{"level":3,"text":"DNS Message Format","id":"dns-message-format"},{"level":4,"text":"DNS Message Structure Overview","id":"dns-message-structure-overview"},{"level":4,"text":"Header Structure Details","id":"header-structure-details"},{"level":4,"text":"Question Section Structure","id":"question-section-structure"},{"level":4,"text":"Resource Record Structure","id":"resource-record-structure"},{"level":4,"text":"Name Compression Algorithm","id":"name-compression-algorithm"},{"level":4,"text":"Message Size and Truncation Handling","id":"message-size-and-truncation-handling"},{"level":3,"text":"Cache and Zone Data Structures","id":"cache-and-zone-data-structures"},{"level":4,"text":"Cache Key and Entry Structure","id":"cache-key-and-entry-structure"},{"level":4,"text":"Zone Data Organization","id":"zone-data-organization"},{"level":4,"text":"Cache Operations and TTL Management","id":"cache-operations-and-ttl-management"},{"level":4,"text":"Negative Caching Implementation","id":"negative-caching-implementation"},{"level":4,"text":"Thread Safety and Concurrent Access","id":"thread-safety-and-concurrent-access"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"DNS Message Infrastructure Code","id":"dns-message-infrastructure-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Zone Data Management","id":"zone-data-management"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":2,"text":"DNS Message Parsing (Milestone 1)","id":"dns-message-parsing-milestone-1"},{"level":3,"text":"Mental Model: DNS as Structured Binary Documents","id":"mental-model-dns-as-structured-binary-documents"},{"level":3,"text":"Name Compression Algorithm","id":"name-compression-algorithm"},{"level":3,"text":"Architecture Decisions for Parsing","id":"architecture-decisions-for-parsing"},{"level":3,"text":"Common Parsing Pitfalls","id":"common-parsing-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Authoritative Server (Milestone 2)","id":"authoritative-server-milestone-2"},{"level":3,"text":"Mental Model: Zones as Local Phone Books","id":"mental-model-zones-as-local-phone-books"},{"level":3,"text":"Zone File Parsing Algorithm","id":"zone-file-parsing-algorithm"},{"level":3,"text":"Query Matching and Response Construction","id":"query-matching-and-response-construction"},{"level":3,"text":"Architecture Decisions for Authority","id":"architecture-decisions-for-authority"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code: Zone File Parser","id":"infrastructure-starter-code-zone-file-parser"},{"level":4,"text":"Core Logic Skeleton: Query Processing","id":"core-logic-skeleton-query-processing"},{"level":4,"text":"Language-Specific Hints for Go","id":"language-specific-hints-for-go"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Recursive Resolver (Milestone 3)","id":"recursive-resolver-milestone-3"},{"level":3,"text":"Mental Model: Recursive Resolution as Detective Work","id":"mental-model-recursive-resolution-as-detective-work"},{"level":3,"text":"Iterative Resolution Algorithm","id":"iterative-resolution-algorithm"},{"level":3,"text":"Glue Records and Circular Dependencies","id":"glue-records-and-circular-dependencies"},{"level":3,"text":"Architecture Decisions for Recursion","id":"architecture-decisions-for-recursion"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Caching and Performance (Milestone 4)","id":"caching-and-performance-milestone-4"},{"level":3,"text":"Mental Model: Cache as Recent Memory","id":"mental-model-cache-as-recent-memory"},{"level":3,"text":"TTL-Based Cache Management","id":"ttl-based-cache-management"},{"level":3,"text":"Negative Caching Strategy","id":"negative-caching-strategy"},{"level":3,"text":"Concurrent Query Processing","id":"concurrent-query-processing"},{"level":3,"text":"Architecture Decisions for Caching","id":"architecture-decisions-for-caching"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Cache Manager Implementation","id":"cache-manager-implementation"},{"level":4,"text":"Concurrent Query Handler","id":"concurrent-query-handler"},{"level":4,"text":"File Structure Organization","id":"file-structure-organization"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Mental Model: DNS Server as a Restaurant Kitchen","id":"mental-model-dns-server-as-a-restaurant-kitchen"},{"level":2,"text":"Query Processing Flow","id":"query-processing-flow"},{"level":3,"text":"Inbound Query Processing Pipeline","id":"inbound-query-processing-pipeline"},{"level":3,"text":"Authoritative Query Path","id":"authoritative-query-path"},{"level":3,"text":"Recursive Query Path","id":"recursive-query-path"},{"level":3,"text":"Error Handling Flow","id":"error-handling-flow"},{"level":2,"text":"Component Interface Contracts","id":"component-interface-contracts"},{"level":3,"text":"Server to Message Handler Interface","id":"server-to-message-handler-interface"},{"level":3,"text":"Message Handler to Resolver Interface","id":"message-handler-to-resolver-interface"},{"level":3,"text":"Cache Manager Interface Contracts","id":"cache-manager-interface-contracts"},{"level":3,"text":"Zone Data Manager Interface","id":"zone-data-manager-interface"},{"level":3,"text":"Network Client Interface","id":"network-client-interface"},{"level":3,"text":"Data Exchange Formats","id":"data-exchange-formats"},{"level":4,"text":"DNS Message Exchange Format","id":"dns-message-exchange-format"},{"level":4,"text":"Cache Entry Exchange","id":"cache-entry-exchange"},{"level":3,"text":"Common Pitfalls in Component Interactions","id":"common-pitfalls-in-component-interactions"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Flow Coordination","id":"core-data-flow-coordination"},{"level":4,"text":"Component Interface Implementation","id":"component-interface-implementation"},{"level":4,"text":"Cache Integration Pattern","id":"cache-integration-pattern"},{"level":4,"text":"Error Handling Patterns","id":"error-handling-patterns"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Mental Model: Error Handling as Immune System Response","id":"mental-model-error-handling-as-immune-system-response"},{"level":3,"text":"Error Categories and Recovery","id":"error-categories-and-recovery"},{"level":4,"text":"Parse and Protocol Errors","id":"parse-and-protocol-errors"},{"level":4,"text":"Network and Transport Errors","id":"network-and-transport-errors"},{"level":4,"text":"Resolution and Logic Errors","id":"resolution-and-logic-errors"},{"level":3,"text":"DNS Protocol Edge Cases","id":"dns-protocol-edge-cases"},{"level":4,"text":"Malformed Query Handling","id":"malformed-query-handling"},{"level":4,"text":"Oversized Response Management","id":"oversized-response-management"},{"level":4,"text":"Protocol Violation Recovery","id":"protocol-violation-recovery"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Error Handling Structure","id":"recommended-error-handling-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: Testing as Safety Nets","id":"mental-model-testing-as-safety-nets"},{"level":3,"text":"Unit Testing Approach","id":"unit-testing-approach"},{"level":4,"text":"Message Parsing Test Strategy","id":"message-parsing-test-strategy"},{"level":4,"text":"Authoritative Server Test Strategy","id":"authoritative-server-test-strategy"},{"level":4,"text":"Recursive Resolver Test Strategy","id":"recursive-resolver-test-strategy"},{"level":4,"text":"Cache Manager Test Strategy","id":"cache-manager-test-strategy"},{"level":3,"text":"Common Testing Pitfalls","id":"common-testing-pitfalls"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Milestone 1: DNS Message Parsing Checkpoint","id":"milestone-1-dns-message-parsing-checkpoint"},{"level":4,"text":"Milestone 2: Authoritative Server Checkpoint","id":"milestone-2-authoritative-server-checkpoint"},{"level":4,"text":"Milestone 3: Recursive Resolver Checkpoint","id":"milestone-3-recursive-resolver-checkpoint"},{"level":4,"text":"Milestone 4: Caching and Performance Checkpoint","id":"milestone-4-caching-and-performance-checkpoint"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Test File Structure","id":"test-file-structure"},{"level":4,"text":"Mock Network Client Infrastructure","id":"mock-network-client-infrastructure"},{"level":4,"text":"Test Data Generation Utilities","id":"test-data-generation-utilities"},{"level":4,"text":"Parser Testing Skeleton","id":"parser-testing-skeleton"},{"level":4,"text":"Cache Testing Skeleton","id":"cache-testing-skeleton"},{"level":4,"text":"Integration Test Framework","id":"integration-test-framework"},{"level":4,"text":"Milestone Checkpoint Automation","id":"milestone-checkpoint-automation"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Mental Model: DNS Debugging as Medical Diagnosis","id":"mental-model-dns-debugging-as-medical-diagnosis"},{"level":3,"text":"Common Bug Patterns","id":"common-bug-patterns"},{"level":4,"text":"Parsing and Message Construction Bugs","id":"parsing-and-message-construction-bugs"},{"level":4,"text":"Recursive Resolution Logic Bugs","id":"recursive-resolution-logic-bugs"},{"level":4,"text":"Caching and Concurrency Bugs","id":"caching-and-concurrency-bugs"},{"level":4,"text":"Network and Protocol Handling Bugs","id":"network-and-protocol-handling-bugs"},{"level":4,"text":"Zone Data and Configuration Bugs","id":"zone-data-and-configuration-bugs"},{"level":3,"text":"Debugging Tools and Techniques","id":"debugging-tools-and-techniques"},{"level":4,"text":"Command-Line DNS Tools","id":"command-line-dns-tools"},{"level":4,"text":"Network Traffic Analysis","id":"network-traffic-analysis"},{"level":4,"text":"Logging and Monitoring Strategies","id":"logging-and-monitoring-strategies"},{"level":4,"text":"Systematic Debugging Methodology","id":"systematic-debugging-methodology"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Debugging Infrastructure","id":"recommended-debugging-infrastructure"},{"level":4,"text":"Core Debugging Integration Points","id":"core-debugging-integration-points"},{"level":4,"text":"Milestone Debugging Checkpoints","id":"milestone-debugging-checkpoints"},{"level":4,"text":"Language-Specific Debugging Hints","id":"language-specific-debugging-hints"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Mental Model: DNS Server Evolution as Infrastructure Maturation","id":"mental-model-dns-server-evolution-as-infrastructure-maturation"},{"level":2,"text":"Protocol Extensions","id":"protocol-extensions"},{"level":3,"text":"Mental Model: Protocol Extensions as Language Dialects","id":"mental-model-protocol-extensions-as-language-dialects"},{"level":3,"text":"DNSSEC (DNS Security Extensions)","id":"dnssec-dns-security-extensions"},{"level":3,"text":"EDNS (Extension Mechanisms for DNS)","id":"edns-extension-mechanisms-for-dns"},{"level":3,"text":"DNS-over-HTTPS (DoH) and DNS-over-TLS (DoT)","id":"dns-over-https-doh-and-dns-over-tls-dot"},{"level":2,"text":"Operational Features","id":"operational-features"},{"level":3,"text":"Mental Model: DNS Operations as Service Management","id":"mental-model-dns-operations-as-service-management"},{"level":3,"text":"Metrics and Monitoring","id":"metrics-and-monitoring"},{"level":3,"text":"Configuration Management","id":"configuration-management"},{"level":3,"text":"Deployment and Scaling","id":"deployment-and-scaling"},{"level":3,"text":"Logging and Audit Trail","id":"logging-and-audit-trail"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: Technical Glossary as a Shared Language Dictionary","id":"mental-model-technical-glossary-as-a-shared-language-dictionary"},{"level":3,"text":"DNS Protocol Fundamentals","id":"dns-protocol-fundamentals"},{"level":3,"text":"DNS Message Structure and Protocol Details","id":"dns-message-structure-and-protocol-details"},{"level":3,"text":"DNS Record Types and Classes","id":"dns-record-types-and-classes"},{"level":3,"text":"Caching and Performance Concepts","id":"caching-and-performance-concepts"},{"level":3,"text":"Resolution Process and State Management","id":"resolution-process-and-state-management"},{"level":3,"text":"Error Handling and Protocol Compliance","id":"error-handling-and-protocol-compliance"},{"level":3,"text":"Implementation and Architecture Concepts","id":"implementation-and-architecture-concepts"},{"level":3,"text":"Testing and Development Concepts","id":"testing-and-development-concepts"},{"level":3,"text":"Advanced DNS Concepts and Extensions","id":"advanced-dns-concepts-and-extensions"},{"level":3,"text":"Operational and Performance Terms","id":"operational-and-performance-terms"},{"level":3,"text":"Wire Protocol and Binary Parsing Terms","id":"wire-protocol-and-binary-parsing-terms"},{"level":3,"text":"State Machine and Process Control Terms","id":"state-machine-and-process-control-terms"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"}],"title":"DNS Server: Design Document","markdown":"# DNS Server: Design Document\n\n\n## Overview\n\nA recursive DNS server that resolves domain names by implementing the DNS protocol, following referrals from root servers through the DNS hierarchy, and caching responses for performance. The key architectural challenge is managing stateful recursive resolution while handling concurrent queries and maintaining cache consistency with TTL-based expiration.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** Foundational understanding for all milestones (1-4)\n\nThe Domain Name System (DNS) serves as the internet's address book, translating human-readable domain names like `google.com` into IP addresses like `142.250.191.14` that computers use to communicate. While this translation might seem straightforward, the underlying challenge involves creating a distributed, hierarchical system that can handle billions of queries per day with sub-second response times. Building a DNS server requires understanding not just the protocol mechanics, but the fundamental approaches to name resolution and the architectural trade-offs each approach entails.\n\n### Mental Model: DNS as a Postal System\n\nThink of DNS resolution as navigating a vast postal system where you need to deliver a letter but only have a partial address. Imagine you have a letter addressed to \"John Smith, Apartment 42, Oak Street, Springfield\" but you don't know which state Springfield is in, or even which country. The DNS hierarchy works exactly like a postal routing system with multiple levels of knowledge and authority.\n\nAt the top level, you have **root mail sorters** (DNS root servers) who don't know about every address in the world, but they know which regional postal centers handle which top-level regions. When you ask a root sorter about \"Springfield,\" they can't give you John Smith's exact location, but they can tell you \"all '.com' addresses go to the Commercial Postal Region\" and give you the address of that regional center.\n\nThe **regional postal centers** (DNS TLD servers) know about all the major districts in their region. When you ask the Commercial Postal Region about \"google.com,\" they can't tell you about specific departments within Google, but they know \"all google.com mail goes to Google's corporate mail center\" and provide you with that center's address.\n\nFinally, the **local mail centers** (authoritative DNS servers) have complete knowledge of their specific district. When you reach Google's mail center asking about \"www.google.com,\" they have authoritative knowledge and can give you the exact building address (IP address) where that service is located.\n\nThe key insight is that **no single entity knows everything**, but each level of the hierarchy knows exactly who to ask next. Root servers know about TLD servers, TLD servers know about domain-specific servers, and authoritative servers know about the actual hosts. This distributed knowledge creates a system that scales to billions of domains without any single point of knowledge becoming a bottleneck.\n\nThe **caching mechanism** works like a mail carrier's local knowledge. After delivering mail to Springfield several times, the carrier remembers the route and doesn't need to ask the regional center every time. However, this knowledge has an expiration date (TTL) because addresses can change, and the carrier needs to refresh their knowledge periodically.\n\n### Resolution Approaches Comparison\n\nDNS servers can operate using three fundamentally different approaches to name resolution, each with distinct architectural implications and use cases. Understanding these approaches is crucial because the choice affects every aspect of your server's design, from data storage patterns to network communication flows.\n\n#### Authoritative-Only Servers\n\n**Authoritative DNS servers** are like local post offices that have complete, definitive knowledge about addresses in their specific district, but no knowledge about addresses outside their jurisdiction. When someone asks about an address in their district, they provide the definitive answer. When asked about anywhere else, they essentially respond \"I don't know, and I'm not going to find out for you.\"\n\nAn authoritative server loads **zone data** from configuration files (zone files) that contain the complete mapping of domain names to IP addresses for domains under its authority. For example, Google's authoritative servers know that `www.google.com` points to specific IP addresses, but they have no information about `facebook.com` and will not attempt to resolve it.\n\n| Aspect | Authoritative Server Characteristics |\n|--------|-------------------------------------|\n| **Data Source** | Zone files containing domain-to-IP mappings for owned domains |\n| **Query Scope** | Only answers queries for domains in its configured zones |\n| **Response Behavior** | Provides definitive answers for owned domains, rejects others |\n| **Caching Requirements** | No caching needed (always has authoritative data) |\n| **Network Dependencies** | None (operates entirely from local zone data) |\n| **Primary Use Case** | Hosting DNS records for specific domain owners |\n\nThe architecture of an authoritative server is relatively straightforward because it never needs to contact other servers. It parses incoming queries, checks if the requested domain exists in its zone data, and either provides the authoritative answer or returns an \"I don't handle that domain\" response.\n\n#### Forwarding Servers\n\n**Forwarding DNS servers** operate like mail forwarding services. They don't have knowledge of addresses themselves, and they don't do the detective work of tracking down unknown addresses. Instead, they simply pass every query to another DNS server (the forwarder) and relay the response back to the client.\n\nThink of a forwarding server as a receptionist at a small office who doesn't know anyone's direct phone numbers, but always transfers calls to the main corporate directory service. The receptionist adds no knowledge to the process but provides a consistent interface and potentially some local benefits like access control or logging.\n\n| Aspect | Forwarding Server Characteristics |\n|--------|-----------------------------------|\n| **Data Source** | No local DNS data; relies entirely on upstream forwarder |\n| **Query Scope** | Forwards all queries to configured upstream server |\n| **Response Behavior** | Relays responses from upstream server without modification |\n| **Caching Requirements** | Optional local caching to improve response times |\n| **Network Dependencies** | Complete dependency on upstream forwarder availability |\n| **Primary Use Case** | Corporate networks, ISPs providing simple DNS service |\n\nForwarding servers are often used in corporate environments where network policies require all DNS traffic to go through specific servers, or by ISPs who want to provide DNS service without the complexity of running a full recursive resolver.\n\n#### Recursive Resolvers\n\n**Recursive DNS servers** are like detective agencies that will track down any address you ask them about, no matter where in the world it might be. When you ask a recursive resolver about an address it doesn't know, it doesn't just give up or forward the question elsewhere. Instead, it starts its own investigation, following the postal system hierarchy from the top down until it finds the definitive answer.\n\nThe recursive resolver implements the **iterative resolution process**: it starts by asking root servers, follows their referrals to TLD servers, then follows those referrals to authoritative servers, and finally returns the authoritative answer to the original client. From the client's perspective, they asked one question and got one complete answer, even though the resolver may have performed dozens of queries behind the scenes.\n\n| Aspect | Recursive Resolver Characteristics |\n|--------|------------------------------------|\n| **Data Source** | No authoritative data; builds knowledge through iterative queries |\n| **Query Scope** | Resolves any domain name in the global DNS namespace |\n| **Response Behavior** | Performs complete resolution and returns final answer |\n| **Caching Requirements** | Extensive caching essential for performance and reduced network load |\n| **Network Dependencies** | Must be able to reach root servers and arbitrary authoritative servers |\n| **Primary Use Case** | ISP DNS servers, public resolvers (8.8.8.8, 1.1.1.1), enterprise DNS |\n\nThe architecture of a recursive resolver is significantly more complex because it must manage **stateful resolution processes**. When a client asks about `www.example.com`, the resolver might need to:\n\n1. Query a root server to learn about `.com` TLD servers\n2. Query a `.com` TLD server to learn about `example.com`'s authoritative servers\n3. Query `example.com`'s authoritative server to get the final answer for `www.example.com`\n4. Return the complete answer to the original client\n\nEach step may involve network timeouts, retries, and following additional referrals, all while maintaining the context of the original query.\n\n![DNS Server System Components](./diagrams/system-components.svg)\n\n#### Architecture Decision: Resolution Approach Selection\n\n> **Decision: Implement Recursive Resolver Architecture**\n> - **Context**: Building an educational DNS server that demonstrates core DNS concepts and protocols while providing practical functionality for learning network programming and distributed systems concepts.\n> - **Options Considered**: \n>   1. Authoritative-only server (simpler implementation, limited scope)\n>   2. Forwarding server (minimal complexity, limited learning value)\n>   3. Recursive resolver (complex but comprehensive learning experience)\n> - **Decision**: Implement a recursive resolver with caching capabilities\n> - **Rationale**: Recursive resolution demonstrates the complete DNS protocol stack, including binary protocol parsing, network programming, hierarchical distributed systems, caching strategies, and concurrent programming. While more complex, it provides the richest learning experience and produces a server that can resolve any domain name, making it immediately useful.\n> - **Consequences**: Requires implementing iterative resolution logic, robust caching with TTL management, concurrent query handling, and comprehensive error handling. The complexity enables learning advanced systems programming concepts but increases implementation time and debugging complexity.\n\n| Resolution Approach | Implementation Complexity | Learning Value | Practical Utility | Network Requirements |\n|---------------------|--------------------------|----------------|-------------------|---------------------|\n| **Authoritative Only** | Low | Medium | Limited to owned domains | None |\n| **Forwarding** | Very Low | Low | Dependent on upstream | Single upstream server |\n| **Recursive** ✓ | High | Very High | Universal DNS resolution | Root server access |\n\nThe recursive resolver approach aligns with the project's educational goals because it requires implementing every layer of the DNS system: binary protocol parsing, network communication, distributed algorithms, caching strategies, and concurrent programming. Students gain experience with real-world systems programming challenges while building something immediately useful.\n\n#### Hybrid Approaches and Operational Considerations\n\nReal-world DNS servers often implement **hybrid approaches** that combine multiple resolution strategies based on the query context. For example, a DNS server might:\n\n- Act as an authoritative server for domains it owns (responding from zone data)\n- Perform recursive resolution for client queries about external domains\n- Forward specific types of queries to specialized servers (like threat intelligence feeds)\n- Implement **conditional forwarding** where certain domain patterns are forwarded to specific servers\n\nOur educational implementation focuses on the recursive resolver core, but the architecture we design will support adding authoritative capabilities in future extensions. This design choice reflects real-world DNS server architecture, where flexibility and extensibility are crucial operational requirements.\n\nThe **performance characteristics** of each approach differ significantly:\n\n| Performance Aspect | Authoritative | Forwarding | Recursive |\n|--------------------|---------------|------------|-----------|\n| **Query Latency** | ~1ms (memory lookup) | ~10-50ms (single upstream query) | ~100-500ms (multiple iterative queries) |\n| **Cache Hit Ratio Impact** | N/A | Medium (reduces upstream load) | Critical (dramatically affects latency) |\n| **Scalability Bottleneck** | Memory for zone data | Upstream server capacity | Network I/O and cache size |\n| **Resource Usage** | Low CPU, moderate memory | Very low CPU/memory | High CPU, high memory |\n\nFor our educational implementation, we prioritize learning value over absolute performance, but we'll implement caching and concurrent query handling to demonstrate how production DNS servers achieve the performance characteristics required for real-world deployment.\n\n### Implementation Guidance\n\nThis implementation guidance provides the foundational code structure and decision framework for building a recursive DNS server in Go. The approach emphasizes modularity and testability while maintaining educational clarity.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **UDP Server** | `net.PacketConn` with goroutine-per-query | `golang.org/x/net/ipv4` with connection pooling |\n| **DNS Parsing** | Manual byte parsing with `binary.BigEndian` | `miekg/dns` library (reduces learning but simplifies) |\n| **Caching** | `sync.Map` with TTL goroutine cleanup | `patrickmn/go-cache` or `golang-lru/v2` |\n| **Configuration** | YAML files with `gopkg.in/yaml.v3` | Environment variables with `kelseyhightower/envconfig` |\n| **Logging** | Standard `log` package with levels | `sirupsen/logrus` or `uber-go/zap` |\n| **Testing** | Standard `testing` package | `stretchr/testify` for assertions and mocks |\n\n**Recommendation**: Use simple options for core DNS functionality (parsing, resolution) to maximize learning, but use advanced options for infrastructure concerns (logging, configuration) to focus effort on DNS-specific challenges.\n\n#### Recommended File Structure\n\n```\ndns-server/\n├── cmd/\n│   ├── dns-server/\n│   │   └── main.go              ← Server entry point and CLI\n│   └── dns-client/\n│       └── main.go              ← Testing client for validation\n├── internal/\n│   ├── server/\n│   │   ├── server.go            ← UDP server and request routing\n│   │   └── server_test.go       \n│   ├── parser/\n│   │   ├── message.go           ← DNS message parsing (Milestone 1)\n│   │   ├── compression.go       ← Name compression handling\n│   │   └── parser_test.go       \n│   ├── resolver/\n│   │   ├── recursive.go         ← Iterative resolution (Milestone 3)\n│   │   ├── authority.go         ← Authoritative responses (Milestone 2)\n│   │   └── resolver_test.go     \n│   ├── cache/\n│   │   ├── cache.go             ← TTL-based caching (Milestone 4)\n│   │   └── cache_test.go        \n│   └── zone/\n│       ├── loader.go            ← Zone file parsing (Milestone 2)\n│       └── zone_test.go         \n├── configs/\n│   ├── root-hints.txt           ← Root server IP addresses\n│   └── example-zone.txt         ← Sample zone file for testing\n├── testdata/\n│   ├── dns-messages/            ← Binary DNS message samples\n│   └── zone-files/              ← Test zone files\n└── go.mod\n```\n\nThis structure separates concerns clearly: `server` handles network I/O, `parser` handles protocol details, `resolver` implements DNS logic, `cache` manages performance, and `zone` handles authoritative data. Each package can be developed and tested independently.\n\n#### Infrastructure Starter Code\n\n**UDP Server Foundation** (`internal/server/server.go`):\n\n```go\npackage server\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net\"\n    \"time\"\n)\n\ntype Server struct {\n    addr     string\n    conn     net.PacketConn\n    resolver Resolver\n    handler  MessageHandler\n}\n\ntype Resolver interface {\n    Resolve(ctx context.Context, question Question) ([]ResourceRecord, error)\n}\n\ntype MessageHandler interface {\n    ParseQuery(data []byte) (*DNSMessage, error)\n    BuildResponse(query *DNSMessage, records []ResourceRecord) ([]byte, error)\n}\n\n// NewServer creates a DNS server that listens on the specified address\nfunc NewServer(addr string, resolver Resolver, handler MessageHandler) *Server {\n    return &Server{\n        addr:     addr,\n        resolver: resolver,\n        handler:  handler,\n    }\n}\n\n// Start begins listening for DNS queries and blocks until context is cancelled\nfunc (s *Server) Start(ctx context.Context) error {\n    // TODO: Implementation provided - this is infrastructure, not core learning\n    conn, err := net.ListenPacket(\"udp\", s.addr)\n    if err != nil {\n        return fmt.Errorf(\"failed to bind UDP socket: %w\", err)\n    }\n    defer conn.Close()\n    s.conn = conn\n    \n    fmt.Printf(\"DNS server listening on %s\\n\", s.addr)\n    \n    buffer := make([]byte, 512) // DNS messages limited to 512 bytes over UDP\n    for {\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        default:\n            // Set read timeout to prevent blocking indefinitely\n            conn.SetReadDeadline(time.Now().Add(1 * time.Second))\n            n, clientAddr, err := conn.ReadFrom(buffer)\n            if err != nil {\n                if netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n                    continue // Timeout is expected, check context and continue\n                }\n                fmt.Printf(\"Error reading UDP packet: %v\\n\", err)\n                continue\n            }\n            \n            // Handle each query in a separate goroutine for concurrency\n            go s.handleQuery(buffer[:n], clientAddr)\n        }\n    }\n}\n\nfunc (s *Server) handleQuery(queryData []byte, clientAddr net.Addr) {\n    // TODO: Students implement this - core learning component\n    // This method should:\n    // 1. Parse the DNS query using s.handler.ParseQuery()\n    // 2. Extract the question from the parsed message  \n    // 3. Resolve the question using s.resolver.Resolve()\n    // 4. Build a response using s.handler.BuildResponse()\n    // 5. Send the response back to clientAddr using s.conn.WriteTo()\n    // 6. Handle errors appropriately (malformed queries, resolution failures, etc.)\n}\n```\n\n**Configuration Management** (`internal/server/config.go`):\n\n```go\npackage server\n\nimport (\n    \"fmt\"\n    \"gopkg.in/yaml.v3\"\n    \"os\"\n)\n\ntype Config struct {\n    Server ServerConfig `yaml:\"server\"`\n    Cache  CacheConfig  `yaml:\"cache\"`\n    Zones  []ZoneConfig `yaml:\"zones\"`\n}\n\ntype ServerConfig struct {\n    ListenAddr string `yaml:\"listen_addr\"`\n    Timeout    string `yaml:\"timeout\"`\n}\n\ntype CacheConfig struct {\n    MaxSize    int    `yaml:\"max_size\"`\n    DefaultTTL string `yaml:\"default_ttl\"`\n}\n\ntype ZoneConfig struct {\n    Domain string `yaml:\"domain\"`\n    File   string `yaml:\"file\"`\n}\n\nfunc LoadConfig(filepath string) (*Config, error) {\n    // TODO: Complete implementation provided - infrastructure component\n    data, err := os.ReadFile(filepath)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read config file: %w\", err)\n    }\n    \n    var config Config\n    if err := yaml.Unmarshal(data, &config); err != nil {\n        return nil, fmt.Errorf(\"failed to parse config YAML: %w\", err)\n    }\n    \n    // Set reasonable defaults\n    if config.Server.ListenAddr == \"\" {\n        config.Server.ListenAddr = \":53\"\n    }\n    if config.Server.Timeout == \"\" {\n        config.Server.Timeout = \"5s\"\n    }\n    if config.Cache.MaxSize == 0 {\n        config.Cache.MaxSize = 10000\n    }\n    \n    return &config, nil\n}\n```\n\n#### Core Logic Skeletons\n\n**DNS Message Parser** (`internal/parser/message.go`):\n\n```go\npackage parser\n\nimport (\n    \"encoding/binary\"\n    \"fmt\"\n)\n\n// DNSMessage represents a complete DNS message with header and sections\ntype DNSMessage struct {\n    Header      Header\n    Questions   []Question\n    Answers     []ResourceRecord\n    Authority   []ResourceRecord\n    Additional  []ResourceRecord\n}\n\n// Header represents the 12-byte DNS message header\ntype Header struct {\n    ID                uint16\n    QueryResponse     bool   // QR bit\n    Opcode           uint8\n    Authoritative    bool   // AA bit  \n    Truncated        bool   // TC bit\n    RecursionDesired bool   // RD bit\n    RecursionAvail   bool   // RA bit\n    ResponseCode     uint8  // RCODE\n    QuestionCount    uint16 // QDCOUNT\n    AnswerCount      uint16 // ANCOUNT\n    AuthorityCount   uint16 // NSCOUNT\n    AdditionalCount  uint16 // ARCOUNT\n}\n\n// ParseMessage parses a complete DNS message from wire format bytes\nfunc ParseMessage(data []byte) (*DNSMessage, error) {\n    // TODO 1: Validate minimum message length (12 bytes for header)\n    // TODO 2: Parse the 12-byte header using parseHeader()\n    // TODO 3: Initialize message structure with parsed header\n    // TODO 4: Parse Questions section (header.QuestionCount questions)\n    // TODO 5: Parse Answer section (header.AnswerCount resource records)  \n    // TODO 6: Parse Authority section (header.AuthorityCount resource records)\n    // TODO 7: Parse Additional section (header.AdditionalCount resource records)\n    // TODO 8: Return complete DNSMessage structure\n    // Hint: Use a position tracker to advance through the byte slice\n    // Hint: Each parse function should return (parsed_data, bytes_consumed, error)\n}\n\n// parseHeader extracts the 12-byte header from the beginning of a DNS message\nfunc parseHeader(data []byte) (Header, error) {\n    // TODO 1: Validate data length is at least 12 bytes\n    // TODO 2: Extract ID (bytes 0-1) using binary.BigEndian.Uint16()\n    // TODO 3: Extract flags (bytes 2-3) and decode individual bits:\n    //         QR=bit15, Opcode=bits14-11, AA=bit10, TC=bit9, RD=bit8\n    //         RA=bit7, RCODE=bits3-0\n    // TODO 4: Extract section counts (bytes 4-11, four 16-bit values)\n    // TODO 5: Return populated Header struct\n    // Hint: Use bit masking and shifting to extract flag bits\n    // Hint: All multi-byte values are in network (big-endian) byte order\n}\n```\n\n#### Language-Specific Hints\n\n**Go-Specific DNS Implementation Tips**:\n\n- Use `binary.BigEndian.Uint16()` and `binary.BigEndian.Uint32()` for parsing multi-byte network values\n- DNS names are case-insensitive; use `strings.ToLower()` for consistent comparisons  \n- UDP messages are limited to 512 bytes; larger responses require TCP (not implemented in basic version)\n- Use `context.WithTimeout()` for network operations to prevent hanging on unresponsive servers\n- The `net.LookupNS()` function can validate your recursive resolution against system resolver\n- Use `sync.Map` or `sync.RWMutex` for concurrent cache access from multiple goroutines\n- Time-based operations should use `time.Now().Unix()` for TTL calculations (avoids timezone issues)\n\n**Common Go Pitfalls in DNS Implementation**:\n- Forgetting to handle name compression in DNS messages leads to incorrect parsing\n- Using signed integers for TTL values causes problems when TTL exceeds 2^31 seconds  \n- Not setting timeouts on network operations can cause goroutines to leak indefinitely\n- Case-sensitive domain name comparisons fail for real-world DNS queries\n- Modifying slices passed to goroutines creates data races without proper synchronization\n\n#### Milestone Checkpoints\n\n**After completing foundation setup**:\n\n1. **Verify UDP server startup**: Run `go run cmd/dns-server/main.go` - should print \"DNS server listening on :53\"\n2. **Test basic connectivity**: Use `dig @127.0.0.1 google.com` - should receive a response (may be error, but connection works)  \n3. **Validate message parsing**: Create unit tests that parse known-good DNS messages from `testdata/`\n4. **Check configuration loading**: Verify server loads `configs/dns-server.yaml` without panicking\n\n**Expected behavior after foundation**:\n- Server starts without errors and binds to UDP port\n- Incoming queries trigger `handleQuery()` function calls\n- Message parsing attempts occur (may fail until Milestone 1 complete)\n- Clean shutdown when interrupted with Ctrl+C\n\n**Signs something is wrong**:\n- \"Permission denied\" when binding port 53 → Run as root or use port 5353 for testing\n- \"Address already in use\" → Another DNS server is running, change port or stop competing service\n- Panic on startup → Check configuration file syntax and required directories exist\n- No response to `dig` queries → Verify firewall allows UDP traffic on chosen port\n\nThis foundation provides the infrastructure framework while leaving the core DNS protocol implementation as the primary learning challenge. Students can focus on understanding DNS message formats, resolution algorithms, and caching strategies rather than UDP socket programming details.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** Foundational understanding for all milestones (1-4)\n\nThe DNS server project aims to build a comprehensive recursive DNS resolver that demonstrates mastery of network protocols, distributed systems concepts, and performance optimization techniques. This section establishes clear boundaries around what the implementation will and will not include, ensuring focused development while maintaining educational value.\n\n### Functional Goals\n\nUnderstanding the functional requirements for a DNS server requires thinking about the different roles DNS servers play in the internet infrastructure. Think of DNS servers as specialized librarians in a vast distributed library system. Some librarians are **reference specialists** who have authoritative knowledge about specific collections (authoritative servers), others are **research assistants** who know how to track down any book by following leads through the entire library system (recursive resolvers), and still others are **information brokers** who simply forward requests to their trusted colleagues upstream (forwarding servers).\n\nOur DNS server implementation will function as both a reference specialist and research assistant, capable of serving authoritative responses for configured domains while also performing complete recursive resolution for any domain on the internet. This dual capability provides comprehensive learning opportunities across all aspects of DNS server operation.\n\n#### Core Protocol Implementation\n\nThe foundation of any DNS server lies in its ability to correctly implement the DNS wire protocol as specified in RFC 1035. This involves handling the binary message format that carries DNS queries and responses across UDP (and potentially TCP) connections.\n\n| Protocol Feature | Implementation Requirement | Learning Objective |\n|------------------|---------------------------|-------------------|\n| DNS Message Format | Parse and construct complete DNS messages with header, question, answer, authority, and additional sections | Understanding binary protocol parsing and network byte order |\n| Name Compression | Decode and encode DNS name compression using pointer labels to reduce message size | Handling complex binary data structures with internal references |\n| Resource Record Types | Support A, AAAA, CNAME, MX, NS, SOA, and TXT record types with proper RDATA parsing | Learning diverse data encoding formats within a single protocol |\n| UDP Transport | Handle DNS queries over UDP with proper packet size limits and truncation handling | Network programming fundamentals and datagram protocols |\n| Error Handling | Generate appropriate DNS response codes (NXDOMAIN, SERVFAIL, FORMERR) for various error conditions | Protocol-level error communication and client experience |\n\nThe message parsing implementation must handle the complexity of DNS name compression, where domain names can reference earlier occurrences in the same message to save space. This creates a challenge similar to managing pointers in binary data—the parser must maintain state about previously encountered names while avoiding infinite loops from malicious compression chains.\n\n> **Design Insight**: DNS message parsing represents one of the most complex binary protocol parsing challenges developers encounter. The combination of variable-length encoded names, compression pointers, and multiple record types with different RDATA formats requires careful buffer management and state tracking. Mastering this provides transferable skills for any network protocol implementation.\n\n#### Authoritative DNS Service\n\nThe authoritative server component transforms our DNS server into a reference specialist for specific domains. Think of this as becoming the official record keeper for a particular section of the internet's namespace—when someone asks about domains we're authoritative for, we provide the definitive answer rather than looking it up elsewhere.\n\n| Authoritative Feature | Implementation Requirement | Learning Objective |\n|----------------------|---------------------------|-------------------|\n| Zone File Parsing | Read BIND-format zone files and load records into queryable data structures | File format parsing and data structure design |\n| Query Matching | Find the best matching records for a given domain name and record type | String matching algorithms and hierarchical data organization |\n| Response Construction | Populate answer, authority, and additional sections according to DNS standards | Understanding multi-section response semantics |\n| Delegation Handling | Properly delegate subdomains with NS records and glue records | Hierarchical namespace management and circular dependency resolution |\n| Negative Responses | Generate NXDOMAIN and NODATA responses with proper SOA records | Error case handling in distributed systems |\n\nThe zone file parsing component must handle the standard BIND zone file format, which includes features like `$ORIGIN` directives, relative domain names, and various record type syntaxes. This parsing challenge teaches important lessons about configuration file design and the trade-offs between human readability and machine parseability.\n\nQuery matching in an authoritative server involves finding the most specific match for a given domain name within the zone data. This is more complex than simple string matching because of DNS's hierarchical structure—a query for `www.example.com` might match a wildcard record `*.example.com` if no more specific record exists.\n\n> **Decision: Zone Data Storage Strategy**\n> - **Context**: Authoritative servers need efficient data structures for storing and querying zone records\n> - **Options Considered**: \n>   - Hash map with full domain names as keys\n>   - Trie structure mirroring DNS hierarchy\n>   - Sorted slice with binary search\n> - **Decision**: Hash map with normalized domain names as keys\n> - **Rationale**: Provides O(1) lookup performance for exact matches and simplifies implementation compared to trie structures, while sorted slices would require O(log n) search time\n> - **Consequences**: Excellent performance for exact matches but requires additional logic for wildcard matching and closest encloser finding\n\n#### Recursive Resolution Engine\n\nThe recursive resolver component transforms our DNS server into a research assistant capable of tracking down any domain name by following the DNS hierarchy from root servers down to authoritative nameservers. This represents the most intellectually challenging aspect of DNS server implementation.\n\nThink of recursive resolution as detective work where each clue (referral) leads you closer to the final answer. You start with a broad lead (the root servers know about top-level domains), follow it to get a more specific lead (TLD servers know about second-level domains), and continue until you find the authoritative source with the definitive answer.\n\n| Resolution Feature | Implementation Requirement | Learning Objective |\n|--------------------|---------------------------|-------------------|\n| Root Hints Bootstrap | Use root hints file to initialize resolution with root server IP addresses | Understanding DNS hierarchy bootstrap process |\n| Iterative Queries | Follow NS referrals from root through TLD to authoritative servers | Implementing stateful multi-step distributed algorithms |\n| CNAME Following | Transparently resolve CNAME chains to final target records | Handling indirection and alias resolution in distributed systems |\n| Glue Record Processing | Use A records from additional section to avoid circular dependencies | Understanding and resolving circular dependencies in distributed lookups |\n| Loop Detection | Detect and prevent infinite referral loops and CNAME chains | Implementing cycle detection in distributed graph traversal |\n\nThe iterative resolution algorithm maintains state about the current query while following a chain of referrals. Each step involves sending a query to a nameserver, processing the response, and deciding whether to return an answer or follow another referral. This state management teaches valuable lessons about distributed algorithms and error recovery.\n\nGlue records solve a fundamental bootstrapping problem in DNS: if `ns1.example.com` is the nameserver for `example.com`, how do you find the IP address of `ns1.example.com` without already knowing it? The parent zone (`com` in this case) provides glue records—A records for nameservers within the zone they serve—to break this circular dependency.\n\n> **Decision: Resolution State Management**\n> - **Context**: Recursive resolution requires tracking state across multiple network round-trips\n> - **Options Considered**:\n>   - Single-threaded state machine with explicit state variables\n>   - Recursive function calls with stack-based state\n>   - Goroutines with channel communication for each resolution step\n> - **Decision**: Iterative approach with explicit state tracking in a resolution context structure\n> - **Rationale**: Provides better control over timeout handling and resource management compared to recursive calls, while being simpler to debug than multi-goroutine approaches\n> - **Consequences**: More explicit code that clearly shows resolution steps, but requires careful state management and cleanup\n\n#### Caching and Performance Optimization\n\nThe caching layer transforms our DNS server from a research assistant who looks up everything from scratch into an experienced librarian who remembers recent answers and can respond immediately to repeated questions. DNS caching is crucial for internet performance—without it, every web page load would require dozens of DNS lookups starting from the root servers.\n\n| Caching Feature | Implementation Requirement | Learning Objective |\n|-----------------|---------------------------|-------------------|\n| TTL-Based Expiration | Store cached records with automatic expiration based on their time-to-live values | Understanding distributed cache consistency and temporal data management |\n| Negative Caching | Cache NXDOMAIN and NODATA responses to avoid repeated failed queries | Caching negative results and handling cache invalidation |\n| Cache Validation | Prevent cache poisoning by validating response records match queries | Security considerations in caching systems |\n| Memory Management | Implement cache size limits and eviction policies to prevent memory exhaustion | Resource management and cache replacement algorithms |\n| Concurrent Access | Handle multiple simultaneous queries with thread-safe cache operations | Concurrent data structure design and locking strategies |\n\nTTL-based caching requires careful time management—each cached record has an independent expiration time that must be tracked and enforced. The cache must continuously expire old records while serving fresh ones, creating a time-based data management challenge.\n\nNegative caching stores the absence of records, which is philosophically different from caching positive data. When a domain doesn't exist (NXDOMAIN), we want to remember that fact temporarily to avoid repeated expensive lookups, but we must be careful about the cache duration since domains can be created at any time.\n\n> **Decision: Cache Implementation Strategy**\n> - **Context**: DNS cache needs to handle thousands of records with different TTL values and concurrent access\n> - **Options Considered**:\n>   - Simple map with periodic cleanup goroutine\n>   - Time-ordered priority queue with exact expiration\n>   - Lazy expiration on access with background cleanup\n> - **Decision**: Lazy expiration on access with periodic background cleanup\n> - **Rationale**: Reduces timer overhead compared to exact expiration while providing reasonable cleanup guarantees, and simplifies concurrent access patterns\n> - **Consequences**: Some expired records may persist briefly in memory, but implementation is more robust and performant under high load\n\n### Non-Goals\n\nDefining what the DNS server will not implement is as important as defining what it will implement. These exclusions focus development effort on core learning objectives while avoiding advanced topics that would significantly increase complexity without proportional educational benefit.\n\n#### Security and Cryptographic Features\n\nModern DNS includes sophisticated security extensions (DNSSEC) that provide cryptographic validation of DNS responses. However, implementing DNSSEC would require deep cryptographic knowledge and significantly complicate the core DNS learning objectives.\n\n| Excluded Security Feature | Rationale for Exclusion | Alternative Learning Path |\n|---------------------------|-------------------------|---------------------------|\n| DNSSEC Validation | Cryptographic signature verification requires extensive PKI knowledge beyond DNS fundamentals | Study DNSSEC as a separate cryptography project after mastering basic DNS |\n| DNS-over-HTTPS (DoH) | HTTPS transport adds TLS complexity that distracts from DNS protocol learning | Implement DoH as an extension after completing basic UDP/TCP DNS |\n| DNS-over-TLS (DoT) | TLS implementation complexity overshadows DNS-specific learning objectives | Focus on transport-layer security in a dedicated TLS project |\n| Query Logging Security | Secure audit logging requires additional infrastructure and privacy considerations | Add comprehensive logging as an operational extension |\n| Rate Limiting | DDoS protection mechanisms are important but distinct from core DNS functionality | Implement rate limiting as a separate network security exercise |\n\nThe exclusion of security features doesn't mean ignoring security entirely—the implementation will include basic validation to prevent cache poisoning and malformed message handling. However, advanced cryptographic features represent separate learning domains that would dilute focus on DNS fundamentals.\n\n#### Advanced Protocol Extensions\n\nThe DNS protocol has evolved significantly since RFC 1035, with numerous extensions that add functionality for specific use cases. While these extensions are important in production systems, they add complexity that can obscure the fundamental DNS concepts this project aims to teach.\n\n| Excluded Protocol Feature | Rationale for Exclusion | Core DNS Alternative |\n|---------------------------|-------------------------|----------------------|\n| EDNS0 Extensions | Extended DNS features like larger UDP payloads add protocol complexity without fundamental learning value | Focus on standard 512-byte UDP limit handling |\n| Dynamic Updates (RFC 2136) | DNS UPDATE mechanism is rarely used and adds significant state management complexity | Static zone files provide sufficient learning about authoritative data |\n| Zone Transfers (AXFR/IXFR) | Zone synchronization between servers is an operational concern separate from query resolution | Single-server deployment eliminates zone transfer needs |\n| Multicast DNS (mDNS) | Local network discovery uses different semantics from internet DNS | Standard DNS hierarchy provides better learning foundation |\n| DNS Service Discovery | Service location records require additional protocol understanding | Focus on basic record types (A, AAAA, CNAME, MX, NS) |\n\nThese protocol extensions represent evolutionary additions to DNS that address specific operational requirements. Excluding them allows deeper focus on the core resolution algorithm and caching behavior that form the foundation for understanding all DNS implementations.\n\n#### Production Operational Features\n\nProduction DNS servers require extensive operational features for monitoring, configuration management, and high availability. While these features are crucial for real-world deployment, they represent systems administration and DevOps concerns rather than fundamental computer science concepts.\n\n| Excluded Operational Feature | Rationale for Exclusion | Learning Focus Alternative |\n|------------------------------|-------------------------|----------------------------|\n| Configuration Hot Reloading | Dynamic configuration adds complexity without teaching core DNS concepts | Static configuration files provide sufficient flexibility for learning |\n| Prometheus Metrics | Monitoring integration is important operationally but distinct from DNS algorithm implementation | Focus on correct DNS behavior rather than observability |\n| High Availability Clustering | Multi-server coordination requires distributed systems concepts beyond DNS scope | Single-server implementation demonstrates all DNS concepts |\n| Administrative APIs | REST APIs for server management add web development complexity | Command-line tools and configuration files provide sufficient control |\n| Logging Frameworks | Structured logging systems are operational concerns separate from DNS functionality | Simple logging to stdout/stderr adequate for debugging and learning |\n\n> **Design Principle**: Educational DNS Implementation Focus\n> \n> This DNS server prioritizes deep understanding of DNS fundamentals over production readiness. Every included feature directly teaches core concepts like protocol parsing, hierarchical resolution, caching strategies, or distributed systems patterns. Excluded features, while valuable in production systems, would add implementation complexity without proportional learning benefit in these foundational areas.\n\nThe non-goals serve as guard rails to prevent scope creep while ensuring the implementation remains focused on its educational mission. Students who complete this project will have mastered the essential DNS concepts and can tackle any of the excluded features as follow-on projects with a solid foundation.\n\n#### Performance and Scale Limitations\n\nWhile the DNS server will implement caching and basic performance optimizations, it explicitly avoids the extreme performance engineering required for high-scale production DNS servers that handle millions of queries per second.\n\n| Performance Limitation | Acceptable Trade-off | Learning Priority |\n|------------------------|---------------------|-------------------|\n| Single-threaded query processing | Simpler debugging and state management | Understanding DNS resolution algorithm correctness |\n| In-memory cache only | No persistence complexity | Focus on cache consistency and TTL management |\n| Basic eviction policies | LRU or random eviction sufficient | Understanding cache behavior principles |\n| No query pipelining | One query at a time per connection | Clear separation of query processing steps |\n| Limited concurrent connections | Handles dozens, not thousands of clients | Network programming fundamentals |\n\nThese performance limitations are intentional design choices that trade maximum throughput for implementation clarity and debugging simplicity. Students learning DNS benefit more from understanding correct resolution behavior than from optimizing for high-scale performance scenarios they're unlikely to encounter in educational environments.\n\n> **Key Insight**: The distinction between educational and production systems lies not in correctness—both must implement the DNS protocol correctly—but in optimization priorities. Educational implementations prioritize understanding and debuggability, while production systems prioritize performance, reliability, and operational features. This DNS server aims for complete correctness with sufficient performance for learning and experimentation.\n\n### Implementation Guidance\n\nThe functional goals and non-goals establish the scope for a comprehensive DNS server implementation that balances educational value with practical functionality. The following guidance helps translate these goals into concrete implementation decisions.\n\n#### Technology Stack Recommendations\n\n| Component | Simple Option | Advanced Option | Recommended for Learning |\n|-----------|---------------|-----------------|-------------------------|\n| Network Transport | `net` package UDP sockets | Custom packet processing with `golang.org/x/net` | `net.PacketConn` for simplicity |\n| Binary Parsing | Manual byte slicing with `binary` package | Code generation from protocol definitions | Manual parsing to understand wire format |\n| Configuration | YAML files with `gopkg.in/yaml.v3` | TOML or JSON with validation schemas | YAML for human readability |\n| Logging | Standard `log` package | Structured logging with `logrus` or `zap` | Standard `log` package to avoid dependencies |\n| Testing | Standard `testing` package | BDD frameworks like `ginkgo` | Standard `testing` with table-driven tests |\n| Time Management | `time.Time` and `time.Duration` | Custom time abstraction for testing | Standard `time` package with mock interfaces for tests |\n\nThe technology choices prioritize Go standard library packages to minimize external dependencies and focus attention on DNS-specific implementation challenges rather than framework learning.\n\n#### Recommended Project Structure\n\nOrganizing the DNS server code into logical packages helps separate concerns and makes the implementation more maintainable and testable.\n\n```\ndns-server/\n├── cmd/\n│   └── dns-server/\n│       └── main.go                    # Entry point, configuration loading\n├── internal/\n│   ├── server/\n│   │   ├── server.go                  # UDP server and query dispatch\n│   │   └── server_test.go             # Server integration tests\n│   ├── protocol/\n│   │   ├── message.go                 # DNS message parsing and construction\n│   │   ├── compression.go             # Name compression handling\n│   │   └── protocol_test.go           # Protocol parsing tests\n│   ├── resolver/\n│   │   ├── recursive.go               # Recursive resolution logic\n│   │   ├── authoritative.go           # Zone data query handling\n│   │   └── resolver_test.go           # Resolution algorithm tests\n│   ├── cache/\n│   │   ├── cache.go                   # TTL-based caching implementation\n│   │   └── cache_test.go              # Cache behavior tests\n│   └── zone/\n│       ├── parser.go                  # Zone file parsing\n│       ├── records.go                 # Resource record data structures\n│       └── zone_test.go               # Zone parsing tests\n├── testdata/\n│   ├── zones/                         # Sample zone files for testing\n│   └── queries/                       # Test DNS messages\n├── configs/\n│   └── server.yaml                    # Server configuration\n└── go.mod\n```\n\nThis structure separates protocol-level concerns (`protocol` package) from application logic (`resolver`, `cache`, `zone` packages) and provides clear testing boundaries for each component.\n\n#### Core Data Structure Definitions\n\nThe DNS server implementation centers around several key data structures that must be defined consistently across all components.\n\n```go\n// Package: internal/protocol\n\n// DNSMessage represents a complete DNS message as defined in RFC 1035\ntype DNSMessage struct {\n    Header     Header            // 12-byte fixed header\n    Questions  []Question        // Query section (usually one question)\n    Answers    []ResourceRecord  // Answer resource records\n    Authority  []ResourceRecord  // Authority section (NS records, SOA for negative responses)\n    Additional []ResourceRecord  // Additional section (glue records, etc.)\n}\n\n// Header represents the 12-byte DNS message header\ntype Header struct {\n    ID              uint16  // Query identifier for matching requests/responses\n    QueryResponse   bool    // false for query, true for response\n    Opcode          uint8   // Query type (0 = standard query)\n    Authoritative   bool    // true if responding server is authoritative\n    Truncated       bool    // true if message was truncated due to size limits\n    RecursionDesired bool   // true if client requests recursive resolution\n    RecursionAvail  bool    // true if server supports recursive resolution\n    ResponseCode    uint8   // Response code (0 = no error, 3 = NXDOMAIN, etc.)\n    \n    // Section counts (derived from slice lengths, not stored separately)\n    QuestionCount   uint16  // Number of questions\n    AnswerCount     uint16  // Number of answer records  \n    AuthorityCount  uint16  // Number of authority records\n    AdditionalCount uint16  // Number of additional records\n}\n\n// Question represents a DNS query question\ntype Question struct {\n    Name  string // Domain name being queried (e.g., \"www.example.com\")\n    Type  uint16 // Record type (1 = A, 28 = AAAA, 5 = CNAME, etc.)\n    Class uint16 // Query class (1 = IN for Internet)\n}\n\n// ResourceRecord represents any DNS resource record\ntype ResourceRecord struct {\n    Name  string // Domain name this record applies to\n    Type  uint16 // Record type\n    Class uint16 // Record class\n    TTL   uint32 // Time-to-live in seconds\n    Data  []byte // Type-specific RDATA (parsed separately by type)\n}\n```\n\n#### Server Configuration Structure\n\nThe server requires configuration for network settings, zone files, and caching parameters.\n\n```go\n// Package: internal/server\n\n// Config represents complete server configuration loaded from YAML\ntype Config struct {\n    Server ServerConfig `yaml:\"server\"`\n    Cache  CacheConfig  `yaml:\"cache\"`  \n    Zones  []ZoneConfig `yaml:\"zones\"`\n}\n\n// ServerConfig contains network and protocol settings\ntype ServerConfig struct {\n    ListenAddr string `yaml:\"listen_addr\"` // \"127.0.0.1:5353\"\n    Timeout    string `yaml:\"timeout\"`     // \"5s\"\n}\n\n// CacheConfig controls caching behavior\ntype CacheConfig struct {\n    MaxSize    int    `yaml:\"max_size\"`     // Maximum cached records\n    DefaultTTL string `yaml:\"default_ttl\"` // \"300s\"\n}\n\n// ZoneConfig specifies an authoritative zone\ntype ZoneConfig struct {\n    Domain string `yaml:\"domain\"` // \"example.com\"\n    File   string `yaml:\"file\"`   // \"zones/example.com.zone\"\n}\n```\n\n#### Milestone Implementation Checkpoints\n\nEach milestone builds toward the complete DNS server implementation with specific verification steps.\n\n**Milestone 1 Checkpoint - DNS Message Parsing:**\nAfter implementing the protocol parsing, verify functionality with:\n\n```bash\ngo test ./internal/protocol/... -v\n```\n\nExpected behavior: Parse a captured DNS query message, extract the question for \"www.example.com\", and reconstruct the message to identical bytes. The test should validate name compression handling by parsing a response with multiple domain names sharing suffixes.\n\n**Milestone 2 Checkpoint - Authoritative Server:**\nAfter implementing zone file parsing and authoritative responses:\n\n```bash\n# Start server with test zone\ngo run cmd/dns-server/main.go -config configs/test.yaml\n\n# Query the authoritative server\ndig @127.0.0.1 -p 5353 www.example.com A\n```\n\nExpected behavior: Return an A record from the loaded zone file with the authoritative flag set. Verify NS records appear in the authority section and glue records in the additional section.\n\n**Milestone 3 Checkpoint - Recursive Resolution:**\nAfter implementing recursive resolution:\n\n```bash\n# Query for external domain (not in local zones)\ndig @127.0.0.1 -p 5353 www.google.com A\n```\n\nExpected behavior: Follow iterative queries from root servers through TLD to authoritative servers, returning the final A record. Verify the recursion available flag is set in responses.\n\n**Milestone 4 Checkpoint - Caching:**\nAfter implementing caching:\n\n```bash\n# First query (cache miss)\ntime dig @127.0.0.1 -p 5353 www.github.com A\n\n# Second query (cache hit)  \ntime dig @127.0.0.1 -p 5353 www.github.com A\n```\n\nExpected behavior: Second query should return significantly faster (under 1ms) indicating cache hit. Verify cached records expire after their TTL by waiting and observing cache miss behavior.\n\n#### Common Implementation Pitfalls\n\n⚠️ **Pitfall: Network Byte Order Confusion**\nDNS uses network byte order (big-endian) for multi-byte integers, but Go's default byte operations assume host byte order. Use `binary.BigEndian.Uint16()` and `binary.BigEndian.PutUint16()` for all DNS header fields. Symptoms include header fields with seemingly random values or queries failing to match responses.\n\n⚠️ **Pitfall: Name Compression Infinite Loops**\nMalicious or malformed DNS messages can contain compression pointer loops that cause infinite recursion during name parsing. Always track visited pointer offsets and abort parsing if a pointer is encountered twice. Implement a maximum pointer chain length (suggested: 63 hops) to prevent resource exhaustion.\n\n⚠️ **Pitfall: Case Sensitivity in Domain Names**\nDNS domain names are case-insensitive, but Go string comparisons are case-sensitive. Always normalize domain names to lowercase before comparison or use `strings.EqualFold()` for DNS name matching. This affects zone lookups, cache keys, and compression pointer matching.\n\n⚠️ **Pitfall: TTL Arithmetic Underflow**\nWhen caching records, calculate remaining TTL by subtracting elapsed time from original TTL. If elapsed time exceeds original TTL, the record has expired—don't return it with a negative or zero TTL. Use `time.Now()` consistently to avoid clock skew issues in TTL calculations.\n\n⚠️ **Pitfall: UDP Message Size Limits**\nStandard DNS over UDP has a 512-byte message size limit. If a response exceeds this limit, set the truncated flag and consider implementing TCP fallback. Large zone responses or many additional records can easily exceed UDP limits, causing client resolution failures.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Foundational understanding for all milestones (1-4)\n\nBuilding a DNS server requires orchestrating multiple specialized components that work together to receive queries, parse protocol messages, resolve domain names, and return responses. Think of this architecture like a **well-organized library system**: the UDP server acts as the front desk receiving requests, the message parser translates between different \"languages\" (binary protocol vs. internal structures), the resolver acts as a research librarian following leads to find information, the cache serves as recent memory for frequently requested items, and the zone data manager maintains the library's own collection of authoritative books.\n\n![DNS Server System Components](./diagrams/system-components.svg)\n\nThe DNS server architecture balances several competing concerns: protocol correctness, performance through caching, concurrent request handling, and extensibility for different resolution modes (authoritative vs. recursive). The modular design allows each component to focus on its specific responsibility while maintaining clean interfaces between components. This separation enables independent testing, easier debugging, and the flexibility to swap implementations (for example, using different caching strategies or storage backends) without affecting other components.\n\n### Component Overview\n\nThe DNS server consists of five major components, each with distinct responsibilities and well-defined interfaces. These components form a pipeline that transforms incoming UDP packets into DNS responses, with caching and recursive resolution providing the intelligence needed for a complete DNS implementation.\n\n#### UDP Server Component\n\nThe **UDP Server** serves as the network interface and coordination hub for the entire DNS server. Think of it as the **receptionist at a busy office** - it greets every visitor (incoming DNS query), ensures they're directed to the right department (message parsing and resolution), and makes sure they receive a proper response before leaving.\n\nThe UDP server's primary responsibilities include binding to the DNS port (typically 53), receiving incoming packets from clients, spawning concurrent handlers for each query, and transmitting responses back to the correct client address. It also manages server lifecycle operations like graceful shutdown and connection error handling.\n\n| Responsibility | Description | Failure Handling |\n|---------------|-------------|------------------|\n| Network Binding | Bind to UDP port 53 and listen for incoming packets | Retry binding with exponential backoff, log fatal error if port unavailable |\n| Packet Reception | Read UDP packets from network and extract client address | Log malformed packets, continue serving other clients |\n| Concurrency Management | Spawn goroutines for concurrent query processing | Limit concurrent goroutines to prevent resource exhaustion |\n| Response Transmission | Send DNS response packets back to querying clients | Retry transmission once, log delivery failures |\n| Lifecycle Management | Handle server startup, graceful shutdown, and cleanup | Ensure in-flight queries complete before shutdown |\n\nThe server maintains minimal state - primarily the network connection and configuration parameters. It delegates all DNS-specific processing to other components, maintaining a clean separation between network concerns and protocol logic.\n\n> **Key Design Insight**: The UDP server should be stateless regarding DNS queries themselves. All query-specific state lives in the handlers it spawns, allowing the server to scale horizontally and recover cleanly from individual query failures without affecting other concurrent requests.\n\n#### Message Parser Component\n\nThe **Message Parser** handles the complex task of translating between the binary DNS wire format and internal Go data structures. Think of it as a **skilled translator at the United Nations** - it must perfectly understand both the formal binary \"language\" of DNS packets and the structured \"language\" of internal application data, ensuring nothing is lost or corrupted in translation.\n\nDNS messages follow the RFC 1035 specification with a fixed 12-byte header followed by variable-length sections. The parser must handle intricate details like network byte order conversion, DNS name compression using pointer labels, and validation of message structure constraints.\n\n| Component Function | Input | Output | Error Conditions |\n|-------------------|--------|--------|------------------|\n| Message Parsing | Raw UDP packet bytes | `DNSMessage` struct | Truncated packet, invalid header, compression loops |\n| Header Extraction | First 12 bytes of packet | `Header` struct with all flags | Packet too short, reserved bits set |\n| Question Parsing | Question section bytes | `[]Question` slice | Invalid domain name, unsupported QTYPE |\n| Resource Record Parsing | RR section bytes | `[]ResourceRecord` slice | Invalid TTL, malformed RDATA, unknown type |\n| Message Construction | `DNSMessage` struct | Wire format bytes | Message too large, compression failure |\n\nThe parser implements DNS name compression, a critical optimization where repeated domain names in a message use pointer labels (starting with bytes 0xC0) to reference earlier occurrences. This compression can reduce message size significantly but introduces complexity around validation and loop detection.\n\n> **Critical Security Consideration**: The parser must validate all compression pointers to prevent infinite loops and buffer overflows. A malicious packet with circular compression pointers could crash the server or enable memory corruption attacks.\n\n#### Recursive Resolver Component\n\nThe **Recursive Resolver** implements the core DNS resolution algorithm, transforming domain name queries into authoritative answers by following the DNS hierarchy. Think of it as a **detective following clues** - it starts with a basic question (\"What's the IP address of www.example.com?\"), follows a chain of evidence from root servers through TLD servers to authoritative servers, and assembles the final answer from multiple sources.\n\nThe resolver maintains the complex state machine of iterative resolution: tracking which servers to query next, following NS referrals, handling CNAME chains, and assembling the final response. It must handle various edge cases like missing glue records, server timeouts, and delegation loops while maintaining the semantic correctness required by the DNS protocol.\n\n| Resolution Phase | Action Taken | Data Sources | Failure Recovery |\n|-----------------|-------------|--------------|------------------|\n| Root Query | Query root server for TLD NS records | Root hints file | Try alternate root servers |\n| TLD Query | Query TLD server for domain NS records | Root response referrals | Follow additional TLD servers |\n| Authoritative Query | Query domain's nameserver for final answer | TLD response referrals | Query alternate authoritative servers |\n| CNAME Following | Resolve CNAME target recursively | Authoritative server response | Detect and break CNAME loops |\n| Response Assembly | Combine results into final DNS message | All resolution phases | Return best partial answer available |\n\nThe resolver integrates closely with both the cache (to avoid repeated queries) and the zone data manager (for authoritative responses). It must decide whether to perform recursive resolution, return cached results, or consult local zone data based on the query and server configuration.\n\n> **Performance Insight**: Recursive resolution can involve 3-10 network round-trips per query. Effective caching and glue record utilization are essential for acceptable performance. The resolver should also implement query pipelining and parallel resolution for independent subqueries.\n\n#### Cache Manager Component\n\nThe **Cache Manager** provides intelligent storage and retrieval of DNS records with TTL-based expiration and negative caching. Think of it as the **librarian's short-term memory** - it remembers recently looked-up information to avoid repeating expensive research, but it also knows when that information becomes stale and needs refreshing.\n\nThe cache stores both positive responses (successful resolutions) and negative responses (NXDOMAIN and NODATA) with their appropriate TTL values. It must handle concurrent access from multiple query handlers while maintaining cache consistency and preventing memory exhaustion through intelligent eviction policies.\n\n| Cache Operation | Input | Output | Side Effects |\n|----------------|--------|--------|--------------|\n| Cache Lookup | Domain name, record type | Cached record or miss | Update access time for LRU |\n| Cache Storage | Resolved record with TTL | Success/failure | Evict expired or LRU entries |\n| TTL Management | Timer events | Expired entry removal | Free memory, update statistics |\n| Negative Caching | NXDOMAIN response | Negative cache entry | Prevent repeated failed queries |\n| Cache Invalidation | Domain name pattern | Removed entries | Force fresh resolution |\n\nThe cache implements several important optimizations: it respects the minimum TTL from SOA records for negative caching, it can perform cache warming by proactively refreshing popular entries before expiration, and it maintains statistics for cache hit rates and memory usage monitoring.\n\n> **Security Consideration**: The cache must validate that cached entries match the original query to prevent cache poisoning attacks. Records returned from recursive resolution should only be cached if they're \"in-bailiwick\" (within the expected domain hierarchy).\n\n#### Zone Data Manager Component\n\nThe **Zone Data Manager** handles authoritative DNS data loaded from zone files, providing the server's \"official\" knowledge about domains it's configured to serve. Think of it as the **library's reference collection** - these are the authoritative books the library owns and maintains, as opposed to information borrowed from other sources.\n\nThe zone manager parses standard BIND-format zone files, validates record consistency, and provides efficient lookup capabilities for authoritative responses. It handles SOA records that define zone parameters, NS records that delegate subdomains, and various resource records (A, AAAA, CNAME, MX, etc.) that contain the actual zone data.\n\n| Zone Management Task | Responsibilities | Data Validation | Error Handling |\n|---------------------|------------------|-----------------|----------------|\n| Zone File Parsing | Read BIND-format files into memory structures | Check SOA presence, validate record syntax | Log parse errors, skip invalid records |\n| Record Indexing | Build efficient lookup structures by name and type | Ensure CNAME exclusivity, validate delegations | Warn about conflicts, apply precedence rules |\n| Authoritative Lookup | Find matching records for queries | Verify query is within zone's authority | Return NXDOMAIN or referral as appropriate |\n| Zone Transfer Support | Serialize zone data for AXFR/IXFR | Maintain zone serial numbers and timestamps | Handle concurrent transfer and update requests |\n| Dynamic Updates | Process DNS UPDATE messages | Validate update authorization and consistency | Roll back failed multi-record updates |\n\nThe zone manager must determine the appropriate response for queries: returning answer records for exact matches, authority records for delegations, and SOA records for negative responses. It also handles wildcard matching according to RFC 1034 specifications.\n\n> **Operational Insight**: Zone data should be reloadable without restarting the server. Implement a file watcher or periodic reload mechanism to pick up zone file changes, with careful coordination to avoid serving partial updates during reload operations.\n\n### Architecture Decisions for Component Design\n\nSeveral critical decisions shaped the component architecture, each involving trade-offs between performance, complexity, and maintainability.\n\n> **Decision: Separate Parser from Network Layer**\n> - **Context**: DNS messages require complex binary parsing with validation, while network handling needs different error recovery and concurrency patterns\n> - **Options Considered**: Combined network+parsing component, separate parser, streaming parser interface\n> - **Decision**: Separate message parser component with complete message parsing\n> - **Rationale**: Parsing errors should not affect network stability; different components can be optimized and tested independently; parser can be reused for zone file processing\n> - **Consequences**: Enables clean unit testing of parsing logic; requires copying packet data between components; allows future optimization like message validation in separate goroutines\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Combined Network+Parser | Fewer data copies, simpler interfaces | Mixed concerns, harder testing, parsing errors affect network | No |\n| Separate Parser | Clean separation, independent optimization | Data copying overhead, more interfaces | **Yes** |\n| Streaming Parser | Memory efficient for large messages | Complex state management, harder error recovery | No |\n\n> **Decision: Unified Resolver vs. Separate Authoritative/Recursive Components**\n> - **Context**: DNS servers can operate in authoritative-only, recursive-only, or hybrid modes with different resolution logic\n> - **Options Considered**: Single resolver with mode flags, separate authoritative and recursive resolvers, resolver interface with multiple implementations\n> - **Decision**: Single resolver component with pluggable strategies for authoritative vs. recursive resolution\n> - **Rationale**: Many queries require both authoritative lookup (checking local zones) and recursive resolution (external queries); unified component can optimize the decision logic and share common code\n> - **Consequences**: Enables hybrid operation modes; resolver component becomes more complex; easier to implement forwarding and conditional resolution policies\n\n> **Decision: In-Memory Cache vs. External Cache Service**\n> - **Context**: DNS queries have high frequency and low latency requirements; cache needs TTL management and concurrent access\n> - **Options Considered**: In-memory map with mutex, external Redis/Memcached, embedded database like SQLite\n> - **Decision**: In-memory cache with TTL-based expiration and LRU eviction\n> - **Rationale**: DNS query latency is critical (sub-millisecond cache lookups required); external cache adds network overhead; most DNS servers handle moderate cache sizes (1M+ records) in memory comfortably\n> - **Consequences**: Enables microsecond cache lookups; cache lost on server restart; memory usage must be carefully managed; requires implementing TTL and eviction logic\n\n### Component Interface Contracts\n\nThe components communicate through well-defined interfaces that enable independent testing and future extensibility. These contracts specify the data formats, method signatures, and behavioral expectations for component interactions.\n\n#### Core Data Exchange Types\n\n| Type | Fields | Purpose |\n|------|--------|---------|\n| `DNSMessage` | `Header Header, Questions []Question, Answers []ResourceRecord, Authority []ResourceRecord, Additional []ResourceRecord` | Complete DNS message representation for inter-component communication |\n| `Header` | `ID uint16, QueryResponse bool, Opcode uint8, Authoritative bool, Truncated bool, RecursionDesired bool, RecursionAvail bool, ResponseCode uint8, QuestionCount uint16, AnswerCount uint16, AuthorityCount uint16, AdditionalCount uint16` | DNS header with all flags and section counts |\n| `Question` | `Name string, Type uint16, Class uint16` | DNS query question specifying what record is requested |\n| `ResourceRecord` | `Name string, Type uint16, Class uint16, TTL uint32, Data []byte` | DNS resource record with type-specific data payload |\n| `ResolverConfig` | `RootHints []string, Timeout time.Duration, MaxDepth int, EnableRecursion bool` | Configuration parameters for resolver behavior |\n\n#### Message Parser Interface\n\n| Method | Parameters | Returns | Description |\n|---------|-----------|---------|-------------|\n| `ParseMessage` | `data []byte` | `*DNSMessage, error` | Parse complete DNS message from wire format bytes |\n| `SerializeMessage` | `msg *DNSMessage` | `[]byte, error` | Convert DNS message to wire format for network transmission |\n| `parseHeader` | `data []byte` | `Header, error` | Extract 12-byte header structure with validation |\n| `parseName` | `data []byte, offset int` | `string, int, error` | Parse DNS name with compression support, returns name and new offset |\n| `ValidateMessage` | `msg *DNSMessage` | `error` | Verify message structure and field consistency |\n\n#### Resolver Interface\n\n| Method | Parameters | Returns | Description |\n|---------|-----------|---------|-------------|\n| `ResolveQuery` | `ctx context.Context, question Question` | `*DNSMessage, error` | Perform complete resolution for a DNS question |\n| `LookupAuthoritative` | `question Question` | `[]ResourceRecord, error` | Check local zone data for authoritative answer |\n| `LookupCache` | `name string, recordType uint16` | `*CacheEntry, bool` | Retrieve cached record if present and not expired |\n| `PerformRecursion` | `ctx context.Context, question Question` | `*DNSMessage, error` | Execute iterative resolution from root servers |\n| `FollowCNAME` | `ctx context.Context, cname string, originalType uint16` | `[]ResourceRecord, error` | Resolve CNAME chain to final target records |\n\n#### Cache Manager Interface\n\n| Method | Parameters | Returns | Description |\n|---------|-----------|---------|-------------|\n| `Get` | `key CacheKey` | `*CacheEntry, bool` | Retrieve cache entry if present and valid |\n| `Put` | `key CacheKey, records []ResourceRecord, ttl uint32` | `error` | Store records with TTL-based expiration |\n| `PutNegative` | `key CacheKey, soaRecord ResourceRecord` | `error` | Cache negative response with SOA-derived TTL |\n| `Evict` | `key CacheKey` | `bool` | Remove specific entry from cache |\n| `Cleanup` | | `int` | Remove expired entries and return count freed |\n| `Stats` | | `CacheStats` | Return cache hit rate, size, and memory usage statistics |\n\n### Common Component Pitfalls\n\nUnderstanding these common mistakes helps avoid architectural problems that can be difficult to fix later in the implementation.\n\n⚠️ **Pitfall: Blocking Network Operations in Parser**\nDNS message parsing should never perform network I/O or other blocking operations. The parser component should be a pure function that transforms bytes to structures and back. Including network calls (like recursive lookups triggered by parsing) creates tight coupling and makes the parser impossible to unit test reliably. Instead, parsing should only validate message structure and extract data, leaving all network operations to the resolver component.\n\n⚠️ **Pitfall: Shared Mutable State Between Components**\nAvoid sharing mutable data structures directly between components, especially the cache and resolver. For example, if the resolver modifies a `ResourceRecord` slice returned by the cache, it can corrupt cached data for future queries. Instead, components should return copies of data or use immutable structures. The cache should clone records before returning them, and the resolver should never modify records in place.\n\n⚠️ **Pitfall: Ignoring DNS Message Size Limits**\nUDP DNS messages are limited to 512 bytes unless EDNS is negotiated. The message serializer must check message size during construction and set the truncation flag if the response doesn't fit. A common mistake is building the complete response in memory and then discovering it's too large, requiring expensive reconstruction. Instead, track message size during construction and truncate gracefully when approaching limits.\n\n⚠️ **Pitfall: Cache Inconsistency During Concurrent Updates**\nThe cache manager must handle concurrent reads and writes carefully. A naive implementation might have race conditions where a cache entry is partially updated during TTL expiration, leading to corrupted responses. Use appropriate locking (typically a read-write mutex) and ensure that cache operations are atomic. Consider implementing a copy-on-write strategy for cache entries that are being read by multiple goroutines.\n\n⚠️ **Pitfall: Resource Leaks in Concurrent Query Handling**\nEach incoming DNS query spawns a goroutine for handling, but without proper resource management, this can lead to goroutine leaks and memory exhaustion under high load. Implement a semaphore or worker pool to limit concurrent queries, and ensure that all goroutines terminate properly even when network errors or timeouts occur. Use context cancellation to clean up abandoned queries.\n\n### Recommended File Structure\n\nThe DNS server should be organized into a modular package structure that reflects the component architecture while following Go conventions for project layout. This organization enables independent development and testing of components while maintaining clear dependency relationships.\n\n```\ndns-server/\n├── cmd/\n│   └── dns-server/\n│       └── main.go                 # Server entry point and configuration loading\n├── internal/\n│   ├── server/\n│   │   ├── server.go              # UDP server component with concurrent query handling\n│   │   ├── handler.go             # Query processing pipeline coordination\n│   │   └── server_test.go         # Integration tests for server component\n│   ├── parser/\n│   │   ├── message.go             # DNS message parsing and serialization\n│   │   ├── compression.go         # DNS name compression implementation\n│   │   ├── types.go               # DNS message data structures\n│   │   └── parser_test.go         # Comprehensive parsing validation tests\n│   ├── resolver/\n│   │   ├── resolver.go            # Main resolver logic and query coordination\n│   │   ├── recursive.go           # Iterative resolution algorithm\n│   │   ├── authoritative.go       # Zone data lookup and authoritative responses\n│   │   ├── root_hints.go          # Root server bootstrap data\n│   │   └── resolver_test.go       # Resolution algorithm tests\n│   ├── cache/\n│   │   ├── cache.go               # TTL-based caching with concurrent access\n│   │   ├── entry.go               # Cache entry data structures and TTL management\n│   │   ├── negative.go            # Negative caching for NXDOMAIN responses\n│   │   └── cache_test.go          # Cache behavior and eviction tests\n│   ├── zones/\n│   │   ├── manager.go             # Zone data loading and management\n│   │   ├── parser.go              # BIND zone file parsing\n│   │   ├── lookup.go              # Efficient zone data lookup algorithms\n│   │   └── zones_test.go          # Zone loading and lookup tests\n│   └── config/\n│       ├── config.go              # Configuration data structures and loading\n│       ├── validation.go          # Configuration validation and defaults\n│       └── config_test.go         # Configuration loading tests\n├── pkg/\n│   └── dns/\n│       ├── constants.go           # DNS protocol constants and record types\n│       ├── errors.go              # DNS-specific error types and handling\n│       └── utils.go               # Common DNS utility functions\n├── test/\n│   ├── integration/\n│   │   ├── server_test.go         # End-to-end server testing\n│   │   └── testdata/              # Sample zone files and test queries\n│   └── fixtures/\n│       ├── messages/              # Binary DNS message test cases\n│       └── zones/                 # Sample zone files for testing\n├── configs/\n│   ├── server.yaml                # Example server configuration\n│   ├── root-hints.txt             # Root server IP addresses\n│   └── example.com.zone           # Example zone file\n└── docs/\n    ├── setup.md                   # Installation and setup instructions\n    └── configuration.md           # Configuration reference\n```\n\nThe `internal/` directory contains the core server implementation with each component in its own package. This prevents external packages from importing internal implementation details while enabling clean interfaces between components. The `pkg/dns/` directory provides reusable DNS utilities that could potentially be used by external packages.\n\nTest organization separates unit tests (alongside their components), integration tests (in `test/integration/`), and test fixtures (binary data and zone files). This structure supports both fast unit testing during development and comprehensive integration testing for release validation.\n\nConfiguration files are separated from code to enable deployment-time customization without rebuilding. The `configs/` directory provides templates and examples that can be copied and modified for specific deployment environments.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Implementation | Advanced Implementation |\n|-----------|----------------------|-------------------------|\n| UDP Server | `net.PacketConn` with `go handleQuery()` per request | Worker pool with `golang.org/x/sync/semaphore` for rate limiting |\n| Message Parser | Manual byte slicing with `binary` package | Code generation from DNS schema definitions |\n| Cache Storage | `sync.Map` with TTL cleanup goroutine | `github.com/patrickmn/go-cache` with LRU and metrics |\n| Zone File Parsing | Custom parser with `bufio.Scanner` | `github.com/miekg/dns` zone parser library |\n| Configuration | `gopkg.in/yaml.v3` for YAML config files | `github.com/spf13/viper` with multiple format support |\n\nFor the initial implementation, prioritize the simple options to focus on learning DNS protocol concepts. The advanced options can be adopted later for production deployments or performance optimization.\n\n#### Core Server Infrastructure\n\n```go\n// Package server provides the UDP DNS server implementation\npackage server\n\nimport (\n    \"context\"\n    \"net\"\n    \"time\"\n    \n    \"dns-server/internal/parser\"\n    \"dns-server/internal/resolver\"\n)\n\n// Server represents a DNS server instance with UDP networking\ntype Server struct {\n    addr     string\n    conn     net.PacketConn\n    resolver resolver.Resolver\n    handler  MessageHandler\n    \n    // Configuration\n    readTimeout  time.Duration\n    writeTimeout time.Duration\n    maxWorkers   int\n    \n    // Runtime state\n    workers chan struct{}  // Semaphore for limiting concurrent queries\n    shutdown chan struct{}\n}\n\n// MessageHandler defines the interface for processing DNS queries\ntype MessageHandler interface {\n    HandleQuery(query *parser.DNSMessage, clientAddr net.Addr) (*parser.DNSMessage, error)\n}\n\n// NewServer creates a DNS server instance ready for listening\nfunc NewServer(addr string, resolver resolver.Resolver, handler MessageHandler) *Server {\n    // TODO 1: Initialize server struct with provided parameters\n    // TODO 2: Set reasonable default timeouts (5s read, 2s write)\n    // TODO 3: Initialize worker semaphore with maxWorkers capacity (default 100)\n    // TODO 4: Create shutdown channel for graceful termination\n    return nil  // Replace with actual implementation\n}\n\n// Start begins listening for DNS queries and handling them concurrently\nfunc (s *Server) Start(ctx context.Context) error {\n    // TODO 1: Create UDP listener on configured address\n    // TODO 2: Store connection in s.conn for cleanup\n    // TODO 3: Start main receive loop with context cancellation support\n    // TODO 4: For each received packet, acquire worker semaphore and spawn handleQuery goroutine\n    // TODO 5: Handle shutdown signal and close connection gracefully\n    // Hint: Use net.ListenPacket(\"udp\", addr) and conn.ReadFrom for packet reception\n    return nil\n}\n```\n\n#### DNS Message Data Structures\n\n```go\n// Package parser provides DNS message parsing and serialization\npackage parser\n\nimport \"fmt\"\n\n// DNSMessage represents a complete DNS message with all sections\ntype DNSMessage struct {\n    Header     Header\n    Questions  []Question\n    Answers    []ResourceRecord\n    Authority  []ResourceRecord\n    Additional []ResourceRecord\n}\n\n// Header represents the 12-byte DNS message header\ntype Header struct {\n    ID              uint16\n    QueryResponse   bool    // false for query, true for response\n    Opcode          uint8   // usually 0 for standard query\n    Authoritative   bool    // true if authoritative answer\n    Truncated       bool    // true if message was truncated\n    RecursionDesired bool   // true if recursion requested\n    RecursionAvail   bool   // true if recursion available\n    ResponseCode     uint8  // 0 for success, 1 for format error, 3 for NXDOMAIN\n    \n    // Section counts (set automatically during serialization)\n    QuestionCount   uint16\n    AnswerCount     uint16\n    AuthorityCount  uint16\n    AdditionalCount uint16\n}\n\n// Question represents a DNS query question\ntype Question struct {\n    Name  string  // Domain name being queried (e.g., \"example.com\")\n    Type  uint16  // Record type (1 for A, 28 for AAAA, etc.)\n    Class uint16  // Usually 1 for Internet class\n}\n\n// ResourceRecord represents any DNS resource record\ntype ResourceRecord struct {\n    Name  string  // Domain name this record belongs to\n    Type  uint16  // Record type (matches Question.Type)\n    Class uint16  // Usually 1 for Internet class\n    TTL   uint32  // Time-to-live in seconds\n    Data  []byte  // Type-specific record data (IP address, domain name, etc.)\n}\n\n// ParseMessage converts wire-format DNS message bytes into structured data\nfunc ParseMessage(data []byte) (*DNSMessage, error) {\n    // TODO 1: Validate minimum message size (12 bytes for header)\n    // TODO 2: Parse header using parseHeader function\n    // TODO 3: Parse question section based on header.QuestionCount\n    // TODO 4: Parse answer section based on header.AnswerCount  \n    // TODO 5: Parse authority section based on header.AuthorityCount\n    // TODO 6: Parse additional section based on header.AdditionalCount\n    // TODO 7: Validate that all bytes were consumed (no trailing data)\n    // Hint: Keep track of current offset as you parse each section\n    return nil, nil\n}\n```\n\n#### Basic Cache Interface\n\n```go\n// Package cache provides TTL-based DNS record caching\npackage cache\n\nimport (\n    \"sync\"\n    \"time\"\n    \n    \"dns-server/internal/parser\"\n)\n\n// Cache provides concurrent-safe DNS record caching with TTL expiration\ntype Cache struct {\n    entries map[CacheKey]*CacheEntry\n    mutex   sync.RWMutex\n    \n    // Configuration\n    maxSize    int\n    defaultTTL time.Duration\n    \n    // Cleanup\n    cleanup    chan struct{}\n}\n\n// CacheKey uniquely identifies a cached DNS record\ntype CacheKey struct {\n    Name  string // Domain name (normalized to lowercase)\n    Type  uint16 // DNS record type\n    Class uint16 // DNS class (usually 1)\n}\n\n// CacheEntry represents a cached DNS record with expiration\ntype CacheEntry struct {\n    Records   []parser.ResourceRecord\n    ExpiresAt time.Time\n    Negative  bool  // true for NXDOMAIN/NODATA responses\n}\n\n// NewCache creates a cache with specified configuration\nfunc NewCache(maxSize int, defaultTTL time.Duration) *Cache {\n    // TODO 1: Initialize cache struct with empty entries map\n    // TODO 2: Start background cleanup goroutine (runs every minute)\n    // TODO 3: Set configuration parameters\n    return nil\n}\n\n// Get retrieves a cached entry if present and not expired\nfunc (c *Cache) Get(key CacheKey) (*CacheEntry, bool) {\n    // TODO 1: Acquire read lock\n    // TODO 2: Look up entry in map\n    // TODO 3: Check if entry has expired (time.Now().After(entry.ExpiresAt))\n    // TODO 4: Return copy of entry (don't return pointer to internal data)\n    // Hint: Always return copies to prevent callers from modifying cache data\n    return nil, false\n}\n```\n\n#### Milestone Checkpoints\n\n**Milestone 1 Checkpoint: Message Parsing**\nAfter implementing the parser component, verify correct behavior:\n- Run `go test ./internal/parser/...` - all parsing tests should pass\n- Test with sample DNS query: `dig @127.0.0.1 -p 8053 example.com` \n- Expected: Server receives packet, parses header correctly, extracts question\n- Debug: Add logging to see parsed header fields and question details\n\n**Milestone 2 Checkpoint: Basic Server**\nAfter implementing UDP server and basic response handling:\n- Run `go run cmd/dns-server/main.go` to start server\n- Test with `dig @127.0.0.1 -p 8053 test.local`\n- Expected: Server responds with basic DNS response (even if empty)\n- Debug: Use Wireshark to capture packets and verify response format\n\n**Milestone 3 Checkpoint: Component Integration**\nAfter connecting all components:\n- Test authoritative responses for local zones\n- Test recursive resolution for external domains  \n- Expected: Different response types based on query and configuration\n- Debug: Add logging at component boundaries to trace query flow\n\n#### Language-Specific Implementation Hints\n\n**Go-Specific DNS Implementation Guidance:**\n\n- Use `binary.BigEndian` for all DNS header field parsing - DNS uses network byte order\n- Implement `String()` methods on DNS types for debugging - extremely helpful for tracing message flow\n- Use `context.WithTimeout()` for all network operations to prevent hanging on unresponsive servers\n- The `net` package's `SplitHostPort()` handles IPv6 addresses correctly for client address parsing\n- Use `sync.RWMutex` for cache access - many concurrent reads, fewer writes\n- Implement graceful shutdown with `context.CancelFunc` and proper connection cleanup\n- Use buffered channels for the worker semaphore to prevent goroutine blocking\n\n**Testing and Debugging:**\n- Install `dig` for manual DNS testing: `apt-get install dnsutils` or `brew install bind`\n- Use `go run -race` to detect concurrent access bugs in cache and server components  \n- Wireshark with DNS filter helps debug protocol-level issues\n- Add structured logging with request IDs to trace queries through components\n\n\n## Data Model\n\n> **Milestone(s):** 1 (DNS Message Parsing), 2 (Authoritative Server), 3 (Recursive Resolver), 4 (Caching & Performance)\n\n### Mental Model: DNS Data as Structured Documents\n\nThink of DNS data structures as organized filing systems in a large corporation. The **DNS message** is like an inter-office memo with a standard header containing routing information (sender, recipient, message type) followed by structured sections for questions, answers, and supporting documents. The **resource records** are like individual file folders, each labeled with a name, category, and expiration date, containing specific information about network resources. The **cache** functions like a secretary's desk drawer of frequently referenced documents, automatically discarding outdated papers when their expiration dates pass. Finally, **zone data** resembles the authoritative filing cabinets maintained by each department, containing the definitive records for their area of responsibility.\n\nThis mental model helps understand why DNS parsing requires careful attention to structure—just as a misfiled memo can disrupt business operations, a malformed DNS message can break name resolution. The binary wire format is like using a standardized inter-office mail system where every memo follows identical formatting rules for reliable delivery across different departments and buildings.\n\nThe DNS protocol's design reflects the need for efficient transmission over unreliable networks, similar to how corporate memos use concise, structured formats to ensure clear communication even when photocopied or faxed multiple times. Name compression in DNS messages is analogous to using departmental abbreviations and reference numbers to keep memos short while maintaining all necessary information.\n\n### DNS Message Format\n\nThe DNS message structure forms the foundation of all communication in the DNS protocol, serving as the container for queries and responses flowing between clients and servers. Understanding this format in detail is crucial because every DNS operation—from simple lookups to complex recursive resolution—relies on correctly parsing and constructing these binary messages.\n\nThe complete DNS message consists of five distinct sections that must be processed in order: the fixed-length header containing metadata and section counts, the question section describing what information is being requested, and three variable-length resource record sections containing the actual DNS data. This hierarchical structure allows DNS messages to carry complex information while maintaining backward compatibility and efficient network transmission.\n\n> **Critical Insight**: DNS messages use a binary wire format optimized for network transmission, not human readability. Every field has a precise byte layout and endianness requirement that must be followed exactly for interoperability with other DNS implementations.\n\n#### DNS Message Structure Overview\n\n| Section | Purpose | Count Field | Content |\n|---------|---------|-------------|---------|\n| Header | Message metadata and flags | Fixed 12 bytes | ID, flags, section counts |\n| Questions | Query specifications | `QuestionCount` | Domain name, record type, class |\n| Answers | Direct responses to questions | `AnswerCount` | Resource records matching query |\n| Authority | Authoritative information | `AuthorityCount` | NS records or SOA for delegation |\n| Additional | Supporting information | `AdditionalCount` | Glue records, additional data |\n\n#### Header Structure Details\n\nThe DNS header occupies exactly 12 bytes and contains all the metadata necessary for message routing, type identification, and response correlation. Every field in the header serves a specific purpose in the DNS protocol state machine, from matching responses to queries through the ID field to indicating whether recursion is desired or available.\n\n| Field | Type | Bits | Purpose | Values |\n|-------|------|------|---------|--------|\n| `ID` | `uint16` | 16 | Query/response correlation | 0-65535, client chosen |\n| `QueryResponse` | `bool` | 1 | Message type indicator | false=query, true=response |\n| `Opcode` | `uint8` | 4 | Operation type | 0=query, 1=inverse query, 2=status |\n| `Authoritative` | `bool` | 1 | Authoritative answer flag | true if server is authoritative |\n| `Truncated` | `bool` | 1 | Message truncation flag | true if message was truncated |\n| `RecursionDesired` | `bool` | 1 | Client recursion request | true if client wants recursion |\n| `RecursionAvail` | `bool` | 1 | Server recursion capability | true if server supports recursion |\n| `Reserved` | `uint8` | 3 | Reserved for future use | Must be zero |\n| `ResponseCode` | `uint8` | 4 | Response status | 0=no error, 3=NXDOMAIN, etc. |\n| `QuestionCount` | `uint16` | 16 | Number of questions | Usually 1 for standard queries |\n| `AnswerCount` | `uint16` | 16 | Number of answer records | Set by responding server |\n| `AuthorityCount` | `uint16` | 16 | Number of authority records | NS or SOA records |\n| `AdditionalCount` | `uint16` | 16 | Number of additional records | Glue records, OPT records |\n\nThe header flags encode critical protocol state information that determines how both clients and servers process the message. The `QueryResponse` bit distinguishes between queries flowing from client to server and responses flowing back. The `Authoritative` bit indicates whether the responding server has definitive knowledge of the requested domain, which affects caching behavior and trust decisions.\n\nThe recursion flags (`RecursionDesired` and `RecursionAvail`) establish a contract between client and server about resolution responsibility. When a client sets `RecursionDesired` to true, it's asking the server to perform complete resolution rather than just returning referrals. The server indicates its willingness to perform recursion through the `RecursionAvail` flag in its responses.\n\n> **Decision: 16-bit Network Byte Order for All Multi-byte Fields**\n> - **Context**: DNS messages traverse networks with different endianness architectures\n> - **Options Considered**: Host byte order, network byte order, little-endian\n> - **Decision**: Use network byte order (big-endian) for all multi-byte fields\n> - **Rationale**: RFC 1035 mandates network byte order for DNS wire format; ensures interoperability across all platforms and network equipment\n> - **Consequences**: Requires explicit byte order conversion on little-endian systems but guarantees protocol compliance\n\n#### Question Section Structure\n\nThe question section specifies what information the client is requesting from the DNS server. Each question contains three components: the domain name being queried, the type of resource record requested, and the protocol class (almost always Internet class). While the DNS protocol technically supports multiple questions in a single message, standard practice uses exactly one question per message to avoid implementation complexity and ambiguity in responses.\n\n| Field | Type | Format | Purpose |\n|-------|------|--------|---------|\n| `Name` | `string` | DNS name encoding | Domain name being queried |\n| `Type` | `uint16` | Network byte order | Resource record type (A, AAAA, CNAME, etc.) |\n| `Class` | `uint16` | Network byte order | Protocol class (1=Internet, others deprecated) |\n\nThe domain name encoding follows DNS label format where each label is prefixed by its length as a single byte, with the entire name terminated by a zero-length label. This format allows efficient parsing while supporting name compression through pointer labels that reference previously occurring names in the same message.\n\nCommon record types include A (IPv4 address), AAAA (IPv6 address), CNAME (canonical name alias), MX (mail exchange), NS (name server), SOA (start of authority), and TXT (text data). The numeric values for these types are standardized across all DNS implementations, ensuring consistent interpretation regardless of software vendor or platform.\n\n#### Resource Record Structure\n\nResource records carry the actual DNS data in the answer, authority, and additional sections of DNS messages. Each resource record follows an identical header format containing the name, type, class, and TTL, followed by variable-length data specific to the record type. This consistent structure allows generic parsing code to handle all record types while delegating type-specific interpretation to specialized handlers.\n\n| Field | Type | Purpose | Constraints |\n|-------|------|---------|-------------|\n| `Name` | `string` | Domain name this record describes | DNS name format, compression allowed |\n| `Type` | `uint16` | Resource record type | Standard IANA registry values |\n| `Class` | `uint16` | Protocol class | 1 for Internet class |\n| `TTL` | `uint32` | Time-to-live in seconds | 0 to 2^31-1, cache expiration time |\n| `DataLength` | `uint16` | Length of data field in bytes | Wire format only, not in internal representation |\n| `Data` | `[]byte` | Type-specific resource data | Format depends on record type |\n\nThe TTL field serves dual purposes: it indicates how long the record remains valid for caching purposes, and it provides a mechanism for zone administrators to control cache behavior across the internet. Short TTL values allow rapid updates but increase query load, while long TTL values reduce load but slow propagation of changes.\n\n> **Decision: Raw Bytes for Resource Record Data Storage**\n> - **Context**: Different record types have vastly different data formats and parsing requirements\n> - **Options Considered**: Type-specific structs, interface{} with type switching, raw byte storage\n> - **Decision**: Store resource record data as raw bytes with type-specific parsing on demand\n> - **Rationale**: Avoids complex type hierarchies; enables efficient message forwarding without re-parsing; supports unknown record types for future extensibility\n> - **Consequences**: Requires type-specific parsing functions but simplifies core message handling and storage\n\n#### Name Compression Algorithm\n\nDNS name compression reduces message size by replacing repeated domain names with pointers to earlier occurrences in the same message. This optimization is crucial for DNS performance because many messages contain multiple references to the same domain names, particularly in authority and additional sections where NS records and their corresponding A records appear together.\n\nThe compression mechanism uses a special label format where the first two bits are set to 11 (binary), indicating a pointer label rather than a regular length-prefixed label. The remaining 14 bits contain an offset from the beginning of the DNS message to the location where the full name appears. This allows names to be referenced without duplication while maintaining the ability to parse names without lookahead.\n\n**Compression Parsing Algorithm:**\n\n1. **Initialize** parsing state with current position and empty name buffer\n2. **Read label length byte** from current position in message\n3. **Check label type** using the top two bits of the length byte\n4. **If regular label** (bits 00): read specified number of characters, append to name with dot separator, advance position\n5. **If compression pointer** (bits 11): extract 14-bit offset, validate it points earlier in message, recursively parse name at offset location\n6. **If end of name** (length 0): terminate parsing and return complete name\n7. **Repeat** from step 2 until name termination or pointer resolution\n\nThe compression algorithm must include cycle detection to prevent infinite loops when malformed messages contain circular pointer references. A robust implementation tracks visited positions during pointer following and rejects messages that revisit any position during name parsing.\n\n> ⚠️ **Pitfall: Compression Pointer Loops**\n> Malicious or corrupted messages may contain compression pointers that create cycles, causing parsers to loop infinitely. Always track visited positions during pointer following and reject messages that revisit any position during name resolution. Set a maximum recursion depth (typically 255) to bound worst-case parsing time even without explicit cycle detection.\n\n#### Message Size and Truncation Handling\n\nDNS messages over UDP are limited to 512 bytes by default, reflecting historical limitations of early internet infrastructure. When a complete response exceeds this limit, servers set the truncated flag in the header and client implementations must retry the query over TCP to receive the complete answer. This size constraint significantly influences DNS message design and caching strategies.\n\nModern DNS extensions like EDNS0 allow clients to advertise support for larger UDP messages, but implementations must still handle the 512-byte baseline for compatibility. The truncation mechanism provides a graceful fallback that maintains functionality while encouraging the use of more efficient UDP transport for typical queries.\n\n**Message Size Considerations:**\n\n| Component | Typical Size | Maximum Size | Impact on Design |\n|-----------|-------------|--------------|------------------|\n| Header | 12 bytes | 12 bytes | Fixed overhead for all messages |\n| Question | 20-50 bytes | 255 bytes | Domain name length dominates |\n| A Record | 16 bytes | 16 bytes | Fixed size, efficient packing |\n| AAAA Record | 28 bytes | 28 bytes | Larger than A, affects message capacity |\n| CNAME Record | 20-100 bytes | Variable | Name length dependent |\n| MX Record | 25-75 bytes | Variable | Priority + name length |\n\nThe size constraints encourage DNS architects to design zones with shorter domain names and to use caching aggressively to minimize query repetition. Server implementations must carefully manage response construction to prioritize the most important information when approaching size limits.\n\n### Cache and Zone Data Structures\n\nThe internal data structures for caching and zone storage form the performance-critical foundation of the DNS server, directly impacting query response times and memory efficiency. These structures must balance fast lookup performance with efficient memory usage while supporting the complex expiration and validation requirements of the DNS protocol.\n\nCache and zone data serve fundamentally different purposes within the DNS server architecture. Zone data represents authoritative information loaded from configuration files, providing definitive answers for domains under the server's authority. Cache data stores temporary copies of records obtained through recursive resolution, with automatic expiration based on TTL values and validation requirements to prevent cache poisoning attacks.\n\n#### Cache Key and Entry Structure\n\nThe cache system uses a composite key structure that uniquely identifies DNS records for storage and retrieval while supporting efficient lookup operations. The key combines the domain name, record type, and class into a single lookup identifier that handles case-insensitivity requirements and supports negative caching for non-existent domains.\n\n| Field | Type | Purpose | Constraints |\n|-------|------|---------|-------------|\n| `Name` | `string` | Domain name (normalized) | Lowercase, fully qualified |\n| `Type` | `uint16` | Resource record type | Standard IANA values |\n| `Class` | `uint16` | Protocol class | Always 1 for Internet |\n\n**Cache Entry Structure:**\n\n| Field | Type | Purpose | Constraints |\n|-------|------|---------|-------------|\n| `Records` | `[]ResourceRecord` | Cached resource records | Empty for negative cache entries |\n| `ExpiresAt` | `time.Time` | Absolute expiration time | Calculated from TTL at insert time |\n| `Negative` | `bool` | Indicates NXDOMAIN/NODATA | True for negative cache entries |\n| `SOARecord` | `ResourceRecord` | Authority for negative entries | Required for negative caching |\n| `InsertTime` | `time.Time` | When entry was cached | For cache statistics and debugging |\n\nThe cache entry structure supports both positive caching (storing actual resource records) and negative caching (remembering that a domain or record type doesn't exist). Negative caching prevents repeated queries for non-existent domains, significantly reducing recursive resolution load for typos and malicious domain queries.\n\n> **Decision: Absolute Expiration Times vs. TTL Storage**\n> - **Context**: Cache entries need expiration tracking for TTL compliance\n> - **Options Considered**: Store original TTL and calculate age, store absolute expiration time, hybrid approach\n> - **Decision**: Store absolute expiration time calculated at insertion\n> - **Rationale**: Eliminates repeated time calculations during cache lookups; simplifies expiration checking; avoids clock skew issues during long-running operations\n> - **Consequences**: Requires time zone consistency but provides faster cache operations and simpler expiration logic\n\n#### Zone Data Organization\n\nZone data represents the authoritative DNS records loaded from configuration files, organized for efficient querying by domain name and record type. The zone structure must support wildcard matching, delegation detection, and SOA record management while providing fast lookup performance for authoritative queries.\n\n**Zone Configuration Structure:**\n\n| Field | Type | Purpose | Example |\n|-------|------|---------|---------|\n| `Domain` | `string` | Zone apex domain | \"example.com.\" |\n| `File` | `string` | Zone file path | \"/etc/dns/example.com.zone\" |\n| `SOA` | `ResourceRecord` | Start of authority record | Contains refresh, retry, expire timers |\n| `Records` | `map[string][]ResourceRecord` | Name to record mapping | Indexed by fully qualified domain name |\n| `Delegations` | `map[string][]ResourceRecord` | Subdomain delegations | NS records for delegated subzones |\n\n**Zone Record Index Structure:**\n\nThe zone record storage uses a hierarchical map structure that enables efficient exact match lookups while supporting wildcard resolution and closest encloser identification for NXDOMAIN responses with proper authority sections.\n\n```\nRecords map structure:\n  \"example.com.\" → [SOA, NS, A, AAAA records]\n  \"www.example.com.\" → [A, AAAA records]\n  \"mail.example.com.\" → [A, MX records]\n  \"*.example.com.\" → [A records for wildcard]\n  \"sub.example.com.\" → [NS records for delegation]\n```\n\nThe zone data structure must handle several DNS-specific requirements that distinguish it from simple key-value storage. Wildcard records apply to any non-existent subdomain within their scope, requiring special matching logic during query processing. Delegation points mark where authority transfers to other name servers, requiring careful handling of glue records and referral construction.\n\n> **Decision: In-Memory Zone Storage with Periodic Reload**\n> - **Context**: Zone data needs fast access during query processing but may change through file updates\n> - **Options Considered**: File-based lookup, full in-memory storage, hybrid caching approach\n> - **Decision**: Load complete zone data into memory with periodic reload detection\n> - **Rationale**: DNS queries are latency-sensitive; file I/O during query processing creates unacceptable delays; memory usage is bounded by zone size\n> - **Consequences**: Higher memory usage but predictable query performance; requires file change detection for dynamic updates\n\n#### Cache Operations and TTL Management\n\nThe cache system implements TTL-based expiration with automatic cleanup and size-based eviction to maintain bounded memory usage while maximizing cache hit rates. The cache operations must be thread-safe to support concurrent query processing while providing efficient lookup and insertion performance.\n\n**Core Cache Operations:**\n\n| Method | Parameters | Returns | Purpose |\n|--------|------------|---------|---------|\n| `Get` | `CacheKey` | `*CacheEntry, bool` | Retrieve valid cache entry |\n| `Put` | `CacheKey, []ResourceRecord, uint32` | `error` | Store records with TTL |\n| `PutNegative` | `CacheKey, ResourceRecord` | `error` | Store negative response |\n| `Evict` | `CacheKey` | `bool` | Remove specific entry |\n| `Cleanup` | none | `int` | Remove expired entries |\n| `Stats` | none | `CacheStats` | Return usage statistics |\n\nThe TTL management system calculates absolute expiration times during cache insertion, enabling efficient expiration checking without repeated time arithmetic. The cleanup operation runs periodically to reclaim memory from expired entries, while size-based eviction removes least recently used entries when the cache approaches configured limits.\n\n**Cache Statistics Structure:**\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `HitRate` | `float64` | Percentage of queries served from cache |\n| `TotalQueries` | `uint64` | Total number of cache lookups |\n| `CacheHits` | `uint64` | Number of successful cache lookups |\n| `CacheMisses` | `uint64` | Number of failed cache lookups |\n| `EntryCount` | `int` | Current number of cached entries |\n| `MemoryUsage` | `int64` | Estimated memory usage in bytes |\n| `EvictionCount` | `uint64` | Number of entries evicted for space |\n\n#### Negative Caching Implementation\n\nNegative caching stores information about non-existent domains and record types to prevent repeated recursive resolution attempts for invalid queries. This optimization significantly reduces server load when handling typos, scan attempts, and other queries for non-existent resources.\n\n**Negative Cache Entry Types:**\n\n| Type | Description | TTL Source | Cache Key |\n|------|-------------|------------|-----------|\n| NXDOMAIN | Domain doesn't exist | SOA minimum TTL | Name=domain, Type=any |\n| NODATA | Domain exists, record type doesn't | SOA minimum TTL | Name=domain, Type=specific |\n| NXRRSET | No records of requested type | Original query TTL | Name=domain, Type=specific |\n\nNegative caching requires careful TTL management because negative responses don't contain explicit TTL values. Instead, the TTL for negative cache entries derives from the minimum TTL field in the SOA record of the zone that provided the negative response. This ensures that negative cache entries expire appropriately when zone data changes.\n\n> ⚠️ **Pitfall: Negative Cache TTL Confusion**\n> Negative cache entries must use the SOA minimum TTL from the authority section, not the TTL of the SOA record itself. The SOA minimum field specifically controls negative caching duration, while the SOA record TTL controls how long the SOA record itself should be cached. Using the wrong TTL can cause negative entries to persist too long or expire too quickly.\n\n#### Thread Safety and Concurrent Access\n\nThe cache and zone data structures must support concurrent access from multiple goroutines processing DNS queries simultaneously. This requires careful synchronization to prevent race conditions while maintaining high performance for read-heavy workloads typical of DNS servers.\n\n**Concurrency Design Considerations:**\n\n| Operation | Frequency | Synchronization Strategy | Performance Impact |\n|-----------|-----------|--------------------------|-------------------|\n| Cache lookups | Very high | Read-write mutex (read lock) | Minimal contention |\n| Cache insertions | Moderate | Read-write mutex (write lock) | Brief blocking |\n| Zone lookups | High | Read-only after loading | No contention |\n| Zone reloading | Very low | Replace entire structure | Brief interruption |\n| Cache cleanup | Low | Background goroutine | Minimal impact |\n\nThe synchronization strategy uses read-write mutexes for cache operations, allowing multiple concurrent readers while ensuring exclusive access for writers. Zone data loading creates new data structures atomically and replaces pointers, minimizing the critical section duration during zone updates.\n\n### Implementation Guidance\n\nThis implementation guidance provides concrete Go code structures and patterns for building the DNS message parsing and data management components. The focus is on creating robust, efficient data structures that handle the binary DNS protocol correctly while providing clean interfaces for higher-level components.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Binary Parsing | `encoding/binary` with byte slices | Custom bit manipulation with unsafe |\n| Name Storage | `strings` with normalization | Interned string table for memory efficiency |\n| Cache Backend | `sync.Map` with cleanup goroutine | Custom hash table with LRU eviction |\n| Time Management | `time.Time` with periodic cleanup | Time wheel for efficient TTL tracking |\n| Concurrency | `sync.RWMutex` for cache protection | Lock-free structures with atomic operations |\n\n#### Recommended File Structure\n\n```\nproject-root/\n├── internal/dns/\n│   ├── message.go           ← DNSMessage, Header, Question, ResourceRecord types\n│   ├── message_test.go      ← Message parsing and serialization tests\n│   ├── parser.go            ← ParseMessage, parseHeader, parseName functions\n│   ├── parser_test.go       ← Parser unit tests with sample messages\n│   ├── compression.go       ← Name compression implementation\n│   └── constants.go         ← DNS protocol constants and record types\n├── internal/cache/\n│   ├── cache.go             ← Cache interface and implementation\n│   ├── cache_test.go        ← Cache behavior tests\n│   ├── entry.go             ← CacheEntry and CacheKey types\n│   └── stats.go             ← CacheStats tracking\n├── internal/zone/\n│   ├── zone.go              ← Zone data structures and loading\n│   ├── zone_test.go         ← Zone file parsing tests\n│   ├── parser.go            ← Zone file format parser\n│   └── testdata/            ← Sample zone files for testing\n└── testdata/\n    ├── sample_queries/       ← Binary DNS message samples\n    └── zone_files/          ← Example zone file formats\n```\n\n#### DNS Message Infrastructure Code\n\n**Core Message Types** (`internal/dns/message.go`):\n\n```go\npackage dns\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\n// DNS protocol constants\nconst (\n\tDNS_HEADER_SIZE  = 12\n\tDNS_UDP_MAX_SIZE = 512\n\tDEFAULT_PORT     = 53\n\t\n\t// DNS message flags\n\tFLAG_QR = 1 << 15  // Query/Response\n\tFLAG_AA = 1 << 10  // Authoritative Answer\n\tFLAG_TC = 1 << 9   // Truncated\n\tFLAG_RD = 1 << 8   // Recursion Desired\n\tFLAG_RA = 1 << 7   // Recursion Available\n\t\n\t// DNS record types\n\tTYPE_A     = 1\n\tTYPE_NS    = 2\n\tTYPE_CNAME = 5\n\tTYPE_SOA   = 6\n\tTYPE_MX    = 15\n\tTYPE_TXT   = 16\n\tTYPE_AAAA  = 28\n\t\n\t// DNS response codes\n\tRCODE_NOERROR  = 0\n\tRCODE_FORMERR  = 1\n\tRCODE_SERVFAIL = 2\n\tRCODE_NXDOMAIN = 3\n)\n\n// DNSMessage represents a complete DNS message with all sections\ntype DNSMessage struct {\n\tHeader     Header           `json:\"header\"`\n\tQuestions  []Question       `json:\"questions\"`\n\tAnswers    []ResourceRecord `json:\"answers\"`\n\tAuthority  []ResourceRecord `json:\"authority\"`\n\tAdditional []ResourceRecord `json:\"additional\"`\n}\n\n// Header contains DNS message header fields per RFC 1035\ntype Header struct {\n\tID              uint16 `json:\"id\"`\n\tQueryResponse   bool   `json:\"query_response\"`\n\tOpcode          uint8  `json:\"opcode\"`\n\tAuthoritative   bool   `json:\"authoritative\"`\n\tTruncated       bool   `json:\"truncated\"`\n\tRecursionDesired bool   `json:\"recursion_desired\"`\n\tRecursionAvail   bool   `json:\"recursion_available\"`\n\tResponseCode     uint8  `json:\"response_code\"`\n\tQuestionCount    uint16 `json:\"question_count\"`\n\tAnswerCount      uint16 `json:\"answer_count\"`\n\tAuthorityCount   uint16 `json:\"authority_count\"`\n\tAdditionalCount  uint16 `json:\"additional_count\"`\n}\n\n// Question represents a DNS question section entry\ntype Question struct {\n\tName  string `json:\"name\"`\n\tType  uint16 `json:\"type\"`\n\tClass uint16 `json:\"class\"`\n}\n\n// ResourceRecord represents any DNS resource record\ntype ResourceRecord struct {\n\tName  string `json:\"name\"`\n\tType  uint16 `json:\"type\"`\n\tClass uint16 `json:\"class\"`\n\tTTL   uint32 `json:\"ttl\"`\n\tData  []byte `json:\"data\"`\n}\n\n// Validation helper methods\nfunc (h *Header) IsQuery() bool {\n\treturn !h.QueryResponse\n}\n\nfunc (h *Header) IsResponse() bool {\n\treturn h.QueryResponse\n}\n\nfunc (rr *ResourceRecord) IsExpired(now time.Time, insertTime time.Time) bool {\n\treturn now.Sub(insertTime) > time.Duration(rr.TTL)*time.Second\n}\n```\n\n**Cache Infrastructure** (`internal/cache/cache.go`):\n\n```go\npackage cache\n\nimport (\n\t\"sync\"\n\t\"time\"\n\t\n\t\"github.com/yourproject/internal/dns\"\n)\n\n// CacheKey uniquely identifies a cached DNS record\ntype CacheKey struct {\n\tName  string `json:\"name\"`\n\tType  uint16 `json:\"type\"`\n\tClass uint16 `json:\"class\"`\n}\n\n// CacheEntry stores cached DNS data with expiration information\ntype CacheEntry struct {\n\tRecords    []dns.ResourceRecord `json:\"records\"`\n\tExpiresAt  time.Time           `json:\"expires_at\"`\n\tNegative   bool                `json:\"negative\"`\n\tSOARecord  *dns.ResourceRecord  `json:\"soa_record,omitempty\"`\n\tInsertTime time.Time           `json:\"insert_time\"`\n}\n\n// CacheStats provides cache performance metrics\ntype CacheStats struct {\n\tHitRate       float64 `json:\"hit_rate\"`\n\tTotalQueries  uint64  `json:\"total_queries\"`\n\tCacheHits     uint64  `json:\"cache_hits\"`\n\tCacheMisses   uint64  `json:\"cache_misses\"`\n\tEntryCount    int     `json:\"entry_count\"`\n\tMemoryUsage   int64   `json:\"memory_usage\"`\n\tEvictionCount uint64  `json:\"eviction_count\"`\n}\n\n// Cache provides thread-safe DNS record caching with TTL expiration\ntype Cache struct {\n\tmu      sync.RWMutex\n\tentries map[CacheKey]*CacheEntry\n\tstats   CacheStats\n\tmaxSize int\n}\n\n// NewCache creates a new DNS cache with the specified maximum size\nfunc NewCache(maxSize int) *Cache {\n\treturn &Cache{\n\t\tentries: make(map[CacheKey]*CacheEntry),\n\t\tmaxSize: maxSize,\n\t}\n}\n\n// Get retrieves a cache entry if present and not expired\nfunc (c *Cache) Get(key CacheKey) (*CacheEntry, bool) {\n\t// TODO 1: Acquire read lock for concurrent access safety\n\t// TODO 2: Look up entry in the entries map\n\t// TODO 3: Check if entry exists and is not expired\n\t// TODO 4: Update cache hit/miss statistics\n\t// TODO 5: Return entry and existence boolean\n\t// Hint: Use time.Now() to check expiration against ExpiresAt\n\tpanic(\"implement me\")\n}\n\n// Put stores DNS records in the cache with TTL-based expiration\nfunc (c *Cache) Put(key CacheKey, records []dns.ResourceRecord, ttl uint32) error {\n\t// TODO 1: Calculate absolute expiration time from TTL\n\t// TODO 2: Create new CacheEntry with records and expiration\n\t// TODO 3: Acquire write lock for modification\n\t// TODO 4: Check if cache is at maximum size and evict if needed\n\t// TODO 5: Store entry in the entries map\n\t// TODO 6: Update cache statistics\n\t// Hint: Use time.Now().Add(time.Duration(ttl) * time.Second) for expiration\n\tpanic(\"implement me\")\n}\n\n// PutNegative stores a negative cache entry for NXDOMAIN/NODATA responses\nfunc (c *Cache) PutNegative(key CacheKey, soaRecord dns.ResourceRecord) error {\n\t// TODO 1: Extract minimum TTL from SOA record data for negative caching duration\n\t// TODO 2: Create CacheEntry with Negative=true and empty Records slice\n\t// TODO 3: Include SOA record for authority information\n\t// TODO 4: Store entry using the same logic as Put() but mark as negative\n\t// Hint: SOA minimum TTL is at bytes 16-20 in SOA record data\n\tpanic(\"implement me\")\n}\n\n// Methods for eviction, cleanup, and statistics...\n```\n\n#### Core Logic Skeleton Code\n\n**Message Parser** (`internal/dns/parser.go`):\n\n```go\npackage dns\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n)\n\n// ParseMessage parses a complete DNS message from wire format bytes\nfunc ParseMessage(data []byte) (*DNSMessage, error) {\n\t// TODO 1: Validate minimum message length (at least header size)\n\t// TODO 2: Parse the 12-byte header using parseHeader()\n\t// TODO 3: Initialize message with parsed header\n\t// TODO 4: Parse question section based on QuestionCount\n\t// TODO 5: Parse answer section based on AnswerCount  \n\t// TODO 6: Parse authority section based on AuthorityCount\n\t// TODO 7: Parse additional section based on AdditionalCount\n\t// TODO 8: Validate that all bytes were consumed (no trailing data)\n\t// Hint: Keep track of current offset as you parse each section\n\tpanic(\"implement me\")\n}\n\n// parseHeader extracts DNS header from the first 12 bytes of a message\nfunc parseHeader(data []byte) (Header, error) {\n\t// TODO 1: Verify data is at least DNS_HEADER_SIZE bytes\n\t// TODO 2: Extract ID from bytes 0-1 using binary.BigEndian\n\t// TODO 3: Extract and decode flags from bytes 2-3 into individual boolean fields\n\t// TODO 4: Extract section counts from remaining header bytes (4-11)\n\t// TODO 5: Return populated Header struct\n\t// Hint: Use bit operations to extract individual flags from the 16-bit flags field\n\tpanic(\"implement me\")\n}\n\n// parseName extracts a DNS name from message data with compression support\nfunc parseName(data []byte, offset int) (string, int, error) {\n\t// TODO 1: Initialize name buffer and current position tracking\n\t// TODO 2: Track visited positions to detect compression loops\n\t// TODO 3: Read label length byte at current position\n\t// TODO 4: Handle regular labels (length 1-63): read characters, append to name\n\t// TODO 5: Handle compression pointers (bits 11): extract offset, jump to referenced position\n\t// TODO 6: Handle name termination (length 0): finalize and return name\n\t// TODO 7: Validate all label lengths and pointer offsets are within bounds\n\t// TODO 8: Return complete name, final offset, and any parsing error\n\t// Hint: Use a map[int]bool to track visited positions during pointer following\n\tpanic(\"implement me\")\n}\n\n// SerializeMessage converts a DNS message to wire format for network transmission\nfunc SerializeMessage(msg *DNSMessage) ([]byte, error) {\n\t// TODO 1: Calculate total message size needed for pre-allocation\n\t// TODO 2: Serialize header with section counts\n\t// TODO 3: Serialize questions section\n\t// TODO 4: Serialize answer resource records\n\t// TODO 5: Serialize authority resource records  \n\t// TODO 6: Serialize additional resource records\n\t// TODO 7: Apply name compression where beneficial\n\t// TODO 8: Validate final message size is within limits\n\t// Hint: Build a compression table as you serialize to track name positions\n\tpanic(\"implement me\")\n}\n```\n\n#### Zone Data Management\n\n**Zone Loading** (`internal/zone/zone.go`):\n\n```go\npackage zone\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\n\t\"github.com/yourproject/internal/dns\"\n)\n\n// Zone represents authoritative DNS data for a domain\ntype Zone struct {\n\tDomain      string                              `json:\"domain\"`\n\tSOA         *dns.ResourceRecord                 `json:\"soa\"`\n\tRecords     map[string][]dns.ResourceRecord     `json:\"records\"`\n\tDelegations map[string][]dns.ResourceRecord     `json:\"delegations\"`\n\tmu          sync.RWMutex                        `json:\"-\"`\n}\n\n// LoadZone reads a BIND-format zone file and returns a Zone structure\nfunc LoadZone(domain, filename string) (*Zone, error) {\n\t// TODO 1: Open zone file and create buffered reader\n\t// TODO 2: Initialize zone structure with domain name\n\t// TODO 3: Parse zone file line by line, handling comments and continuations\n\t// TODO 4: Parse SOA record and store as zone authority\n\t// TODO 5: Parse NS records and identify delegations\n\t// TODO 6: Parse A, AAAA, CNAME, MX, TXT records into records map\n\t// TODO 7: Validate zone has required SOA and NS records\n\t// TODO 8: Return fully populated zone structure\n\t// Hint: Use strings.Fields() to split zone file lines into components\n\tpanic(\"implement me\")\n}\n\n// LookupAuthoritative finds records in the zone for a given question\nfunc (z *Zone) LookupAuthoritative(question dns.Question) ([]dns.ResourceRecord, error) {\n\t// TODO 1: Acquire read lock for concurrent access protection\n\t// TODO 2: Normalize the question name to lowercase FQDN format\n\t// TODO 3: Check for exact match in records map\n\t// TODO 4: If no exact match, check for wildcard matches\n\t// TODO 5: If no match found, return appropriate NXDOMAIN/NODATA response\n\t// TODO 6: Handle CNAME records with special processing\n\t// TODO 7: Return matching records with proper authority section\n\t// Hint: Wildcard matching requires checking parent domains for \"*\" labels\n\tpanic(\"implement me\")\n}\n```\n\n#### Milestone Checkpoints\n\n**Milestone 1 - DNS Message Parsing:**\n- Run: `go test ./internal/dns/...` \n- Expected: All parsing tests pass, including compression and edge cases\n- Manual test: Create a simple program that parses a real DNS query packet\n- Signs of problems: Panic on malformed input, incorrect flag parsing, name compression failures\n\n**Milestone 2 - Zone Data Loading:**\n- Run: `go test ./internal/zone/...`\n- Expected: Zone file parser handles BIND format correctly\n- Manual test: Load a zone file and query for different record types\n- Signs of problems: Missing records, incorrect TTL values, delegation handling errors\n\n**Milestone 3 - Cache Operations:**\n- Run: `go test ./internal/cache/...`\n- Expected: Cache stores and retrieves records, handles TTL expiration\n- Manual test: Store records, wait for TTL expiration, verify automatic cleanup\n- Signs of problems: Memory leaks from expired entries, race conditions, incorrect TTL calculations\n\n#### Language-Specific Implementation Hints\n\n**Binary Parsing in Go:**\n- Use `encoding/binary.BigEndian.Uint16()` for network byte order conversion\n- Validate slice bounds before accessing to prevent panics\n- Use `bytes.Buffer` for efficient message construction during serialization\n\n**Concurrency Patterns:**\n- Use `sync.RWMutex` for read-heavy cache workloads\n- Implement atomic operations with `sync/atomic` for statistics counters  \n- Use `context.Context` for timeout handling in network operations\n\n**Memory Management:**\n- Pre-allocate slices with known capacity to reduce garbage collection\n- Use string interning for repeated domain names to save memory\n- Implement periodic cleanup goroutines with `time.Ticker` for expired entries\n\n**Testing Strategies:**\n- Create test helper functions for generating valid DNS messages\n- Use table-driven tests for comprehensive edge case coverage\n- Test with real DNS message captures from network traffic for validation\n\n\n## DNS Message Parsing (Milestone 1)\n\n> **Milestone(s):** 1 (DNS Message Parsing)\n\nThe foundation of any DNS server lies in its ability to parse and construct DNS messages in their binary wire format. DNS messages are not human-readable text like HTTP requests—they are carefully structured binary documents that pack maximum information into minimum bytes for efficient network transmission. Understanding this binary protocol is essential before implementing any higher-level DNS functionality.\n\n### Mental Model: DNS as Structured Binary Documents\n\nThink of DNS messages like highly structured legal documents with a rigid format. Just as a legal contract has specific sections (header information, parties involved, terms, signatures) that must appear in a particular order, DNS messages have exactly four sections that must be parsed in sequence: the header, questions, answers, and authority/additional records.\n\n![DNS Message Data Structure](./diagrams/dns-message-structure.svg)\n\nHowever, unlike text documents, DNS messages are binary data where every bit has meaning. Imagine trying to read a document where the first 12 bytes contain metadata about the document (like the number of pages, document type, and status flags), followed by variable-length sections where you must count bytes carefully to know where one section ends and another begins. This is exactly how DNS message parsing works—there are no delimiters or whitespace to guide you, only precise byte counting and format knowledge.\n\nThe parsing challenge becomes more complex due to **name compression**, DNS's clever optimization technique. Think of name compression like legal document references—instead of writing out \"The State of California\" every time it appears, the document might write it fully once and then use \"said State\" for subsequent references. DNS does something similar but with byte-level pointers: when \"example.com\" appears multiple times in a message, it's written out fully once, and subsequent occurrences are replaced with 2-byte pointers to the original location.\n\n### Name Compression Algorithm\n\nDNS name compression exists because domain names frequently share common suffixes. In a single DNS response, you might see \"www.example.com\", \"mail.example.com\", and \"ns1.example.com\"—all sharing the \".example.com\" suffix. Rather than repeat these bytes, DNS compression stores the suffix once and uses pointers for subsequent references.\n\n![DNS Name Compression Example](./diagrams/name-compression-example.svg)\n\nThe compression algorithm works through **pointer labels** that begin with the bit pattern `11` (which corresponds to bytes starting with `0xC0` or higher). When the parser encounters such a byte, it knows the next byte forms a 14-bit offset pointing backward into the message where the actual name data resides.\n\nHere's how the name compression algorithm operates:\n\n1. **Initialize parsing state**: Start with an empty name buffer and the current parsing offset\n2. **Read label length byte**: This tells you how many characters follow in this label component\n3. **Check for compression pointer**: If the length byte has its top two bits set (≥ 0xC0), this is a pointer\n4. **Handle normal labels**: If not a pointer, read the specified number of characters and add them to the name\n5. **Follow compression pointers**: Extract the 14-bit offset from the pointer bytes and jump to that location\n6. **Continue parsing at pointer target**: Resume normal label parsing from the referenced location\n7. **Detect completion**: Names end with a zero-length label (null terminator)\n8. **Return final name and next parse position**: Provide the complete domain name and where parsing should continue\n\nThe compression algorithm must handle several edge cases. **Nested compression** occurs when a pointer target itself contains pointers—the parser must follow these chains to their conclusion. **Loop detection** is critical because malicious or corrupted messages might create circular pointer references that would cause infinite loops. Most implementations limit pointer following to a maximum depth or maintain a visited-offset list.\n\n> **Critical Insight**: Name compression creates a trade-off between message size reduction and parsing complexity. While compression can reduce message sizes by 20-30% in typical responses, it requires parsers to maintain additional state and perform bounds checking carefully.\n\n### Architecture Decisions for Parsing\n\nSeveral architectural decisions fundamentally shape how DNS message parsing is implemented. Each decision involves trade-offs between performance, memory usage, safety, and code complexity.\n\n> **Decision: Message Parsing Strategy**\n> - **Context**: DNS messages must be parsed from raw UDP packets into structured data for processing\n> - **Options Considered**: \n>   1. Single-pass streaming parser that extracts data on-demand\n>   2. Two-pass parser that validates structure first, then extracts data\n>   3. Full message parser that loads everything into memory structures immediately\n> - **Decision**: Full message parser with immediate structure loading\n> - **Rationale**: DNS messages are small (≤512 bytes for UDP), so memory usage is minimal. Having all data immediately available simplifies resolver logic and error handling. Validation can happen during parsing rather than requiring separate passes.\n> - **Consequences**: Higher memory usage per message (acceptable due to small message sizes), but simpler downstream code and better error locality.\n\n| Parsing Strategy | Memory Usage | Error Detection | Implementation Complexity | Performance |\n|------------------|--------------|-----------------|---------------------------|-------------|\n| Streaming | Minimal | Delayed | High | Best |\n| Two-pass | Moderate | Early | Moderate | Good |\n| Full load | Higher | Immediate | Low | Good |\n\n> **Decision: Name Compression Validation**\n> - **Context**: Name compression pointers could reference invalid offsets or create infinite loops\n> - **Options Considered**:\n>   1. Trust all pointers and follow them without validation\n>   2. Validate pointer targets are within message bounds but allow loops\n>   3. Full validation with bounds checking and loop detection\n> - **Decision**: Full validation with bounds checking and loop detection\n> - **Rationale**: Security is paramount for DNS servers. Invalid pointer following could lead to buffer overruns or infinite loops that enable denial-of-service attacks. The performance cost is minimal compared to the security benefits.\n> - **Consequences**: Slightly more complex parsing code and minor performance overhead, but protection against malformed messages and potential security vulnerabilities.\n\n| Validation Level | Security | Performance | Implementation | Attack Surface |\n|------------------|----------|-------------|----------------|-----------------|\n| No validation | Poor | Best | Simplest | Large |\n| Bounds only | Fair | Good | Moderate | Medium |\n| Full validation | Excellent | Good | Complex | Minimal |\n\n> **Decision: Byte Order Handling**\n> - **Context**: DNS messages use network byte order (big-endian) but most modern processors are little-endian\n> - **Options Considered**:\n>   1. Manual byte swapping with bitwise operations\n>   2. Platform-specific intrinsics for byte order conversion\n>   3. Standard library functions for network-to-host conversion\n> - **Decision**: Standard library functions for network-to-host conversion\n> - **Rationale**: Using established functions like `binary.BigEndian` in Go reduces bugs and improves code readability. These functions are optimized by compiler and runtime teams.\n> - **Consequences**: Cleaner code with fewer byte-manipulation bugs, but slight abstraction overhead (typically optimized away by compilers).\n\nThe parser must also decide how to handle **buffer management**. DNS messages arrive as byte slices from UDP packets, and the parser must track its position while extracting multi-byte values and variable-length strings. The chosen approach uses a parsing cursor that advances through the buffer while maintaining bounds checking at each step.\n\n**Error propagation strategy** affects how parsing failures are handled. The parser uses Go's idiomatic error return pattern, where each parsing function returns both its result and an error. This allows precise error reporting with context about which field failed parsing and why, rather than generic \"parse failed\" messages.\n\n### Common Parsing Pitfalls\n\nDNS message parsing involves numerous subtle challenges that frequently trip up implementers. Understanding these pitfalls is crucial for building robust parsers.\n\n⚠️ **Pitfall: Compression Pointer Loops**\n\nThe most dangerous parsing bug involves following compression pointers that form loops. Consider a malicious message where a pointer at offset 50 references offset 20, and a pointer at offset 20 references offset 50. A naive parser will follow this loop indefinitely, consuming CPU and potentially hanging the server.\n\n**Why it's wrong**: Infinite loops in DNS parsing can enable denial-of-service attacks and violate the expectation that parsing completes in bounded time.\n\n**Detection**: Implement loop detection by tracking visited offsets during name parsing or limiting the maximum number of pointer follows to a reasonable bound (typically 5-10).\n\n**Fix**: Maintain a set of visited offsets during name parsing, or use a simpler counter-based approach:\n\n| Detection Method | Memory Usage | Complexity | Effectiveness |\n|------------------|--------------|-------------|---------------|\n| Visited set | Higher | Moderate | Perfect |\n| Counter limit | Minimal | Low | Good enough |\n| Recursion depth | Minimal | Low | Good enough |\n\n⚠️ **Pitfall: Endianness Confusion**\n\nDNS multi-byte values use network byte order (big-endian), but most development platforms are little-endian. Forgetting to convert byte order results in wildly incorrect values—a message ID of `0x1234` becomes `0x3412` when read incorrectly.\n\n**Why it's wrong**: Incorrect byte order causes message correlation failures, wrong record counts, and invalid resource record parsing.\n\n**Detection**: Values appear scrambled or impossibly large. A question count of 13,568 (0x3500) likely should be 0x0035 (53 questions).\n\n**Fix**: Always use network-to-host conversion functions when reading multi-byte values from DNS messages. Never access multi-byte values directly from byte buffers.\n\n⚠️ **Pitfall: Buffer Overflow in Name Parsing**\n\nDomain name parsing involves reading length-prefixed labels, but malicious messages might contain label lengths that exceed remaining buffer space. Reading beyond buffer bounds can cause crashes or security vulnerabilities.\n\n**Why it's wrong**: Buffer overruns can lead to crashes, memory corruption, or security exploits where attackers control program execution.\n\n**Detection**: Implement bounds checking before every buffer read. Verify that `current_offset + label_length < buffer_size` before reading label data.\n\n**Fix**: Always validate buffer bounds before reading:\n\n| Check Type | When to Apply | Protection Level |\n|------------|---------------|------------------|\n| Label length vs remaining buffer | Before reading each label | Essential |\n| Total name length accumulation | Throughout name parsing | Good practice |\n| Maximum name length limit | At name completion | Defense in depth |\n\n⚠️ **Pitfall: Incomplete Message Validation**\n\nParsers sometimes validate the header but skip validating that section counts match actual section contents. A message claiming 3 answers but containing only 1 answer record can cause array access errors or incomplete processing.\n\n**Why it's wrong**: Mismatched counts can lead to accessing non-existent records or stopping parsing before all data is processed.\n\n**Detection**: Count actual parsed records and compare against header-declared counts after parsing each section.\n\n**Fix**: Implement comprehensive validation that verifies consistency between header counts and actual parsed content:\n\n| Validation Point | Check Performed | Error Type if Failed |\n|------------------|-----------------|----------------------|\n| After questions | Count matches QuestionCount | Structure mismatch |\n| After answers | Count matches AnswerCount | Structure mismatch |\n| After authority | Count matches AuthorityCount | Structure mismatch |\n| After additional | Count matches AdditionalCount | Structure mismatch |\n| End of message | No trailing data remains | Extra data error |\n\n⚠️ **Pitfall: Name Compression Target Validation**\n\nCompression pointers might reference valid offsets that don't contain valid name data. A pointer could reference the middle of a previous resource record's data field, leading to garbage name parsing.\n\n**Why it's wrong**: Invalid compression targets produce malformed domain names that can cause lookup failures or security issues.\n\n**Detection**: Compression targets should only reference the beginning of name fields, not arbitrary message locations.\n\n**Fix**: Maintain a map of valid compression targets (offsets where names begin) during parsing and validate that all pointers reference these known-good locations.\n\n### Implementation Guidance\n\nThe DNS message parsing implementation requires careful attention to binary data handling, error management, and security considerations. This guidance provides both foundational infrastructure and detailed skeleton code for the core parsing logic.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Binary parsing | Manual byte slicing with bounds checks | Binary reader with automatic advancement |\n| Error handling | Return error on first parse failure | Collect multiple errors with detailed context |\n| Name compression | Simple offset tracking with loop counter | Full validation with visited offset sets |\n| Message validation | Basic field presence checks | Comprehensive structural validation |\n| Testing | Manual test cases with hex literals | Property-based testing with random messages |\n\n#### Recommended File Structure\n\nThe parsing implementation should be organized to separate concerns and enable thorough testing:\n\n```\ndns-server/\n  internal/protocol/\n    message.go           ← DNSMessage, Header, Question, ResourceRecord types\n    parser.go            ← ParseMessage, parseHeader, parseName functions  \n    parser_test.go       ← Comprehensive parsing tests with malformed inputs\n    serializer.go        ← SerializeMessage for response construction\n    constants.go         ← DNS_HEADER_SIZE, TYPE_A, RCODE_NXDOMAIN\n  internal/server/\n    server.go            ← Main server that uses protocol package\n  cmd/dns-server/\n    main.go              ← Entry point\n```\n\nThis structure isolates protocol handling from server logic, making both easier to test and maintain.\n\n#### Infrastructure Starter Code\n\nHere's the complete message structure and basic parsing infrastructure. This code is fully functional and handles the complex byte order and buffer management details:\n\n```go\npackage protocol\n\nimport (\n    \"encoding/binary\"\n    \"errors\"\n    \"fmt\"\n    \"strings\"\n)\n\n// DNS message structure as defined in RFC 1035\ntype DNSMessage struct {\n    Header     Header\n    Questions  []Question\n    Answers    []ResourceRecord\n    Authority  []ResourceRecord\n    Additional []ResourceRecord\n}\n\ntype Header struct {\n    ID               uint16\n    QueryResponse    bool    // false = query, true = response\n    Opcode           uint8   // usually 0 for standard query\n    Authoritative    bool    // true if answering server is authoritative\n    Truncated        bool    // true if message was truncated\n    RecursionDesired bool    // true if client wants recursive resolution\n    RecursionAvail   bool    // true if server supports recursion\n    ResponseCode     uint8   // 0 = no error, 3 = NXDOMAIN\n    QuestionCount    uint16\n    AnswerCount      uint16\n    AuthorityCount   uint16\n    AdditionalCount  uint16\n}\n\ntype Question struct {\n    Name  string  // domain name like \"example.com\"\n    Type  uint16  // record type (1 = A, 28 = AAAA, etc.)\n    Class uint16  // usually 1 for Internet class\n}\n\ntype ResourceRecord struct {\n    Name  string  // domain name this record applies to\n    Type  uint16  // record type\n    Class uint16  // record class\n    TTL   uint32  // time to live in seconds\n    Data  []byte  // type-specific data (A record = 4-byte IP)\n}\n\n// DNS protocol constants\nconst (\n    DNS_HEADER_SIZE   = 12\n    DNS_UDP_MAX_SIZE  = 512\n    DEFAULT_PORT      = 53\n    TYPE_A            = 1\n    TYPE_AAAA         = 28\n    TYPE_CNAME        = 5\n    RCODE_NXDOMAIN    = 3\n)\n\n// Parser state for tracking position and preventing infinite loops\ntype parseState struct {\n    data      []byte\n    offset    int\n    visited   map[int]bool  // for compression loop detection\n    jumpCount int           // limit compression pointer follows\n}\n\n// Create new parser state for a message\nfunc newParseState(data []byte) *parseState {\n    return &parseState{\n        data:    data,\n        offset:  0,\n        visited: make(map[int]bool),\n    }\n}\n\n// Check if enough bytes remain for reading\nfunc (p *parseState) canRead(bytes int) bool {\n    return p.offset+bytes <= len(p.data)\n}\n\n// Read single byte and advance\nfunc (p *parseState) readByte() (byte, error) {\n    if !p.canRead(1) {\n        return 0, errors.New(\"unexpected end of message\")\n    }\n    b := p.data[p.offset]\n    p.offset++\n    return b, nil\n}\n\n// Read 16-bit value in network byte order\nfunc (p *parseState) readUint16() (uint16, error) {\n    if !p.canRead(2) {\n        return 0, errors.New(\"unexpected end of message reading uint16\")\n    }\n    value := binary.BigEndian.Uint16(p.data[p.offset:])\n    p.offset += 2\n    return value, nil\n}\n\n// Read 32-bit value in network byte order  \nfunc (p *parseState) readUint32() (uint32, error) {\n    if !p.canRead(4) {\n        return 0, errors.New(\"unexpected end of message reading uint32\")\n    }\n    value := binary.BigEndian.Uint32(p.data[p.offset:])\n    p.offset += 4\n    return value, nil\n}\n\n// Read specified number of bytes\nfunc (p *parseState) readBytes(count int) ([]byte, error) {\n    if !p.canRead(count) {\n        return nil, fmt.Errorf(\"unexpected end of message reading %d bytes\", count)\n    }\n    bytes := make([]byte, count)\n    copy(bytes, p.data[p.offset:p.offset+count])\n    p.offset += count\n    return bytes, nil\n}\n```\n\n#### Core Logic Skeleton Code\n\nHere are the main parsing functions that learners should implement. The TODOs map directly to the algorithm steps described in the design section:\n\n```go\n// ParseMessage parses a complete DNS message from wire format bytes.\n// This is the main entry point that coordinates parsing of all message sections.\nfunc ParseMessage(data []byte) (*DNSMessage, error) {\n    // TODO 1: Validate minimum message size (must be at least DNS_HEADER_SIZE)\n    // TODO 2: Create parse state and initialize message structure\n    // TODO 3: Parse header using parseHeader function\n    // TODO 4: Parse questions section (QuestionCount times)\n    // TODO 5: Parse answers section (AnswerCount times) \n    // TODO 6: Parse authority section (AuthorityCount times)\n    // TODO 7: Parse additional section (AdditionalCount times)\n    // TODO 8: Validate no trailing data remains in message\n    // TODO 9: Return completed message structure\n    // Hint: Each section parsing should validate the count matches actual parsed records\n}\n\n// parseHeader extracts the 12-byte DNS header from the beginning of the message.\n// The header contains flags, counts, and metadata about the message structure.\nfunc parseHeader(state *parseState) (Header, error) {\n    // TODO 1: Read 16-bit message ID \n    // TODO 2: Read 16-bit flags field and extract individual flag bits\n    //         Flags format: QR(1) | Opcode(4) | AA(1) | TC(1) | RD(1) | RA(1) | Z(3) | RCODE(4)\n    // TODO 3: Read QuestionCount (16-bit)\n    // TODO 4: Read AnswerCount (16-bit)  \n    // TODO 5: Read AuthorityCount (16-bit)\n    // TODO 6: Read AdditionalCount (16-bit)\n    // TODO 7: Extract individual flags from the flags field using bit operations\n    // TODO 8: Return populated Header struct\n    // Hint: Use bitwise AND to extract individual flags: (flags & 0x8000) != 0 for QR bit\n}\n\n// parseName extracts a domain name from the DNS message, handling compression pointers.\n// Returns the complete domain name and the next parsing position.\nfunc parseName(state *parseState) (string, error) {\n    // TODO 1: Initialize name parts slice and starting position\n    // TODO 2: Check for compression loop detection (track visited offsets)\n    // TODO 3: Read label length byte\n    // TODO 4: Check if this is a compression pointer (top 2 bits set: >= 0xC0)\n    // TODO 5: For compression pointers:\n    //         - Extract 14-bit offset from pointer bytes  \n    //         - Validate offset is within message bounds\n    //         - Jump to referenced location and continue parsing\n    //         - Track visited offsets to prevent infinite loops\n    // TODO 6: For normal labels:\n    //         - Read specified number of characters\n    //         - Add label to name parts\n    // TODO 7: Continue until null terminator (zero-length label)\n    // TODO 8: Join name parts with dots and return complete name\n    // Hint: Limit compression pointer follows to prevent infinite loops (max 10 jumps)\n}\n\n// parseQuestion extracts a single question from the questions section.\n// Questions contain the domain name being queried and the requested record type.\nfunc parseQuestion(state *parseState) (Question, error) {\n    // TODO 1: Parse domain name using parseName function\n    // TODO 2: Read 16-bit query type (A, AAAA, CNAME, etc.)\n    // TODO 3: Read 16-bit query class (usually 1 for Internet)\n    // TODO 4: Return populated Question struct\n    // Hint: Most queries use class 1 (Internet), other classes are rare\n}\n\n// parseResourceRecord extracts a single resource record from answer/authority/additional sections.\n// Resource records contain the actual DNS data being returned.\nfunc parseResourceRecord(state *parseState) (ResourceRecord, error) {\n    // TODO 1: Parse domain name using parseName function\n    // TODO 2: Read 16-bit record type\n    // TODO 3: Read 16-bit record class  \n    // TODO 4: Read 32-bit TTL (time to live)\n    // TODO 5: Read 16-bit data length\n    // TODO 6: Read data bytes (length specified in previous step)\n    // TODO 7: Return populated ResourceRecord struct with raw data\n    // Hint: Don't parse data contents here - leave as raw bytes for type-specific handling later\n}\n\n// ValidateMessage performs comprehensive validation of parsed message structure.\n// Checks for consistency between header counts and actual section contents.\nfunc ValidateMessage(msg *DNSMessage) error {\n    // TODO 1: Validate question count matches actual questions parsed\n    // TODO 2: Validate answer count matches actual answers parsed\n    // TODO 3: Validate authority count matches actual authority records parsed  \n    // TODO 4: Validate additional count matches actual additional records parsed\n    // TODO 5: Validate all domain names contain only valid characters\n    // TODO 6: Validate record types are known values\n    // TODO 7: Return error with specific details if any validation fails\n    // Hint: Create detailed error messages that specify which field failed validation\n}\n```\n\n#### Language-Specific Hints\n\n**Go-Specific Implementation Details:**\n\n- Use `binary.BigEndian.Uint16()` and `binary.BigEndian.Uint32()` for network byte order conversion\n- Implement bounds checking with slice length comparisons: `offset + size <= len(data)`\n- Use `strings.Join(labels, \".\")` to construct domain names from parsed labels\n- Handle UTF-8 properly in domain names, though DNS traditionally uses ASCII\n- Use `make([]byte, length)` followed by `copy()` for safe byte slice extraction\n- Implement error wrapping with `fmt.Errorf(\"context: %w\", err)` for better error context\n\n**Memory Management:**\n\n- Avoid excessive allocations during parsing by reusing slices where possible\n- Consider using `sync.Pool` for parser state objects if processing high message volumes\n- Be careful with slice sharing—use `copy()` when extracting data that outlives the original buffer\n\n**Concurrency Considerations:**\n\n- Make parsing functions stateless except for the `parseState` parameter\n- Don't share `parseState` objects between goroutines\n- Consider parsing messages in parallel if processing batch operations\n\n#### Milestone Checkpoints\n\nAfter implementing DNS message parsing, verify the implementation with these specific tests:\n\n**Basic Parsing Test:**\n```bash\ngo test ./internal/protocol -v -run TestParseBasicMessage\n```\n\nExpected behavior: Parse a simple A record query and response successfully, with correct header flags, question domain name, and answer data extraction.\n\n**Compression Handling Test:**\n```bash\ngo test ./internal/protocol -v -run TestParseCompressedNames  \n```\n\nExpected behavior: Correctly parse messages with name compression pointers, producing the same domain names as uncompressed equivalents.\n\n**Malformed Message Tests:**\n```bash\ngo test ./internal/protocol -v -run TestParseErrors\n```\n\nExpected behavior: Reject messages with invalid compression pointers, insufficient data, wrong counts, and other malformation with specific error messages.\n\n**Manual Verification:**\n\nCreate a test program that parses real DNS responses:\n1. Use `dig +noedns example.com A` to generate a simple query  \n2. Capture the response with a packet analyzer or programmatically\n3. Parse the captured bytes and verify the output matches expected values\n4. Test with multiple record types and compressed names\n\n**Signs of Problems:**\n\n| Symptom | Likely Cause | Check |\n|---------|--------------|--------|\n| Domain names contain garbage characters | Compression pointer following error | Verify pointer offset calculation |\n| Parse fails on valid messages | Byte order problems | Check endianness conversion |\n| Infinite loop during parsing | Compression pointer loop | Verify loop detection logic |\n| Wrong record counts | Header parsing errors | Verify flag bit extraction |\n\nThe parsing implementation forms the foundation for all subsequent DNS server functionality. Robust error handling and thorough validation at this stage prevent subtle bugs from propagating through the resolver and cache components.\n\n\n## Authoritative Server (Milestone 2)\n\n> **Milestone(s):** 2 (Authoritative Server)\n\nAn authoritative DNS server serves as the definitive source of truth for specific domains, responding to queries with records from its zone files rather than performing recursive resolution. This milestone transforms our DNS message parser into a functioning authoritative server that can load zone data, match queries against its configured domains, and construct proper DNS responses with populated answer, authority, and additional sections.\n\n### Mental Model: Zones as Local Phone Books\n\nThink of DNS zones as specialized phone books, where each phone book covers a specific geographic region or organization. Just as a local phone book contains authoritative listings for businesses and residents in a particular city, a DNS zone contains authoritative resource records for a specific domain and its subdomains.\n\nWhen someone calls directory assistance asking for \"John Smith's number in Springfield,\" the operator first determines which phone book to consult based on the location. Similarly, when a DNS query arrives asking for \"mail.example.com,\" an authoritative server first checks whether it has authoritative data for the \"example.com\" zone. If it does, it becomes the definitive source for that information—no need to call other directories or perform further lookups.\n\nThe phone book analogy extends to the structure of DNS responses. A complete directory assistance response might include the requested phone number (answer section), information about the phone company serving that area (authority section), and related numbers like the main switchboard (additional section). DNS responses follow the same pattern, providing not just the requested record but also supporting information that helps clients understand the authoritative structure and potentially avoid additional queries.\n\nUnlike a phone book that covers an entire city uniformly, DNS zones can have complex delegation patterns. A zone might contain complete information for some subdomains while delegating others to different nameservers, similar to how a regional phone directory might include full listings for some neighborhoods but refer to specialized business directories for commercial districts.\n\n### Zone File Parsing Algorithm\n\nZone files follow the BIND format established by RFC 1035, representing DNS resource records in a human-readable text format that must be parsed into queryable in-memory data structures. The parsing process handles multiple record types, origin directives, TTL inheritance, and domain name expansion to build a comprehensive zone database.\n\n**Zone File Structure and Components**\n\nZone files begin with administrative records that define the zone's properties and delegation information. The Start of Authority (SOA) record establishes the zone's primary nameserver, responsible party contact, and timing parameters for zone transfers and caching. Name Server (NS) records define which servers are authoritative for the zone, creating the delegation chain that recursive resolvers follow.\n\n| Zone Directive | Purpose | Example | Effect |\n|---------------|---------|---------|--------|\n| $ORIGIN | Set default domain suffix | `$ORIGIN example.com.` | All relative names append this suffix |\n| $TTL | Set default time-to-live | `$TTL 3600` | Records without TTL use this value |\n| @ symbol | Reference to origin domain | `@ IN SOA ...` | Expands to current $ORIGIN value |\n| Relative names | Names without trailing dot | `mail IN A 192.0.2.1` | Become `mail.example.com.` |\n| Absolute names | Names with trailing dot | `ns1.example.org.` | Used exactly as written |\n\n**Resource Record Parsing Process**\n\nThe zone file parser processes records line by line, handling continuation characters, comments, and various record formats. Each line potentially contains multiple pieces of information that must be extracted and validated according to DNS protocol specifications.\n\n1. **Tokenization and Line Processing**: The parser splits each line into tokens while respecting quoted strings that may contain spaces. Comments beginning with semicolons are stripped, and backslash continuation characters allow records to span multiple lines for readability.\n\n2. **Name Field Resolution**: Record names can be specified as relative (requiring origin expansion), absolute (ending with a dot), or omitted entirely (inheriting from the previous record). The parser maintains context about the current record name to handle implicit repetition.\n\n3. **Class and TTL Handling**: These optional fields can appear in either order and may be omitted if defaults are established. The parser must distinguish between numeric TTL values and symbolic class identifiers like \"IN\" for Internet.\n\n4. **Type-Specific Data Parsing**: Each record type has unique data format requirements. A records contain IPv4 addresses, AAAA records contain IPv6 addresses, CNAME records contain domain names, and MX records contain priority values followed by domain names.\n\n5. **Domain Name Canonicalization**: All domain names are converted to canonical lowercase form with trailing dots to ensure consistent matching during query processing. This normalization eliminates case sensitivity issues and ambiguity about absolute versus relative names.\n\n**Zone Data Storage Structure**\n\nThe parsed zone data requires efficient storage for query matching, supporting both exact name lookups and wildcard matching patterns. The data structure must accommodate multiple record types for each domain name while preserving TTL values and maintaining the hierarchical relationships between parent and child domains.\n\n| Storage Component | Data Type | Purpose | Key Features |\n|------------------|-----------|----------|--------------|\n| Zone name map | `map[string]*DomainNode` | Primary lookup structure | Keys are canonical domain names |\n| Domain nodes | `*DomainNode` | Per-domain record storage | Contains record sets by type |\n| Record sets | `map[uint16][]ResourceRecord` | Type-grouped records | Indexed by DNS type constants |\n| Wildcard patterns | `[]WildcardPattern` | Wildcard matching rules | Ordered by specificity |\n| Delegation points | `map[string]bool` | Subdomain delegations | Identifies zone cuts |\n\n> **Decision: Hierarchical Storage vs. Flat Map**\n> - **Context**: Zone data can be stored as a flat map of domain names or as a hierarchical tree reflecting DNS structure\n> - **Options Considered**: Flat hash map, Hierarchical tree with parent pointers, Hybrid approach with delegation awareness\n> - **Decision**: Flat map with explicit delegation tracking\n> - **Rationale**: Simpler implementation with O(1) exact lookups, while delegation map provides necessary hierarchy information for authority section population\n> - **Consequences**: Enables efficient exact matching but requires additional logic for wildcard resolution and closest enclosing authority determination\n\n### Query Matching and Response Construction\n\nQuery processing for authoritative servers involves determining whether the server has authoritative data for the requested domain, finding the most specific matching records, and constructing a complete DNS response with properly populated answer, authority, and additional sections.\n\n**Authoritative Determination Process**\n\nBefore processing any query, the server must determine its authority relationship to the requested domain. This involves checking whether the queried name falls within any configured zone and identifying the most specific zone that applies.\n\n1. **Zone Boundary Detection**: The server examines each configured zone to determine if the queried domain is within its authority. For a query about \"mail.sales.example.com\", zones for \"example.com\", \"sales.example.com\", and \"com\" would all claim authority, but \"sales.example.com\" provides the most specific match.\n\n2. **Delegation Checking**: Even within an authoritative zone, subdomains may be delegated to other nameservers. The server must check for NS records that delegate authority for the queried domain or any parent domain, as delegated zones fall outside the server's authority.\n\n3. **Authority Classification**: Based on this analysis, the server classifies each query as authoritative (server has definitive data), delegated (authority transferred to other nameservers), or non-authoritative (domain falls outside configured zones).\n\n**Record Matching Algorithm**\n\nFor queries within the server's authority, the matching algorithm finds the most appropriate records to include in the response, handling exact matches, wildcard patterns, and various DNS edge cases.\n\nThe matching process follows a specific precedence order designed to provide the most useful information while respecting DNS protocol semantics:\n\n1. **Exact Domain Match**: Check if the queried domain name exists exactly in the zone data. If found, examine the available record types to determine the appropriate response.\n\n2. **Type-Specific Matching**: If the domain exists, check for records matching the requested type. A successful match populates the answer section with all records of that type for the domain.\n\n3. **CNAME Resolution**: If no records match the requested type but a CNAME record exists for the domain, the CNAME provides an alias that should be followed. However, CNAME records cannot coexist with other types for the same domain name.\n\n4. **Wildcard Matching**: If no exact domain match exists, search for applicable wildcard patterns. Wildcards match any subdomain at the specified level but cannot match across delegation boundaries.\n\n5. **Negative Response Generation**: If no positive match is found, generate an appropriate negative response (NXDOMAIN for non-existent domains or NODATA for existing domains without requested record types).\n\n**Response Section Population**\n\nDNS responses contain four sections that serve different purposes in conveying information to clients. Proper population of each section follows specific rules that help clients understand the authoritative structure and optimize future queries.\n\n| Response Section | Content Rules | Population Logic | Purpose |\n|-----------------|---------------|------------------|---------|\n| Answer | Records matching query exactly | Direct matches for query name/type | Provides requested information |\n| Authority | SOA or NS records establishing authority | Current zone's NS records or SOA for negative responses | Proves authoritative source |\n| Additional | Supporting records for names in other sections | A/AAAA records for NS names, MX targets, etc. | Reduces follow-up queries |\n| Header flags | AA bit, RCODE values | Set AA=1 for authoritative responses | Indicates response authority level |\n\n**Answer Section Construction**: When records match the query exactly, all records of the requested type are included in the answer section. For CNAME records, both the CNAME and the records it points to may be included if the target is within the same zone.\n\n**Authority Section Logic**: For positive responses, the authority section contains NS records for the zone containing the answer, establishing which nameservers are authoritative for this data. For negative responses, the SOA record provides caching parameters and proves the server's authority to make negative assertions.\n\n**Additional Section Optimization**: The additional section includes records that clients are likely to need next, based on names appearing in other sections. For NS records in the authority section, corresponding A or AAAA records (glue records) help clients contact those nameservers without additional queries.\n\n**CNAME Handling Complexity**\n\nCNAME records introduce special processing requirements because they create aliases that must be resolved transparently to clients while respecting zone boundaries and avoiding infinite loops.\n\nWhen a query matches a CNAME record, the authoritative server has several response options depending on whether the CNAME target falls within its authority:\n\n- **In-zone targets**: If the CNAME points to another name within the same zone, the server can include both the CNAME and the target records in a single response, providing complete resolution.\n- **Out-of-zone targets**: If the CNAME points outside the server's authority, only the CNAME record is returned, leaving target resolution to the client or recursive resolver.\n- **CNAME chains**: Multiple CNAME records can form chains that require iterative following while detecting loops and respecting zone boundaries.\n\n> **Critical insight**: CNAME processing must balance completeness (providing as much information as possible) with authority boundaries (not making assertions about domains outside the server's control).\n\n### Architecture Decisions for Authority\n\nSeveral key architectural decisions shape how the authoritative server handles edge cases, ensures correctness, and optimizes performance. These decisions involve trade-offs between simplicity and functionality, affecting both implementation complexity and operational behavior.\n\n> **Decision: Case Sensitivity Handling**\n> - **Context**: DNS names are case-insensitive by protocol definition, but file systems and programming languages may be case-sensitive\n> - **Options Considered**: Store names in original case with case-insensitive matching, normalize all names to lowercase on input, mixed approach with case preservation for display\n> - **Decision**: Normalize all domain names to lowercase during parsing and storage\n> - **Rationale**: Eliminates case-related bugs in matching logic, simplifies string comparisons, and ensures consistent behavior across different platforms\n> - **Consequences**: Faster query matching with simple string equality, but loses original case information for response formatting (acceptable trade-off for correctness)\n\n| Case Handling Option | Pros | Cons | Implementation Complexity |\n|---------------------|------|------|---------------------------|\n| Preserve original case | Maintains zone file formatting | Requires case-insensitive matching logic | High - custom comparison functions |\n| Normalize to lowercase | Simple string equality matching | Loses cosmetic case information | Low - standard string operations |\n| Case-insensitive map keys | Balanced approach | Complex key hashing requirements | Medium - custom map implementation |\n\n**Wildcard Matching Strategy**\n\nWildcard records in DNS zones use asterisk labels to match arbitrary subdomains, but the matching rules have subtle complexities that affect both correctness and performance.\n\n> **Decision: Wildcard Matching Implementation**\n> - **Context**: DNS wildcards match subdomains but have specific precedence rules and delegation boundaries that must be respected\n> - **Options Considered**: Pre-compile wildcard patterns into regular expressions, implement custom matching logic with explicit rules, use suffix-based matching with validation\n> - **Decision**: Custom matching logic following RFC 1034 rules exactly\n> - **Rationale**: DNS wildcard semantics don't map cleanly to regular expressions, and custom logic provides better control over edge cases and performance\n> - **Consequences**: More implementation effort but guaranteed correctness and predictable performance characteristics\n\nThe wildcard matching algorithm must handle several edge cases that distinguish DNS wildcards from general pattern matching:\n\n1. **Delegation Boundaries**: Wildcards cannot match across zone delegation points, even if the parent zone contains the wildcard pattern. This prevents wildcard records from inadvertently claiming authority over delegated subdomains.\n\n2. **Exact Match Precedence**: Explicit records always take precedence over wildcard matches. If both \"host.example.com\" and \"*.example.com\" exist in a zone, queries for \"host.example.com\" must return the explicit record.\n\n3. **Single-Label Matching**: The asterisk label matches exactly one label in the domain name hierarchy. \"*.example.com\" matches \"host.example.com\" but not \"web.host.example.com\".\n\n4. **Empty Non-Terminal Handling**: Wildcard matches must respect the DNS tree structure, avoiding matches that would create inconsistencies with the hierarchical naming system.\n\n**Resource Record TTL Management**\n\nTime-to-live values control how long clients and resolvers may cache DNS records, affecting both performance and the speed of DNS changes propagation. The authoritative server must handle TTL inheritance, minimum values, and response consistency.\n\n> **Decision: TTL Inheritance and Override Rules**\n> - **Context**: Zone files can specify TTLs at multiple levels (zone default, record-specific, type-specific), requiring a clear precedence hierarchy\n> - **Options Considered**: Record-level TTL only with required specification, hierarchical inheritance with zone/record defaults, dynamic TTL calculation based on record type\n> - **Decision**: Hierarchical inheritance: record-specific TTL > zone $TTL directive > server default TTL\n> - **Rationale**: Provides flexibility for zone administrators while ensuring all records have valid TTL values without requiring explicit specification\n> - **Consequences**: Simplifies zone file management but requires careful TTL inheritance tracking during parsing\n\n| TTL Source | Precedence Level | Scope | Override Capability |\n|------------|------------------|-------|---------------------|\n| Record-specific TTL | 1 (highest) | Individual record | Overrides all defaults |\n| Zone $TTL directive | 2 | Entire zone file | Overrides server defaults |\n| Server default TTL | 3 (lowest) | Global fallback | Used when no other TTL specified |\n| SOA minimum TTL | Special | Negative caching | Controls NXDOMAIN cache time |\n\n**Error Response Generation**\n\nAuthoritative servers must generate appropriate error responses for various failure conditions, ensuring clients receive useful information about why queries cannot be satisfied.\n\nThe server distinguishes between several categories of query failures, each requiring different response codes and additional information:\n\n- **NXDOMAIN (Name Error)**: The queried domain name does not exist within the zone. The response includes the zone's SOA record in the authority section to provide negative caching parameters and prove the server's authority to make this assertion.\n\n- **NODATA (No Error, No Data)**: The queried domain name exists but has no records of the requested type. The response has an empty answer section but includes NS records in the authority section to confirm the server's authoritative status.\n\n- **Delegation (Referral)**: The queried domain falls within a subdomain that has been delegated to other nameservers. The response includes NS records for the delegation in the authority section and any available glue records in the additional section.\n\n- **Format Error**: The query message is malformed or contains unsupported options. The response uses the FORMERR response code and typically includes minimal additional information.\n\n⚠️ **Pitfall: Incomplete Authority Section Population**\nMany implementations forget to populate the authority section for negative responses, making it difficult for clients to cache negative results effectively. The SOA record in the authority section provides the minimum TTL value that determines how long the negative result should be cached, and its absence can cause inefficient repeated queries for non-existent domains.\n\n**Glue Record Handling**\n\nGlue records solve circular dependency problems that arise when nameserver names fall within the domains they serve. Without glue records, resolvers would need the very nameservers they're trying to find in order to resolve those nameservers' addresses.\n\nThe authoritative server must identify when glue records are necessary and include appropriate A or AAAA records in the additional section of responses containing NS records:\n\n1. **In-Bailiwick Detection**: Determine when NS record targets fall within the zone being served, creating potential circular dependencies for resolvers.\n\n2. **Glue Record Lookup**: Find corresponding A or AAAA records for nameserver names that require glue, ensuring resolvers can contact those nameservers without additional queries.\n\n3. **Additional Section Population**: Include glue records in the additional section of responses, but only when they're necessary to avoid circular dependencies.\n\n4. **Glue Validation**: Ensure glue records are consistent with authoritative data and don't introduce security vulnerabilities through inappropriate out-of-zone data.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Case-Sensitive Domain Name Matching**\nImplementing domain name comparisons using standard string equality without case normalization leads to failed matches when clients send queries with different capitalization than the zone file. DNS names are explicitly case-insensitive, so \"Example.com\", \"EXAMPLE.COM\", and \"example.com\" must all match the same zone data. The fix involves normalizing all domain names to lowercase during both parsing and query processing.\n\n⚠️ **Pitfall: Incorrect Wildcard Precedence**\nReturning wildcard matches when explicit records exist violates DNS semantics and can cause unexpected behavior for clients. For example, if a zone contains both \"host.example.com A 192.0.2.1\" and \"*.example.com A 192.0.2.100\", queries for \"host.example.com\" must return the explicit record, not the wildcard. Implement wildcard matching only after confirming no exact match exists.\n\n⚠️ **Pitfall: Missing SOA in Negative Responses**\nOmitting the SOA record from NXDOMAIN responses prevents proper negative caching and makes it impossible for clients to determine appropriate cache timeouts. The SOA record's minimum TTL field specifically controls negative caching duration, and its absence in the authority section violates RFC requirements. Always include the zone's SOA record in the authority section for negative responses.\n\n⚠️ **Pitfall: Incomplete CNAME Chain Resolution**\nStopping CNAME resolution at the first alias instead of following chains to their final targets can leave clients with incomplete answers. However, CNAME following must respect zone boundaries—don't attempt to resolve targets outside your authoritative zones. Include CNAME records in the answer section and add target records only if they fall within your authority.\n\n⚠️ **Pitfall: Improper TTL Inheritance**\nUsing inconsistent or missing TTL values causes unpredictable caching behavior and potential performance problems. Establish clear TTL inheritance rules (record-level TTL overrides zone default, which overrides server default) and ensure every response includes valid TTL values. Never send records with zero TTL unless specifically intended for no-cache behavior.\n\n⚠️ **Pitfall: Authority Section Confusion**\nIncorrectly populating the authority section with the wrong NS records or omitting it entirely makes it difficult for clients to understand the authoritative structure. For positive responses within your zones, include your zone's NS records in the authority section. For delegations, include the delegation's NS records. For negative responses, include the SOA record to prove your authority to make negative assertions.\n\n![Zone Data and Resource Record Model](./diagrams/zone-data-model.svg)\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing an authoritative DNS server in Go, including complete zone file parsing infrastructure and skeletal code for the core query processing logic.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Zone File Parsing | Text scanner with line-by-line processing | Full RFC-compliant parser with error recovery |\n| Data Storage | In-memory maps with periodic reload | Database backend with change notifications |\n| Record Matching | Linear search with case normalization | Trie-based matching with compression |\n| Configuration | YAML files with manual reload | Dynamic configuration with validation |\n| Logging | Standard library log package | Structured logging with log levels |\n\n#### Recommended File Structure\n\n```\ndns-server/\n  cmd/authserver/\n    main.go                    ← Authoritative server entry point\n  internal/auth/\n    server.go                  ← Authoritative server implementation\n    server_test.go            ← Server tests\n    query.go                  ← Query processing logic\n    zone.go                   ← Zone data management\n    zone_parser.go            ← BIND format zone file parser\n    zone_parser_test.go       ← Parser tests with sample zone files\n  internal/dns/\n    message.go                ← DNS message structures (from Milestone 1)\n    parser.go                 ← Wire format parsing (from Milestone 1)\n  configs/\n    zones/\n      example.com.zone        ← Sample zone files for testing\n      test.zone              ← Test zone data\n    server.yaml              ← Server configuration\n  testdata/\n    zone-files/              ← Test zone files for unit tests\n    queries/                 ← Sample query files for integration tests\n```\n\n#### Infrastructure Starter Code: Zone File Parser\n\nComplete zone file parsing implementation that handles BIND format files with proper error handling and validation:\n\n```go\n// internal/auth/zone_parser.go\npackage auth\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"io\"\n    \"net\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\n// ZoneData represents parsed zone file contents\ntype ZoneData struct {\n    Origin      string                           // Zone origin domain\n    DefaultTTL  uint32                          // Default TTL from $TTL directive\n    SOA         *ResourceRecord                  // Start of Authority record\n    Records     map[string]map[uint16][]ResourceRecord // Domain -> Type -> Records\n    NSRecords   map[string][]ResourceRecord      // NS records for delegation detection\n}\n\n// ZoneParser handles BIND-format zone file parsing\ntype ZoneParser struct {\n    origin     string\n    defaultTTL uint32\n    lastDomain string\n    lineNum    int\n}\n\n// ParseZoneFile reads and parses a complete zone file\nfunc ParseZoneFile(reader io.Reader, origin string) (*ZoneData, error) {\n    parser := &ZoneParser{\n        origin:     canonicalizeName(origin),\n        defaultTTL: 3600, // Default 1 hour TTL\n    }\n    \n    zone := &ZoneData{\n        Origin:    parser.origin,\n        Records:   make(map[string]map[uint16][]ResourceRecord),\n        NSRecords: make(map[string][]ResourceRecord),\n    }\n    \n    scanner := bufio.NewScanner(reader)\n    var currentRecord strings.Builder\n    \n    for scanner.Scan() {\n        parser.lineNum++\n        line := strings.TrimSpace(scanner.Text())\n        \n        // Handle line continuation with backslash\n        if strings.HasSuffix(line, \"\\\\\") {\n            currentRecord.WriteString(strings.TrimSuffix(line, \"\\\\\"))\n            continue\n        }\n        \n        currentRecord.WriteString(line)\n        fullLine := currentRecord.String()\n        currentRecord.Reset()\n        \n        if err := parser.parseLine(zone, fullLine); err != nil {\n            return nil, fmt.Errorf(\"line %d: %w\", parser.lineNum, err)\n        }\n    }\n    \n    if err := scanner.Err(); err != nil {\n        return nil, fmt.Errorf(\"reading zone file: %w\", err)\n    }\n    \n    zone.DefaultTTL = parser.defaultTTL\n    return zone, parser.validateZone(zone)\n}\n\n// parseLine processes a single logical line from the zone file\nfunc (p *ZoneParser) parseLine(zone *ZoneData, line string) error {\n    // Remove comments\n    if idx := strings.Index(line, \";\"); idx >= 0 {\n        line = line[:idx]\n    }\n    \n    line = strings.TrimSpace(line)\n    if line == \"\" {\n        return nil\n    }\n    \n    // Handle directives\n    if strings.HasPrefix(line, \"$\") {\n        return p.parseDirective(line)\n    }\n    \n    // Parse resource record\n    return p.parseResourceRecord(zone, line)\n}\n\n// parseDirective handles $ORIGIN and $TTL directives\nfunc (p *ZoneParser) parseDirective(line string) error {\n    fields := strings.Fields(line)\n    if len(fields) < 2 {\n        return fmt.Errorf(\"invalid directive: %s\", line)\n    }\n    \n    switch strings.ToUpper(fields[0]) {\n    case \"$ORIGIN\":\n        p.origin = canonicalizeName(fields[1])\n        return nil\n    case \"$TTL\":\n        ttl, err := parseTTL(fields[1])\n        if err != nil {\n            return fmt.Errorf(\"invalid TTL in $TTL directive: %w\", err)\n        }\n        p.defaultTTL = ttl\n        return nil\n    default:\n        return fmt.Errorf(\"unknown directive: %s\", fields[0])\n    }\n}\n\n// canonicalizeName converts domain names to canonical lowercase form with trailing dot\nfunc canonicalizeName(name string) string {\n    name = strings.ToLower(strings.TrimSpace(name))\n    if name == \"@\" {\n        return \"\"  // Will be replaced with origin\n    }\n    if name != \"\" && !strings.HasSuffix(name, \".\") {\n        name += \".\"\n    }\n    return name\n}\n\n// parseTTL converts TTL strings to seconds, supporting time unit suffixes\nfunc parseTTL(ttlStr string) (uint32, error) {\n    ttlStr = strings.ToLower(strings.TrimSpace(ttlStr))\n    \n    // Handle unit suffixes\n    multiplier := uint32(1)\n    if len(ttlStr) > 0 {\n        switch ttlStr[len(ttlStr)-1] {\n        case 's': // seconds\n            ttlStr = ttlStr[:len(ttlStr)-1]\n            multiplier = 1\n        case 'm': // minutes\n            ttlStr = ttlStr[:len(ttlStr)-1]\n            multiplier = 60\n        case 'h': // hours\n            ttlStr = ttlStr[:len(ttlStr)-1]\n            multiplier = 3600\n        case 'd': // days\n            ttlStr = ttlStr[:len(ttlStr)-1]\n            multiplier = 86400\n        case 'w': // weeks\n            ttlStr = ttlStr[:len(ttlStr)-1]\n            multiplier = 604800\n        }\n    }\n    \n    value, err := strconv.ParseUint(ttlStr, 10, 32)\n    if err != nil {\n        return 0, fmt.Errorf(\"invalid TTL value: %s\", ttlStr)\n    }\n    \n    return uint32(value) * multiplier, nil\n}\n```\n\n#### Core Logic Skeleton: Query Processing\n\nSkeletal implementation for authoritative query processing with detailed TODOs mapping to the algorithms described in the design section:\n\n```go\n// internal/auth/query.go\npackage auth\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"strings\"\n    \n    \"dns-server/internal/dns\"\n)\n\n// AuthoritativeServer handles queries for configured zones\ntype AuthoritativeServer struct {\n    zones map[string]*ZoneData  // Domain -> Zone data\n    config *AuthConfig\n}\n\n// AuthConfig holds authoritative server configuration\ntype AuthConfig struct {\n    ZoneFiles    map[string]string  // Domain -> file path\n    DefaultTTL   uint32\n    SOARefresh   uint32\n    SOARetry     uint32\n    SOAExpire    uint32\n    SOAMinimum   uint32\n}\n\n// ProcessQuery handles an incoming DNS query for authoritative data\nfunc (s *AuthoritativeServer) ProcessQuery(ctx context.Context, query *dns.DNSMessage) (*dns.DNSMessage, error) {\n    if len(query.Questions) != 1 {\n        // TODO 1: Return FORMERR for queries with != 1 question\n        // Hint: Use dns.ResponseCode = 1 for format error\n    }\n    \n    question := query.Questions[0]\n    canonicalName := canonicalizeName(question.Name)\n    \n    // TODO 2: Determine if this server is authoritative for the queried domain\n    // Check s.zones map for the most specific zone that contains canonicalName\n    // Example: for \"mail.sales.example.com\", prefer \"sales.example.com\" over \"example.com\"\n    zone, authoritative := s.findAuthoritativeZone(canonicalName)\n    \n    if !authoritative {\n        // TODO 3: Return REFUSED for non-authoritative queries\n        // Set response code to dns.RCODE_REFUSED (5) and empty sections\n        return s.buildRefusedResponse(query), nil\n    }\n    \n    // TODO 4: Check for delegation within the authoritative zone\n    // Look for NS records that delegate this specific domain to other nameservers\n    // If delegation exists, return referral response with NS records in authority section\n    \n    // TODO 5: Perform record matching within the zone\n    // Call s.matchRecords(zone, canonicalName, question.Type) to find answers\n    records, matchType := s.matchRecords(zone, canonicalName, question.Type)\n    \n    // TODO 6: Construct response based on match results\n    // matchType can be: \"exact\", \"cname\", \"wildcard\", \"nxdomain\", \"nodata\"\n    response := s.buildResponse(query, zone, records, matchType)\n    \n    // TODO 7: Populate authority and additional sections\n    // Add NS records for positive responses, SOA for negative responses\n    // Include glue records in additional section for any NS records\n    s.populateAuthoritySections(response, zone, matchType, question.Name)\n    \n    return response, nil\n}\n\n// findAuthoritativeZone determines which zone (if any) is authoritative for a domain\nfunc (s *AuthoritativeServer) findAuthoritativeZone(domain string) (*ZoneData, bool) {\n    // TODO 1: Iterate through s.zones to find the most specific match\n    // Example: for \"mail.example.com\", check \"mail.example.com\", \"example.com\", \"com\"\n    // Return the zone with the longest matching suffix and true\n    // If no zone matches, return nil and false\n    // Hint: Use strings.HasSuffix() for suffix matching\n}\n\n// matchRecords finds the best matching records for a query within a zone\nfunc (s *AuthoritativeServer) matchRecords(zone *ZoneData, domain string, qtype uint16) ([]dns.ResourceRecord, string) {\n    // TODO 1: Check for exact domain match in zone.Records[domain]\n    // If domain exists, proceed to type matching\n    \n    // TODO 2: Check for exact type match\n    // If zone.Records[domain][qtype] exists, return those records with \"exact\"\n    \n    // TODO 3: Check for CNAME record\n    // If zone.Records[domain][dns.TYPE_CNAME] exists, return CNAME with \"cname\"\n    // Note: CNAME cannot coexist with other record types for the same name\n    \n    // TODO 4: If domain doesn't exist, check for wildcard matches\n    // Look for \"*.parent-domain\" patterns that could match this domain\n    // Wildcard matching rules: single label replacement, no delegation crossing\n    \n    // TODO 5: Determine negative response type\n    // If domain exists but no matching type: return empty slice with \"nodata\"\n    // If domain doesn't exist and no wildcard: return empty slice with \"nxdomain\"\n    \n    return nil, \"nxdomain\"  // Placeholder\n}\n\n// buildResponse constructs the basic DNS response message\nfunc (s *AuthoritativeServer) buildResponse(query *dns.DNSMessage, zone *ZoneData, records []dns.ResourceRecord, matchType string) *dns.DNSMessage {\n    response := &dns.DNSMessage{\n        Header: dns.Header{\n            ID: query.Header.ID,\n            QueryResponse: true,\n            Opcode: query.Header.Opcode,\n            Authoritative: true,  // We are authoritative for this zone\n            RecursionDesired: query.Header.RecursionDesired,\n            RecursionAvail: false,  // Authoritative servers don't do recursion\n        },\n        Questions: query.Questions,  // Echo the question\n    }\n    \n    // TODO 1: Set appropriate response code based on matchType\n    // \"exact\", \"cname\", \"wildcard\" -> RCODE 0 (NOERROR)\n    // \"nxdomain\" -> RCODE 3 (NXDOMAIN) \n    // \"nodata\" -> RCODE 0 (NOERROR) with empty answer section\n    \n    // TODO 2: Populate answer section for positive responses\n    // Add records to response.Answers for exact, cname, and wildcard matches\n    // Leave answer section empty for negative responses\n    \n    // TODO 3: Handle CNAME chain resolution\n    // If matchType is \"cname\", check if CNAME target is also in this zone\n    // If so, add target records to answer section as well\n    \n    return response\n}\n\n// populateAuthoritySections adds authority and additional section records\nfunc (s *AuthoritativeServer) populateAuthoritySections(response *dns.DNSMessage, zone *ZoneData, matchType string, queryName string) {\n    // TODO 1: Add authority section for positive responses\n    // Include NS records for the zone in response.Authority\n    // Use zone.NSRecords to find NS records for the zone origin\n    \n    // TODO 2: Add SOA record for negative responses  \n    // For \"nxdomain\" and \"nodata\" responses, add zone.SOA to response.Authority\n    // SOA record proves authority to make negative assertions\n    \n    // TODO 3: Add glue records to additional section\n    // For each NS record in authority section, check if NS hostname is in-zone\n    // If so, add corresponding A/AAAA records to response.Additional\n    // This prevents circular dependencies in resolution\n    \n    // TODO 4: Update header counts\n    // Set response.Header.AnswerCount = len(response.Answers)\n    // Set response.Header.AuthorityCount = len(response.Authority)  \n    // Set response.Header.AdditionalCount = len(response.Additional)\n}\n```\n\n#### Language-Specific Hints for Go\n\n- **Zone File Reading**: Use `os.Open()` with `bufio.Scanner` for efficient line-by-line processing of large zone files\n- **String Comparison**: Use `strings.EqualFold()` for case-insensitive comparison, or `strings.ToLower()` for normalization\n- **Map Initialization**: Initialize nested maps with `make()` before assignment: `zone.Records[domain] = make(map[uint16][]ResourceRecord)`\n- **IP Address Parsing**: Use `net.ParseIP()` to validate IPv4/IPv6 addresses in A and AAAA record data\n- **TTL Parsing**: Handle time unit suffixes (s, m, h, d, w) with `strings.HasSuffix()` and conversion multipliers\n- **Error Wrapping**: Use `fmt.Errorf(\"context: %w\", err)` to maintain error chains for debugging zone file parse errors\n\n#### Milestone Checkpoint\n\nAfter implementing this milestone, verify authoritative server functionality with these steps:\n\n**Test Commands:**\n```bash\n# Run unit tests for zone parsing\ngo test ./internal/auth/... -v\n\n# Start authoritative server on localhost:5353  \ngo run cmd/authserver/main.go -port 5353 -config configs/server.yaml\n\n# Query for A record (should return authoritative answer)\ndig @127.0.0.1 -p 5353 example.com A\n\n# Query for non-existent domain (should return NXDOMAIN with SOA in authority)\ndig @127.0.0.1 -p 5353 nonexistent.example.com A\n\n# Query for existing domain with non-existent type (should return NODATA)\ndig @127.0.0.1 -p 5353 example.com AAAA\n```\n\n**Expected Behavior:**\n- Zone file parser successfully loads BIND-format files with SOA, NS, A, AAAA, CNAME, and MX records\n- Queries for existing records return authoritative responses (AA bit set) with populated answer section\n- NXDOMAIN responses include SOA record in authority section with appropriate TTL values\n- NODATA responses have empty answer section but NS records in authority section  \n- Response header counts match the actual number of records in each section\n\n**Troubleshooting Signs:**\n- Parse errors usually indicate malformed zone file syntax or unsupported record types\n- Missing AA (Authoritative Answer) flag means the server doesn't recognize its authority for the queried domain\n- Empty authority sections in negative responses prevent proper client-side negative caching\n- Incorrect response codes (REFUSED vs NXDOMAIN vs NOERROR) indicate query classification bugs\n\n\n## Recursive Resolver (Milestone 3)\n\n> **Milestone(s):** 3 (Recursive Resolver)\n\nThe recursive resolver represents the heart of a full-featured DNS server, implementing the complex dance of iterative resolution that follows the DNS hierarchy from root servers down to authoritative nameservers. Unlike authoritative servers that simply answer from local zone data, or forwarding servers that delegate all work to upstream resolvers, a recursive resolver takes complete responsibility for finding answers by systematically querying the distributed DNS infrastructure.\n\nThis milestone transforms your DNS server from a simple authoritative responder into a sophisticated resolver capable of answering queries for any domain on the internet. The implementation challenges center around managing the stateful resolution process, handling referrals correctly, avoiding circular dependencies through glue records, and maintaining robustness in the face of network failures and malformed responses.\n\n### Mental Model: Recursive Resolution as Detective Work\n\nThink of recursive DNS resolution as detective work investigating a missing person case across multiple jurisdictions. When someone asks \"Where is John Smith?\", you don't immediately know the answer, but you know the systematic process to find out.\n\nYou start at the highest authority - like contacting the federal government, which might say \"John Smith? That name suggests he's probably in the United States. Try asking the state of California - here's their contact information.\" The federal authority doesn't know John Smith personally, but they know who has jurisdiction over California addresses.\n\nSo you contact California, who says \"John Smith in California? That's a common name, but based on the specific details you're looking for, try the city of San Francisco - here's how to reach them.\" Again, California doesn't know John Smith directly, but they know which local authority would have that information.\n\nFinally, you contact San Francisco's city hall, who says \"Yes! John Smith lives at 123 Main Street. Here's his current address and phone number.\" San Francisco is the **authoritative source** for information about San Francisco residents - they maintain the definitive records.\n\nIn DNS terms, your recursive resolver plays the detective role. When a client asks for `www.example.com`, you start by asking the **root servers** (the federal government equivalent), who refer you to the `.com` **Top-Level Domain (TLD) servers** (state level). The `.com` servers then refer you to the **authoritative nameservers** for `example.com` (city level), who finally provide the definitive answer.\n\nThe key insight is that each level of authority knows about the level below it, but not the specific details two levels down. Root servers know about TLD servers, TLD servers know about authoritative nameservers for domains, but root servers don't directly know about specific hostnames within domains. This hierarchical referral system distributes the massive namespace across thousands of servers while ensuring every query can eventually reach the authoritative source.\n\nJust like a detective must follow leads methodically and avoid being sent in circles by false information, your recursive resolver must follow referrals carefully, validate responses, and guard against malicious servers trying to redirect queries inappropriately.\n\n### Iterative Resolution Algorithm\n\nThe iterative resolution process follows a systematic sequence that mirrors the hierarchical structure of the DNS namespace. Understanding this algorithm is crucial because it represents the core logic that transforms your server from a simple message parser into a full-featured resolver.\n\nThe resolution process begins when your server receives a query from a client. Unlike a forwarding resolver that would immediately pass this query to an upstream server, your recursive resolver takes personal responsibility for finding the answer through the following systematic approach:\n\n**Phase 1: Query Preparation and Cache Check**\n\nThe resolver first examines the incoming question to understand what information is being requested. It extracts the domain name, record type (A, AAAA, CNAME, etc.), and class (almost always IN for internet) from the question section. Before initiating any network queries, the resolver checks its local cache to see if it already knows the answer. This cache lookup uses the combination of domain name, record type, and class as the cache key, following the same `CacheKey` structure established in previous milestones.\n\nIf a valid, non-expired cache entry exists, the resolver constructs a response immediately and returns it to the client. This represents the fastest possible resolution path and dramatically reduces load on upstream servers. However, if the cache misses or contains only expired entries, the resolver proceeds to active resolution.\n\n**Phase 2: Root Server Bootstrap**\n\nThe resolver initializes its search at the top of the DNS hierarchy by selecting a root server from its configured root hints. The **root hints** are a predefined list of IP addresses for the 13 logical root servers (a.root-servers.net through m.root-servers.net) that form the foundation of the global DNS system. These addresses are typically hardcoded in the resolver configuration or loaded from a root hints file.\n\nThe resolver constructs a DNS query message identical to the original client query and sends it via UDP to the selected root server. The query asks for the same domain name and record type that the client requested. For example, if the client asked for the A record of `www.example.com`, the resolver asks the root server for the A record of `www.example.com`.\n\n**Phase 3: Root Server Response Processing**\n\nThe root server typically responds with a referral rather than a direct answer. The response contains no answer records but includes NS records in the authority section pointing to the TLD servers responsible for the domain's top-level domain. For a query about `www.example.com`, the root server returns NS records pointing to the `.com` TLD servers.\n\nCritically, the root server also includes **glue records** in the additional section. These are A and AAAA records providing the IP addresses of the TLD nameservers mentioned in the NS records. Without these glue records, the resolver would face a circular dependency: to resolve `www.example.com`, it needs to contact the `.com` TLD servers, but to find the `.com` TLD servers, it would need to resolve their domain names, which would require contacting the `.com` TLD servers.\n\nThe resolver extracts both the NS records (indicating where to go next) and the glue records (providing the IP addresses needed to get there) from the response. It validates that these records are within the proper **bailiwick** - meaning the root server only provides information it's authoritative for and doesn't inject unrelated records that could be used for cache poisoning attacks.\n\n**Phase 4: TLD Server Query**\n\nUsing the IP addresses from the glue records, the resolver selects one of the TLD servers and sends the same query. The TLD server for `.com` knows about all the authoritative nameservers for domains within the `.com` zone but doesn't know about specific hostnames within those domains.\n\nThe TLD server responds with another referral, this time providing NS records pointing to the authoritative nameservers for `example.com`. Again, it includes glue records in the additional section with the IP addresses of these authoritative nameservers. The resolver processes this response identically to the root server response, extracting NS records and glue records while validating bailiwick.\n\n**Phase 5: Authoritative Server Query**\n\nFinally, the resolver queries one of the authoritative nameservers for `example.com`. This server is responsible for maintaining the definitive records for the `example.com` zone and can provide a final answer rather than another referral.\n\nThe authoritative server responds with the requested records in the answer section. For an A record query, this would be one or more A records containing IPv4 addresses. The resolver validates that these answer records match the original question (same domain name and record type) and that they come from an authoritative source.\n\n**Phase 6: Response Construction and Caching**\n\nThe resolver constructs a response message for the original client, copying the answer records from the authoritative server's response. Before sending this response, it stores all received records in its cache with their respective TTL values. This includes not just the final answer records but also the NS and glue records received during the referral process, as these may be useful for future queries.\n\nThe resolver sends the completed response back to the original client, fulfilling the recursive query. From the client's perspective, the resolver provided a direct answer, hiding the complexity of the multi-step resolution process.\n\nHere's the detailed algorithmic breakdown:\n\n| Step | Action | Input | Output | Error Handling |\n|------|--------|-------|--------|----------------|\n| 1 | Parse client query | UDP packet | `Question` struct | Return FORMERR for malformed messages |\n| 2 | Check cache lookup | `CacheKey{Name, Type, Class}` | `CacheEntry` or miss | Continue on cache miss |\n| 3 | Select root server | Root hints list | Root server IP | Try next server on timeout |\n| 4 | Send query to root | `DNSMessage` + root IP | Root response | Retry with different root on failure |\n| 5 | Process root referral | Root response | TLD NS records + glue | Return SERVFAIL on invalid response |\n| 6 | Select TLD server | Glue records | TLD server IP | Try next TLD server on failure |\n| 7 | Send query to TLD | Same query + TLD IP | TLD response | Retry with different TLD server |\n| 8 | Process TLD referral | TLD response | Auth NS records + glue | Return SERVFAIL on invalid response |\n| 9 | Select auth server | Auth glue records | Auth server IP | Try next auth server on failure |\n| 10 | Send query to auth | Same query + auth IP | Final answer | Return SERVFAIL on all failures |\n| 11 | Validate answer | Auth response | Validated records | Return SERVFAIL on validation failure |\n| 12 | Cache all records | All RRs from resolution | Updated cache | Log cache errors but continue |\n| 13 | Construct response | Answer records | Client response | Return SERVFAIL on construction failure |\n| 14 | Send to client | Response + client addr | UDP transmission | Log transmission errors |\n\n> **Key Design Insight**: The iterative resolution algorithm is stateless from the perspective of the servers being queried. Each server (root, TLD, authoritative) receives a complete question and provides a complete response. The resolver maintains all the state needed to follow the referral chain and construct the final answer.\n\n![Recursive Resolution Sequence](./diagrams/recursive-resolution-flow.svg)\n\n### Glue Records and Circular Dependencies\n\nOne of the most critical aspects of DNS resolution involves understanding and properly handling glue records. These records solve a fundamental bootstrapping problem that would otherwise create unsolvable circular dependencies in the DNS system.\n\n**The Circular Dependency Problem**\n\nConsider the domain `example.com` whose authoritative nameservers are `ns1.example.com` and `ns2.example.com`. When a resolver queries the `.com` TLD servers asking \"What are the nameservers for example.com?\", it receives NS records pointing to `ns1.example.com` and `ns2.example.com`. However, to contact these nameservers, the resolver needs their IP addresses, which requires resolving `ns1.example.com` and `ns2.example.com`. But to resolve those names, the resolver needs to ask... the authoritative nameservers for `example.com`, which are `ns1.example.com` and `ns2.example.com`.\n\nThis creates an infinite loop: to resolve `example.com`, you need to contact its nameservers, but to contact its nameservers, you need to resolve `example.com`. Without a mechanism to break this cycle, resolution would be impossible for any domain whose nameservers are within the same domain.\n\n**Glue Records as the Solution**\n\nGlue records solve this problem by providing the IP addresses of nameservers when the nameserver names fall within the same domain they're authoritative for. When the `.com` TLD servers respond with NS records pointing to `ns1.example.com` and `ns2.example.com`, they also include A records in the additional section providing the IP addresses of these nameservers:\n\n```\n;; AUTHORITY SECTION:\nexample.com.    172800  IN  NS  ns1.example.com.\nexample.com.    172800  IN  NS  ns2.example.com.\n\n;; ADDITIONAL SECTION:\nns1.example.com.    172800  IN  A   192.0.2.1\nns2.example.com.    172800  IN  A   192.0.2.2\n```\n\nThese A records in the additional section are the glue records. They're called \"glue\" because they glue together the referral chain, providing the essential information needed to continue resolution.\n\n**Bailiwick Validation for Glue Records**\n\nYour resolver must carefully validate glue records to prevent cache poisoning attacks. The concept of **bailiwick** determines which glue records a server is allowed to provide. A server can only provide glue records for nameserver names that fall within the domain it's authoritative for.\n\nFor example, the `.com` TLD servers can provide glue records for `ns1.example.com` because `ns1.example.com` is within the `.com` domain that the TLD servers are authoritative for. However, if the NS records pointed to `ns1.otherdomain.net`, the `.com` TLD servers should NOT provide glue records for that name, because `.net` names are outside their bailiwick.\n\nThe bailiwick validation algorithm works as follows:\n\n| Nameserver Name | Authoritative Zone | Glue Allowed? | Reason |\n|-----------------|-------------------|---------------|---------|\n| `ns1.example.com` | `.com` TLD | Yes | Nameserver is within .com domain |\n| `ns2.example.com` | `.com` TLD | Yes | Nameserver is within .com domain |\n| `ns1.otherdomain.net` | `.com` TLD | No | Nameserver is in .net, outside bailiwick |\n| `external.nameserver.org` | `example.com` zone | No | Nameserver is outside example.com domain |\n| `internal.example.com` | `example.com` zone | Yes | Nameserver is within example.com domain |\n\n**Processing Glue Records in Resolution**\n\nWhen your resolver receives a referral response, it must extract and process glue records correctly. The algorithm follows these steps:\n\n1. **Extract NS Records**: Parse the authority section to identify the nameservers for the next level of resolution.\n\n2. **Extract Glue Records**: Parse the additional section to find A and AAAA records that correspond to the nameserver names from step 1.\n\n3. **Validate Bailiwick**: Verify that each glue record is within the authoritative scope of the server that provided it.\n\n4. **Build Nameserver List**: Create a list of nameservers with their associated IP addresses, using glue records where available.\n\n5. **Handle Missing Glue**: For nameservers that don't have glue records, note that their IP addresses must be resolved separately before they can be contacted.\n\n**Cache Management for Glue Records**\n\nGlue records present interesting cache management challenges because they serve dual purposes. A glue record for `ns1.example.com` functions both as a nameserver address for resolving `example.com` queries and as a regular A record that could answer direct queries for `ns1.example.com`.\n\nYour cache should store glue records with their full TTL values, allowing them to be reused for future resolutions. However, you must be careful about the authority of cached glue records. A glue record provided by the `.com` TLD servers should not be considered authoritative for direct queries about `ns1.example.com` - only the `example.com` authoritative servers can provide authoritative answers for names within their zone.\n\n**Error Handling Without Glue**\n\nWhen glue records are missing for in-bailiwick nameservers, your resolver faces a bootstrapping challenge. The proper approach is to temporarily set aside the current resolution and initiate a separate recursive resolution for the nameserver's IP address. This creates a recursive resolution within recursive resolution:\n\n1. Main resolution for `www.example.com` encounters NS records for `ns1.example.com`\n2. No glue records provided for `ns1.example.com`\n3. Initiate separate resolution for `ns1.example.com A record`\n4. Once `ns1.example.com` resolves to an IP address, resume main resolution\n5. Continue with original query to the now-known nameserver IP\n\nThis approach requires careful state management to avoid infinite recursion and to detect genuine circular dependencies that cannot be resolved.\n\n> ⚠️ **Pitfall: Trusting Out-of-Bailiwick Glue**\n> \n> A common security vulnerability occurs when resolvers blindly trust glue records that fall outside the providing server's bailiwick. For example, if a `.com` TLD server provides a glue record for `ns1.evil.net`, your resolver should ignore this record because `.net` names are outside the `.com` server's authority. Accepting such records can lead to cache poisoning attacks where malicious servers redirect your queries to attacker-controlled IP addresses.\n\n### Architecture Decisions for Recursion\n\nThe recursive resolver implementation involves several critical architectural decisions that significantly impact the server's performance, reliability, and security characteristics. Each decision represents a trade-off between competing concerns, and understanding the rationale behind these choices is essential for building a robust resolver.\n\n> **Decision: Loop Detection Strategy**\n> - **Context**: Recursive resolution can encounter infinite loops due to misconfigured DNS zones, malicious servers providing circular referrals, or bugs in the resolver logic. Without proper loop detection, the resolver could consume unbounded resources and never return a response to the client.\n> - **Options Considered**: \n>   1. Maximum iteration count limiting total queries per resolution\n>   2. Visited nameserver tracking to detect cycles in server queries  \n>   3. Query depth limiting based on DNS hierarchy levels\n> - **Decision**: Implement maximum iteration count with a reasonable limit (typically 10-15 queries per resolution)\n> - **Rationale**: Maximum iteration count provides the strongest protection against all types of loops while being simple to implement and reason about. Most legitimate DNS resolutions require fewer than 10 queries (root → TLD → authoritative, plus possible CNAME following), so a limit of 15 provides safety margin without impacting normal operation.\n> - **Consequences**: Enables robust operation in hostile network environments but may fail to resolve extremely deep or complex DNS configurations. Requires careful tuning of the limit value.\n\n| Loop Detection Option | Pros | Cons | Implementation Complexity |\n|-----------------------|------|------|---------------------------|\n| Maximum iteration count | Simple, comprehensive protection | May block legitimate deep recursions | Low |\n| Visited server tracking | Precise cycle detection | Complex state management, memory overhead | Medium |\n| Query depth limiting | Maps to DNS hierarchy | Doesn't prevent horizontal loops | Low |\n\n> **Decision: Timeout and Retry Strategy**\n> - **Context**: DNS queries over UDP can be lost due to network congestion, server overload, or routing failures. The resolver must balance responsiveness (returning answers quickly) with reliability (finding answers despite transient failures).\n> - **Options Considered**:\n>   1. Single query with fixed timeout per server\n>   2. Exponential backoff with multiple retries per server\n>   3. Parallel queries to multiple servers with first-response wins\n> - **Decision**: Implement single query with 2-second timeout, try all available servers before giving up\n> - **Rationale**: DNS queries should typically complete within 1-2 seconds under normal conditions. Rather than spending time on retries to unresponsive servers, it's more effective to try alternative servers immediately. This provides better user experience and more effectively handles server-specific failures.\n> - **Consequences**: Provides good balance of speed and reliability while keeping implementation simple. May not handle transient network glitches as well as retry-based approaches.\n\n| Timeout Strategy | Pros | Cons | User Experience |\n|------------------|------|------|-----------------|\n| Fixed timeout, try all servers | Fast failure detection, simple | Less resilient to transient failures | Good |\n| Exponential backoff retries | Handles transient issues well | Slower response times | Poor |\n| Parallel queries | Fastest response | Higher bandwidth usage, server load | Excellent |\n\n> **Decision: CNAME Following Implementation**\n> - **Context**: CNAME records create aliases that point from one domain name to another. When a resolver encounters a CNAME, it must follow the chain to the final target to find the requested record type. CNAME chains can be complex, involving multiple hops and crossing zone boundaries.\n> - **Options Considered**:\n>   1. Recursive CNAME following with separate resolution for each target\n>   2. Iterative CNAME following within the same resolution context\n>   3. CNAME chain limit with immediate error on cycles\n> - **Decision**: Implement iterative CNAME following with a chain length limit of 10 and cycle detection\n> - **Rationale**: Iterative following within the same resolution context is more efficient and maintains better cache coherency. The chain limit prevents infinite loops while accommodating legitimate multi-hop CNAME configurations. Cycle detection provides additional safety against misconfigured zones.\n> - **Consequences**: Provides robust CNAME handling with good performance characteristics. Chain limit may be too restrictive for some complex configurations but prevents abuse.\n\n| CNAME Handling Option | Pros | Cons | Performance Impact |\n|-----------------------|------|------|-------------------|\n| Recursive resolution | Clean separation of concerns | Higher latency, cache fragmentation | High |\n| Iterative following | Better performance, cache coherency | More complex state management | Low |\n| Immediate error on CNAME | Simple, fast | Breaks many legitimate configurations | None |\n\n> **Decision: Concurrent Query Processing**\n> - **Context**: A recursive resolver may receive multiple queries simultaneously and should handle them efficiently without blocking. Each recursive resolution may involve multiple network round-trips, creating opportunities for parallelism.\n> - **Options Considered**:\n>   1. Goroutine per client query with shared cache\n>   2. Worker pool processing queries from a queue\n>   3. Single-threaded event loop with async I/O\n> - **Decision**: Use goroutine per client query with carefully synchronized cache access\n> - **Rationale**: Go's goroutines provide excellent concurrency primitives with low overhead. Each client query involves multiple network operations that benefit from parallel execution. Shared cache maximizes efficiency by allowing concurrent queries to benefit from each other's resolution work.\n> - **Consequences**: Excellent performance and scalability with straightforward implementation. Requires careful synchronization of shared state but Go's sync package provides good primitives for this.\n\n| Concurrency Model | Pros | Cons | Scalability |\n|-------------------|------|------|-------------|\n| Goroutine per query | Simple, excellent parallelism | Requires synchronization | Excellent |\n| Worker pool | Bounded resource usage | More complex, potential queuing delays | Good |\n| Single-threaded async | No synchronization needed | Complex state machines | Limited |\n\n> **Decision: Response Validation Strictness**\n> - **Context**: DNS responses from remote servers may contain malformed data, out-of-bailiwick records, or potentially malicious content. The resolver must balance security (rejecting invalid responses) with interoperability (working with imperfect server implementations).\n> - **Options Considered**:\n>   1. Strict validation rejecting any protocol violations\n>   2. Permissive validation accepting common protocol deviations\n>   3. Configurable validation with security/compatibility modes\n> - **Decision**: Implement strict validation for security-critical aspects (bailiwick, record matching) but permissive for formatting issues\n> - **Rationale**: Security violations like out-of-bailiwick records can enable cache poisoning attacks and must be rejected. However, minor formatting issues in responses are common in real-world DNS and shouldn't break resolution. This approach maximizes both security and interoperability.\n> - **Consequences**: Provides strong security guarantees while maintaining compatibility with the existing DNS ecosystem. May require ongoing tuning as new edge cases are discovered.\n\nThe resolver maintains several critical data structures to support these architectural decisions:\n\n| Data Structure | Purpose | Key Fields | Synchronization |\n|---------------|---------|------------|-----------------|\n| `ResolverConfig` | Resolution behavior parameters | `RootHints`, `Timeout`, `MaxDepth` | Read-only after initialization |\n| `ResolutionState` | Per-query resolution tracking | `QueryCount`, `VisitedServers`, `CNAMEChain` | Per-goroutine, no synchronization needed |\n| `CacheManager` | Shared resolution cache | `entries map[CacheKey]CacheEntry` | Mutex-protected for concurrent access |\n| `NetworkClient` | UDP query/response handling | `conn net.PacketConn`, `timeout time.Duration` | Thread-safe through net package |\n\n> ⚠️ **Pitfall: Infinite CNAME Loops**\n> \n> CNAME records can create infinite loops where domain A points to domain B, which points back to domain A. Without proper cycle detection, your resolver will follow this loop forever, eventually hitting the query count limit and returning SERVFAIL. Implement explicit CNAME cycle detection by maintaining a set of visited names during CNAME following. If you encounter a name you've already visited in the current chain, immediately return SERVFAIL with an appropriate error message.\n\n> ⚠️ **Pitfall: Cache Poisoning Through Glue Records**\n> \n> Malicious authoritative servers might try to poison your cache by providing glue records for domains outside their authority. For example, a server authoritative for `evil.com` might try to provide a glue record claiming that `www.google.com` resolves to an IP address they control. Always validate that glue records fall within the bailiwick of the server providing them, and never cache or use glue records that fall outside this scope.\n\n> ⚠️ **Pitfall: Unbounded Resource Consumption**\n> \n> Without proper limits, recursive resolution can consume unbounded memory and network resources. A single malicious query could trigger thousands of recursive lookups, exhausting server resources. Implement strict limits on query count per resolution, CNAME chain length, concurrent resolutions per client, and cache memory usage. These limits should be generous enough for legitimate use but strict enough to prevent abuse.\n\n### Implementation Guidance\n\nThe recursive resolver represents the most complex component of your DNS server, requiring careful orchestration of network operations, state management, and error handling. This implementation guidance provides the complete foundation and skeleton code needed to build a robust recursive resolver.\n\n**A. Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Network Transport | `net.Dial()` with manual UDP | `golang.org/x/net/dns` package |\n| Concurrent Processing | Goroutines with `sync.Mutex` | Worker pools with channels |\n| Timeout Management | `context.WithTimeout()` | Custom timeout manager |\n| DNS Message Construction | Manual serialization | Third-party DNS library |\n| Root Hints Storage | Hardcoded slice | External hints file |\n\n**B. Recommended File Structure:**\n\n```\ninternal/resolver/\n├── resolver.go              ← Main recursive resolver logic\n├── resolver_test.go         ← Comprehensive resolver tests  \n├── iterative.go            ← Iterative resolution algorithm\n├── glue.go                 ← Glue record handling\n├── cname.go                ← CNAME following logic\n├── validation.go           ← Response validation\n├── roothints.go            ← Root server bootstrap data\n└── testdata/\n    ├── root-hints.txt      ← Root server IP addresses\n    └── test-responses/     ← Canned DNS responses for testing\n```\n\n**C. Infrastructure Starter Code:**\n\nHere's the complete root hints management system that handles bootstrapping resolution:\n\n```go\npackage resolver\n\nimport (\n    \"net\"\n    \"strings\"\n)\n\n// RootHints manages the IP addresses of DNS root servers for bootstrap resolution\ntype RootHints struct {\n    servers []string\n    current int\n}\n\n// DefaultRootHints returns hardcoded root server IP addresses\n// These are the actual IP addresses of the DNS root servers as of 2024\nfunc DefaultRootHints() *RootHints {\n    return &RootHints{\n        servers: []string{\n            \"198.41.0.4\",     // a.root-servers.net\n            \"170.247.170.2\",  // b.root-servers.net  \n            \"192.33.4.12\",    // c.root-servers.net\n            \"199.7.91.13\",    // d.root-servers.net\n            \"192.203.230.10\", // e.root-servers.net\n            \"192.5.5.241\",    // f.root-servers.net\n            \"192.112.36.4\",   // g.root-servers.net\n            \"198.97.190.53\",  // h.root-servers.net\n            \"192.36.148.17\",  // i.root-servers.net\n            \"192.58.128.30\",  // j.root-servers.net\n            \"193.0.14.129\",   // k.root-servers.net\n            \"199.7.83.42\",    // l.root-servers.net\n            \"202.12.27.33\",   // m.root-servers.net\n        },\n    }\n}\n\n// NextServer returns the next root server IP to try, cycling through all servers\nfunc (rh *RootHints) NextServer() string {\n    if len(rh.servers) == 0 {\n        return \"\"\n    }\n    server := rh.servers[rh.current]\n    rh.current = (rh.current + 1) % len(rh.servers)\n    return server\n}\n\n// AllServers returns all root server IPs for parallel querying\nfunc (rh *RootHints) AllServers() []string {\n    return append([]string(nil), rh.servers...)\n}\n\n// NetworkClient handles UDP DNS query/response operations with timeout support\ntype NetworkClient struct {\n    conn    net.PacketConn\n    timeout time.Duration\n}\n\n// NewNetworkClient creates a UDP client for DNS queries\nfunc NewNetworkClient(timeout time.Duration) (*NetworkClient, error) {\n    conn, err := net.ListenPacket(\"udp\", \":0\")\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create UDP socket: %w\", err)\n    }\n    \n    return &NetworkClient{\n        conn:    conn,\n        timeout: timeout,\n    }, nil\n}\n\n// QueryServer sends a DNS query to the specified server and returns the response\nfunc (nc *NetworkClient) QueryServer(ctx context.Context, query []byte, serverIP string) ([]byte, error) {\n    addr, err := net.ResolveUDPAddr(\"udp\", serverIP+\":53\")\n    if err != nil {\n        return nil, fmt.Errorf(\"invalid server address %s: %w\", serverIP, err)\n    }\n\n    // Set deadline based on context timeout\n    deadline, ok := ctx.Deadline()\n    if ok {\n        nc.conn.SetWriteDeadline(deadline)\n    }\n\n    // Send query\n    _, err = nc.conn.WriteTo(query, addr)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to send query to %s: %w\", serverIP, err)\n    }\n\n    // Receive response\n    buffer := make([]byte, DNS_UDP_MAX_SIZE)\n    if ok {\n        nc.conn.SetReadDeadline(deadline)\n    }\n    \n    n, _, err := nc.conn.ReadFrom(buffer)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to receive response from %s: %w\", serverIP, err)\n    }\n\n    return buffer[:n], nil\n}\n\n// Close releases the UDP socket\nfunc (nc *NetworkClient) Close() error {\n    return nc.conn.Close()\n}\n```\n\n**D. Core Logic Skeleton Code:**\n\nHere's the main recursive resolver structure with detailed TODO comments mapping to the algorithm steps:\n\n```go\n// RecursiveResolver implements iterative DNS resolution following the DNS hierarchy\ntype RecursiveResolver struct {\n    config      *ResolverConfig\n    cache       *CacheManager\n    client      *NetworkClient\n    rootHints   *RootHints\n    mu          sync.RWMutex // Protects resolver statistics\n    queryCount  uint64\n    failedCount uint64\n}\n\n// ResolverConfig contains configuration parameters for recursive resolution behavior\ntype ResolverConfig struct {\n    RootHints      []string      // IP addresses of root servers\n    Timeout        time.Duration // Per-query timeout\n    MaxDepth       int          // Maximum referral depth\n    EnableRecursion bool         // Whether to perform recursive resolution\n    MaxCNAMEChain  int          // Maximum CNAME chain length\n}\n\n// ResolutionState tracks the state of a single recursive resolution operation\ntype ResolutionState struct {\n    originalQuestion Question           // The client's original question\n    currentQuestion  Question           // Current question being resolved (may differ due to CNAME)\n    queryCount      int               // Number of queries made so far\n    visitedServers  map[string]bool   // Servers already queried to detect loops\n    cnameChain      []string          // CNAME chain being followed\n    ctx            context.Context    // Cancellation and timeout context\n}\n\n// NewRecursiveResolver creates a new recursive resolver with the given configuration\nfunc NewRecursiveResolver(config *ResolverConfig, cache *CacheManager) (*RecursiveResolver, error) {\n    client, err := NewNetworkClient(config.Timeout)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create network client: %w\", err)\n    }\n\n    rootHints := DefaultRootHints()\n    if len(config.RootHints) > 0 {\n        rootHints = &RootHints{servers: config.RootHints}\n    }\n\n    return &RecursiveResolver{\n        config:    config,\n        cache:     cache,\n        client:    client,\n        rootHints: rootHints,\n    }, nil\n}\n\n// ResolveQuery performs complete recursive resolution for the given question\nfunc (r *RecursiveResolver) ResolveQuery(ctx context.Context, question Question) (*DNSMessage, error) {\n    // TODO 1: Create resolution state to track this query's progress\n    //   - Initialize ResolutionState with original question\n    //   - Set up visited servers map and CNAME chain tracking\n    //   - Create context with timeout from config\n\n    // TODO 2: Check cache for existing answer\n    //   - Build CacheKey from question name, type, class  \n    //   - Call cache.Get() to check for cached entry\n    //   - If cache hit and not expired, construct response and return\n    //   - Log cache hit for debugging\n\n    // TODO 3: Perform iterative resolution starting from root servers\n    //   - Call PerformIterativeResolution with resolution state\n    //   - Handle case where no answer is found (return NXDOMAIN)\n    //   - Handle network errors and timeouts appropriately\n\n    // TODO 4: Process final answer and handle CNAME chains\n    //   - If answer contains CNAME records, call FollowCNAME\n    //   - Validate that final answer matches original question type\n    //   - Cache all records received during resolution with their TTLs\n\n    // TODO 5: Construct final response message\n    //   - Create DNSMessage with same ID as original query\n    //   - Set appropriate flags (QR=1, RA=1, AA=0 for recursive)\n    //   - Copy question section from original query\n    //   - Add answer records to answer section\n    //   - Return completed response\n}\n\n// PerformIterativeResolution follows DNS hierarchy from root to authoritative servers\nfunc (r *RecursiveResolver) PerformIterativeResolution(state *ResolutionState) ([]ResourceRecord, error) {\n    // TODO 1: Initialize current nameserver list with root servers\n    //   - Get all root server IPs from rootHints\n    //   - Create nameserver list with IPs and port 53\n    //   - Set current zone to root zone (\"\")\n\n    // TODO 2: Begin iterative resolution loop\n    //   - Loop while we have nameservers to query and haven't exceeded maxDepth\n    //   - Check query count against MaxDepth limit on each iteration\n    //   - Select next nameserver from current nameserver list\n\n    // TODO 3: Send query to current nameserver\n    //   - Serialize current question into wire format using SerializeMessage\n    //   - Use NetworkClient.QueryServer to send query with timeout\n    //   - Parse response using ParseMessage\n    //   - Validate response ID matches query ID\n\n    // TODO 4: Process response based on type\n    //   - If response has answer records: validate and return them\n    //   - If response has authority section: extract NS records and continue\n    //   - If response is NXDOMAIN: cache negative response and return error\n    //   - If response is malformed: try next nameserver\n\n    // TODO 5: Extract referral information from authority section  \n    //   - Parse NS records to get next level nameservers\n    //   - Validate NS records are within proper bailiwick\n    //   - Extract glue records from additional section\n    //   - Build new nameserver list for next iteration\n\n    // TODO 6: Handle missing glue records\n    //   - For each NS record without corresponding glue\n    //   - If NS name is in-bailiwick, recursively resolve its A record\n    //   - Add resolved IP addresses to nameserver list\n    //   - Detect circular dependencies and handle gracefully\n\n    // TODO 7: Update resolution state for next iteration\n    //   - Add current server to visitedServers map  \n    //   - Increment query count\n    //   - Update current zone to the zone we're now querying\n    //   - Continue loop with new nameserver list\n\n    // Return empty slice and appropriate error if resolution fails\n    return nil, fmt.Errorf(\"resolution failed after %d queries\", state.queryCount)\n}\n\n// FollowCNAME resolves CNAME chains to find the final target records\nfunc (r *RecursiveResolver) FollowCNAME(ctx context.Context, cnameTarget string, originalType uint16, state *ResolutionState) ([]ResourceRecord, error) {\n    // TODO 1: Validate CNAME chain length\n    //   - Check len(state.cnameChain) against MaxCNAMEChain limit\n    //   - Return error if chain is too long to prevent infinite loops\n\n    // TODO 2: Detect CNAME cycles\n    //   - Check if cnameTarget is already in state.cnameChain  \n    //   - Return error if cycle detected to prevent infinite loops\n    //   - Add cnameTarget to cnameChain for tracking\n\n    // TODO 3: Create new question for CNAME target\n    //   - Build Question with cnameTarget as name\n    //   - Use originalType as the desired record type\n    //   - Preserve class from original question\n\n    // TODO 4: Recursively resolve the CNAME target\n    //   - Call PerformIterativeResolution with new question\n    //   - Handle case where CNAME target also returns CNAME (recursive following)\n    //   - Cache intermediate CNAME records with their TTLs\n\n    // TODO 5: Return final resolved records\n    //   - Validate final records match original requested type\n    //   - Include original CNAME record in answer along with final records\n    //   - Return combined record set to caller\n}\n\n// validateResponse checks DNS response for correctness and security issues\nfunc (r *RecursiveResolver) validateResponse(query *DNSMessage, response *DNSMessage, serverIP string) error {\n    // TODO 1: Validate basic response structure\n    //   - Check that response.Header.ID matches query.Header.ID\n    //   - Verify QR flag is set (this is a response, not a query)\n    //   - Check that question section matches original query\n    //   - Validate response code is not malformed\n\n    // TODO 2: Validate bailiwick for all records\n    //   - For each record in answer, authority, and additional sections\n    //   - Determine the authoritative zone being queried\n    //   - Verify record names fall within expected bailiwick\n    //   - Reject out-of-bailiwick records that could poison cache\n\n    // TODO 3: Validate glue records specifically  \n    //   - Extract NS records from authority section\n    //   - For each corresponding A/AAAA record in additional section\n    //   - Verify the A/AAAA record name matches an NS record target\n    //   - Verify the NS target name is within the delegated zone\n\n    // TODO 4: Validate record data integrity\n    //   - Check that A records contain valid IPv4 addresses\n    //   - Check that AAAA records contain valid IPv6 addresses\n    //   - Verify TTL values are reasonable (not negative, not excessive)\n    //   - Validate CNAME records don't coexist with other record types\n\n    return nil\n}\n```\n\n**E. Language-Specific Hints:**\n\n- Use `context.WithTimeout()` for per-query timeouts and cancellation\n- `sync.Map` can provide better performance than `map` with `sync.RWMutex` for cache\n- `net.SplitHostPort()` helps parse server addresses with ports\n- `time.Now().Add(time.Duration(ttl) * time.Second)` for TTL expiration times\n- `strings.ToLower()` for case-insensitive domain name comparisons\n- `binary.BigEndian` for network byte order in manual message parsing\n\n**F. Milestone Checkpoint:**\n\nAfter implementing the recursive resolver, verify correct behavior:\n\n```bash\n# Test basic recursive resolution\ngo test ./internal/resolver/ -v -run TestRecursiveResolution\n\n# Test with real DNS queries\ngo run cmd/dns-server/main.go &\ndig @localhost -p 8053 www.google.com\n\n# Expected output: Answer section with A records for www.google.com\n# Response should have RA flag set indicating recursion available\n# Query should complete in under 5 seconds for cached results\n\n# Test CNAME following\ndig @localhost -p 8053 www.github.com\n# Should follow CNAME chain and return final A records\n\n# Test error handling\ndig @localhost -p 8053 nonexistent.invalid\n# Should return NXDOMAIN response code\n```\n\n**Signs of correct implementation:**\n- Queries for popular domains (google.com, cloudflare.com) resolve successfully\n- Second query for same domain returns much faster (cache hit)\n- NXDOMAIN responses are returned for nonexistent domains\n- Server doesn't crash or hang on malformed queries\n- Memory usage remains stable over time\n\n**Signs something is wrong:**\n- All queries timeout → Check network client setup and root hints\n- Queries never complete → Look for infinite loops in iterative resolution\n- Cache poisoning warnings → Verify bailiwick validation logic\n- Memory usage grows unbounded → Check for cache size limits and cleanup\n\n\n## Caching and Performance (Milestone 4)\n\n> **Milestone(s):** 4 (Caching & Performance)\n\nA DNS server without caching is like a librarian who forgets every book's location the moment they help a patron. Every query would require walking through the entire resolution process from root servers, creating unbearable latency and overwhelming upstream servers with redundant requests. Milestone 4 transforms our recursive resolver from a forgetful librarian into one with excellent short-term memory, dramatically improving performance through intelligent caching while maintaining correctness through TTL-based expiration.\n\nThe caching layer serves multiple critical functions beyond simple performance optimization. It acts as a buffer against network failures, provides consistent response times for popular domains, and implements negative caching to avoid repeatedly querying for non-existent domains. However, caching introduces complexity around cache consistency, security validation, and concurrent access patterns that require careful architectural decisions.\n\n### Mental Model: Cache as Recent Memory\n\nThink of the DNS cache as human short-term memory with automatic forgetting. When you meet someone new, you remember their name for a while, but if you don't use that information, it gradually fades until you've completely forgotten it. The DNS cache works similarly—when the resolver learns a domain's IP address, it remembers that mapping for a specific duration (the TTL), but automatically forgets it when that time expires.\n\nThis memory analogy extends to capacity limits and prioritization. Just as human memory has finite capacity and prioritizes recent or frequently accessed information, the DNS cache must make decisions about what to remember when storage becomes limited. The cache evicts older or less frequently accessed entries to make room for new information, similar to how we naturally forget unused details over time.\n\nThe automatic forgetting aspect is crucial for correctness. Unlike human memory, which fades gradually and unreliably, DNS cache expiration is precise and mandatory. Each cached entry has an exact expiration time, ensuring that stale information is never served beyond its intended lifetime. This precision prevents the cache from becoming a source of incorrect data when domain configurations change.\n\nNegative caching adds another dimension to this memory model—remembering that something doesn't exist. When you ask someone about a person they've never heard of, you might remember that this person doesn't exist in their social circle, avoiding the need to ask again soon. DNS negative caching works similarly, remembering that specific domains or record types don't exist to avoid repeated failed queries.\n\n### TTL-Based Cache Management\n\nThe Time-To-Live (TTL) system forms the foundation of DNS cache management, providing a distributed mechanism for controlling cache consistency across the internet. Each resource record includes a TTL value specified by the authoritative server, representing the maximum number of seconds that record may be cached before it must be refreshed. This creates a contract between authoritative servers and caches—the authoritative server promises not to change the record for at least the TTL duration, while caches promise not to serve the record beyond that time.\n\nCache storage involves creating entries that combine the resource records with expiration timestamps calculated from the current time plus the TTL value. The cache key consists of the domain name, record type, and class, ensuring that different query types for the same domain are cached separately. When storing records, the cache must handle cases where multiple records of the same type exist for a domain, such as multiple A records for load balancing.\n\n| Cache Entry Field | Type | Description |\n|-------------------|------|-------------|\n| Records | []ResourceRecord | The actual DNS records being cached |\n| ExpiresAt | time.Time | Absolute expiration timestamp calculated from current time + TTL |\n| Negative | bool | True if this entry represents a negative response (NXDOMAIN/NODATA) |\n| SOARecord | *ResourceRecord | SOA record for negative entries to determine negative cache TTL |\n| HitCount | uint64 | Number of times this entry has been accessed (for LRU eviction) |\n| Size | int | Memory usage of this entry for cache size management |\n\nCache lookup involves checking for the existence of a key and validating that the cached entry hasn't expired. The lookup process must be atomic to prevent race conditions in concurrent environments. If an entry exists but has expired, it should be treated as a cache miss and removed during the lookup operation to prevent serving stale data.\n\n> **Key Design Insight**: TTL countdown should be calculated using absolute expiration times rather than decrementing counters. This approach is more robust against system clock adjustments and simplifies the expiration checking logic.\n\nCache expiration requires periodic cleanup to remove expired entries and reclaim memory. A background cleanup process runs at regular intervals, scanning all cache entries and removing those whose expiration time has passed. This proactive cleanup prevents the cache from growing unbounded with expired entries and maintains accurate memory usage statistics.\n\nThe cache must handle TTL edge cases carefully. When multiple resource records for the same cache key have different TTL values, the cache should use the minimum TTL to ensure all records remain valid. For negative responses, the TTL is derived from the SOA record's minimum field rather than from the non-existent records themselves.\n\n> **Decision: Absolute Expiration Times vs. TTL Countdown**\n> - **Context**: Cache entries need expiration tracking to ensure stale data isn't served\n> - **Options Considered**: \n>   1. Store original TTL and decrement periodically\n>   2. Calculate absolute expiration time at storage\n>   3. Hybrid approach with both TTL and expiration time\n> - **Decision**: Store absolute expiration time calculated at storage\n> - **Rationale**: Absolute times are immune to system clock adjustments, eliminate the need for periodic TTL decrements, and simplify expiration checking to a single timestamp comparison\n> - **Consequences**: Enables efficient expiration checking and eliminates TTL underflow bugs, but requires accurate system clock for correctness\n\n### Negative Caching Strategy\n\nNegative caching prevents the cache from becoming a performance bottleneck when clients repeatedly query for non-existent domains or record types. Without negative caching, each query for a non-existent domain would trigger a full recursive resolution, consuming network resources and adding latency. Negative caching transforms these expensive operations into fast cache hits, dramatically improving performance for common error scenarios.\n\nDNS defines two types of negative responses that should be cached differently. NXDOMAIN responses indicate that the queried domain name does not exist at all, while NODATA responses indicate that the domain exists but has no records of the requested type. Both response types should be cached, but they have different implications for future queries and different TTL calculation methods.\n\nThe TTL for negative cache entries is derived from the SOA record's minimum field, which appears in the authority section of negative responses. This SOA minimum value represents the negative cache TTL as specified by the authoritative server, providing a mechanism for domain administrators to control how long negative responses should be cached.\n\n| Negative Cache Type | Response Code | Meaning | TTL Source | Cache Behavior |\n|---------------------|---------------|---------|------------|----------------|\n| NXDOMAIN | 3 | Domain does not exist | SOA minimum field | Cache for exact domain name, all types |\n| NODATA | 0 | Domain exists, no records of this type | SOA minimum field | Cache for specific domain/type combination |\n\nNegative cache storage requires careful key management to ensure that negative responses don't interfere with positive responses. A negative cache entry for a specific domain and record type should only prevent queries for that exact combination, not for other record types that might exist for the same domain.\n\nThe negative cache must handle query patterns intelligently. When a client queries for multiple record types for the same domain, a negative cache hit for one type shouldn't prevent checking for other types unless it's an NXDOMAIN response, which indicates the entire domain is non-existent.\n\n> **Decision: Separate Negative Cache vs. Unified Cache with Flags**\n> - **Context**: Negative responses need caching but have different semantics than positive responses\n> - **Options Considered**:\n>   1. Separate data structure for negative cache entries\n>   2. Unified cache with boolean flag to indicate negative entries\n>   3. Special sentinel values in the main cache\n> - **Decision**: Unified cache with Negative boolean field in CacheEntry\n> - **Rationale**: Simplifies cache management logic, enables unified TTL handling and eviction policies, and reduces code duplication while maintaining semantic clarity\n> - **Consequences**: Slightly more complex cache entry structure, but unified expiration and size management across positive and negative entries\n\nCache poisoning prevention becomes critical when implementing negative caching. Malicious responses could attempt to inject negative cache entries for legitimate domains, causing denial of service. The cache must validate that negative responses come from authoritative sources and that the SOA record in the authority section matches the queried domain's zone.\n\n### Concurrent Query Processing\n\nDNS servers must handle multiple simultaneous queries without blocking, as real-world DNS traffic consists of concurrent requests from many clients. A blocking approach where each query waits for the previous one to complete would create unacceptable latency and poor throughput. Concurrent processing transforms the DNS server from a single-threaded bottleneck into a responsive service capable of handling realistic traffic loads.\n\nThe primary concurrency challenge involves shared access to the cache data structure. Multiple goroutines will simultaneously read from and write to the cache, requiring synchronization to prevent data races and corruption. The cache must support high-concurrency read access (cache hits) while serializing write access (cache updates) to maintain consistency.\n\n![Concurrent Query Processing Architecture](./diagrams/concurrent-query-handling.svg)\n\nRead-write mutex locking provides an efficient solution for cache concurrency. Read operations (cache lookups) can proceed concurrently using read locks, while write operations (cache updates, expiration) require exclusive write locks. This approach maximizes throughput for the common case (cache hits) while ensuring safety for cache modifications.\n\n| Concurrency Pattern | Lock Type | Use Case | Performance Impact |\n|---------------------|-----------|----------|-------------------|\n| Cache Lookup | Read Lock | Multiple concurrent cache hits | High throughput, low contention |\n| Cache Insert | Write Lock | Adding new cache entries | Exclusive access, brief contention |\n| Cache Cleanup | Write Lock | Removing expired entries | Exclusive access, periodic operation |\n| Cache Statistics | Read Lock | Monitoring cache state | Concurrent with lookups |\n\nQuery processing pipelines can be implemented using goroutines, where each incoming UDP packet spawns a new goroutine to handle the query independently. This approach provides natural isolation between queries and allows the Go runtime to efficiently schedule work across available CPU cores.\n\n```go\n// Goroutine-per-query pattern\ngo func(queryData []byte, clientAddr net.Addr) {\n    defer recover() // Handle panics gracefully\n    response := server.handleQuery(queryData, clientAddr)\n    server.sendResponse(response, clientAddr)\n}(data, addr)\n```\n\nResource management becomes important with goroutine-per-query patterns to prevent resource exhaustion under high load. The server should implement goroutine pooling or rate limiting to cap the maximum number of concurrent queries. Additionally, each query should have a timeout to prevent goroutines from hanging indefinitely on network operations.\n\nConnection sharing for upstream queries requires careful coordination. When multiple concurrent queries need to resolve the same domain, they should share the recursive resolution work rather than each starting independent resolution processes. This requires query coalescing logic that detects duplicate in-flight queries and allows multiple local queries to wait for a single upstream resolution.\n\n> **Decision: Goroutine-Per-Query vs. Worker Pool Pattern**\n> - **Context**: Server must handle multiple concurrent DNS queries efficiently\n> - **Options Considered**:\n>   1. Goroutine spawned for each incoming query\n>   2. Fixed pool of worker goroutines processing query queue\n>   3. Adaptive worker pool that scales with load\n> - **Decision**: Goroutine-per-query with resource limits\n> - **Rationale**: Go's goroutines are lightweight and the runtime handles scheduling efficiently, query processing is naturally isolated, and implementation is simpler than worker pool management\n> - **Consequences**: Excellent performance under normal load with simple implementation, but requires rate limiting to prevent resource exhaustion under extreme load\n\n### Architecture Decisions for Caching\n\nCache size management requires balancing memory usage against performance benefits. The cache should implement both entry count limits and memory usage limits to prevent unbounded growth. When limits are reached, the cache must evict entries using a policy that maximizes hit rate while maintaining fairness across different query patterns.\n\nLeast Recently Used (LRU) eviction provides a good balance between implementation complexity and cache effectiveness. The cache tracks access times for entries and evicts the least recently accessed entries when space is needed. This policy tends to keep frequently accessed entries while removing entries that are no longer actively used.\n\n| Eviction Policy | Implementation Complexity | Hit Rate Performance | Memory Overhead | Chosen |\n|-----------------|---------------------------|----------------------|-----------------|--------|\n| FIFO (First In, First Out) | Low | Poor for temporal locality | Low | No |\n| LRU (Least Recently Used) | Medium | Good for most workloads | Medium | Yes |\n| LFU (Least Frequently Used) | High | Good for stable workloads | High | No |\n| Random Replacement | Very Low | Unpredictable | Very Low | No |\n\nCache security validation prevents cache poisoning attacks where malicious responses attempt to inject false information into the cache. The cache must validate that response records match the original query and that the responding server has authority for the returned data. This validation is particularly important for negative caching, where false negative responses could cause denial of service.\n\nBailiwick checking ensures that cache entries only contain records that the responding server has authority to provide. For example, a response from a .com nameserver should only contain records for domains within the .com zone, not for arbitrary domains like .org. This prevents cache poisoning through out-of-bailiwick data injection.\n\n> **Decision: Cache Size Limits - Entry Count vs. Memory Usage**\n> - **Context**: Cache needs bounds to prevent memory exhaustion\n> - **Options Considered**:\n>   1. Limit by number of cache entries only\n>   2. Limit by total memory usage only  \n>   3. Dual limits with both entry count and memory usage\n> - **Decision**: Dual limits with both maximum entries and maximum memory\n> - **Rationale**: Entry count limits provide predictable behavior and simple implementation, while memory limits prevent large records from bypassing entry limits and consuming excessive memory\n> - **Consequences**: More complex cache management logic, but better protection against both memory exhaustion and cache flooding attacks\n\nCache statistics collection enables monitoring and performance tuning of the cache system. The cache should track hit rates, memory usage, eviction rates, and other metrics that help operators understand cache behavior and identify performance bottlenecks.\n\n| Cache Metric | Purpose | Collection Method | Impact on Performance |\n|--------------|---------|-------------------|----------------------|\n| Hit Rate | Measure cache effectiveness | Increment counters on hit/miss | Minimal |\n| Memory Usage | Monitor resource consumption | Track entry sizes | Low |\n| Eviction Count | Detect cache pressure | Increment on eviction | Minimal |\n| Average TTL | Understand cache lifetime patterns | Calculate during insertion | Low |\n\nThread safety for cache statistics requires atomic operations or separate locks to prevent corruption while maintaining performance. The statistics collection should not significantly impact cache operation performance, suggesting the use of atomic counters rather than mutex-protected counters for frequently updated metrics.\n\n![Cache Entry State Machine](./diagrams/cache-state-machine.svg)\n\n### Common Pitfalls\n\n⚠️ **Pitfall: TTL Underflow in Countdown Systems**\n\nMany implementations attempt to store the original TTL and decrement it periodically, leading to integer underflow bugs when the decrement operation occurs after the TTL should have expired. This can cause entries to appear to have very large TTL values (due to unsigned integer wraparound) and remain cached indefinitely. The fix is to use absolute expiration timestamps calculated at cache insertion time.\n\n⚠️ **Pitfall: Cache Poisoning Through Out-of-Bailiwick Records**\n\nAccepting and caching records that are outside the authority of the responding server creates a cache poisoning vulnerability. For example, caching an A record for google.com from a response by a .edu nameserver. Always validate that cached records fall within the responding server's zone of authority, and reject out-of-bailiwick records even if they appear in otherwise legitimate responses.\n\n⚠️ **Pitfall: Race Conditions in Concurrent Cache Access**\n\nReading cache entries while they're being modified by concurrent goroutines can lead to corrupted data or panics. This often manifests as intermittent crashes or incorrect responses under load. Implement proper read-write mutex locking around all cache operations, ensuring that cache lookups use read locks and cache modifications use write locks.\n\n⚠️ **Pitfall: Memory Leaks from Unbounded Cache Growth**\n\nWithout proper size limits and eviction policies, the cache can grow indefinitely and consume all available memory. This is particularly problematic when handling queries for many different domains or when under attack from cache flooding attempts. Implement both entry count and memory usage limits with LRU eviction to bound cache size.\n\n⚠️ **Pitfall: Serving Expired Cache Entries**\n\nForgetting to check expiration times during cache lookup can result in serving stale data beyond its intended lifetime. This violates DNS protocol requirements and can cause incorrect resolution. Always verify that `time.Now().Before(entry.ExpiresAt)` before returning cache entries, and remove expired entries during lookup operations.\n\n⚠️ **Pitfall: Incorrect Negative Cache TTL Calculation**\n\nUsing the wrong TTL source for negative cache entries can result in caching negative responses for inappropriate durations. Negative cache TTL should come from the SOA record's minimum field in the authority section, not from the query's requested record type or arbitrary default values. Missing or incorrectly parsed SOA records should result in shorter default negative cache durations.\n\n⚠️ **Pitfall: Query Coalescing Race Conditions**\n\nWhen multiple concurrent queries for the same domain attempt to share resolution work, race conditions can occur where multiple recursive resolutions start simultaneously, or where query responses are delivered to the wrong waiting queries. Implement proper synchronization using channels or condition variables to coordinate query sharing and response distribution.\n\n### Implementation Guidance\n\nThe caching layer requires careful coordination between concurrent access patterns, memory management, and expiration handling. The implementation should prioritize correctness over performance optimizations, as cache corruption bugs are difficult to debug and can cause widespread DNS resolution failures.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Cache Storage | `sync.RWMutex` + `map[CacheKey]*CacheEntry` | Concurrent hash map with lock striping |\n| Expiration Cleanup | Periodic `time.Ticker` goroutine | Lazy expiration on access + background cleanup |\n| Memory Tracking | Manual size calculation and summation | Memory profiling integration with pprof |\n| Concurrency Model | Goroutine per query with shared cache | Worker pool with per-worker cache shards |\n| Statistics Collection | Atomic counters (`sync/atomic`) | Metrics framework like Prometheus |\n\n#### Cache Manager Implementation\n\n```go\npackage cache\n\nimport (\n    \"sync\"\n    \"sync/atomic\"\n    \"time\"\n)\n\n// CacheManager implements TTL-based caching with concurrent access support.\n// It provides both positive and negative caching with LRU eviction policy.\ntype CacheManager struct {\n    // Core cache storage protected by RWMutex for concurrent access\n    mu    sync.RWMutex\n    cache map[CacheKey]*CacheEntry\n    \n    // Configuration and limits\n    maxEntries int\n    maxMemory  int64\n    \n    // Statistics tracked with atomic operations for thread safety\n    stats CacheStats\n    \n    // Background cleanup management\n    cleanupTicker *time.Ticker\n    stopCleanup   chan struct{}\n}\n\n// NewCacheManager creates a cache manager with specified limits.\n// maxEntries controls the maximum number of cache entries.\n// maxMemory limits total memory usage in bytes.\n// cleanupInterval determines how often expired entries are removed.\nfunc NewCacheManager(maxEntries int, maxMemory int64, cleanupInterval time.Duration) *CacheManager {\n    cm := &CacheManager{\n        cache:      make(map[CacheKey]*CacheEntry),\n        maxEntries: maxEntries,\n        maxMemory:  maxMemory,\n        stopCleanup: make(chan struct{}),\n    }\n    \n    // Start background cleanup goroutine\n    cm.cleanupTicker = time.NewTicker(cleanupInterval)\n    go cm.backgroundCleanup()\n    \n    return cm\n}\n\n// Get retrieves a cache entry if it exists and hasn't expired.\n// Returns the entry and true if found and valid, nil and false otherwise.\nfunc (cm *CacheManager) Get(key CacheKey) (*CacheEntry, bool) {\n    // TODO 1: Acquire read lock for concurrent access\n    // TODO 2: Look up key in cache map\n    // TODO 3: Check if entry exists\n    // TODO 4: Verify entry hasn't expired using time.Now().Before(entry.ExpiresAt)\n    // TODO 5: If expired, remove entry and return cache miss\n    // TODO 6: Update hit count for LRU tracking\n    // TODO 7: Increment cache hit statistics atomically\n    // TODO 8: Return entry copy to prevent external modification\n    panic(\"TODO: implement cache lookup with expiration checking\")\n}\n\n// Put stores records in the cache with TTL-based expiration.\n// Records with TTL 0 are not cached. Handles cache size limits with LRU eviction.\nfunc (cm *CacheManager) Put(key CacheKey, records []ResourceRecord, ttl uint32) error {\n    // TODO 1: Validate TTL is greater than 0 (don't cache zero TTL records)\n    // TODO 2: Calculate absolute expiration time from current time + TTL\n    // TODO 3: Create CacheEntry with records, expiration, and metadata\n    // TODO 4: Acquire write lock for exclusive access\n    // TODO 5: Check if adding entry would exceed size limits\n    // TODO 6: If over limits, run LRU eviction to free space\n    // TODO 7: Insert entry into cache map\n    // TODO 8: Update memory usage and entry count statistics\n    // TODO 9: Return nil on success\n    panic(\"TODO: implement cache insertion with size management\")\n}\n\n// PutNegative caches a negative response (NXDOMAIN or NODATA).\n// Uses SOA minimum field for TTL calculation.\nfunc (cm *CacheManager) PutNegative(key CacheKey, soaRecord ResourceRecord) error {\n    // TODO 1: Extract TTL from SOA record's minimum field\n    // TODO 2: Create negative CacheEntry with Negative flag set to true\n    // TODO 3: Store SOA record for negative cache TTL validation\n    // TODO 4: Use same insertion logic as Put() but mark as negative\n    // Hint: Negative entries contain the SOA record instead of answer records\n    panic(\"TODO: implement negative caching with SOA TTL\")\n}\n\n// backgroundCleanup runs periodically to remove expired entries.\n// This prevents the cache from growing with expired entries between lookups.\nfunc (cm *CacheManager) backgroundCleanup() {\n    for {\n        select {\n        case <-cm.cleanupTicker.C:\n            // TODO 1: Acquire write lock for cleanup operation\n            // TODO 2: Iterate through all cache entries\n            // TODO 3: Check each entry's expiration time against current time\n            // TODO 4: Remove expired entries from map\n            // TODO 5: Update memory usage and entry count statistics\n            // TODO 6: Track number of entries cleaned up\n            \n        case <-cm.stopCleanup:\n            return\n        }\n    }\n}\n\n// Stats returns current cache performance and usage statistics.\n// Safe for concurrent access using atomic operations.\nfunc (cm *CacheManager) Stats() CacheStats {\n    // TODO 1: Read atomic counters for hits, misses, queries\n    // TODO 2: Calculate hit rate as hits / total queries\n    // TODO 3: Get current entry count and memory usage with read lock\n    // TODO 4: Return populated CacheStats struct\n    panic(\"TODO: implement statistics collection\")\n}\n```\n\n#### Concurrent Query Handler\n\n```go\npackage server\n\nimport (\n    \"context\"\n    \"net\"\n    \"sync\"\n    \"time\"\n)\n\n// QueryCoalescer prevents duplicate concurrent queries for the same domain.\n// Multiple clients querying the same domain will share one recursive resolution.\ntype QueryCoalescer struct {\n    mu sync.Mutex\n    inFlight map[CacheKey]chan *DNSMessage\n}\n\n// NewQueryCoalescer creates a coalescer for sharing resolution work.\nfunc NewQueryCoalescer() *QueryCoalescer {\n    return &QueryCoalescer{\n        inFlight: make(map[CacheKey]chan *DNSMessage),\n    }\n}\n\n// CoalesceQuery checks if the same query is already being resolved.\n// If yes, waits for the existing resolution. If no, starts a new resolution.\nfunc (qc *QueryCoalescer) CoalesceQuery(ctx context.Context, key CacheKey, resolveFunc func() (*DNSMessage, error)) (*DNSMessage, error) {\n    // TODO 1: Lock the in-flight map for exclusive access\n    // TODO 2: Check if this query key is already being resolved\n    // TODO 3: If yes, wait on the existing channel for the result\n    // TODO 4: If no, create a new channel and add to in-flight map\n    // TODO 5: Release lock and call resolveFunc to perform resolution\n    // TODO 6: Send result to all waiting goroutines via the channel\n    // TODO 7: Remove completed query from in-flight map\n    // TODO 8: Handle context cancellation and timeouts\n    panic(\"TODO: implement query coalescing\")\n}\n\n// Server handles concurrent DNS queries with caching and coalescing.\nfunc (s *Server) handleConcurrentQuery(queryData []byte, clientAddr net.Addr) {\n    // TODO 1: Parse incoming DNS message from queryData\n    // TODO 2: Extract question to create cache key\n    // TODO 3: Check cache for existing valid entry\n    // TODO 4: If cache hit, construct response and send immediately\n    // TODO 5: If cache miss, use QueryCoalescer to avoid duplicate work\n    // TODO 6: Perform recursive resolution if needed\n    // TODO 7: Cache the resolution result with appropriate TTL\n    // TODO 8: Construct and send response to client\n    // TODO 9: Handle any errors gracefully and send error responses\n    \n    // Use timeout context to prevent hanging queries\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()\n    \n    panic(\"TODO: implement concurrent query handling\")\n}\n```\n\n#### File Structure Organization\n\n```\ndns-server/\n├── cmd/dns-server/\n│   └── main.go                    ← Entry point, configuration loading\n├── internal/cache/\n│   ├── manager.go                 ← CacheManager implementation\n│   ├── manager_test.go            ← Cache functionality tests\n│   ├── stats.go                   ← Statistics collection and reporting\n│   └── types.go                   ← CacheKey, CacheEntry, CacheStats definitions\n├── internal/server/\n│   ├── server.go                  ← Main server with concurrent handling\n│   ├── coalesce.go                ← Query coalescing implementation\n│   └── handlers.go                ← Query processing pipeline\n├── internal/resolver/\n│   ├── recursive.go               ← RecursiveResolver from Milestone 3\n│   └── validation.go              ← Response validation and security checks\n└── internal/protocol/\n    ├── message.go                 ← DNS message parsing from Milestone 1\n    └── types.go                   ← DNS protocol type definitions\n```\n\n#### Milestone Checkpoint\n\nAfter implementing Milestone 4, your DNS server should demonstrate significant performance improvements and handle concurrent load effectively:\n\n**Testing Cache Functionality:**\n```bash\n# Test basic caching - first query should be slow, second should be fast\ntime dig @localhost -p 5053 google.com A\ntime dig @localhost -p 5053 google.com A  # Should be much faster\n\n# Test negative caching\ntime dig @localhost -p 5053 nonexistent.example.com A\ntime dig @localhost -p 5053 nonexistent.example.com A  # Should be fast\n\n# Test concurrent queries\nfor i in {1..10}; do dig @localhost -p 5053 facebook.com A & done\nwait  # All queries should complete without errors\n```\n\n**Expected Behavior:**\n- First query to a domain takes 100-500ms (recursive resolution time)\n- Subsequent queries to cached domains complete in <10ms\n- Negative queries for non-existent domains are cached and return quickly\n- Server handles 10+ concurrent queries without blocking\n- Cache statistics show reasonable hit rates (>50% after some usage)\n\n**Performance Verification:**\n- Monitor cache hit rate via statistics endpoint or logs\n- Verify memory usage stays within configured limits\n- Check that expired entries are cleaned up automatically\n- Confirm that cache poisoning attempts are rejected\n\n**Signs of Problems:**\n- Memory usage grows indefinitely → missing eviction policy or cleanup\n- Intermittent crashes under load → race conditions in cache access\n- Stale data served after TTL expiration → expiration checking bugs\n- Poor cache hit rates → incorrect cache key generation or premature eviction\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** All milestones (1-4) - Understanding component interactions is essential for implementing each milestone's functionality\n\nThe architecture of a DNS server comes alive through the intricate dance of data flowing between its components. Like a well-orchestrated symphony where each musician knows their part and cues, the DNS server components must seamlessly pass messages, coordinate state changes, and maintain consistency while handling concurrent requests. Understanding these interactions is crucial because DNS servers must process hundreds or thousands of queries per second while maintaining correctness and performance.\n\n### Mental Model: DNS Server as a Restaurant Kitchen\n\nThink of the DNS server as a high-end restaurant kitchen during dinner rush. The **UDP Server** acts as the expediter, receiving orders (queries) from customers (clients) and routing them to the appropriate stations. The **Message Parser** is like the prep cook who breaks down complex orders into understandable ingredients and instructions. The **Recursive Resolver** functions as the head chef who coordinates with multiple vendors (root servers, TLD servers) to source special ingredients (authoritative answers) when they're not in stock. The **Cache Manager** serves as the walk-in cooler, storing frequently used ingredients (cached records) so they're immediately available without ordering from suppliers. Finally, the **Zone Data Manager** acts as the pantry containing house-made items (authoritative zone data) that the restaurant produces itself.\n\nJust as kitchen stations must communicate timing, share resources, and coordinate handoffs without dropping orders or serving cold food, DNS components must pass messages efficiently, share cached data safely across concurrent operations, and maintain response times that meet client expectations.\n\n## Query Processing Flow\n\nThe end-to-end flow of a DNS query through the server represents the primary workflow that ties all components together. This flow must handle multiple query types, error conditions, and performance optimizations while maintaining protocol correctness.\n\n### Inbound Query Processing Pipeline\n\nWhen a UDP packet arrives at the DNS server, it triggers a carefully orchestrated sequence of operations that involves every major component. The processing pipeline follows a consistent pattern regardless of whether the query can be answered authoritatively, from cache, or requires recursive resolution.\n\nThe pipeline begins with **packet reception** at the UDP server layer. The server receives a raw byte array from the network along with the client's address information. This raw data must be immediately validated for basic sanity checks - minimum packet size, proper DNS header structure, and message length consistency. Invalid packets are dropped silently to prevent resource exhaustion from malformed requests or potential attacks.\n\n![Query Processing Flowchart](./diagrams/query-processing-flow.svg)\n\nOnce basic validation passes, the **message parsing** phase begins. The `MessageParser` component takes the raw bytes and constructs a structured `DNSMessage` object. This parsing must handle name compression, validate field relationships (like question counts matching actual questions), and detect malformed sections that could indicate protocol violations or corruption. Parse failures result in immediate FORMERR responses to inform clients of malformed queries.\n\nThe **query classification** step determines how to route the parsed message through the rest of the system. The server examines the question section to determine if it holds authoritative data for the queried domain, whether cached data might satisfy the request, or if recursive resolution is needed. This decision point fundamentally changes the processing path and involves consulting the zone configuration and cache state.\n\n| Processing Phase | Component Responsible | Input | Output | Error Conditions |\n|-----------------|----------------------|--------|---------|------------------|\n| Packet Reception | UDP Server | Raw bytes + client address | Validated byte array | Packet too small, network errors |\n| Message Parsing | Message Parser | Raw DNS bytes | `DNSMessage` struct | Malformed header, compression loops |\n| Query Classification | Message Handler | Parsed DNS message | Processing decision | Invalid question section |\n| Authority Check | Zone Data Manager | Domain name + question | Zone match result | Zone file corruption |\n| Cache Lookup | Cache Manager | Cache key | Cache entry or miss | Cache corruption |\n| Response Construction | Message Handler | Answer records | `DNSMessage` response | Serialization failure |\n| Response Transmission | UDP Server | Response message + client | Network transmission | Client unreachable |\n\n### Authoritative Query Path\n\nWhen the DNS server determines it holds authoritative data for a queried domain, the processing follows a streamlined path through the zone data manager. The server first validates that the questioned domain falls within one of its configured zones, considering the DNS hierarchy and longest-match principles.\n\nThe **zone matching** process examines the question's domain name against all configured zone origins, finding the most specific zone that encompasses the query. For example, a query for `mail.example.com` would match a zone for `example.com` rather than a zone for `com`, following DNS delegation principles. This matching must handle edge cases like empty non-terminal nodes and wildcard records.\n\nOnce the appropriate zone is identified, **record matching** searches the zone's data structures for records that satisfy the query. The matching algorithm considers the exact domain name, record type, and class, but must also handle special cases like CNAME resolution, wildcard expansion, and delegation responses for subdomains.\n\nThe **response construction** phase assembles answer, authority, and additional sections according to DNS protocol requirements. Answer sections contain the requested records, authority sections include SOA or NS records as appropriate, and additional sections provide glue records for NS responses to enable resolution continuation.\n\n### Recursive Query Path\n\nRecursive queries follow a more complex path that may involve multiple external network requests and cache interactions. The recursive resolver must maintain resolution state across multiple round trips while avoiding infinite loops and handling various error conditions.\n\nThe **cache consultation** happens first, where the resolver checks if a valid, non-expired cache entry exists for the exact question. Cache hits allow immediate response construction, while cache misses trigger the full recursive resolution process. Negative cache entries (for NXDOMAIN responses) are also consulted to avoid repeated queries for non-existent domains.\n\nWhen cache misses occur, **iterative resolution** begins by consulting root hints and following NS referrals down the DNS hierarchy. The resolver maintains a `ResolutionState` object that tracks the current question, visited servers, CNAME chains, and query depth to prevent loops and limit resource consumption.\n\nEach iteration of the resolution process involves **server selection** from the current set of nameservers, **query transmission** over UDP with timeout handling, **response validation** to prevent cache poisoning, and **referral following** to continue down the hierarchy. The resolver must handle glue records, out-of-bailiwick data filtering, and CNAME chain resolution.\n\n### Error Handling Flow\n\nError conditions can arise at every stage of query processing, and the server must handle them gracefully while providing meaningful responses to clients. The error handling strategy varies based on the error type, processing stage, and whether recovery is possible.\n\n**Parse errors** during message processing result in FORMERR responses when the error can be detected early enough to construct a valid response header. However, severe parsing failures that prevent header extraction result in silent packet drops to avoid amplification attacks.\n\n**Resolution timeout errors** during recursive queries trigger retry logic with exponential backoff, but ultimately result in SERVFAIL responses if no authoritative answer can be obtained. The resolver must balance persistence in following referrals against response time requirements.\n\n**Cache corruption** or **zone file errors** represent more serious conditions that may require administrative intervention. These errors are logged extensively but typically result in SERVFAIL responses rather than server crashes.\n\n> **Architecture Decision: Error Response Strategy**\n> - **Context**: DNS servers must handle various error conditions while maintaining availability and preventing abuse\n> - **Options Considered**: \n>   1. Always respond with error codes\n>   2. Drop malformed packets silently\n>   3. Hybrid approach based on error severity\n> - **Decision**: Use hybrid error handling with silent drops for severe parse errors and proper error codes for recoverable failures\n> - **Rationale**: Silent drops prevent amplification attacks and resource exhaustion while proper error codes help legitimate clients diagnose issues\n> - **Consequences**: Requires careful classification of error severity and comprehensive logging for debugging\n\n## Component Interface Contracts\n\nThe interfaces between DNS server components define the contracts that enable loose coupling while ensuring correct behavior. These interfaces must be precisely specified to handle concurrent access, error propagation, and resource management across component boundaries.\n\n### Server to Message Handler Interface\n\nThe UDP server interacts with message handlers through a well-defined interface that abstracts the specific resolution logic from network concerns. This separation allows different handler implementations (authoritative-only, recursive, forwarding) to be plugged into the same server infrastructure.\n\n| Method Signature | Parameters | Returns | Description |\n|-----------------|------------|---------|-------------|\n| `ProcessQuery(ctx context.Context, query *DNSMessage) (*DNSMessage, error)` | Context for cancellation, parsed query message | Response message or error | Main entry point for query processing |\n| `ValidateQuery(query *DNSMessage) error` | Parsed query message | Error if invalid | Validates query structure and requirements |\n| `GetServerCapabilities() ServerCapabilities` | None | Server capability flags | Returns supported features (recursion, DNSSEC, etc.) |\n| `GetStatistics() HandlerStats` | None | Statistical counters | Returns query counts, error rates, response times |\n\nThe `ProcessQuery` method serves as the primary interface contract between the server and handler layers. The handler receives a fully parsed DNS message and context for timeout/cancellation control, and must return either a valid response message or an error that the server can convert to an appropriate DNS error code.\n\n**Context handling** is critical for this interface, as DNS queries have strict timeout requirements (typically 5-10 seconds maximum). The handler must respect context cancellation and avoid blocking indefinitely on network operations or lock acquisition. Context propagation continues through all downstream operations including cache lookups and recursive resolution.\n\n**Error semantics** follow a specific pattern where different error types map to DNS response codes. Network timeouts become SERVFAIL responses, parse errors become FORMERR responses, and policy violations (like recursion disabled) become appropriate refused responses.\n\n### Message Handler to Resolver Interface\n\nThe message handler coordinates between authoritative lookup, cache consultation, and recursive resolution through well-defined resolver interfaces. This abstraction allows testing with mock resolvers and supports different resolution strategies.\n\n| Method Signature | Parameters | Returns | Description |\n|-----------------|------------|---------|-------------|\n| `ResolveQuery(ctx context.Context, question Question) (*DNSMessage, error)` | Context and DNS question | Complete DNS response | Performs full resolution (cache + recursion) |\n| `LookupAuthoritative(question Question) ([]ResourceRecord, error)` | DNS question | Matching authoritative records | Queries local zone data only |\n| `LookupCache(key CacheKey) (*CacheEntry, bool)` | Cache lookup key | Cache entry and found flag | Retrieves cached records if present/valid |\n| `PerformRecursion(ctx context.Context, question Question) (*DNSMessage, error)` | Context and question | Resolved response | Executes full recursive resolution |\n\nThe resolver interface separates concerns between different types of DNS resolution. `LookupAuthoritative` handles queries for domains where the server is authoritative, consulting only local zone data. `LookupCache` provides fast access to previously resolved queries. `PerformRecursion` handles the complex iterative resolution process for cache misses.\n\n**Resolution priority** follows a specific order: authoritative data takes precedence over cached data, which takes precedence over recursive resolution. This priority ensures that authoritative servers provide definitive answers for their zones while still benefiting from caching for delegation responses.\n\n**State isolation** between resolution attempts prevents interference between concurrent queries. Each resolution maintains its own `ResolutionState` object with separate CNAME chains, server lists, and loop detection state.\n\n### Cache Manager Interface Contracts\n\nThe cache manager provides thread-safe access to cached DNS records with TTL-based expiration and memory management. The interface must support concurrent readers and writers while maintaining cache consistency and preventing memory exhaustion.\n\n| Method Signature | Parameters | Returns | Description |\n|-----------------|------------|---------|-------------|\n| `Get(key CacheKey) (*CacheEntry, bool)` | Cache key (name, type, class) | Entry and found flag | Thread-safe cache lookup |\n| `Put(key CacheKey, records []ResourceRecord, ttl uint32) error` | Key, records, TTL | Error if storage failed | Stores positive cache entry |\n| `PutNegative(key CacheKey, soaRecord ResourceRecord) error` | Key and SOA record | Error if storage failed | Stores negative (NXDOMAIN) entry |\n| `Evict(key CacheKey) bool` | Cache key | True if entry existed | Removes specific cache entry |\n| `Cleanup() int` | None | Count of expired entries | Removes expired entries, returns count |\n| `Stats() CacheStats` | None | Cache statistics | Hit rate, memory usage, entry counts |\n\nThe cache interface emphasizes **thread safety** through internal locking rather than requiring callers to coordinate access. The `CacheManager` uses read-write mutexes to allow concurrent cache lookups while serializing cache updates and cleanup operations.\n\n**TTL handling** occurs automatically within the cache manager. The `Get` method checks expiration timestamps and treats expired entries as cache misses, while background cleanup removes expired entries periodically to prevent memory leaks.\n\n**Memory management** involves both entry count limits and total memory consumption limits. The cache tracks the serialized size of stored records and implements LRU eviction when limits are approached.\n\n> **Decision: Cache Interface Design**\n> - **Context**: Cache must support concurrent access while maintaining consistency and performance\n> - **Options Considered**:\n>   1. External locking with simple map interface\n>   2. Internal locking with Get/Put methods\n>   3. Lock-free implementation with atomic operations\n> - **Decision**: Internal locking with comprehensive cache management\n> - **Rationale**: Simplifies caller code, enables sophisticated cache policies, and provides better encapsulation of cache internals\n> - **Consequences**: Slightly higher memory overhead but much simpler usage and better testability\n\n### Zone Data Manager Interface\n\nThe zone data manager provides access to authoritative DNS records loaded from zone files. The interface must support efficient lookups while handling zone reloading and configuration changes.\n\n| Method Signature | Parameters | Returns | Description |\n|-----------------|------------|---------|-------------|\n| `LoadZone(config ZoneConfig) error` | Zone configuration | Error if load failed | Loads zone file into memory |\n| `FindZone(domain string) (*ZoneData, bool)` | Domain name | Zone data and found flag | Finds authoritative zone for domain |\n| `LookupRecords(zone *ZoneData, name string, qtype uint16) ([]ResourceRecord, error)` | Zone, name, type | Matching records | Finds records in zone |\n| `ReloadZone(domain string) error` | Zone domain name | Error if reload failed | Hot-reloads zone from file |\n| `GetZoneStats(domain string) ZoneStats` | Zone domain | Zone statistics | Query counts, record counts |\n\n**Zone matching** uses longest-prefix matching to find the most specific zone that contains a queried domain. For example, `mail.example.com` would match zone `example.com` rather than zone `com` if both were configured.\n\n**Record lookup** within zones uses efficient data structures (typically hash maps keyed by domain name and record type) to minimize search time. Wildcard matching and empty non-terminal handling add complexity that must be hidden behind the interface.\n\n**Hot reloading** allows zone file updates without server restart. The implementation must handle file locking, parse error recovery, and atomic replacement of zone data to prevent partial updates during active queries.\n\n### Network Client Interface\n\nThe network client abstracts UDP DNS communication for recursive resolution, providing timeout handling, retry logic, and response correlation across multiple outstanding queries.\n\n| Method Signature | Parameters | Returns | Description |\n|-----------------|------------|---------|-------------|\n| `QueryServer(ctx context.Context, query []byte, serverIP string) ([]byte, error)` | Context, query bytes, server IP | Response bytes | Sends DNS query via UDP |\n| `QueryWithRetry(ctx context.Context, query []byte, servers []string) ([]byte, error)` | Context, query, server list | Response bytes | Tries multiple servers |\n| `SetTimeout(timeout time.Duration)` | Timeout duration | None | Configures query timeout |\n| `GetStats() NetworkStats` | None | Network statistics | Timeout rates, RTT measurements |\n\n**Connection management** involves maintaining UDP sockets for outbound queries while handling connection errors and server unreachability. The client may use a single shared socket or create dedicated sockets per query depending on performance requirements.\n\n**Timeout handling** must balance responsiveness against reliability. Short timeouts improve user experience but may abandon slow but valid responses, while long timeouts can tie up resolution threads and delay error responses.\n\n**Retry strategies** help handle temporary network issues and server overload. The client typically tries each server once before moving to the next, but may implement more sophisticated backoff algorithms for persistent failures.\n\n![System Components](./diagrams/system-components.svg)\n\n![Recursive Resolution Sequence](./diagrams/recursive-resolution-flow.svg)\n\n![Concurrent Query Processing Architecture](./diagrams/concurrent-query-handling.svg)\n\n### Data Exchange Formats\n\nThe components exchange several standardized data structures that must maintain consistency across component boundaries. These formats define the contracts for data integrity and enable component testing and validation.\n\n#### DNS Message Exchange Format\n\nAll components that handle DNS messages use the standardized `DNSMessage` structure, but different components may populate different sections based on their responsibilities.\n\n| Component | Populates Sections | Validates Sections | Purpose |\n|-----------|-------------------|-------------------|---------|\n| Message Parser | All sections from wire format | Header and basic structure | Convert wire format to internal representation |\n| Authoritative Server | Answer, Authority, Additional | Question section | Provide definitive answers for local zones |\n| Recursive Resolver | Answer section primarily | All sections for security | Resolve queries via hierarchy traversal |\n| Cache Manager | Not applicable | Answer section for storage | Store and retrieve resolved records |\n\n**Section ownership** determines which component is responsible for populating each part of DNS responses. The authoritative server owns authority section content for its zones, while recursive resolvers focus primarily on answer section population.\n\n**Validation responsibilities** are distributed across components with each component validating the data it receives and uses. Parsers validate wire format compliance, resolvers validate response security properties, and caches validate record consistency.\n\n#### Cache Entry Exchange\n\nCache entries contain additional metadata beyond basic DNS records to support TTL management, negative caching, and cache statistics.\n\n| Field Name | Type | Populated By | Used By | Purpose |\n|------------|------|--------------|---------|---------|\n| `Records` | `[]ResourceRecord` | Resolver | All components | The actual DNS records |\n| `ExpiresAt` | `time.Time` | Cache Manager | Cache Manager | Absolute expiration time |\n| `Negative` | `bool` | Resolver | Query processors | Indicates NXDOMAIN/NODATA response |\n| `SOARecord` | `*ResourceRecord` | Resolver | Response construction | SOA for negative responses |\n| `HitCount` | `uint64` | Cache Manager | Statistics | Track cache entry popularity |\n\n**Expiration semantics** use absolute timestamps rather than relative TTL values to avoid timing issues with cache entry age calculation. The cache manager converts TTL values to expiration timestamps when storing entries.\n\n**Negative cache entries** require special handling because they represent the absence of records rather than the presence of specific records. The associated SOA record provides the appropriate TTL and authority information for negative responses.\n\n### Common Pitfalls in Component Interactions\n\nSeveral categories of errors frequently occur in DNS server implementations related to component interactions and data flow management.\n\n⚠️ **Pitfall: Race Conditions in Cache Access**\n\nMultiple goroutines accessing cache entries simultaneously can lead to data races, especially during cache updates and TTL expiration. Reading cache entries while they're being modified can return partial or inconsistent data.\n\nThe cache manager must use appropriate synchronization primitives (read-write mutexes) to coordinate access between readers and writers. Cache lookups should hold read locks only for the duration of entry location and validation, not for the entire query processing.\n\n⚠️ **Pitfall: Context Cancellation Propagation**\n\nFailure to properly propagate context cancellation through component interfaces can lead to goroutine leaks and resource exhaustion. Long-running recursive queries may continue consuming resources after clients have disconnected or timed out.\n\nEvery component interface that performs I/O operations or blocking calls must accept and respect context cancellation. Network operations, cache operations, and resolution steps must check context state and abort cleanly when cancellation occurs.\n\n⚠️ **Pitfall: Error Semantic Mismatches**\n\nDifferent components may interpret the same error condition differently, leading to inappropriate responses or recovery actions. For example, a temporary network timeout might be treated as a permanent failure if error types aren't properly distinguished.\n\nComponent interfaces should define specific error types for different failure conditions (temporary vs permanent, recoverable vs fatal) and document the expected handling behavior for each error category.\n\n⚠️ **Pitfall: Memory Ownership Confusion**\n\nWhen components share references to DNS messages or resource records, unclear ownership semantics can lead to concurrent modification or premature garbage collection. Modifying shared data structures can corrupt other components' state.\n\nComponent interfaces should clearly specify whether returned data structures are read-only views, private copies, or shared references with specific modification constraints. Defensive copying may be necessary when multiple components need to modify the same base data.\n\n### Implementation Guidance\n\nThe component interactions and data flow implementation requires careful attention to concurrency, error handling, and resource management. The following guidance provides practical approaches for implementing these critical aspects.\n\n#### Technology Recommendations\n\n| Aspect | Simple Option | Advanced Option |\n|--------|---------------|-----------------|\n| Concurrency | Basic goroutines with mutexes | Worker pools with channels |\n| Error Handling | Direct error returns | Structured error types with context |\n| Metrics | Simple counters | Prometheus metrics |\n| Logging | Standard log package | Structured logging (logrus/zap) |\n| Configuration | YAML files | Dynamic configuration with watchers |\n\n#### Recommended File Structure\n\n```\ninternal/\n  server/\n    server.go              ← UDP server and main coordination\n    handler.go             ← MessageHandler implementation\n    handler_test.go\n  parser/\n    parser.go              ← DNS message parsing\n    compression.go         ← Name compression handling\n  resolver/\n    recursive.go           ← RecursiveResolver implementation\n    authoritative.go       ← AuthoritativeServer implementation\n    client.go              ← NetworkClient for upstream queries\n  cache/\n    manager.go             ← CacheManager implementation\n    entry.go               ← Cache entry management\n    cleanup.go             ← Background cleanup routines\n  zones/\n    loader.go              ← Zone file parsing and loading\n    data.go                ← Zone data structures and lookup\n```\n\n#### Core Data Flow Coordination\n\nThe main server coordination logic manages the interaction between all components while handling concurrency and error conditions:\n\n```go\n// Server coordinates all DNS server components and manages query processing\ntype Server struct {\n    addr        string\n    conn        net.PacketConn\n    parser      *parser.MessageParser\n    handler     MessageHandler\n    shutdown    chan struct{}\n    wg          sync.WaitGroup\n}\n\n// handleQuery processes a single DNS query through the component pipeline\nfunc (s *Server) handleQuery(queryData []byte, clientAddr net.Addr) {\n    // TODO 1: Parse the incoming DNS message using MessageParser\n    // TODO 2: Validate the parsed message structure and question section\n    // TODO 3: Create context with timeout for query processing\n    // TODO 4: Call MessageHandler.ProcessQuery with parsed message\n    // TODO 5: Serialize the response message back to wire format\n    // TODO 6: Send response packet to client address\n    // TODO 7: Handle and log any errors at each step\n    // Hint: Use defer for cleanup and always respond to avoid client timeouts\n}\n```\n\n#### Component Interface Implementation\n\nThe `MessageHandler` interface coordinates between authoritative lookup, caching, and recursive resolution:\n\n```go\n// MessageHandler processes DNS queries using appropriate resolution strategy\ntype MessageHandler struct {\n    zones      *zones.Manager\n    cache      *cache.Manager\n    resolver   *resolver.RecursiveResolver\n    authoritative *resolver.AuthoritativeServer\n    config     *Config\n}\n\n// ProcessQuery implements the main query processing workflow\nfunc (h *MessageHandler) ProcessQuery(ctx context.Context, query *DNSMessage) (*DNSMessage, error) {\n    // TODO 1: Extract question from query message\n    // TODO 2: Check if we have authoritative data for the question domain\n    // TODO 3: If authoritative, use AuthoritativeServer.ProcessQuery\n    // TODO 4: If not authoritative, check cache with CacheManager.Get\n    // TODO 5: If cache miss, use RecursiveResolver.ResolveQuery\n    // TODO 6: Store successful recursive results in cache\n    // TODO 7: Construct appropriate response message with answer/authority sections\n    // Hint: Always set response header flags correctly (QR, RA, AA)\n}\n```\n\n#### Cache Integration Pattern\n\nCache integration requires careful handling of concurrent access and TTL management:\n\n```go\n// CacheManager provides thread-safe DNS record caching with TTL expiration\ntype CacheManager struct {\n    mu          sync.RWMutex\n    cache       map[CacheKey]*CacheEntry\n    maxEntries  int\n    stats       CacheStats\n    cleanup     *time.Ticker\n}\n\n// Get retrieves a cache entry if present and not expired\nfunc (c *CacheManager) Get(key CacheKey) (*CacheEntry, bool) {\n    // TODO 1: Acquire read lock for thread-safe access\n    // TODO 2: Look up cache entry in internal map\n    // TODO 3: Check if entry exists and is not expired\n    // TODO 4: Update hit statistics atomically\n    // TODO 5: Return deep copy of entry to prevent modification\n    // Hint: Use time.Now().After(entry.ExpiresAt) to check expiration\n}\n\n// Put stores records in cache with TTL-based expiration\nfunc (c *CacheManager) Put(key CacheKey, records []ResourceRecord, ttl uint32) error {\n    // TODO 1: Acquire write lock for thread-safe modification\n    // TODO 2: Create CacheEntry with expiration timestamp\n    // TODO 3: Check if adding entry would exceed size limits\n    // TODO 4: Evict LRU entries if necessary to make space\n    // TODO 5: Store entry in cache map and update statistics\n    // Hint: Use time.Now().Add(time.Duration(ttl) * time.Second) for expiration\n}\n```\n\n#### Error Handling Patterns\n\nDNS-specific error handling requires mapping internal errors to appropriate DNS response codes:\n\n```go\n// DNSError represents DNS-specific errors with response codes\ntype DNSError struct {\n    Code    uint8\n    Message string\n    Cause   error\n}\n\n// MapErrorToResponseCode converts internal errors to DNS response codes\nfunc MapErrorToResponseCode(err error) uint8 {\n    // TODO 1: Handle context timeout/cancellation as SERVFAIL\n    // TODO 2: Handle parse errors as FORMERR\n    // TODO 3: Handle resolution failures as SERVFAIL\n    // TODO 4: Handle policy violations as REFUSED\n    // TODO 5: Handle unknown domains as NXDOMAIN (from authoritative only)\n    // Hint: Use type assertions to check for specific error types\n}\n```\n\n#### Milestone Checkpoint\n\nAfter implementing component interactions:\n\n1. **Basic Flow Test**: Run `go test ./internal/server/...` - should show successful query parsing and response construction\n2. **Integration Test**: Start server with `go run cmd/server/main.go`, query with `dig @localhost -p 8053 example.com` - should receive valid response\n3. **Concurrency Test**: Run multiple concurrent dig commands - should handle without blocking or errors\n4. **Cache Verification**: Enable debug logging and verify cache hits/misses appear in logs for repeated queries\n5. **Error Handling**: Send malformed DNS packets and verify appropriate error responses or silent drops\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Server hangs on startup | UDP bind failure | Check `netstat -ulnp \\| grep :53` | Use different port or check permissions |\n| Responses always SERVFAIL | Component interface errors | Add logging to each interface call | Fix error handling in component chain |\n| Cache never hits | Key generation issues | Log cache keys during Get/Put | Ensure consistent key generation |\n| Memory usage grows unbounded | Cache not evicting entries | Check cleanup goroutine and TTL handling | Implement proper cache size limits |\n| Concurrent queries interfere | Data race in shared state | Run with `go run -race` | Add proper synchronization primitives |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones (1-4) - Error handling is critical throughout DNS message parsing, authoritative responses, recursive resolution, and caching operations\n\nBuilding a robust DNS server requires comprehensive error handling that gracefully manages the myriad of failure modes inherent in distributed network systems. DNS operates in an environment where partial failures, malformed data, and network timeouts are not exceptional cases but routine occurrences that must be handled transparently. The challenge lies in distinguishing between recoverable errors that should trigger retry logic and fatal errors that require immediate failure responses, while maintaining the strict timing requirements that DNS clients expect.\n\n### Mental Model: Error Handling as Immune System Response\n\nThink of DNS error handling like a biological immune system responding to various threats. Just as your immune system has different responses for different types of infections—quarantining viruses, attacking bacteria, or triggering inflammation—a DNS server must have tailored responses for different error categories. Parse errors are like toxins that must be immediately rejected, network failures are like temporary blockages that require alternate pathways, and malformed queries are like foreign substances that need careful classification before response. The key insight is that not all errors are created equal, and the response must be proportional and appropriate to maintain system health while continuing to serve legitimate requests.\n\nThe DNS protocol itself provides structured error signaling through response codes (`RCODE` values), but the server must also handle the vast space of errors that occur before a proper DNS response can be constructed. This dual-layer error handling—internal error management and protocol-level error signaling—requires careful coordination to ensure that clients receive meaningful feedback while protecting the server from cascading failures.\n\n### Error Categories and Recovery\n\nDNS server error handling can be systematically organized into distinct categories, each requiring different detection mechanisms, recovery strategies, and client communication approaches. Understanding these categories allows developers to implement appropriate error boundaries and recovery logic that maintains service availability while providing meaningful feedback to clients.\n\n#### Parse and Protocol Errors\n\nParse errors represent the first line of defense against malformed or malicious DNS messages. These errors occur during the binary-to-structure conversion process and must be detected before any business logic processes potentially invalid data. The challenge with parse errors is that they often leave the parser in an undefined state, making error recovery particularly critical for preventing memory corruption or infinite loops.\n\n| Error Type | Detection Method | Recovery Strategy | DNS Response |\n|------------|------------------|-------------------|---------------|\n| Insufficient Buffer | `len(data) < expectedSize` check | Reject entire message, log source | `RCODE_FORMERR` |\n| Invalid Compression Pointer | Pointer target validation during `parseName` | Skip malformed name, continue parsing | `RCODE_FORMERR` |\n| Compression Loop | Loop detection in `parseState.visited` | Break loop, return partial name | `RCODE_FORMERR` |\n| Unknown Record Type | Type field validation in `parseResourceRecord` | Skip unknown RR, continue parsing | Continue processing |\n| Truncated Header | Header size validation | Reject message immediately | No response |\n| Invalid Section Count | Count vs actual records mismatch | Process available records, ignore excess | Continue processing |\n\nThe most critical aspect of parse error handling is maintaining parser state integrity. When a parse error occurs mid-message, the parser must either complete processing with degraded results or cleanly abort without corrupting shared state. This is particularly important for the `parseState` structure that tracks compression pointer locations and parsing offsets.\n\n> **Key Insight**: Parse errors should never cause server crashes or memory corruption. The DNS protocol's robustness depends on servers gracefully rejecting malformed messages while continuing to serve legitimate requests.\n\n**Decision: Parse Error Isolation Strategy**\n- **Context**: Parse errors can occur at any point during message processing, potentially leaving the parser in an inconsistent state\n- **Options Considered**: \n  1. Fail fast on first parse error\n  2. Skip malformed sections and continue processing\n  3. Attempt error correction and recovery\n- **Decision**: Fail fast for structural errors, skip individual malformed records\n- **Rationale**: DNS clients expect predictable responses, and partial parsing can lead to security vulnerabilities\n- **Consequences**: Higher reliability at the cost of reduced fault tolerance for slightly malformed messages\n\n#### Network and Transport Errors\n\nNetwork errors encompass the broad category of failures that occur during DNS message transmission and reception. Unlike parse errors, network errors often represent transient conditions that may resolve with retry logic or alternative approaches. The challenge is distinguishing between temporary network congestion and persistent connectivity failures.\n\n| Error Type | Detection Symptoms | Recovery Strategy | Timeout Strategy |\n|------------|-------------------|-------------------|------------------|\n| UDP Socket Timeout | `net.PacketConn` read timeout | Retry with exponential backoff | Start at 1s, max 8s |\n| Connection Refused | `ECONNREFUSED` on socket operations | Try next server in list | Immediate failover |\n| Network Unreachable | `EHOSTUNREACH` or `ENETUNREACH` | Mark server as down, use alternate | 30s cooldown period |\n| DNS Response Timeout | No response within query timeout | Retry different server | 2s initial, double up to 8s |\n| Server Overload | `RCODE_SERVFAIL` responses | Reduce query rate, try alternate | Exponential backoff |\n| Malformed Response | Parse failure on received data | Treat as server failure | Try next available server |\n\nNetwork error recovery requires careful balance between responsiveness and resource consumption. Aggressive retry logic can amplify network congestion during outages, while conservative retry logic can unnecessarily degrade user experience during transient failures. The key is implementing adaptive timeouts that adjust based on observed network conditions.\n\nThe recursive resolver component bears primary responsibility for network error handling, as it must manage connections to multiple upstream servers while maintaining query performance expectations. When a network error occurs during recursive resolution, the resolver must decide whether to retry the same server, try an alternate server, or return a failure response to the client.\n\n> **Critical Design Principle**: Network errors should trigger alternate resolution paths before failing queries. DNS's distributed architecture provides multiple resolution paths that should be exhausted before returning `RCODE_SERVFAIL`.\n\n#### Resolution and Logic Errors\n\nResolution errors occur during the business logic phases of DNS processing—when the server successfully parses a query but encounters problems during authoritative lookup, recursive resolution, or cache management. These errors often indicate configuration problems, resource exhaustion, or logical inconsistencies in DNS data.\n\n| Error Category | Specific Errors | Detection Method | Recovery Strategy |\n|----------------|----------------|------------------|-------------------|\n| Zone Configuration | Missing SOA, invalid delegations | Zone validation at startup | Return `RCODE_SERVFAIL`, log error |\n| Recursive Loops | CNAME chains, NS referral cycles | Loop detection counters | Break loop, return available data |\n| Cache Corruption | Expired entries, invalid data | TTL validation, data integrity checks | Evict corrupted entries, query upstream |\n| Resource Exhaustion | Memory limits, connection pools | Resource monitoring, threshold checks | Shed load, return `RCODE_SERVFAIL` |\n| Authority Conflicts | Multiple zones claiming authority | Zone overlap detection | Prefer most specific zone match |\n| Upstream Failures | All recursive servers unavailable | Health monitoring, retry logic | Return cached data if available |\n\nResolution errors require sophisticated handling because they often indicate systemic problems rather than transient failures. For example, a CNAME loop in zone data represents a configuration error that won't resolve with retry logic, while upstream server failures may require falling back to cached data or alternative resolution strategies.\n\nThe challenge with resolution errors is maintaining consistency across the distributed DNS infrastructure. When an authoritative server detects invalid zone data, it must decide whether to refuse queries entirely or serve partial data. Similarly, recursive resolvers must balance freshness requirements against availability when upstream failures prevent cache refresh.\n\n**Decision: Resolution Error Handling Strategy**\n- **Context**: Resolution errors can indicate either transient network issues or persistent configuration problems\n- **Options Considered**:\n  1. Always fail fast on resolution errors\n  2. Implement aggressive fallback to cached data\n  3. Differentiate between error types with targeted recovery\n- **Decision**: Differentiate error types with targeted recovery strategies per error category\n- **Rationale**: Different resolution errors require different handling—loops should be broken, network failures should trigger retries, and configuration errors should be logged for operator attention\n- **Consequences**: More complex error handling logic but better service availability and easier troubleshooting\n\n### DNS Protocol Edge Cases\n\nBeyond standard error conditions, DNS servers must handle numerous protocol edge cases that arise from the evolution of DNS over decades, interoperability requirements across diverse implementations, and the security considerations introduced by malicious actors. These edge cases often involve technically valid but unusual message patterns that can expose vulnerabilities or trigger unexpected behavior in naive implementations.\n\n#### Malformed Query Handling\n\nMalformed queries represent a particularly challenging class of edge cases because they often exploit ambiguities in the DNS specification or test boundary conditions in parser implementations. A robust DNS server must handle these queries without compromising security or stability while providing meaningful error responses where appropriate.\n\nThe most common malformed query patterns include oversized messages that exceed the 512-byte UDP limit, queries with invalid question counts, malformed domain names that violate length restrictions, and queries that attempt to exploit compression pointer vulnerabilities. Each pattern requires specific detection and handling logic.\n\n| Malformed Query Type | Detection Criteria | Response Strategy | Security Consideration |\n|---------------------|-------------------|-------------------|------------------------|\n| Oversized UDP Query | `len(message) > DNS_UDP_MAX_SIZE` | Return truncated response with TC bit | Potential amplification attack |\n| Invalid Question Count | `header.QuestionCount != 1` for standard queries | Return `RCODE_FORMERR` | Protocol violation |\n| Label Length Violation | Any label > 63 bytes or name > 255 bytes | Return `RCODE_FORMERR` | Buffer overflow attempt |\n| Invalid Character Set | Non-ASCII characters in domain names | Return `RCODE_FORMERR` unless IDNA encoded | Protocol compliance |\n| Compression Bomb | Excessive pointer indirection depth | Limit recursion depth, return `RCODE_FORMERR` | DoS attack vector |\n| Reserved Bit Manipulation | Non-zero reserved header bits | Ignore reserved bits, process normally | Future compatibility |\n\nThe key principle for malformed query handling is failing securely while maintaining protocol compliance. When a query cannot be processed safely, the server should return an appropriate error response rather than silently dropping the query or attempting unsafe processing that could compromise security.\n\nCompression-related attacks deserve special attention because they can exploit the recursive nature of pointer following to consume excessive server resources. A malicious query might construct compression pointers that create deep recursive chains or circular references that could cause stack overflow or infinite loops in naive implementations.\n\n> **Security Principle**: Never trust client-provided data structures. All parsing operations must include bounds checking, recursion limits, and loop detection to prevent exploitation of parser vulnerabilities.\n\n#### Oversized Response Management\n\nDNS responses can legitimately exceed the 512-byte UDP limit when they contain numerous resource records or long text records. The protocol handles this through the truncation mechanism, where the server sets the TC (truncation) bit and returns partial data, expecting the client to retry over TCP for the complete response. However, implementing this correctly requires careful consideration of which records to include in the truncated response.\n\nThe truncation algorithm must prioritize response sections to maximize utility while respecting size constraints. Generally, the answer section takes highest priority, followed by authority section records that enable the client to find authoritative servers, and finally additional section records that provide convenience data like glue records.\n\n| Response Section | Truncation Priority | Inclusion Strategy | Size Estimation |\n|------------------|--------------------|--------------------|-----------------|\n| Header | Always included | Complete 12-byte header | Fixed 12 bytes |\n| Question Section | Always included | Copy original question | Variable, usually small |\n| Answer Section | Highest priority | Include all if possible, truncate if necessary | Sum of RR sizes |\n| Authority Section | Medium priority | Include NS records for referrals | Critical for delegation |\n| Additional Section | Lowest priority | Include glue records for delegation | Optional optimization |\n\nThe implementation challenge lies in accurately predicting serialized message size before committing to specific records. Since DNS name compression can significantly reduce message size, but compression effectiveness depends on name overlap patterns, the server must either implement conservative size estimation or perform trial serialization to determine optimal record selection.\n\nWhen truncation is necessary, the server must decide whether to include partial record sets or complete record sets with some sections omitted. The protocol strongly favors complete record sets to avoid confusing clients that might interpret partial data as authoritative negative responses.\n\n**Decision: Truncation Strategy for Oversized Responses**\n- **Context**: UDP responses exceeding 512 bytes must be truncated with TC bit set\n- **Options Considered**:\n  1. Simple truncation at byte boundary regardless of record boundaries\n  2. Intelligent truncation preserving complete resource records\n  3. Dynamic TCP fallback for all large responses\n- **Decision**: Intelligent truncation preserving complete resource records with section priority ordering\n- **Rationale**: Partial resource records confuse clients and violate protocol semantics; complete records in priority order maximize client utility\n- **Consequences**: More complex truncation logic but better client compatibility and protocol compliance\n\n#### Protocol Violation Recovery\n\nReal-world DNS implementations often deviate from strict RFC compliance due to implementation bugs, configuration errors, or deliberate protocol extensions. A robust DNS server must handle these protocol violations gracefully while maintaining its own compliance standards. This creates a tension between strict protocol adherence and operational compatibility.\n\nCommon protocol violations include responses with mismatched question sections, resource records in unexpected sections, invalid TTL values, and responses that don't properly implement compression. Each violation type requires careful analysis to determine whether it represents a benign compatibility issue or a potential security threat.\n\nThe challenge is implementing liberal parsing policies that accept minor deviations while rejecting dangerous violations. For example, a response that omits the question section might be acceptable if the answer section clearly identifies the queried name, but a response with compressed pointers that reference invalid offsets should be rejected entirely.\n\n| Violation Type | Severity Level | Handling Strategy | Compatibility Impact |\n|----------------|----------------|-------------------|---------------------|\n| Missing Question Echo | Minor | Accept if answer section is clear | High compatibility gain |\n| Invalid Compression | Critical | Reject response, try next server | Security protection |\n| Wrong Section Placement | Minor | Process records regardless of section | Operational flexibility |\n| Invalid TTL Values | Minor | Clamp to reasonable ranges | Cache consistency |\n| Malformed RDATA | Moderate | Skip record, continue processing | Partial data preservation |\n| Response/Query Mismatch | Critical | Reject response, potential cache poisoning | Security protection |\n\nThe recursive resolver must be particularly careful about protocol violations in upstream responses, as accepting invalid data could propagate errors to clients or compromise cache integrity. The principle is to be liberal in parsing but conservative in trusting, validating all critical security properties while accommodating minor formatting deviations.\n\n> **Operational Insight**: Real-world DNS infrastructure contains numerous implementations with minor protocol violations. Strict compliance can reduce interoperability, but security-critical validations must never be relaxed.\n\n### Implementation Guidance\n\nThe implementation of comprehensive error handling in a DNS server requires careful attention to error boundaries, recovery strategies, and security validation. The following guidance provides concrete approaches for implementing robust error handling that maintains service availability while protecting against malicious input.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Logging | Standard log package with structured logging | Structured logging with log levels (logrus/zap) |\n| Metrics Collection | Simple counters and timers | Prometheus metrics with alerting |\n| Circuit Breaking | Basic retry with exponential backoff | Circuit breaker pattern (hystrix-go) |\n| Resource Monitoring | Manual memory/connection tracking | Runtime metrics with automatic limits |\n| Configuration Validation | Startup validation with error exit | Hot reload with validation and rollback |\n\n#### Recommended Error Handling Structure\n\n```\ninternal/\n  errors/\n    dns_errors.go           ← DNS-specific error types and codes\n    error_handler.go        ← Central error processing and logging\n    recovery.go             ← Error recovery strategies\n  parser/\n    parse_errors.go         ← Parse-specific error handling\n    validation.go           ← Message validation and sanitization\n  resolver/\n    resolution_errors.go    ← Resolution failure handling\n    retry_logic.go          ← Network retry and backoff logic\n  server/\n    error_responses.go      ← DNS error response construction\n    request_validation.go   ← Request validation and filtering\n```\n\n#### Infrastructure Starter Code\n\n**Complete DNS Error Types (dns_errors.go):**\n```go\npackage errors\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n// DNSError represents DNS-specific errors with response codes\ntype DNSError struct {\n    Code        uint8     // DNS RCODE value\n    Message     string    // Human-readable error description\n    Underlying  error     // Wrapped underlying error\n    Timestamp   time.Time // When error occurred\n    Source      string    // Component that generated error\n}\n\nfunc (e *DNSError) Error() string {\n    return fmt.Sprintf(\"DNS %s error: %s\", e.Source, e.Message)\n}\n\nfunc (e *DNSError) Unwrap() error {\n    return e.Underlying\n}\n\n// Common DNS error constructors\nfunc NewFormatError(msg string, err error) *DNSError {\n    return &DNSError{\n        Code:       1, // RCODE_FORMERR\n        Message:    msg,\n        Underlying: err,\n        Timestamp:  time.Now(),\n        Source:     \"parser\",\n    }\n}\n\nfunc NewServerFailure(msg string, err error) *DNSError {\n    return &DNSError{\n        Code:       2, // RCODE_SERVFAIL\n        Message:    msg,\n        Underlying: err,\n        Timestamp:  time.Now(),\n        Source:     \"resolver\",\n    }\n}\n\nfunc NewNameError(msg string) *DNSError {\n    return &DNSError{\n        Code:       3, // RCODE_NXDOMAIN\n        Message:    msg,\n        Underlying: nil,\n        Timestamp:  time.Now(),\n        Source:     \"authoritative\",\n    }\n}\n\n// RetryableError indicates errors that should trigger retry logic\ntype RetryableError struct {\n    Underlying error\n    RetryAfter time.Duration\n    Attempts   int\n}\n\nfunc (e *RetryableError) Error() string {\n    return fmt.Sprintf(\"retryable error (attempt %d): %v\", e.Attempts, e.Underlying)\n}\n\nfunc (e *RetryableError) Unwrap() error {\n    return e.Underlying\n}\n\n// NetworkError represents network-related failures\ntype NetworkError struct {\n    ServerAddr string\n    Operation  string\n    Underlying error\n    Timeout    bool\n}\n\nfunc (e *NetworkError) Error() string {\n    status := \"failed\"\n    if e.Timeout {\n        status = \"timed out\"\n    }\n    return fmt.Sprintf(\"network %s to %s %s: %v\", e.Operation, e.ServerAddr, status, e.Underlying)\n}\n```\n\n**Complete Error Response Builder (error_responses.go):**\n```go\npackage server\n\nimport (\n    \"log\"\n    \"time\"\n    \n    \"dns-server/internal/errors\"\n)\n\n// ErrorResponseBuilder constructs DNS error responses\ntype ErrorResponseBuilder struct {\n    logger *log.Logger\n}\n\nfunc NewErrorResponseBuilder(logger *log.Logger) *ErrorResponseBuilder {\n    return &ErrorResponseBuilder{\n        logger: logger,\n    }\n}\n\n// BuildErrorResponse creates a DNS response for various error conditions\nfunc (e *ErrorResponseBuilder) BuildErrorResponse(query *DNSMessage, err error) *DNSMessage {\n    response := &DNSMessage{\n        Header: Header{\n            ID:              query.Header.ID,\n            QueryResponse:   true,\n            Opcode:          query.Header.Opcode,\n            Authoritative:   false,\n            Truncated:       false,\n            RecursionDesired: query.Header.RecursionDesired,\n            RecursionAvail:  true,\n            ResponseCode:    e.determineResponseCode(err),\n            QuestionCount:   query.Header.QuestionCount,\n            AnswerCount:     0,\n            AuthorityCount:  0,\n            AdditionalCount: 0,\n        },\n        Questions:  query.Questions, // Echo original questions\n        Answers:    nil,\n        Authority:  nil,\n        Additional: nil,\n    }\n    \n    // Log error for monitoring and debugging\n    e.logError(query, err)\n    \n    return response\n}\n\nfunc (e *ErrorResponseBuilder) determineResponseCode(err error) uint8 {\n    switch dnsErr := err.(type) {\n    case *errors.DNSError:\n        return dnsErr.Code\n    case *errors.NetworkError:\n        return 2 // RCODE_SERVFAIL\n    case *errors.RetryableError:\n        return 2 // RCODE_SERVFAIL\n    default:\n        return 2 // RCODE_SERVFAIL for unknown errors\n    }\n}\n\nfunc (e *ErrorResponseBuilder) logError(query *DNSMessage, err error) {\n    queryName := \"unknown\"\n    if len(query.Questions) > 0 {\n        queryName = query.Questions[0].Name\n    }\n    \n    e.logger.Printf(\"DNS Error - Query: %s, ID: %d, Error: %v\", \n        queryName, query.Header.ID, err)\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Parse Error Handler (parse_errors.go):**\n```go\npackage parser\n\n// ValidateMessage performs comprehensive DNS message validation\nfunc ValidateMessage(msg *DNSMessage) error {\n    // TODO 1: Validate header fields are within acceptable ranges\n    // - Check that Opcode is standard query (0) or supported value\n    // - Verify section counts don't exceed reasonable limits\n    // - Ensure reserved bits are zero for strict compliance\n    \n    // TODO 2: Validate question section consistency\n    // - Verify QuestionCount matches actual Questions slice length\n    // - Check that all question names are valid DNS labels\n    // - Validate QTYPE and QCLASS values are known or acceptable\n    \n    // TODO 3: Validate resource record sections\n    // - Check that record counts match slice lengths\n    // - Verify all names in records are properly formatted\n    // - Validate TTL values are reasonable (not negative when cast)\n    \n    // TODO 4: Validate message size constraints\n    // - Ensure total message size would not exceed UDP limits\n    // - Check that name compression is used efficiently\n    // - Verify no resource records have oversized RDATA\n    \n    // TODO 5: Security validation checks\n    // - Ensure no compression loops exist in any names\n    // - Validate that all compression pointers reference valid offsets\n    // - Check for potential buffer overflow conditions\n    \n    return nil\n}\n\n// RecoverFromParseError attempts to recover parsing after encountering an error\nfunc RecoverFromParseError(state *parseState, err error) error {\n    // TODO 1: Classify the parse error type and severity\n    // - Determine if error is recoverable or should abort parsing\n    // - Check if error indicates malicious input that should be rejected\n    // - Evaluate whether partial parsing results are safe to use\n    \n    // TODO 2: Reset parser state to known good position\n    // - Clear any corrupted state from failed parsing attempt\n    // - Reset compression pointer tracking to prevent loops\n    // - Advance parsing position past corrupted data if possible\n    \n    // TODO 3: Implement recovery strategies based on error type\n    // - For truncated data: return partial results with appropriate flags\n    // - For compression errors: skip problematic name and continue\n    // - For section errors: process available sections, mark others empty\n    \n    // TODO 4: Log recovery action for monitoring and debugging\n    // - Record what recovery action was taken and why\n    // - Include enough context for operators to diagnose problems\n    // - Track recovery success/failure rates for monitoring\n    \n    return nil\n}\n```\n\n**Network Error Handler (retry_logic.go):**\n```go\npackage resolver\n\nimport (\n    \"context\"\n    \"time\"\n)\n\n// RetryConfig controls retry behavior for network operations\ntype RetryConfig struct {\n    MaxAttempts    int\n    InitialDelay   time.Duration\n    MaxDelay       time.Duration\n    BackoffFactor  float64\n    RetryableErrors map[string]bool\n}\n\n// NetworkRetryHandler manages retry logic for DNS network operations\ntype NetworkRetryHandler struct {\n    config RetryConfig\n}\n\nfunc NewNetworkRetryHandler(config RetryConfig) *NetworkRetryHandler {\n    return &NetworkRetryHandler{config: config}\n}\n\n// ExecuteWithRetry performs DNS network operation with intelligent retry logic\nfunc (r *NetworkRetryHandler) ExecuteWithRetry(\n    ctx context.Context,\n    operation func() (*DNSMessage, error),\n) (*DNSMessage, error) {\n    // TODO 1: Initialize retry state and timing\n    // - Set up attempt counter starting from 1\n    // - Calculate initial delay based on config\n    // - Prepare context timeout monitoring\n    \n    // TODO 2: Execute operation with retry loop\n    // - Call operation function and capture result/error\n    // - Check if error is retryable using config.RetryableErrors map\n    // - If non-retryable, return error immediately without retry\n    \n    // TODO 3: Implement exponential backoff delay\n    // - Calculate next delay = current delay * BackoffFactor\n    // - Cap delay at config.MaxDelay to prevent excessive waits\n    // - Use time.Sleep or context-aware waiting\n    \n    // TODO 4: Check retry limits and context cancellation\n    // - Stop retrying if MaxAttempts reached\n    // - Check ctx.Done() to respect client timeouts\n    // - Log retry attempts for debugging and monitoring\n    \n    // TODO 5: Handle final failure after all retries exhausted\n    // - Wrap error with retry context (attempts, total time)\n    // - Return most informative error from retry attempts\n    // - Update metrics for retry success/failure rates\n    \n    return nil, nil\n}\n\n// IsRetryableError determines if an error should trigger retry logic\nfunc (r *NetworkRetryHandler) IsRetryableError(err error) bool {\n    // TODO 1: Check for network timeout errors\n    // - Look for context.DeadlineExceeded or net timeout errors\n    // - These usually indicate temporary network congestion\n    \n    // TODO 2: Check for connection refused/unreachable errors  \n    // - ECONNREFUSED might indicate server restart\n    // - EHOSTUNREACH might be temporary routing issue\n    \n    // TODO 3: Check for DNS protocol errors that might be temporary\n    // - RCODE_SERVFAIL could indicate temporary server overload\n    // - Parse errors might indicate network corruption\n    \n    // TODO 4: Avoid retrying on permanent failures\n    // - RCODE_NXDOMAIN is authoritative negative response\n    // - RCODE_REFUSED indicates policy rejection\n    // - Authentication failures should not be retried\n    \n    return false\n}\n```\n\n#### Milestone Checkpoints\n\n**After implementing parse error handling:**\n```bash\n# Test malformed message handling\ngo test -v ./internal/parser/ -run TestMalformedMessages\n\n# Expected: All malformed message tests pass without panics\n# Verify: Error responses have appropriate RCODE values\n# Check: No memory leaks or goroutine leaks during error conditions\n```\n\n**After implementing network error handling:**\n```bash\n# Test network failure scenarios\ngo test -v ./internal/resolver/ -run TestNetworkErrors\n\n# Expected: Retry logic triggers on appropriate errors\n# Verify: Exponential backoff timing is correct\n# Check: Context cancellation stops retries promptly\n```\n\n**After implementing protocol edge case handling:**\n```bash\n# Test with real-world malformed queries\ndig @localhost -p 8053 malformed-compression-test.example.com\n\n# Expected: Server responds with FORMERR without crashing\n# Verify: Logs show specific error classification\n# Check: Server continues processing subsequent queries normally\n```\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|-----------------|-----|\n| Server crashes on malformed queries | Missing bounds checking in parser | Enable panic recovery, examine stack trace | Add buffer length validation before all reads |\n| Infinite loop during name parsing | Compression pointer cycle | Check parse state logs, look for repeated offsets | Implement visited offset tracking in parseState |\n| Memory usage grows continuously | Parse errors not cleaning up resources | Monitor heap growth, check goroutine count | Ensure all parse failures call cleanup functions |\n| Network timeouts not retrying | Error classification incorrect | Log error types, check IsRetryableError logic | Update retryable error detection for specific error types |\n| Responses have wrong error codes | Error mapping incomplete | Compare expected vs actual RCODE values | Review error type to RCODE mapping in BuildErrorResponse |\n| Cache corruption after parse errors | Partial data stored despite errors | Examine cache contents after error conditions | Validate data completely before cache storage |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones (1-4) - Testing strategies are essential for verifying correct behavior at each stage of DNS server implementation\n\n### Mental Model: Testing as Safety Nets\n\nThink of DNS server testing like building safety nets for acrobats performing increasingly complex routines. Each unit test is like a small safety net positioned under specific moves—if the parser fails to handle name compression correctly, the test catches that specific failure immediately. Integration tests are like larger nets that catch interactions between components—ensuring the resolver and cache work together properly. Milestone checkpoints are like full dress rehearsals where the entire performance is evaluated before moving to more challenging routines.\n\nJust as acrobats practice individual moves before attempting complex sequences, DNS server development requires testing individual components (parsers, resolvers, cache) before integrating them into a complete system. The safety nets must be positioned at every level—from validating single function behavior to ensuring the entire query processing pipeline works correctly under various network conditions.\n\nDNS servers operate in an inherently unreliable environment where network failures, malformed packets, and timing issues are common. Without comprehensive testing at each level, subtle bugs can cascade through the system, causing failures that are difficult to diagnose in production. The testing strategy must account for both the deterministic aspects (message parsing, zone data lookup) and the non-deterministic challenges (network timeouts, concurrent queries, cache eviction timing).\n\n### Unit Testing Approach\n\nThe DNS server's modular architecture enables focused unit testing where each component can be tested in isolation before integration. This approach builds confidence incrementally—ensuring foundational components like message parsing work correctly before testing higher-level functionality like recursive resolution that depends on those foundations.\n\n#### Message Parsing Test Strategy\n\nDNS message parsing forms the foundation of all DNS operations, making it critical to test exhaustively. The binary nature of DNS messages means that small errors in byte manipulation can cause complete parsing failures or subtle data corruption that surfaces much later in the processing pipeline.\n\n**Message Parsing Test Categories:**\n\n| Test Category | Focus Area | Test Count | Critical Edge Cases |\n|---------------|------------|------------|-------------------|\n| Header Parsing | 12-byte header extraction | 15+ tests | Bit flag combinations, invalid opcodes |\n| Name Parsing | Domain name extraction with compression | 25+ tests | Compression loops, malformed pointers |\n| Question Parsing | Query section extraction | 10+ tests | Invalid record types, truncated data |\n| Resource Record Parsing | Answer/Authority/Additional sections | 30+ tests | All record types, invalid RDATA |\n| Message Construction | Wire format serialization | 20+ tests | Maximum message size, compression efficiency |\n| Validation Logic | Protocol compliance checking | 15+ tests | Circular dependencies, out-of-bailiwick data |\n\nThe message parsing tests must cover both valid protocol usage and malicious or malformed inputs. Real-world DNS traffic includes packets from buggy implementations, network corruption, and potential security attacks. Each test should verify not just that parsing succeeds for valid input, but that it fails gracefully for invalid input without crashing or corrupting internal state.\n\n**Name Compression Testing Matrix:**\n\n| Compression Scenario | Test Validation | Potential Failure Mode |\n|---------------------|----------------|----------------------|\n| No compression | Direct label parsing | Basic functionality |\n| Simple compression | Single pointer reference | Pointer calculation errors |\n| Nested compression | Pointers to compressed names | Chain resolution bugs |\n| Circular references | Loop detection triggers | Infinite loop crashes |\n| Invalid pointers | Out-of-bounds references | Buffer overflow vulnerabilities |\n| Maximum depth | Deep compression chains | Stack overflow in recursion |\n\n> **Key Testing Insight:** DNS name compression is where most parsing bugs occur because it requires maintaining state across multiple parsing operations while validating pointer references don't create infinite loops.\n\n#### Authoritative Server Test Strategy\n\nThe authoritative server component requires testing both the zone data management and the query matching logic. Unlike message parsing which deals with binary protocols, authoritative server testing focuses on business logic correctness and data integrity.\n\n**Zone Data Test Categories:**\n\n| Test Category | Focus Area | Test Count | Critical Scenarios |\n|---------------|------------|------------|-------------------|\n| Zone File Parsing | BIND format interpretation | 20+ tests | All record types, directives, edge cases |\n| Query Matching | Record lookup by name/type | 25+ tests | Exact matches, wildcards, case insensitivity |\n| Response Construction | DNS message assembly | 15+ tests | Authority sections, additional records, glue |\n| CNAME Handling | Alias resolution | 10+ tests | CNAME chains, loops, mixed record types |\n| Negative Responses | NXDOMAIN and NODATA | 12+ tests | SOA records, authority section population |\n| Zone Updates | Dynamic record modification | 8+ tests | Consistency during concurrent access |\n\nThe zone data tests must verify that the in-memory representation accurately reflects the zone file contents and that queries return exactly the records specified in the DNS standards. Case sensitivity handling is particularly important since DNS names are case-insensitive but implementations often make mistakes in normalization.\n\n**Query Response Validation Matrix:**\n\n| Query Type | Expected Response Sections | Validation Points |\n|------------|---------------------------|------------------|\n| A record exists | Answer: A records | Correct IP addresses returned |\n| AAAA record exists | Answer: AAAA records | IPv6 format validation |\n| CNAME record | Answer: CNAME, target records | Chain resolution completeness |\n| NS delegation | Authority: NS records, Additional: glue | Proper referral construction |\n| NXDOMAIN | Authority: SOA record | Negative cache TTL from SOA minimum |\n| No record of type | Authority: SOA record | NODATA vs NXDOMAIN distinction |\n\n#### Recursive Resolver Test Strategy\n\nTesting the recursive resolver requires simulating network interactions and handling the complexity of iterative resolution across multiple servers. This component has the most challenging testing requirements because it involves both deterministic logic (following referrals) and non-deterministic networking (timeouts, server availability).\n\n**Recursive Resolution Test Categories:**\n\n| Test Category | Focus Area | Test Count | Critical Scenarios |\n|---------------|------------|------------|-------------------|\n| Iterative Query Logic | Root to authoritative traversal | 15+ tests | Normal resolution paths, deep hierarchies |\n| Network Error Handling | Timeout and failure recovery | 20+ tests | Server unavailability, partial responses |\n| CNAME Following | Cross-domain alias resolution | 12+ tests | Multi-hop CNAMEs, circular references |\n| Security Validation | Response verification | 18+ tests | Cache poisoning prevention, bailiwick checking |\n| Concurrent Resolution | Multiple simultaneous queries | 10+ tests | Race conditions, resource sharing |\n| Loop Detection | Infinite referral prevention | 8+ tests | Circular NS dependencies, malicious responses |\n\nThe recursive resolver tests require mock network infrastructure to simulate different server behaviors without depending on external DNS infrastructure. This enables testing error conditions like server timeouts and malformed responses that would be difficult to reproduce reliably with real DNS servers.\n\n**Mock Server Response Patterns:**\n\n| Mock Scenario | Server Behavior | Test Validation |\n|---------------|----------------|-----------------|\n| Normal Resolution | Root → TLD → Auth chain | Complete answer returned |\n| Server Timeout | No response from TLD | Fallback to next TLD server |\n| Malformed Response | Invalid message format | Error handling without crash |\n| NXDOMAIN Response | Authoritative negative answer | Proper negative caching |\n| Referral Loop | Circular NS references | Loop detection triggers |\n| Cache Poisoning Attempt | Out-of-bailiwick records | Malicious data rejected |\n\n#### Cache Manager Test Strategy\n\nThe cache manager requires testing both the correctness of TTL-based expiration and the performance characteristics under concurrent access. Cache bugs can be particularly subtle because they often manifest as incorrect data being returned minutes or hours after the initial caching operation.\n\n**Cache Management Test Categories:**\n\n| Test Category | Focus Area | Test Count | Critical Scenarios |\n|---------------|------------|------------|-------------------|\n| TTL Expiration | Time-based entry eviction | 15+ tests | Various TTL values, clock manipulation |\n| Negative Caching | NXDOMAIN/NODATA storage | 10+ tests | SOA-derived TTLs, proper invalidation |\n| Concurrent Access | Thread safety validation | 20+ tests | Read-write conflicts, atomic operations |\n| Memory Management | Entry size limits and eviction | 12+ tests | LRU policies, memory pressure handling |\n| Cache Invalidation | Entry removal and updates | 8+ tests | Zone changes, administrative purging |\n| Statistics Tracking | Hit rates and performance metrics | 6+ tests | Counter accuracy, thread-safe updates |\n\nCache testing requires careful control of time to verify TTL expiration behavior. Mock clocks or time manipulation techniques enable testing cache expiration without waiting for real time to pass. This is essential for validating that entries expire at exactly the right moment and that expired entries are properly cleaned up.\n\n**Cache Concurrency Test Matrix:**\n\n| Concurrency Scenario | Thread Pattern | Validation Point |\n|---------------------|----------------|------------------|\n| Multiple Readers | Concurrent cache lookups | No data corruption |\n| Reader-Writer Conflict | Lookup during cache update | Consistent view returned |\n| Multiple Writers | Concurrent cache insertions | Proper serialization |\n| Cleanup During Access | Background eviction + lookup | No use-after-free bugs |\n| Statistics Updates | Concurrent counter increments | Accurate final counts |\n\n### Common Testing Pitfalls\n\n⚠️ **Pitfall: Testing Only Happy Path Scenarios**\n\nMany developers focus exclusively on testing correct DNS protocol usage without validating error handling and edge cases. DNS servers must handle malformed packets, network failures, and potentially malicious traffic robustly. A parser that works perfectly with valid messages but crashes on malformed input will fail quickly in production.\n\nThe fix requires systematic error injection testing. For every parsing function, create tests with truncated data, invalid field values, and out-of-bounds references. For every network operation, test timeout scenarios and connection failures. This defensive testing approach builds resilience into the DNS server.\n\n⚠️ **Pitfall: Ignoring Timing Dependencies in Cache Tests**\n\nCache behavior is inherently time-dependent, but many tests fail to properly control time progression. Tests that rely on `time.Sleep()` to wait for TTL expiration are fragile and slow. They may pass during development but fail in CI environments with different timing characteristics.\n\nThe solution involves injectable time sources or mock clock implementations. Instead of waiting for real time, tests can advance a mock clock to trigger TTL expiration immediately. This makes tests both faster and more reliable while ensuring TTL logic is properly validated.\n\n⚠️ **Pitfall: Testing Components in Complete Isolation**\n\nWhile unit testing individual components is valuable, DNS server components have important integration points that pure isolation testing misses. For example, testing the cache manager separately from the resolver doesn't validate that TTL values are properly propagated or that negative caching interacts correctly with recursive resolution.\n\nIntegration tests that combine 2-3 components help catch interface mismatches and data flow problems. These tests should focus on the boundaries between components—ensuring data passes correctly from parser to resolver to cache and back.\n\n⚠️ **Pitfall: Insufficient Concurrent Testing**\n\nDNS servers handle multiple simultaneous queries, but many test suites only validate single-threaded behavior. Race conditions and deadlocks may not surface until the server experiences production load levels. These bugs are particularly dangerous because they can cause complete server hangs.\n\nConcurrent testing requires spawning multiple goroutines that exercise the same code paths simultaneously. Tools like Go's race detector can help identify data races, but tests must also verify logical correctness under concurrent access—ensuring cache updates don't interfere with ongoing lookups.\n\n### Milestone Checkpoints\n\nEach milestone represents a significant functional increment in DNS server capability. The checkpoint system provides concrete verification steps that confirm implementation correctness before proceeding to more complex features that depend on earlier milestones.\n\n#### Milestone 1: DNS Message Parsing Checkpoint\n\nThe first milestone establishes the foundation for all DNS operations by implementing robust message parsing and construction. Success at this checkpoint means the server can correctly interpret binary DNS messages and construct valid responses.\n\n**Parsing Verification Steps:**\n\n| Verification Step | Test Command | Expected Outcome | Failure Indicators |\n|-------------------|--------------|------------------|-------------------|\n| Basic Header Parsing | `go test -v ./internal/parser/` | All header tests pass | Flag bit extraction errors |\n| Name Compression | `dig @localhost test.example.com` | Compressed names decoded | Truncated domain names |\n| Record Type Support | Test suite with A/AAAA/CNAME/MX/NS records | All record types parsed | Unknown record type errors |\n| Message Construction | Round-trip parse + serialize test | Identical binary output | Byte order or length errors |\n| Malformed Input Handling | Fuzzing with invalid packets | Graceful error returns | Crashes or infinite loops |\n| Performance Validation | Parse 1000 messages/second | Sub-millisecond average latency | Memory leaks or excessive allocation |\n\nThe parsing checkpoint requires both automated testing and manual verification using standard DNS tools. Running `dig` against the developing server helps identify integration issues that pure unit tests might miss.\n\n**Manual Testing Protocol:**\n\n1. Start the DNS server in a test mode that only echoes parsed message contents\n2. Send queries using `dig` with various record types: `dig @127.0.0.1 -p 5353 example.com A`\n3. Verify the server correctly logs all fields from the incoming query message\n4. Send malformed packets using `nc` or custom test tools\n5. Confirm the server handles errors gracefully without crashing\n6. Monitor memory usage during sustained query load to detect parsing leaks\n\n#### Milestone 2: Authoritative Server Checkpoint\n\nThe authoritative server milestone adds zone data management and query response capabilities. This checkpoint validates that the server can act as an authoritative nameserver for configured domains.\n\n**Authority Verification Steps:**\n\n| Verification Step | Test Command | Expected Outcome | Failure Indicators |\n|-------------------|--------------|------------------|-------------------|\n| Zone File Loading | `go test -v ./internal/authority/` | Zone data populated correctly | Parse errors or missing records |\n| A Record Queries | `dig @localhost example.com A` | Correct IP addresses returned | Wrong IPs or SERVFAIL responses |\n| NS Delegation | `dig @localhost subdomain.example.com NS` | Proper referral with glue records | Missing authority sections |\n| NXDOMAIN Handling | `dig @localhost nonexistent.example.com A` | NXDOMAIN with SOA record | Wrong response code |\n| CNAME Resolution | `dig @localhost alias.example.com A` | Target record returned | Incomplete CNAME following |\n| Zone Reload | Update zone file and send SIGHUP | New records served | Stale data or reload failures |\n\n**Zone File Test Configuration:**\n\n```\n$ORIGIN example.com.\n$TTL 3600\n\n@       IN  SOA ns1.example.com. admin.example.com. (\n            2023010101 ; serial\n            3600       ; refresh\n            1800       ; retry\n            604800     ; expire\n            86400      ; minimum\n        )\n\n        IN  NS  ns1.example.com.\n        IN  NS  ns2.example.com.\n\nns1     IN  A   192.0.2.1\nns2     IN  A   192.0.2.2\nwww     IN  A   192.0.2.10\nmail    IN  A   192.0.2.20\nalias   IN  CNAME www.example.com.\n\nsubdomain IN NS ns1.subdomain.example.com.\nns1.subdomain IN A 192.0.2.30\n```\n\nThis test zone file provides comprehensive coverage of DNS record types and delegation scenarios needed to validate authoritative server functionality.\n\n#### Milestone 3: Recursive Resolver Checkpoint\n\nThe recursive resolver milestone implements the complex iterative resolution process that follows referrals from root servers to authoritative servers. This checkpoint confirms the server can resolve arbitrary domain names.\n\n**Recursion Verification Steps:**\n\n| Verification Step | Test Command | Expected Outcome | Failure Indicators |\n|-------------------|--------------|------------------|-------------------|\n| Root Server Bootstrap | Monitor initial root queries | Successful root server contact | Network timeouts or resolution failures |\n| Iterative Resolution | `dig @localhost google.com A` | External domain resolved | SERVFAIL or timeout responses |\n| CNAME Following | `dig @localhost www.github.com A` | Final A record returned | Incomplete alias resolution |\n| NS Referral Handling | Trace resolution of deep subdomain | Proper referral following | Stuck in referral loops |\n| Timeout Recovery | Block authoritative server | Fallback to alternate servers | Complete resolution failures |\n| Concurrent Queries | Multiple simultaneous resolutions | All queries complete successfully | Deadlocks or resource conflicts |\n\n**Resolution Tracing Example:**\n\n```bash\n# Enable query tracing to validate iterative resolution\ndig @localhost +trace example.org A\n\n# Expected output shows:\n# 1. Query to root server (.)\n# 2. Referral to .org TLD servers\n# 3. Query to .org server\n# 4. Referral to example.org authoritative servers\n# 5. Query to authoritative server\n# 6. Final answer returned\n```\n\nThe trace output allows manual verification that the recursive resolver follows the correct DNS hierarchy path and doesn't skip levels or create loops.\n\n#### Milestone 4: Caching and Performance Checkpoint\n\nThe caching milestone adds TTL-based response caching and optimizes performance for high query loads. This checkpoint validates both correctness of cache behavior and performance under concurrent load.\n\n**Cache Verification Steps:**\n\n| Verification Step | Test Command | Expected Outcome | Failure Indicators |\n|-------------------|--------------|------------------|-------------------|\n| Cache Population | Resolve domain, check cache stats | Cache hit count increases | Cache misses on repeated queries |\n| TTL Expiration | Wait for TTL + 1 second, re-query | Fresh resolution performed | Stale data returned |\n| Negative Caching | Query non-existent domain twice | Second query cached | Repeated resolution attempts |\n| Cache Statistics | `/stats` endpoint or admin command | Accurate hit/miss ratios | Counter inconsistencies |\n| Performance Load | 1000 concurrent queries | Sub-10ms average response | High latency or timeouts |\n| Memory Management | Sustained high query rate | Stable memory usage | Unbounded memory growth |\n\n**Performance Benchmarking Script:**\n\n```bash\n#!/bin/bash\n# Generate concurrent load to validate caching performance\n\necho \"Starting DNS performance test...\"\nstart_time=$(date +%s)\n\n# Launch 100 concurrent query batches\nfor i in {1..100}; do\n  {\n    for domain in google.com facebook.com github.com stackoverflow.com; do\n      dig @localhost $domain A +short >/dev/null\n    done\n  } &\ndone\n\nwait  # Wait for all background jobs to complete\n\nend_time=$(date +%s)\nduration=$((end_time - start_time))\necho \"Completed 400 queries in ${duration} seconds\"\n\n# Check cache statistics\ncurl -s localhost:8080/stats | jq '.cache.hit_rate'\n```\n\nThis performance test validates both the caching effectiveness and the server's ability to handle concurrent query load without performance degradation.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Test Framework | Go standard `testing` package | Testify with assertions and mocks |\n| Mock Networks | Custom UDP listener simulation | Gomock generated mocks |\n| Time Control | Manual time injection | Clockwork time mocking library |\n| Load Testing | Simple bash scripts with `dig` | Custom Go benchmark harness |\n| Coverage Analysis | `go test -cover` | Codecov integration with CI |\n\n#### Test File Structure\n\n```\ndns-server/\n  internal/\n    parser/\n      parser.go\n      parser_test.go          ← Unit tests for message parsing\n      testdata/               ← Binary DNS message test files\n        valid_query.bin\n        compressed_names.bin\n        malformed_header.bin\n    authority/\n      authority.go\n      authority_test.go       ← Unit tests for authoritative server\n      testdata/               ← Zone file test cases\n        example.com.zone\n        delegated.zone\n    resolver/\n      resolver.go\n      resolver_test.go        ← Unit tests for recursive resolution\n      mock_client.go          ← Mock network client for testing\n    cache/\n      cache.go\n      cache_test.go           ← Unit tests for caching logic\n  test/\n    integration/              ← Integration tests\n      query_processing_test.go\n      concurrent_queries_test.go\n    fixtures/                 ← Shared test data\n      root_hints.txt\n      test_zones/\n    benchmarks/               ← Performance tests\n      resolution_bench_test.go\n      cache_performance_test.go\n```\n\n#### Mock Network Client Infrastructure\n\n```go\n// MockNetworkClient simulates DNS server responses for testing\ntype MockNetworkClient struct {\n    responses map[string][]byte  // Query pattern to response mapping\n    delays    map[string]time.Duration\n    errors    map[string]error\n}\n\nfunc NewMockNetworkClient() *MockNetworkClient {\n    return &MockNetworkClient{\n        responses: make(map[string][]byte),\n        delays:    make(map[string]time.Duration),\n        errors:    make(map[string]error),\n    }\n}\n\n// AddResponse configures mock to return specific response for query pattern\nfunc (m *MockNetworkClient) AddResponse(pattern string, response []byte) {\n    m.responses[pattern] = response\n}\n\n// AddDelay simulates network latency for specific servers\nfunc (m *MockNetworkClient) AddDelay(serverIP string, delay time.Duration) {\n    m.delays[serverIP] = delay\n}\n\n// AddError simulates network failures for testing error handling\nfunc (m *MockNetworkClient) AddError(serverIP string, err error) {\n    m.errors[serverIP] = err\n}\n\n// QueryServer simulates DNS query with configured responses/errors/delays\nfunc (m *MockNetworkClient) QueryServer(ctx context.Context, query []byte, serverIP string) ([]byte, error) {\n    // TODO: Check for configured error for this server\n    // TODO: Apply configured delay with time.Sleep()\n    // TODO: Find matching response pattern and return configured response\n    // TODO: Return network timeout error if no response configured\n}\n```\n\n#### Test Data Generation Utilities\n\n```go\n// TestMessageBuilder helps construct DNS messages for testing\ntype TestMessageBuilder struct {\n    msg *DNSMessage\n}\n\nfunc NewTestMessage() *TestMessageBuilder {\n    return &TestMessageBuilder{\n        msg: &DNSMessage{\n            Header: Header{\n                ID: 12345,\n                QueryResponse: false,\n                RecursionDesired: true,\n            },\n        },\n    }\n}\n\n// AddQuestion adds question to test message\nfunc (b *TestMessageBuilder) AddQuestion(name string, qtype uint16) *TestMessageBuilder {\n    // TODO: Append Question{Name: name, Type: qtype, Class: 1} to msg.Questions\n    // TODO: Update Header.QuestionCount\n    return b\n}\n\n// AddAnswer adds resource record to answer section\nfunc (b *TestMessageBuilder) AddAnswer(name string, rtype uint16, ttl uint32, data []byte) *TestMessageBuilder {\n    // TODO: Append ResourceRecord to msg.Answers\n    // TODO: Update Header.AnswerCount\n    return b\n}\n\n// Build returns constructed DNS message ready for testing\nfunc (b *TestMessageBuilder) Build() *DNSMessage {\n    return b.msg\n}\n\n// ToWireFormat serializes test message to binary format\nfunc (b *TestMessageBuilder) ToWireFormat() []byte {\n    data, _ := SerializeMessage(b.msg)\n    return data\n}\n```\n\n#### Parser Testing Skeleton\n\n```go\nfunc TestParseHeader(t *testing.T) {\n    tests := []struct {\n        name     string\n        data     []byte\n        expected Header\n        wantErr  bool\n    }{\n        {\n            name: \"valid header with all flags set\",\n            data: []byte{0x12, 0x34, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00},\n            expected: Header{\n                ID: 0x1234,\n                QueryResponse: true,\n                Authoritative: true,\n                // TODO: Fill in all expected header fields\n            },\n            wantErr: false,\n        },\n        // TODO: Add test cases for:\n        // - Header with no flags set\n        // - Invalid opcode values\n        // - Maximum section counts\n        // - Truncated header (less than 12 bytes)\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            header, err := parseHeader(tt.data)\n            // TODO: Verify error handling matches wantErr\n            // TODO: Compare all header fields with expected values\n            // TODO: Use reflect.DeepEqual or manual field comparison\n        })\n    }\n}\n\nfunc TestNameCompression(t *testing.T) {\n    // TODO: Create test message with compressed names\n    // TODO: Verify parser correctly follows compression pointers\n    // TODO: Test compression loop detection\n    // TODO: Test invalid pointer references (out of bounds)\n    // TODO: Test maximum compression depth limits\n}\n```\n\n#### Cache Testing Skeleton\n\n```go\nfunc TestCacheExpiration(t *testing.T) {\n    // Create mock clock for controlling time\n    mockClock := &MockClock{current: time.Unix(1000, 0)}\n    cache := NewCacheManager(100, 1024*1024, time.Minute)\n    cache.SetClock(mockClock)  // Inject mock clock\n\n    // TODO: Store entry with 30-second TTL\n    // TODO: Advance mock clock by 29 seconds\n    // TODO: Verify entry still exists and is returned\n    // TODO: Advance mock clock by 2 more seconds (total 31)\n    // TODO: Verify entry is expired and not returned\n    // TODO: Verify cleanup removes expired entry from memory\n}\n\nfunc TestConcurrentCacheAccess(t *testing.T) {\n    cache := NewCacheManager(1000, 10*1024*1024, time.Minute)\n    var wg sync.WaitGroup\n    \n    // Launch concurrent readers\n    for i := 0; i < 50; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            // TODO: Perform 100 cache lookups for various keys\n            // TODO: Verify no panics or data corruption\n            // TODO: Track hit/miss ratios\n        }(i)\n    }\n    \n    // Launch concurrent writers\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            // TODO: Insert 50 cache entries with various TTLs\n            // TODO: Update existing entries\n            // TODO: Verify thread-safe insertion\n        }(i)\n    }\n    \n    wg.Wait()\n    \n    // TODO: Verify cache statistics are consistent\n    // TODO: Verify no memory leaks occurred\n    // TODO: Verify cache size limits were respected\n}\n```\n\n#### Integration Test Framework\n\n```go\nfunc TestEndToEndQueryProcessing(t *testing.T) {\n    // Setup test DNS server\n    config := &Config{\n        Server: ServerConfig{ListenAddr: \"127.0.0.1:0\"},\n        Cache: CacheConfig{MaxSize: 1000, DefaultTTL: \"5m\"},\n    }\n    \n    server := NewTestServer(config)\n    defer server.Shutdown()\n    \n    // Configure mock upstream servers\n    mockRoot := NewMockDNSServer(\"192.0.2.1:53\")\n    mockTLD := NewMockDNSServer(\"192.0.2.2:53\")\n    mockAuth := NewMockDNSServer(\"192.0.2.3:53\")\n    \n    // TODO: Configure mock responses for root → TLD → authoritative chain\n    // TODO: Start test server\n    // TODO: Send DNS query using real UDP socket\n    // TODO: Verify correct response received\n    // TODO: Verify cache populated with results\n    // TODO: Send identical query and verify cache hit\n}\n\nfunc TestRecursiveResolutionWithFailures(t *testing.T) {\n    // TODO: Configure some upstream servers to timeout\n    // TODO: Configure some servers to return SERVFAIL\n    // TODO: Verify resolver retries with different servers\n    // TODO: Verify eventual successful resolution\n    // TODO: Verify appropriate error handling when all servers fail\n}\n```\n\n#### Milestone Checkpoint Automation\n\n```go\n// MilestoneChecker provides automated verification for each milestone\ntype MilestoneChecker struct {\n    serverAddr string\n    client     *dns.Client  // Third-party DNS client library\n}\n\nfunc (m *MilestoneChecker) CheckMilestone1() error {\n    // TODO: Send various DNS queries to test parser\n    // TODO: Verify server doesn't crash on malformed input\n    // TODO: Check response message format correctness\n    // TODO: Validate name compression handling\n    return nil\n}\n\nfunc (m *MilestoneChecker) CheckMilestone2() error {\n    // TODO: Query for A records in configured zone\n    // TODO: Query for non-existent domains (expect NXDOMAIN)\n    // TODO: Query for delegated subdomains (expect NS referral)\n    // TODO: Verify SOA records in authority section\n    return nil\n}\n\nfunc (m *MilestoneChecker) CheckMilestone3() error {\n    // TODO: Query for external domains not in local zones\n    // TODO: Verify iterative resolution from root servers\n    // TODO: Test CNAME following across different domains\n    // TODO: Verify proper error handling for resolution failures\n    return nil\n}\n\nfunc (m *MilestoneChecker) CheckMilestone4() error {\n    // TODO: Measure query performance before and after caching\n    // TODO: Verify cache hit rate improves with repeated queries\n    // TODO: Test TTL expiration behavior\n    // TODO: Verify concurrent query handling\n    return nil\n}\n\n```\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones (1-4) - Debugging skills are essential throughout DNS message parsing, authoritative responses, recursive resolution, and caching operations\n\n### Mental Model: DNS Debugging as Medical Diagnosis\n\nThink of debugging a DNS server like diagnosing a patient in a hospital. Just as a doctor follows a systematic approach—observing symptoms, running diagnostic tests, forming hypotheses, and applying treatments—DNS debugging requires methodical investigation of symptoms using specialized tools to identify root causes and apply targeted fixes.\n\nLike medical diagnosis, DNS debugging benefits from pattern recognition. Experienced DNS engineers recognize common symptom patterns just as doctors recognize disease presentations. A query timeout combined with specific log patterns suggests network connectivity issues, while parsing failures with certain byte sequences indicate compression loop problems. Building this diagnostic intuition requires understanding both the common failure modes and the tools available to investigate them.\n\nThe DNS protocol's layered nature—from binary message parsing through recursive resolution to caching—means that symptoms at one layer often originate from problems at another layer. A \"server failure\" response might stem from a parsing error, a network timeout, or cache corruption. Effective debugging requires tracing symptoms through these layers to identify the true root cause.\n\n### Common Bug Patterns\n\nDNS server implementations exhibit predictable failure patterns that map to specific implementation mistakes. Understanding these patterns enables rapid diagnosis and targeted fixes rather than lengthy debugging sessions.\n\n#### Parsing and Message Construction Bugs\n\n**Binary Protocol Parsing Errors** represent the most common category of DNS server bugs, stemming from the complexity of handling variable-length binary data with compression and strict formatting requirements.\n\n| Bug Pattern | Symptoms | Root Cause | Diagnostic Steps | Fix Strategy |\n|-------------|----------|------------|------------------|--------------|\n| Compression Loop | Server crashes with stack overflow or hangs indefinitely | Circular references in DNS pointer labels create infinite loops | Check parse state for repeated offsets, trace compression jumps | Implement jump counting and visited offset tracking in `parseName` |\n| Endianness Error | All numeric values appear incorrect, query IDs don't match responses | Using little-endian instead of network byte order | Compare raw bytes with expected values, check if values are byte-swapped | Use `binary.BigEndian` consistently in `readUint16` and `readUint32` |\n| Buffer Overflow | Parsing crashes with slice bounds errors | Reading beyond available data without bounds checking | Log buffer length and current offset before each read operation | Implement `canRead` validation before all buffer access |\n| Name Truncation | Domain names missing characters or appearing corrupted | Improper null termination or length calculation in name parsing | Compare parsed names with expected values, check label length encoding | Ensure proper string building and null byte handling in `parseName` |\n| Resource Record Corruption | RDATA appears scrambled or causes parsing failures | Incorrect RDLENGTH calculation or improper data type handling | Hexdump raw RDATA bytes and compare with expected format | Validate RDLENGTH matches actual data consumption |\n\n⚠️ **Pitfall: Compression Pointer Validation**\nMany implementations fail to detect malicious or malformed compression pointers that could cause crashes or infinite loops. The DNS message format allows compression pointers to reference any previous location in the message, but implementations must guard against circular references where pointer A points to pointer B which points back to A. This creates an infinite loop during name parsing that can crash the server or consume excessive CPU resources.\n\nThe fix requires maintaining a `visited` map in the `parseState` structure that tracks which message offsets have been encountered during name parsing. Before following any compression pointer, check if the target offset exists in the visited map. Additionally, implement a maximum jump count (typically 16) to prevent excessively long compression chains even without circular references.\n\n#### Recursive Resolution Logic Bugs\n\n**Resolution State Management Errors** occur when the complex state tracking required for iterative DNS resolution becomes inconsistent or corrupted during the resolution process.\n\n| Bug Pattern | Symptoms | Root Cause | Diagnostic Steps | Fix Strategy |\n|-------------|----------|------------|------------------|--------------|\n| Infinite Referral Loops | Queries never complete, excessive network traffic | Following NS referrals that point back to previously visited servers | Log all visited servers in `ResolutionState`, check for cycles | Maintain `visitedServers` map and detect cycles before queries |\n| CNAME Chain Explosion | Resolution takes excessive time, network amplification | Following CNAME records without limiting chain depth | Count CNAME hops during resolution, trace chain path | Implement maximum CNAME chain length (typically 16) |\n| Glue Record Blindness | Resolution fails for domains that should work | Ignoring A records in additional section when NS targets are in-bailiwick | Check if glue records are being extracted and used | Parse additional section for A/AAAA records matching NS targets |\n| Root Server Exhaustion | All queries fail after initial period | Cycling through root servers without reset mechanism | Monitor root server rotation and success/failure patterns | Implement root server health tracking and recovery |\n| Authority Validation Bypass | Cache poisoning or incorrect responses accepted | Accepting out-of-bailiwick records without validation | Log response validation decisions for each received record | Implement strict bailiwick checking in `validateResponse` |\n\n⚠️ **Pitfall: Resolution State Corruption**\nThe `ResolutionState` structure maintains critical state during iterative resolution, including the current question, visited servers, and CNAME chain. If this state becomes corrupted—for example, if the current question is modified incorrectly during CNAME following—subsequent resolution steps operate on invalid data, leading to incorrect queries or resolution failures.\n\nThis commonly occurs when implementations modify the original question directly instead of creating new question instances for each resolution step. The fix requires treating the `originalQuestion` as immutable and creating new `currentQuestion` instances when following CNAMEs or referrals.\n\n#### Caching and Concurrency Bugs\n\n**Cache Consistency Errors** arise from improper synchronization in concurrent environments or incorrect TTL handling that leads to stale or corrupted cache data.\n\n| Bug Pattern | Symptoms | Root Cause | Diagnostic Steps | Fix Strategy |\n|-------------|----------|------------|------------------|--------------|\n| Race Condition Corruption | Cache returns inconsistent data, occasional panics | Multiple goroutines modifying cache without proper locking | Run with race detector, log all cache operations with goroutine IDs | Use `sync.RWMutex` consistently, minimize critical sections |\n| TTL Underflow | Cache entries never expire or expire immediately | Incorrect TTL arithmetic causing wraparound | Monitor TTL values and expiration timestamps in cache | Use proper time arithmetic with `time.Time` and `time.Duration` |\n| Memory Leak Growth | Memory usage grows continuously without bounds | Cache entries not being evicted despite expiration | Profile memory usage, check cleanup goroutine activity | Implement periodic cleanup and LRU eviction in `backgroundCleanup` |\n| Thundering Herd | Massive duplicate queries during cache misses | Multiple concurrent queries for same record causing resolution storms | Monitor query coalescing effectiveness and duplicate resolution | Implement query coalescing with `QueryCoalescer` |\n| Negative Cache Pollution | Legitimate queries return NXDOMAIN incorrectly | Negative cache entries with incorrect keys or excessive TTL | Check negative cache entries and their expiration times | Validate negative cache keys and use SOA minimum for TTL |\n\n⚠️ **Pitfall: Cache Key Collisions**\nThe `CacheKey` structure uses domain name, type, and class to uniquely identify cached records. However, DNS name comparison is case-insensitive, meaning \"Example.com\" and \"EXAMPLE.COM\" represent the same domain. If cache key construction doesn't normalize domain names to a consistent case, the cache may treat these as different entries, reducing cache hit rates and potentially causing consistency issues.\n\nThe fix requires implementing `canonicalizeName` to convert all domain names to lowercase with trailing dots before constructing cache keys. This ensures consistent cache behavior regardless of the case used in incoming queries.\n\n#### Network and Protocol Handling Bugs\n\n**Network Communication Errors** stem from improper handling of UDP communication characteristics, timeout management, or protocol violation scenarios.\n\n| Bug Pattern | Symptoms | Root Cause | Diagnostic Steps | Fix Strategy |\n|-------------|----------|------------|------------------|--------------|\n| UDP Packet Truncation | Large responses appear incomplete | Sending responses larger than UDP maximum without truncation bit | Check response sizes and truncation bit setting | Implement proper truncation handling in `SerializeMessage` |\n| Socket Resource Exhaustion | Server stops responding, connection errors | Creating new sockets without proper cleanup | Monitor file descriptor usage and socket lifecycle | Reuse UDP connections, implement proper resource management |\n| Timeout Cascade Failures | All queries start failing simultaneously | Short timeouts causing cascading failures during high load | Analyze timeout patterns and success/failure correlation | Implement adaptive timeouts and circuit breaker patterns |\n| Response ID Mismatch | Clients reject responses as invalid | Reusing query IDs or incorrect ID assignment | Compare query and response IDs in network traces | Generate unique IDs per query and validate responses |\n| Protocol Violation Handling | Server crashes on malformed queries | Insufficient validation of incoming message format | Test with malformed queries, check validation paths | Implement comprehensive message validation in `ValidateMessage` |\n\n#### Zone Data and Configuration Bugs\n\n**Authoritative Data Errors** result from incorrect zone file parsing, improper record handling, or configuration inconsistencies that affect authoritative responses.\n\n| Bug Pattern | Symptoms | Root Cause | Diagnostic Steps | Fix Strategy |\n|-------------|----------|------------|------------------|--------------|\n| Zone File Parse Failures | Server starts but returns SERVFAIL for authoritative domains | Syntax errors or unsupported directives in zone files | Parse zone files manually, check parser error logs | Implement robust zone file parsing with error reporting |\n| SOA Record Mishandling | Authority section missing or incorrect for negative responses | Improper SOA record construction or missing authority population | Check authority section in NXDOMAIN responses | Ensure SOA records are included in authority section |\n| Case Sensitivity Bugs | Queries fail intermittently based on case | Domain name comparison not following DNS case insensitivity rules | Test queries with mixed case domain names | Implement case-insensitive domain name comparison |\n| Wildcard Record Confusion | Wildcard records match incorrectly or don't match when they should | Complex wildcard matching logic with edge cases | Test various wildcard scenarios and matching patterns | Implement RFC-compliant wildcard matching |\n| Glue Record Generation | Delegation responses missing required glue records | Failing to include A/AAAA records for in-bailiwick NS targets | Check additional section of delegation responses | Generate glue records for NS targets within zone |\n\n### Debugging Tools and Techniques\n\nEffective DNS debugging requires a combination of specialized DNS tools, network analysis capabilities, and systematic logging strategies. Understanding when and how to use each tool accelerates problem diagnosis and resolution.\n\n#### Command-Line DNS Tools\n\nThe `dig` command serves as the primary DNS debugging tool, providing detailed query and response information with extensive formatting options for different diagnostic scenarios.\n\n| Tool Usage | Purpose | Key Options | Example Output Analysis |\n|------------|---------|-------------|------------------------|\n| `dig @server domain A` | Basic query testing | `+short`, `+noall +answer` | Verify basic resolution functionality |\n| `dig @server domain A +trace` | Full resolution path | `+dnssec`, `+additional` | Trace iterative resolution steps |\n| `dig @server domain A +bufsize=4096` | Large response handling | `+edns=0`, `+ignore` | Test EDNS and truncation behavior |\n| `dig @server domain A +tcp` | TCP fallback testing | `+vc`, `+time=30` | Verify TCP implementation |\n| `dig @server -x IP` | Reverse DNS testing | `+short`, `+trace` | Test PTR record resolution |\n\n**Advanced dig Techniques** for specific debugging scenarios:\n\n| Debugging Scenario | Command | What It Reveals |\n|-------------------|---------|-----------------|\n| Cache behavior testing | `dig @server domain A; sleep 5; dig @server domain A` | Whether responses are cached (consistent timing) |\n| TTL countdown verification | `dig @server domain A +ttlid` | TTL decreasing over time indicates proper caching |\n| Authority vs recursive | `dig @server domain A +norec` | Whether server handles authoritative vs recursive queries |\n| DNSSEC validation | `dig @server domain A +dnssec +cd` | DNSSEC signature handling |\n| Response size analysis | `dig @server domain ANY +bufsize=512` | Truncation and EDNS behavior |\n\nThe `nslookup` tool provides an alternative interface with interactive capabilities, while `host` offers simplified output for scripted testing scenarios.\n\n#### Network Traffic Analysis\n\n**Wireshark** provides comprehensive DNS packet analysis capabilities essential for diagnosing protocol-level issues and network communication problems.\n\n| Analysis Task | Wireshark Filter | Purpose | Key Fields to Examine |\n|---------------|-----------------|---------|----------------------|\n| DNS traffic isolation | `dns` | Focus on DNS packets only | Query ID, response codes, flags |\n| Server communication | `ip.addr == server_ip and dns` | Traffic to/from specific server | Source/destination, timing |\n| Query/response matching | `dns.id == 0x1234` | Track specific query through system | Transaction ID consistency |\n| Error response analysis | `dns.flags.rcode != 0` | Focus on error conditions | Response code, authority section |\n| Large response tracking | `dns.flags.truncated == 1` | Truncation and TCP fallback | TC bit, subsequent TCP connection |\n\n**Packet Analysis Techniques** for specific DNS debugging scenarios:\n\n1. **Message Format Validation**: Examine raw bytes in packet details to verify correct wire format encoding. Look for proper header structure, correct section counts, and valid compression pointer usage.\n\n2. **Timing Analysis**: Use Wireshark's time delta features to measure query response times, identify network delays, and detect timeout conditions.\n\n3. **Sequence Tracking**: Follow complete resolution sequences to identify where failures occur in multi-step recursive resolution processes.\n\n4. **Compression Analysis**: Examine name compression usage to identify compression loops or inefficient encoding that could cause parsing failures.\n\n#### Logging and Monitoring Strategies\n\n**Structured Logging** provides essential visibility into DNS server internal operations, enabling rapid diagnosis of complex issues spanning multiple components.\n\n| Log Level | Information Captured | Example Format | When to Use |\n|-----------|---------------------|----------------|-------------|\n| ERROR | Critical failures, parsing errors | `{\"level\":\"error\",\"component\":\"parser\",\"error\":\"compression loop detected\",\"offset\":42}` | Always enabled |\n| WARN | Recoverable issues, protocol violations | `{\"level\":\"warn\",\"component\":\"resolver\",\"msg\":\"malformed response ignored\",\"server\":\"8.8.8.8\"}` | Production monitoring |\n| INFO | Query processing, cache events | `{\"level\":\"info\",\"component\":\"cache\",\"action\":\"miss\",\"key\":\"example.com/A\",\"ttl\":300}` | Performance analysis |\n| DEBUG | Detailed operation tracing | `{\"level\":\"debug\",\"component\":\"parser\",\"msg\":\"parsing name\",\"offset\":12,\"length\":7}` | Development debugging |\n\n**Component-Specific Logging** focuses on capturing the most diagnostic information for each major component:\n\n| Component | Key Metrics | Critical Events | Performance Indicators |\n|-----------|-------------|-----------------|----------------------|\n| Message Parser | Parse success/failure rate, compression usage | Malformed messages, validation failures | Parse time per message |\n| Recursive Resolver | Resolution success rate, query count per resolution | Timeout failures, referral loops | Time per resolution |\n| Cache Manager | Hit rate, eviction count, memory usage | TTL expiration events, cleanup cycles | Cache lookup time |\n| Authoritative Server | Query match rate, zone load status | Zone parsing errors, missing records | Response construction time |\n| Network Handler | Query rate, response size distribution | Socket errors, truncation events | Network round-trip time |\n\n**Metrics Collection** enables trend analysis and performance monitoring essential for production DNS servers:\n\n| Metric Category | Key Measurements | Collection Method | Alerting Thresholds |\n|----------------|------------------|-------------------|-------------------|\n| Throughput | Queries per second, responses per second | Counter increments | Drop below baseline |\n| Latency | Average/median/p95 response time | Histogram tracking | Exceed SLA targets |\n| Error Rates | Parse failures, resolution timeouts, cache misses | Error counters with categorization | Exceed 1% of total |\n| Resource Usage | Memory consumption, CPU utilization, socket count | System resource monitoring | Approach capacity limits |\n\n#### Systematic Debugging Methodology\n\n**Root Cause Analysis** follows a structured approach to efficiently identify and resolve DNS server issues:\n\n1. **Symptom Collection**: Gather complete information about the observed problem, including error messages, affected domains, timing patterns, and environmental conditions.\n\n2. **Hypothesis Formation**: Based on symptoms and common bug patterns, form specific hypotheses about potential root causes, prioritizing the most likely candidates.\n\n3. **Targeted Testing**: Design specific tests to validate or eliminate each hypothesis, using appropriate tools and techniques for the suspected component.\n\n4. **Isolation and Reproduction**: Create minimal test cases that reliably reproduce the issue, enabling focused analysis and fix validation.\n\n5. **Fix Implementation**: Apply targeted fixes based on confirmed root causes, ensuring changes don't introduce new issues.\n\n6. **Verification and Monitoring**: Confirm fix effectiveness through comprehensive testing and ongoing monitoring to prevent regression.\n\n**Environment-Specific Debugging** accounts for different deployment scenarios and their unique challenges:\n\n| Environment | Common Issues | Debugging Approaches | Special Considerations |\n|-------------|---------------|---------------------|----------------------|\n| Development | Parse errors, logic bugs | Unit tests, debugger | Full logging enabled |\n| Integration Testing | Component interaction issues | End-to-end traces | Mock external services |\n| Staging | Configuration problems, performance issues | Load testing, monitoring | Production-like data |\n| Production | Scale issues, network problems | Minimal impact diagnosis | Service availability priority |\n\n### Implementation Guidance\n\nThe debugging capabilities of a DNS server must be built into the architecture from the beginning rather than added as an afterthought. Effective debugging requires structured logging, comprehensive error handling, and diagnostic tools integrated into each component.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|----------------|\n| Logging | Standard library `log` with structured formatting | `logrus` or `zap` for structured JSON logging |\n| Metrics | Manual counters with periodic output | Prometheus metrics with Grafana dashboards |\n| Tracing | Request ID propagation through context | Distributed tracing with Jaeger or Zipkin |\n| Profiling | Built-in Go `pprof` endpoint | Continuous profiling with dedicated tools |\n| Monitoring | File-based log analysis | Centralized logging with ELK stack |\n\n#### Recommended Debugging Infrastructure\n\n```go\n// Debugging infrastructure starter code - copy and use directly\npackage debug\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    _ \"net/http/pprof\"\n    \"sync/atomic\"\n    \"time\"\n)\n\n// Metrics provides DNS server operational metrics\ntype Metrics struct {\n    QueriesReceived   uint64 `json:\"queries_received\"`\n    ResponsesSent     uint64 `json:\"responses_sent\"`\n    ParseErrors       uint64 `json:\"parse_errors\"`\n    ResolutionErrors  uint64 `json:\"resolution_errors\"`\n    CacheHits         uint64 `json:\"cache_hits\"`\n    CacheMisses       uint64 `json:\"cache_misses\"`\n    RecursiveQueries  uint64 `json:\"recursive_queries\"`\n    AuthoritativeHits uint64 `json:\"authoritative_hits\"`\n}\n\n// Logger provides structured logging with component context\ntype Logger struct {\n    component string\n    enabled   map[string]bool\n}\n\nfunc NewLogger(component string) *Logger {\n    return &Logger{\n        component: component,\n        enabled: map[string]bool{\n            \"ERROR\": true,\n            \"WARN\":  true,\n            \"INFO\":  true,\n            \"DEBUG\": false, // Enable for development\n        },\n    }\n}\n\nfunc (l *Logger) Error(msg string, fields map[string]interface{}) {\n    l.log(\"ERROR\", msg, fields)\n}\n\nfunc (l *Logger) Warn(msg string, fields map[string]interface{}) {\n    l.log(\"WARN\", msg, fields)\n}\n\nfunc (l *Logger) Info(msg string, fields map[string]interface{}) {\n    l.log(\"INFO\", msg, fields)\n}\n\nfunc (l *Logger) Debug(msg string, fields map[string]interface{}) {\n    l.log(\"DEBUG\", msg, fields)\n}\n\nfunc (l *Logger) log(level, msg string, fields map[string]interface{}) {\n    if !l.enabled[level] {\n        return\n    }\n    \n    entry := map[string]interface{}{\n        \"timestamp\": time.Now().UTC().Format(time.RFC3339),\n        \"level\":     level,\n        \"component\": l.component,\n        \"message\":   msg,\n    }\n    \n    for k, v := range fields {\n        entry[k] = v\n    }\n    \n    data, _ := json.Marshal(entry)\n    log.Println(string(data))\n}\n\n// MetricsCollector provides thread-safe metrics collection\ntype MetricsCollector struct {\n    metrics Metrics\n}\n\nfunc NewMetricsCollector() *MetricsCollector {\n    return &MetricsCollector{}\n}\n\nfunc (m *MetricsCollector) IncrementQueriesReceived() {\n    atomic.AddUint64(&m.metrics.QueriesReceived, 1)\n}\n\nfunc (m *MetricsCollector) IncrementResponsesSent() {\n    atomic.AddUint64(&m.metrics.ResponsesSent, 1)\n}\n\nfunc (m *MetricsCollector) IncrementParseErrors() {\n    atomic.AddUint64(&m.metrics.ParseErrors, 1)\n}\n\nfunc (m *MetricsCollector) IncrementCacheHits() {\n    atomic.AddUint64(&m.metrics.CacheHits, 1)\n}\n\nfunc (m *MetricsCollector) IncrementCacheMisses() {\n    atomic.AddUint64(&m.metrics.CacheMisses, 1)\n}\n\nfunc (m *MetricsCollector) GetMetrics() Metrics {\n    return Metrics{\n        QueriesReceived:   atomic.LoadUint64(&m.metrics.QueriesReceived),\n        ResponsesSent:     atomic.LoadUint64(&m.metrics.ResponsesSent),\n        ParseErrors:       atomic.LoadUint64(&m.metrics.ParseErrors),\n        ResolutionErrors:  atomic.LoadUint64(&m.metrics.ResolutionErrors),\n        CacheHits:         atomic.LoadUint64(&m.metrics.CacheHits),\n        CacheMisses:       atomic.LoadUint64(&m.metrics.CacheMisses),\n        RecursiveQueries:  atomic.LoadUint64(&m.metrics.RecursiveQueries),\n        AuthoritativeHits: atomic.LoadUint64(&m.metrics.AuthoritativeHits),\n    }\n}\n\n// DebugServer provides HTTP endpoints for debugging and monitoring\ntype DebugServer struct {\n    metrics *MetricsCollector\n    logger  *Logger\n}\n\nfunc NewDebugServer(metrics *MetricsCollector) *DebugServer {\n    return &DebugServer{\n        metrics: metrics,\n        logger:  NewLogger(\"debug-server\"),\n    }\n}\n\nfunc (d *DebugServer) Start(addr string) {\n    http.HandleFunc(\"/metrics\", d.handleMetrics)\n    http.HandleFunc(\"/health\", d.handleHealth)\n    \n    d.logger.Info(\"Starting debug server\", map[string]interface{}{\n        \"address\": addr,\n    })\n    \n    go http.ListenAndServe(addr, nil)\n}\n\nfunc (d *DebugServer) handleMetrics(w http.ResponseWriter, r *http.Request) {\n    metrics := d.metrics.GetMetrics()\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(metrics)\n}\n\nfunc (d *DebugServer) handleHealth(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(\"OK\"))\n}\n```\n\n#### Core Debugging Integration Points\n\nThe following debugging hooks should be integrated into each DNS server component. These provide essential diagnostic visibility without the complete implementation:\n\n```go\n// Parser debugging integration - add to your parser\nfunc ParseMessage(data []byte) (*DNSMessage, error) {\n    logger := NewLogger(\"parser\")\n    \n    logger.Debug(\"Starting message parse\", map[string]interface{}{\n        \"message_size\": len(data),\n    })\n    \n    // TODO 1: Create parseState with visited tracking for compression loops\n    // TODO 2: Parse header section with bounds checking\n    // TODO 3: Parse questions section with name compression support\n    // TODO 4: Parse answer/authority/additional sections\n    // TODO 5: Validate message structure and compression usage\n    \n    logger.Info(\"Message parsed successfully\", map[string]interface{}{\n        \"questions\": len(msg.Questions),\n        \"answers\":   len(msg.Answers),\n    })\n    \n    return msg, nil\n}\n\n// Resolver debugging integration - add to your resolver\nfunc (r *RecursiveResolver) ResolveQuery(ctx context.Context, question Question) (*DNSMessage, error) {\n    logger := NewLogger(\"resolver\")\n    requestID := fmt.Sprintf(\"%x\", time.Now().UnixNano())\n    \n    logger.Info(\"Starting recursive resolution\", map[string]interface{}{\n        \"request_id\": requestID,\n        \"domain\":     question.Name,\n        \"type\":       question.Type,\n    })\n    \n    // TODO 1: Check cache for existing answer\n    // TODO 2: Initialize resolution state with visited server tracking\n    // TODO 3: Perform iterative resolution from root servers\n    // TODO 4: Follow CNAME chains with loop detection\n    // TODO 5: Cache final result with appropriate TTL\n    \n    logger.Info(\"Resolution completed\", map[string]interface{}{\n        \"request_id\":    requestID,\n        \"answer_count\":  len(response.Answers),\n        \"query_count\":   state.queryCount,\n    })\n    \n    return response, nil\n}\n\n// Cache debugging integration - add to your cache\nfunc (c *CacheManager) Get(key CacheKey) (*CacheEntry, bool) {\n    logger := NewLogger(\"cache\")\n    \n    c.mu.RLock()\n    entry, exists := c.cache[key]\n    c.mu.RUnlock()\n    \n    if exists && time.Now().Before(entry.ExpiresAt) {\n        logger.Debug(\"Cache hit\", map[string]interface{}{\n            \"key\":        fmt.Sprintf(\"%s/%d\", key.Name, key.Type),\n            \"expires_at\": entry.ExpiresAt.Format(time.RFC3339),\n        })\n        atomic.AddUint64(&c.stats.CacheHits, 1)\n        return entry, true\n    }\n    \n    logger.Debug(\"Cache miss\", map[string]interface{}{\n        \"key\":     fmt.Sprintf(\"%s/%d\", key.Name, key.Type),\n        \"exists\":  exists,\n        \"expired\": exists && time.Now().After(entry.ExpiresAt),\n    })\n    atomic.AddUint64(&c.stats.CacheMisses, 1)\n    \n    return nil, false\n}\n```\n\n#### Milestone Debugging Checkpoints\n\nEach milestone should include specific debugging verification steps to ensure proper implementation:\n\n**Milestone 1 - Message Parsing Debugging**:\n1. Enable debug logging and parse a simple A record query\n2. Verify header fields are correctly extracted: `dig @localhost example.com A`\n3. Test compression parsing with: `dig @localhost long.domain.name.example.com A`\n4. Expected: Debug logs showing offset progression, no compression loop errors\n5. Red flag: Stack overflow, endless loops, or incorrect field values\n\n**Milestone 2 - Authoritative Server Debugging**:\n1. Load a zone file and query for existing records\n2. Test NXDOMAIN responses: `dig @localhost nonexistent.example.com A`\n3. Verify SOA records appear in authority section for negative responses\n4. Expected: Structured logs showing zone lookups and authority section population\n5. Red flag: Missing SOA records, case sensitivity failures, or wildcard issues\n\n**Milestone 3 - Recursive Resolution Debugging**:\n1. Enable resolution tracing and query for external domain\n2. Follow resolution path: `dig @localhost google.com A +trace`\n3. Monitor visited servers and referral following\n4. Expected: Logs showing iterative queries from root to authoritative\n5. Red flag: Infinite referral loops, missing glue records, or timeout cascades\n\n**Milestone 4 - Caching Performance Debugging**:\n1. Query same domain twice and verify cache hit on second query\n2. Wait for TTL expiration and verify cache miss\n3. Monitor concurrent query handling under load\n4. Expected: Cache hit/miss ratios, TTL countdown, and cleanup cycles\n5. Red flag: Race conditions, memory leaks, or thundering herd scenarios\n\n#### Language-Specific Debugging Hints\n\n**Go-Specific Debugging Techniques**:\n- Use `go run -race` to detect concurrency issues in cache and resolver components\n- Enable pprof endpoints with `import _ \"net/http/pprof\"` for performance analysis\n- Use `go test -v -run TestSpecificCase` for focused test debugging\n- Leverage `context.WithTimeout` for resolution timeout debugging\n- Use `defer func() { recover() }()` carefully to handle parser panics gracefully\n\n**Common Go DNS Pitfalls**:\n- Slice bounds: Always check `len(data) >= offset + size` before reading\n- Goroutine leaks: Ensure all resolution goroutines have proper timeout contexts\n- Memory alignment: Use `binary.BigEndian` for consistent multi-byte integer parsing\n- String building: Use `strings.Builder` for efficient name construction in parsing\n- Time arithmetic: Use `time.Time` and `time.Duration` instead of manual calculations\n\n\n## Future Extensions\n\n> **Milestone(s):** Beyond core implementation (post-milestone 4) - Advanced DNS server features and operational considerations\n\n### Mental Model: DNS Server Evolution as Infrastructure Maturation\n\nThink of DNS server evolution like building infrastructure in a growing city. Your basic DNS server from milestones 1-4 is like the initial road network and traffic signals—it handles the fundamental need for navigation and traffic flow. But as the city grows and faces new challenges, you need additional infrastructure layers: security systems (DNSSEC), modern transportation options (DNS-over-HTTPS), advanced traffic management (intelligent caching), monitoring systems (metrics and alerting), and operational frameworks (configuration management and deployment automation).\n\nEach extension builds upon the solid foundation of your core DNS server while addressing specific operational, security, or performance concerns that emerge in production environments. The key insight is that these extensions don't replace your core functionality—they enhance it with additional capabilities that become increasingly important as your DNS server scales and faces real-world operational demands.\n\n> **Design Principle**: Extensions should integrate seamlessly with existing components rather than requiring architectural overhauls. The modular design established in milestones 1-4 provides extension points where new functionality can be layered on without disrupting core DNS processing logic.\n\n## Protocol Extensions\n\n### Mental Model: Protocol Extensions as Language Dialects\n\nConsider DNS protocol extensions like regional dialects of a shared language. Your basic DNS implementation speaks \"Standard DNS\" fluently, but modern networks require additional \"dialects\" like DNSSEC (the security-aware dialect), EDNS (the extended capabilities dialect), and encrypted transports (the privacy-conscious dialects). Each extension maintains compatibility with the core language while adding specialized vocabulary and grammar rules for specific use cases.\n\nThe architectural challenge lies in supporting multiple dialects simultaneously without creating a \"tower of babel\" where components can't communicate effectively. The solution involves designing protocol abstraction layers that can negotiate capabilities and translate between different DNS dialects as needed.\n\n### DNSSEC (DNS Security Extensions)\n\nDNSSEC represents the most significant protocol extension for DNS servers, adding cryptographic authentication to DNS responses. Think of DNSSEC as adding a notarization system to DNS—every authoritative response gets digitally signed, and recursive resolvers verify these signatures to detect tampering or spoofing attempts.\n\n**DNSSEC Architecture Components:**\n\n| Component | Purpose | Integration Point |\n|-----------|---------|-------------------|\n| `DNSSECValidator` | Validates DNSSEC signatures and chains | Integrates with `RecursiveResolver` before caching responses |\n| `ZoneSigner` | Signs authoritative zone data with private keys | Extends `AuthoritativeServer` to add RRSIG records |\n| `KeyManager` | Manages DNSSEC key lifecycle and rotation | Standalone component with file-based or HSM backends |\n| `TrustAnchorStore` | Maintains root and DLV trust anchors | Used by validator to bootstrap signature verification |\n\nThe DNSSEC validation process extends the recursive resolution algorithm with additional cryptographic verification steps. After receiving a DNS response but before caching it, the validator must verify the signature chain from the response back to a trusted anchor (typically the root zone's key).\n\n**DNSSEC Resource Record Types:**\n\n| Record Type | Purpose | Data Format |\n|-------------|---------|-------------|\n| `RRSIG` | Contains cryptographic signature for an RRset | Algorithm, labels, original TTL, signature expiration/inception, key tag, signer name, signature |\n| `DNSKEY` | Contains public key for zone | Flags, protocol, algorithm, public key data |\n| `DS` | Contains hash of child zone's key | Key tag, algorithm, digest type, digest |\n| `NSEC/NSEC3` | Proves non-existence of records | Next domain name and type bitmap (NSEC) or hashed names (NSEC3) |\n\n> **Decision: DNSSEC Implementation Strategy**\n> - **Context**: DNSSEC adds significant complexity to both authoritative and recursive functionality\n> - **Options Considered**: \n>   1. Full DNSSEC implementation with signing and validation\n>   2. Validation-only recursive resolver\n>   3. Hybrid approach with pluggable DNSSEC backend\n> - **Decision**: Validation-only recursive resolver with external signing tools\n> - **Rationale**: Key management and zone signing require specialized security practices beyond the scope of a DNS server implementation project. Validation provides the primary security benefit for recursive resolvers.\n> - **Consequences**: Enables DNSSEC-aware recursive resolution while avoiding the complexity of cryptographic key management and zone signing workflows.\n\n### EDNS (Extension Mechanisms for DNS)\n\nEDNS extends the basic DNS protocol to support larger message sizes, additional flags, and option codes for protocol extensions. Think of EDNS as adding a \"capabilities negotiation\" layer to DNS—it allows clients and servers to advertise and utilize enhanced DNS features beyond the original 512-byte UDP limit.\n\n**EDNS Implementation Architecture:**\n\n| Component | Responsibility | Extension Point |\n|-----------|----------------|-----------------|\n| `EDNSProcessor` | Handles EDNS option parsing and generation | Extends `MessageHandler` processing pipeline |\n| `UDPSizeNegotiator` | Manages UDP payload size negotiation | Integrates with `Server` transport layer |\n| `OptionCodeHandler` | Processes specific EDNS option types | Pluggable handlers for different option codes |\n\n**EDNS Option Codes:**\n\n| Option Code | Name | Purpose |\n|-------------|------|---------|\n| 3 | NSID | Name Server Identifier for debugging |\n| 5 | DAU/DHU/N3U | DNSSEC algorithm understanding |\n| 8 | Client Subnet | Geographic location hints for CDN optimization |\n| 9 | EXPIRE | SOA EXPIRE value in responses |\n| 10 | COOKIE | DNS cookies for security and performance |\n| 12 | PADDING | Message padding for privacy |\n\nEDNS fundamentally changes how your DNS server handles message size limitations. Instead of the hard 512-byte UDP limit, EDNS allows negotiation of much larger UDP payloads (typically 1232 bytes to avoid IP fragmentation). This requires modifications to your UDP transport layer to handle variable-sized buffers and fragmentation detection.\n\n> **Design Insight**: EDNS options provide a standardized extension mechanism that avoids the need for new DNS message formats. Each option code represents a mini-protocol that can be independently implemented and deployed.\n\n### DNS-over-HTTPS (DoH) and DNS-over-TLS (DoT)\n\nEncrypted DNS transports address privacy concerns by encrypting DNS queries and responses. DoT wraps standard DNS queries in TLS connections, while DoH embeds DNS messages in HTTP/2 requests. Think of these as \"secure tunnels\" for DNS traffic—the core DNS message processing remains unchanged, but the transport layer provides encryption and authentication.\n\n**Encrypted Transport Architecture:**\n\n| Transport | Protocol Stack | Implementation Approach |\n|-----------|----------------|-------------------------|\n| DNS-over-TLS | DNS/TLS/TCP | TLS server with DNS message framing |\n| DNS-over-HTTPS | DNS/HTTP/2/TLS/TCP | HTTP/2 server with DNS message encoding |\n| DNS-over-QUIC | DNS/QUIC/UDP | QUIC connection with DNS message streams |\n\nThe key architectural insight is that encrypted transports require minimal changes to your core DNS processing logic. The `MessageHandler`, `RecursiveResolver`, and `CacheManager` components remain unchanged—only the transport layer needs modification to handle TLS handshakes, HTTP request parsing, and connection management.\n\n> **Decision: Transport Layer Abstraction**\n> - **Context**: Supporting multiple transports (UDP, TCP, TLS, HTTPS) without duplicating DNS processing logic\n> - **Options Considered**:\n>   1. Separate server implementations for each transport\n>   2. Transport abstraction with common DNS processing pipeline\n>   3. Protocol-specific forks of core components\n> - **Decision**: Transport abstraction with unified message processing\n> - **Rationale**: DNS message semantics remain identical across transports—only framing and security differ. A transport abstraction allows code reuse while supporting multiple protocols.\n> - **Consequences**: Enables easy addition of new transports without modifying core DNS logic, but requires careful abstraction design to handle transport-specific features like connection state.\n\n**Common Protocol Extension Pitfalls:**\n\n⚠️ **Pitfall: Version Proliferation**\nAdding protocol extensions often leads to combinatorial explosion of supported feature combinations. For example, supporting both DNSSEC and EDNS requires testing every EDNS option with and without DNSSEC validation. Create feature matrices to track supported combinations and use feature flags to enable/disable extensions independently during testing.\n\n⚠️ **Pitfall: Backward Compatibility Breakage**\nProtocol extensions must remain compatible with clients that don't support the extension. Always implement graceful fallback—if a client doesn't support EDNS, respond with standard 512-byte messages. If DNSSEC validation fails, log the failure but still provide the response (with appropriate flags) rather than returning SERVFAIL.\n\n⚠️ **Pitfall: Security Regression**\nAdding new protocol features often introduces security vulnerabilities if not carefully implemented. DNSSEC validation bugs can disable security entirely, and encrypted transport implementations may be vulnerable to downgrade attacks. Implement security extensions in separate, well-tested modules with comprehensive failure mode analysis.\n\n## Operational Features\n\n### Mental Model: DNS Operations as Service Management\n\nThink of operational features as the difference between running a personal vehicle and managing a commercial fleet. Your core DNS server from milestones 1-4 is like a well-functioning car—it gets you from point A to point B reliably. But operating DNS infrastructure in production requires fleet management capabilities: monitoring dashboards to track performance across multiple servers, centralized configuration management to update policies consistently, automated deployment pipelines to roll out changes safely, and comprehensive logging to diagnose issues quickly.\n\nThe operational layer sits \"around\" your DNS server rather than \"inside\" it. These features observe, configure, and manage your DNS server without changing its core resolution logic. The architectural challenge is designing clean integration points that provide operational visibility without compromising DNS processing performance.\n\n### Metrics and Monitoring\n\nProduction DNS servers require comprehensive metrics collection to track performance, detect anomalies, and guide capacity planning. Think of metrics as the \"vital signs\" of your DNS server—just as medical monitors track heart rate, blood pressure, and temperature, DNS metrics track query rates, resolution latencies, cache hit rates, and error frequencies.\n\n**DNS Metrics Categories:**\n\n| Category | Key Metrics | Purpose |\n|----------|-------------|---------|\n| Traffic | `queries_per_second`, `responses_per_second`, `bytes_in`, `bytes_out` | Capacity planning and traffic analysis |\n| Performance | `resolution_latency_p50`, `resolution_latency_p99`, `cache_hit_rate` | Performance optimization and SLA monitoring |\n| Reliability | `servfail_rate`, `nxdomain_rate`, `timeout_rate`, `uptime_percentage` | Service health and error analysis |\n| Resources | `memory_usage`, `cpu_utilization`, `cache_memory_bytes`, `goroutine_count` | Resource monitoring and leak detection |\n\n**Metrics Collection Architecture:**\n\n| Component | Responsibility | Integration Pattern |\n|-----------|----------------|-------------------|\n| `MetricsCollector` | Aggregates counters and histograms | Embedded in each major component (resolver, cache, handler) |\n| `MetricsExporter` | Exports metrics in Prometheus format | HTTP endpoint at `/metrics` for scraping |\n| `HealthChecker` | Provides service health endpoints | HTTP endpoint at `/health` with dependency checks |\n| `AlertManager` | Defines alert rules and thresholds | External configuration with metric threshold rules |\n\nThe metrics collection pattern involves embedding metric collection points throughout your DNS server components without impacting the critical path. Use atomic counters for high-frequency events (query counts) and sampling for expensive metrics (detailed latency histograms).\n\n```go\n// Example metrics integration pattern:\ntype MetricsCollector struct {\n    queriesReceived     uint64\n    cacheHits          uint64\n    resolutionLatency  prometheus.Histogram\n}\n\nfunc (m *MetricsCollector) RecordQuery() {\n    atomic.AddUint64(&m.queriesReceived, 1)\n}\n```\n\n> **Decision: Metrics Collection Strategy**\n> - **Context**: Need comprehensive observability without impacting DNS resolution performance\n> - **Options Considered**:\n>   1. Synchronous metrics collection on every operation\n>   2. Asynchronous metrics aggregation with periodic export\n>   3. Sampling-based metrics with statistical extrapolation\n> - **Decision**: Atomic counters for high-frequency metrics with periodic aggregation\n> - **Rationale**: Atomic operations provide accurate counts with minimal performance overhead. Periodic aggregation reduces export overhead while maintaining near-real-time visibility.\n> - **Consequences**: Provides accurate, low-overhead metrics collection suitable for high-query-rate DNS servers.\n\n### Configuration Management\n\nProduction DNS servers require dynamic configuration management to update policies, zone data, and operational parameters without service restarts. Think of configuration management as the \"control panel\" for your DNS server—it allows operators to adjust server behavior in response to changing requirements, security threats, or performance issues.\n\n**Configuration Categories:**\n\n| Configuration Type | Examples | Update Method |\n|-------------------|----------|---------------|\n| Server Configuration | `listen_addresses`, `timeout_values`, `thread_pools` | File-based with hot reload |\n| Zone Configuration | `zone_files`, `zone_transfers`, `delegation_points` | Dynamic zone loading |\n| Policy Configuration | `rate_limits`, `access_controls`, `filtering_rules` | API-based updates |\n| Cache Configuration | `cache_size`, `ttl_overrides`, `negative_cache_ttl` | Runtime parameter updates |\n\n**Configuration Management Architecture:**\n\n| Component | Purpose | Implementation Approach |\n|-----------|---------|------------------------|\n| `ConfigLoader` | Loads configuration from files and APIs | YAML/JSON parsing with validation |\n| `ConfigWatcher` | Detects configuration file changes | Filesystem watching with inotify/polling |\n| `ConfigValidator` | Validates configuration syntax and semantics | Schema validation with dependency checking |\n| `ConfigApplier` | Applies configuration changes to running server | Component-specific update handlers |\n\nConfiguration management requires careful handling of update atomicity and rollback scenarios. Configuration changes should be validated before application, and the server should maintain the ability to revert to a known-good configuration if updates cause operational issues.\n\n> **Design Insight**: Configuration hot reloading is essential for DNS servers because restart-based configuration updates cause query interruption and cache loss. Design your configuration system with incremental updates that preserve server state wherever possible.\n\n### Deployment and Scaling\n\nDNS infrastructure requires deployment strategies that ensure continuous availability during updates and provide horizontal scaling capabilities for high-query loads. Think of DNS deployment like air traffic control system updates—you can't take the system offline for maintenance, so you need rolling update strategies that maintain service continuity.\n\n**Deployment Patterns:**\n\n| Pattern | Description | Use Case |\n|---------|-------------|----------|\n| Blue-Green Deployment | Two identical environments with traffic switching | Major version updates with quick rollback |\n| Rolling Updates | Gradual replacement of servers in a cluster | Minor updates with zero downtime |\n| Canary Deployment | Small percentage of traffic to new version | Testing updates with limited blast radius |\n| A/B Testing | Split traffic between configuration variants | Performance testing and optimization |\n\n**Scaling Architectures:**\n\n| Architecture | Benefits | Trade-offs |\n|--------------|----------|------------|\n| Load Balancer + Multiple Resolvers | Simple horizontal scaling | Shared cache warming and coordination complexity |\n| Anycast DNS with Geographic Distribution | Geographic latency optimization | Complex routing and failure handling |\n| Hierarchical Resolver Chains | Specialized resolver roles | Additional network hops and complexity |\n\nProduction DNS deployment requires careful consideration of state management during updates. Your `CacheManager` contains valuable cached data that provides significant performance benefits. Deployment strategies should preserve cache state when possible or implement cache warming procedures to minimize performance impact during server replacement.\n\n> **Decision: Deployment State Management**\n> - **Context**: DNS server updates should minimize performance impact from cache loss\n> - **Options Considered**:\n>   1. Stateless deployment with cache rebuilding after updates\n>   2. Cache persistence with state restoration during updates  \n>   3. Cache sharing between old and new server instances\n> - **Decision**: Gradual traffic shifting with cache warming period\n> - **Rationale**: Allows new instances to warm their caches gradually while maintaining performance. Avoids complexity of cache persistence while minimizing performance impact.\n> - **Consequences**: Requires load balancer support for gradual traffic shifting but provides best balance of simplicity and performance.\n\n**Operational Features Common Pitfalls:**\n\n⚠️ **Pitfall: Metrics Overhead**\nComprehensive metrics collection can introduce significant performance overhead if implemented poorly. Avoid string concatenation in metric names, use pre-allocated metric objects, and batch metric exports. Monitor the overhead of your monitoring system itself—metrics collection should consume less than 5% of total server resources.\n\n⚠️ **Pitfall: Configuration Validation Gaps**\nInvalid configurations that pass initial validation but cause runtime failures are particularly dangerous in DNS servers. Implement multi-layer validation: syntax validation at load time, semantic validation before application, and runtime health checks after application. Always maintain a rollback path to the previous known-good configuration.\n\n⚠️ **Pitfall: Deployment Race Conditions**\nDNS server deployments can suffer from race conditions where configuration updates, zone data changes, and software updates interfere with each other. Implement deployment coordination mechanisms that serialize conflicting operations and provide clear rollback procedures when deployments fail partially.\n\n### Logging and Audit Trail\n\nProduction DNS servers require comprehensive logging for security analysis, performance debugging, and compliance requirements. Think of DNS logging as creating a \"flight recorder\" for your DNS server—it captures enough detail to reconstruct what happened during incidents, security events, or performance anomalies without creating excessive storage overhead.\n\n**Logging Categories:**\n\n| Log Type | Content | Retention Policy |\n|----------|---------|------------------|\n| Query Logs | Client IP, query name/type, response code, latency | 7-30 days (high volume) |\n| Security Logs | Failed validation, rate limiting, suspicious patterns | 90+ days (compliance) |\n| Performance Logs | Slow queries, cache misses, upstream failures | 30 days (analysis) |\n| Audit Logs | Configuration changes, administrative actions | 1+ years (compliance) |\n\nDNS logging must balance comprehensive coverage with storage costs and privacy requirements. High-volume query logs require efficient compression and rotation strategies, while security and audit logs need longer retention with tamper-evident storage.\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Metrics Collection | Expvar + JSON export | Prometheus + Grafana |\n| Configuration Management | YAML files + file watching | Consul + dynamic updates |\n| Deployment | Docker + shell scripts | Kubernetes + Helm charts |\n| Logging | Standard library + log rotation | Structured logging + ELK stack |\n| Transport Security | Go TLS + certificate files | cert-manager + automatic rotation |\n\n**Recommended File Structure:**\n\n```\ndns-server/\n  cmd/\n    dns-server/main.go          ← main server entry point\n    config-validator/main.go    ← configuration validation tool\n  internal/\n    metrics/\n      collector.go              ← metrics collection interface\n      prometheus.go             ← Prometheus exporter implementation\n      health.go                 ← health check endpoints\n    config/\n      loader.go                 ← configuration loading and validation\n      watcher.go                ← configuration change detection\n      schema.go                 ← configuration schema definitions\n    transport/\n      udp.go                    ← standard UDP transport\n      tls.go                    ← DNS-over-TLS implementation\n      https.go                  ← DNS-over-HTTPS implementation\n    extensions/\n      dnssec/                   ← DNSSEC validation components\n      edns/                     ← EDNS option handling\n  configs/\n    server.yaml                 ← server configuration template\n    zones/                      ← zone file directory\n  deploy/\n    docker/                     ← container deployment files\n    k8s/                        ← Kubernetes manifests\n  scripts/\n    deploy.sh                   ← deployment automation\n    backup.sh                   ← backup procedures\n```\n\n**Infrastructure Starter Code:**\n\n**Metrics Collection Framework:**\n\n```go\n// Package metrics provides DNS server metrics collection\npackage metrics\n\nimport (\n    \"net/http\"\n    \"sync/atomic\"\n    \"time\"\n)\n\n// Collector aggregates DNS server metrics\ntype Collector struct {\n    // Query counters\n    queriesReceived uint64\n    responsesSent   uint64\n    \n    // Error counters  \n    parseErrors      uint64\n    resolutionErrors uint64\n    \n    // Performance metrics\n    cacheHits        uint64\n    cacheMisses      uint64\n    \n    // Latency tracking\n    totalLatency     uint64\n    queryCount       uint64\n}\n\n// NewCollector creates a metrics collector instance\nfunc NewCollector() *Collector {\n    return &Collector{}\n}\n\n// RecordQuery increments the queries received counter\nfunc (c *Collector) RecordQuery() {\n    atomic.AddUint64(&c.queriesReceived, 1)\n}\n\n// RecordResponse increments the responses sent counter  \nfunc (c *Collector) RecordResponse() {\n    atomic.AddUint64(&c.responsesSent, 1)\n}\n\n// RecordLatency adds query latency to running average\nfunc (c *Collector) RecordLatency(duration time.Duration) {\n    latencyMs := uint64(duration.Nanoseconds() / 1e6)\n    atomic.AddUint64(&c.totalLatency, latencyMs)\n    atomic.AddUint64(&c.queryCount, 1)\n}\n\n// GetStats returns current metrics snapshot\nfunc (c *Collector) GetStats() map[string]interface{} {\n    queries := atomic.LoadUint64(&c.queriesReceived)\n    responses := atomic.LoadUint64(&c.responsesSent)\n    hits := atomic.LoadUint64(&c.cacheHits)\n    misses := atomic.LoadUint64(&c.cacheMisses)\n    totalLat := atomic.LoadUint64(&c.totalLatency)\n    count := atomic.LoadUint64(&c.queryCount)\n    \n    stats := map[string]interface{}{\n        \"queries_received\":  queries,\n        \"responses_sent\":    responses,\n        \"cache_hits\":        hits,\n        \"cache_misses\":      misses,\n        \"cache_hit_rate\":    float64(hits) / float64(hits+misses),\n    }\n    \n    if count > 0 {\n        stats[\"avg_latency_ms\"] = float64(totalLat) / float64(count)\n    }\n    \n    return stats\n}\n\n// ServeHTTP provides HTTP metrics endpoint\nfunc (c *Collector) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    // TODO: Implement Prometheus format export\n    // TODO: Add histogram buckets for latency distribution  \n    // TODO: Include server metadata and build info\n}\n```\n\n**Configuration Management Framework:**\n\n```go\n// Package config provides dynamic configuration management\npackage config\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"path/filepath\"\n    \"time\"\n    \n    \"gopkg.in/yaml.v2\"\n)\n\n// ServerConfig defines DNS server configuration\ntype ServerConfig struct {\n    ListenAddr    string        `yaml:\"listen_addr\"`\n    Timeout       time.Duration `yaml:\"timeout\"`\n    MaxGoroutines int           `yaml:\"max_goroutines\"`\n    \n    Cache struct {\n        MaxSize     int           `yaml:\"max_size\"`\n        DefaultTTL  time.Duration `yaml:\"default_ttl\"`\n        CleanupInt  time.Duration `yaml:\"cleanup_interval\"`\n    } `yaml:\"cache\"`\n    \n    Zones []ZoneConfig `yaml:\"zones\"`\n    \n    Metrics struct {\n        Enabled bool   `yaml:\"enabled\"`\n        Port    int    `yaml:\"port\"`\n        Path    string `yaml:\"path\"`\n    } `yaml:\"metrics\"`\n}\n\n// ZoneConfig defines authoritative zone configuration\ntype ZoneConfig struct {\n    Domain string `yaml:\"domain\"`\n    File   string `yaml:\"file\"`\n    Type   string `yaml:\"type\"` // \"master\" or \"slave\"\n}\n\n// Loader manages configuration loading and reloading\ntype Loader struct {\n    configPath string\n    current    *ServerConfig\n    watchers   []func(*ServerConfig)\n}\n\n// NewLoader creates a configuration loader\nfunc NewLoader(configPath string) *Loader {\n    return &Loader{\n        configPath: configPath,\n        watchers:   make([]func(*ServerConfig), 0),\n    }\n}\n\n// Load reads and parses configuration file\nfunc (l *Loader) Load() error {\n    data, err := ioutil.ReadFile(l.configPath)\n    if err != nil {\n        return fmt.Errorf(\"reading config file: %w\", err)\n    }\n    \n    var config ServerConfig\n    if err := yaml.Unmarshal(data, &config); err != nil {\n        return fmt.Errorf(\"parsing config YAML: %w\", err)\n    }\n    \n    if err := l.validate(&config); err != nil {\n        return fmt.Errorf(\"validating config: %w\", err)\n    }\n    \n    l.current = &config\n    l.notifyWatchers()\n    return nil\n}\n\n// validate performs semantic validation of configuration\nfunc (l *Loader) validate(config *ServerConfig) error {\n    // TODO: Validate listen address format\n    // TODO: Check zone file paths exist and are readable  \n    // TODO: Validate timeout and size parameters are reasonable\n    // TODO: Check for conflicting zone domains\n    return nil\n}\n\n// Watch registers callback for configuration changes\nfunc (l *Loader) Watch(callback func(*ServerConfig)) {\n    l.watchers = append(l.watchers, callback)\n}\n\n// notifyWatchers calls all registered change callbacks\nfunc (l *Loader) notifyWatchers() {\n    for _, watcher := range l.watchers {\n        go watcher(l.current) // Non-blocking notification\n    }\n}\n\n// StartWatching begins monitoring config file for changes\nfunc (l *Loader) StartWatching() error {\n    // TODO: Implement file system watching with inotify/polling\n    // TODO: Debounce rapid file changes \n    // TODO: Handle file deletion and recreation\n    // TODO: Reload configuration when changes detected\n    return nil\n}\n```\n\n**Core Logic Skeleton Code:**\n\n**DNSSEC Validator Interface:**\n\n```go\n// ValidateResponse performs DNSSEC validation on DNS response\nfunc (v *DNSSECValidator) ValidateResponse(response *DNSMessage, question Question) error {\n    // TODO 1: Check if response requires DNSSEC validation (AD bit or DO bit set)\n    // TODO 2: Extract RRSIG records from answer, authority, and additional sections\n    // TODO 3: Verify each RRSIG against its corresponding RRset using DNSKEY records  \n    // TODO 4: Build trust chain from response back to configured trust anchor\n    // TODO 5: Validate signature timestamps (inception/expiration) against current time\n    // TODO 6: Check for NSEC/NSEC3 records to validate negative responses\n    // TODO 7: Set AD (Authenticated Data) bit in response if validation succeeds\n    // Hint: Use crypto/rsa or crypto/ecdsa for signature verification\n    // Hint: Implement recursive trust chain building for multi-level domains\n}\n```\n\n**Transport Abstraction Interface:**\n\n```go\n// HandleConnection processes DNS queries over encrypted transport\nfunc (s *TLSServer) HandleConnection(conn net.Conn) error {\n    // TODO 1: Perform TLS handshake and certificate validation\n    // TODO 2: Read DNS message length prefix (2 bytes, network order)\n    // TODO 3: Read DNS message data based on length prefix\n    // TODO 4: Parse DNS message using existing ParseMessage function\n    // TODO 5: Process query using existing MessageHandler \n    // TODO 6: Serialize response using existing SerializeMessage function\n    // TODO 7: Write length prefix and response data to connection\n    // TODO 8: Handle connection errors and cleanup resources\n    // Hint: DNS over TCP/TLS uses 2-byte length prefixes unlike UDP\n    // Hint: Reuse existing UDP message processing pipeline unchanged\n}\n```\n\n**Metrics Export Endpoint:**\n\n```go\n// ExportPrometheusMetrics formats metrics in Prometheus exposition format\nfunc (c *Collector) ExportPrometheusMetrics() string {\n    // TODO 1: Get current metrics snapshot from atomic counters\n    // TODO 2: Format counter metrics with Prometheus naming conventions  \n    // TODO 3: Calculate derived metrics like cache hit rate percentages\n    // TODO 4: Include metric metadata (HELP and TYPE comments)\n    // TODO 5: Add server identification labels (version, instance)\n    // TODO 6: Format histogram buckets for latency distributions\n    // TODO 7: Return complete Prometheus exposition format string\n    // Hint: Follow Prometheus metric naming: dns_queries_total, dns_cache_hits_total\n    // Hint: Include timestamp for each metric sample\n}\n```\n\n**Language-Specific Implementation Hints:**\n\n- **Metrics Collection**: Use `sync/atomic` for counters, `sync.RWMutex` for histograms, avoid string concatenation in hot paths\n- **Configuration Management**: Use `gopkg.in/yaml.v2` for YAML parsing, `github.com/fsnotify/fsnotify` for file watching  \n- **TLS Implementation**: Use `crypto/tls` with `tls.Config` for certificate management, handle TLS handshake errors gracefully\n- **HTTP/2 for DoH**: Use `golang.org/x/net/http2` package, handle HTTP/2 stream multiplexing correctly\n- **DNSSEC Cryptography**: Use `github.com/miekg/dns` package for DNSSEC record parsing, `crypto/rsa` and `crypto/ecdsa` for validation\n\n**Milestone Checkpoints:**\n\n**Protocol Extensions Checkpoint:**\n- Verify EDNS support: `dig @localhost -p 5353 +edns=0 +bufsize=4096 example.com` should return larger UDP responses\n- Test DNSSEC validation: Configure trust anchor and verify DNSSEC-signed domains return validated responses\n- Validate DoT/DoH: Connect using TLS/HTTPS clients and verify standard DNS responses over encrypted transports\n\n**Operational Features Checkpoint:**\n- Access metrics endpoint: `curl http://localhost:8080/metrics` should return Prometheus-format metrics\n- Test configuration reload: Modify configuration file and verify changes applied without restart\n- Monitor health endpoint: `curl http://localhost:8080/health` should return service status and dependency checks\n\n**Performance Validation:**\n- Load test with metrics: Run high query rate load test while monitoring metrics export overhead\n- Configuration change impact: Measure query latency during configuration reload operations  \n- Memory usage tracking: Monitor memory growth over time with comprehensive metrics collection enabled\n\n\n## Glossary\n\n> **Milestone(s):** All milestones (1-4) - Terminology reference for DNS server implementation concepts and technical terms\n\n### Mental Model: Technical Glossary as a Shared Language Dictionary\n\nThink of this glossary as the shared vocabulary that enables effective communication between DNS engineers. Just as lawyers have precise definitions for legal terms like \"tort\" or \"jurisdiction,\" DNS engineers need precise definitions for concepts like \"bailiwick\" or \"glue records.\" Without this shared language, discussions about DNS server behavior become ambiguous and error-prone. This glossary serves as the authoritative reference for all technical terms used throughout the DNS server implementation, ensuring consistent understanding across different components and development phases.\n\nThe glossary is organized into logical categories that mirror the DNS server's architectural layers: protocol fundamentals, message structure, resolution processes, caching mechanisms, implementation concepts, and operational terminology. Each definition provides not just the meaning, but context about when and why the term is important in DNS server implementation.\n\n### DNS Protocol Fundamentals\n\nThese terms form the foundation of DNS understanding and appear throughout all milestones of the implementation.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **DNS (Domain Name System)** | Distributed hierarchical naming system that translates domain names to IP addresses and other resource data | Core protocol that the entire server implements |\n| **recursive resolver** | DNS server that performs complete domain name resolution by following referrals from root servers through the DNS hierarchy until reaching authoritative servers | Primary server type implemented in Milestone 3 |\n| **authoritative server** | DNS server that holds definitive, original DNS records for specific domains and can provide authoritative answers | Server type implemented in Milestone 2 |\n| **forwarding server** | DNS server that relays all queries to upstream DNS servers without performing resolution itself | Alternative architecture not implemented in this project |\n| **iterative resolution** | Process where a DNS resolver follows referrals from root servers through TLD servers to authoritative servers, making separate queries at each level | Core algorithm implemented in recursive resolver |\n| **zone** | Administrative unit of DNS namespace for which a single authoritative server is responsible | Organizational concept used in authoritative server implementation |\n| **zone data** | Collection of authoritative DNS records loaded from configuration files for domains under server authority | Data structure managed by authoritative server |\n| **root servers** | Thirteen DNS servers that form the top of the DNS hierarchy, knowing the authoritative servers for all top-level domains | Starting point for recursive resolution |\n| **root hints** | Configuration file containing IP addresses of DNS root servers used to bootstrap recursive resolution | Required configuration for recursive resolver |\n\n### DNS Message Structure and Protocol Details\n\nThese terms describe the binary protocol format and message components that are central to Milestone 1 (DNS Message Parsing).\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **wire format** | Binary representation of DNS messages as transmitted over the network, following RFC 1035 specification | Target format for message serialization and source for parsing |\n| **DNS message** | Complete DNS protocol data unit containing header, questions, and resource record sections | Primary data structure processed by all server components |\n| **resource record** | DNS data entry containing name, type, class, TTL, and type-specific data fields | Fundamental unit of DNS information |\n| **TTL (Time To Live)** | Numeric value in seconds indicating how long a DNS record can be cached before expiration | Critical for cache management in Milestone 4 |\n| **network byte order** | Big-endian byte ordering used in DNS messages where most significant byte comes first | Required for correct binary message parsing |\n| **label length encoding** | DNS name representation where each component is prefixed with a length byte | Core parsing algorithm for domain names |\n| **name compression** | DNS optimization technique using pointer labels to reference previously encoded domain names within the same message | Essential for efficient message parsing and construction |\n| **compression pointer** | Two-byte reference (starting with 0xC0) that points to another location in the DNS message containing a domain name | Implementation detail for name compression |\n| **pointer labels** | DNS name components beginning with bits 11 (0xC0) that reference other message locations instead of containing literal text | Specific type of label requiring special parsing logic |\n\n### DNS Record Types and Classes\n\nThese terms define the types of DNS data that servers handle throughout all milestones.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **A record** | DNS resource record type 1 containing 32-bit IPv4 address | Most common record type processed by all server components |\n| **AAAA record** | DNS resource record type 28 containing 128-bit IPv6 address | IPv6 equivalent of A records |\n| **CNAME record** | DNS resource record type 5 containing canonical name alias pointing to another domain | Requires special handling during resolution |\n| **MX record** | DNS resource record type 15 containing mail exchange server information with priority | Email routing records handled by authoritative server |\n| **NS record** | DNS resource record type 2 containing authoritative nameserver for a domain | Critical for delegation and referrals in recursive resolution |\n| **SOA record** | DNS resource record type 6 containing Start of Authority information for a zone | Required for authoritative responses and negative caching |\n| **TXT record** | DNS resource record type 16 containing arbitrary text data | General-purpose record type for various applications |\n| **glue records** | A or AAAA records for nameservers within their own delegated zone, preventing circular dependencies | Essential for resolving delegation loops in recursive resolution |\n\n### Caching and Performance Concepts\n\nThese terms are central to Milestone 4 (Caching & Performance) and performance optimization throughout the implementation.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **negative caching** | Caching NXDOMAIN and NODATA responses to avoid repeated queries for non-existent domains | Performance optimization preventing unnecessary repeated resolution attempts |\n| **cache poisoning** | Security attack where false DNS data is injected into resolver cache | Security concern addressed by response validation |\n| **bailiwick** | Domain hierarchy validation ensuring DNS responses only contain records within the queried domain's authority | Security mechanism preventing cache poisoning |\n| **TTL expiration** | Process where cached DNS records become invalid after their time-to-live countdown reaches zero | Automatic cache management maintaining data freshness |\n| **cache hit rate** | Percentage of DNS queries served from cache without requiring resolution | Key performance metric for cache effectiveness |\n| **LRU eviction** | Least Recently Used cache replacement policy removing oldest entries when cache reaches capacity limits | Memory management strategy for bounded cache size |\n| **query coalescing** | Optimization technique sharing resolution work between concurrent identical queries | Performance optimization preventing duplicate resolution work |\n| **thundering herd** | Performance problem where many concurrent clients make identical requests during cache misses | Problem addressed by query coalescing |\n\n### Resolution Process and State Management\n\nThese terms describe the complex stateful processes involved in DNS resolution, particularly relevant to Milestone 3.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **resolution state** | Data structure tracking current progress through recursive resolution including visited servers and CNAME chains | State management for complex resolution processes |\n| **CNAME following** | Process of resolving alias chains to final target records by making additional queries | Algorithm required during recursive resolution |\n| **circular dependency** | Situation where nameserver resolution requires querying the nameserver itself | Problem solved by glue records |\n| **referral** | NS records in authority section directing resolver to query different nameservers | Core mechanism of iterative resolution |\n| **delegation** | Assignment of authority for subdomain to different nameservers using NS records | Organizational mechanism enabling distributed DNS |\n| **loop detection** | Algorithm preventing infinite loops during recursive resolution or CNAME following | Safety mechanism preventing resolver hang |\n| **compression loops** | Circular references in DNS name compression pointers creating infinite parsing loops | Parsing error requiring detection and recovery |\n\n### Error Handling and Protocol Compliance\n\nThese terms relate to error conditions, edge cases, and protocol compliance across all milestones.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **RCODE** | Response code field in DNS header indicating query outcome (NOERROR, NXDOMAIN, SERVFAIL, etc.) | Status communication in DNS protocol |\n| **NXDOMAIN** | DNS response code indicating queried domain name does not exist | Common negative response requiring special caching |\n| **SERVFAIL** | DNS response code indicating server encountered error processing query | Generic error response for internal failures |\n| **FORMERR** | DNS response code indicating query contained format errors | Response to malformed incoming queries |\n| **protocol violations** | DNS messages that deviate from RFC 1035 specifications | Error category requiring detection and appropriate responses |\n| **malformed queries** | DNS queries with invalid structure, incorrect lengths, or missing required fields | Input validation concern across all query processing |\n| **bounds checking** | Validation ensuring parsing operations don't read beyond buffer limits | Essential safety mechanism in binary protocol parsing |\n| **parse errors** | Failures during conversion of binary DNS messages to internal data structures | Error category specific to message parsing |\n| **truncation** | DNS mechanism indicating UDP response was too large and client should retry over TCP | Protocol feature for handling oversized responses |\n\n### Implementation and Architecture Concepts\n\nThese terms describe the internal architecture and implementation patterns used throughout the DNS server.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **parse state** | Data structure tracking current position and context during DNS message parsing | Implementation pattern for stateful parsing |\n| **message handler** | Component interface responsible for coordinating query processing between different resolution strategies | Architectural pattern for component integration |\n| **cache manager** | Component responsible for TTL-based caching, eviction, and memory management | Core component implementing caching functionality |\n| **zone data manager** | Component managing authoritative DNS records loaded from zone files | Core component for authoritative server functionality |\n| **query processing pipeline** | Sequence of operations from UDP packet receipt through parsing, resolution, and response transmission | Architectural pattern organizing request processing |\n| **component interface contracts** | Method signatures and data exchange formats between major system components | Design pattern ensuring loose coupling |\n| **context propagation** | Passing timeout and cancellation signals through component method calls | Concurrency pattern for request lifecycle management |\n| **concurrent query handling** | Processing multiple DNS requests simultaneously using goroutines or threads | Performance requirement for production DNS servers |\n| **atomic operations** | Thread-safe operations for updating statistics without explicit locking | Concurrency pattern for shared counter management |\n| **read-write mutex** | Synchronization primitive allowing concurrent reads but exclusive writes to shared data | Concurrency pattern for cache access |\n\n### Testing and Development Concepts\n\nThese terms relate to testing strategies, debugging techniques, and development practices across all milestones.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **milestone checkpoints** | Verification steps confirming correct behavior after completing each development phase | Development methodology ensuring incremental progress |\n| **unit testing** | Testing individual components in isolation with mock dependencies | Testing strategy for component verification |\n| **integration testing** | Testing interactions between components with real dependencies | Testing strategy for system behavior verification |\n| **mock network client** | Simulated network infrastructure for testing without external dependencies | Testing utility for controlled environment testing |\n| **race conditions** | Timing-dependent bugs in concurrent code where outcome depends on execution order | Common bug pattern in concurrent DNS server implementation |\n| **concurrent testing** | Validation of thread-safe behavior under concurrent load | Testing strategy for concurrency correctness |\n| **compression loop** | Specific bug where DNS pointer labels create circular references causing infinite parsing loops | Common parsing implementation bug |\n| **cache integration** | Thread-safe access to cached records with proper TTL management and synchronization | Implementation pattern for cache component usage |\n\n### Advanced DNS Concepts and Extensions\n\nThese terms relate to advanced DNS features and potential future enhancements beyond the core implementation.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **DNSSEC** | DNS Security Extensions providing cryptographic authentication of DNS responses | Advanced security feature for future implementation |\n| **EDNS** | Extension Mechanisms for DNS allowing larger messages, additional flags, and protocol extensions | Protocol extension for enhanced functionality |\n| **DNS-over-TLS (DoT)** | Encrypted DNS transport layer providing privacy and security | Modern DNS transport option |\n| **DNS-over-HTTPS (DoH)** | DNS queries embedded in HTTP/2 requests for privacy and firewall traversal | Alternative encrypted DNS transport |\n| **trust anchor** | Cryptographic root of trust for DNSSEC validation chain | Security concept for authenticated DNS |\n\n### Operational and Performance Terms\n\nThese terms describe operational aspects, monitoring, and production deployment considerations.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **metrics collection** | Gathering performance statistics, query counts, and operational health indicators | Production readiness feature for monitoring |\n| **cache warming** | Preloading cache with frequently accessed records to minimize cold start performance impact | Operational optimization technique |\n| **configuration management** | Dynamic server configuration updates without requiring restart | Operational requirement for production deployment |\n| **circuit breaking** | Pattern preventing cascading failures by stopping requests to consistently failing upstream services | Resilience pattern for production stability |\n| **exponential backoff** | Retry delay strategy that increases wait time after each failure attempt | Common retry pattern for network operations |\n| **blue-green deployment** | Deployment pattern using two identical environments for zero-downtime updates | Production deployment strategy |\n\n### Wire Protocol and Binary Parsing Terms\n\nThese terms describe low-level binary protocol handling essential for Milestone 1 implementation.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **DNS_HEADER_SIZE** | Constant value 12 representing fixed size of DNS message header in bytes | Binary protocol constant |\n| **DNS_UDP_MAX_SIZE** | Constant value 512 representing maximum DNS message size for UDP transport | Protocol limitation requiring truncation handling |\n| **endianness** | Byte order used in multi-byte values, with DNS using big-endian network byte order | Binary parsing consideration |\n| **null termination** | DNS name encoding requirement where domain names end with zero-length label | Protocol requirement for name parsing |\n| **type codes** | Numeric identifiers for DNS record types (A=1, AAAA=28, CNAME=5, etc.) | Protocol constants for record type identification |\n| **class codes** | Numeric identifiers for DNS classes, typically IN=1 for Internet class | Protocol constants rarely used beyond Internet class |\n\n### State Machine and Process Control Terms\n\nThese terms describe the state-driven aspects of DNS server operation and control flow.\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **query lifecycle** | Complete sequence of states from query receipt through parsing, resolution, caching, and response | Process model for understanding query handling |\n| **resolution priority** | Order of attempting authoritative lookup, cache lookup, and recursive resolution | Algorithm decision tree for query processing |\n| **error boundaries** | Isolation points preventing error propagation between system components | Architectural pattern for fault isolation |\n| **retry logic** | Automated mechanisms for recovering from transient network or server failures | Resilience pattern for unreliable network conditions |\n| **timeout handling** | Mechanisms for abandoning operations that exceed time limits | Essential for preventing hung requests |\n| **backpressure** | Flow control mechanism preventing overwhelming of downstream components | Performance pattern for load management |\n\n> **Design Insight: Terminology Precision Enables Clear Communication**\n> \n> The precision of these definitions directly impacts implementation success. When developers share exact meanings for terms like \"bailiwick validation\" or \"query coalescing,\" they can communicate complex architectural decisions unambiguously. Conversely, loose terminology leads to misunderstood requirements and subtle bugs.\n\n### Implementation Guidance\n\nThis glossary serves as the canonical reference for all technical terms throughout the DNS server implementation. When encountering unfamiliar terminology in code reviews, documentation, or debugging sessions, developers should refer to these definitions for authoritative understanding.\n\nThe terms are organized to support the milestone-driven development approach:\n\n- **Milestone 1 terms** focus on binary protocol parsing, message structure, and wire format concepts\n- **Milestone 2 terms** emphasize authoritative server concepts, zone data, and response construction\n- **Milestone 3 terms** center on recursive resolution, iterative queries, and DNS hierarchy traversal\n- **Milestone 4 terms** concentrate on caching strategies, performance optimization, and concurrent operations\n\nEach definition includes context about when and why the term is important, helping developers understand not just what concepts mean, but how they fit into the broader DNS server architecture. This contextual understanding proves invaluable when making implementation decisions or diagnosing system behavior.\n"}