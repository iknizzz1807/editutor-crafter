{"html":"<h1 id=\"build-your-own-docker-design-document\">Build Your Own Docker: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This document outlines the architecture for a container runtime that isolates processes using Linux primitives like namespaces, cgroups, and union filesystems. The key architectural challenge is orchestrating these low-level OS features into a coherent, secure, and user-friendly containerization system while maintaining compatibility with OCI standards.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (provides foundational understanding)</p>\n</blockquote>\n<h3 id=\"mental-model-apartments-in-a-building\">Mental Model: Apartments in a Building</h3>\n<p>Think of your computer&#39;s operating system as a large apartment building. Each <strong>process</strong> (a running program like a web server or database) is a <strong>tenant</strong> living in this building. By default, all tenants share common spaces and resources:</p>\n<ul>\n<li>They see the same <strong>directory of residents</strong> (process table)</li>\n<li>They share the same <strong>mailroom and packages</strong> (filesystem)</li>\n<li>They use the same <strong>utility meters</strong> (CPU, memory)</li>\n<li>They&#39;re connected to the same <strong>phone system</strong> (network)</li>\n<li>They have the same <strong>building nameplate</strong> (hostname)</li>\n</ul>\n<p>This shared arrangement causes problems. A noisy tenant (a buggy process consuming all memory) disturbs everyone. A tenant rummaging through the mailroom (a process reading sensitive files) violates privacy. If one tenant changes the building&#39;s nameplate (hostname), it changes for everyone.</p>\n<p><strong>Containerization</strong> is like giving each tenant their own fully-contained apartment unit within the same building:</p>\n<table>\n<thead>\n<tr>\n<th>Apartment Feature</th>\n<th>Container Equivalent</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Private walls</td>\n<td><strong>Namespaces</strong> (PID, network, mount)</td>\n<td>Tenants can&#39;t see or interfere with each other&#39;s activities</td>\n</tr>\n<tr>\n<td>Individual utility meters</td>\n<td><strong>cgroups</strong> (CPU, memory limits)</td>\n<td>No single tenant can monopolize building resources</td>\n</tr>\n<tr>\n<td>Custom furniture layout</td>\n<td><strong>Root filesystem</strong> (chroot/pivot_root)</td>\n<td>Each tenant can decorate their space without affecting others</td>\n</tr>\n<tr>\n<td>Layered wallpaper</td>\n<td><strong>Union filesystems</strong> (OverlayFS)</td>\n<td>Common decorative elements are shared, saving space</td>\n</tr>\n<tr>\n<td>Private phone line</td>\n<td><strong>Network namespace</strong> (veth pairs)</td>\n<td>Tenants have separate phone numbers and can&#39;t eavesdrop</td>\n</tr>\n</tbody></table>\n<p>The key architectural challenge is that while these apartments exist within the same physical building (the same Linux kernel), they must appear to be completely independent living spaces. The building superintendent (our container runtime) must:</p>\n<ol>\n<li>Construct these apartments on demand</li>\n<li>Install appropriate isolation features</li>\n<li>Connect utilities while maintaining separation</li>\n<li>Clean up when tenants leave</li>\n</ol>\n<p>This mental model helps understand why we need multiple Linux primitives working together: namespaces provide the walls, cgroups provide the resource meters, and filesystem isolation provides the private furnishings.</p>\n<h3 id=\"the-isolation-problem-in-concrete-terms\">The Isolation Problem in Concrete Terms</h3>\n<p>Consider a typical deployment scenario: you need to run a web application consisting of a Node.js API server, a PostgreSQL database, and a Redis cache on a single physical server. Without isolation, these three processes:</p>\n<ol>\n<li><strong>See each other&#39;s processes</strong> - The Node.js process can see and send signals to PostgreSQL workers</li>\n<li><strong>Share filesystem access</strong> - A bug in Redis could delete PostgreSQL data files</li>\n<li><strong>Compete for resources</strong> - A memory leak in Node.js could starve PostgreSQL of memory</li>\n<li><strong>Conflict on network ports</strong> - All three try to listen on port 80 or use the same loopback interface</li>\n<li><strong>Share host identity</strong> - All three report the same hostname to monitoring systems</li>\n</ol>\n<p>The isolation problem manifests in these concrete technical requirements:</p>\n<p><strong>Requirement 1: Process Visibility Isolation</strong></p>\n<ul>\n<li><strong>Problem</strong>: <code>ps aux</code> run from within the Node.js process shows PostgreSQL and Redis workers</li>\n<li><strong>Consequence</strong>: Accidental termination, security exposure of process arguments</li>\n<li><strong>Solution Needed</strong>: Private process ID space where the containerized process sees itself as PID 1</li>\n</ul>\n<p><strong>Requirement 2: Filesystem Boundary Enforcement</strong></p>\n<ul>\n<li><strong>Problem</strong>: A path traversal bug in the web application allows reading <code>/etc/shadow</code></li>\n<li><strong>Consequence</strong>: Complete system compromise via credential theft</li>\n<li><strong>Solution Needed</strong>: A virtual root directory that appears to be the entire filesystem</li>\n</ul>\n<p><strong>Requirement 3: Resource Fairness Guarantees</strong></p>\n<ul>\n<li><strong>Problem</strong>: Redis cache grows uncontrollably and triggers system-wide Out-Of-Memory killer</li>\n<li><strong>Consequence</strong>: Random important processes (SSH daemon, system logger) get killed</li>\n<li><strong>Solution Needed</strong>: Hard memory limits that only affect the offending container</li>\n</ul>\n<p><strong>Requirement 4: Network Stack Separation</strong></p>\n<ul>\n<li><strong>Problem</strong>: Redis binds to <code>127.0.0.1:6379</code>, preventing PostgreSQL from using loopback for replication</li>\n<li><strong>Consequence</strong>: Service conflicts, inability to run multiple instances</li>\n<li><strong>Solution Needed</strong>: Private network interfaces and routing tables per container</li>\n</ul>\n<p><strong>Requirement 5: Host Identity Segregation</strong></p>\n<ul>\n<li><strong>Problem</strong>: All services report the same hostname to centralized logging</li>\n<li><strong>Consequence</strong>: Debugging nightmare, monitoring confusion</li>\n<li><strong>Solution Needed</strong>: Independent UTS (Unix Timesharing System) namespace</li>\n</ul>\n<p>The following table illustrates how these isolation failures manifest in practice:</p>\n<table>\n<thead>\n<tr>\n<th>Isolation Failure</th>\n<th>Symptom</th>\n<th>Attack Vector</th>\n<th>Business Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PID namespace</td>\n<td>Container process kills host <code>systemd</code></td>\n<td>Malicious container sends <code>SIGKILL</code> to PID 1</td>\n<td>System crash, requiring physical access</td>\n</tr>\n<tr>\n<td>Mount namespace</td>\n<td>Container modifies host <code>/etc/passwd</code></td>\n<td>Path traversal or symlink attack</td>\n<td>Complete system compromise</td>\n</tr>\n<tr>\n<td>Network namespace</td>\n<td>Container sniffs other containers&#39; traffic</td>\n<td>ARP spoofing in shared network</td>\n<td>Data breach across tenants</td>\n</tr>\n<tr>\n<td>cgroup failure</td>\n<td>Container triggers host OOM killer</td>\n<td>Memory exhaustion attack</td>\n<td>Service outage for all containers</td>\n</tr>\n<tr>\n<td>UTS namespace</td>\n<td>Container changes system hostname</td>\n<td>Service masquerading</td>\n<td>Monitoring/alerting system failure</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: Isolation isn&#39;t just about security—it&#39;s about predictability. The fundamental value proposition of containers is that they provide <strong>predictable, reproducible execution environments</strong> regardless of the underlying host system configuration.</p>\n</blockquote>\n<h3 id=\"existing-isolation-approaches-comparison\">Existing Isolation Approaches Comparison</h3>\n<p>Before containers became mainstream, several approaches addressed isolation with different trade-offs in security, performance, and complexity. Understanding these alternatives clarifies why the Linux namespace+cgroup approach prevailed for application packaging and deployment.</p>\n<p><strong>Approach 1: Physical Servers</strong>\nThe most complete isolation but maximum overhead.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Physical Server</th>\n<th>Container</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Isolation Level</strong></td>\n<td>Complete physical separation</td>\n<td>Kernel-level logical separation</td>\n</tr>\n<tr>\n<td><strong>Startup Time</strong></td>\n<td>Minutes to hours</td>\n<td>Milliseconds to seconds</td>\n</tr>\n<tr>\n<td><strong>Resource Efficiency</strong></td>\n<td>Poor (idle resources wasted)</td>\n<td>Excellent (shared kernel, dynamic allocation)</td>\n</tr>\n<tr>\n<td><strong>Density</strong></td>\n<td>1 application per server</td>\n<td>10s-100s per server</td>\n</tr>\n<tr>\n<td><strong>Operational Overhead</strong></td>\n<td>High (individual maintenance)</td>\n<td>Low (orchestrated management)</td>\n</tr>\n<tr>\n<td><strong>Use Case</strong></td>\n<td>Legacy applications, maximum security</td>\n<td>Microservices, CI/CD, PaaS</td>\n</tr>\n</tbody></table>\n<p><strong>Approach 2: Virtual Machines (VMs)</strong>\nHardware-level virtualization with guest operating systems.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Virtual Machine</th>\n<th>Container</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Abstraction Level</strong></td>\n<td>Hardware (CPU, memory, devices)</td>\n<td>Operating system (processes, files, network)</td>\n</tr>\n<tr>\n<td><strong>Guest OS</strong></td>\n<td>Full independent kernel</td>\n<td>Shared host kernel</td>\n</tr>\n<tr>\n<td><strong>Isolation Mechanism</strong></td>\n<td>Hypervisor + VM boundaries</td>\n<td>Linux namespaces + cgroups</td>\n</tr>\n<tr>\n<td><strong>Overhead</strong></td>\n<td>Higher (full OS + virtualization)</td>\n<td>Lower (direct syscalls)</td>\n</tr>\n<tr>\n<td><strong>Image Size</strong></td>\n<td>GBs (entire OS)</td>\n<td>MBs (app + dependencies)</td>\n</tr>\n<tr>\n<td><strong>Boot Time</strong></td>\n<td>Seconds to minutes</td>\n<td>Sub-second</td>\n</tr>\n<tr>\n<td><strong>Security Boundary</strong></td>\n<td>Strong (hardware isolation)</td>\n<td>Weaker (kernel shared)</td>\n</tr>\n<tr>\n<td><strong>Use Case</strong></td>\n<td>Multi-OS environments, strong isolation</td>\n<td>Single-OS app packaging, high density</td>\n</tr>\n</tbody></table>\n<p><strong>Approach 3: chroot Jails</strong>\nFilesystem isolation only—the historical precursor.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>chroot Jail</th>\n<th>Container</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Filesystem Isolation</strong></td>\n<td>Yes (but escapable)</td>\n<td>Yes (with mount namespace)</td>\n</tr>\n<tr>\n<td><strong>Process Isolation</strong></td>\n<td>No (shared PID space)</td>\n<td>Yes (PID namespace)</td>\n</tr>\n<tr>\n<td><strong>Network Isolation</strong></td>\n<td>No (shared stack)</td>\n<td>Yes (network namespace)</td>\n</tr>\n<tr>\n<td><strong>Resource Limits</strong></td>\n<td>No</td>\n<td>Yes (cgroups)</td>\n</tr>\n<tr>\n<td><strong>Security</strong></td>\n<td>Weak (many escape vectors)</td>\n<td>Moderate (with seccomp, SELinux)</td>\n</tr>\n<tr>\n<td><strong>Complexity</strong></td>\n<td>Low</td>\n<td>Moderate</td>\n</tr>\n<tr>\n<td><strong>Modern Relevance</strong></td>\n<td>Legacy, specialized use cases</td>\n<td>Standard application deployment</td>\n</tr>\n</tbody></table>\n<p><strong>Approach 4: BSD Jails / Solaris Zones</strong>\nOS-level containerization in other Unix variants.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>BSD Jails</th>\n<th>Linux Containers</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>OS Family</strong></td>\n<td>BSD derivatives (FreeBSD)</td>\n<td>Linux</td>\n</tr>\n<tr>\n<td><strong>Isolation Model</strong></td>\n<td>Single unified jail mechanism</td>\n<td>Composition of independent namespaces</td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>Centralized jail configuration</td>\n<td>Distributed across multiple subsystems</td>\n</tr>\n<tr>\n<td><strong>Ecosystem</strong></td>\n<td>Smaller tooling ecosystem</td>\n<td>Vast (Docker, Kubernetes, etc.)</td>\n</tr>\n<tr>\n<td><strong>Adoption</strong></td>\n<td>Niche, specialized deployments</td>\n<td>Industry standard</td>\n</tr>\n</tbody></table>\n<p><strong>Approach 5: Application Sandboxing (Firejail, Bubblewrap)</strong>\nUser-space containment for desktop applications.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Application Sandbox</th>\n<th>System Container</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Target Use Case</strong></td>\n<td>Desktop applications</td>\n<td>Server applications</td>\n</tr>\n<tr>\n<td><strong>Privilege Level</strong></td>\n<td>Often user namespace only</td>\n<td>Full root capabilities</td>\n</tr>\n<tr>\n<td><strong>Orchestration</strong></td>\n<td>Manual, per-application</td>\n<td>Automated, cluster-wide</td>\n</tr>\n<tr>\n<td><strong>Networking</strong></td>\n<td>Typically shared</td>\n<td>Configurable topologies</td>\n</tr>\n<tr>\n<td><strong>Image Format</strong></td>\n<td>None (uses host files)</td>\n<td>Standardized (OCI)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision Record: Choosing Linux Primitives Over Alternatives</strong></p>\n</blockquote>\n<p><strong>Decision: Use Linux namespaces + cgroups for container isolation</strong></p>\n<p><strong>Context</strong>: We need to build a container runtime for educational purposes that demonstrates real-world containerization principles while running efficiently on commodity Linux systems.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Full virtualization (KVM/QEMU)</strong> - Complete isolation via hardware virtualization</li>\n<li><strong>User-space virtualization (gVisor)</strong> - Syscall interception for stronger security</li>\n<li><strong>Linux namespaces + cgroups</strong> - Native kernel features for OS-level virtualization</li>\n</ol>\n<p><strong>Decision</strong>: Implement using Linux namespaces and cgroups.</p>\n<p><strong>Rationale</strong>:</p>\n<ol>\n<li><strong>Educational value</strong>: Namespaces and cgroups are the foundational primitives underlying Docker, LXC, and Kubernetes, making this knowledge transferable to production systems.</li>\n<li><strong>Minimal overhead</strong>: No hypervisor layer or syscall translation means near-native performance for learning resource management concepts.</li>\n<li><strong>Incremental complexity</strong>: Each primitive (PID, mount, network namespaces) can be implemented and tested independently, matching our milestone-based approach.</li>\n<li><strong>Ubiquitous availability</strong>: Available on any modern Linux kernel without special hardware support (VT-x/AMD-V).</li>\n<li><strong>Compatibility with OCI</strong>: The Open Container Initiative runtime specification expects these Linux primitives.</li>\n</ol>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: Learners understand the actual mechanisms used by Docker, can debug production container issues, and gain low-level Linux systems knowledge.</li>\n<li><strong>Negative</strong>: Limited to Linux hosts, requires root privileges, and provides weaker security boundaries than virtualization (though can be enhanced with seccomp, SELinux).</li>\n<li><strong>Trade-off</strong>: We accept platform limitation for deeper understanding of the dominant containerization technology.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Full Virtualization</strong></td>\n<td>Strong isolation, multi-OS support, mature security model</td>\n<td>High overhead, slow startup, complex implementation</td>\n<td>Overkill for application packaging, obscures the Linux primitives we want to teach</td>\n</tr>\n<tr>\n<td><strong>User-space Virtualization</strong></td>\n<td>Strong security via syscall filtering, no kernel sharing</td>\n<td>Performance overhead, compatibility issues with some syscalls</td>\n<td>Adds abstraction layer that hides the underlying Linux mechanisms</td>\n</tr>\n<tr>\n<td><strong>Linux Primitives</strong></td>\n<td>Native performance, direct kernel interaction, industry standard</td>\n<td>Weaker isolation, Linux-only, requires privileged operations</td>\n<td><strong>CHOSEN</strong>: Best for educational goals, matches real-world container runtimes</td>\n</tr>\n</tbody></table>\n<p><strong>The Evolution to Modern Containers</strong>:</p>\n<p>The containerization approach we&#39;re implementing represents an evolutionary convergence of several historical threads:</p>\n<ol>\n<li><strong>2000: FreeBSD Jails</strong> - Introduced the concept of OS-level virtualization</li>\n<li><strong>2005: Solaris Zones</strong> - Commercial implementation with resource controls</li>\n<li><strong>2008: LXC (Linux Containers)</strong> - First complete container implementation for Linux</li>\n<li><strong>2013: Docker</strong> - Developer-friendly tooling and image format</li>\n<li><strong>2015: OCI Specification</strong> - Standardization of runtime and image formats</li>\n<li><strong>2017: Kubernetes dominance</strong> - Orchestration ecosystem maturation</li>\n</ol>\n<p>Our implementation follows the architectural pattern established by LXC and standardized by OCI: composing discrete Linux kernel features into a coherent isolation boundary. This composition is both a strength (flexibility, incremental adoption) and a complexity (multiple subsystems to configure correctly).</p>\n<p><strong>Common Misconceptions About Container Isolation</strong>:</p>\n<p>⚠️ <strong>Pitfall: Assuming containers provide VM-level security</strong></p>\n<ul>\n<li><strong>Misconception</strong>: &quot;My containers are as isolated as virtual machines&quot;</li>\n<li><strong>Reality</strong>: Containers share the kernel, making kernel exploits catastrophic</li>\n<li><strong>Fix</strong>: Use additional hardening (seccomp profiles, SELinux, user namespaces) for production</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Believing cgroups prevent all resource exhaustion</strong></p>\n<ul>\n<li><strong>Misconception</strong>: &quot;Memory limit protects against all memory issues&quot;</li>\n<li><strong>Reality</strong>: cgroups memory limit doesn&#39;t cover page cache, swap, or kernel memory</li>\n<li><strong>Fix</strong>: Set multiple limits (<code>memory.limit_in_bytes</code>, <code>memory.kmem.limit_in_bytes</code>)</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Thinking network namespace equals network security</strong></p>\n<ul>\n<li><strong>Misconception</strong>: &quot;Network namespace prevents all network attacks&quot;</li>\n<li><strong>Reality</strong>: Containers on same bridge can ARP spoof each other</li>\n<li><strong>Fix</strong>: Use network policies, ebtables rules, or separate bridges</li>\n</ul>\n<p>The following table summarizes how our container runtime addresses these historical approaches&#39; limitations:</p>\n<table>\n<thead>\n<tr>\n<th>Historical Limitation</th>\n<th>Our Solution</th>\n<th>Implementation Component</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>chroot escape via <code>..</code></td>\n<td>Mount namespace + pivot_root</td>\n<td>Milestone 3</td>\n</tr>\n<tr>\n<td>Resource monopolization</td>\n<td>cgroups with memory/CPU limits</td>\n<td>Milestone 2</td>\n</tr>\n<tr>\n<td>Process visibility</td>\n<td>PID namespace</td>\n<td>Milestone 1</td>\n</tr>\n<tr>\n<td>Network port conflicts</td>\n<td>Network namespace + veth pairs</td>\n<td>Milestone 5</td>\n</tr>\n<tr>\n<td>Storage inefficiency</td>\n<td>OverlayFS layered filesystem</td>\n<td>Milestone 4</td>\n</tr>\n<tr>\n<td>Non-standard formats</td>\n<td>OCI image specification</td>\n<td>Milestone 6</td>\n</tr>\n</tbody></table>\n<p>By understanding this context, learners appreciate that containerization isn&#39;t a revolutionary new technology but rather a clever composition of existing Linux features with developer-friendly tooling. This composition approach is what makes containers simultaneously powerful (leveraging decades of OS research) and accessible (hiding the complexity behind simple commands).</p>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (providing foundational requirements and scope boundaries)</p>\n</blockquote>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<p>This section establishes clear boundaries for what our container runtime will and will not accomplish. Building a production-grade container runtime like Docker involves immense complexity; our educational implementation focuses on the core isolation primitives while deliberately excluding enterprise features. These definitions serve as guardrails throughout development, ensuring we build something complete enough to demonstrate containerization concepts while remaining achievable within educational constraints.</p>\n<h3 id=\"must-have-goals\">Must-Have Goals</h3>\n<p>The following capabilities represent the non-negotiable requirements for our container runtime. Each goal maps directly to one or more milestones and implements a fundamental containerization concept.</p>\n<table>\n<thead>\n<tr>\n<th>Goal</th>\n<th>Milestone</th>\n<th>Concept Demonstrated</th>\n<th>User Benefit</th>\n<th>Implementation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Process Isolation via Namespaces</strong></td>\n<td>1</td>\n<td>Kernel-level isolation of global system resources</td>\n<td>Processes cannot see or interfere with other containers or the host system</td>\n<td>Create PID, UTS, mount, network, and IPC namespaces using <code>clone()</code> or <code>unshare()</code> system calls</td>\n</tr>\n<tr>\n<td><strong>Resource Limiting via cgroups</strong></td>\n<td>2</td>\n<td>Enforce CPU, memory, and process count limits</td>\n<td>Prevent any single container from monopolizing system resources</td>\n<td>Create cgroup hierarchy, write limit values to control files, attach container processes</td>\n</tr>\n<tr>\n<td><strong>Filesystem Isolation via pivot_root</strong></td>\n<td>3</td>\n<td>Provide containers with their own root filesystem</td>\n<td>Container sees only its own files, cannot access host filesystem</td>\n<td>Extract base image, set up mount namespace, call <code>pivot_root()</code>, mount <code>/proc</code> and <code>/sys</code></td>\n</tr>\n<tr>\n<td><strong>Copy-on-Write Layers via OverlayFS</strong></td>\n<td>4</td>\n<td>Efficient storage and sharing of container images</td>\n<td>Multiple containers can share common base layers, saving disk space</td>\n<td>Configure OverlayFS mounts with lower (read-only), upper (writable), and work directories</td>\n</tr>\n<tr>\n<td><strong>Container Networking via veth pairs</strong></td>\n<td>5</td>\n<td>Isolated network stack with external connectivity</td>\n<td>Containers get private IP addresses and can communicate with each other and the internet</td>\n<td>Create network namespace, set up veth pair, configure bridge, add iptables NAT rules</td>\n</tr>\n<tr>\n<td><strong>OCI Image Compatibility</strong></td>\n<td>6</td>\n<td>Standardized container image format</td>\n<td>Can run containers from images built by Docker and other OCI-compliant tools</td>\n<td>Parse OCI image manifests, download layers from registries, follow layer extraction specifications</td>\n</tr>\n<tr>\n<td><strong>Basic CLI Lifecycle Management</strong></td>\n<td>6</td>\n<td>Command-line interface for container operations</td>\n<td>Users can create, start, stop, and remove containers with simple commands</td>\n<td>Implement <code>create</code>, <code>start</code>, <code>stop</code>, <code>remove</code> commands with appropriate state transitions</td>\n</tr>\n<tr>\n<td><strong>Clean Resource Cleanup</strong></td>\n<td>All</td>\n<td>Proper cleanup of all isolation primitives</td>\n<td>No orphaned namespaces, cgroups, or network interfaces after container removal</td>\n<td>Track all created resources and implement cleanup handlers for all termination paths</td>\n</tr>\n<tr>\n<td><strong>Educational Clarity</strong></td>\n<td>All</td>\n<td>Code demonstrates concepts clearly</td>\n<td>Learners understand how each Linux primitive contributes to containerization</td>\n<td>Well-commented code, minimal abstraction layers, explicit error handling</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> These goals form a <strong>minimum viable container runtime</strong>—enough to demonstrate how Docker works under the hood without implementing the complete feature set of production container runtimes. Each goal directly corresponds to a specific Linux kernel feature that containers rely upon.</p>\n</blockquote>\n<p><strong>Architecture Decision Record: Scope of Implementation</strong></p>\n<p><strong>Decision: Build an Educational Implementation Rather Than Production-Grade</strong></p>\n<ul>\n<li><strong>Context</strong>: This project aims to teach container internals, not to compete with Docker, containerd, or runc. Learners need to understand the fundamental Linux primitives without getting overwhelmed by enterprise features.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Full OCI Runtime Implementation</strong>: Implement complete OCI runtime specification including all optional features, hooks, and security configurations.</li>\n<li><strong>Educational Subset</strong>: Implement only the core primitives that demonstrate container concepts, skipping complex edge cases and optimization.</li>\n<li><strong>Docker-Compatible CLI</strong>: Build a Docker CLI clone with identical command structure and flags.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Choose option 2 (Educational Subset) with basic OCI compatibility for image handling.</li>\n<li><strong>Rationale</strong>: <ul>\n<li>Learning objectives focus on understanding namespaces, cgroups, and filesystem isolation, not production deployment concerns.</li>\n<li>A simpler implementation reduces cognitive load, allowing learners to focus on core concepts.</li>\n<li>Basic OCI compatibility demonstrates real-world standards without requiring full spec compliance.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Cannot run all Docker images (some require features we don&#39;t implement).</li>\n<li>Performance and security are not production-grade.</li>\n<li>Learners gain deep understanding of fundamentals that apply to all container runtimes.</li>\n</ul>\n</li>\n</ul>\n<p><strong>The Must-Have Goals in Practice:</strong></p>\n<p>For each goal, we define concrete success criteria:</p>\n<ol>\n<li><p><strong>Process Isolation Success</strong>: When running <code>ps aux</code> inside a container, the process list shows only processes within that container, with the container process as PID 1. Changing the hostname inside the container (<code>hostname mycontainer</code>) doesn&#39;t affect the host.</p>\n</li>\n<li><p><strong>Resource Limiting Success</strong>: A container configured with 100MB memory limit gets terminated by the OOM killer when it allocates 101MB. A container with CPU shares of 512 gets approximately half the CPU time of a container with 1024 shares under contention.</p>\n</li>\n<li><p><strong>Filesystem Isolation Success</strong>: A container cannot read <code>/etc/hostname</code> from the host filesystem. The container&#39;s <code>/</code> directory shows files from the container image, not host files.</p>\n</li>\n<li><p><strong>Layered Filesystem Success</strong>: Two containers using the same base Ubuntu image share the read-only layers on disk. When one container modifies a file, the other container still sees the original version.</p>\n</li>\n<li><p><strong>Networking Success</strong>: Containers get IP addresses like <code>172.17.0.2</code> and can ping each other. Containers can access the internet via NAT. Host can forward port 8080 to a container&#39;s port 80.</p>\n</li>\n<li><p><strong>Image Compatibility Success</strong>: Can pull and run <code>alpine:latest</code> from Docker Hub. The container runs the correct entrypoint command with the expected environment.</p>\n</li>\n<li><p><strong>CLI Success</strong>: Users can run <code>./byod run -it ubuntu:latest /bin/bash</code> and get an interactive shell in a container, then exit and clean up with <code>./byod rm &lt;container-id&gt;</code>.</p>\n</li>\n</ol>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>The following capabilities are explicitly <strong>not</strong> part of our implementation. Understanding what we&#39;re omitting is as important as understanding what we&#39;re including—it defines the boundaries of our learning exercise.</p>\n<table>\n<thead>\n<tr>\n<th>Non-Goal</th>\n<th>Reason for Exclusion</th>\n<th>Real-World Implementation (for context)</th>\n<th>What We Do Instead</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Production Security Hardening</strong></td>\n<td>Security is a complex domain requiring expertise beyond educational scope. Our implementation runs as root and doesn&#39;t implement security best practices.</td>\n<td>Docker uses seccomp, SELinux/AppArmor, capabilities dropping, user namespaces with ID mapping</td>\n<td>Run containers as root without additional security constraints; assume trusted environment</td>\n</tr>\n<tr>\n<td><strong>Orchestration Features</strong></td>\n<td>Container orchestration (scheduling, service discovery, load balancing) is a separate domain from container runtime fundamentals.</td>\n<td>Kubernetes, Docker Swarm, Nomad manage container lifecycle across hosts</td>\n<td>Single-host runtime only; no clustering or scheduling</td>\n</tr>\n<tr>\n<td><strong>Volume Management</strong></td>\n<td>Persistent storage involves complex lifecycle management and driver plugins beyond core isolation concepts.</td>\n<td>Docker volumes with various storage drivers (local, NFS, cloud storage)</td>\n<td>No persistent volume support; all container filesystem changes are ephemeral (in upper layer)</td>\n</tr>\n<tr>\n<td><strong>Container Registry Server</strong></td>\n<td>Building a registry server duplicates effort and doesn&#39;t teach container runtime fundamentals.</td>\n<td>Docker Registry, Amazon ECR, Google Container Registry</td>\n<td>Client-only implementation that pulls from existing registries (Docker Hub)</td>\n</tr>\n<tr>\n<td><strong>Windows/MacOS Support</strong></td>\n<td>Container internals differ fundamentally on non-Linux systems; our focus is Linux primitives.</td>\n<td>Docker Desktop uses Linux VMs on Windows/Mac</td>\n<td>Linux-only implementation requiring Linux kernel features</td>\n</tr>\n<tr>\n<td><strong>GPU/Device Passthrough</strong></td>\n<td>Specialized hardware access requires complex driver integration and security considerations.</td>\n<td>NVIDIA Container Toolkit, device plugins in Kubernetes</td>\n<td>No device passthrough; containers access only standard virtual devices</td>\n</tr>\n<tr>\n<td><strong>Live Migration</strong></td>\n<td>Process migration across hosts involves complex memory and filesystem synchronization beyond educational scope.</td>\n<td>CRIU (Checkpoint/Restore In Userspace) for container migration</td>\n<td>Single-host containers that cannot be checkpointed or migrated</td>\n</tr>\n<tr>\n<td><strong>Logging and Monitoring Infrastructure</strong></td>\n<td>Production observability requires distributed systems design for log aggregation and metrics collection.</td>\n<td>Docker logging drivers, Prometheus metrics, Fluentd log forwarding</td>\n<td>Simple stdout/stderr capture to terminal; no log persistence or metrics</td>\n</tr>\n<tr>\n<td><strong>Image Build System</strong></td>\n<td>Building images involves Dockerfile parsing, layer caching, and optimization strategies that warrant separate focus.</td>\n<td>Docker Build, BuildKit, Kaniko</td>\n<td>Pull and run pre-built images only; no <code>docker build</code> equivalent</td>\n</tr>\n<tr>\n<td><strong>Networking Plugins</strong></td>\n<td>Advanced networking (overlay networks, service mesh, network policies) requires complex network virtualization.</td>\n<td>CNI plugins, Calico, Flannel, Weave Net</td>\n<td>Single bridge network with NAT; no plugin system or advanced topologies</td>\n</tr>\n<tr>\n<td><strong>Resource Quota Enforcement</strong></td>\n<td>Fine-grained resource accounting (disk I/O, network bandwidth) requires complex cgroup controllers.</td>\n<td>Docker uses blkio, net_cls, and net_prio cgroup controllers</td>\n<td>Basic CPU and memory limits only; no I/O or network bandwidth limiting</td>\n</tr>\n<tr>\n<td><strong>Health Checks and Liveness Probes</strong></td>\n<td>Container health monitoring requires process supervision and restart policies beyond simple process execution.</td>\n<td>Docker HEALTHCHECK instruction, Kubernetes liveness/readiness probes</td>\n<td>No health monitoring; container runs until main process exits</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Important Boundary:</strong> By explicitly stating these non-goals, we acknowledge that real container runtimes are far more complex than our implementation. This allows learners to focus on the fundamentals while understanding where additional complexity would be needed for production use.</p>\n</blockquote>\n<p><strong>Common Pitfalls to Avoid Given Our Non-Goals:</strong></p>\n<ol>\n<li><p>⚠️ <strong>Pitfall: Attempting to Implement Security Features Prematurely</strong></p>\n<ul>\n<li><strong>Description</strong>: Learners might try to add user namespace mapping or seccomp profiles before mastering basic namespace isolation.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Adds unnecessary complexity when we&#39;re still learning fundamentals. Security without understanding the base isolation is fragile.</li>\n<li><strong>Fix</strong>: Focus on making basic isolation work first. Add security features only after core functionality is stable.</li>\n</ul>\n</li>\n<li><p>⚠️ <strong>Pitfall: Over-Engineering the CLI</strong></p>\n<ul>\n<li><strong>Description</strong>: Spending excessive time building a Docker-compatible CLI with all flags and subcommands.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Distracts from the core learning objective of understanding Linux primitives. The CLI is just an interface to the runtime.</li>\n<li><strong>Fix</strong>: Implement minimal CLI with just <code>run</code>, <code>ps</code>, <code>stop</code>, and <code>rm</code> commands. Use simple flag parsing.</li>\n</ul>\n</li>\n<li><p>⚠️ <strong>Pitfall: Adding Orchestration Features</strong></p>\n<ul>\n<li><strong>Description</strong>: Trying to implement multi-container applications or inter-container networking beyond basic bridge networking.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Orchestration builds upon container runtime fundamentals but is a separate layer of abstraction.</li>\n<li><strong>Fix</strong>: Focus on single-container isolation. Multi-container coordination is out of scope.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Design Accommodations for Future Extensions:</strong></p>\n<p>While these are non-goals for the initial implementation, our architecture should not preclude adding them later:</p>\n<ol>\n<li><p><strong>Security Features</strong>: The <code>ContainerConfig</code> type includes fields that could be extended for security settings (capabilities, seccomp profiles, user namespace mappings).</p>\n</li>\n<li><p><strong>Volume Support</strong>: The <code>FilesystemManager.SetupRootfs</code> method could be extended to mount additional volumes before container start.</p>\n</li>\n<li><p><strong>Advanced Networking</strong>: The <code>NetworkConfig</code> type&#39;s <code>Mode</code> field could support values beyond &quot;bridge&quot; (e.g., &quot;host&quot;, &quot;none&quot;, &quot;overlay&quot;).</p>\n</li>\n<li><p><strong>Logging</strong>: The <code>Container</code> struct could include log file paths, and the runtime could redirect stdout/stderr to files.</p>\n</li>\n</ol>\n<p>These accommodations mean we choose extensible designs even for features we don&#39;t implement, following good software design principles while maintaining focus on educational objectives.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Recommended)</th>\n<th>Advanced Option (If Time Permits)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CLI Parsing</td>\n<td><code>flag</code> package (Go standard library)</td>\n<td><code>cobra</code> library for richer CLI experience</td>\n</tr>\n<tr>\n<td>Image Registry Client</td>\n<td>HTTP client with basic auth for Docker Hub</td>\n<td>Full OCI distribution client with token auth</td>\n</tr>\n<tr>\n<td>JSON Parsing</td>\n<td><code>encoding/json</code> for OCI manifests</td>\n<td>Streaming JSON parser for large manifests</td>\n</tr>\n<tr>\n<td>Process Management</td>\n<td><code>os/exec</code> for host process management</td>\n<td>Direct syscall usage for finer control</td>\n</tr>\n<tr>\n<td>Network Configuration</td>\n<td><code>netlink</code> library for veth creation</td>\n<td>Raw socket operations for custom networking</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>build-your-own-docker/\n├── cmd/\n│   └── byod/                    # CLI entry point\n│       └── main.go              # CLI command parsing and routing\n├── internal/\n│   ├── runtime/                 # Core container runtime\n│   │   ├── runtime.go           # ContainerRuntime implementation\n│   │   ├── container.go         # Container struct and lifecycle methods\n│   │   └── state.go             # ContainerState enum and state machine logic\n│   ├── namespaces/              # Milestone 1: Process isolation\n│   │   ├── manager.go           # NamespaceManager implementation\n│   │   └── flags.go             # Namespace flag constants and helpers\n│   ├── cgroups/                 # Milestone 2: Resource limits\n│   │   ├── manager.go           # CgroupManager implementation\n│   │   ├── v1/                  # cgroup v1 implementation\n│   │   └── v2/                  # cgroup v2 implementation\n│   ├── filesystem/              # Milestones 3 &amp; 4: Filesystem isolation\n│   │   ├── manager.go           # FilesystemManager implementation\n│   │   ├── rootfs.go            # pivot_root and mount setup\n│   │   └── overlay.go           # OverlayFS layer management\n│   ├── network/                 # Milestone 5: Container networking\n│   │   ├── manager.go           # NetworkManager implementation\n│   │   ├── veth.go              # Virtual ethernet pair creation\n│   │   └── bridge.go            # Bridge network setup\n│   ├── image/                   # Milestone 6: OCI image handling\n│   │   ├── manager.go           # Image pull and parse\n│   │   ├── oci/                 # OCI spec structures\n│   │   └── registry/            # Registry client\n│   └── storage/                 # Container and image storage\n│       ├── store.go             # Persistent storage interface\n│       └── jsonfile/            # JSON file-based storage implementation\n├── pkg/\n│   └── types/                   # Shared data types\n│       ├── container.go         # Container, ContainerConfig types\n│       ├── image.go             # Image, ImageLayer types\n│       └── network.go           # NetworkConfig, PortMapping types\n└── scripts/                     # Helper scripts for testing\n    ├── test-isolation.sh        # Test namespace isolation\n    └── setup-bridge.sh          # Setup bridge network for testing</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete, ready to use):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/types/container.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCreated</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateRunning</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"running\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatePaused</span><span style=\"color:#B392F0\">  ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paused\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateStopped</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"stopped\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateRemoved</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"removed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Container</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State     </span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#9ECBFF\"> `json:\"state\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Config    </span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#9ECBFF\"> `json:\"config\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pid       </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `json:\"pid,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Image      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"image\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cmd        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"cmd\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Env        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"env\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"working_dir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Hostname   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"hostname\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limits     </span><span style=\"color:#B392F0\">ResourceLimits</span><span style=\"color:#9ECBFF\"> `json:\"limits\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Network    </span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#9ECBFF\">  `json:\"network\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryMB  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"memory_mb\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPUShares </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"cpu_shares\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PidsLimit </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"pids_limit\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Mode         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"mode\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BridgeName   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"bridge_name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"ip_address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#9ECBFF\"> `json:\"port_mappings\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PortMapping</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HostPort      </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"host_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerPort </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"container_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Protocol      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"protocol\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/runtime/runtime.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-org/byod/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerRuntime</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add other managers as fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewContainerRuntime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize the ContainerRuntime struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up the containers map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize any sub-managers (namespace, cgroup, filesystem, network)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the initialized runtime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate the ContainerConfig (check required fields)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate a unique container ID (use UUID or hash)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create Container struct with initial state (StateCreated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Store the container in runtime's container map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set up container root directory in filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return the created container or error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">{}, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up container by ID, return error if not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check container is in StateCreated or StateStopped (valid start states)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update container state to StateRunning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create namespaces for the container (using NamespaceManager)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set up cgroups with resource limits (using CgroupManager)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set up root filesystem with pivot_root (using FilesystemManager)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Configure network namespace (using NetworkManager)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Execute the container's entrypoint command inside the namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Record the container's PID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Handle errors and cleanup if any step fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StopContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up container by ID, return error if not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check container is in StateRunning (can't stop non-running containers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send SIGTERM to container process (use the recorded PID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for process to exit (with timeout)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If timeout, send SIGKILL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update container state to StateStopped</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Clean up network namespace (but keep other resources for possible restart)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Handle errors appropriately</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up container by ID, return error if not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check container is in StateStopped or StateCreated (can't remove running)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If container has root filesystem, clean it up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove cgroup hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove container from runtime's container map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update container state to StateRemoved</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Handle errors and ensure cleanup is idempotent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ol>\n<li><p><strong>Go syscall Package</strong>: Use <code>syscall.Syscall</code> or <code>syscall.RawSyscall</code> for direct system calls like <code>clone()</code>, <code>unshare()</code>, and <code>pivot_root()</code>.</p>\n</li>\n<li><p><strong>Namespace Flags</strong>: Use the exact constants from the naming conventions: <code>syscall.CLONE_NEWPID</code>, <code>syscall.CLONE_NEWNET</code>, etc.</p>\n</li>\n<li><p><strong>Process Execution</strong>: Use <code>syscall.Exec</code> to replace the current process with the container&#39;s entrypoint, not <code>os/exec.Command</code> which creates a child process.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Check <code>errno</code> values after syscalls using <code>syscall.Errno</code> type to determine specific failure reasons.</p>\n</li>\n<li><p><strong>File Operations</strong>: Use <code>os</code> package for file operations, but remember <code>os.RemoveAll</code> for cleanup of container directories.</p>\n</li>\n<li><p><strong>JSON Serialization</strong>: Use <code>encoding/json</code> with struct tags for OCI manifest parsing and container state persistence.</p>\n</li>\n</ol>\n<p><strong>Milestone Checkpoint - Goals Validation:</strong></p>\n<p>After implementing all six milestones, verify our must-have goals by running:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test process isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --hostname</span><span style=\"color:#9ECBFF\"> mycontainer</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should output: mycontainer (not the host's hostname)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test resource limits</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --memory</span><span style=\"color:#9ECBFF\"> 100m</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"tail /dev/zero\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should be OOM-killed within a few seconds</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test filesystem isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#9ECBFF\"> /</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show alpine rootfs contents, not host root files</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test layered filesystem</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> touch</span><span style=\"color:#9ECBFF\"> /testfile</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#9ECBFF\"> /testfile</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># First command creates file, second should NOT see it (separate containers)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test networking</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --net</span><span style=\"color:#9ECBFF\"> bridge</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> addr</span><span style=\"color:#9ECBFF\"> show</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show veth interface with private IP (172.17.0.x)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test OCI image compatibility</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> pull</span><span style=\"color:#9ECBFF\"> ubuntu:latest</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> ubuntu:latest</span><span style=\"color:#9ECBFF\"> echo</span><span style=\"color:#9ECBFF\"> \"Hello from Ubuntu\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should successfully download and run Ubuntu image</span></span></code></pre></div>\n\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container exits immediately</td>\n<td>Missing or incorrect entrypoint command</td>\n<td>Check OCI image config for <code>Entrypoint</code> and <code>Cmd</code></td>\n<td>Use image&#39;s entrypoint or provide command in <code>ContainerConfig.Cmd</code></td>\n</tr>\n<tr>\n<td><code>ps aux</code> shows host processes</td>\n<td>PID namespace not properly isolated</td>\n<td>Check <code>clone()</code> flags include <code>CLONE_NEWPID</code></td>\n<td>Ensure PID namespace is created before process starts</td>\n</tr>\n<tr>\n<td>Container cannot access internet</td>\n<td>Missing NAT rules or DNS</td>\n<td>Check <code>iptables -t nat -L</code> for MASQUERADE rule</td>\n<td>Add iptables masquerade rule for bridge network</td>\n</tr>\n<tr>\n<td>&quot;Operation not permitted&quot; errors</td>\n<td>Running without root privileges</td>\n<td>Check <code>id</code> command output</td>\n<td>Run container runtime with <code>sudo</code></td>\n</tr>\n<tr>\n<td>OverlayFS mount fails</td>\n<td>Missing kernel module or incorrect options</td>\n<td>Check <code>dmesg | grep overlay</code></td>\n<td>Load overlay module: <code>sudo modprobe overlay</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (this section provides the overall architectural framework that unifies all six implementation milestones)</p>\n</blockquote>\n<p>This section describes the macro-architecture of our container runtime—how all the Linux primitives (namespaces, cgroups, filesystem isolation) come together into a cohesive system. Think of this as the blueprint for a <strong>container factory</strong> with specialized assembly stations: each component handles one aspect of isolation, and the runtime orchestrates them in the correct sequence to produce fully isolated container environments.</p>\n<h3 id=\"component-overview-and-relationships\">Component Overview and Relationships</h3>\n<p>Imagine our container runtime as a <strong>specialized manufacturing assembly line</strong> for creating isolated process environments. Each workstation in this factory has a specific job:</p>\n<ol>\n<li><strong>The Design Office (CLI)</strong> - Takes customer orders (commands) and translates them into work orders</li>\n<li><strong>The Factory Manager (Container Manager)</strong> - Coordinates all workstations and ensures the assembly line flows correctly</li>\n<li><strong>The Privacy Room Constructor (Namespace Manager)</strong> - Builds private rooms with mirrored walls (isolated views of system resources)</li>\n<li><strong>The Resource Meter (cgroup Manager)</strong> - Installs smart meters that limit electricity, water, and occupancy in each room</li>\n<li><strong>The Furniture Installer (Filesystem Manager)</strong> - Delivers and arranges customized furniture sets (root filesystems)</li>\n<li><strong>The Telephone System Technician (Network Manager)</strong> - Sets up private phone lines with switchboards and external connections</li>\n<li><strong>The Inventory and Parts Department (Image Handler)</strong> - Manages prefabricated furniture kits (container images) and their assembly instructions</li>\n</ol>\n<p>Each component has a single responsibility and communicates through well-defined interfaces managed by the Container Manager. The overall architecture follows a <strong>coordinator pattern</strong>: the Container Manager orchestrates all other components but delegates specific technical work to specialized managers.</p>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fsystem-component.svg\" alt=\"System Component Diagram\"></p>\n<h4 id=\"core-components-and-their-responsibilities\">Core Components and Their Responsibilities</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Key Data Owned</th>\n<th>Collaborates With</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>CLI (Command Line Interface)</strong></td>\n<td>User interaction, command parsing, output formatting</td>\n<td>Command arguments, flags</td>\n<td>Container Manager (via API)</td>\n</tr>\n<tr>\n<td><strong>Container Manager</strong></td>\n<td>Container lifecycle orchestration, state management</td>\n<td><code>Container</code> registry, state transitions</td>\n<td>All managers (delegates work)</td>\n</tr>\n<tr>\n<td><strong>Namespace Manager</strong></td>\n<td>Linux namespace creation and isolation</td>\n<td>Namespace file descriptors, isolation flags</td>\n<td>Container Manager, Network Manager</td>\n</tr>\n<tr>\n<td><strong>cgroup Manager</strong></td>\n<td>Resource limit enforcement via control groups</td>\n<td>cgroup hierarchy paths, limit configurations</td>\n<td>Container Manager, OS kernel</td>\n</tr>\n<tr>\n<td><strong>Filesystem Manager</strong></td>\n<td>Root filesystem setup, layer management, mount operations</td>\n<td>Rootfs paths, layer directories, mount points</td>\n<td>Image Handler, Container Manager</td>\n</tr>\n<tr>\n<td><strong>Network Manager</strong></td>\n<td>Network namespace configuration, virtual networking</td>\n<td>veth pairs, bridge interfaces, IP allocations</td>\n<td>Namespace Manager, Container Manager</td>\n</tr>\n<tr>\n<td><strong>Image Handler</strong></td>\n<td>OCI image downloading, parsing, layer extraction</td>\n<td>Image cache, layer manifests, configuration</td>\n<td>Filesystem Manager, external registries</td>\n</tr>\n</tbody></table>\n<h4 id=\"component-communication-patterns\">Component Communication Patterns</h4>\n<p>The system uses two primary communication patterns:</p>\n<ol>\n<li><strong>Orchestration Flow (Top-Down)</strong>: The Container Manager receives requests from the CLI and sequentially invokes specialized managers in a specific order:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   CLI → Container Manager → Namespace Manager → cgroup Manager → \n   Filesystem Manager → Network Manager → Process Execution</code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Data Flow (Configuration Passing)</strong>: Each component receives a subset of the <code>ContainerConfig</code> relevant to its domain:<ul>\n<li><code>NamespaceManager</code> receives namespace flags</li>\n<li><code>CgroupManager</code> receives <code>ResourceLimits</code></li>\n<li><code>FilesystemManager</code> receives <code>Image</code> and mount specifications</li>\n<li><code>NetworkManager</code> receives <code>NetworkConfig</code></li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>Architectural Insight</strong>: The Container Manager acts as a <strong>facade</strong> over the complex Linux kernel interfaces. Users and the CLI interact with a simple container abstraction while the manager translates these operations into the appropriate sequence of low-level system calls and configurations.</p>\n</blockquote>\n<h4 id=\"key-architectural-decisions\">Key Architectural Decisions</h4>\n<blockquote>\n<p><strong>Decision: Coordinator Pattern Over Microservices</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to manage multiple Linux isolation primitives that must be applied in a specific sequence during container creation. The system runs on a single host and doesn&#39;t require distributed coordination.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Microservices architecture</strong>: Each manager runs as a separate process with IPC</li>\n<li><strong>Monolithic runtime</strong>: All logic in a single binary with internal modules</li>\n<li><strong>Coordinator pattern</strong>: Main orchestrator with pluggable manager components</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Coordinator pattern with in-process managers</li>\n<li><strong>Rationale</strong>: <ul>\n<li>Microservices add unnecessary IPC overhead for operations that require tight sequencing</li>\n<li>Monolithic design makes testing and replacement of components difficult</li>\n<li>Coordinator pattern provides clear separation of concerns while maintaining performance</li>\n<li>In-process communication avoids serialization overhead for configuration passing</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Easier to test components in isolation via mock interfaces</li>\n<li>Can swap implementations (e.g., cgroup v1 vs v2) without changing the coordinator</li>\n<li>All components share the same memory space and life cycle</li>\n<li>Single point of failure (if the coordinator crashes, all operations halt)</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Architecture Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Microservices</strong></td>\n<td>Fault isolation, independent scaling, language polyglot</td>\n<td>IPC overhead, complex deployment, sequencing difficulty</td>\n<td>Overkill for single-host container runtime</td>\n</tr>\n<tr>\n<td><strong>Monolithic</strong></td>\n<td>Performance, simplicity, no IPC</td>\n<td>Hard to test, tight coupling, difficult to extend</td>\n<td>Too rigid for educational project with clear component boundaries</td>\n</tr>\n<tr>\n<td><strong>Coordinator Pattern</strong></td>\n<td>Clear separation, testable components, flexible implementations</td>\n<td>Still single process, coordinator can become complex</td>\n<td><strong>CHOSEN</strong>: Balances separation with practical sequencing needs</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Immutable Container Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: Container properties (resource limits, network setup) must be established before process execution and shouldn&#39;t change during runtime for predictability and security.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Mutable configuration</strong>: Allow runtime modifications to limits, network, etc.</li>\n<li><strong>Immutable configuration</strong>: Freeze configuration after container creation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Immutable <code>ContainerConfig</code> after container creation</li>\n<li><strong>Rationale</strong>:<ul>\n<li>Changing cgroup limits during runtime can cause unpredictable behavior</li>\n<li>Network reconfiguration while processes are running is complex and error-prone</li>\n<li>Matches Docker/OCI runtime behavior (config changes require container restart)</li>\n<li>Simplifies state management and validation</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Users must recreate containers to change most settings</li>\n<li>Runtime code doesn&#39;t need to handle reconfiguration edge cases</li>\n<li>Clearer audit trail of container properties</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"system-entry-points-and-control-flow\">System Entry Points and Control Flow</h4>\n<p>The system has three primary entry points that users interact with:</p>\n<ol>\n<li><strong>Container Lifecycle Commands</strong>: <code>create</code>, <code>start</code>, <code>stop</code>, <code>remove</code></li>\n<li><strong>Image Management Commands</strong>: <code>pull</code>, <code>images</code>, <code>rmi</code></li>\n<li><strong>System Inspection Commands</strong>: <code>ps</code>, <code>inspect</code>, <code>logs</code></li>\n</ol>\n<p>Each command follows a similar flow through the architecture:</p>\n<ol>\n<li><strong>CLI Parsing</strong>: User command → flag parsing → validation</li>\n<li><strong>Request Routing</strong>: CLI invokes appropriate method on <code>ContainerRuntime</code></li>\n<li><strong>Orchestration</strong>: <code>ContainerManager</code> sequences the required operations</li>\n<li><strong>Specialist Execution</strong>: Specialized managers perform their isolated tasks</li>\n<li><strong>State Management</strong>: Results are recorded in the container registry</li>\n<li><strong>Response</strong>: Status/errors returned to user</li>\n</ol>\n<h4 id=\"data-persistence-and-state-management\">Data Persistence and State Management</h4>\n<p>The runtime maintains two primary forms of persistent state:</p>\n<table>\n<thead>\n<tr>\n<th>State Type</th>\n<th>Storage Location</th>\n<th>Purpose</th>\n<th>Managed By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container Metadata</strong></td>\n<td>JSON files in <code>/var/lib/container-runtime/containers/</code></td>\n<td>Track container state, configuration, PID</td>\n<td><code>ContainerManager</code></td>\n</tr>\n<tr>\n<td><strong>Image Layers</strong></td>\n<td>Directory structure in <code>/var/lib/container-runtime/images/</code></td>\n<td>Cache downloaded image layers for reuse</td>\n<td><code>ImageHandler</code></td>\n</tr>\n<tr>\n<td><strong>cgroup Hierarchies</strong></td>\n<td>Virtual filesystem at <code>/sys/fs/cgroup/</code></td>\n<td>Enforce resource limits across restarts</td>\n<td><code>cgroupManager</code> (with OS)</td>\n</tr>\n<tr>\n<td><strong>Network Namespaces</strong></td>\n<td>Persistent references in <code>/var/run/netns/</code></td>\n<td>Maintain network isolation across processes</td>\n<td><code>NetworkManager</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Design Insight</strong>: The <code>ContainerManager</code> serves as the <strong>system of record</strong> for container state. All other managers are stateless relative to container lifecycle—they apply configurations when requested but don&#39;t track what they&#39;ve applied. This centralization simplifies recovery and cleanup.</p>\n</blockquote>\n<h3 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h3>\n<p>Organizing the codebase clearly from the start is crucial for managing the complexity of interacting with multiple Linux kernel subsystems. Think of this structure as <strong>department offices in our factory</strong>—each team (component) has its own workspace with clear boundaries and defined interfaces for collaboration.</p>\n<h4 id=\"project-root-layout\">Project Root Layout</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>build-your-own-docker/\n├── cmd/\n│   └── containerd/                    # Main CLI binary (named to avoid confusion with actual Docker)\n│       └── main.go                    # Entry point: CLI parsing and routing\n├── internal/                          # Private application code (not for external use)\n│   ├── runtime/                       # Container Manager and core orchestration\n│   │   ├── container.go               # Container struct and state management\n│   │   ├── manager.go                 # ContainerManager implementation\n│   │   ├── runtime.go                 # ContainerRuntime interface implementation\n│   │   └── registry.go                # Container storage and retrieval\n│   ├── namespaces/                    # Namespace Manager\n│   │   ├── manager.go                 # NamespaceManager implementation\n│   │   ├── flags.go                   # Namespace flag constants and helpers\n│   │   └── unix.go                    # Low-level syscall wrappers\n│   ├── cgroups/                       # cgroup Manager\n│   │   ├── manager.go                 # CgroupManager implementation\n│   │   ├── v1/                        # cgroup v1 implementation\n│   │   │   └── controller.go          # v1-specific controller logic\n│   │   ├── v2/                        # cgroup v2 implementation\n│   │   │   └── controller.go          # v2-specific controller logic\n│   │   └── common.go                  # Shared cgroup utilities\n│   ├── filesystem/                    # Filesystem Manager\n│   │   ├── manager.go                 # FilesystemManager implementation\n│   │   ├── rootfs.go                  # Root filesystem setup (pivot_root)\n│   │   ├── overlay.go                 # OverlayFS mounting and management\n│   │   └── mounts.go                  /proc, /sys, /dev mounting\n│   ├── network/                       # Network Manager\n│   │   ├── manager.go                 # NetworkManager implementation\n│   │   ├── veth.go                    # Virtual ethernet pair creation\n│   │   ├── bridge.go                  # Linux bridge setup and management\n│   │   ├── iptables.go                # NAT and firewall rules\n│   │   └── dns.go                     # DNS/resolv.conf configuration\n│   └── image/                         # Image Handler\n│       ├── manager.go                 # ImageHandler implementation\n│       ├── oci/                       # OCI specification handling\n│       │   ├── manifest.go            # Manifest parsing and validation\n│       │   └── config.go              # Image config parsing\n│       ├── registry/                  # Registry client\n│       │   ├── client.go              # HTTP client for Docker Registry API\n│       │   └── auth.go                # Authentication handling\n│       └── storage.go                 # Layer storage and extraction\n├── pkg/                               # Public libraries (potentially reusable)\n│   ├── spec/                          # OCI specification types\n│   │   ├── container.go               # Container runtime spec types\n│   │   └── image.go                   # Image spec types\n│   └── utils/                         # General utilities\n│       ├── exec.go                    # Process execution helpers\n│       └── signal.go                  # Signal handling utilities\n├── var/                               # Runtime data (created at runtime)\n│   ├── lib/container-runtime/         # Persistent data\n│   │   ├── containers/                # Container state JSON files\n│   │   ├── images/                    # Extracted image layers\n│   │   └── overlay/                   # OverlayFS work and upper directories\n│   └── run/container-runtime/         # Ephemeral runtime data\n│       └── netns/                     # Network namespace bind mounts\n├── scripts/                           # Build and development scripts\n│   ├── setup.sh                       # Environment setup\n│   └── test.sh                        # Test runner\n├── examples/                          # Example configurations and usage\n│   ├── simple-container/              # Minimal container example\n│   └── custom-network/                # Network configuration example\n├── go.mod                             # Go module definition\n└── README.md                          # Project documentation</code></pre></div>\n\n<h4 id=\"module-dependencies-and-import-relationships\">Module Dependencies and Import Relationships</h4>\n<p>The dependency flow follows the orchestration pattern: higher-level modules import lower-level ones, but not vice versa.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>cmd/containerd/ → internal/runtime/ → [all other internal/ components]\n                                ↳ internal/namespaces/\n                                ↳ internal/cgroups/\n                                ↳ internal/filesystem/\n                                ↳ internal/network/\n                                ↳ internal/image/</code></pre></div>\n\n<p><strong>Key Dependency Rules:</strong></p>\n<ol>\n<li><strong>Horizontal dependencies are forbidden</strong>: <code>internal/namespaces/</code> cannot import <code>internal/network/</code></li>\n<li><strong>Upward dependencies are forbidden</strong>: No internal component imports <code>cmd/</code></li>\n<li><strong>Shared types live in <code>pkg/spec/</code></strong>: All managers import common types from here</li>\n<li><strong>Utilities are shared via <code>pkg/utils/</code></strong>: Common helpers used by multiple components</li>\n</ol>\n<h4 id=\"component-interface-definitions\">Component Interface Definitions</h4>\n<p>Each manager component implements a well-defined interface that the <code>ContainerManager</code> uses:</p>\n<table>\n<thead>\n<tr>\n<th>Interface</th>\n<th>File Location</th>\n<th>Key Methods</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NamespaceManager</code></td>\n<td><code>internal/namespaces/manager.go</code></td>\n<td><code>CreateNamespaces(flags int) (int, error)</code></td>\n<td><code>ContainerManager</code> during container creation</td>\n</tr>\n<tr>\n<td><code>CgroupManager</code></td>\n<td><code>internal/cgroups/manager.go</code></td>\n<td><code>CreateGroup(path string) error</code>, <code>SetLimits(path string, limits ResourceLimits) error</code></td>\n<td><code>ContainerManager</code> after namespace creation</td>\n</tr>\n<tr>\n<td><code>FilesystemManager</code></td>\n<td><code>internal/filesystem/manager.go</code></td>\n<td><code>SetupRootfs(image Image, containerID string) (string, error)</code></td>\n<td><code>ContainerManager</code> before process execution</td>\n</tr>\n<tr>\n<td><code>NetworkManager</code></td>\n<td><code>internal/network/manager.go</code></td>\n<td><code>SetupNetwork(nsPath string, config NetworkConfig) error</code></td>\n<td><code>ContainerManager</code> after filesystem setup</td>\n</tr>\n<tr>\n<td><code>ImageHandler</code></td>\n<td><code>internal/image/manager.go</code></td>\n<td><code>Pull(imageName string) (Image, error)</code>, <code>Extract(image Image) error</code></td>\n<td><code>ContainerManager</code> and <code>FilesystemManager</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Principle</strong>: Each interface represents a <strong>capability</strong> not an implementation. This allows us to swap implementations (e.g., cgroup v1 vs v2) without changing the orchestration logic.</p>\n</blockquote>\n<h4 id=\"state-directory-structure\">State Directory Structure</h4>\n<p>At runtime, the system creates and manages the following directory structure under <code>/var/lib/container-runtime/</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/var/lib/container-runtime/\n├── containers/                    # One subdirectory per container\n│   ├── {container-id}/           # Container-specific data\n│   │   ├── config.json           # ContainerConfig serialized\n│   │   ├── state.json            # Current ContainerState, PID, etc.\n│   │   └── rootfs/               # Container's root filesystem (if not using overlay)\n│   └── metadata.db               # Optional: SQLite for faster lookups\n├── images/                       # Extracted image layers\n│   ├── {image-digest}/           # One directory per image layer\n│   │   ├── layer.tar             # Original layer archive\n│   │   └── fs/                   # Extracted files\n│   └── manifests/                # Downloaded image manifests\n└── overlay/                      # OverlayFS directories\n    ├── {container-id}/           # Per-container overlay directories\n    │   ├── upper/                # Writable layer (changes)\n    │   ├── work/                 # Work directory for OverlayFS\n    │   └── merged/               # Unified view (actual rootfs)\n    └── layers/                   # Shared read-only lower layers</code></pre></div>\n\n<p>This structure ensures:</p>\n<ul>\n<li><strong>Isolation</strong>: Each container&#39;s data is separate</li>\n<li><strong>Persistence</strong>: Container state survives runtime restarts</li>\n<li><strong>Sharing</strong>: Image layers are shared between containers</li>\n<li><strong>Cleanup</strong>: Removing a container deletes its directory entirely</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Transition Note</strong>: The following implementation guidance bridges the gap between architectural design and actual code. It provides concrete starting points for implementing the high-level structure described above.</p>\n</blockquote>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommendation for Learning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>CLI Framework</strong></td>\n<td>Standard <code>flag</code> package</td>\n<td><code>cobra</code> or <code>urfave/cli</code></td>\n<td><strong>Standard <code>flag</code></strong> (minimal dependencies, focuses on concepts)</td>\n</tr>\n<tr>\n<td><strong>Configuration Storage</strong></td>\n<td>JSON files in directories</td>\n<td>SQLite database</td>\n<td><strong>JSON files</strong> (transparent, easy to debug, matches OCI spec)</td>\n</tr>\n<tr>\n<td><strong>Image Registry Client</strong></td>\n<td>Basic HTTP with <code>net/http</code></td>\n<td>Full OCI distribution client</td>\n<td><strong>Basic HTTP</strong> with authentication support (teaches registry API)</td>\n</tr>\n<tr>\n<td><strong>Process Management</strong></td>\n<td><code>os/exec</code> package</td>\n<td>Direct syscall wrappers</td>\n<td><strong>Mix</strong>: <code>os/exec</code> for orchestration, syscalls for isolation</td>\n</tr>\n<tr>\n<td><strong>File System Operations</strong></td>\n<td><code>os</code> and <code>io</code> packages</td>\n<td>Lower-level syscalls</td>\n<td><strong>Standard library</strong> (safer, portable across Unix-like systems)</td>\n</tr>\n<tr>\n<td><strong>Networking Setup</strong></td>\n<td><code>net</code> package + <code>exec</code> for <code>ip</code> commands</td>\n<td>Direct netlink socket calls</td>\n<td><strong><code>exec</code> for <code>ip</code> and <code>iptables</code></strong> (simpler, mirrors actual admin work)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure-starter-implementation\">B. Recommended File/Module Structure (Starter Implementation)</h4>\n<p>Let&#39;s begin with the minimal viable structure to get started. Create these files first:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>build-your-own-docker/\n├── cmd/\n│   └── byod/                         # &quot;Build Your Own Docker&quot; CLI\n│       └── main.go                   # Start here - basic CLI skeleton\n├── internal/\n│   └── runtime/\n│       ├── container.go              # Core data structures\n│       └── manager.go                # ContainerManager skeleton\n├── pkg/\n│   └── spec/\n│       └── types.go                  # All type definitions\n└── go.mod                            # Initialize with: go mod init build-your-own-docker</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>File: <code>pkg/spec/types.go</code></strong> - Complete type definitions matching the naming conventions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package spec defines the core data types for the container runtime.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> spec</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerState represents the lifecycle state of a container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCreated</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateRunning</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"running\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatePaused</span><span style=\"color:#B392F0\">  ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paused\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateStopped</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"stopped\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateRemoved</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"removed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceLimits defines resource constraints for a container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryMB  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // Memory limit in megabytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPUShares </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // CPU shares (relative weight)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PidsLimit </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // Maximum number of processes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PortMapping defines a port forwarding rule.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PortMapping</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HostPort      </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Port on the host</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerPort </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Port in the container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Protocol      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // \"tcp\" or \"udp\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkConfig defines network settings for a container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Mode         </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">       // \"bridge\", \"host\", \"none\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BridgeName   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">       // Name of the bridge interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress    </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">       // Container IP address (optional)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#6A737D\"> // Port forwarding rules</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerConfig defines the configuration for creating a container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Image      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">         // Image name or ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cmd        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">       // Command to run (overrides image entrypoint)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Env        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">       // Environment variables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">         // Working directory inside container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Hostname   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">         // Container hostname</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limits     </span><span style=\"color:#B392F0\">ResourceLimits</span><span style=\"color:#6A737D\"> // Resource limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Network    </span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#6A737D\">  // Network configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container represents a running or stopped container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Container</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID        </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">          // Unique container identifier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">          // Human-readable name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State     </span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#6A737D\">  // Current state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Config    </span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#6A737D\"> // Creation configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pid       </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">             // Process ID of container process (if running)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\">       // Creation timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ImageLayer represents a single filesystem layer in an image.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ImageLayer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Digest </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // SHA256 digest of layer content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Size   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // Size in bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Local filesystem path to extracted layer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ImageConfig defines the runtime configuration from an image.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ImageConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entrypoint []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Entrypoint command</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cmd        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Default arguments to entrypoint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Env        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Default environment variables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">   // Default working directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Image represents a container image.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Image</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">        // Image name (e.g., \"alpine:latest\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Digest </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">        // SHA256 digest of image manifest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Layers []</span><span style=\"color:#B392F0\">ImageLayer</span><span style=\"color:#6A737D\">  // Filesystem layers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Config </span><span style=\"color:#B392F0\">ImageConfig</span><span style=\"color:#6A737D\">   // Image configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>cmd/byod/main.go</code></strong> - Basic CLI skeleton:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package main implements the Build Your Own Docker CLI.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">flag</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">build-your-own-docker/internal/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize the container runtime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">NewContainerRuntime</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse command line arguments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(os.Args) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printUsage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    command </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.Args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.Args[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">:]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> command {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"run\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        runCommand</span><span style=\"color:#E1E4E8\">(rt, args)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"create\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        createCommand</span><span style=\"color:#E1E4E8\">(rt, args)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"start\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        startCommand</span><span style=\"color:#E1E4E8\">(rt, args)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"stop\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        stopCommand</span><span style=\"color:#E1E4E8\">(rt, args)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"rm\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        rmCommand</span><span style=\"color:#E1E4E8\">(rt, args)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"ps\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        psCommand</span><span style=\"color:#E1E4E8\">(rt, args)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"pull\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pullCommand</span><span style=\"color:#E1E4E8\">(rt, args)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"images\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        imagesCommand</span><span style=\"color:#E1E4E8\">(rt, args)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unknown command: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, command)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printUsage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> printUsage</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Build Your Own Docker - A minimal container runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Usage:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod run [OPTIONS] IMAGE [COMMAND] [ARG...]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod create [OPTIONS] IMAGE [COMMAND] [ARG...]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod start [OPTIONS] CONTAINER</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod stop [OPTIONS] CONTAINER</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod rm [OPTIONS] CONTAINER</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod ps [OPTIONS]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod pull [OPTIONS] IMAGE</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod images [OPTIONS]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Examples:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod run alpine:latest /bin/sh</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod ps</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  byod pull ubuntu:20.04`</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement individual command handlers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> runCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rt</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"run command not yet implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> createCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rt</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"create command not yet implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> startCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rt</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"start command not yet implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> stopCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rt</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"stop command not yet implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> rmCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rt</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"rm command not yet implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> psCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rt</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ps command not yet implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> pullCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rt</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pull command not yet implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> imagesCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rt</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"images command not yet implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>internal/runtime/container.go</code></strong> - Container registry and state management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package runtime implements the container lifecycle manager.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">build-your-own-docker/pkg/spec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// containerStore manages persistent container state.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> containerStore</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseDir </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">               // Directory for container state files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#6A737D\"> // In-memory cache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// newContainerStore creates a new container store.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> newContainerStore</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">baseDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">containerStore</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure base directory exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(baseDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create container store directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">containerStore</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        baseDir:    baseDir,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        containers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// save writes a container's state to disk.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">containerStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">save</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create container directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containerDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(s.baseDir, container.ID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create container directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write config.json</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#9ECBFF\">\"config.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configData, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">MarshalIndent</span><span style=\"color:#E1E4E8\">(container.Config, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to marshal container config: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(configPath, configData, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write container config: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write state.json</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#9ECBFF\">\"state.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stateData, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">MarshalIndent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ID        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        State     </span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Pid       </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CreatedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ID:        container.ID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name:      container.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        State:     container.State,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Pid:       container.Pid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CreatedAt: container.CreatedAt,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to marshal container state: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(statePath, stateData, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write container state: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update in-memory cache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.containers[container.ID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// load reads all containers from disk into memory.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">containerStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entries, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadDir</span><span style=\"color:#E1E4E8\">(s.baseDir)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read container store directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, entry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> entries {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">entry.</span><span style=\"color:#B392F0\">IsDir</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        containerID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> entry.</span><span style=\"color:#B392F0\">Name</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        containerDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(s.baseDir, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Load config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        configPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#9ECBFF\">\"config.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        configData, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(configPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Skip corrupt containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerConfig</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(configData, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">config); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Load state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        statePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#9ECBFF\">\"state.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stateData, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(statePath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> state </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ID        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            State     </span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Pid       </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CreatedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(stateData, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        container </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ID:        state.ID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:      state.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            State:     state.State,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Config:    config,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Pid:       state.Pid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CreatedAt: state.CreatedAt,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s.containers[container.ID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// get retrieves a container by ID.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">containerStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    container, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.containers[id]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"container </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">, id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> container, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// list returns all containers.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">containerStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">list</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(s.containers))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, container </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> s.containers {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        containers </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(s.containers))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, container </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> s.containers {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            containers </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(containers, container)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> containers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// remove deletes a container from the store.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">containerStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">remove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Delete from filesystem</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containerDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(s.baseDir, id)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">RemoveAll</span><span style=\"color:#E1E4E8\">(containerDir); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to remove container directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Delete from memory</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(s.containers, id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>File: <code>internal/runtime/manager.go</code></strong> - ContainerManager skeleton with detailed TODOs:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">math/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">build-your-own-docker/pkg/spec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerRuntime defines the interface for container operations.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerRuntime</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    StartContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    StopContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RemoveContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ListContainers</span><span style=\"color:#E1E4E8\">() ([]</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerManager implements ContainerRuntime.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    store </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">containerStore</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add references to specialized managers as fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // namespaceMgr namespaces.NamespaceManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // cgroupMgr    cgroups.CgroupManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // fsMgr        filesystem.FilesystemManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // networkMgr   network.NetworkManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // imageMgr     image.ImageHandler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewContainerRuntime creates a new container runtime instance.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewContainerRuntime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize container store with default path (/var/lib/container-runtime)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Load existing containers from disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize specialized managers (nil for now)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ContainerManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        store: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Will be initialized in TODO 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateContainer creates a new container with given configuration.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique container ID (e.g., random 12-character hex string)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create Container struct with initial state (StateCreated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate configuration (check image exists, valid resource limits, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Pull image if not already available locally</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Setup container directory in store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Save container to store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return the created container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartContainer starts a created container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Retrieve container from store by ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate container is in StateCreated state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create Linux namespaces (PID, UTS, mount, network, IPC)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create and configure cgroup for container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Setup root filesystem using image layers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Configure network namespace (veth pair, bridge, IP, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Execute the container process inside the namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Update container state to StateRunning and save PID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Monitor container process (in goroutine) to detect exit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StopContainer stops a running container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StopContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Retrieve container from store by ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate container is in StateRunning state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send SIGTERM to container process (PID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for process termination with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If timeout, send SIGKILL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Cleanup network namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Remove cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Update container state to StateStopped</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Save updated state to store</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveContainer removes a stopped container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Retrieve container from store by ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate container is in StateStopped state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove container root filesystem (if not using overlay)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove container directory from store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update container state to StateRemoved in memory (optional)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ListContainers returns all containers.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ListContainers</span><span style=\"color:#E1E4E8\">() ([]</span><span style=\"color:#B392F0\">spec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Retrieve all containers from store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Convert to slice of spec.Container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return containers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// generateID creates a unique container ID.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> generateID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> letters</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"abcdef0123456789\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> idLength</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rand.</span><span style=\"color:#B392F0\">Seed</span><span style=\"color:#E1E4E8\">(time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, idLength)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> b {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        b[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> letters[rand.</span><span style=\"color:#B392F0\">Intn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(letters))]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">(b)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<p><strong>Go-Specific Implementation Tips:</strong></p>\n<ol>\n<li><p><strong>Syscall vs. Exec</strong>: Use the <code>syscall</code> package for namespace creation (<code>unshare</code>, <code>setns</code>, <code>clone</code>), but prefer <code>exec.Command</code> for configuring network (<code>ip</code>, <code>iptables</code>) to avoid reimplementing complex logic.</p>\n</li>\n<li><p><strong>Process Management</strong>: Use <code>os.StartProcess</code> instead of <code>os/exec</code> when you need fine-grained control over process attributes (like clone flags for namespaces).</p>\n</li>\n<li><p><strong>File Operations</strong>: Always use absolute paths when dealing with mount operations and namespace references to avoid confusion about which namespace you&#39;re operating in.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Use <code>fmt.Errorf(&quot;... %w&quot;, err)</code> to wrap errors with context, especially for syscalls where the raw error message might be unclear.</p>\n</li>\n<li><p><strong>Concurrency</strong>: Use <code>sync.RWMutex</code> for the container store since multiple goroutines might read container state while only one modifies it.</p>\n</li>\n<li><p><strong>JSON Serialization</strong>: Use <code>json.MarshalIndent</code> for debugging but regular <code>json.Marshal</code> for production to save space.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>After implementing the basic structure above, verify your setup:</strong></p>\n<ol>\n<li><strong>Build the project</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> ./cmd/byod</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Run the CLI without arguments</strong> to see usage:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   ./byod</span></span></code></pre></div>\n<p>   Expected output: The usage message defined in <code>printUsage()</code></p>\n<ol start=\"3\">\n<li><strong>Test each command stub</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span></code></pre></div>\n<p>   Expected: &quot;run command not yet implemented&quot; error</p>\n<ol start=\"4\">\n<li><strong>Check that types compile correctly</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./pkg/spec/...</span></span></code></pre></div>\n<p>   Expected: No compilation errors (even with no tests)</p>\n<p><strong>Signs of correct setup:</strong></p>\n<ul>\n<li>Binary compiles without errors</li>\n<li>Each command shows appropriate &quot;not implemented&quot; message</li>\n<li>Directory structure matches the blueprint</li>\n<li><code>go mod tidy</code> runs without dependency issues</li>\n</ul>\n<p><strong>Common setup problems:</strong></p>\n<ul>\n<li><strong>&quot;cannot find module&quot;</strong>: Run <code>go mod init build-your-own-docker</code> in project root</li>\n<li><strong>Import path errors</strong>: Ensure <code>go.mod</code> module name matches import paths</li>\n<li><strong>Permission errors</strong>: You&#39;ll need root/sudo for later milestones but not for this structure</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>&quot;Command not found&quot; when running ./byod</strong></td>\n<td>File not executable or wrong path</td>\n<td>Run <code>ls -la ./byod</code></td>\n<td><code>chmod +x ./byod</code> or use <code>go run cmd/byod/main.go</code></td>\n</tr>\n<tr>\n<td><strong>Import errors in Go files</strong></td>\n<td>Incorrect module name or missing dependencies</td>\n<td>Check <code>go.mod</code> first line matches import paths</td>\n<td>Update <code>go.mod</code> or fix import statements</td>\n</tr>\n<tr>\n<td><strong>JSON marshaling fails</strong></td>\n<td>Struct fields not exported (capitalized)</td>\n<td>Check field names start with uppercase</td>\n<td>Export fields: <code>Name</code> not <code>name</code></td>\n</tr>\n<tr>\n<td><strong>Store directory not created</strong></td>\n<td>Permission issues or parent doesn&#39;t exist</td>\n<td>Check <code>os.MkdirAll</code> error return</td>\n<td>Run with appropriate permissions or create parent directory</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (this section defines the core data structures that every component will use to represent containers, images, and runtime state)</p>\n</blockquote>\n<p>This section defines the foundational data structures that our container runtime uses to represent the state of the system. Think of these structures as <strong>blueprints and records</strong> in a construction project: the blueprints (<code>ContainerConfig</code>, <code>Image</code>) specify what to build, while the records (<code>Container</code>, runtime state) track what&#39;s actually been built and its current condition. These data models serve as the single source of truth that coordinates all our components—from namespace isolation to network configuration.</p>\n<h3 id=\"key-types-and-structures\">Key Types and Structures</h3>\n<p>The container runtime manipulates several core entity types, each with specific responsibilities and lifecycle. These structures capture everything from container configuration and runtime state to image metadata and network settings.</p>\n<h4 id=\"container-lifecycle-state-containerstate\">Container Lifecycle State (<code>ContainerState</code>)</h4>\n<p>Containers transition through a well-defined lifecycle, much like processes in an operating system. The <code>ContainerState</code> enumeration tracks where a container is in this lifecycle, enabling proper management operations and preventing invalid state transitions (like trying to start an already running container).</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Description</th>\n<th>Allowed Next States</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Created</code></td>\n<td>Container configuration has been validated and persisted, but the isolated process hasn&#39;t started yet. Namespaces, cgroups, and filesystems may be partially prepared.</td>\n<td><code>Running</code>, <code>Stopped</code> (if cleanup fails)</td>\n</tr>\n<tr>\n<td><code>Running</code></td>\n<td>Container process is actively executing inside its isolated environment. All resources (namespaces, cgroups, network) are active and being used.</td>\n<td><code>Paused</code>, <code>Stopped</code></td>\n</tr>\n<tr>\n<td><code>Paused</code></td>\n<td>Container process is suspended (via cgroup freezer). The process exists but isn&#39;t scheduled for CPU time. Memory and other resources remain allocated.</td>\n<td><code>Running</code> (resumed), <code>Stopped</code></td>\n</tr>\n<tr>\n<td><code>Stopped</code></td>\n<td>Container process has terminated (either normally or via signal). Resources are still allocated but can be cleaned up. This is a terminal state before removal.</td>\n<td><code>Removed</code></td>\n</tr>\n<tr>\n<td><code>Removed</code></td>\n<td>All container resources have been released (namespaces destroyed, cgroups deleted, filesystems unmounted). Only metadata may remain for historical tracking.</td>\n<td>(terminal state)</td>\n</tr>\n</tbody></table>\n<p>The state machine ensures that operations like <code>StartContainer</code> can only be called on <code>Created</code> containers, while <code>RemoveContainer</code> requires a <code>Stopped</code> container, preventing resource leaks or inconsistent states.</p>\n<h4 id=\"container-configuration-containerconfig\">Container Configuration (<code>ContainerConfig</code>)</h4>\n<p>The <code>ContainerConfig</code> structure serves as the <strong>recipe</strong> for creating a container—it specifies what to run, with what resources, and in what environment. This is the primary input from users (via CLI or API) and contains all the settings needed to create an isolated environment.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Image</code></td>\n<td><code>string</code></td>\n<td>Reference to the container image (e.g., &quot;alpine:latest&quot; or &quot;ubuntu:22.04&quot;). This identifies which root filesystem and default configuration to use.</td>\n</tr>\n<tr>\n<td><code>Cmd</code></td>\n<td><code>[]string</code></td>\n<td>Command and arguments to execute inside the container (overrides the image&#39;s default <code>Cmd</code>). Example: <code>[&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>.</td>\n</tr>\n<tr>\n<td><code>Env</code></td>\n<td><code>[]string</code></td>\n<td>Environment variables in &quot;KEY=VALUE&quot; format that will be available to the container process. These are merged with (and can override) the image&#39;s environment variables.</td>\n</tr>\n<tr>\n<td><code>WorkingDir</code></td>\n<td><code>string</code></td>\n<td>Initial working directory for the container process. If empty, defaults to the image&#39;s <code>WorkingDir</code> or root (&quot;/&quot;).</td>\n</tr>\n<tr>\n<td><code>Hostname</code></td>\n<td><code>string</code></td>\n<td>Hostname to set inside the container&#39;s UTS namespace. If empty, defaults to the container ID or a generated name.</td>\n</tr>\n<tr>\n<td><code>Limits</code></td>\n<td><code>ResourceLimits</code></td>\n<td>Resource constraints (CPU, memory, process count) to apply via cgroups. Zero values typically mean &quot;no limit.&quot;</td>\n</tr>\n<tr>\n<td><code>Network</code></td>\n<td><code>NetworkConfig</code></td>\n<td>Network isolation and connectivity settings, including IP address, port mappings, and network mode.</td>\n</tr>\n</tbody></table>\n<p>This configuration is <strong>immutable</strong> after container creation—runtime changes to resource limits or network settings would require complex live updates and are beyond our scope.</p>\n<h4 id=\"resource-limits-resourcelimits\">Resource Limits (<code>ResourceLimits</code>)</h4>\n<p>Resource limits enforce <strong>quotas</strong> on container resource consumption, preventing any single container from monopolizing system resources. Think of these as utility caps in an apartment building—each unit gets a maximum allocation of water, electricity, and gas.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MemoryMB</code></td>\n<td><code>int</code></td>\n<td>Maximum resident memory (RAM) in megabytes that the container can use. When exceeded, the OOM killer terminates container processes.</td>\n</tr>\n<tr>\n<td><code>CPUShares</code></td>\n<td><code>int</code></td>\n<td>Relative CPU weight (in the cgroups v1 &quot;cpu.shares&quot; scheme). Default is 1024; values are proportional to other containers&#39; shares.</td>\n</tr>\n<tr>\n<td><code>PidsLimit</code></td>\n<td><code>int</code></td>\n<td>Maximum number of processes (including threads) the container can create. Prevents fork bombs and process exhaustion attacks.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> We use simple integer fields rather than more complex types (like <code>uint64</code> or custom units) to keep the API straightforward for learners. In production systems, you&#39;d want finer-grained controls (CPU quotas, memory+swap limits, I/O bandwidth), but these three limits cover the essential isolation concerns.</p>\n</blockquote>\n<h4 id=\"network-configuration-networkconfig-and-portmapping\">Network Configuration (<code>NetworkConfig</code> and <code>PortMapping</code>)</h4>\n<p>Network configuration defines how the container connects to networks—whether it&#39;s fully isolated, bridged to a host network, or uses host networking directly. The <code>PortMapping</code> structure enables <strong>port forwarding</strong>, similar to how a hotel switchboard directs external calls to specific room extensions.</p>\n<p><strong><code>NetworkConfig</code> structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Mode</code></td>\n<td><code>string</code></td>\n<td>Network isolation mode: &quot;bridge&quot; (default, private network with NAT), &quot;host&quot; (share host&#39;s network namespace), &quot;none&quot; (no network interfaces).</td>\n</tr>\n<tr>\n<td><code>BridgeName</code></td>\n<td><code>string</code></td>\n<td>Name of the Linux bridge to connect to (for &quot;bridge&quot; mode). Defaults to &quot;byob0&quot; (Build Your Own Bridge).</td>\n</tr>\n<tr>\n<td><code>IPAddress</code></td>\n<td><code>string</code></td>\n<td>Static IPv4 address to assign to the container (e.g., &quot;172.17.0.2&quot;). If empty, uses DHCP or automatic allocation from bridge subnet.</td>\n</tr>\n<tr>\n<td><code>PortMappings</code></td>\n<td><code>[]PortMapping</code></td>\n<td>List of port forwardings from host to container (e.g., host port 8080 → container port 80).</td>\n</tr>\n</tbody></table>\n<p><strong><code>PortMapping</code> structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>HostPort</code></td>\n<td><code>int</code></td>\n<td>Port number on the host interface (0-65535). Ports below 1024 typically require root privileges.</td>\n</tr>\n<tr>\n<td><code>ContainerPort</code></td>\n<td><code>int</code></td>\n<td>Port number inside the container network namespace (0-65535).</td>\n</tr>\n<tr>\n<td><code>Protocol</code></td>\n<td><code>string</code></td>\n<td>Transport protocol: &quot;tcp&quot; or &quot;udp&quot;. Determines which iptables rule chain to modify.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Network Configuration Simplicity</strong></p>\n<p><strong>Context:</strong> We need to provide network connectivity options for containers while keeping implementation complexity manageable for learners.</p>\n<p><strong>Options Considered:</strong></p>\n<ol>\n<li><strong>Full OCI network specification</strong> with CNI plugins, multiple network interfaces, DNS configurations</li>\n<li><strong>Simple bridge-only model</strong> with static IP assignment and basic port forwarding</li>\n<li><strong>Host-only networking</strong> (simplest, but no isolation)</li>\n</ol>\n<p><strong>Decision:</strong> Option 2 (simple bridge model) with extensible <code>Mode</code> field.</p>\n<p><strong>Rationale:</strong> Bridge networking provides practical isolation while being implementable with standard Linux tools (ip, brctl, iptables). The <code>Mode</code> field allows future extension to &quot;host&quot; and &quot;none&quot; modes without breaking existing configurations. We avoid CNI complexity as it&#39;s a significant learning curve beyond core container concepts.</p>\n<p><strong>Consequences:</strong> Containers get reasonable network isolation out-of-the-box, but advanced networking features (multiple networks, custom DNS, IPv6) would require significant extensions to the data model and implementation.</p>\n</blockquote>\n<h4 id=\"container-runtime-instance-container\">Container Runtime Instance (<code>Container</code>)</h4>\n<p>The <code>Container</code> structure represents an <strong>actual running or runnable instance</strong>—it&#39;s the runtime manifestation of a <code>ContainerConfig</code>. Think of it as the difference between an architectural blueprint (<code>ContainerConfig</code>) and the actual constructed building (<code>Container</code>).</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier (typically a random 64-bit hex string). Used to reference the container in all operations.</td>\n</tr>\n<tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Human-readable name for the container (e.g., &quot;my-web-server&quot;). Must be unique across running containers.</td>\n</tr>\n<tr>\n<td><code>State</code></td>\n<td><code>ContainerState</code></td>\n<td>Current lifecycle state (Created, Running, etc.). Determines which operations are valid.</td>\n</tr>\n<tr>\n<td><code>Config</code></td>\n<td><code>ContainerConfig</code></td>\n<td>Immutable configuration used to create this container. Stored for reference and potential restart.</td>\n</tr>\n<tr>\n<td><code>Pid</code></td>\n<td><code>int</code></td>\n<td>Process ID of the container&#39;s init process on the host. Zero if container isn&#39;t running. Used to manage cgroup membership and send signals.</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Timestamp when the container was first created. Used for display (e.g., <code>docker ps</code>) and cleanup of old containers.</td>\n</tr>\n</tbody></table>\n<p>The <code>Container</code> object is persisted to disk (typically as JSON) so the runtime can recover state after a restart. This is critical for operations like <code>StopContainer</code> to work—the runtime needs to know which host PID to signal.</p>\n<h4 id=\"image-metadata-image-and-imagelayer\">Image Metadata (<code>Image</code> and <code>ImageLayer</code>)</h4>\n<p>Images are <strong>immutable templates</strong> for container filesystems. An image consists of multiple layers (like a layered cake) that are stacked together using OverlayFS. The <code>Image</code> structure represents a downloaded and extracted image, ready to be instantiated into containers.</p>\n<p><strong><code>Image</code> structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Image reference including registry, repository, and tag (e.g., &quot;docker.io/library/alpine:latest&quot;).</td>\n</tr>\n<tr>\n<td><code>Digest</code></td>\n<td><code>string</code></td>\n<td>Cryptographic hash of the image manifest (SHA256). Uniquely identifies this exact image version.</td>\n</tr>\n<tr>\n<td><code>Layers</code></td>\n<td><code>[]ImageLayer</code></td>\n<td>Ordered list of filesystem layers (bottom to top) that make up the image&#39;s root filesystem.</td>\n</tr>\n<tr>\n<td><code>Config</code></td>\n<td><code>ImageConfig</code></td>\n<td>Default runtime configuration from the image (entrypoint, environment, working directory).</td>\n</tr>\n</tbody></table>\n<p><strong><code>ImageLayer</code> structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Digest</code></td>\n<td><code>string</code></td>\n<td>Content-addressable hash (SHA256) of the layer tarball. Used for caching and verification.</td>\n</tr>\n<tr>\n<td><code>Size</code></td>\n<td><code>int64</code></td>\n<td>Size of the layer tarball in bytes. Used for download progress reporting and disk space management.</td>\n</tr>\n<tr>\n<td><code>Path</code></td>\n<td><code>string</code></td>\n<td>Filesystem path where this layer&#39;s extracted contents are stored (typically in a content-addressable store).</td>\n</tr>\n</tbody></table>\n<p><strong><code>ImageConfig</code> structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Entrypoint</code></td>\n<td><code>[]string</code></td>\n<td>Default executable and arguments to run when container starts (e.g., <code>[&quot;/bin/myapp&quot;]</code>).</td>\n</tr>\n<tr>\n<td><code>Cmd</code></td>\n<td><code>[]string</code></td>\n<td>Default arguments to <code>Entrypoint</code> (overridden by container&#39;s <code>Cmd</code>).</td>\n</tr>\n<tr>\n<td><code>Env</code></td>\n<td><code>[]string</code></td>\n<td>Default environment variables (e.g., <code>[&quot;PATH=/usr/bin&quot;, &quot;HOME=/root&quot;]</code>).</td>\n</tr>\n<tr>\n<td><code>WorkingDir</code></td>\n<td><code>string</code></td>\n<td>Default working directory if none specified in container config.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The separation between <code>Image</code> metadata and <code>ContainerConfig</code> allows for inheritance and override patterns. When a container is created, its <code>ContainerConfig</code> merges with the <code>ImageConfig</code>—explicit container settings override image defaults, similar to how subclass methods override parent class methods in object-oriented programming.</p>\n</blockquote>\n<h3 id=\"relationships-between-entities\">Relationships Between Entities</h3>\n<p>The data model entities relate to each other in specific ways that define the overall system architecture. Understanding these relationships is crucial for implementing correct lifecycle management and resource cleanup.</p>\n<h4 id=\"container-image-relationship\">Container-Image Relationship</h4>\n<p>A container <strong>instantiates</strong> an image, much like an object instantiates a class in programming. The relationship is directional: containers reference images, but images don&#39;t know about their running instances.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Image (template)\n    ↑ referenced by\nContainer (instance)</code></pre></div>\n\n<p><strong>Key behaviors:</strong></p>\n<ul>\n<li>Multiple containers can reference the same image (sharing layers via OverlayFS)</li>\n<li>Images are immutable; containers add writable layers on top</li>\n<li>Deleting an image fails if any containers still reference it</li>\n<li>Container configuration (<code>ContainerConfig</code>) overrides image defaults (<code>ImageConfig</code>)</li>\n</ul>\n<p>This relationship is managed through the <code>ContainerConfig.Image</code> field, which contains the image name or digest. The runtime resolves this to an actual <code>Image</code> object during container creation.</p>\n<h4 id=\"container-state-transitions\">Container State Transitions</h4>\n<p>The container lifecycle defines a <strong>state machine</strong> where each transition corresponds to a management operation. The following table shows all valid transitions and the operations that trigger them:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event/Operation</th>\n<th>Next State</th>\n<th>Actions Performed During Transition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>(nonexistent)</td>\n<td><code>CreateContainer</code></td>\n<td><code>Created</code></td>\n<td>Validate config, allocate ID, persist metadata, prepare namespaces and rootfs</td>\n</tr>\n<tr>\n<td><code>Created</code></td>\n<td><code>StartContainer</code></td>\n<td><code>Running</code></td>\n<td>Create cgroups, apply limits, setup network, start init process</td>\n</tr>\n<tr>\n<td><code>Created</code></td>\n<td><code>RemoveContainer</code></td>\n<td><code>Removed</code></td>\n<td>Clean up any prepared resources (namespaces, rootfs)</td>\n</tr>\n<tr>\n<td><code>Running</code></td>\n<td><code>StopContainer</code> (or process exits)</td>\n<td><code>Stopped</code></td>\n<td>Send termination signal, wait for exit, update state</td>\n</tr>\n<tr>\n<td><code>Running</code></td>\n<td><code>PauseContainer</code></td>\n<td><code>Paused</code></td>\n<td>Freeze cgroup, suspend all processes</td>\n</tr>\n<tr>\n<td><code>Paused</code></td>\n<td><code>ResumeContainer</code></td>\n<td><code>Running</code></td>\n<td>Unfreeze cgroup, resume processes</td>\n</tr>\n<tr>\n<td><code>Stopped</code></td>\n<td><code>RemoveContainer</code></td>\n<td><code>Removed</code></td>\n<td>Delete cgroups, network namespace, mounted filesystems</td>\n</tr>\n<tr>\n<td>Any</td>\n<td>Error during operation</td>\n<td><code>Stopped</code></td>\n<td>Clean up partially created resources, log error</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Implementation Detail:</strong> The transition from <code>Stopped</code> to <code>Removed</code> is irreversible and must clean up <strong>all</strong> resources (cgroups, network interfaces, mount points). Resource leaks occur if any resource isn&#39;t properly released during this transition.</p>\n</blockquote>\n<h4 id=\"layer-composition-and-sharing\">Layer Composition and Sharing</h4>\n<p>Images use a <strong>layered composition</strong> model where each layer builds upon previous ones. Containers then add a writable layer on top of the image stack:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Container Writable Layer (upperdir)\n    ↑\nImage Layer N (topmost read-only layer)\n    ↑\nImage Layer N-1\n    ↑\n...\n    ↑\nImage Layer 1 (base layer)\n    ↑\nBase Filesystem (scratch)</code></pre></div>\n\n<p><strong>Sharing implications:</strong></p>\n<ul>\n<li>Identical layers across images are stored once and referenced multiple times (content-addressable storage)</li>\n<li>When a container modifies a file from a read-only layer, OverlayFS performs <strong>copy-on-write</strong> to the writable layer</li>\n<li>Deleting an image only removes its unique layers; shared layers remain until all referencing images are deleted</li>\n<li>The runtime must track layer reference counts to implement garbage collection</li>\n</ul>\n<p>This relationship is captured through the <code>Image.Layers</code> field (ordered list) and the filesystem manager&#39;s layer stacking logic.</p>\n<h4 id=\"network-configuration-inheritance\">Network Configuration Inheritance</h4>\n<p>Network settings follow a <strong>hierarchical override</strong> pattern where container-specific settings override network defaults:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Network Defaults (bridge: byob0, subnet: 172.17.0.0/16)\n    ↑ can be overridden by\nContainer NetworkConfig\n    ↑ can be overridden by\nRuntime State (actual assigned IP, port mappings in iptables)</code></pre></div>\n\n<p>For example, if the container doesn&#39;t specify an <code>IPAddress</code>, the network manager assigns one from the bridge&#39;s DHCP range. If no <code>BridgeName</code> is specified, the default bridge is used. This inheritance chain ensures sensible defaults while allowing customization.</p>\n<h4 id=\"data-persistence-relationships\">Data Persistence Relationships</h4>\n<p>Different parts of the data model have different persistence requirements:</p>\n<table>\n<thead>\n<tr>\n<th>Entity</th>\n<th>Storage Location</th>\n<th>Format</th>\n<th>Lifetime</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Container</code> metadata</td>\n<td><code>/var/lib/byob/containers/{id}/config.json</code></td>\n<td>JSON</td>\n<td>Until explicit removal</td>\n</tr>\n<tr>\n<td><code>Container</code> runtime state</td>\n<td>In-memory + above JSON</td>\n<td>Go struct + JSON</td>\n<td>Runtime + persisted</td>\n</tr>\n<tr>\n<td><code>Image</code> metadata</td>\n<td><code>/var/lib/byob/images/{digest}/manifest.json</code></td>\n<td>JSON</td>\n<td>Until all referencing containers removed and image deleted</td>\n</tr>\n<tr>\n<td><code>ImageLayer</code> contents</td>\n<td><code>/var/lib/byob/layers/{digest}/</code></td>\n<td>Extracted files</td>\n<td>Until all referencing images removed</td>\n</tr>\n<tr>\n<td>Network allocation state</td>\n<td><code>/var/lib/byob/network/allocations.json</code></td>\n<td>JSON</td>\n<td>Until host reboot or network cleanup</td>\n</tr>\n</tbody></table>\n<p>These persistence relationships ensure the runtime can:</p>\n<ol>\n<li>Recover container state after a restart (critical for managing long-running containers)</li>\n<li>Share images across multiple containers efficiently</li>\n<li>Avoid IP address conflicts by tracking allocations</li>\n<li>Implement garbage collection for unused layers</li>\n</ol>\n<h4 id=\"component-ownership-relationships\">Component Ownership Relationships</h4>\n<p>Each component in the high-level architecture owns specific parts of the data model:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Owned Data</th>\n<th>Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container Manager</td>\n<td><code>Container</code> objects, state transitions</td>\n<td>Lifecycle management, persistence</td>\n</tr>\n<tr>\n<td>Image Handler</td>\n<td><code>Image</code> objects, layer storage</td>\n<td>Image download, extraction, caching</td>\n</tr>\n<tr>\n<td>Filesystem Manager</td>\n<td>Layer directories, mount points</td>\n<td>OverlayFS stacking, rootfs preparation</td>\n</tr>\n<tr>\n<td>Network Manager</td>\n<td>IP allocations, veth interfaces</td>\n<td>Network namespace setup, connectivity</td>\n</tr>\n<tr>\n<td>cgroup Manager</td>\n<td>cgroup directories, process memberships</td>\n<td>Resource limit enforcement</td>\n</tr>\n</tbody></table>\n<p>This ownership model prevents data races and ensures each component has authority over its domain. For example, only the cgroup Manager should write to cgroup control files, while only the Network Manager should modify iptables rules.</p>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fdata-model-types.svg\" alt=\"Data Model Type Relationships\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete implementation starting points for the data model structures and their persistence.</p>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Data serialization</td>\n<td>JSON (<code>encoding/json</code>)</td>\n<td>Protocol Buffers (<code>google.golang.org/protobuf</code>)</td>\n</tr>\n<tr>\n<td>Unique ID generation</td>\n<td>Random hex (<code>crypto/rand</code>)</td>\n<td>ULID or UUID v4</td>\n</tr>\n<tr>\n<td>Time handling</td>\n<td><code>time.Time</code> with <code>time.RFC3339</code></td>\n<td>Monotonic timestamps for ordering</td>\n</tr>\n<tr>\n<td>File storage</td>\n<td>Direct filesystem I/O</td>\n<td>Embedded database (BoltDB, SQLite)</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/byob/                       # CLI entry point\n    main.go\n  internal/\n    runtime/                      # Container Manager component\n      container.go                # Container struct and methods\n      manager.go                  # Runtime interface implementation\n      state.go                    # State machine logic\n    image/                        # Image Handler component  \n      image.go                    # Image struct and methods\n      store.go                    # Image storage and retrieval\n    config/                       # Configuration structures\n      types.go                    # All data model structs (ContainerConfig, etc.)\n    storage/                      # Persistence layer\n      persistence.go              # JSON serialization/deserialization\n      paths.go                    # Filesystem path management\n  pkg/\n    uuid/                         # ID generation utilities\n      uuid.go</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete):</strong></p>\n<p>Here&#39;s a complete, ready-to-use implementation for the core data structures and their JSON persistence:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/config/types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> config</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCreated</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateRunning</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"running\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatePaused</span><span style=\"color:#B392F0\">  ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paused\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateStopped</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"stopped\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateRemoved</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"removed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Image      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"image\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cmd        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"cmd,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Env        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"env,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"working_dir,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Hostname   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"hostname,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limits     </span><span style=\"color:#B392F0\">ResourceLimits</span><span style=\"color:#9ECBFF\"> `json:\"limits\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Network    </span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#9ECBFF\">  `json:\"network\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryMB  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"memory_mb\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPUShares </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"cpu_shares\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PidsLimit </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"pids_limit\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Mode         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"mode\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BridgeName   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"bridge_name,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"ip_address,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#9ECBFF\"> `json:\"port_mappings,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PortMapping</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HostPort      </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"host_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerPort </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"container_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Protocol      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"protocol\"`</span><span style=\"color:#6A737D\"> // \"tcp\" or \"udp\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Container</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State     </span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#9ECBFF\">  `json:\"state\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Config    </span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#9ECBFF\"> `json:\"config\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pid       </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">             `json:\"pid,omitempty\"`</span><span style=\"color:#6A737D\"> // 0 if not running</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">       `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Image</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Digest </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"digest\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Layers []</span><span style=\"color:#B392F0\">ImageLayer</span><span style=\"color:#9ECBFF\"> `json:\"layers\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Config </span><span style=\"color:#B392F0\">ImageConfig</span><span style=\"color:#9ECBFF\">  `json:\"config\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ImageLayer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Digest </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"digest\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Size   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">  `json:\"size\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"path\"`</span><span style=\"color:#6A737D\"> // Filesystem path to extracted layer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ImageConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entrypoint []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"entrypoint,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cmd        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"cmd,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Env        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"env,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"working_dir,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// internal/storage/persistence.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourusername/byob/internal/config</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerStore</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    basePath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewContainerStore</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">basePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerStore</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ContainerStore</span><span style=\"color:#E1E4E8\">{basePath: basePath}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Save</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">config</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containerPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(s.basePath, container.ID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(containerPath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"create container directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerPath, </span><span style=\"color:#9ECBFF\">\"config.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">MarshalIndent</span><span style=\"color:#E1E4E8\">(container, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"marshal container config: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(configPath, data, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"write container config: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">config</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(s.basePath, id, </span><span style=\"color:#9ECBFF\">\"config.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(configPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"read container config: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> container </span><span style=\"color:#B392F0\">config</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">container); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unmarshal container config: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">container, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containerPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(s.basePath, id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only delete if container is in \"removed\" state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerPath, </span><span style=\"color:#9ECBFF\">\"config.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(configPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">os.</span><span style=\"color:#B392F0\">IsNotExist</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"check container state: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> container </span><span style=\"color:#B392F0\">config</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">container); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> container.State </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> config.StateRemoved {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"container </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> is not in removed state\"</span><span style=\"color:#E1E4E8\">, id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">RemoveAll</span><span style=\"color:#E1E4E8\">(containerPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// pkg/uuid/uuid.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> uuid</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/hex</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Generate</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rand.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(bytes); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"generate random bytes: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hex.</span><span style=\"color:#B392F0\">EncodeToString</span><span style=\"color:#E1E4E8\">(bytes), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Short</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rand.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(bytes); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fallback to timestamp-based ID if crypto fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hex.</span><span style=\"color:#B392F0\">EncodeToString</span><span style=\"color:#E1E4E8\">(bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/runtime/manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourusername/byob/internal/config</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourusername/byob/pkg/uuid</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerRuntime</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    store </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">storage</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerStore</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Other component managers will be added here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewContainerRuntime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    store </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> storage.</span><span style=\"color:#B392F0\">NewContainerStore</span><span style=\"color:#E1E4E8\">(storePath)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create store directory if it doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize other managers (network, cgroup, filesystem)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Load existing containers and restore their state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">{store: store}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerConfig</span><span style=\"color:#B392F0\"> config</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">config</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate containerConfig (check image exists, valid resource limits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate unique container ID using uuid.Generate()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Merge image config with container config (image defaults → container overrides)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create Container struct with State = StateCreated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set CreatedAt to current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Save container to persistence store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Prepare root filesystem (but don't start process yet)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return the created container object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load container from store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate container is in StateCreated state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create namespaces using namespace manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Setup cgroups with limits from container.Config.Limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Configure network using network manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Fork/exec the container process inside the namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update container State = StateRunning, set Pid to child PID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Save updated container to store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Monitor container process for exit (in goroutine)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StopContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">force</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load container from store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate container is in StateRunning or StatePaused state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send SIGTERM (or SIGKILL if force) to container.Pid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for process to exit with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Clean up resources (cgroups, network, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update container State = StateStopped, clear Pid field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Save updated container to store</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load container from store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate container is in StateStopped or StateCreated state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If StateCreated, clean up prepared resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Delete container root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update container State = StateRemoved</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Save updated container to store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Delete container directory from store (optional cleanup)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ol>\n<li><p><strong>JSON serialization:</strong> Use <code>json.MarshalIndent(container, &quot;&quot;, &quot;  &quot;)</code> for human-readable config files. The <code>omitempty</code> tag prevents zero values from cluttering the JSON.</p>\n</li>\n<li><p><strong>Time handling:</strong> Always use <code>time.Now().UTC()</code> for timestamps to ensure consistency across timezones. Store as RFC3339 format in JSON.</p>\n</li>\n<li><p><strong>Error wrapping:</strong> Use <code>fmt.Errorf(&quot;operation: %w&quot;, err)</code> pattern throughout to create actionable error messages with context.</p>\n</li>\n<li><p><strong>File permissions:</strong> Use <code>0755</code> for directories, <code>0644</code> for config files, and <code>0700</code> for sensitive data.</p>\n</li>\n<li><p><strong>Path construction:</strong> Always use <code>filepath.Join()</code> instead of string concatenation for cross-platform compatibility.</p>\n</li>\n</ol>\n<p><strong>Milestone Checkpoint (Data Model):</strong></p>\n<p>After implementing the data model structures and persistence layer, verify functionality with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create and run a simple test</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> project-root</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/config/...</span><span style=\"color:#9ECBFF\"> ./internal/storage/...</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output should show:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: TestContainerSaveLoad</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: TestImageSerialization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: TestStateTransitions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> /tmp/byob-test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/byob/main.go</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --name</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> echo</span><span style=\"color:#9ECBFF\"> \"hello\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check that /tmp/byob-test/containers/ contains a directory with config.json</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># The config.json should have all fields properly serialized</span></span></code></pre></div>\n\n<p><strong>Debugging Tips for Data Model Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container config fails to save</td>\n<td>Permission denied on store directory</td>\n<td>Check <code>os.MkdirAll</code> error return</td>\n<td>Ensure runtime has write permissions to store path</td>\n</tr>\n<tr>\n<td>JSON unmarshal fails</td>\n<td>Type mismatch or extra fields</td>\n<td>Print raw JSON before unmarshaling</td>\n<td>Ensure struct tags match JSON fields exactly</td>\n</tr>\n<tr>\n<td>Container ID collisions</td>\n<td>Poor random number generation</td>\n<td>Test <code>uuid.Generate()</code> in a loop</td>\n<td>Use crypto/rand with proper error handling</td>\n</tr>\n<tr>\n<td>State transitions violating rules</td>\n<td>Missing validation logic</td>\n<td>Add state transition matrix check</td>\n<td>Implement <code>canTransition(from, to State) bool</code> helper</td>\n</tr>\n<tr>\n<td>Resource leaks on removal</td>\n<td>Missing cleanup in RemoveContainer</td>\n<td>Add logging for each resource cleanup step</td>\n<td>Ensure all managers have cleanup methods called</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Process Isolation (Namespaces)</p>\n</blockquote>\n<h2 id=\"component-design-process-isolation-milestone-1\">Component Design: Process Isolation (Milestone 1)</h2>\n<p>Process isolation is the foundational component of our container runtime. It leverages Linux namespaces to create separate, isolated environments for containerized processes, providing the illusion that each container is running on its own system. This section details the design of the namespace isolation component.</p>\n<h3 id=\"mental-model-private-rooms-with-mirrored-walls\">Mental Model: Private Rooms with Mirrored Walls</h3>\n<p>Imagine a large, open-plan office (the host operating system). To create private work areas, we build enclosed rooms (containers) with special &quot;mirrored walls&quot; (namespaces). Each room has:</p>\n<ol>\n<li><strong>Private Bulletin Board (PID Namespace):</strong> A list of everyone in the room (processes). People inside only see their own list. The person who enters first is designated as the &quot;Manager&quot; (PID 1).</li>\n<li><strong>Private Nameplate (UTS Namespace):</strong> The room has its own name and company sign (hostname and NIS domain name), independent of the building&#39;s main signage.</li>\n<li><strong>Private Furniture &amp; Layout (Mount Namespace):</strong> The room can have its own furniture arrangement (filesystem mount points). Adding or removing a desk (mounting/unmounting) in this room doesn&#39;t affect the open-plan office or other rooms.</li>\n<li><strong>Private Phone System (Network Namespace):</strong> The room has its own phone lines, internal extensions, and switchboard. Calls within the room are private, and external calls must go through the building&#39;s main reception (host network).</li>\n<li><strong>Private Meeting Room (IPC Namespace):</strong> The room has its own whiteboards and message boards (System V IPC objects, POSIX message queues) that only its occupants can use.</li>\n</ol>\n<p>These &quot;mirrored walls&quot; create a powerful illusion: from inside the room, it appears you are in your own, self-contained building. The namespace component is responsible for constructing these private rooms for each container.</p>\n<h3 id=\"architecture-decision-records-for-namespace-strategy\">Architecture Decision Records for Namespace Strategy</h3>\n<blockquote>\n<p><strong>Decision: Use the <code>clone()</code> Syscall with Combined Flags for Initial Process Isolation</strong></p>\n<ul>\n<li><strong>Context:</strong> We need to launch the container&#39;s initial process (the <code>init</code> process) in a set of isolated namespaces. The two primary Linux APIs for namespace creation are <code>clone()</code> (creates a new process in new namespaces) and <code>unshare()</code> (moves the calling process into new namespaces). We must choose the primary method for the initial container launch.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong><code>clone()</code> with namespace flags:</strong> Create the container process directly in new namespaces.</li>\n<li><strong><code>fork()</code> + <code>unshare()</code>:</strong> Fork the current process, then have the child call <code>unshare()</code> to enter new namespaces before executing the container command.</li>\n<li><strong>Combination (clone for most, user ns first):</strong> Use <code>clone()</code> with <code>CLONE_NEWUSER</code> first, then use <code>setns()</code> to join other namespaces for enhanced security.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Use <code>clone()</code> with a combined set of namespace flags (e.g., <code>CLONE_NEWPID | CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWNET</code>) to create the container&#39;s first process. This is a single, atomic operation.</li>\n<li><strong>Rationale:</strong> The <code>clone()</code> approach is simpler, more atomic, and aligns with the standard pattern used by runc and other OCI runtimes. It cleanly creates a new process that is immediately isolated, without the intermediate state and potential race conditions of a <code>fork()</code>+<code>unshare()</code> sequence. It also provides a clear parent-child relationship between the runtime manager and the container <code>init</code> process.</li>\n<li><strong>Consequences:</strong> This decision centralizes namespace creation logic at process launch. It requires the runtime process to have appropriate privileges (typically root) to create most namespaces. It also means the container <code>init</code> process will be the direct child of the runtime, simplifying state tracking and signal forwarding.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>clone()</code> with flags</td>\n<td align=\"left\">Atomic, simple, standard pattern.</td>\n<td align=\"left\">Requires CAP_SYS_ADMIN for most namespaces (except user).</td>\n<td align=\"left\"><strong>Yes</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><code>fork()</code> + <code>unshare()</code></td>\n<td align=\"left\">More flexibility in multi-stage setup.</td>\n<td align=\"left\">Non-atomic, complex state management, potential for leaks.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">User ns first</td>\n<td align=\"left\">Enhanced security via privilege dropping.</td>\n<td align=\"left\">Significantly more complex, requires mapping UIDs/GIDs.</td>\n<td align=\"left\">No (considered for future extension)</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fnamespace-hierarchy.svg\" alt=\"Namespace Hierarchy\"></p>\n<blockquote>\n<p><strong>Decision: Implement a <code>NamespaceManager</code> Component for Lifecycle Operations</strong></p>\n<ul>\n<li><strong>Context:</strong> Namespace creation, management, and cleanup are distinct operations that must be coordinated with the container&#39;s lifecycle. These operations also differ for the initial <code>init</code> process versus subsequent <code>exec</code> operations (like <code>docker exec</code>).</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Inline in <code>StartContainer</code>:</strong> Place all namespace logic directly within the container start sequence.</li>\n<li><strong>Dedicated <code>NamespaceManager</code>:</strong> Create a component responsible for namespace operations, providing a clean API.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Implement a dedicated <code>NamespaceManager</code> component. It will expose methods like <code>CreateNamespaces(flags int)</code> to launch processes in namespaces and <code>JoinNetworkNamespace(path string)</code> for attaching to existing namespaces.</li>\n<li><strong>Rationale:</strong> A dedicated manager promotes separation of concerns, testability, and code reuse. It encapsulates the low-level syscall details and provides a clear interface for the <code>ContainerManager</code>. This pattern also aligns with our other managers (<code>CgroupManager</code>, <code>FilesystemManager</code>).</li>\n<li><strong>Consequences:</strong> Introduces an additional component to the architecture but creates a cleaner, more modular design. The <code>ContainerManager</code> orchestrates the managers but does not need to know the specifics of <code>clone()</code> flags or <code>/proc/&lt;pid&gt;/ns</code> file handling.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Inline Logic</td>\n<td align=\"left\">Fewer components, direct control.</td>\n<td align=\"left\">Blurs responsibilities, harder to test and reuse.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Dedicated Manager</td>\n<td align=\"left\">Separation of concerns, testable, reusable API.</td>\n<td align=\"left\">Slight increase in architectural complexity.</td>\n<td align=\"left\"><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-namespace-implementation\">Common Pitfalls in Namespace Implementation</h3>\n<p>⚠️ <strong>Pitfall: Incorrect PID Namespace Setup Leading to Host PID Visibility</strong></p>\n<ul>\n<li><strong>Description:</strong> A process is placed in a new PID namespace (<code>CLONE_NEWPID</code>), but running <code>ps aux</code> or <code>ls /proc</code> inside the container still shows all host processes.</li>\n<li><strong>Why it&#39;s Wrong:</strong> The <code>/proc</code> filesystem is a view into the kernel&#39;s process information. A new PID namespace only controls the PID numbers; you must also have a separate mount namespace and (re-)mount <code>/proc</code> <em>inside</em> that namespace for <code>ps</code> to reflect the isolated PID view.</li>\n<li><strong>Fix:</strong> Ensure the container has its own mount namespace (<code>CLONE_NEWNS</code>) and mount a new <code>proc</code> filesystem on <code>/proc</code> after setting up the root filesystem. Do this before executing the final container command.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to Isolate the Mount Namespace (<code>CLONE_NEWNS</code>)</strong></p>\n<ul>\n<li><strong>Description:</strong> The container can mount or unmount filesystems, and these changes are visible and affect the host and other containers.</li>\n<li><strong>Why it&#39;s Wrong:</strong> Mount operations should be contained within the container. Without <code>CLONE_NEWNS</code>, the container shares the global mount table, breaking isolation and creating a security risk.</li>\n<li><strong>Fix:</strong> Always include <code>CLONE_NEWNS</code> in the set of flags passed to <code>clone()</code> or <code>unshare()</code>. Note: The flag&#39;s name is historical; it is the flag for creating a new mount namespace.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: <code>CLONE_NEWPID</code> and the Parent&#39;s View</strong></p>\n<ul>\n<li><strong>Description:</strong> A developer expects the parent process (the container runtime) to see the container&#39;s <code>init</code> process as PID 1. Instead, the parent still sees the child with a regular host PID.</li>\n<li><strong>Why it&#39;s Wrong:</strong> PID namespaces are hierarchical. A process&#39;s PID is relative to its namespace. The parent resides in the <em>initial</em> PID namespace, so it sees the child&#39;s PID in that namespace. The child, inside the new PID namespace, sees itself as PID 1.</li>\n<li><strong>Fix:</strong> This is not a bug but a key property to understand. The runtime must track the child&#39;s host PID for signaling and cgroup management. Use the PID returned by <code>clone()</code> (or <code>fork()</code>).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Cleaning Up Orphaned Namespaces</strong></p>\n<ul>\n<li><strong>Description:</strong> When a container exits, its network namespace (or others) might persist if not explicitly cleaned up, leading to resource leaks (dangling veth interfaces, IP addresses).</li>\n<li><strong>Why it&#39;s Wrong:</strong> Linux maintains a namespace as long as at least one process remains inside or a reference (like an open file descriptor) exists. The runtime must ensure all references are closed.</li>\n<li><strong>Fix:</strong> The <code>NamespaceManager</code> or <code>ContainerManager</code> should be responsible for cleaning up. This includes terminating all processes in the namespace and closing any open file descriptors to <code>/proc/&lt;pid&gt;/ns/*</code> that were kept for later <code>setns()</code> operations.</li>\n</ul>\n<h3 id=\"implementation-guidance-for-namespace-isolation\">Implementation Guidance for Namespace Isolation</h3>\n<p>This section bridges the design concepts to concrete Go code. We&#39;ll structure the namespace management logic within a dedicated component.</p>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option</th>\n<th align=\"left\">Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Namespace Creation</td>\n<td align=\"left\"><code>syscall.SysProcAttr</code> in <code>cmd.SysProcAttr</code> for <code>clone()</code></td>\n<td align=\"left\">Raw <code>syscall.Clone()</code> with more granular control</td>\n</tr>\n<tr>\n<td align=\"left\">Namespace File Handling</td>\n<td align=\"left\"><code>os.Open</code> on <code>/proc/self/ns/*</code></td>\n<td align=\"left\"><code>syscall.Open</code> with <code>O_CLOEXEC</code> for safer file descriptors</td>\n</tr>\n<tr>\n<td align=\"left\">Process Execution</td>\n<td align=\"left\"><code>exec.Command</code> with <code>SysProcAttr</code></td>\n<td align=\"left\">Low-level <code>syscall.ForkExec</code></td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong>\nIntegrate the <code>NamespaceManager</code> into the project structure defined in the High-Level Architecture.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>build-your-own-docker/\n├── cmd/\n│   └── byod/                         # CLI entry point\n├── internal/\n│   ├── container/                    # Container lifecycle and state management\n│   │   ├── manager.go                # ContainerManager (orchestrator)\n│   │   └── store.go                  # ContainerStore (persistence)\n│   ├── namespaces/                   # Namespace isolation component (NEW)\n│   │   ├── manager.go                # NamespaceManager\n│   │   └── util.go                   # Helpers for ns paths, flags\n│   ├── cgroups/                      # Resource limits (Milestone 2)\n│   ├── fs/                           # Filesystem isolation (Milestone 3,4)\n│   ├── network/                      # Networking (Milestone 5)\n│   └── image/                        # Image handling (Milestone 6)\n└── pkg/\n    └── uuid/                         # ID generation utilities</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong>\nThe following is a complete, reusable helper for executing a function in a new set of namespaces. It handles the <code>clone()</code> call and the transition into the child&#39;s context.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/namespaces/runner.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> namespaces</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os/exec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ChildFunc is a function to be executed inside the new namespaces.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The return value will be passed back to the parent as the exit status.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ChildFunc</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RunInNamespaces runs the provided childFunc in a new set of Linux namespaces.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The flags parameter is a bitmask of CLONE_NEW* flags (e.g., syscall.CLONE_NEWPID).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It returns the exit status of the child process as seen by the parent.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RunInNamespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">flags</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">childFunc</span><span style=\"color:#B392F0\"> ChildFunc</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create a pipe for the child to communicate its exit status.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This avoids relying on the child's process exit status which can be</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ambiguous with signals.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r, w, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Pipe</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"create pipe: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cmd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">exec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Cmd</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Path: </span><span style=\"color:#9ECBFF\">\"/proc/self/exe\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Re-execute the current program</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Args: []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"byod-child\"</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#6A737D\">// Special argument for child mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SysProcAttr: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SysProcAttr</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Cloneflags: syscall.</span><span style=\"color:#B392F0\">Cloneflags</span><span style=\"color:#E1E4E8\">(flags),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ExtraFiles: []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span><span style=\"color:#E1E4E8\">{w}, </span><span style=\"color:#6A737D\">// Pipe write end is passed to child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Stdin:      os.Stdin,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Stdout:     os.Stdout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Stderr:     os.Stderr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start the child process. It will execute the code path for \"byod-child\".</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cmd.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"start child process: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parent: close our copy of the write end.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wait for the child to finish and read its exit code from the pipe.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> childStatus </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Fscanf</span><span style=\"color:#E1E4E8\">(r, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">childStatus); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If the pipe read fails, fall back to cmd.Wait().</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        waitErr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cmd.</span><span style=\"color:#B392F0\">Wait</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> waitErr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> exitErr, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> waitErr.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">exec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExitError</span><span style=\"color:#E1E4E8\">); ok {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                childStatus </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> exitErr.</span><span style=\"color:#B392F0\">ExitCode</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                childStatus </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure the child process is reaped.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cmd.</span><span style=\"color:#B392F0\">Wait</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> childStatus, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ChildEntryPoint is called from the main function when args[0] == \"byod-child\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It reads the exit status from the child function and writes it to the pipe.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ChildEntryPoint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">childFunc</span><span style=\"color:#B392F0\"> ChildFunc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The pipe write end is file descriptor 3 (ExtraFiles[0]).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pipe </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">NewFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"pipe\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pipe </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> pipe.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> childFunc</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Fprintf</span><span style=\"color:#E1E4E8\">(pipe, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, status)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(status)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong>\nThe main logic for the <code>NamespaceManager</code> involves creating namespaces and providing a way to launch processes within them.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/namespaces/manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> namespaces</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manager handles creation and management of Linux namespaces.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Manager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We may store paths to namespace files for later joining (e.g., for exec).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For simplicity, this initial version focuses on creation.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewManager creates a new NamespaceManager.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewManager</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateNamespaces launches a process in new namespaces.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It configures the provided exec.Cmd to run inside the specified namespaces.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the host PID of the created process.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateNamespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cmd</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">exec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">flags</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cmd.SysProcAttr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cmd.SysProcAttr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SysProcAttr</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cmd.SysProcAttr.Cloneflags </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Cloneflags</span><span style=\"color:#E1E4E8\">(flags)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Ensure the process will have a controlling terminal if needed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set the Pdeathsig attribute to ensure child dies if parent dies (optional).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start the process using cmd.Start().</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the process's PID (cmd.Process.Pid).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetNamespacePath returns the path to a namespace file for a given process.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example: GetNamespacePath(pid, \"pid\") returns \"/proc/pid/ns/pid\".</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetNamespacePath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nsType</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate nsType against known types: pid, net, mnt, uts, ipc, user.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Construct the path: fmt.Sprintf(\"/proc/%d/ns/%s\", pid, nsType).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if the path exists (os.Stat).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the path.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// JoinNetworkNamespace configures an exec.Cmd to join an existing network namespace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is used for operations like `docker exec`.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">JoinNetworkNamespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cmd</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">exec</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Open the namespace file at nsPath with syscall.Open.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Ensure the file descriptor is closed on exec (FD_CLOEXEC).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set the cmd.SysProcAttr.Cloneflags to avoid creating new namespaces.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set the cmd.SysProcAttr.Setns to the opened file descriptor.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Close the file descriptor after cmd.Start().</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Syscall Flags:</strong> Use the constants from the <code>syscall</code> package: <code>syscall.CLONE_NEWPID</code>, <code>syscall.CLONE_NEWNS</code>, <code>syscall.CLONE_NEWUTS</code>, <code>syscall.CLONE_NEWIPC</code>, <code>syscall.CLONE_NEWNET</code>.</li>\n<li><strong>Process Execution:</strong> The standard <code>exec.Command</code> combined with <code>cmd.SysProcAttr</code> is sufficient for most namespace operations. For very advanced scenarios (like <code>clone()</code> with a custom stack), you would use <code>syscall.Clone()</code> directly.</li>\n<li><strong>Namespace Files:</strong> You can open <code>/proc/&lt;pid&gt;/ns/&lt;type&gt;</code> as a regular file. Holding an open file descriptor keeps the namespace alive, which is useful for keeping a network namespace alive after the <code>init</code> process dies.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong>\nAfter implementing the namespace isolation component, you should be able to run a simple test program inside an isolated environment.</p>\n<ol>\n<li><strong>Expected Output:</strong> Create a test program that prints its PID, hostname, and list of mount points.</li>\n<li><strong>Test Command:</strong> Run it using your <code>RunInNamespaces</code> helper with flags for PID, UTS, and Mount namespaces.</li>\n<li><strong>Verification:</strong><ul>\n<li>The program should report its PID as 1.</li>\n<li>It should be able to change its hostname without affecting the host.</li>\n<li>Running <code>mount -t proc proc /proc</code> and then <code>ls /proc</code> should only show PIDs 1 and maybe a few kernel threads.</li>\n</ul>\n</li>\n<li><strong>Signs of Trouble:</strong><ul>\n<li><strong>PID is not 1:</strong> Ensure you included <code>syscall.CLONE_NEWPID</code>.</li>\n<li><strong>Host hostname changes:</strong> You forgot <code>syscall.CLONE_NEWUTS</code>.</li>\n<li><strong>Cannot mount /proc:</strong> You likely need <code>syscall.CLONE_NEWNS</code> (mount namespace). Also, the process needs <code>CAP_SYS_ADMIN</code> capability (run as root).</li>\n</ul>\n</li>\n</ol>\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">How to Diagnose</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Child process exits immediately with no output.</td>\n<td align=\"left\">The child function is not being executed, or the <code>exec.Command</code> arguments are wrong.</td>\n<td align=\"left\">Add debug prints before and inside the child function. Check <code>cmd.Path</code> and <code>cmd.Args</code>.</td>\n<td align=\"left\">Ensure <code>ChildEntryPoint</code> is called correctly in your main function when the special argument is present.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ps aux</code> inside container shows all host processes.</td>\n<td align=\"left\"><code>/proc</code> is not remounted inside the new PID namespace.</td>\n<td align=\"left\">Check if you have <code>CLONE_NEWNS</code> and are mounting proc after <code>chroot</code>/<code>pivot_root</code>.</td>\n<td align=\"left\">Mount a new procfs: <code>syscall.Mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;&quot;)</code> inside the container&#39;s mount namespace.</td>\n</tr>\n<tr>\n<td align=\"left\">Container can still see host network interfaces.</td>\n<td align=\"left\"><code>CLONE_NEWNET</code> flag was not included.</td>\n<td align=\"left\">Check the flags passed to <code>RunInNamespaces</code> or <code>CreateNamespaces</code>.</td>\n<td align=\"left\">Add <code>syscall.CLONE_NEWNET</code> to the flag set.</td>\n</tr>\n<tr>\n<td align=\"left\">Getting &quot;operation not permitted&quot; errors.</td>\n<td align=\"left\">Insufficient privileges (not running as root).</td>\n<td align=\"left\">Run your runtime with <code>sudo</code>.</td>\n<td align=\"left\">Ensure the binary is executed as root (or has the necessary capabilities via <code>setcap</code>).</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2: Resource Limits (cgroups)</p>\n</blockquote>\n<h2 id=\"component-design-resource-limits-via-cgroups-milestone-2\">Component Design: Resource Limits via cgroups (Milestone 2)</h2>\n<p>This component is responsible for enforcing resource constraints on containerized processes using Linux <strong>cgroups</strong> (control groups). While namespaces provide isolation boundaries, cgroups provide the resource accounting and limiting mechanisms that prevent any single container from monopolizing system resources like CPU, memory, or process slots. This component translates the abstract <code>ResourceLimits</code> configuration into concrete kernel-level resource controls.</p>\n<h3 id=\"mental-model-resource-quotas-in-an-apartment-building\">Mental Model: Resource Quotas in an Apartment Building</h3>\n<p>Imagine an apartment building where each tenant (container) has access to shared building resources. Without controls, one tenant could:</p>\n<ol>\n<li>Use all the building&#39;s water pressure (CPU)</li>\n<li>Generate so much garbage that the dumpsters overflow (memory)</li>\n<li>Invite hundreds of guests who block the hallways (processes)</li>\n</ol>\n<p>The building manager (cgroup manager) solves this by installing:</p>\n<ul>\n<li><strong>Individual water meters with flow restrictors</strong> (CPU limits): Each apartment gets a maximum flow rate</li>\n<li><strong>Designated garbage bin capacity</strong> (memory limits): Each apartment gets a specific bin size; overflowing bins get removed (OOM-killed)</li>\n<li><strong>Guest limit per apartment</strong> (PIDs limit): Each apartment can only register a set number of residents</li>\n</ul>\n<p>These quotas apply collectively to everyone in the apartment, not per person. If you have five roommates sharing an apartment, they collectively share the apartment&#39;s quotas. Similarly, all processes within a container (including child processes and their descendants) share the container&#39;s cgroup resource limits.</p>\n<p>The key insight is that cgroups don&#39;t just monitor resource usage—they actively enforce hard limits through kernel mechanisms that throttle, deny, or terminate processes that exceed their allocations. This enforcement happens at the kernel level, making it both efficient and unavoidable for processes within the cgroup.</p>\n<h3 id=\"architecture-decision-records-for-cgroup-version\">Architecture Decision Records for cgroup Version</h3>\n<h4 id=\"decision-cgroup-v2-as-primary-target-with-v1-fallback\">Decision: cgroup v2 as Primary Target with v1 Fallback</h4>\n<p><strong>Context</strong>: Linux has two major cgroup implementations: the original cgroup v1 (with multiple, sometimes inconsistent controllers) and the unified hierarchy of cgroup v2. Modern distributions (Ubuntu 22.04+, Fedora 31+, RHEL 8+) default to cgroup v2, but many production systems still run cgroup v1. Our container runtime must work reliably across both versions.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Exclusive cgroup v2 support</strong>: Assume modern Linux and only implement v2 interfaces</li>\n<li><strong>Exclusive cgroup v1 support</strong>: Target older systems but miss modern features like memory pressure notifications</li>\n<li><strong>Dual-stack with automatic detection</strong>: Detect available cgroup version and use appropriate implementation</li>\n<li><strong>User-configurable with automatic fallback</strong>: Allow explicit configuration but fall back based on system detection</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Exclusive cgroup v2</td>\n<td>Cleaner API, unified hierarchy, better memory management</td>\n<td>Doesn&#39;t work on older systems (~30% of production)</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Exclusive cgroup v1</td>\n<td>Maximum compatibility with existing systems</td>\n<td>Misses v2 improvements, inconsistent controller mounting</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Dual-stack auto-detection</td>\n<td>Works everywhere, uses best available version</td>\n<td>More complex implementation, testing burden</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Configurable with fallback</td>\n<td>User control when needed, still works automatically</td>\n<td>Complexity of config parsing and validation</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p><strong>Decision</strong>: Implement dual-stack cgroup management with automatic version detection. The runtime will check <code>/sys/fs/cgroup/cgroup.controllers</code> to determine if cgroup v2 is mounted; if present, use v2 interfaces; otherwise, fall back to cgroup v1 with separate controller hierarchies.</p>\n<p><strong>Rationale</strong>:</p>\n<ol>\n<li><strong>User experience</strong>: Most users won&#39;t know or care about cgroup versions; they expect containers to &quot;just work&quot;</li>\n<li><strong>Forward compatibility</strong>: As systems upgrade to cgroup v2, our runtime automatically uses the better API</li>\n<li><strong>Maintainability</strong>: We can implement a common interface with version-specific backends, keeping logic clean</li>\n<li><strong>Production readiness</strong>: Many container orchestration systems (Kubernetes, Docker) already use this approach</li>\n</ol>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li>We must implement and test two code paths</li>\n<li>Resource limit configuration may need translation between versions (e.g., CPU shares vs CPU weight)</li>\n<li>Some advanced features (like cgroup v2&#39;s memory pressure stall information) may only be available in v2 mode</li>\n<li>The implementation must handle mixed systems where some controllers are v1 and others v2 (hybrid mode)</li>\n</ul>\n<h4 id=\"decision-hierarchical-cgroup-organization-by-container-id\">Decision: Hierarchical cgroup Organization by Container ID</h4>\n<p><strong>Context</strong>: cgroups can be organized in hierarchies. We need to decide how to structure our cgroups relative to each other and to system cgroups.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Flat organization</strong>: All containers at the same level under a runtime parent</li>\n<li><strong>Hierarchical by container ID</strong>: Each container gets its own nested cgroup</li>\n<li><strong>Pool-based organization</strong>: Group containers by resource class (high-memory, low-CPU, etc.)</li>\n<li><strong>Integration with systemd</strong>: Delegate cgroup management to systemd via <code>systemd-run</code></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Flat organization</td>\n<td>Simple to implement, easy to enumerate</td>\n<td>No hierarchy for resource delegation, messy cleanup</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Hierarchical by container ID</td>\n<td>Clean isolation, natural cleanup path, supports delegation</td>\n<td>Slightly more complex to create nested groups</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Pool-based</td>\n<td>Could optimize resource allocation</td>\n<td>Complex to manage, requires scheduling logic</td>\n<td>No</td>\n</tr>\n<tr>\n<td>systemd integration</td>\n<td>Leverages system&#39;s cgroup manager, consistent with OS</td>\n<td>Adds systemd dependency, harder to debug</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p><strong>Decision</strong>: Create hierarchical cgroups using the container ID as the cgroup name, nested under a runtime-managed parent cgroup (e.g., <code>/sys/fs/cgroup/container_runtime/{container_id}</code> for v2 or per-controller paths for v1).</p>\n<p><strong>Rationale</strong>:</p>\n<ol>\n<li><strong>Clean resource accounting</strong>: Each container&#39;s resource usage is clearly isolated and measurable</li>\n<li><strong>Simplified cleanup</strong>: Removing the container cgroup recursively removes all resource tracking</li>\n<li><strong>Delegation support</strong>: Future extensions could delegate sub-cgroups to containers (for nested containers)</li>\n<li><strong>Consistency with Docker</strong>: Docker uses similar hierarchical organization, aiding user familiarity</li>\n</ol>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li>Must ensure proper cleanup on container exit to avoid &quot;cgroup leakage&quot;</li>\n<li>Need to handle cgroup filesystem permissions (typically require root)</li>\n<li>Nested cgroups add path complexity that must be managed in both v1 and v2</li>\n</ul>\n<h3 id=\"component-responsibilities-and-interfaces\">Component Responsibilities and Interfaces</h3>\n<p>The cgroup management component has three primary responsibilities:</p>\n<ol>\n<li><strong>cgroup Creation and Configuration</strong>: Establish cgroup hierarchies and apply resource limits before process execution</li>\n<li><strong>Process Attachment</strong>: Move processes (and their future descendants) into the appropriate cgroups</li>\n<li><strong>Cleanup and Resource Reclamation</strong>: Remove cgroups when containers are destroyed</li>\n</ol>\n<h4 id=\"data-structures\">Data Structures</h4>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Fields</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CgroupManager</code></td>\n<td><code>version int</code>, <code>basePath string</code>, <code>controllers map[string]bool</code></td>\n<td>Manages cgroup operations, detects version, tracks available controllers</td>\n</tr>\n<tr>\n<td><code>ResourceLimits</code></td>\n<td><code>MemoryMB int</code>, <code>CPUShares int</code>, <code>PidsLimit int</code></td>\n<td>User-specified resource constraints (from <code>ContainerConfig</code>)</td>\n</tr>\n<tr>\n<td><code>CgroupStats</code></td>\n<td><code>MemoryUsage int64</code>, <code>CPUUsage int64</code>, <code>PidCount int</code></td>\n<td>Runtime statistics collected from cgroup interface files</td>\n</tr>\n</tbody></table>\n<h4 id=\"interface-methods\">Interface Methods</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NewCgroupManager()</code></td>\n<td>none</td>\n<td><code>(*CgroupManager, error)</code></td>\n<td>Factory function that detects cgroup version and available controllers</td>\n</tr>\n<tr>\n<td><code>CreateCgroup(containerID string)</code></td>\n<td><code>containerID string</code></td>\n<td><code>error</code></td>\n<td>Creates cgroup hierarchy for the container</td>\n</tr>\n<tr>\n<td><code>ApplyLimits(containerID string, limits ResourceLimits)</code></td>\n<td><code>containerID string</code>, <code>limits ResourceLimits</code></td>\n<td><code>error</code></td>\n<td>Writes resource limits to cgroup control files</td>\n</tr>\n<tr>\n<td><code>AddProcess(containerID string, pid int)</code></td>\n<td><code>containerID string</code>, <code>pid int</code></td>\n<td><code>error</code></td>\n<td>Moves a process (and its future children) into the container&#39;s cgroup</td>\n</tr>\n<tr>\n<td><code>RemoveCgroup(containerID string)</code></td>\n<td><code>containerID string</code></td>\n<td><code>error</code></td>\n<td>Recursively removes the container&#39;s cgroup and all sub-cgroups</td>\n</tr>\n<tr>\n<td><code>GetStats(containerID string)</code></td>\n<td><code>containerID string</code></td>\n<td><code>(*CgroupStats, error)</code></td>\n<td>Reads current resource usage statistics from cgroup interface</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-cgroup-implementation\">Common Pitfalls in cgroup Implementation</h3>\n<h4 id=\"-pitfall-forgetting-to-add-the-process-to-the-cgroup\">⚠️ <strong>Pitfall: Forgetting to Add the Process to the cgroup</strong></h4>\n<p><strong>Description</strong>: Creating cgroups and setting limits but never actually moving the container process into them.</p>\n<p><strong>Why it&#39;s wrong</strong>: cgroup limits only apply to processes within the cgroup. If the container process remains in the root cgroup (or a different cgroup), it won&#39;t be subject to the limits you configured.</p>\n<p><strong>How to fix</strong>: Always call <code>AddProcess</code> with the container&#39;s PID <strong>after</strong> <code>fork</code> but <strong>before</strong> <code>exec</code> in the child process. Better yet, use the cgroup&#39;s <code>cgroup.procs</code> file (v2) or <code>tasks</code> file (v1) which automatically includes all child processes.</p>\n<h4 id=\"-pitfall-not-handling-cgroup-v1-controller-mounts\">⚠️ <strong>Pitfall: Not Handling cgroup v1 Controller Mounts</strong></h4>\n<p><strong>Description</strong>: Assuming all cgroup controllers are mounted in standard locations in cgroup v1.</p>\n<p><strong>Why it&#39;s wrong</strong>: In cgroup v1, each controller (cpu, memory, pids) can be mounted separately, and systems may have different mount points or hierarchies. Some controllers might not be mounted at all.</p>\n<p><strong>How to fix</strong>: Parse <code>/proc/mounts</code> to find controller mount points, check <code>/proc/cgroups</code> for available controllers, and provide clear error messages if required controllers are missing.</p>\n<h4 id=\"-pitfall-memory-limits-don39t-account-for-kernel-memory\">⚠️ <strong>Pitfall: Memory Limits Don&#39;t Account for Kernel Memory</strong></h4>\n<p><strong>Description</strong>: Setting only <code>memory.limit_in_bytes</code> without considering <code>memory.kmem.limit_in_bytes</code> in cgroup v1.</p>\n<p><strong>Why it&#39;s wrong</strong>: Containers can use kernel memory (page cache, sockets, etc.) that isn&#39;t counted against the normal memory limit. A container could exceed total memory through kernel allocations and not be OOM-killed.</p>\n<p><strong>How to fix</strong>: In cgroup v1, also set <code>memory.kmem.limit_in_bytes</code> (typically to the same value as <code>memory.limit_in_bytes</code>). In cgroup v2, the unified <code>memory.max</code> includes both user and kernel memory.</p>\n<h4 id=\"-pitfall-not-cleaning-up-cgroups-on-container-exit\">⚠️ <strong>Pitfall: Not Cleaning Up cgroups on Container Exit</strong></h4>\n<p><strong>Description</strong>: Leaving cgroup directories after container termination.</p>\n<p><strong>Why it&#39;s wrong</strong>: Accumulating empty cgroups wastes inodes, complicates monitoring, and may hit filesystem limits. It also leaks information about past containers.</p>\n<p><strong>How to fix</strong>: Implement <code>RemoveCgroup</code> and call it during container removal. Use <code>SetFinalizer</code> or defer statements to ensure cleanup even on unexpected exits. Consider using cgroup notification to detect when all processes in a cgroup have exited.</p>\n<h4 id=\"-pitfall-misunderstanding-cpu-shares-vs-quotaperiod\">⚠️ <strong>Pitfall: Misunderstanding CPU Shares vs Quota/Period</strong></h4>\n<p><strong>Description</strong>: Confusing the relative <code>cpu.shares</code> with the absolute <code>cpu.cfs_quota_us</code>/<code>cpu.cfs_period_us</code>.</p>\n<p><strong>Why it&#39;s wrong</strong>: CPU shares only matter when there&#39;s contention; a container with 1024 shares gets twice as much CPU as one with 512 shares <strong>only when the CPU is saturated</strong>. Quota/period provides absolute limits (e.g., 0.5 CPU cores maximum).</p>\n<p><strong>How to fix</strong>: Understand your use case: use shares for fair sharing among containers, use quota for hard limits. Document this clearly for users configuring <code>ResourceLimits</code>.</p>\n<h3 id=\"implementation-algorithm\">Implementation Algorithm</h3>\n<p>The cgroup setup follows this sequence during container creation:</p>\n<ol>\n<li><p><strong>Version Detection</strong> (once at runtime initialization):</p>\n<ol>\n<li>Check if <code>/sys/fs/cgroup/cgroup.controllers</code> exists</li>\n<li>If yes, parse it to determine available controllers (cgroup v2)</li>\n<li>If no, check <code>/proc/cgroups</code> and <code>/proc/mounts</code> for cgroup v1 controllers</li>\n</ol>\n</li>\n<li><p><strong>cgroup Creation</strong> (per container):</p>\n<ol>\n<li>Generate cgroup path: <code>/sys/fs/cgroup/container_runtime/{container_id}</code> (v2) or per-controller paths (v1)</li>\n<li>Create directory with appropriate permissions (typically 0755)</li>\n<li>For cgroup v1, repeat for each required controller (cpu, memory, pids)</li>\n</ol>\n</li>\n<li><p><strong>Limit Application</strong>:</p>\n<ol>\n<li>Convert <code>ResourceLimits</code> to cgroup-specific values:<ul>\n<li>Memory: MB → bytes (multiply by 1,048,576)</li>\n<li>CPU shares: Keep as is (1024 = default weight)</li>\n<li>PIDs limit: Set directly</li>\n</ul>\n</li>\n<li>Write to appropriate control files:<ul>\n<li>cgroup v2: <code>memory.max</code>, <code>cpu.weight</code>, <code>pids.max</code></li>\n<li>cgroup v1: <code>memory.limit_in_bytes</code>, <code>memory.kmem.limit_in_bytes</code>, <code>cpu.shares</code>, <code>pids.max</code></li>\n</ul>\n</li>\n<li>Verify writes by reading back and comparing</li>\n</ol>\n</li>\n<li><p><strong>Process Attachment</strong>:</p>\n<ol>\n<li>After <code>fork</code> but before <code>exec</code> in the child, get the child&#39;s PID</li>\n<li>Write PID to <code>cgroup.procs</code> (v2) or each controller&#39;s <code>tasks</code> file (v1)</li>\n<li>Verify the process appears in the cgroup by reading the file back</li>\n</ol>\n</li>\n<li><p><strong>Cleanup</strong> (on container removal):</p>\n<ol>\n<li>Kill all processes in the cgroup (if not already dead)</li>\n<li>Remove all subdirectories recursively</li>\n<li>Remove the container&#39;s cgroup directory</li>\n<li>Verify removal by checking directory existence</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight</strong>: The critical timing requirement is that processes must be added to cgroups <strong>before they start executing user code</strong>. If you add them after <code>exec</code>, there&#39;s a race window where the process could allocate memory or fork child processes outside the limits. Always use the pattern: <code>fork</code> → <code>add to cgroup</code> → <code>apply namespaces</code> → <code>exec</code>.</p>\n</blockquote>\n<h3 id=\"integration-with-container-creation-sequence\">Integration with Container Creation Sequence</h3>\n<p>Referencing the <img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fcontainer-creation-sequence.svg\" alt=\"Container Creation Sequence Diagram\">, cgroup operations occur between namespace creation and filesystem setup:</p>\n<ol>\n<li>CLI receives <code>run</code> command with <code>--memory</code>, <code>--cpus</code> flags</li>\n<li>Container Manager creates <code>ContainerConfig</code> with <code>ResourceLimits</code></li>\n<li>Namespace Manager creates new namespaces via <code>clone()</code> or <code>unshare()</code></li>\n<li><strong>Cgroup Manager creates cgroup and applies limits</strong></li>\n<li><strong>Cgroup Manager adds the forked child process to the cgroup</strong></li>\n<li>Filesystem Manager sets up rootfs with <code>pivot_root()</code></li>\n<li>Network Manager configures veth pair and network namespace</li>\n<li>Container process executes entrypoint within all constraints</li>\n</ol>\n<p>This ordering ensures that:</p>\n<ul>\n<li>Resource limits are active before the process starts meaningful work</li>\n<li>The process inherits the cgroup membership, so all its children are automatically in the same cgroup</li>\n<li>If cgroup setup fails, we can abort before setting up more complex resources like network</li>\n</ul>\n<h3 id=\"error-handling-and-recovery\">Error Handling and Recovery</h3>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection</th>\n<th>Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cgroup filesystem not mounted</td>\n<td><code>open()</code> on cgroup path returns <code>ENOENT</code> or <code>EACCES</code></td>\n<td>Check <code>/proc/mounts</code>, suggest mounting cgroups, or fall back to no resource limits (with warning)</td>\n</tr>\n<tr>\n<td>Insufficient permissions</td>\n<td><code>open()</code> or <code>write()</code> returns <code>EACCES</code></td>\n<td>Require root/sudo, or suggest configuring cgroup delegation</td>\n</tr>\n<tr>\n<td>Invalid limit value</td>\n<td><code>write()</code> succeeds but kernel rejects value (may be silent)</td>\n<td>Read back after write to verify, validate limits against system capacity first</td>\n</tr>\n<tr>\n<td>Controller not available</td>\n<td>Controller file doesn&#39;t exist in cgroup directory</td>\n<td>Skip that controller, warn user, continue without that limit</td>\n</tr>\n<tr>\n<td>Process already in cgroup</td>\n<td><code>write()</code> to <code>cgroup.procs</code> returns <code>EBUSY</code> (v2)</td>\n<td>Check if PID is already in correct cgroup, continue if so</td>\n</tr>\n<tr>\n<td>cgroup cleanup fails</td>\n<td><code>rmdir()</code> returns <code>EBUSY</code> (processes still exist)</td>\n<td>Attempt to kill remaining processes, retry removal</td>\n</tr>\n</tbody></table>\n<h3 id=\"example-walkthrough-memory-limit-enforcement\">Example Walkthrough: Memory Limit Enforcement</h3>\n<p>Consider a container configured with <code>MemoryMB: 100</code> (100MB memory limit):</p>\n<ol>\n<li><strong>Configuration</strong>: <code>ResourceLimits{MemoryMB: 100, CPUShares: 512, PidsLimit: 100}</code> is created</li>\n<li><strong>Translation</strong>: CgroupManager converts 100MB to 104,857,600 bytes</li>\n<li><strong>Writing</strong>: For cgroup v2, writes &quot;104857600&quot; to <code>/sys/fs/cgroup/container_runtime/abc123/memory.max</code></li>\n<li><strong>Enforcement</strong>: Kernel tracks container&#39;s resident memory usage via RSS (Resident Set Size)</li>\n<li><strong>Exceedance</strong>: If container allocates 101MB, kernel invokes OOM killer on processes in the cgroup</li>\n<li><strong>Notification</strong>: CgroupManager could watch <code>memory.events</code> file for &quot;oom_kill&quot; events</li>\n<li><strong>Cleanup</strong>: When container exits, cgroup directory is removed</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight</strong>: Memory limits in cgroups use RSS, which measures physical memory pages. This differs from virtual memory size (which can be much larger due to memory-mapped files, shared libraries, and swap). A container with 100MB limit might have 200MB of virtual memory but only 80MB of RSS.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cgroup Detection</td>\n<td>Parse <code>/proc/mounts</code> manually</td>\n<td>Use <code>github.com/containerd/cgroups</code> library</td>\n</tr>\n<tr>\n<td>File Operations</td>\n<td>Standard <code>os.Open</code>, <code>os.WriteFile</code></td>\n<td>Memory-mapped files for frequent stats polling</td>\n</tr>\n<tr>\n<td>Process Tracking</td>\n<td>Periodic scanning of <code>cgroup.procs</code></td>\n<td>Inotify on cgroup directory for real-time updates</td>\n</tr>\n<tr>\n<td>Statistics Collection</td>\n<td>Read interface files on demand</td>\n<td>Background goroutine with caching for dashboard</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    runtime/           # CLI entry point\n      main.go\n  internal/\n    cgroup/            # cgroup management component\n      manager.go       # Main CgroupManager implementation\n      detector.go      # cgroup version and controller detection\n      v1/              # cgroup v1 specific implementation\n        controller.go  # Per-controller operations\n      v2/              # cgroup v2 specific implementation  \n        unified.go     # Unified hierarchy operations\n      common.go        # Shared utilities and types\n      manager_test.go  # Unit tests\n    container/         # Container lifecycle management\n      manager.go\n    namespace/         # Namespace isolation\n      manager.go\n    # ... other components</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Here&#39;s a complete, ready-to-use cgroup detector that handles both v1 and v2:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/cgroup/detector.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cgroup</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">io/ioutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CgroupVersion represents detected cgroup version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CgroupVersion</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tCgroupV1</span><span style=\"color:#B392F0\"> CgroupVersion</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tCgroupV2</span><span style=\"color:#B392F0\"> CgroupVersion</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tCgroupUnknown</span><span style=\"color:#B392F0\"> CgroupVersion</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ControllerInfo holds detected controller availability</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ControllerInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tVersion     </span><span style=\"color:#B392F0\">CgroupVersion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tControllers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // Available controllers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMountPoints </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Controller -> mount path (v1 only)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DetectCgroupInfo detects cgroup version and available controllers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DetectCgroupInfo</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ControllerInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tinfo </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ControllerInfo</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tControllers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tMountPoints: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Check for cgroup v2 unified hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcgroupV2Path </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> controllers, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(cgroupV2Path, </span><span style=\"color:#9ECBFF\">\"cgroup.controllers\"</span><span style=\"color:#E1E4E8\">)); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tinfo.Version </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CgroupV2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tfor</span><span style=\"color:#E1E4E8\"> _, controller </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Fields</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(controllers)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tinfo.Controllers[controller] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> info, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Fall back to cgroup v1 detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tinfo.Version </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CgroupV1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Parse /proc/cgroups for available controllers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tprocCgroups, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc/cgroups\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot read /proc/cgroups: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlines </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(procCgroups), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> _, line </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> lines[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:] { </span><span style=\"color:#6A737D\">// Skip header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tfields </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Fields</span><span style=\"color:#E1E4E8\">(line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(fields) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> fields[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"1\"</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">// Enabled controller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tcontroller </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fields[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tinfo.Controllers[controller] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Find mount points from /proc/mounts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmounts, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc/mounts\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot read /proc/mounts: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> _, line </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(mounts), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tfields </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Fields</span><span style=\"color:#E1E4E8\">(line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(fields) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> fields[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"cgroup\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\toptions </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(fields[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\",\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\tfor</span><span style=\"color:#E1E4E8\"> _, opt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> options {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\t\tif</span><span style=\"color:#E1E4E8\"> opt </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"cgroup\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">strings.</span><span style=\"color:#B392F0\">HasPrefix</span><span style=\"color:#E1E4E8\">(opt, </span><span style=\"color:#9ECBFF\">\"__\"</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\t\t\tinfo.MountPoints[opt] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fields[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Verify we have required controllers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\trequired </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"memory\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"cpu\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"pids\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> _, req </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> required {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">info.Controllers[req] {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"required cgroup controller </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not available\"</span><span style=\"color:#E1E4E8\">, req)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> _, mounted </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> info.MountPoints[req]; </span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">mounted </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> info.Version </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CgroupV1 {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cgroup controller </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not mounted\"</span><span style=\"color:#E1E4E8\">, req)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> info, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/cgroup/manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cgroup</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CgroupManager manages cgroup operations for containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CgroupManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tversion      </span><span style=\"color:#B392F0\">CgroupVersion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbasePath     </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">            // Base path for cgroup v2 or parent for v1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontrollers  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">   // Available controllers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmountPoints  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Controller mount points (v1 only)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCgroupManager creates a new cgroup manager with auto-detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCgroupManager</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tinfo, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DetectCgroupInfo</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to detect cgroup info: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmanager </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CgroupManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tversion:     info.Version,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tcontrollers: info.Controllers,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tmountPoints: info.MountPoints,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Set base path based on version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> manager.version </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CgroupV2 {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tmanager.basePath </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// For v1, we'll use a parent directory under each controller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tmanager.basePath </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> manager, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateCgroup creates a cgroup for the given container ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> m.version </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CgroupV2 {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 1: Construct full path: filepath.Join(m.basePath, \"container_runtime\", containerID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 2: Create directory with os.MkdirAll, permissions 0755</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 3: Verify directory was created and is writable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 4: For v2, enable controllers by writing to cgroup.subtree_control</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 5: For v1, create directory under each controller's mount point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 6: For each required controller (memory, cpu, pids):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t//   - Build path: filepath.Join(mountPoints[controller], \"container_runtime\", containerID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t//   - Create directory with os.MkdirAll</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 7: Verify all required controller directories were created</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ApplyLimits writes resource limits to the container's cgroup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ApplyLimits</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limits</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> m.version </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CgroupV2 {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 8: Build cgroup path for this container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 9: Apply memory limit: convert MB to bytes, write to \"memory.max\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 10: Apply CPU weight: convert CPUShares to v2 weight (1-10000), write to \"cpu.weight\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 11: Apply PIDs limit: write to \"pids.max\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 12: Verify each write by reading back and comparing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 13: For v1, apply limits to each controller separately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 14: Memory: write to memory.limit_in_bytes and memory.kmem.limit_in_bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 15: CPU: write cpu.shares to cpu directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 16: PIDs: write to pids.max in pids directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 17: Handle memory swappiness (optional): write to memory.swappiness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddProcess adds a process to the container's cgroup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddProcess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tpidStr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">Itoa</span><span style=\"color:#E1E4E8\">(pid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> m.version </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CgroupV2 {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 18: Write PID to cgroup.procs file in container's cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 19: Verify write succeeded by checking if PID appears in file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 20: For v1, write PID to tasks file in each controller's cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 21: Write to memory, cpu, and pids controller tasks files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 22: Handle case where process might already be in a cgroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveCgroup recursively removes the container's cgroup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> m.version </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CgroupV2 {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 23: Build full cgroup path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 24: Kill any remaining processes in cgroup (read cgroup.procs, send SIGKILL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 25: Remove directory with os.RemoveAll</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 26: Retry a few times if directory is busy (EBUSY)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 27: For v1, remove directory under each controller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// TODO 28: For each controller, kill processes, then remove directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><strong>File Operations</strong>: Use <code>ioutil.WriteFile</code> for atomic writes to cgroup control files. The kernel expects entire content at once, not partial writes.</li>\n<li><strong>Error Handling</strong>: Check for <code>os.IsPermission</code> and <code>os.IsNotExist</code> to provide helpful error messages about cgroup configuration.</li>\n<li><strong>Concurrency</strong>: Use a mutex (<code>sync.Mutex</code>) in <code>CgroupManager</code> if multiple goroutines might create cgroups concurrently.</li>\n<li><strong>Cleanup</strong>: Implement <code>RemoveCgroup</code> as an idempotent operation—calling it multiple times should be safe.</li>\n<li><strong>Path Safety</strong>: Always use <code>filepath.Join</code> instead of string concatenation to handle path separators correctly across systems.</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>Test Command</strong>: </p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/cgroup/...</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Expected Output</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>=== RUN   TestCgroupDetection\n--- PASS: TestCgroupDetection (0.01s)\n=== RUN   TestCreateCgroup\n--- PASS: TestCreateCgroup (0.02s)\n=== RUN   TestApplyMemoryLimit\n--- PASS: TestApplyMemoryLimit (0.03s)\n=== RUN   TestAddProcess\n--- PASS: TestAddProcess (0.05s)\nPASS</code></pre></div>\n\n<p><strong>Manual Verification</strong>:</p>\n<ol>\n<li>Run a container with memory limit: <code>sudo ./runtime run --memory 50 alpine echo &quot;hello&quot;</code></li>\n<li>Check cgroup exists: <code>sudo cat /sys/fs/cgroup/container_runtime/{container_id}/memory.max</code></li>\n<li>Should show <code>52428800</code> (50MB in bytes)</li>\n<li>Run a memory-hungry process in container and verify OOM kill occurs when exceeding limit</li>\n</ol>\n<p><strong>Debugging Tips</strong>:</p>\n<ul>\n<li>If cgroup creation fails with &quot;permission denied&quot;, ensure running as root</li>\n<li>If memory limit isn&#39;t enforced, check if you&#39;re using cgroup v1 but forgot <code>memory.kmem.limit_in_bytes</code></li>\n<li>If <code>AddProcess</code> fails with &quot;no such process&quot;, ensure you&#39;re using the correct PID (the child&#39;s PID, not the parent&#39;s)</li>\n</ul>\n<h4 id=\"g-debugging-tips-table\">G. Debugging Tips Table</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container not subject to memory limit</td>\n<td>Process not in cgroup</td>\n<td>Check <code>cat /sys/fs/cgroup/container_runtime/{id}/cgroup.procs</code></td>\n<td>Call <code>AddProcess</code> before <code>exec</code></td>\n</tr>\n<tr>\n<td>Memory limit enforced but container uses more</td>\n<td>Kernel memory not limited (v1)</td>\n<td>Check <code>cat /sys/fs/cgroup/memory/container_runtime/{id}/memory.kmem.usage_in_bytes</code></td>\n<td>Set <code>memory.kmem.limit_in_bytes</code></td>\n</tr>\n<tr>\n<td>CPU limit has no effect</td>\n<td>CPU not saturated on host</td>\n<td>Check <code>top</code> to see if system CPU usage is low</td>\n<td>Shares only matter during contention; use quota/period for hard limits</td>\n</tr>\n<tr>\n<td>cgroup cleanup fails</td>\n<td>Processes still running in cgroup</td>\n<td><code>ls -la /proc/{pid}/cgroup</code> for PIDs in cgroup</td>\n<td>Kill processes before removing cgroup</td>\n</tr>\n<tr>\n<td>&quot;no such file&quot; errors</td>\n<td>cgroup v2 not mounted</td>\n<td>Check `mount</td>\n<td>grep cgroup`</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3: Filesystem Isolation (chroot/pivot_root)</p>\n</blockquote>\n<h2 id=\"component-design-filesystem-isolation-milestone-3\">Component Design: Filesystem Isolation (Milestone 3)</h2>\n<p>This component is responsible for giving each container its own private view of the filesystem, completely isolated from the host&#39;s filesystem hierarchy. While namespaces provide process isolation, filesystem isolation ensures the container can only see and modify files within its designated root filesystem (<code>rootfs</code>). This creates the illusion for the containerized process that it&#39;s running on a complete, independent operating system with its own <code>/bin</code>, <code>/lib</code>, <code>/etc</code>, and other directories, even though these are just directories on the host.</p>\n<h3 id=\"mental-model-giving-each-apartment-its-own-furniture\">Mental Model: Giving Each Apartment Its Own Furniture</h3>\n<p>Think of the host filesystem as a massive, fully-furnished mansion. When we create containers, we&#39;re setting up individual apartments within this mansion. Without filesystem isolation, each apartment resident would have access to the entire mansion&#39;s furniture, appliances, and personal belongings—a clear security and privacy problem.</p>\n<p>Filesystem isolation is like giving each apartment its own complete set of furniture and appliances that only that tenant can see and use:</p>\n<ol>\n<li><p><strong>Private Furniture (Root Filesystem)</strong>: Each container gets its own <code>/</code> (root directory) containing all the files it needs to operate. This <code>rootfs</code> is typically extracted from a container image (like Alpine or Ubuntu). The container can install packages, create files, and modify configuration within this space without affecting other containers or the host.</p>\n</li>\n<li><p><strong>Mirrored Utilities (Essential Filesystems)</strong>: While the container has its own furniture, it still needs access to certain &quot;utilities&quot; provided by the building. We mount special filesystems like <code>/proc</code> and <code>/sys</code> inside the container so it can see its own processes and system information, not the host&#39;s. This is like providing each apartment with electricity and water connections that are metered separately.</p>\n</li>\n<li><p><strong>Locked Doors (Unmounting Host Access)</strong>: After moving the container into its private apartment, we lock the door to the rest of the mansion. This is achieved by unmounting the host&#39;s root filesystem from within the container&#39;s mount namespace, ensuring the container cannot access any host files even if it knows their paths.</p>\n</li>\n<li><p><strong>Shared Storage Areas (Bind Mounts)</strong>: Sometimes tenants need access to shared storage areas, like a communal laundry room. We can provide this through bind mounts—taking specific directories from the host and making them available at specific locations within the container. This is controlled and explicit, unlike the unrestricted access of <code>chroot</code> without mount namespaces.</p>\n</li>\n</ol>\n<p>The key insight is that filesystem isolation isn&#39;t about creating physical copies of files (that would be wasteful), but about creating a <strong>virtual view</strong> where the container sees only its assigned directory tree as the entire filesystem universe.</p>\n<h3 id=\"architecture-decision-records-pivot_root-vs-chroot\">Architecture Decision Records: pivot_root vs chroot</h3>\n<blockquote>\n<p><strong>Decision: Use pivot_root with Mount Namespaces Instead of chroot</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to give containers an isolated view of the filesystem. The traditional approach is <code>chroot</code>, which changes the root directory for a process and its children. However, <code>chroot</code> has security limitations and doesn&#39;t play well with modern container requirements like proper <code>/proc</code> mounting and clean separation from the host.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>chroot only</strong>: Simple system call that changes the root directory</li>\n<li><strong>chroot with mount namespace</strong>: chroot inside a mount namespace</li>\n<li><strong>pivot_root with mount namespace</strong>: Modern approach that completely swaps root filesystems</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use <code>pivot_root</code> combined with a mount namespace (<code>CLONE_NEWNS</code>).</li>\n<li><strong>Rationale</strong>: <ul>\n<li><code>pivot_root</code> is designed for containerization and allows us to completely replace the root filesystem while keeping the old root accessible for cleanup</li>\n<li>It works atomically and avoids race conditions that <code>chroot</code> can have</li>\n<li>Combined with a mount namespace, it allows us to unmount the old root entirely, preventing any access to host files</li>\n<li>The OCI runtime specification recommends <code>pivot_root</code> for proper isolation</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Slightly more complex implementation than <code>chroot</code></li>\n<li>Requires creating a mount namespace first</li>\n<li>Provides stronger security guarantees and cleaner isolation</li>\n<li>Compatible with overlayfs and other union filesystems</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Comparison Table: Filesystem Isolation Approaches</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>chroot only</strong></td>\n<td>Simple single system call, widely understood</td>\n<td>Process can escape via file descriptors or procfs, doesn&#39;t isolate mounts, old root remains accessible</td>\n<td>Security vulnerabilities, insufficient isolation for containers</td>\n</tr>\n<tr>\n<td><strong>chroot + mount namespace</strong></td>\n<td>Better isolation than chroot alone, allows private mount points</td>\n<td>Still uses chroot which has escape vectors, old root remains mounted somewhere</td>\n<td><code>pivot_root</code> is more secure and designed for this purpose</td>\n</tr>\n<tr>\n<td><strong>pivot_root + mount namespace</strong> (CHOSEN)</td>\n<td>Complete root replacement, old root can be unmounted, atomic operation, OCI-recommended</td>\n<td>More complex, requires temporary directories</td>\n<td>Best practice for container runtimes, provides proper isolation</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-filesystem-isolation\">Common Pitfalls in Filesystem Isolation</h3>\n<p>⚠️ <strong>Pitfall 1: Using chroot Without Mount Namespace</strong></p>\n<ul>\n<li><strong>Description</strong>: Using only <code>chroot()</code> to change the root directory without first creating a mount namespace.</li>\n<li><strong>Why it&#39;s wrong</strong>: The process can escape the chroot jail using various techniques: keeping file descriptors to host directories, using <code>..</code> paths with <code>/proc/self/fd</code>, or mounting new filesystems. The host&#39;s <code>/proc</code> is still visible unless remounted.</li>\n<li><strong>How to fix</strong>: Always create a mount namespace (<code>CLONE_NEWNS</code>) before calling <code>chroot</code>, or better yet, use <code>pivot_root</code> which requires a mount namespace.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 2: Forgetting to Mount /proc Inside Container</strong></p>\n<ul>\n<li><strong>Description</strong>: After isolating the filesystem, not mounting a new <code>/proc</code> filesystem inside the container.</li>\n<li><strong>Why it&#39;s wrong</strong>: Many utilities (<code>ps</code>, <code>top</code>, <code>ls /proc</code>) will fail or show host processes. The container&#39;s PID namespace needs its own <code>/proc</code> to reflect container PIDs, not host PIDs.</li>\n<li><strong>How to fix</strong>: After <code>pivot_root</code>, mount a new proc filesystem at <code>/proc</code> inside the container with appropriate options (<code>nosuid,nodev,noexec</code>).</li>\n</ul>\n<p>⚠️ <strong>Pitfall 3: Not Unmounting the Old Root</strong></p>\n<ul>\n<li><strong>Description</strong>: After <code>pivot_root</code>, leaving the old root filesystem accessible at the pivot directory.</li>\n<li><strong>Why it&#39;s wrong</strong>: The container could access host files through the old root mount point, breaking isolation.</li>\n<li><strong>How to fix</strong>: Always unmount the old root directory (with <code>MNT_DETACH</code> flag) after successful <code>pivot_root</code> and changing directory to the new root.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 4: Using Relative Paths for pivot_root</strong></p>\n<ul>\n<li><strong>Description</strong>: Passing relative paths to <code>pivot_root</code> instead of absolute paths.</li>\n<li><strong>Why it&#39;s wrong</strong>: <code>pivot_root</code> system call requires both arguments to be absolute paths. Relative paths cause the call to fail with <code>EINVAL</code>.</li>\n<li><strong>How to fix</strong>: Always convert paths to absolute using <code>filepath.Abs()</code> or similar before calling <code>pivot_root</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 5: Incomplete Root Filesystem</strong></p>\n<ul>\n<li><strong>Description</strong>: The extracted <code>rootfs</code> doesn&#39;t contain essential binaries or libraries needed by the container&#39;s entrypoint.</li>\n<li><strong>Why it&#39;s wrong</strong>: Container process fails to start with &quot;executable not found&quot; or shared library errors, even though the binary exists in the path.</li>\n<li><strong>How to fix</strong>: Ensure the container image is properly extracted with all dependencies. Use minimal but complete base images like Alpine, and verify that required dynamic libraries are present with <code>ldd</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance-for-root-filesystem-setup\">Implementation Guidance for Root Filesystem Setup</h3>\n<p>The filesystem isolation component orchestrates multiple steps to prepare and switch to the container&#39;s root filesystem. Here&#39;s the complete procedure:</p>\n<h4 id=\"step-by-step-filesystem-isolation-procedure\">Step-by-Step Filesystem Isolation Procedure</h4>\n<ol>\n<li><p><strong>Prepare Container Directories</strong>:</p>\n<ul>\n<li>Create a unique directory for the container under the runtime&#39;s storage path (e.g., <code>/var/lib/container-runtime/containers/&lt;id&gt;/</code>)</li>\n<li>Create subdirectories: <code>rootfs</code> (for the final merged view), <code>workdir</code> (for OverlayFS), <code>oldroot</code> (for pivot temporary)</li>\n</ul>\n</li>\n<li><p><strong>Extract or Prepare Root Filesystem</strong>:</p>\n<ul>\n<li>If using a container image, extract all layers to create the <code>rootfs</code> (using OverlayFS for Milestone 4)</li>\n<li>If using a direct rootfs directory, copy or bind mount it to the container&#39;s <code>rootfs</code> directory</li>\n<li>Ensure the rootfs contains essential directories (<code>/dev</code>, <code>/proc</code>, <code>/sys</code>, <code>/tmp</code> will be created or mounted later)</li>\n</ul>\n</li>\n<li><p><strong>Create Mount Namespace</strong>:</p>\n<ul>\n<li>Use <code>CLONE_NEWNS</code> flag when creating the container process to give it a private mount namespace</li>\n<li>This ensures all subsequent mount operations only affect the container, not the host</li>\n</ul>\n</li>\n<li><p><strong>Mount Essential Virtual Filesystems</strong>:\nBefore <code>pivot_root</code>, mount essential filesystems that should be available in the new root:</p>\n<ul>\n<li>Mount <code>tmpfs</code> at <code>/dev</code> for device nodes (or bind mount <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/random</code>, etc.)</li>\n<li>Create basic device nodes if needed (<code>mknod</code> for console, null, etc.)</li>\n<li>Mount <code>proc</code> at <code>rootfs/proc</code> with <code>nosuid,nodev,noexec</code> flags</li>\n<li>Mount <code>sysfs</code> at <code>rootfs/sys</code> with <code>nosuid,nodev,noexec,ro</code> flags (read-only for security)</li>\n<li>Mount <code>tmpfs</code> at <code>rootfs/tmp</code> with appropriate size limits</li>\n</ul>\n</li>\n<li><p><strong>Perform pivot_root</strong>:</p>\n<ul>\n<li>Change to the container&#39;s <code>rootfs</code> directory</li>\n<li>Create a temporary directory (e.g., <code>.pivot_root</code>) inside <code>rootfs</code> to hold the old root</li>\n<li>Call <code>pivot_root</code> with arguments: new root = <code>rootfs</code>, put old = <code>.pivot_root</code></li>\n<li>Change directory to the new root (<code>/</code>)</li>\n<li>Unmount the old root directory (now at <code>/.pivot_root</code>) with <code>MNT_DETACH</code></li>\n<li>Remove the temporary <code>.pivot_root</code> directory</li>\n</ul>\n</li>\n<li><p><strong>Final Mount Adjustments</strong>:</p>\n<ul>\n<li>Remount <code>/</code> as private if needed (to prevent mount propagation to host)</li>\n<li>Ensure <code>/proc</code> is mounted correctly (remount if needed)</li>\n<li>Set up any bind mounts specified in container configuration (for volumes)</li>\n</ul>\n</li>\n<li><p><strong>Change Working Directory</strong>:</p>\n<ul>\n<li>Change to the working directory specified in the container configuration (or default to <code>/</code>)</li>\n<li>This ensures the process starts in the correct location within the container</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"component-responsibilities\">Component Responsibilities</h4>\n<p>The <code>FilesystemManager</code> component handles these responsibilities:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SetupRootfs(image Image, containerID string)</code></td>\n<td><code>image</code>: Image metadata, <code>containerID</code>: Unique container identifier</td>\n<td><code>string</code> (path to rootfs), <code>error</code></td>\n<td>Extracts image layers and prepares root filesystem for container</td>\n</tr>\n<tr>\n<td><code>IsolateFilesystem(rootfsPath string)</code></td>\n<td><code>rootfsPath</code>: Path to prepared root filesystem</td>\n<td><code>error</code></td>\n<td>Performs pivot_root and mounts essential filesystems inside container</td>\n</tr>\n<tr>\n<td><code>CleanupFilesystem(containerID string)</code></td>\n<td><code>containerID</code>: Container to clean up</td>\n<td><code>error</code></td>\n<td>Unmounts and removes container filesystem resources</td>\n</tr>\n<tr>\n<td><code>MountProc(rootfsPath string)</code></td>\n<td><code>rootfsPath</code>: Path to root filesystem</td>\n<td><code>error</code></td>\n<td>Mounts proc filesystem at rootfsPath/proc with proper options</td>\n</tr>\n<tr>\n<td><code>MountSys(rootfsPath string)</code></td>\n<td><code>rootfsPath</code>: Path to root filesystem</td>\n<td><code>error</code></td>\n<td>Mounts sysfs at rootfsPath/sys with read-only options</td>\n</tr>\n</tbody></table>\n<h4 id=\"data-structures-for-filesystem-management\">Data Structures for Filesystem Management</h4>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FilesystemManager</code></td>\n<td>struct</td>\n<td>Manages container filesystem lifecycle</td>\n</tr>\n<tr>\n<td><code>MountInfo</code></td>\n<td>struct</td>\n<td>Information about a mount operation</td>\n</tr>\n<tr>\n<td><code>MountConfig</code></td>\n<td>struct</td>\n<td>Configuration for mounting virtual filesystems</td>\n</tr>\n</tbody></table>\n<p>The <code>FilesystemManager</code> struct will contain:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>basePath</code></td>\n<td><code>string</code></td>\n<td>Base directory for container storage</td>\n</tr>\n<tr>\n<td><code>imageStore</code></td>\n<td><code>ImageStore</code></td>\n<td>Reference to image storage component</td>\n</tr>\n<tr>\n<td><code>useOverlay</code></td>\n<td><code>bool</code></td>\n<td>Whether to use OverlayFS (Milestone 4)</td>\n</tr>\n</tbody></table>\n<h4 id=\"sequence-of-operations\">Sequence of Operations</h4>\n<p>Referencing the container creation sequence diagram <img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fcontainer-creation-sequence.svg\" alt=\"Container Creation Sequence\">, the filesystem isolation occurs at this point in the flow:</p>\n<ol>\n<li><strong>User</strong> runs <code>container run</code> command with an image name</li>\n<li><strong>CLI</strong> parses command and calls <code>Runtime.CreateContainer()</code></li>\n<li><strong>Container Manager</strong> creates <code>Container</code> record in <code>StateCreated</code></li>\n<li><strong>Container Manager</strong> calls <code>FilesystemManager.SetupRootfs()</code> to extract image</li>\n<li><strong>Container Manager</strong> creates namespaces including <code>CLONE_NEWNS</code></li>\n<li><strong>Inside container process</strong>, <code>FilesystemManager.IsolateFilesystem()</code> is called</li>\n<li><strong>Container process</strong> performs <code>pivot_root</code> and mounts <code>/proc</code>, <code>/sys</code></li>\n<li><strong>Container process</strong> executes the entrypoint command inside isolated rootfs</li>\n</ol>\n<h4 id=\"security-considerations\">Security Considerations</h4>\n<ol>\n<li><strong>Mount Flags</strong>: Always use <code>nosuid,nodev,noexec</code> on non-essential mounts to prevent privilege escalation</li>\n<li><strong>Read-Only Mounts</strong>: Mount <code>/sys</code> and potentially other directories as read-only when possible</li>\n<li><strong>Private Propagation</strong>: Set mount propagation to <code>MS_PRIVATE</code> to prevent mount leaks between containers</li>\n<li><strong>Capabilities</strong>: The container process needs <code>CAP_SYS_ADMIN</code> for mount operations, which should be dropped after setup</li>\n</ol>\n<h4 id=\"example-walkthrough-alpine-container-startup\">Example Walkthrough: Alpine Container Startup</h4>\n<p>Let&#39;s trace through a concrete example: starting an Alpine Linux container with <code>/bin/sh</code> as the entrypoint:</p>\n<ol>\n<li><strong>Image Extraction</strong>: Alpine image layers are extracted to <code>/var/lib/container-runtime/containers/abc123/rootfs</code></li>\n<li><strong>Namespace Creation</strong>: Container process created with <code>CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUTS</code></li>\n<li><strong>Mount Setup Inside Container</strong>:<ul>\n<li>Mount new <code>proc</code> at <code>/var/lib/.../abc123/rootfs/proc</code></li>\n<li>Mount new <code>sysfs</code> at <code>/var/lib/.../abc123/rootfs/sys</code> (read-only)</li>\n<li>Mount <code>tmpfs</code> at <code>/var/lib/.../abc123/rootfs/tmp</code></li>\n</ul>\n</li>\n<li><strong>pivot_root</strong>:<ul>\n<li><code>pivot_root(&quot;/var/lib/.../abc123/rootfs&quot;, &quot;/var/lib/.../abc123/rootfs/.pivot_root&quot;)</code></li>\n<li><code>chdir(&quot;/&quot;)</code></li>\n<li><code>umount2(&quot;/.pivot_root&quot;, MNT_DETACH)</code></li>\n<li><code>rmdir(&quot;/.pivot_root&quot;)</code></li>\n</ul>\n</li>\n<li><strong>Process Execution</strong>: <code>execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], container_env)</code></li>\n</ol>\n<p>The container now sees <code>/</code> as its Alpine root filesystem, <code>/proc</code> shows only container processes, and it cannot access any host files outside its rootfs.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RootFS Preparation</td>\n<td>Direct directory copy</td>\n<td>OverlayFS union mount (Milestone 4)</td>\n</tr>\n<tr>\n<td>pivot_root Wrapper</td>\n<td>Direct syscall.Syscall</td>\n<td>Use <code>github.com/moby/sys/mount</code> package</td>\n</tr>\n<tr>\n<td>Mount Management</td>\n<td>Manual mount/unmount calls</td>\n<td>Use <code>golang.org/x/sys/unix</code> for mount constants</td>\n</tr>\n<tr>\n<td>ProcFS Setup</td>\n<td>Simple mount with default options</td>\n<td>Fine-tuned options (hidepid, gid, etc.)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    byod/                      # CLI entry point\n      main.go\n  internal/\n    container/\n      container.go             # Container struct and methods\n      store.go                 # ContainerStore implementation\n    runtime/\n      runtime.go              # ContainerRuntime main logic\n    filesystem/\n      manager.go              # FilesystemManager implementation\n      pivot.go                # pivot_root logic\n      mounts.go               # Mount/unmount helpers\n      overlay.go              # OverlayFS (for Milestone 4)\n    namespace/\n      manager.go              # NamespaceManager\n    cgroup/\n      manager.go              # CgroupManager\n    network/\n      manager.go              # NetworkManager\n    image/\n      manager.go              # Image handling\n  pkg/\n    syscall/                  # System call wrappers\n      pivot_root.go\n      mount.go</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Here&#39;s a complete, working <code>FilesystemManager</code> skeleton with helper functions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> filesystem</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">golang.org/x/sys/unix</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FilesystemManager handles container filesystem operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FilesystemManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbasePath   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">      // Base directory for container storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\timageStore </span><span style=\"color:#B392F0\">ImageStore</span><span style=\"color:#6A737D\">  // Reference to image storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewFilesystemManager creates a new filesystem manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewFilesystemManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">basePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">imageStore</span><span style=\"color:#B392F0\"> ImageStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tbasePath:   basePath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\timageStore: imageStore,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerPath returns the path to a container's directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ContainerPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(fm.basePath, </span><span style=\"color:#9ECBFF\">\"containers\"</span><span style=\"color:#E1E4E8\">, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RootfsPath returns the path to a container's root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RootfsPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(fm.</span><span style=\"color:#B392F0\">ContainerPath</span><span style=\"color:#E1E4E8\">(containerID), </span><span style=\"color:#9ECBFF\">\"rootfs\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupRootfs extracts image layers and prepares root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupRootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">image</span><span style=\"color:#B392F0\"> Image</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainerPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fm.</span><span style=\"color:#B392F0\">ContainerPath</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\trootfsPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fm.</span><span style=\"color:#B392F0\">RootfsPath</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Create container directory structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(rootfsPath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating container directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Extract image layers to rootfsPath</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// For Milestone 3, you can start with a simple rootfs directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// For Milestone 4, implement OverlayFS mounting here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> rootfsPath, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsolateFilesystem performs pivot_root and mounts essential filesystems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This function is called from inside the container process after clone()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsolateFilesystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rootfsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Mount proc filesystem at rootfsPath/proc</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> MountProc</span><span style=\"color:#E1E4E8\">(rootfsPath); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mounting proc: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Mount sysfs at rootfsPath/sys (read-only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> MountSys</span><span style=\"color:#E1E4E8\">(rootfsPath); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mounting sys: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Create /dev directory and basic device nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SetupDev</span><span style=\"color:#E1E4E8\">(rootfsPath); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"setting up /dev: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Perform pivot_root to switch to the new root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> PivotRoot</span><span style=\"color:#E1E4E8\">(rootfsPath); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pivot_root: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MountProc mounts proc filesystem at the given path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> MountProc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rootfsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tprocPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rootfsPath, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(procPath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Mount proc with safe options: nosuid, nodev, noexec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tflags </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uintptr</span><span style=\"color:#E1E4E8\">(syscall.MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> syscall.MS_NODEV </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> syscall.MS_NOEXEC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, procPath, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, flags, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MountSys mounts sysfs at the given path (read-only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> MountSys</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rootfsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsysPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rootfsPath, </span><span style=\"color:#9ECBFF\">\"sys\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(sysPath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Mount sysfs read-only with safe options</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tflags </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uintptr</span><span style=\"color:#E1E4E8\">(syscall.MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> syscall.MS_NODEV </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> syscall.MS_NOEXEC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> syscall.MS_RDONLY)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">, sysPath, </span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">, flags, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupDev creates /dev directory and essential device nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SetupDev</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rootfsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdevPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rootfsPath, </span><span style=\"color:#9ECBFF\">\"dev\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(devPath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Create basic device nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdevices </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tpath  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tmajor </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tminor </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tmode  </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t{</span><span style=\"color:#9ECBFF\">\"/dev/null\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, syscall.S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> 0666</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t{</span><span style=\"color:#9ECBFF\">\"/dev/zero\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, syscall.S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> 0666</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t{</span><span style=\"color:#9ECBFF\">\"/dev/random\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">, syscall.S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> 0666</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t{</span><span style=\"color:#9ECBFF\">\"/dev/urandom\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">, syscall.S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> 0666</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> _, dev </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> devices {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tfullPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rootfsPath, dev.path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Mknod</span><span style=\"color:#E1E4E8\">(fullPath, dev.mode, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(unix.</span><span style=\"color:#B392F0\">Mkdev</span><span style=\"color:#E1E4E8\">(dev.major, dev.minor))); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">os.</span><span style=\"color:#B392F0\">IsExist</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating device node </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, dev.path, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PivotRoot switches to a new root filesystem using pivot_root syscall</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> PivotRoot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// pivot_root requires both paths to be absolute</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\trootfs, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Abs</span><span style=\"color:#E1E4E8\">(rootfs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"getting absolute path: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Create temporary directory for old root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tpivotDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rootfs, </span><span style=\"color:#9ECBFF\">\".pivot_root\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Mkdir</span><span style=\"color:#E1E4E8\">(pivotDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating pivot directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Change to rootfs directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Chdir</span><span style=\"color:#E1E4E8\">(rootfs); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"chdir to rootfs: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Call pivot_root system call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// new_root = rootfs, put_old = pivotDir</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">PivotRoot</span><span style=\"color:#E1E4E8\">(rootfs, pivotDir); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pivot_root system call: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Change directory to new root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Chdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"chdir to new root: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Unmount old root (now at /.pivot_root)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\toldRoot </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"/.pivot_root\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Unmount</span><span style=\"color:#E1E4E8\">(oldRoot, syscall.MNT_DETACH); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unmounting old root: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Remove temporary directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(oldRoot); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"removing old root directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupFilesystem unmounts and removes container filesystem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupFilesystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\trootfsPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fm.</span><span style=\"color:#B392F0\">RootfsPath</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Try to unmount any mounted filesystems</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmounts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tfilepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rootfsPath, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tfilepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rootfsPath, </span><span style=\"color:#9ECBFF\">\"sys\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tfilepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rootfsPath, </span><span style=\"color:#9ECBFF\">\"dev\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> _, mountPoint </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> mounts {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(mountPoint); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t\t// Best-effort unmount, ignore errors if not mounted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tsyscall.</span><span style=\"color:#B392F0\">Unmount</span><span style=\"color:#E1E4E8\">(mountPoint, syscall.MNT_DETACH)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Remove container directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainerPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fm.</span><span style=\"color:#B392F0\">ContainerPath</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">RemoveAll</span><span style=\"color:#E1E4E8\">(containerPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>Here&#39;s the skeleton for the main container entry point that orchestrates filesystem isolation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ChildEntryPoint is the function executed inside the container namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is called after clone() from the parent process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ChildEntryPoint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">childFunc</span><span style=\"color:#B392F0\"> ChildFunc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Parse container configuration from command-line arguments or pipe</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Setup root filesystem isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// fsManager.IsolateFilesystem(rootfsPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Set hostname if UTS namespace is isolated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// syscall.Sethostname([]byte(config.Hostname))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Setup container networking if network namespace is isolated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// networkManager.SetupContainerNetwork()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Drop capabilities if running as root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Apply security restrictions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Execute the container command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// syscall.Exec(command, args, env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: If exec fails, exit with error code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// setupContainerFilesystem orchestrates all filesystem isolation steps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> setupContainerFilesystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Get FilesystemManager instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Extract image and prepare rootfs if not already done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// rootfsPath, err := fsManager.SetupRootfs(image, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Mount /proc inside container rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// fsManager.MountProc(rootfsPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Mount /sys inside container rootfs (read-only)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// fsManager.MountSys(rootfsPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Setup /dev directory with essential device nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// fsManager.SetupDev(rootfsPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Apply any bind mounts specified in config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Change working directory to container's WorkingDir</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Syscall Package</strong>: Use <code>golang.org/x/sys/unix</code> for system call constants and <code>syscall</code> package for actual calls. Note that Go&#39;s <code>syscall</code> package is frozen but still works for basic operations.</p>\n</li>\n<li><p><strong>Mount Flags</strong>: Pay attention to mount flag differences between systems. Use <code>unix.MS_NOSUID | unix.MS_NODEV | unix.MS_NOEXEC</code> for safety.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Many filesystem operations can fail with <code>EBUSY</code> if something is still using the filesystem. Use <code>MNT_DETACH</code> flag when unmounting to force detachment.</p>\n</li>\n<li><p><strong>Path Handling</strong>: Always use <code>filepath.Abs()</code> to convert to absolute paths before system calls, as many syscalls (including <code>pivot_root</code>) require absolute paths.</p>\n</li>\n<li><p><strong>Cleanup on Failure</strong>: Implement proper cleanup in case of partial failure. Use <code>defer</code> statements strategically to clean up temporary directories and mounts.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing filesystem isolation, you should be able to:</p>\n<ol>\n<li><strong>Test Basic Container</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   $ sudo ./byod run --rootfs /path/to/alpine-rootfs /bin/sh</code></pre></div>\n<p>   Should start a shell inside an isolated filesystem.</p>\n<ol start=\"2\">\n<li><strong>Verify Isolation</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Inside container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#9ECBFF\"> /</span><span style=\"color:#6A737D\">           # Should show container rootfs, not host root</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#6A737D\">         # Should only show container processes (initially just sh)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> hostname</span><span style=\"color:#6A737D\">       # Should be container hostname, not host</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Test pivot_root Success</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # From host, check mounts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> mount</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> container-id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should show container's proc mount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Try to access host files from container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --rootfs</span><span style=\"color:#9ECBFF\"> /path/to/alpine-rootfs</span><span style=\"color:#9ECBFF\"> /bin/sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"ls /host\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should fail: /host doesn't exist in container</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Common Failure Signs</strong>:<ul>\n<li><strong>&quot;Invalid argument&quot; error</strong>: Likely wrong paths to <code>pivot_root</code> (not absolute)</li>\n<li><strong>&quot;Permission denied&quot;</strong>: Need root privileges for mount operations</li>\n<li><strong>&quot;No such file or directory&quot;</strong>: Missing essential directories in rootfs</li>\n<li><strong>/proc shows host processes</strong>: Forgot to mount new proc after pivot_root</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container can&#39;t find <code>/bin/sh</code></td>\n<td>Incomplete rootfs or wrong path</td>\n<td>Check <code>ls -la /path/to/rootfs/bin/</code> from host</td>\n<td>Ensure rootfs contains all needed binaries</td>\n</tr>\n<tr>\n<td><code>pivot_root</code> returns EINVAL</td>\n<td>Paths not absolute or rootfs not a mount point</td>\n<td>Print paths before calling pivot_root</td>\n<td>Use <code>filepath.Abs()</code> and ensure rootfs is a mount</td>\n</tr>\n<tr>\n<td>Can still see host files in container</td>\n<td>Old root not unmounted or mount propagation issues</td>\n<td>Check <code>mount</code> output inside container</td>\n<td>Ensure unmount old root with <code>MNT_DETACH</code></td>\n</tr>\n<tr>\n<td><code>/proc</code> shows host PIDs</td>\n<td>Proc not mounted or mounted incorrectly</td>\n<td>Check <code>ls /proc</code> inside container</td>\n<td>Mount proc after pivot_root with correct options</td>\n</tr>\n<tr>\n<td>Container exits immediately</td>\n<td>Entrypoint binary missing libraries</td>\n<td>Run <code>ldd /path/to/rootfs/bin/sh</code> from host</td>\n<td>Include all shared libraries in rootfs</td>\n</tr>\n<tr>\n<td>&quot;Operation not permitted&quot;</td>\n<td>Missing <code>CAP_SYS_ADMIN</code> capability</td>\n<td>Check effective capabilities</td>\n<td>Run as root or grant appropriate capabilities</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4: Layered Filesystem (OverlayFS)</p>\n</blockquote>\n<h2 id=\"component-design-layered-filesystem-milestone-4\">Component Design: Layered Filesystem (Milestone 4)</h2>\n<p>This component is responsible for implementing copy-on-write layered filesystems, a cornerstone technology that enables efficient container image storage and sharing. While the previous filesystem isolation component (<code>FilesystemManager</code>) provides each container with its own private root filesystem, this component revolutionizes how those root filesystems are constructed by stacking multiple read-only layers and a single writable layer into a unified view, enabling the container to see a complete filesystem while writes are captured separately.</p>\n<h3 id=\"mental-model-transparent-overlays-on-a-projector\">Mental Model: Transparent Overlays on a Projector</h3>\n<p>Think of layered filesystems as a <strong>stack of transparent acetate sheets on an overhead projector</strong>. Each sheet (layer) contains drawings (files and directories) that can overlap. When projected together, you see a unified image where upper sheets obscure portions of lower sheets. The crucial property is that you can only draw on the top sheet—any modifications go there while preserving the original drawings on lower sheets for everyone else.</p>\n<p>In technical terms:</p>\n<ul>\n<li><strong>Lower layers</strong> are read-only acetate sheets containing base operating system files, installed packages, and application code.</li>\n<li><strong>Upper layer</strong> is the writable top sheet where all container modifications (created files, deleted files, modified files) are recorded.</li>\n<li><strong>Work directory</strong> acts as a temporary scratch pad that the filesystem uses internally to manage atomic operations.</li>\n<li><strong>Merged view</strong> is the projected image—what the container process actually sees when it looks at its root filesystem.</li>\n</ul>\n<p>The critical insight is that <strong>identical lower layers can be shared across hundreds of containers</strong>, just as multiple classrooms can use the same set of base acetate sheets. Each container gets its own writable top sheet for modifications, but the vast majority of data (OS files, libraries) is stored once and referenced many times, achieving tremendous storage efficiency.</p>\n<h3 id=\"architecture-decision-records-overlayfs-vs-alternatives\">Architecture Decision Records: OverlayFS vs Alternatives</h3>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Foverlayfs-layout.svg\" alt=\"Overlayfs Layout\"></p>\n<h4 id=\"decision-overlayfs-for-layered-filesystem-implementation\">Decision: OverlayFS for Layered Filesystem Implementation</h4>\n<p><strong>Context</strong>: We need a union filesystem that supports multiple read-only lower layers and a single writable upper layer with copy-on-write semantics. The solution must be kernel-based (for performance), widely available in modern Linux distributions, and support the OCI image standard&#39;s layer model. We must choose between kernel union filesystem implementations and userspace alternatives.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>OverlayFS</strong>: Kernel-based union filesystem merged into Linux mainline since kernel 3.18.</li>\n<li><strong>AUFS (Another Union File System)</strong>: Older kernel patchset popular in early Docker versions.</li>\n<li><strong>Device Mapper + thin-provisioning</strong>: Block-level snapshot mechanism used by Docker&#39;s devicemapper storage driver.</li>\n<li><strong>FUSE-based union filesystems (mergerfs, unionfs-fuse)</strong>: Userspace implementations that don&#39;t require kernel support.</li>\n</ol>\n<p><strong>Decision</strong>: We will implement OverlayFS as our layered filesystem technology.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Mainstream adoption</strong>: OverlayFS is the default storage driver in Docker and recommended by the OCI community.</li>\n<li><strong>Kernel integration</strong>: As a kernel filesystem, it offers superior performance over FUSE-based solutions with lower CPU overhead.</li>\n<li><strong>Minimal dependencies</strong>: Available in stock Linux kernels since 3.18 (2015), requiring no additional kernel modules or patches.</li>\n<li><strong>Simplicity</strong>: The mount options and directory structure are straightforward, with clear documentation.</li>\n<li><strong>Copy-on-write efficiency</strong>: Provides true copy-on-write at the file level without block-level complexity.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: Excellent performance, widespread compatibility, and alignment with industry standards.</li>\n<li><strong>Negative</strong>: Requires Linux kernel ≥3.18 with OverlayFS enabled (CONFIG_OVERLAY_FS). Some advanced features (like recursive directory operations) have edge cases.</li>\n<li><strong>Maintenance</strong>: OverlayFS behavior is consistent across distributions, reducing platform-specific bugs.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OverlayFS</td>\n<td>Kernel-native, excellent performance, default in Docker</td>\n<td>Requires kernel ≥3.18, some edge cases with rename/delete</td>\n<td><strong>CHOSEN</strong> - Best balance of performance and availability</td>\n</tr>\n<tr>\n<td>AUFS</td>\n<td>Mature, feature-rich</td>\n<td>Not in mainline kernel, requires patching, less maintained</td>\n<td>Not in mainline kernel, distribution support inconsistent</td>\n</tr>\n<tr>\n<td>Device Mapper</td>\n<td>Block-level efficiency, snapshot support</td>\n<td>Complex setup, requires LVM/thin-provisioning tools</td>\n<td>Overkill for our educational container runtime, complex</td>\n</tr>\n<tr>\n<td>FUSE unionfs</td>\n<td>Works on any kernel, no special privileges</td>\n<td>High CPU overhead, slower performance, userspace complexity</td>\n<td>Performance penalty too high for container workloads</td>\n</tr>\n</tbody></table>\n<h4 id=\"decision-multiple-lower-layer-support\">Decision: Multiple Lower Layer Support</h4>\n<p><strong>Context</strong>: OCI images consist of multiple layers (often 10-20 for a typical application image). We need to decide how to represent these layers in our OverlayFS mount—either flattening them into a single directory or supporting true multi-layer stacking.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>True multi-layer OverlayFS</strong>: Pass all lower directories as a colon-separated list to the <code>lowerdir</code> mount option.</li>\n<li><strong>Two-layer flattening</strong>: Extract and merge all read-only layers into a single directory, then use it as the only lower layer.</li>\n<li><strong>Incremental mounting</strong>: Mount layers sequentially, with each layer becoming the lowerdir for the next.</li>\n</ol>\n<p><strong>Decision</strong>: We will implement true multi-layer OverlayFS with colon-separated <code>lowerdir</code>.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Preserves layer identity</strong>: Each layer remains distinct, enabling efficient layer sharing across containers.</li>\n<li><strong>Optimized storage</strong>: Identical layers aren&#39;t duplicated on disk when multiple images share them.</li>\n<li><strong>OCI compliance</strong>: Matches the standard image format where layers are applied sequentially.</li>\n<li><strong>Efficient pull/update</strong>: When pulling updated images, only changed layers need downloading; unchanged layers remain shared.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Implementation complexity</strong>: Must manage layer ordering (lowest layer first in list) and handle potentially long <code>lowerdir</code> strings.</li>\n<li><strong>Path length limitations</strong>: Linux has PATH_MAX (4096) limitations for mount options; many layers could exceed this.</li>\n<li><strong>Performance</strong>: Kernel handles layer traversal efficiently without userspace merging overhead.</li>\n</ul>\n<h3 id=\"common-pitfalls-in-overlayfs-implementation\">Common Pitfalls in OverlayFS Implementation</h3>\n<p>⚠️ <strong>Pitfall 1: Incorrect layer ordering in lowerdir</strong></p>\n<p><strong>Description</strong>: Placing layers in the wrong order (newest first instead of oldest first) causes files from upper layers to be hidden by lower ones, breaking the image.</p>\n<p><strong>Why it&#39;s wrong</strong>: OverlayFS renders files from the <strong>last</strong> lowerdir entry as the &quot;lowest&quot; layer. The base OS layer must be first in the list, with application layers appended in the order they were added during image build.</p>\n<p><strong>How to fix</strong>: Always order layers chronologically from base to top. When parsing an OCI image manifest, layers are listed in application order—the first in the list is applied to the base, so it should be nearest to the upper layer in <code>lowerdir</code>.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># CORRECT: base layer first, then intermediate layers, then top read-only layer last\nlowerdir=/layers/layer4:/layers/layer3:/layers/layer2:/layers/layer1\n\n# WRONG: reversed order hides application files under OS files\nlowerdir=/layers/layer1:/layers/layer2:/layers/layer3:/layers/layer4</code></pre></div>\n\n<p>⚠️ <strong>Pitfall 2: Forgetting the work directory</strong></p>\n<p><strong>Description</strong>: Omitting the <code>workdir</code> mount option or pointing it to a non-empty directory.</p>\n<p><strong>Why it&#39;s wrong</strong>: OverlayFS requires a dedicated <code>workdir</code> for atomic rename operations during copy-up. If absent or non-empty, the mount fails with &quot;invalid argument.&quot;</p>\n<p><strong>How to fix</strong>: Always create an empty <code>workdir</code> adjacent to the <code>upperdir</code>. Use a unique subdirectory per container to prevent collisions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Create work directory alongside upper</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">workDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#9ECBFF\">\"work\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(workDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\"> }</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall 3: Not handling whiteouts properly</strong></p>\n<p><strong>Description</strong>: When a container deletes a file from a lower layer, OverlayFS creates a &quot;whiteout&quot; (character device with major/minor 0/0) in the upper layer. Userspace tools must interpret these when exporting layers.</p>\n<p><strong>Why it&#39;s wrong</strong>: If you later commit the container&#39;s upper layer to create a new image layer, you must convert whiteout devices back to OCI whiteout format (<code>.wh.&lt;filename&gt;</code> files) for compatibility with other tools.</p>\n<p><strong>How to fix</strong>: When traversing the upper layer for layer creation, check for device files with <code>stat.Rdev == 0</code>. Convert them to whiteout entries in the layer tar archive.</p>\n<p>⚠️ <strong>Pitfall 4: Mount propagation leaking between containers</strong></p>\n<p><strong>Description</strong>: Without proper mount namespace isolation, an OverlayFS mount in one container might become visible in another container&#39;s filesystem view.</p>\n<p><strong>Why it&#39;s wrong</strong>: This violates filesystem isolation—containers could see each other&#39;s OverlayFS mount points or, worse, modify them.</p>\n<p><strong>How to fix</strong>: Ensure the container process runs in its own mount namespace (<code>CLONE_NEWNS</code>). Set mount propagation to <code>MS_PRIVATE</code> before creating OverlayFS mounts so they don&#39;t propagate to other namespaces.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In the container setup, before mounting OverlayFS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">syscall.</span><span style=\"color:#B392F0\">Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"none\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, syscall.MS_PRIVATE</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">syscall.MS_REC, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall 5: Open file handles surviving unmount</strong></p>\n<p><strong>Description</strong>: If a process inside the container holds open file descriptors to files in the OverlayFS, unmounting will fail with &quot;device busy.&quot;</p>\n<p><strong>Why it&#39;s wrong</strong>: During container cleanup, you need to unmount the OverlayFS to release resources. Open files prevent this, causing resource leaks.</p>\n<p><strong>How to fix</strong>: Before unmounting, ensure all processes in the container namespace have terminated. Use <code>MNT_DETACH</code> flag for lazy unmount as a fallback, but prefer proper process termination.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Force unmount with detach if regular unmount fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Unmount</span><span style=\"color:#E1E4E8\">(mountPath, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    syscall.</span><span style=\"color:#B392F0\">Unmount</span><span style=\"color:#E1E4E8\">(mountPath, syscall.MNT_DETACH)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"implementation-guidance-for-layered-filesystem\">Implementation Guidance for Layered Filesystem</h3>\n<p>This section bridges the design concepts to concrete Go implementation, providing the scaffolding and key algorithms for the layered filesystem component.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Union Filesystem</td>\n<td>OverlayFS with <code>mount</code> syscall</td>\n<td>Multiple backing stores (btrfs, zfs snapshots)</td>\n</tr>\n<tr>\n<td>Layer Storage</td>\n<td>Plain directories with extracted tar layers</td>\n<td>Content-addressable storage with deduplication</td>\n</tr>\n<tr>\n<td>Image Layer Cache</td>\n<td>In-memory map of layer digests to paths</td>\n<td>Database with reference counting and GC</td>\n</tr>\n<tr>\n<td>Whiteout Handling</td>\n<td>Basic device node detection</td>\n<td>Full OCI whiteout spec with opaque directories</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<p>Extend the existing project structure with overlay-specific modules:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   └── byod/                    # CLI entry point\n├── internal/\n│   ├── container/               # Container management\n│   ├── cgroup/                  # Resource limits\n│   ├── namespace/               # Namespace isolation\n│   ├── network/                 # Networking\n│   ├── image/                   # Image handling (from Milestone 6)\n│   └── storage/                 # NEW: Storage and layered filesystems\n│       ├── storage.go           # Storage interface definitions\n│       ├── overlay.go           # OverlayFS implementation\n│       ├── layer.go             # Layer management\n│       ├── cache.go             # Layer caching\n│       └── whiteout.go          # Whiteout handling utilities\n└── pkg/\n    └── oci/                     # OCI image spec types</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete OverlayFS Mount Helper</strong> (ready to use):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/storage/overlay.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/byod/pkg/oci</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OverlayManager handles OverlayFS mounts for container root filesystems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OverlayManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstorageBase </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Base directory for layer storage (e.g., /var/lib/byod/storage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewOverlayManager creates a new OverlayFS manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewOverlayManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storageBase</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OverlayManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(storageBase, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating storage base: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">OverlayManager</span><span style=\"color:#E1E4E8\">{storageBase: storageBase}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MountOverlay creates an OverlayFS mount for a container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the path to the merged directory (container's rootfs view)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">om </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OverlayManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MountOverlay</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">lowerDirs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">upperDir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">workDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Create necessary directories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(upperDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating upper dir: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(workDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating work dir: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmergedDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Dir</span><span style=\"color:#E1E4E8\">(upperDir), </span><span style=\"color:#9ECBFF\">\"merged\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(mergedDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating merged dir: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Build lowerdir string (oldest layer first)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlowerdir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(lowerDirs, </span><span style=\"color:#9ECBFF\">\":\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// OverlayFS mount options</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\toptions </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"lowerdir=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">,upperdir=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">,workdir=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, lowerdir, upperDir, workDir)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Mount OverlayFS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"overlay\"</span><span style=\"color:#E1E4E8\">, mergedDir, </span><span style=\"color:#9ECBFF\">\"overlay\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, options); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mounting overlayfs: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> mergedDir, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UnmountOverlay unmounts and cleans up OverlayFS mount</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">om </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OverlayManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UnmountOverlay</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mergedDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Try normal unmount first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Unmount</span><span style=\"color:#E1E4E8\">(mergedDir, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Fallback to lazy unmount if busy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tsyscall.</span><span style=\"color:#B392F0\">Unmount</span><span style=\"color:#E1E4E8\">(mergedDir, syscall.MNT_DETACH)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Clean up merged directory (safe after unmount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tos.</span><span style=\"color:#B392F0\">RemoveAll</span><span style=\"color:#E1E4E8\">(mergedDir)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetLayerPath returns the path where a layer with given digest is stored</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">om </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OverlayManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetLayerPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Convert digest to safe filesystem path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// OCI digests are like \"sha256:abc123...\" - use just the hash part</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tparts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">SplitN</span><span style=\"color:#E1E4E8\">(digest, </span><span style=\"color:#9ECBFF\">\":\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> parts[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> else</span><span style=\"color:#E1E4E8\"> digest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(om.storageBase, </span><span style=\"color:#9ECBFF\">\"layers\"</span><span style=\"color:#E1E4E8\">, hash[:</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], hash) </span><span style=\"color:#6A737D\">// Sharding by first 2 chars</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Layer Cache with Reference Counting</strong> (ready to use):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/storage/cache.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LayerCache tracks which layers are in use by containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LayerCache</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlayers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // digest -> reference count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewLayerCache creates a new layer cache</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewLayerCache</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LayerCache</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">LayerCache</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tlayers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddReference increments reference count for a layer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LayerCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlc.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> lc.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlc.layers[digest]</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReleaseReference decrements reference count, returns true if count reaches zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LayerCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReleaseReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlc.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> lc.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> count, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> lc.layers[digest]; exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\t\t\tdelete</span><span style=\"color:#E1E4E8\">(lc.layers, digest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#6A737D\"> // Layer is no longer referenced</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tlc.layers[digest] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsLayerCached checks if a layer exists in the cache</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LayerCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsLayerCached</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlc.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> lc.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t_, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> lc.layers[digest]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Layer Extraction and Preparation</strong> (learner implements):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/storage/layer.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">archive/tar</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">compress/gzip</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/byod/pkg/oci</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExtractLayer extracts a compressed tar layer to the destination directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// layerPath: path to the .tar.gz layer file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// destDir: directory to extract contents to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the digest of the extracted layer for verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ExtractLayer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">layerPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">destDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Open the layer file for reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: os.Open(layerPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create a gzip reader to decompress the tar</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: gzip.NewReader(file)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Create a tar reader from the gzip reader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Hint: tar.NewReader(gzipReader)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Iterate through tar headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// for {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   header, err := tarReader.Next()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   if err == io.EOF { break }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   if err != nil { return \"\", err }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: For each header, construct the full destination path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// targetPath := filepath.Join(destDir, header.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Handle different tar entry types:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - TypeDir: Create directory with header.Mode permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - TypeReg/TypeRegA: Create file, copy contents from tarReader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - TypeSymlink: Create symbolic link</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - TypeLink: Create hard link</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - TypeChar/TypeBlock: Create device node with header.Devmajor/Devminor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Set proper ownership (header.Uid, header.Gid) using syscall.Chown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Note: This may require root privileges or user namespace setup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Set modification time from header.ModTime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: Handle whiteout files (header.Name starts with \".wh.\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Remove the corresponding file/directory from destination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - For \".wh..wh..opq\" (opaque directory), mark directory as opaque</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 10: Close all readers and return nil if successful</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PrepareLayersForContainer prepares all layers for a container's rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// image: The OCI image containing layer descriptors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// containerID: Unique container identifier for storage paths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns: paths to lower directories (oldest first), upper dir, work dir, error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">om </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OverlayManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PrepareLayersForContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">image</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">oci</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Image</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainerDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(om.storageBase, </span><span style=\"color:#9ECBFF\">\"containers\"</span><span style=\"color:#E1E4E8\">, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Create container directories: upper, work, layers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// upperDir := filepath.Join(containerDir, \"upper\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// workDir := filepath.Join(containerDir, \"work\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// layersDir := filepath.Join(containerDir, \"layers\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: For each layer in image.Layers (in order they appear in manifest):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   a. Check if layer already extracted in cache (use GetLayerPath)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   b. If not cached, download layer (from image store) and extract to cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   c. Add layer reference to LayerCache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   d. Add layer path to lowerDirs slice</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: IMPORTANT: Reverse the lowerDirs slice for OverlayFS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// OverlayFS expects oldest layer first, but OCI lists layers in application order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// So layer[0] is applied on top of base, should be last in lowerdir list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Return lowerDirs (reversed), upperDir, workDir, nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Updated FilesystemManager Integration</strong> (learner implements):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/container/filesystem.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> container</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/byod/internal/storage</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/byod/pkg/oci</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// setupLayeredRootfs sets up a container rootfs using OverlayFS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">setupLayeredRootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">image</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">oci</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Image</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Initialize OverlayManager if not already done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// if fm.overlayManager == nil {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   fm.overlayManager = storage.NewOverlayManager(fm.basePath)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Prepare layers using OverlayManager.PrepareLayersForContainer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// lowerDirs, upperDir, workDir, err := fm.overlayManager.PrepareLayersForContainer(image, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Mount OverlayFS to create merged view</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// mergedDir, err := fm.overlayManager.MountOverlay(containerID, lowerDirs, upperDir, workDir)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Mount essential filesystems inside the merged directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Mount /proc at mergedDir/proc</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Mount /sys at mergedDir/sys (read-only)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Create /dev entries in mergedDir/dev</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Return path to merged directory (will become container's rootfs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cleanupLayeredRootfs cleans up OverlayFS mount and references</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">cleanupLayeredRootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Unmount essential filesystems (/proc, /sys, /dev) inside container rootfs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Get path to merged directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// mergedDir := filepath.Join(fm.basePath, \"containers\", containerID, \"merged\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Unmount OverlayFS using OverlayManager.UnmountOverlay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Release references to all layers in LayerCache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Clean up container directories (upper, work, layers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Note: Don't delete cached layers - they might be used by other containers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Mount Syscall</strong>: Use <code>syscall.Mount(&quot;overlay&quot;, target, &quot;overlay&quot;, 0, options)</code> where options is a comma-separated string like <code>&quot;lowerdir=/a:/b,upperdir=/c,workdir=/d&quot;</code>.</p>\n</li>\n<li><p><strong>Tar Extraction</strong>: Use <code>archive/tar</code> and <code>compress/gzip</code> packages. Remember to handle symlinks and device files specially—regular file copying won&#39;t work for them.</p>\n</li>\n<li><p><strong>Whiteout Detection</strong>: Check if tar header name starts with <code>.wh.</code>. The OCI spec uses <code>.wh.&lt;filename&gt;</code> for whiteouts and <code>.wh..wh..opq</code> for opaque directories.</p>\n</li>\n<li><p><strong>Path Length Limits</strong>: Linux kernel has a 4096-byte limit for mount options. If your <code>lowerdir</code> string exceeds this, consider using the <code>volatile</code> lowerdir feature (kernel 4.13+) or workaround with intermediate mounts.</p>\n</li>\n<li><p><strong>Error Handling</strong>: OverlayFS mount can fail with specific errno values:</p>\n<ul>\n<li><code>EINVAL</code>: Invalid options (check lowerdir/upperdir/workdir paths exist)</li>\n<li><code>ENODEV</code>: OverlayFS not enabled in kernel (<code>CONFIG_OVERLAY_FS</code>)</li>\n<li><code>EBUSY</code>: Mount point is busy (unmount previous mounts first)</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the layered filesystem component, verify it works correctly:</p>\n<p><strong>Test Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and run a test that creates a container with layered rootfs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/storage/...</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestOverlayFS</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ol>\n<li>An OCI image with multiple layers should be correctly assembled into a single rootfs.</li>\n<li>Files from upper layers should override files from lower layers with the same path.</li>\n<li>Creating a file in the container should appear only in the upper layer directory.</li>\n<li>Deleting a file from a lower layer should create a whiteout in the upper layer.</li>\n<li>After container cleanup, the merged directory should unmount successfully.</li>\n</ol>\n<p><strong>Manual Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># 1. Create a container with an alpine image</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --name</span><span style=\"color:#9ECBFF\"> test-layers</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Inside container, create a file</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"test\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /myfile.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Exit container and inspect layers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /var/lib/byod/storage/containers/test-layers/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: upper/, work/, merged/, layers/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. Check upper layer contains the new file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /var/lib/byod/storage/containers/test-layers/upper/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show myfile.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 5. Check lower layers remain unchanged</span></span></code></pre></div>\n\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li>Container fails to start with &quot;invalid argument&quot;: Check OverlayFS mount options format.</li>\n<li>Files from base layer not visible: Lower layer order is reversed.</li>\n<li>&quot;Device busy&quot; on cleanup: Processes still running in container namespace.</li>\n<li>Permission errors: User namespace mapping incorrect or extraction ownership issues.</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mount fails with &quot;invalid argument&quot;</td>\n<td>Missing work directory or non-empty workdir</td>\n<td>Check <code>dmesg | tail</code> for kernel messages</td>\n<td>Create empty work directory before mount</td>\n</tr>\n<tr>\n<td>Files from application layer not visible</td>\n<td>Lowerdir order incorrect</td>\n<td>Print lowerdir string, verify chronological order</td>\n<td>Reverse the lowerdir list (oldest first)</td>\n</tr>\n<tr>\n<td>&quot;Operation not permitted&quot; on mount</td>\n<td>Missing capabilities or user namespace</td>\n<td>Check <code>cat /proc/self/status | grep CapEff</code></td>\n<td>Run as root or grant CAP_SYS_ADMIN</td>\n</tr>\n<tr>\n<td>Container sees wrong file contents</td>\n<td>Upper layer not properly separated</td>\n<td>Check if upperdir is shared between containers</td>\n<td>Use unique upperdir per container</td>\n</tr>\n<tr>\n<td>Unmount fails with &quot;device busy&quot;</td>\n<td>Open file handles in container</td>\n<td><code>lsof +D /var/lib/byod/containers/&lt;id&gt;/merged</code></td>\n<td>Ensure all container processes terminated</td>\n</tr>\n<tr>\n<td>Whiteouts appear as character devices</td>\n<td>Upper layer not interpreting whiteouts</td>\n<td>Check <code>ls -l</code> in upperdir for device files with 0,0</td>\n<td>Implement whiteout handling in layer extraction</td>\n</tr>\n<tr>\n<td>Copy-up causes high CPU</td>\n<td>Many small files copying up</td>\n<td>Monitor with <code>inotifywait -rm /merged</code></td>\n<td>Consider tuning overlay kernel module params</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 5: Container Networking</p>\n</blockquote>\n<h2 id=\"component-design-container-networking-milestone-5\">Component Design: Container Networking (Milestone 5)</h2>\n<p>Container networking is the component that provides each container with an isolated network environment while enabling controlled connectivity to the host, other containers, and external networks. This involves creating a private network stack, establishing virtual network links, and configuring routing and firewall rules. The key architectural challenge is to provide useful network connectivity while maintaining the security and isolation guarantees of containers.</p>\n<h3 id=\"mental-model-private-phone-lines-with-a-switchboard\">Mental Model: Private Phone Lines with a Switchboard</h3>\n<p>Imagine an office building with private phone lines. Each office (container) has its own private telephone network with a unique phone number and internal extensions. These private networks are connected to a central switchboard (bridge) in the building&#39;s telecom room (host). The switchboard can:</p>\n<ol>\n<li><strong>Connect offices internally</strong>: When an office calls another office&#39;s extension, the switchboard routes the call directly between their private lines.</li>\n<li><strong>Route external calls</strong>: When an office calls an outside number, the switchboard forwards the call through the building&#39;s main trunk line (host&#39;s physical interface), making it appear as if the call originated from the building&#39;s main number (host IP).</li>\n<li><strong>Receive incoming calls</strong>: The switchboard can route calls from the main trunk to specific offices by mapping the building&#39;s main number plus an extension (host port) to an office&#39;s internal line (container port).</li>\n</ol>\n<p>The private phone lines are <strong>virtual ethernet (veth) pairs</strong>—twin cables where one end plugs into the office&#39;s phone system and the other into the switchboard. The switchboard is a <strong>Linux bridge</strong>—a virtual switch that connects multiple veth ends. The building&#39;s firewall rules (<strong>iptables</strong>) determine which calls are allowed and how they&#39;re translated.</p>\n<p>This model illustrates the complete isolation (each office has its own phone system), controlled connectivity (via the switchboard), and network address translation (external calls appear from the building) that container networking provides.</p>\n<h3 id=\"architecture-decision-records-network-topology\">Architecture Decision Records: Network Topology</h3>\n<h4 id=\"decision-bridge-network-with-nat-for-default-connectivity\">Decision: Bridge Network with NAT for Default Connectivity</h4>\n<p><strong>Context</strong>: Containers need network isolation but also practical connectivity. We must choose a default network topology that balances isolation, ease of use, and compatibility with existing Docker workflows.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Host network mode</strong>: Containers share the host&#39;s network namespace, providing maximum performance but zero network isolation.</li>\n<li><strong>Bridge network with NAT</strong>: Each container gets its own network namespace, connected via veth pair to a Linux bridge, with NAT for external connectivity (Docker&#39;s default).</li>\n<li><strong>Macvlan</strong>: Containers get direct MAC addresses on the physical network, appearing as separate physical devices but requiring switch configuration.</li>\n<li><strong>None</strong>: No network connectivity at all—complete isolation.</li>\n</ol>\n<p><strong>Decision</strong>: Bridge network with NAT as the default topology.</p>\n<p><strong>Rationale</strong>: </p>\n<ul>\n<li><strong>Isolation</strong>: Each container gets a full isolated network stack (own interfaces, routing, iptables).</li>\n<li><strong>Practicality</strong>: NAT allows containers to access external networks without requiring public IPs for each container.</li>\n<li><strong>Port mapping</strong>: Host port forwarding enables services inside containers to be accessible from outside the host.</li>\n<li><strong>Inter-container communication</strong>: Containers on the same bridge can communicate directly via their private IPs.</li>\n<li><strong>Established pattern</strong>: Matches Docker&#39;s default <code>bridge</code> driver, providing familiar behavior for users.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Performance overhead</strong>: Extra hop through bridge and NAT layer introduces minor latency.</li>\n<li><strong>IP address management</strong>: Requires IPAM (IP Address Management) to allocate unique IPs to containers.</li>\n<li><strong>NAT complexities</strong>: Requires iptables rules for masquerading and port forwarding.</li>\n<li><strong>Bridge setup</strong>: Requires creating and managing a Linux bridge device.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Host network</td>\n<td>Maximum performance, no setup required</td>\n<td>Zero network isolation, port conflicts</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Bridge with NAT</strong></td>\n<td><strong>Good isolation, external access via NAT, port mapping, inter-container communication</strong></td>\n<td><strong>NAT overhead, IPAM required, bridge setup</strong></td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Macvlan</td>\n<td>Direct physical network access, no NAT overhead</td>\n<td>Requires network support, no port mapping, less isolation</td>\n<td>No</td>\n</tr>\n<tr>\n<td>None</td>\n<td>Maximum isolation</td>\n<td>No network connectivity</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"decision-veth-pair-for-container-host-connectivity\">Decision: veth Pair for Container-Host Connectivity</h4>\n<p><strong>Context</strong>: We need to connect the container&#39;s isolated network namespace to the host&#39;s network namespace to provide connectivity.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>veth pair</strong>: Virtual Ethernet device pair—one end in container, one end in host, connected like a virtual network cable.</li>\n<li><strong>macvlan</strong>: Assigns a unique MAC address to container, attaching directly to physical interface.</li>\n<li><strong>ipvlan</strong>: Similar to macvlan but shares MAC address, differing only in IP configuration.</li>\n</ol>\n<p><strong>Decision</strong>: veth pair.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Simplicity</strong>: Well-understood, stable Linux primitive.</li>\n<li><strong>Bridge compatibility</strong>: veth endpoints can be added to Linux bridges easily.</li>\n<li><strong>Isolation</strong>: Complete layer 2 separation between container and host.</li>\n<li><strong>Debugging</strong>: Easy to inspect with <code>ip link</code> on both ends.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li>Requires creating and configuring two devices per container.</li>\n<li>Must manage lifecycle (create, move to namespace, delete).</li>\n<li>Bridge acts as a virtual switch connecting multiple veth ends.</li>\n</ul>\n<h4 id=\"decision-iptables-for-nat-and-firewalling\">Decision: iptables for NAT and Firewalling</h4>\n<p><strong>Context</strong>: Containers with private IPs need to communicate with external networks, and we need to forward host ports to container ports.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>iptables</strong>: Traditional Linux firewall/NAT tool using netfilter hooks.</li>\n<li><strong>nftables</strong>: Newer replacement for iptables with unified syntax.</li>\n<li><strong>Userspace proxy</strong>: Proxy connections in userspace (like Docker&#39;s legacy mode).</li>\n</ol>\n<p><strong>Decision</strong>: iptables.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Ubiquity</strong>: Available on virtually all Linux systems.</li>\n<li><strong>Docker compatibility</strong>: Docker uses iptables, ensuring consistent behavior.</li>\n<li><strong>Performance</strong>: Kernel-space packet processing, minimal overhead.</li>\n<li><strong>Mature</strong>: Well-documented with extensive community knowledge.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li>Complex rule management (must add/remove rules per container).</li>\n<li>Potential conflicts with existing host iptables rules.</li>\n<li>Requires understanding of netfilter chains and traversal order.</li>\n</ul>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fnetwork-topology.svg\" alt=\"Container Network Topology\"></p>\n<h3 id=\"common-pitfalls-in-container-networking\">Common Pitfalls in Container Networking</h3>\n<p>⚠️ <strong>Pitfall: DNS Resolution Failures Inside Container</strong></p>\n<p><strong>Description</strong>: The container can ping IP addresses but cannot resolve hostnames (e.g., <code>curl https://google.com</code> fails). This occurs because the container&#39;s <code>/etc/resolv.conf</code> is either missing, empty, or contains invalid DNS servers.</p>\n<p><strong>Why it&#39;s wrong</strong>: Network connectivity without DNS is severely limited—most applications rely on hostname resolution.</p>\n<p><strong>How to fix</strong>: </p>\n<ol>\n<li>Copy the host&#39;s <code>/etc/resolv.conf</code> into the container rootfs (but note this may leak host DNS configuration).</li>\n<li>Use a known public DNS server like <code>8.8.8.8</code> (Google) or <code>1.1.1.1</code> (Cloudflare).</li>\n<li>Better: Detect the host&#39;s DNS configuration via <code>systemd-resolve</code> or <code>/run/systemd/resolve/resolv.conf</code> and use those nameservers.</li>\n</ol>\n<p><strong>Prevention</strong>: Always configure <code>/etc/resolv.conf</code> as part of container filesystem setup. Use a template that includes fallback nameservers.</p>\n<p>⚠️ <strong>Pitfall: iptables Rules Blocking Inter-Container Communication</strong></p>\n<p><strong>Description</strong>: Containers on the same bridge cannot ping each other, though they have IP addresses on the same subnet. This often happens because the host&#39;s firewall rules (particularly in the <code>FORWARD</code> chain) are dropping packets between bridge interfaces.</p>\n<p><strong>Why it&#39;s wrong</strong>: The bridge device forwards at layer 2, but iptables filters at layer 3. Default policies may block forwarded traffic.</p>\n<p><strong>How to fix</strong>: </p>\n<ol>\n<li>Ensure <code>net.ipv4.ip_forward=1</code> is set on the host.</li>\n<li>Add iptables rules to allow forwarded traffic between bridge interfaces: <code>iptables -I FORWARD -i br0 -o br0 -j ACCEPT</code>.</li>\n<li>Check that the bridge&#39;s <code>FORWARD</code> chain policy is <code>ACCEPT</code>.</li>\n</ol>\n<p><strong>Prevention</strong>: During bridge creation, configure iptables rules to allow traffic between containers on the same bridge and set appropriate forward policies.</p>\n<p>⚠️ <strong>Pitfall: Host Port Conflict on Container Start</strong></p>\n<p><strong>Description</strong>: Starting a container with port mapping fails with &quot;bind: address already in use&quot; because the host port is already occupied by another process.</p>\n<p><strong>Why it&#39;s wrong</strong>: The container runtime should detect this before attempting to start the container and provide a clear error message.</p>\n<p><strong>How to fix</strong>: </p>\n<ol>\n<li>Before setting up port forwarding, check if the host port is available by attempting to listen on it (with <code>SO_REUSEADDR</code>).</li>\n<li>If occupied, either fail with a clear error or automatically select an alternative port (if configured to do so).</li>\n</ol>\n<p><strong>Prevention</strong>: Implement port availability checking in the <code>NetworkManager.SetupNetwork</code> method before adding iptables rules.</p>\n<p>⚠️ <strong>Pitfall: Orphaned Network Resources After Container Crash</strong></p>\n<p><strong>Description</strong>: When a container crashes or is killed, its network namespace and veth pair may remain on the host, accumulating over time and causing resource leaks.</p>\n<p><strong>Why it&#39;s wrong</strong>: Orphaned network namespaces consume kernel resources and may interfere with subsequent containers (e.g., IP address conflicts).</p>\n<p><strong>How to fix</strong>: </p>\n<ol>\n<li>Always implement cleanup in a <code>defer</code> statement or signal handler.</li>\n<li>On container start, record the network namespace handle and veth pair names for later cleanup.</li>\n<li>During container removal, forcefully delete the network namespace if it still exists (<code>ip netns delete &lt;ns&gt;</code>).</li>\n</ol>\n<p><strong>Prevention</strong>: Design the <code>NetworkManager</code> to track created resources and provide a <code>CleanupNetwork</code> method that is called during container removal, even after failures.</p>\n<p>⚠️ <strong>Pitfall: MTU Mismatch Causing Packet Fragmentation</strong></p>\n<p><strong>Description</strong>: Network performance is poor, with high latency and dropped packets. This can occur when the MTU (Maximum Transmission Unit) of the veth interface differs from the host&#39;s physical interface or bridge.</p>\n<p><strong>Why it&#39;s wrong</strong>: Packets exceeding the MTU will be fragmented (reducing performance) or dropped.</p>\n<p><strong>How to fix</strong>: </p>\n<ol>\n<li>Set the MTU on veth interfaces to match the host&#39;s physical interface (typically 1500 for Ethernet).</li>\n<li>Consider lowering MTU if using overlay networks or VPNs.</li>\n</ol>\n<p><strong>Prevention</strong>: During veth creation, explicitly set the MTU based on the host&#39;s default route interface MTU.</p>\n<h3 id=\"implementation-guidance-for-network-setup\">Implementation Guidance for Network Setup</h3>\n<p>This section provides concrete implementation guidance for the networking component. The primary challenge is orchestrating multiple Linux networking primitives while handling errors and cleanup properly.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Namespace Creation</td>\n<td><code>unshare(CLONE_NEWNET)</code> via Go&#39;s <code>syscall</code> package</td>\n<td><code>ip netns add</code> via exec for better tool compatibility</td>\n</tr>\n<tr>\n<td>Interface Management</td>\n<td><code>netlink</code> library (e.g., <code>github.com/vishvananda/netlink</code>)</td>\n<td>Raw syscalls via <code>syscall</code> package</td>\n</tr>\n<tr>\n<td>Bridge Creation</td>\n<td><code>netlink</code> library or <code>ip link add br0 type bridge</code> via exec</td>\n<td>Direct ioctl calls</td>\n</tr>\n<tr>\n<td>iptables Rules</td>\n<td><code>exec.Command(&quot;iptables&quot;, ...)</code></td>\n<td><code>github.com/coreos/go-iptables/iptables</code> library</td>\n</tr>\n<tr>\n<td>Port Forwarding</td>\n<td>iptables DNAT rules</td>\n<td>Userspace proxy (like socat) for complex scenarios</td>\n</tr>\n<tr>\n<td>IP Address Management</td>\n<td>Static allocation from a predefined subnet</td>\n<td>DHCP server or IPAM library</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Add networking-specific files to the project structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   └── byod/                         # CLI entry point\n├── internal/\n│   ├── container/                    # Container management\n│   ├── cgroup/                       # cgroup management\n│   ├── image/                        # Image handling\n│   ├── filesystem/                   # Filesystem isolation\n│   ├── network/                      # NEW: Network component\n│   │   ├── manager.go                # NetworkManager implementation\n│   │   ├── bridge.go                 # Bridge creation and management\n│   │   ├── veth.go                   # veth pair operations\n│   │   ├── iptables.go               # iptables rule management\n│   │   ├── ipam.go                   # IP Address Management\n│   │   └── network_test.go           # Network tests\n│   └── runtime/                      # Main runtime coordination\n└── pkg/\n    └── netutil/                      # Reusable networking utilities</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete <code>netlink</code> wrapper for basic operations</strong> (import and use as-is):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/network/netlink_helper.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> network</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/vishvananda/netlink</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/vishvananda/netns</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetlinkHelper provides convenience methods for common network operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetlinkHelper</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewNetlinkHelper creates a new helper instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewNetlinkHelper</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateBridge creates a Linux bridge with the given name and IP address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateBridge</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ipNet</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IPNet</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Check if bridge already exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t_, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkByName</span><span style=\"color:#E1E4E8\">(name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bridge </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> already exists\"</span><span style=\"color:#E1E4E8\">, name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Create bridge attributes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tla </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">NewLinkAttrs</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tla.Name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbridge </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Bridge</span><span style=\"color:#E1E4E8\">{LinkAttrs: la}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Add bridge</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkAdd</span><span style=\"color:#E1E4E8\">(bridge); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create bridge </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, name, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Set bridge UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkSetUp</span><span style=\"color:#E1E4E8\">(bridge); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Clean up on failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tnetlink.</span><span style=\"color:#B392F0\">LinkDel</span><span style=\"color:#E1E4E8\">(bridge)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to set bridge </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, name, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Assign IP address if provided</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> ipNet </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\taddr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Addr</span><span style=\"color:#E1E4E8\">{IPNet: ipNet}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">AddrAdd</span><span style=\"color:#E1E4E8\">(bridge, addr); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tnetlink.</span><span style=\"color:#B392F0\">LinkDel</span><span style=\"color:#E1E4E8\">(bridge)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to add IP </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> to bridge </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ipNet.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(), name, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateVethPair creates a veth pair with the given names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateVethPair</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">hostVethName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerVethName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">mtu</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Create veth pair attributes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tveth </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Veth</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tLinkAttrs: </span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">LinkAttrs</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tName: hostVethName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tMTU:  mtu,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tPeerName: containerVethName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Add veth pair</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkAdd</span><span style=\"color:#E1E4E8\">(veth); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create veth pair </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, hostVethName, containerVethName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Set host veth UP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thostVeth, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkByName</span><span style=\"color:#E1E4E8\">(hostVethName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tnetlink.</span><span style=\"color:#B392F0\">LinkDel</span><span style=\"color:#E1E4E8\">(veth)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to find host veth </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, hostVethName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkSetUp</span><span style=\"color:#E1E4E8\">(hostVeth); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tnetlink.</span><span style=\"color:#B392F0\">LinkDel</span><span style=\"color:#E1E4E8\">(veth)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to set host veth </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, hostVethName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MoveInterfaceToNamespace moves a network interface to the specified network namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MoveInterfaceToNamespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ifaceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Get the interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tiface, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkByName</span><span style=\"color:#E1E4E8\">(ifaceName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to find interface </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ifaceName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Get the target namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tnsHandle, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netns.</span><span style=\"color:#B392F0\">GetFromPath</span><span style=\"color:#E1E4E8\">(nsPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to get namespace from path </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, nsPath, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> nsHandle.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Move the interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkSetNsFd</span><span style=\"color:#E1E4E8\">(iface, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(nsHandle)); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to move interface </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> to namespace: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ifaceName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ConfigureInterfaceInNamespace configures an interface inside a network namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must be called from within the namespace context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ConfigureInterfaceInNamespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ifaceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ipNet</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IPNet</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">gateway</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IP</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Get the interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tiface, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkByName</span><span style=\"color:#E1E4E8\">(ifaceName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to find interface </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> in namespace: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ifaceName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Set interface UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkSetUp</span><span style=\"color:#E1E4E8\">(iface); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to set interface </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ifaceName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Add IP address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> ipNet </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\taddr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Addr</span><span style=\"color:#E1E4E8\">{IPNet: ipNet}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">AddrAdd</span><span style=\"color:#E1E4E8\">(iface, addr); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to add IP </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> to interface </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ipNet.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(), ifaceName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Add default route if gateway provided</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> gateway </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tdefaultRoute </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Route</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tDst: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Default route</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tGw:  gateway,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">RouteAdd</span><span style=\"color:#E1E4E8\">(defaultRoute); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to add default route via </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gateway.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(), err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LockOSThreadAndExecute locks the OS thread and executes fn in the specified namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LockOSThreadAndExecute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fn</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Lock the goroutine to its current OS thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\truntime.</span><span style=\"color:#B392F0\">LockOSThread</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">UnlockOSThread</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Get current namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\toriginalNS, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netns.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to get current namespace: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> originalNS.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Get target namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttargetNS, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netns.</span><span style=\"color:#B392F0\">GetFromPath</span><span style=\"color:#E1E4E8\">(nsPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to get target namespace </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, nsPath, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> targetNS.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Switch to target namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netns.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(targetNS); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to enter namespace </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, nsPath, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Execute function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\terr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fn</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Switch back to original namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> setErr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netns.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(originalNS); setErr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Log but return original error if any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\terr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to return to original namespace: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, setErr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>NetworkManager implementation</strong> (to be completed by the learner):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/network/manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> network</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">your-project/internal/container</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkManager handles container network setup and teardown</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbaseBridgeName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbridgeIPNet    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IPNet</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tipam           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPAM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thelper         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewNetworkManager creates a new NetworkManager with default bridge configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewNetworkManager</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Default bridge subnet: 172.17.0.0/16 (Docker-compatible)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t_, ipNet, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> net.</span><span style=\"color:#B392F0\">ParseCIDR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"172.17.0.1/16\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to parse default subnet: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">NetworkManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tbaseBridgeName: </span><span style=\"color:#9ECBFF\">\"byod0\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tbridgeIPNet:    ipNet,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tipam:           </span><span style=\"color:#B392F0\">NewIPAM</span><span style=\"color:#E1E4E8\">(ipNet),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\thelper:         </span><span style=\"color:#B392F0\">NewNetlinkHelper</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupNetwork configures the network namespace for a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">nm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> container</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Validate network configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Check NetworkConfig.Mode is supported (e.g., \"bridge\", \"none\", \"host\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - For bridge mode, ensure BridgeName is set or use default</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Validate IPAddress if provided (must be within bridge subnet)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Validate PortMappings (host port > 0, container port > 0)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create or ensure bridge exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Use nm.helper.CreateBridge() to create bridge if it doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Set bridge IP address (first IP in subnet, e.g., 172.17.0.1/16)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Enable IP forwarding on host: sysctl net.ipv4.ip_forward=1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Allocate IP address for container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Use nm.ipam.Allocate() to get an available IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - If config.IPAddress is provided, try to allocate that specific IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Store allocation for later cleanup</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Create veth pair</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Generate unique names: host veth \"veth&#x3C;containerID[:8]>\", container veth \"eth0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Use nm.helper.CreateVethPair() with MTU 1500</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Move container veth end to container's network namespace using nm.helper.MoveInterfaceToNamespace()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Configure container veth inside namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Use nm.helper.LockOSThreadAndExecute() to enter container namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Inside namespace:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//     a. Rename container veth to \"eth0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//     b. Configure IP address and default gateway (bridge IP)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//     c. Set interface UP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//     d. Configure loopback interface (set UP)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Attach host veth to bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Use netlink to attach host veth end to bridge</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Setup iptables rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Masquerading: Allow container outbound traffic via NAT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Port forwarding: DNAT rules for each PortMapping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Inter-container communication: Allow FORWARD traffic between bridge interfaces</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Configure DNS in container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Create /etc/resolv.conf in container rootfs with nameservers (e.g., 8.8.8.8)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: Record network configuration for later cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Store veth names, IP allocation, iptables rule identifiers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupNetwork removes all network resources for a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">nm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> container</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Retrieve saved network configuration for this container</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Remove iptables rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Delete masquerading rule</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Delete port forwarding rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   - Delete inter-container communication rules if this is the last container</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Remove veth pair from bridge and delete it</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Release IP address back to IPAM pool</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: If this is the last container using the bridge, optionally remove bridge</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IPAM manages IP address allocation within a subnet</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IPAM</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsubnet    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IPNet</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tallocated </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewIPAM creates a new IPAM for the given subnet</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewIPAM</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">subnet</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IPNet</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPAM</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">IPAM</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tsubnet:    subnet,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tallocated: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allocate allocates an available IP address from the subnet</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPAM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Allocate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">requestedIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IP</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: If requestedIP is provided, validate it's within subnet and not allocated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: If no requestedIP, find first available IP in subnet (skip network and broadcast addresses)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Mark IP as allocated in the map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Return allocated IP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Release returns an IP address to the pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPAM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ip</span><span style=\"color:#B392F0\"> net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IP</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Validate IP is within subnet</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Check if IP is actually allocated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Remove from allocated map</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>iptables rule management</strong> (skeleton):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/network/iptables.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> network</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os/exec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IPTablesManager manages iptables rules for container networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IPTablesManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupMasquerade sets up NAT masquerading for containers to reach external networks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPTablesManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupMasquerade</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bridgeName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Check if masquerade rule already exists in nat table POSTROUTING chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: If not, add rule: iptables -t nat -A POSTROUTING -s &#x3C;bridgeSubnet> ! -o &#x3C;bridgeName> -j MASQUERADE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Also ensure FORWARD chain accepts traffic from and to bridge</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddPortForwarding adds DNAT rule to forward host port to container port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPTablesManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddPortForwarding</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">hostPort</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerPort</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">protocol</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Validate protocol is \"tcp\" or \"udp\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Add rule: iptables -t nat -A PREROUTING -p &#x3C;protocol> --dport &#x3C;hostPort> -j DNAT --to-destination &#x3C;containerIP>:&#x3C;containerPort></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Add rule: iptables -A FORWARD -p &#x3C;protocol> -d &#x3C;containerIP> --dport &#x3C;containerPort> -j ACCEPT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemovePortForwarding removes the DNAT rule</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPTablesManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemovePortForwarding</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">hostPort</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerPort</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">protocol</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Construct the exact rule that was added</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Use iptables -t nat -D PREROUTING ... to delete the rule</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Delete the corresponding FORWARD rule</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// runIptablesCommand is a helper to execute iptables commands</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> runIptablesCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\"> ...</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcmd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> exec.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables\"</span><span style=\"color:#E1E4E8\">, args</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\toutput, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cmd.</span><span style=\"color:#B392F0\">CombinedOutput</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\"> failed: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">, output: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, args, err, output)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Namespace Handling</strong>: Use <code>runtime.LockOSThread()</code> when switching network namespaces with <code>netns.Set()</code>. The Go scheduler may move goroutines between threads, causing namespace switches to affect other goroutines.</p>\n</li>\n<li><p><strong>Netlink Library</strong>: The <code>github.com/vishvananda/netlink</code> and <code>github.com/vishvananda/netns</code> packages are de facto standards for Go container networking. They wrap complex netlink socket operations.</p>\n</li>\n<li><p><strong>Error Cleanup</strong>: Use defer statements strategically. When creating multiple resources (bridge, veth, iptables rules), create a cleanup function that can be called on failure.</p>\n</li>\n<li><p><strong>Concurrent Access</strong>: The <code>NetworkManager</code> may be called concurrently for multiple containers. Use a mutex to protect the IPAM allocation map and bridge creation.</p>\n</li>\n<li><p><strong>File Descriptors</strong>: When working with network namespaces via file descriptors (<code>/proc/&lt;pid&gt;/ns/net</code>), ensure they&#39;re closed properly to avoid resource leaks.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>Verification Steps</strong>:</p>\n<ol>\n<li><strong>Basic Network Isolation</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run a container with network isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network=bridge</span><span style=\"color:#79B8FF\"> --hostname=testcontainer</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> addr</span></span></code></pre></div>\n<p>   <strong>Expected</strong>: The container should show only <code>lo</code> and <code>eth0</code> interfaces, not host interfaces.</p>\n<ol start=\"2\">\n<li><strong>External Connectivity</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run a container and test external connectivity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network=bridge</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#79B8FF\"> 8.8.8.8</span></span></code></pre></div>\n<p>   <strong>Expected</strong>: Ping succeeds with 3 packets transmitted and received.</p>\n<ol start=\"3\">\n<li><strong>DNS Resolution</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Test DNS inside container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network=bridge</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> nslookup</span><span style=\"color:#9ECBFF\"> google.com</span></span></code></pre></div>\n<p>   <strong>Expected</strong>: Returns IP addresses for google.com.</p>\n<ol start=\"4\">\n<li><strong>Port Forwarding</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # In one terminal, run a web server in container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network=bridge</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> 8080:80</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> nc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 80</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # In another terminal, connect via host port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   echo</span><span style=\"color:#9ECBFF\"> \"test\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span></code></pre></div>\n<p>   <strong>Expected</strong>: The connection succeeds; the first terminal receives &quot;test&quot;.</p>\n<ol start=\"5\">\n<li><strong>Inter-Container Communication</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start first container with custom hostname</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network=bridge</span><span style=\"color:#79B8FF\"> --name=container1</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sleep</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   CONTAINER1_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Get its IP address (you'll need to implement `byod inspect` or check bridge)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   CONTAINER1_IP</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">172.17.0.2</span><span style=\"color:#6A737D\">  # Adjust based on actual allocation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Start second container and ping first</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network=bridge</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\"> $CONTAINER1_IP</span></span></code></pre></div>\n<p>   <strong>Expected</strong>: Ping succeeds between containers.</p>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li><code>ping: bad address &#39;google.com&#39;</code> → DNS misconfiguration</li>\n<li><code>connect: Network is unreachable</code> → Default route missing or bridge not configured</li>\n<li><code>bind: address already in use</code> → Host port conflict</li>\n<li><code>ping: sendmsg: operation not permitted</code> → Missing NAT masquerading rule</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container has no network interfaces</td>\n<td>Network namespace not created or veth not moved</td>\n<td>Check <code>/proc/&lt;pid&gt;/ns/net</code> symlink target; run <code>ip netns list</code></td>\n<td>Ensure <code>CLONE_NEWNET</code> flag is used and veth is moved to namespace</td>\n</tr>\n<tr>\n<td>Container cannot ping external IPs</td>\n<td>Missing NAT masquerading or IP forwarding disabled</td>\n<td>Check <code>sysctl net.ipv4.ip_forward</code>; check iptables <code>POSTROUTING</code> chain</td>\n<td>Enable IP forwarding; add masquerade rule</td>\n</tr>\n<tr>\n<td>Container cannot resolve DNS</td>\n<td>Missing/incorrect <code>/etc/resolv.conf</code></td>\n<td>Check container&#39;s <code>/etc/resolv.conf</code> contents</td>\n<td>Copy host&#39;s resolv.conf or use public DNS (8.8.8.8)</td>\n</tr>\n<tr>\n<td>Host cannot connect to container port</td>\n<td>Missing port forwarding rule or wrong iptables chain</td>\n<td>Check <code>iptables -t nat -L PREROUTING -n</code> for DNAT rule</td>\n<td>Add correct DNAT rule and ensure FORWARD chain allows traffic</td>\n</tr>\n<tr>\n<td>Containers on same bridge cannot ping each other</td>\n<td>FORWARD chain dropping packets between bridge interfaces</td>\n<td>Check <code>iptables -L FORWARD -n</code>; check bridge STP settings</td>\n<td>Add <code>iptables -I FORWARD -i br0 -o br0 -j ACCEPT</code></td>\n</tr>\n<tr>\n<td>veth interface disappears after container exit</td>\n<td>Not properly cleaning up network namespace</td>\n<td>Check if network namespace still exists: <code>ip netns list</code></td>\n<td>Ensure cleanup deletes namespace or moves veth back before deleting</td>\n</tr>\n</tbody></table>\n<p><strong>Diagnostic Commands</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Inspect network namespaces</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> netns</span><span style=\"color:#9ECBFF\"> list</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">container-pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">/ns/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check bridge configuration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> brctl</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#6A737D\">  # or ip link show type bridge</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> addr</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> br0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check iptables rules</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> iptables</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#9ECBFF\"> FORWARD</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check routing inside container namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> nsenter</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> route</span><span style=\"color:#9ECBFF\"> show</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> nsenter</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> addr</span><span style=\"color:#9ECBFF\"> show</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check DNS configuration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> nsenter</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#9ECBFF\"> /etc/resolv.conf</span></span></code></pre></div>\n\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 6: Image Format and CLI</p>\n</blockquote>\n<h2 id=\"component-design-image-format-and-cli-milestone-6\">Component Design: Image Format and CLI (Milestone 6)</h2>\n<p>This component is the user-facing interface and the image management engine of the container runtime. It transforms user commands into containerized processes by orchestrating all the underlying isolation primitives and managing the lifecycle of container images according to the OCI (Open Container Initiative) specification. While the previous components (<code>NamespaceManager</code>, <code>CgroupManager</code>, <code>FilesystemManager</code>, <code>NetworkManager</code>) provide the raw isolation capabilities, this component provides the cohesive user experience and image distribution model that make containers usable and portable.</p>\n<h3 id=\"mental-model-recipe-cards-and-ingredient-boxes\">Mental Model: Recipe Cards and Ingredient Boxes</h3>\n<p>Think of a container image as a <strong>recipe card</strong> for creating a standardized environment. The card (<code>ImageConfig</code>) lists the ingredients (<code>ImageLayers</code> - tar archives of filesystem diffs) and the instructions (<code>Entrypoint</code>, <code>Cmd</code>, <code>Env</code>) for what to run. The <strong>ingredient boxes</strong> are stored in a shared pantry (<code>image store</code>), where each box is labeled with a unique hash (<code>Digest</code>) of its contents. When you want to run the recipe, you don&#39;t copy all the boxes to your kitchen; instead, you create a thin, writable overlay on top of the stacked boxes (<code>OverlayFS merged view</code>) to cook in. If multiple people are making the same dish, they can all reference the same read-only ingredient boxes, saving immense space and time.</p>\n<p>The <strong>CLI (Command Line Interface)</strong> is like the head chef who reads the recipe card, gathers the ingredients from the pantry (or orders them online from a <code>registry</code>), sets up a new, private kitchen station (<code>namespaces</code>, <code>cgroups</code>, <code>network</code>), and then hands over control to the recipe&#39;s instructions to cook the meal (run the <code>Entrypoint</code>). The chef also keeps a logbook (<code>ContainerStore</code>) of all the kitchen stations currently set up, their status, and who is cooking what.</p>\n<p>This mental model clarifies the separation of concerns: <strong>images are immutable, content-addressed templates</strong>, and <strong>containers are runtime instances</strong> of those templates with added writable state, resource limits, and network connectivity. The CLI is the orchestration layer that glues these concepts together into a coherent workflow.</p>\n<h3 id=\"architecture-decision-records-oci-compatibility\">Architecture Decision Records: OCI Compatibility</h3>\n<blockquote>\n<p><strong>Decision: Implement OCI Image and Runtime Specs for Maximum Compatibility</strong></p>\n<ul>\n<li><strong>Context</strong>: Our runtime must be able to run standard container images (like those from Docker Hub) and interoperate with existing ecosystem tools. We need to choose an image format and runtime interface.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Proprietary, Simple Format</strong>: Define a custom, minimal tarball and JSON config format.</li>\n<li><strong>Docker v1 Image Format</strong>: Implement Docker&#39;s older, legacy image manifest format.</li>\n<li><strong>OCI Image &amp; Runtime Specifications</strong>: Implement the open standards defined by the Open Container Initiative.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement a subset of the <strong>OCI Image Specification (v1.0.2)</strong> and adhere to the <strong>OCI Runtime Specification</strong> for the low-level container execution.</li>\n<li><strong>Rationale</strong>: The OCI specs are industry standards, ensuring our runtime can pull and run any OCI-compliant image (including those built by Docker, Podman, and buildah). This maximizes utility and educational value by connecting to the real-world container ecosystem. While more complex than a proprietary format, the specs are well-documented and designed for interoperability.</li>\n<li><strong>Consequences</strong>: We must parse multi-layer manifests, handle content-addressable storage via layer digests, and structure our container creation process to match the OCI runtime lifecycle. This adds implementation complexity but yields a tool with real-world relevance.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Proprietary Format</strong></td>\n<td align=\"left\">Simple to implement and understand; total control.</td>\n<td align=\"left\">Cannot run existing images; not useful beyond the project.</td>\n<td align=\"left\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Docker v1 Format</strong></td>\n<td align=\"left\">Wide historical image base; well-understood.</td>\n<td align=\"left\">Legacy, deprecated format; less future-proof.</td>\n<td align=\"left\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>OCI Specifications</strong></td>\n<td align=\"left\">Industry standard; interoperable; future-proof; well-documented.</td>\n<td align=\"left\">More complex; larger spec surface area.</td>\n<td align=\"left\">✅</td>\n</tr>\n</tbody></table>\n<p>A second critical decision involves the client-registry protocol:</p>\n<blockquote>\n<p><strong>Decision: Implement Basic OCI Distribution API for Image Pull</strong></p>\n<ul>\n<li><strong>Context</strong>: To get images, we need to communicate with a registry (like Docker Hub). The protocol must support authentication, manifest fetching, and layer downloads.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Local Images Only</strong>: Only support loading images from tar files on disk.</li>\n<li><strong>Implement Docker Registry HTTP API V2</strong>: The protocol Docker uses.</li>\n<li><strong>Implement OCI Distribution Spec</strong>: The standardized protocol for distributing OCI images.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement the core of the <strong>OCI Distribution Specification</strong> (which is largely compatible with Docker Registry API v2) for pulling images.</li>\n<li><strong>Rationale</strong>: The OCI Distribution Spec is the standardized, non-proprietary way to fetch OCI images. Its overlap with Docker&#39;s API means we can pull from <code>docker.io</code> and other compliant registries. Supporting only local archives would severely limit the tool&#39;s usefulness.</li>\n<li><strong>Consequences</strong>: We must handle HTTP <code>GET</code> requests for manifests and blob (layer) downloads, parse authentication realms from <code>WWW-Authenticate</code> headers for public images (and optionally support token-based auth), and respect layer <code>Content-Type</code> headers. We will not initially support pushing (<code>PUT</code>) images.</li>\n</ul>\n</blockquote>\n<h3 id=\"common-pitfalls-in-image-handling-and-cli\">Common Pitfalls in Image Handling and CLI</h3>\n<p>⚠️ <strong>Pitfall: Assuming Manifest is a Single JSON File</strong></p>\n<ul>\n<li><strong>Description</strong>: An OCI image index or manifest is not a simple JSON file sitting alone. It&#39;s part of a <strong>content-addressable store</strong> where the digest (hash) of the manifest&#39;s content is used as its address. The <code>index.json</code> points to a platform-specific manifest, which then points to a config and layers.</li>\n<li><strong>Why it&#39;s wrong</strong>: Trying to fetch <code>index.json</code> as a static file will fail. You must use the digest (or tag) to request the manifest blob from the <code>/manifests/</code> endpoint. The registry returns the manifest&#39;s content <em>and</em> a <code>Docker-Content-Digest</code> header, which you must verify.</li>\n<li><strong>How to fix</strong>: Always treat manifests as blobs. Use the <code>Accept: application/vnd.oci.image.manifest.v1+json</code> header. After downloading, compute the SHA256 of the received content and verify it matches the digest in the response header or the one you requested.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Managing Layer Cache References</strong></p>\n<ul>\n<li><strong>Description</strong>: When multiple containers use the same base image layer, the layer should exist only once on disk. If you simply extract layers to a container-specific directory each time, you duplicate storage.</li>\n<li><strong>Why it&#39;s wrong</strong>: This defeats the primary efficiency of container images. It wastes disk space and makes container creation slower.</li>\n<li><strong>How to fix</strong>: Implement a <strong>content-addressable layer cache</strong> (using the <code>LayerCache</code> type). Store layers keyed by their digest. When setting up a container rootfs, create hard links or copy-on-write references from the cache to the container&#39;s OverlayFS lower directories. Use a reference count to know when a layer can be safely garbage-collected.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Image Configuration</strong></p>\n<ul>\n<li><strong>Description</strong>: The <code>ImageConfig</code> (a separate JSON blob referenced by the manifest) contains critical runtime information: the default <code>Entrypoint</code>, <code>Cmd</code>, <code>Env</code>, <code>WorkingDir</code>, and <code>Volumes</code>. Ignoring it and just extracting layers results in a container that may not start correctly.</li>\n<li><strong>Why it&#39;s wrong</strong>: The container&#39;s intended command and environment won&#39;t be set. The user would have to specify the full command every time, breaking compatibility with standard images.</li>\n<li><strong>How to fix</strong>: Parse the <code>ImageConfig</code> and use its fields to populate the <code>ContainerConfig</code>. The <code>Entrypoint</code> and <code>Cmd</code> from the image should be combined (following OCI rules) to form the final <code>argv</code> for the container process. The <code>Env</code> should be merged with any user-provided environment variables.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Poor CLI State Management</strong></p>\n<ul>\n<li><strong>Description</strong>: The CLI&#39;s <code>start</code>, <code>stop</code>, <code>remove</code> commands must track the container&#39;s state precisely. For example, trying to <code>start</code> an already <code>running</code> container should be an error, and <code>remove</code> should only work on <code>stopped</code> containers.</li>\n<li><strong>Why it&#39;s wrong</strong>: Without a clear state machine, you can get into inconsistent states (e.g., a &quot;removed&quot; container whose cgroups and network are still active). This leads to resource leaks and confusing user experience.</li>\n<li><strong>How to fix</strong>: Model the container lifecycle as a <strong>state machine</strong> (see diagram below). The <code>ContainerStore</code> should persist the <code>ContainerState</code>. Every state transition (<code>start</code>, <code>stop</code>, <code>remove</code>) must validate the current state, perform the transition, and update the persisted state atomically. Use file locks or a simple database to prevent concurrent modifications.</li>\n</ul>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fcontainer-lifecycle.svg\" alt=\"Container Lifecycle State Machine\"></p>\n<h3 id=\"implementation-guidance-for-image-format-and-cli\">Implementation Guidance for Image Format and CLI</h3>\n<p>This section bridges the high-level design to concrete implementation in Go. We&#39;ll structure the code into clear modules for image handling and CLI commands.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option</th>\n<th align=\"left\">Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Image Registry Client</strong></td>\n<td align=\"left\">HTTP GET with <code>net/http</code>, basic token auth</td>\n<td align=\"left\">Full OCI distribution client with auth challenges, retries, progress bars</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Manifest/Layer Storage</strong></td>\n<td align=\"left\">Filesystem in a directory tree (<code>&lt;store&gt;/blobs/sha256/&lt;digest&gt;</code>)</td>\n<td align=\"left\">Content-addressable storage with integrity verification and garbage collection</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>CLI Framework</strong></td>\n<td align=\"left\">Standard library <code>flag</code> package for parsing</td>\n<td align=\"left\"><code>cobra</code> or <code>urfave/cli</code> for structured subcommands, help generation</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State Persistence</strong></td>\n<td align=\"left\">JSON files in a directory (<code>&lt;store&gt;/containers/&lt;id&gt;/config.json</code>)</td>\n<td align=\"left\">Embedded SQLite database for atomic transactions and queries</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Image Cache</strong></td>\n<td align=\"left\">In-memory map of digest to path with file-based refcount</td>\n<td align=\"left\">Deduplicated storage with reflinks (if filesystem supports)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>The Image and CLI components integrate with the existing runtime components. Create a new <code>internal</code> directory for them.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   └── byod/                          # CLI entry point\n│       └── main.go                    # Parses flags, calls runtime\n├── internal/\n│   ├── cli/                           # CLI command implementations\n│   │   ├── commands.go                # run, start, stop, ps, rm commands\n│   │   └── utils.go                   # Table output, formatting helpers\n│   ├── image/                         # OCI image handling\n│   │   ├── image.go                   # Image, ImageConfig, ImageLayer types\n│   │   ├── store.go                   # ImageStore (local cache of images)\n│   │   ├── registry/                  # Client for remote registries\n│   │   │   ├── client.go              # RegistryClient, pull logic\n│   │   │   ├── auth.go                # Token authentication\n│   │   │   └── types.go               # Manifest, Descriptor types\n│   │   └── oci/                       # OCI spec structs (can be generated)\n│   │       ├── manifest.go            # OCI Manifest and Index structs\n│   │       └── config.go              # OCI Image Config structs\n│   └── runtime/                       # Existing components (from prev. milestones)\n│       ├── container.go               # Container, ContainerConfig, etc.\n│       ├── store.go                   # ContainerStore\n│       ├── manager.go                 # ContainerRuntime (orchestrates all managers)\n│       ├── namespace/\n│       ├── cgroup/\n│       ├── filesystem/\n│       ├── network/\n│       └── overlay/\n└── storage/                           # Default storage directory\n    ├── containers/\n    │   └── &lt;id&gt;/\n    │       ├── config.json\n    │       └── rootfs/                # OverlayFS merged directory\n    └── images/\n        ├── &lt;image-name&gt;/\n        │   └── manifest.json          # Cached manifest\n        └── blobs/\n            └── sha256/\n                ├── &lt;digest1&gt;          # Layer tar.gz\n                ├── &lt;digest2&gt;          # Config json\n                └── ...</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Here is complete, working starter code for the <strong>ImageStore</strong> (local cache) and the <strong>RegistryClient</strong>&#39;s core HTTP fetching logic. These are prerequisites that learners can copy and use directly.</p>\n<p><strong>File: <code>internal/image/store.go</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> image</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">crypto/sha256</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">encoding/hex</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">yourproject/internal/image/oci</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ImageStore manages the local cache of OCI images.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ImageStore</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbasePath </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // e.g., \"/var/lib/byod/images\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewImageStore creates a new store at the given base directory.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewImageStore</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">basePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImageStore</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(basePath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating image store directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Create blob directory structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tblobsPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(basePath, </span><span style=\"color:#9ECBFF\">\"blobs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sha256\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(blobsPath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating blobs directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ImageStore</span><span style=\"color:#E1E4E8\">{basePath: basePath}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// blobPath returns the filesystem path for a blob with the given digest.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Digest must be of the form \"sha256:abcdef...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImageStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">blobPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(digest) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> digest[:</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"sha256:\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid digest format: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, digest)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> digest[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">:]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(s.basePath, </span><span style=\"color:#9ECBFF\">\"blobs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sha256\"</span><span style=\"color:#E1E4E8\">, hash), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StoreBlob saves a blob (layer tar, config json, manifest) to the store.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It computes the SHA256 digest of the content as it's written and verifies it matches the provided digest.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the digest (sha256:...) on success.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImageStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StoreBlob</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">src</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">expectedDigest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tpath, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">blobPath</span><span style=\"color:#E1E4E8\">(expectedDigest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// If already exists, verify? For simplicity, assume it's correct.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(path); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> expectedDigest, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Write to temporary file first, then rename atomically.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttmpPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \".tmp\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttmpFile, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(tmpPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"creating temp blob file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> tmpFile.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(tmpPath)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sha256.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmultiWriter </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">MultiWriter</span><span style=\"color:#E1E4E8\">(tmpFile, hash)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">Copy</span><span style=\"color:#E1E4E8\">(multiWriter, src); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"copying blob data: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tmpFile.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcomputedDigest </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"sha256:\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> hex.</span><span style=\"color:#B392F0\">EncodeToString</span><span style=\"color:#E1E4E8\">(hash.</span><span style=\"color:#B392F0\">Sum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> computedDigest </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expectedDigest {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"digest mismatch: expected </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, expectedDigest, computedDigest)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Rename</span><span style=\"color:#E1E4E8\">(tmpPath, path); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"renaming blob to final location: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> computedDigest, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetBlob returns a ReadCloser for the blob with the given digest.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImageStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetBlob</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ReadCloser</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tpath, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">blobPath</span><span style=\"color:#E1E4E8\">(digest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetManifest reads and parses an OCI manifest for a given image reference (tag or digest).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImageStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetManifest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ref</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">oci</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manifest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// For simplicity, assume ref is a digest. In a real implementation,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// you'd resolve tags to digests via an index.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tpath, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">blobPath</span><span style=\"color:#E1E4E8\">(ref)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdata, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reading manifest blob: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tvar</span><span style=\"color:#E1E4E8\"> manifest </span><span style=\"color:#B392F0\">oci</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manifest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">manifest); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unmarshaling manifest: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">manifest, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StoreManifest saves a manifest and associates it with a tag (image reference).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImageStore</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StoreManifest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ref</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">manifest</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">oci</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manifest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdata, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(manifest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"marshaling manifest: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Store as a blob first.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdigest, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">StoreBlob</span><span style=\"color:#E1E4E8\">(bytes.</span><span style=\"color:#B392F0\">NewReader</span><span style=\"color:#E1E4E8\">(data), </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Then create a tag file pointing to the digest.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// In OCI, tags are usually managed by an index. Simplified here.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttagPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(s.basePath, </span><span style=\"color:#9ECBFF\">\"refs\"</span><span style=\"color:#E1E4E8\">, ref)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Dir</span><span style=\"color:#E1E4E8\">(tagPath), </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(tagPath, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(digest</span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>internal/image/registry/client.go</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> registry</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">net/url</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">yourproject/internal/image/oci</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegistryClient can pull images from an OCI-compliant registry.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RegistryClient</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbaseURL    </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // e.g., \"https://registry-1.docker.io\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\thttpClient </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewRegistryClient creates a client for a given registry host.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewRegistryClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">host</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RegistryClient</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RegistryClient</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tbaseURL:    </span><span style=\"color:#9ECBFF\">\"https://\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> host,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\thttpClient: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// getManifest fetches the manifest for a given image reference (e.g., \"library/alpine:latest\").</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It returns the raw manifest bytes and its digest (from Docker-Content-Digest header).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RegistryClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">getManifest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">imageRef</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tag</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// URL path: /v2/&#x3C;image>/manifests/&#x3C;tag></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tpath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/v2/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/manifests/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, imageRef, tag)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\treq, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">, c.baseURL</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">path, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Accept OCI manifest format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\treq.Header.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Accept\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/vnd.oci.image.manifest.v1+json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// For Docker Hub, also accept Docker's manifest schema.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\treq.Header.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Accept\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/vnd.docker.distribution.manifest.v2+json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tresp, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.httpClient.</span><span style=\"color:#B392F0\">Do</span><span style=\"color:#E1E4E8\">(req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"HTTP request failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> resp.Body.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> resp.StatusCode </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.StatusOK {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected status </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> for manifest\"</span><span style=\"color:#E1E4E8\">, resp.StatusCode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdata, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">ReadAll</span><span style=\"color:#E1E4E8\">(resp.Body)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdigest </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> resp.Header.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Docker-Content-Digest\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> digest </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Fallback: compute digest locally if header missing.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tdigest </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> computeSHA256Digest</span><span style=\"color:#E1E4E8\">(data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> data, digest, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PullManifest fetches and parses the manifest for an image.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RegistryClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PullManifest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">imageRef</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tag</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">oci</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manifest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdata, digest, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">getManifest</span><span style=\"color:#E1E4E8\">(imageRef, tag)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tvar</span><span style=\"color:#E1E4E8\"> manifest </span><span style=\"color:#B392F0\">oci</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manifest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">manifest); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unmarshaling manifest: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">manifest, digest, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PullLayer downloads a layer blob identified by digest and writes it to the provided writer.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RegistryClient</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PullLayer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">imageRef</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Writer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// URL path: /v2/&#x3C;image>/blobs/&#x3C;digest></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tpath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/v2/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/blobs/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, imageRef, digest)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\treq, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">, c.baseURL</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">path, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tresp, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.httpClient.</span><span style=\"color:#B392F0\">Do</span><span style=\"color:#E1E4E8\">(req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"HTTP request failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> resp.Body.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> resp.StatusCode </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.StatusOK {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected status </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> for layer </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, resp.StatusCode, digest)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t_, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">Copy</span><span style=\"color:#E1E4E8\">(w, resp.Body)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function to compute SHA256 digest.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> computeSHA256Digest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Implementation omitted for brevity; use crypto/sha256.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#9ECBFF\"> \"sha256:...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>Now, the core logic that learners should implement themselves: the <code>ContainerRuntime</code> methods that orchestrate image pull and container creation, and the CLI command handlers.</p>\n<p><strong>File: <code>internal/runtime/manager.go</code> (additions)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// PullImage downloads an image from a registry, stores it locally, and returns an Image object.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// imageRef format: [registry/]repository[:tag|@digest] (e.g., \"alpine:latest\", \"docker.io/library/nginx:alpine\")</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PullImage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">imageRef</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">image</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Image</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Parse the image reference into registry host, repository, and tag/digest.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         Default registry to \"docker.io\" and tag to \"latest\" if not specified.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create a RegistryClient for the registry host.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Call PullManifest to fetch the manifest and its digest.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Download the config blob (manifest.Config.Digest) using PullLayer and store it via ImageStore.StoreBlob.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: For each layer descriptor in manifest.Layers:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   a. Check if the layer already exists in the local ImageStore (by digest).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   b. If not, download it via PullLayer, writing to a temporary file or pipe.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   c. Store the downloaded layer blob using ImageStore.StoreBlob.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   d. Optionally, update a progress bar for the user.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Create and return an image.Image struct populated with the manifest data and local layer paths.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateContainerFromImage creates a new container from a locally stored image.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It performs all isolation setup but does not start the process.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainerFromImage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">imageName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userConfig</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Look up the image by name in the ImageStore. If not found, return error (or pull?).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Merge the image's configuration (ImageConfig) with the user's ContainerConfig.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//         Rules: user-specified Cmd overrides image's Entrypoint+Cmd; user Env extends image Env.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Generate a unique container ID (e.g., using uuid.Generate()).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Create a Container struct with the merged config, ID, and state StateCreated.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Call FilesystemManager.SetupRootfs (which internally uses OverlayManager) to prepare the container's root filesystem.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Create namespaces for the container (using NamespaceManager.CreateNamespaces). This may involve forking a child process that pauses.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Create cgroups for the container and apply resource limits (CgroupManager.CreateGroup, SetLimits).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Setup network namespace (NetworkManager.SetupNetwork) if network mode is not \"none\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: Save the container state to ContainerStore (ContainerStore.Save).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 10: Return the created Container object.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>internal/cli/commands.go</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cli</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">yourproject/internal/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RunCommand handles `byod run &#x3C;image> [command...]`</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RunCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">imageRef</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userCmd</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Check if image exists locally; if not, call runtime.PullImage to download it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create a ContainerConfig, populating Cmd with userCmd (if provided), and other defaults.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Call runtime.CreateContainerFromImage to create a container in StateCreated.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Call runtime.StartContainer to start the container process (which will transition to StateRunning).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: If the run is detached (--detach flag), print the container ID and return.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: If attached (foreground), wait for the container process to exit (by monitoring its PID).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: After the process exits, call runtime.StopContainer to transition to StateStopped.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Optionally, remove the container automatically if --rm flag is set.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartCommand handles `byod start &#x3C;container-id>`</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> StartCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Load the container from ContainerStore by ID.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Validate that the container state is StateCreated (or StateStopped if we support restart).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Call runtime.StartContainer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: If attached, wait for the process and then update state to StateStopped.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StopCommand handles `byod stop &#x3C;container-id>`</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> StopCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">force</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Load the container from ContainerStore.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Validate state is StateRunning (or StatePaused).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: If force is true, send SIGKILL to the container's init process. Otherwise, send SIGTERM, wait, then SIGKILL.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Call runtime.StopContainer to update state to StateStopped.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveCommand handles `byod rm &#x3C;container-id>`</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RemoveCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Load the container.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Validate state is StateStopped (cannot remove running containers).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Call runtime.RemoveContainer which will:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   a. Clean up network resources (NetworkManager.CleanupNetwork).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   b. Remove cgroups (CgroupManager.RemoveCgroup).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   c. Unmount and clean up the root filesystem (FilesystemManager.CleanupFilesystem).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   d. Delete the container from ContainerStore.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: If successful, print confirmation.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Go&#39;s <code>net/http</code> for Registry Client</strong>: Use <code>http.Client</code> with a custom <code>Transport</code> if you need to add authentication headers globally. Remember to close response bodies (<code>defer resp.Body.Close()</code>). For downloading large layers, consider using <code>io.Copy</code> with a buffer to provide progress updates.</p>\n</li>\n<li><p><strong>JSON Parsing</strong>: Use <code>encoding/json</code> with struct tags that match the OCI spec field names. You can generate Go structs from the OCI JSON schema using tools like <code>quicktype</code>. For flexibility with unknown fields, use <code>json.RawMessage</code> for parts you don&#39;t need to parse immediately.</p>\n</li>\n<li><p><strong>Concurrent Layer Downloads</strong>: To speed up image pull, you can download multiple layers concurrently using goroutines and a <code>sync.WaitGroup</code>. Be mindful of registry rate limits. Use a semaphore pattern (buffered channel) to limit concurrency.</p>\n</li>\n<li><p><strong>CLI Flag Parsing</strong>: The standard <code>flag</code> package supports subcommands via <code>flag.NewFlagSet</code>. For a more structured CLI, consider using <code>cobra</code>. Remember to define persistent flags (like <code>--storage-path</code>) and local flags for each command.</p>\n</li>\n<li><p><strong>State Machine Implementation</strong>: Implement the container state transitions as methods on <code>Container</code> or <code>ContainerRuntime</code>. Use a <code>sync.Mutex</code> to protect state changes if the CLI could be called concurrently (e.g., from multiple terminals). The state should be persisted after each transition.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Use Go&#39;s error wrapping with <code>fmt.Errorf(&quot;... %w&quot;, err)</code>. Provide meaningful error messages to the user (e.g., &quot;image &#39;foo:latest&#39; not found locally and pulling from registry failed: connection refused&quot;).</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing Milestone 6, you should be able to perform the following workflow:</p>\n<ol>\n<li><p><strong>Pull an image</strong>: <code>sudo ./byod pull alpine:latest</code></p>\n<ul>\n<li><strong>Expected</strong>: Output showing layer download progress (e.g., &quot;Layer sha256:abc... downloaded&quot;). The image should be stored in the configured storage directory (e.g., <code>/var/lib/byod/images</code>).</li>\n<li><strong>Verification</strong>: Check <code>ls -la /var/lib/byod/images/blobs/sha256/</code> to see downloaded layer files.</li>\n</ul>\n</li>\n<li><p><strong>Run a container</strong>: <code>sudo ./byod run alpine:latest echo &quot;hello world&quot;</code></p>\n<ul>\n<li><strong>Expected</strong>: The command outputs &quot;hello world&quot; and exits. The container should be created, started, execute the command, stop, and (if <code>--rm</code> is used) be removed.</li>\n<li><strong>Verification</strong>: Use <code>./byod ps -a</code> to see the container (if not removed) in <code>Stopped</code> state.</li>\n</ul>\n</li>\n<li><p><strong>Run a detached container</strong>: <code>sudo ./byod run -d --name myapp nginx:alpine</code></p>\n<ul>\n<li><strong>Expected</strong>: Prints a container ID. The container stays running in the background.</li>\n<li><strong>Verification</strong>: <code>./byod ps</code> shows the container in <code>Running</code> state. <code>curl http://&lt;container-ip&gt;</code> should return the nginx welcome page (if networking is set up).</li>\n</ul>\n</li>\n<li><p><strong>Container lifecycle</strong>: <code>sudo ./byod stop myapp</code>, then <code>sudo ./byod rm myapp</code></p>\n<ul>\n<li><strong>Expected</strong>: <code>stop</code> terminates the container, <code>rm</code> removes it.</li>\n<li><strong>Verification</strong>: <code>./byod ps -a</code> no longer lists the container. Check that the container&#39;s rootfs directory and cgroup are cleaned up.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li><strong>&quot;manifest unknown&quot; error</strong>: Likely an incorrect image reference format or registry authentication issue. Verify the image exists on Docker Hub.</li>\n<li><strong>Container exits immediately with code 127</strong>: The <code>Entrypoint</code> or <code>Cmd</code> binary not found in the image. Check that the image config was parsed correctly and the rootfs was set up properly.</li>\n<li><strong>Resource leaks (cgroups, mounts) after <code>rm</code></strong>: The <code>RemoveContainer</code> method is not cleaning up all resources. Add logging to each cleanup step and verify they are called.</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">How to Diagnose</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Pull fails with &quot;unauthorized&quot;</strong></td>\n<td align=\"left\">Registry requires authentication, even for public images.</td>\n<td align=\"left\">Check the <code>WWW-Authenticate</code> header in the HTTP response.</td>\n<td align=\"left\">Implement token authentication: request a token from the auth service URL, then retry the request with <code>Authorization: Bearer &lt;token&gt;</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Container runs but cannot resolve DNS</strong></td>\n<td align=\"left\"><code>/etc/resolv.conf</code> is not set up inside the container.</td>\n<td align=\"left\"><code>cat</code> the container&#39;s rootfs <code>/etc/resolv.conf</code>; it may be empty or missing.</td>\n<td align=\"left\">Copy the host&#39;s <code>/etc/resolv.conf</code> into the container rootfs during filesystem setup, or bind-mount it.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>byod ps</code> shows empty list</strong></td>\n<td align=\"left\">Container state is not being persisted to disk.</td>\n<td align=\"left\">Check the storage directory for container config JSON files.</td>\n<td align=\"left\">Ensure <code>ContainerStore.Save</code> is called after creating/updating a container, and that it writes valid JSON.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Image layers are re-downloaded every time</strong></td>\n<td align=\"left\">Layer cache is not being checked or used.</td>\n<td align=\"left\">Check if <code>ImageStore.StoreBlob</code> is skipping already-existing blobs.</td>\n<td align=\"left\">Implement a layer cache with reference counting. Before downloading, check if the blob file exists and matches the digest.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>CLI command hangs after container start</strong></td>\n<td align=\"left\">The parent process is waiting for the child but the child might have died.</td>\n<td align=\"left\">Check the container&#39;s init process status with <code>ps aux | grep &lt;container-pid&gt;</code>.</td>\n<td align=\"left\">Ensure the child process is correctly reparented to PID 1 after the parent exits. Use double-fork or proper signal handling.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (this section describes the dynamic interactions between components across the entire system)</p>\n</blockquote>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<p>This section describes the dynamic orchestration between the architectural components defined in previous sections. While component design explains <em>what</em> each part does, interactions and data flow explain <em>how</em> and <em>when</em> they work together to achieve container lifecycle operations. Understanding these sequences is critical for implementing a cohesive runtime where isolation primitives are applied in the correct order with proper cleanup on failure.</p>\n<h3 id=\"container-creation-sequence\">Container Creation Sequence</h3>\n<p>The container creation sequence transforms a user&#39;s request (<code>container run</code>) into an isolated, resource-limited process with its own filesystem and network. Think of this as a <strong>restaurant kitchen preparing a complex dish</strong>: the chef (Container Manager) coordinates specialized stations (Namespace, Cgroup, Filesystem managers) in a precise sequence, where timing matters (network must be set up before the process starts, cgroups must be applied before the process forks). If any station fails, the entire order must be rolled back cleanly.</p>\n<p>The complete sequence involves 8 major phases, with error handling and rollback at each step:</p>\n<ol>\n<li><p><strong>Request Validation and Preparation</strong> (CLI → Container Manager)</p>\n<ul>\n<li>The CLI parses user command (image name, command, flags) into a <code>ContainerConfig</code></li>\n<li>Container Manager validates the configuration (e.g., image exists locally, resource limits are sane)</li>\n<li>A unique <code>containerID</code> is generated (via <code>uuid.Generate()</code>)</li>\n<li>Container entry is created in <code>ContainerStore</code> with state <code>StateCreated</code></li>\n</ul>\n</li>\n<li><p><strong>Image Preparation</strong> (Container Manager → Image Store → Filesystem Manager)</p>\n<ul>\n<li>If the specified image isn&#39;t locally available, trigger the image pull flow (described separately)</li>\n<li><code>ImageStore</code> loads the <code>Image</code> object with its layers and configuration</li>\n<li><code>FilesystemManager.SetupRootfs()</code> is called with the image and containerID<ul>\n<li>This delegates to <code>OverlayManager</code> to create layered rootfs (Milestone 4)</li>\n<li>Returns path to the prepared root filesystem</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Namespace Creation</strong> (Container Manager → Namespace Manager)</p>\n<ul>\n<li><code>NamespaceManager.CreateNamespaces()</code> is called with flags for <code>CLONE_NEWPID|CLONE_NEWUTS|CLONE_NEWNS|CLONE_NEWNET|CLONE_NEWIPC</code></li>\n<li>The manager creates a new child process via <code>clone()</code> or <code>unshare()</code> with these namespace flags</li>\n<li>This child will eventually become the container&#39;s PID 1</li>\n<li>The function returns the host PID of this child process (still in a suspended state)</li>\n</ul>\n</li>\n<li><p><strong>Cgroup Configuration</strong> (Container Manager → Cgroup Manager)</p>\n<ul>\n<li><code>CgroupManager.CreateGroup(containerID)</code> creates the cgroup hierarchy</li>\n<li><code>CgroupManager.SetLimits(containerID, config.Limits)</code> writes memory, CPU, and PID limits to control files</li>\n<li><code>CgroupManager.AddProcess(containerID, pid)</code> moves the child process (from step 3) into the cgroup</li>\n<li>This ensures resource limits are enforced from the moment the child process starts executing</li>\n</ul>\n</li>\n<li><p><strong>Network Namespace Setup</strong> (Container Manager → Network Manager)</p>\n<ul>\n<li><code>NetworkManager.SetupNetwork()</code> is called with the path to the container&#39;s network namespace (<code>/proc/&lt;pid&gt;/ns/net</code>)</li>\n<li>Network Manager creates veth pair, attaches one end to bridge, configures IP addresses, sets up iptables rules</li>\n<li>This happens <em>outside</em> the container namespace but affects the namespace by moving interfaces into it</li>\n<li>Port forwarding rules are established if specified in <code>NetworkConfig</code></li>\n</ul>\n</li>\n<li><p><strong>Filesystem Isolation Finalization</strong> (Container Manager → Filesystem Manager, inside the child process)</p>\n<ul>\n<li>The child process (still suspended) executes <code>ChildEntryPoint()</code> which calls:<ul>\n<li><code>FilesystemManager.IsolateFilesystem(rootfsPath)</code> to perform <code>pivot_root()</code> and mount <code>/proc</code>, <code>/sys</code></li>\n<li><code>syscall.Sethostname(config.Hostname)</code> to set UTS namespace hostname</li>\n<li>Environment variable setup and working directory change</li>\n</ul>\n</li>\n<li>This happens <em>inside</em> the container&#39;s namespaces, so mount operations only affect the container</li>\n</ul>\n</li>\n<li><p><strong>Process Execution</strong> (Inside the child process)</p>\n<ul>\n<li>The child process performs <code>exec()</code> to replace itself with the container&#39;s entry point command</li>\n<li>Command is taken from <code>ImageConfig.Entrypoint</code> and <code>ImageConfig.Cmd</code>, overridden by user&#39;s <code>config.Cmd</code></li>\n<li>The process becomes PID 1 in the container&#39;s PID namespace</li>\n</ul>\n</li>\n<li><p><strong>State Transition and Monitoring</strong> (Container Manager)</p>\n<ul>\n<li>Container state transitions from <code>StateCreated</code> to <code>StateRunning</code></li>\n<li><code>ContainerStore.Save()</code> persists the updated state</li>\n<li>Container Manager begins monitoring the container process (via <code>waitpid()</code> or cgroup notifications)</li>\n<li>On process exit, state transitions to <code>StateStopped</code> and cleanup is scheduled</li>\n</ul>\n</li>\n</ol>\n<p>The following table details the key interactions between components during container creation:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Triggering Component</th>\n<th>Target Component</th>\n<th>Data Passed</th>\n<th>Expected Outcome</th>\n<th>Error Rollback</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. Validation</td>\n<td>CLI</td>\n<td>Container Manager</td>\n<td><code>ContainerConfig</code></td>\n<td>Validated config, generated containerID</td>\n<td>Return error to user</td>\n</tr>\n<tr>\n<td>2. Image Prep</td>\n<td>Container Manager</td>\n<td>Filesystem Manager</td>\n<td><code>Image</code>, containerID</td>\n<td>Prepared rootfs path</td>\n<td>Cleanup any extracted layers</td>\n</tr>\n<tr>\n<td>3. Namespace</td>\n<td>Container Manager</td>\n<td>Namespace Manager</td>\n<td>namespace flags</td>\n<td>Child process PID</td>\n<td>Kill child process if created</td>\n</tr>\n<tr>\n<td>4. Cgroup</td>\n<td>Container Manager</td>\n<td>Cgroup Manager</td>\n<td>containerID, <code>ResourceLimits</code></td>\n<td>Process in cgroup with limits</td>\n<td>Remove cgroup hierarchy</td>\n</tr>\n<tr>\n<td>5. Network</td>\n<td>Container Manager</td>\n<td>Network Manager</td>\n<td>nsPath, <code>NetworkConfig</code></td>\n<td>Network namespace configured</td>\n<td>Remove veth, iptables rules, release IP</td>\n</tr>\n<tr>\n<td>6. Filesystem</td>\n<td>Container Manager</td>\n<td>Filesystem Manager</td>\n<td>rootfsPath (inside child)</td>\n<td><code>pivot_root()</code> completed, mounts setup</td>\n<td>Cannot rollback child - it exits with error</td>\n</tr>\n<tr>\n<td>7. Execution</td>\n<td>Child process</td>\n<td>OS kernel</td>\n<td>command, args, env</td>\n<td>Container process running</td>\n<td>Child exits with error code</td>\n</tr>\n<tr>\n<td>8. Monitoring</td>\n<td>Container Manager</td>\n<td>Container Store</td>\n<td>updated <code>Container</code> state</td>\n<td>State saved as <code>StateRunning</code></td>\n<td>Revert to previous state</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The sequence must preserve the <strong>principle of least privilege escalation</strong> - once the child process enters the container&#39;s namespaces and drops privileges (if user namespaces are implemented), it should not perform operations requiring host root privileges. That&#39;s why network setup and cgroup configuration happen <em>outside</em> the container namespace before the child starts.</p>\n</blockquote>\n<p>The state transitions during this sequence follow a strict state machine:</p>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fcontainer-lifecycle.svg\" alt=\"Container Lifecycle State Machine\"></p>\n<p>For a visual representation of the component interactions, refer to the sequence diagram:</p>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fcontainer-creation-sequence.svg\" alt=\"Container Creation Sequence Diagram\"></p>\n<p><strong>Critical Error Handling Considerations:</strong></p>\n<ul>\n<li><strong>Rollback must be comprehensive:</strong> If network setup fails after cgroups are created, both must be cleaned up</li>\n<li><strong>Orphan prevention:</strong> If the Container Manager crashes mid-creation, restart should detect and clean up partially created resources (via containerID scanning)</li>\n<li><strong>Atomic state transitions:</strong> The <code>ContainerStore.Save()</code> operation should be atomic; partial writes could leave the container in an undefined state</li>\n</ul>\n<h3 id=\"image-pull-and-preparation-flow\">Image Pull and Preparation Flow</h3>\n<p>Image preparation is the process of transforming a named image reference (e.g., <code>ubuntu:latest</code>) into a ready-to-use root filesystem. Think of this as a <strong>warehouse fulfillment system</strong>: the clerk (Image Handler) receives an order, checks local inventory (layer cache), requests missing items from suppliers (registry), verifies shipments (digest validation), and assembles the complete package (layered rootfs) for the kitchen (container creation).</p>\n<p>The flow involves both remote registry interaction and local filesystem operations:</p>\n<ol>\n<li><p><strong>Reference Parsing</strong> (CLI → Registry Client)</p>\n<ul>\n<li>Parse <code>imageRef</code> (e.g., <code>docker.io/library/ubuntu:latest</code>) into registry URL, repository, and tag</li>\n<li>Default to <code>latest</code> tag if not specified</li>\n<li>Check local <code>ImageStore</code> for existing image with same digest</li>\n</ul>\n</li>\n<li><p><strong>Manifest Fetching</strong> (Registry Client → OCI Registry)</p>\n<ul>\n<li><code>RegistryClient.PullManifest()</code> makes HTTP request to registry API</li>\n<li>For Docker Hub: <code>GET /v2/library/ubuntu/manifests/latest</code></li>\n<li>Registry returns OCI manifest (JSON) with media type and layer digests</li>\n<li>Client verifies manifest structure and extracts layer descriptors</li>\n</ul>\n</li>\n<li><p><strong>Layer Download and Verification</strong> (Registry Client → Image Store, per layer)</p>\n<ul>\n<li>For each layer descriptor in the manifest:<ul>\n<li>Check <code>LayerCache.IsLayerCached(digest)</code> - if present, skip download</li>\n<li><code>RegistryClient.PullLayer()</code> downloads layer blob with progress reporting</li>\n<li><code>ImageStore.StoreBlob()</code> saves with content-addressable naming (digest as filename)</li>\n<li>SHA256 verification ensures downloaded content matches digest</li>\n<li>Layer is marked as cached in <code>LayerCache.AddReference(digest)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Image Configuration</strong> (Registry Client → Image Store)</p>\n<ul>\n<li>Download image configuration blob (referenced in manifest)</li>\n<li>Parse into <code>ImageConfig</code> (entrypoint, env, working directory, etc.)</li>\n<li>Create and store complete <code>Image</code> object with references to all layers</li>\n</ul>\n</li>\n<li><p><strong>Root Filesystem Preparation</strong> (Container Manager → Filesystem Manager, on demand)</p>\n<ul>\n<li>When container creation requires the image, <code>FilesystemManager.SetupRootfs()</code> is called</li>\n<li><code>OverlayManager.PrepareLayersForContainer()</code> assembles layers:<ul>\n<li>Lower directories: all read-only layers in order (base → top)</li>\n<li>Upper directory: writable layer for this container</li>\n<li>Work directory: internal OverlayFS work area</li>\n</ul>\n</li>\n<li><code>OverlayManager.MountOverlay()</code> creates the merged view</li>\n<li>Returns path to merged directory ready for <code>pivot_root()</code></li>\n</ul>\n</li>\n</ol>\n<p>The decision flow for image handling can be visualized:</p>\n<p><img src=\"/api/project/build-docker/architecture-doc/asset?path=diagrams%2Fimage-pull-flowchart.svg\" alt=\"Image Pull and Extraction Flowchart\"></p>\n<p>The following table details the data transformations at each stage:</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input</th>\n<th>Processing</th>\n<th>Output</th>\n<th>Storage Location</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Reference Parsing</td>\n<td><code>&quot;ubuntu:latest&quot;</code></td>\n<td>Parse registry, repo, tag</td>\n<td><code>{Registry: &quot;docker.io&quot;, Repository: &quot;library/ubuntu&quot;, Tag: &quot;latest&quot;}</code></td>\n<td>In-memory struct</td>\n</tr>\n<tr>\n<td>Manifest Fetch</td>\n<td>Repository, tag</td>\n<td>HTTP GET to registry, parse JSON</td>\n<td><code>Manifest</code> with layer digests, config digest</td>\n<td><code>ImageStore</code> as blob (digest)</td>\n</tr>\n<tr>\n<td>Layer Download</td>\n<td>Layer digest</td>\n<td>HTTP GET blob, SHA256 verify</td>\n<td>Compressed tar blob</td>\n<td><code>ImageStore/base/blobs/sha256/&lt;digest&gt;</code></td>\n</tr>\n<tr>\n<td>Image Assembly</td>\n<td>Manifest, all layers</td>\n<td>Create <code>Image</code> with layer paths, config</td>\n<td>Complete <code>Image</code> object</td>\n<td><code>ImageStore/index/&lt;name&gt;/image.json</code></td>\n</tr>\n<tr>\n<td>Rootfs Prep</td>\n<td><code>Image</code>, containerID</td>\n<td>OverlayFS mount with layers</td>\n<td>Merged directory path</td>\n<td><code>OverlayManager</code> temporary mount</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight:</strong> Image layers are <strong>content-addressable</strong> and <strong>immutable</strong>. The same layer digest (SHA256 of its content) will always produce identical files. This enables global deduplication: if two images share a base layer (e.g., <code>alpine</code> base), it&#39;s stored once and referenced by both images, significantly saving disk space.</p>\n</blockquote>\n<p><strong>Common Failure Modes and Recovery:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network timeout during layer pull</td>\n<td>HTTP client timeout</td>\n<td>Retry with exponential backoff (max 3 attempts)</td>\n</tr>\n<tr>\n<td>Digest mismatch</td>\n<td>SHA256 comparison fails</td>\n<td>Delete corrupted blob, retry download</td>\n</tr>\n<tr>\n<td>Disk full during extraction</td>\n<td><code>io.ErrShortWrite</code> or <code>ENOSPC</code></td>\n<td>Clean up partial extraction, return error</td>\n</tr>\n<tr>\n<td>Registry authentication required</td>\n<td>HTTP 401 Unauthorized</td>\n<td>Prompt for credentials or use configured auth</td>\n</tr>\n<tr>\n<td>Manifest not found</td>\n<td>HTTP 404</td>\n<td>Check tag exists, suggest alternative tags</td>\n</tr>\n</tbody></table>\n<p><strong>Optimization: Layer Caching Strategy</strong></p>\n<ul>\n<li><strong>Reference counting:</strong> <code>LayerCache</code> tracks how many images/containers use each layer</li>\n<li><strong>LRU eviction:</strong> When cache exceeds size limit, remove least recently used layers with zero references</li>\n<li><strong>Shared layers:</strong> Multiple containers from same image share the same read-only lower layers, with separate upper writable layers</li>\n<li><strong>Concurrent pulls:</strong> Download different layers in parallel, but serialize writes to same layer</li>\n</ul>\n<h3 id=\"message-and-configuration-formats\">Message and Configuration Formats</h3>\n<p>The container runtime uses three primary formats for communication: 1) <strong>Internal Go structs</strong> for component interaction, 2) <strong>Persistent JSON files</strong> for state and configuration storage, and 3) <strong>External protocols</strong> (OCI registry API) for image distribution. Understanding these formats is essential for implementing serialization, deserialization, and interoperability.</p>\n<h4 id=\"internal-component-communication\">Internal Component Communication</h4>\n<p>Components communicate through method calls with the structured types defined in the Data Model section. The following table summarizes key method signatures and their data flows:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Calling Component</th>\n<th>Target Component</th>\n<th>Input Data</th>\n<th>Output Data</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateContainer(config)</code></td>\n<td>CLI/User</td>\n<td>Container Manager</td>\n<td><code>ContainerConfig</code></td>\n<td><code>Container</code></td>\n<td>Initiate container creation</td>\n</tr>\n<tr>\n<td><code>SetupRootfs(image, id)</code></td>\n<td>Container Manager</td>\n<td>Filesystem Manager</td>\n<td><code>Image</code>, containerID</td>\n<td>rootfs path (string)</td>\n<td>Prepare container filesystem</td>\n</tr>\n<tr>\n<td><code>CreateNamespaces(flags)</code></td>\n<td>Container Manager</td>\n<td>Namespace Manager</td>\n<td>namespace flags (int)</td>\n<td>child PID (int)</td>\n<td>Create isolated namespaces</td>\n</tr>\n<tr>\n<td><code>SetupNetwork(nsPath, config)</code></td>\n<td>Container Manager</td>\n<td>Network Manager</td>\n<td>nsPath (string), <code>NetworkConfig</code></td>\n<td>error</td>\n<td>Configure container networking</td>\n</tr>\n<tr>\n<td><code>SetLimits(path, limits)</code></td>\n<td>Container Manager</td>\n<td>Cgroup Manager</td>\n<td>cgroup path (string), <code>ResourceLimits</code></td>\n<td>error</td>\n<td>Apply resource constraints</td>\n</tr>\n<tr>\n<td><code>PullManifest(imageRef, tag)</code></td>\n<td>Image Handler</td>\n<td>Registry Client</td>\n<td>image reference, tag</td>\n<td><code>Manifest</code>, digest</td>\n<td>Fetch image metadata</td>\n</tr>\n<tr>\n<td><code>StoreBlob(reader, digest)</code></td>\n<td>Registry Client</td>\n<td>Image Store</td>\n<td>io.Reader, expected digest</td>\n<td>actual digest</td>\n<td>Store and verify layer blob</td>\n</tr>\n</tbody></table>\n<p><strong>Method Invocation Patterns:</strong></p>\n<ul>\n<li><strong>Synchronous blocking:</strong> Most methods block until completion (network setup, filesystem mount)</li>\n<li><strong>Error propagation:</strong> All methods return <code>error</code>; callers must handle failures appropriately</li>\n<li><strong>Context passing:</strong> Some long operations (image pull) accept <code>context.Context</code> for cancellation</li>\n</ul>\n<h4 id=\"persistent-storage-formats\">Persistent Storage Formats</h4>\n<p>The runtime persists state in JSON files within the <code>CONTAINER_RUNTIME_ROOT</code> directory (typically <code>/var/lib/byd</code>). These files survive process restarts and enable recovery.</p>\n<p><strong>1. Container State File (<code>/containers/&lt;id&gt;/state.json</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"ID\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"a1b2c3d4e5f6\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"Name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"my-ubuntu\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"State\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"running\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"Config\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"Image\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ubuntu:latest\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"Cmd\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"/bin/bash\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"Env\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"PATH=/usr/bin\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"WorkingDir\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"Hostname\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"mycontainer\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"Limits\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"MemoryMB\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"CPUShares\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"PidsLimit\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"Network\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"Mode\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"bridge\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"BridgeName\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"byd0\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"IPAddress\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"10.0.0.2\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"PortMappings\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#79B8FF\">\"HostPort\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">8080</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"ContainerPort\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"Protocol\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"tcp\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"Pid\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">12345</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"CreatedAt\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2023-10-01T12:00:00Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>2. Image Manifest File (<code>/images/&lt;repo&gt;/&lt;tag&gt;/manifest.json</code>):</strong>\nThis follows the OCI Image Manifest Specification v1.0.2:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>schemaVersion</code></td>\n<td>int</td>\n<td>OCI spec version</td>\n<td><code>2</code></td>\n</tr>\n<tr>\n<td><code>mediaType</code></td>\n<td>string</td>\n<td>MIME type of manifest</td>\n<td><code>application/vnd.oci.image.manifest.v1+json</code></td>\n</tr>\n<tr>\n<td><code>config</code></td>\n<td>object</td>\n<td>Descriptor for image config</td>\n<td><code>{&quot;mediaType&quot;: &quot;...&quot;, &quot;digest&quot;: &quot;sha256:...&quot;, &quot;size&quot;: 1234}</code></td>\n</tr>\n<tr>\n<td><code>layers</code></td>\n<td>array</td>\n<td>Array of layer descriptors</td>\n<td><code>[{&quot;mediaType&quot;: &quot;...&quot;, &quot;digest&quot;: &quot;...&quot;, &quot;size&quot;: ...}]</code></td>\n</tr>\n<tr>\n<td><code>annotations</code></td>\n<td>object</td>\n<td>Optional metadata</td>\n<td><code>{&quot;org.opencontainers.image.created&quot;: &quot;2023-10-01&quot;}</code></td>\n</tr>\n</tbody></table>\n<p><strong>3. Image Configuration (<code>/blobs/sha256/&lt;digest&gt;</code>):</strong>\nThis is the OCI Image Configuration JSON, parsed into our <code>ImageConfig</code> struct:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n<th>Maps to <code>ImageConfig</code> Field</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>architecture</code></td>\n<td>string</td>\n<td>Target CPU architecture</td>\n<td>(Not directly used)</td>\n</tr>\n<tr>\n<td><code>os</code></td>\n<td>string</td>\n<td>Target OS</td>\n<td>(Not directly used)</td>\n</tr>\n<tr>\n<td><code>config.Entrypoint</code></td>\n<td>array</td>\n<td>Default executable</td>\n<td><code>Entrypoint</code></td>\n</tr>\n<tr>\n<td><code>config.Cmd</code></td>\n<td>array</td>\n<td>Default arguments</td>\n<td><code>Cmd</code></td>\n</tr>\n<tr>\n<td><code>config.Env</code></td>\n<td>array</td>\n<td>Environment variables</td>\n<td><code>Env</code></td>\n</tr>\n<tr>\n<td><code>config.WorkingDir</code></td>\n<td>string</td>\n<td>Working directory</td>\n<td><code>WorkingDir</code></td>\n</tr>\n<tr>\n<td><code>rootfs.diff_ids</code></td>\n<td>array</td>\n<td>Layer digests (uncompressed)</td>\n<td>Used for layer verification</td>\n</tr>\n</tbody></table>\n<h4 id=\"external-protocol-oci-registry-api\">External Protocol: OCI Registry API</h4>\n<p>The runtime communicates with OCI/Docker registries using the Distribution Specification API:</p>\n<p><strong>Registry Endpoints:</strong></p>\n<ul>\n<li><code>GET /v2/</code> - Registry version check</li>\n<li><code>GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;</code> - Fetch manifest (reference can be tag or digest)</li>\n<li><code>GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;</code> - Fetch layer/blob content</li>\n<li><code>HEAD /v2/&lt;name&gt;/blobs/&lt;digest&gt;</code> - Check if blob exists (layer cache validation)</li>\n</ul>\n<p><strong>HTTP Headers for Content Negotiation:</strong></p>\n<ul>\n<li><code>Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json</code></li>\n<li><code>Authorization: Bearer &lt;token&gt;</code> (for authenticated registries)</li>\n<li><code>Docker-Content-Digest: sha256:...</code> (in responses, for verification)</li>\n</ul>\n<p><strong>Authentication Flow:</strong></p>\n<ol>\n<li>Initial request often returns <code>401 Unauthorized</code> with <code>WWW-Authenticate</code> header</li>\n<li>Parse header for realm, service, scope</li>\n<li>Request bearer token from authentication server</li>\n<li>Retry original request with <code>Authorization: Bearer &lt;token&gt;</code></li>\n</ol>\n<p><strong>Message Flow Example (Pull Manifest):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Client → GET /v2/library/ubuntu/manifests/latest\nRegistry → 200 OK\n            Content-Type: application/vnd.oci.image.manifest.v1+json\n            Docker-Content-Digest: sha256:abc123...\n            \n            {\n              &quot;schemaVersion&quot;: 2,\n              &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;,\n              &quot;config&quot;: {&quot;digest&quot;: &quot;sha256:def456...&quot;, &quot;size&quot;: 1234},\n              &quot;layers&quot;: [\n                {&quot;digest&quot;: &quot;sha256:layer1...&quot;, &quot;size&quot;: 567890}\n              ]\n            }</code></pre></div>\n\n<h4 id=\"configuration-inheritance-and-overrides\">Configuration Inheritance and Overrides</h4>\n<p>The runtime merges configuration from multiple sources with clear precedence:</p>\n<ol>\n<li><strong>Base Image Configuration</strong> (<code>ImageConfig</code> from OCI image) - Lowest priority</li>\n<li><strong>Container Defaults</strong> (runtime defaults for security, resources) - Medium priority  </li>\n<li><strong>User Configuration</strong> (<code>ContainerConfig</code> from CLI/flags) - Highest priority</li>\n<li><strong>Runtime Enforcement</strong> (security hardening, required mounts) - Overrides all</li>\n</ol>\n<p>Example merge for command execution:</p>\n<ul>\n<li>Image defines: <code>Entrypoint: [&quot;/bin/sh&quot;]</code>, <code>Cmd: [&quot;-c&quot;, &quot;echo hello&quot;]</code></li>\n<li>User provides: <code>Cmd: [&quot;/bin/bash&quot;]</code></li>\n<li>Result: <code>[&quot;/bin/sh&quot;, &quot;/bin/bash&quot;]</code> (Docker behavior: user <code>Cmd</code> replaces image <code>Cmd</code>, not <code>Entrypoint</code>)</li>\n</ul>\n<p>The configuration resolution is implemented in <code>ContainerRuntime.CreateContainerFromImage()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Pseudo-code for configuration merging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> mergeConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">imageConfig</span><span style=\"color:#B392F0\"> ImageConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userConfig</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Command: user Cmd overrides image Cmd, but Entrypoint from image unless user specifies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(userConfig.Cmd) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.Cmd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> userConfig.Cmd</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Keep image Entrypoint unless user provided both</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.Cmd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> imageConfig.Cmd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Environment: merge with user values overriding image values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result.Env </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mergeEnv</span><span style=\"color:#E1E4E8\">(imageConfig.Env, userConfig.Env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Working directory: user overrides image</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> userConfig.WorkingDir </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.WorkingDir </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> userConfig.WorkingDir</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.WorkingDir </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> imageConfig.WorkingDir</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"inter-process-communication\">Inter-Process Communication</h4>\n<p>For the parent-child coordination during container creation, the runtime uses:</p>\n<ol>\n<li><strong><code>/proc/self/exe</code> re-execution:</strong> The parent re-executes itself with a <code>--child</code> flag and the containerID</li>\n<li><strong>Environment variables:</strong> Parent passes configuration via <code>BYD_CONTAINER_ID</code>, <code>BYD_ROOTFS_PATH</code></li>\n<li><strong>File descriptors:</strong> Network namespace path, cgroup directories can be passed via inherited FDs</li>\n<li><strong>Signals:</strong> Parent monitors child via <code>SIGCHLD</code>, sends <code>SIGTERM</code>/<code>SIGKILL</code> for stop operations</li>\n</ol>\n<p>This IPC approach avoids complex serialization and maintains simplicity while crossing privilege boundaries.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Communication</td>\n<td>Direct method calls (in-process)</td>\n<td>gRPC with Protocol Buffers (for daemon mode)</td>\n</tr>\n<tr>\n<td>Persistent Storage</td>\n<td>JSON files with <code>encoding/json</code></td>\n<td>SQLite database with migrations</td>\n</tr>\n<tr>\n<td>Registry Protocol</td>\n<td>HTTP/1.1 with net/http</td>\n<td>HTTP/2 with connection pooling, parallel downloads</td>\n</tr>\n<tr>\n<td>Configuration Merging</td>\n<td>Manual field-by-field merging</td>\n<td>JSON Merge Patch (RFC 7396) or strategic merge</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>byd/                           # Project root\n├── cmd/\n│   └── byd/                   # CLI entry point\n│       └── main.go\n├── internal/\n│   ├── runtime/               # Container Manager component\n│   │   ├── runtime.go         # ContainerRuntime type and main logic\n│   │   ├── state_manager.go   # Container state transitions\n│   │   └── sequence.go        # Container creation sequence (this section)\n│   ├── store/                 # Persistent storage\n│   │   ├── container_store.go # ContainerStore implementation\n│   │   ├── image_store.go     # ImageStore implementation\n│   │   └── layer_cache.go     # LayerCache implementation\n│   ├── images/                # Image handling (Milestone 6)\n│   │   ├── registry.go        # RegistryClient\n│   │   ├── oci_parser.go      # OCI manifest/config parsing\n│   │   └── pull_sequence.go   # Image pull flow\n│   └── utils/\n│       └── uuid.go            # ID generation helpers\n└── pkg/                       # Public API (if needed)\n    └── types/\n        └── types.go           # All data model structs</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<p><strong>Complete UUID Generator (<code>pkg/utils/uuid.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> utils</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">encoding/hex</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu        </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tshortID   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tshortOnce </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Once</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Generate creates a random 128-bit hex ID (32 characters)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Generate</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tbytes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rand.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(bytes); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"generate uuid: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> hex.</span><span style=\"color:#B392F0\">EncodeToString</span><span style=\"color:#E1E4E8\">(bytes), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Short generates a random 64-bit hex ID (16 characters) with caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Short</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tshortOnce.</span><span style=\"color:#B392F0\">Do</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tbytes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rand.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(bytes); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t\t// Fallback to timestamp-based ID if crypto fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tshortID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tshortID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hex.</span><span style=\"color:#B392F0\">EncodeToString</span><span style=\"color:#E1E4E8\">(bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t})</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> shortID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Container State Manager (<code>internal/runtime/state_manager.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">byd/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StateManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstore      </span><span style=\"color:#B392F0\">ContainerStore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewStateManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstore, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewContainerStore</span><span style=\"color:#E1E4E8\">(storePath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"create state manager: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Load existing containers from disk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Implementation: scan store directory, load each container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tcontainers: containers,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tstore:      store,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Transition validates and executes state changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Transition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\t\tfromState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">toState</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> sm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainer, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.containers[containerID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"container </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> container.State </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> fromState {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid state transition: current </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, expected </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tcontainer.State, fromState)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Validate transition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isValidTransition</span><span style=\"color:#E1E4E8\">(fromState, toState) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid transition from </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> to </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, fromState, toState)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Update state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainer.State </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> toState</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> toState </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> types.StateRunning {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Set started timestamp if needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Persist</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.store.</span><span style=\"color:#B392F0\">Save</span><span style=\"color:#E1E4E8\">(container); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Revert in-memory state on persistence failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tcontainer.State </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fromState</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"save container state: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> isValidTransition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">from</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">to</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Define valid transitions based on state machine diagram</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\ttransitions </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttypes.StateCreated:  {types.StateRunning, types.StateStopped},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttypes.StateRunning:  {types.StatePaused, types.StateStopped},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttypes.StatePaused:   {types.StateRunning, types.StateStopped},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttypes.StateStopped:  {types.StateRemoved},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttypes.StateRemoved:  {}, </span><span style=\"color:#6A737D\">// Terminal state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> _, validTo </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> transitions[from] {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#E1E4E8\"> validTo </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> to {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\t\treturn</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<p><strong>Container Creation Sequence (<code>internal/runtime/sequence.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">byd/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// createContainerSequence orchestrates the 8-phase container creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the created Container and any error encountered</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">createContainerSequence</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\tconfig</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\tname</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Phase 1: Validation and Preparation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Validate config fields (image exists, limits positive, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Generate containerID using utils.Generate()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Create container entry with StateCreated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Save to ContainerStore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Phase 2: Image Preparation  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Check if image exists locally via ImageStore</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: If not, call cr.PullImage() (this may be long-running)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Load Image object from store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Call FilesystemManager.SetupRootfs() to prepare root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Phase 3: Namespace Creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: Determine namespace flags from config (PID, UTS, mount, network, IPC)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 10: Call NamespaceManager.CreateNamespaces() with flags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 11: Capture returned child PID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Phase 4: Cgroup Configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 12: Call CgroupManager.CreateGroup() with containerID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 13: Call CgroupManager.SetLimits() with config.Limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 14: Call CgroupManager.AddProcess() to move child PID into cgroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Phase 5: Network Setup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 15: Construct network namespace path: fmt.Sprintf(\"/proc/%d/ns/net\", childPID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 16: Call NetworkManager.SetupNetwork() with nsPath and config.Network</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 17: Handle error - if fails, roll back previous phases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Phase 6: Filesystem Isolation (inside child)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// This is handled by the child process via ChildEntryPoint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// The parent just waits for child to signal ready or error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Phase 7: Process Execution (inside child)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Handled by ChildEntryPoint which calls exec()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Phase 8: State Transition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 18: Update container state to StateRunning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 19: Set container.Pid = childPID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 20: Save updated container to store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 21: Start monitoring goroutine for container exit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Error handling: implement rollback for each phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Use defer with named return values to track if sequence succeeded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ChildEntryPoint is the function executed inside the new namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It's called via re-execution of the binary with --child flag</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ChildEntryPoint</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Parse containerID from environment (BYD_CONTAINER_ID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Load container from store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Call FilesystemManager.IsolateFilesystem() with container's rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Set hostname using syscall.Sethostname()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Set up environment variables from container.Config.Env</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Change working directory to container.Config.WorkingDir</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Determine command to execute (merge image and user config)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Perform syscall.Exec() to replace this process with container command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: If exec fails, exit with error code; otherwise never returns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\"> // Error exit if we reach here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Image Pull Sequence (<code>internal/images/pull_sequence.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> images</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PullImage orchestrates downloading an image from registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ih </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImageHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PullImage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">imageRef</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Image</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Parse image reference into registry, repository, tag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Check local cache for existing image with same digest</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Fetch manifest from registry using RegistryClient.PullManifest()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Verify manifest structure and media type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: For each layer in manifest.Layers:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   TODO 5a: Check LayerCache for existing layer with same digest</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   TODO 5b: If not cached, download using RegistryClient.PullLayer()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   TODO 5c: Verify SHA256 digest matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   TODO 5d: Store blob in ImageStore.StoreBlob()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t//   TODO 5e: Add to LayerCache with AddReference()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Download image configuration blob</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Parse into ImageConfig struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Create Image object with all layers and config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: Store image in ImageStore with tag reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 10: Return complete Image object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li><strong>Go concurrency:</strong> Use goroutines for parallel layer downloads but limit concurrency with a worker pool</li>\n<li><strong>Error wrapping:</strong> Use <code>fmt.Errorf(&quot;step: %w&quot;, err)</code> for error chains that show the sequence of failures</li>\n<li><strong>JSON serialization:</strong> Use struct tags: <code>`json:&quot;fieldName,omitempty&quot;`</code> for proper serialization</li>\n<li><strong>File locking:</strong> Use <code>flock</code> or directory-based locking for atomic operations on container state</li>\n<li><strong>Context propagation:</strong> Pass <code>context.Context</code> through long operations (network downloads) for cancellation</li>\n<li><strong>Cleanup with defer:</strong> Structure functions with <code>defer cleanup()</code> pattern, but be careful with early returns</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong>\nAfter implementing the container creation sequence, verify with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> ./cmd/byd</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byd</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --rm</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> echo</span><span style=\"color:#9ECBFF\"> \"Hello from container\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. Downloads alpine image (if first time)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Creates container with isolated namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Runs echo command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. Prints \"Hello from container\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 5. Container exits and is cleaned up (due to --rm)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verification commands:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> byd</span><span style=\"color:#6A737D\">          # Should show only the byd process, not container processes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/</span><span style=\"color:#6A737D\">         # Should see byd-* cgroups created and cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#6A737D\">               # Should see veth interfaces created and removed</span></span></code></pre></div>\n\n<p><strong>G. Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container exits immediately with code 1</td>\n<td><code>exec()</code> failure in child</td>\n<td>Check child logs, verify binary exists in rootfs</td>\n<td>Ensure rootfs has the executable at correct path</td>\n</tr>\n<tr>\n<td>Network setup fails with &quot;device busy&quot;</td>\n<td>veth interface already exists</td>\n<td><code>ip link show</code> to see conflicting names</td>\n<td>Use unique interface names, clean up old interfaces</td>\n</tr>\n<tr>\n<td>Cgroup limits not enforced</td>\n<td>Process not in cgroup</td>\n<td>Check <code>/proc/&lt;pid&gt;/cgroup</code> file</td>\n<td>Ensure <code>AddProcess()</code> is called before process starts</td>\n</tr>\n<tr>\n<td>Rootfs appears empty after mount</td>\n<td>OverlayFS mount failed</td>\n<td>Check <code>dmesg</code> for overlay errors</td>\n<td>Verify lowerdir paths exist, work dir is empty</td>\n</tr>\n<tr>\n<td>Registry pull returns 404</td>\n<td>Invalid image reference</td>\n<td>Check registry API response</td>\n<td>Use full image name: <code>docker.io/library/alpine:latest</code></td>\n</tr>\n<tr>\n<td>State file corruption</td>\n<td>Concurrent writes to same file</td>\n<td>Check file timestamps, use file locking</td>\n<td>Implement atomic writes (write to temp, then rename)</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (error handling and edge cases are relevant throughout the entire system, from low-level system calls to high-level user operations)</p>\n</blockquote>\n<p>This section defines the comprehensive error handling philosophy and edge case management strategy for the container runtime. Unlike application-level software that can often rely on the operating system to clean up after failures, container runtimes operate at the system level where partial failures can leave resources (namespaces, cgroups, mounts, network interfaces) orphaned and system state inconsistent. The key architectural challenge is designing <strong>idempotent, atomic, and recoverable operations</strong> despite the inherent statefulness of Linux kernel primitives.</p>\n<h3 id=\"common-failure-modes-and-detection\">Common Failure Modes and Detection</h3>\n<p>Container runtime failures can be categorized by their <strong>origin layer</strong>: kernel/system call failures, resource exhaustion, user configuration errors, race conditions, and external dependencies. Each category requires distinct detection strategies.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The runtime must assume that any operation can fail at any point, and the failure detection must be <strong>immediate and precise</strong>. Delayed or vague error detection leads to resource leaks and security vulnerabilities.</p>\n</blockquote>\n<h4 id=\"system-call-and-kernel-interface-failures\">System Call and Kernel Interface Failures</h4>\n<p>These are the most fundamental failures, occurring when Linux kernel interfaces reject our requests due to permissions, invalid arguments, or resource constraints.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Strategy</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Namespace creation failure</strong> (<code>clone()</code>, <code>unshare()</code> returns -1)</td>\n<td>Check <code>errno</code> after syscall: <code>EPERM</code> (no privileges), <code>EINVAL</code> (invalid flags), <code>ENOMEM</code> (kernel memory)</td>\n<td>Container cannot start; partial isolation may leave process in host namespace</td>\n</tr>\n<tr>\n<td><strong>cgroup filesystem operations fail</strong> (<code>mkdir</code>, <code>write</code> to control files)</td>\n<td>Check file operation errors: <code>EACCES</code> (permissions), <code>ENOSPC</code> (device full), <code>EROFS</code> (read-only)</td>\n<td>Resource limits not applied; container may consume unbounded resources</td>\n</tr>\n<tr>\n<td><strong>Mount operations fail</strong> (<code>mount()</code>, <code>pivot_root()</code>, <code>umount()</code>)</td>\n<td>Check mount return value and <code>errno</code>: <code>EINVAL</code> (invalid option), <code>EPERM</code> (no CAP_SYS_ADMIN), <code>EBUSY</code> (busy mount)</td>\n<td>Filesystem isolation incomplete; container may access host filesystem</td>\n</tr>\n<tr>\n<td><strong>Network namespace operations fail</strong> (<code>socket()</code>, <code>ioctl()</code>, netlink errors)</td>\n<td>Check network syscall returns and netlink error codes</td>\n<td>Network connectivity broken; container may be unreachable or have incorrect routing</td>\n</tr>\n<tr>\n<td><strong>Process execution fails</strong> (<code>execve()</code> returns -1)</td>\n<td>Check <code>errno</code>: <code>ENOENT</code> (binary not found), <code>EACCES</code> (permission denied), <code>ENOTDIR</code> (path component not directory)</td>\n<td>Container starts but immediately exits; init process fails</td>\n</tr>\n</tbody></table>\n<p><strong>Detection Implementation</strong>: Each component manager (<code>NamespaceManager</code>, <code>CgroupManager</code>, <code>FilesystemManager</code>, <code>NetworkManager</code>) must wrap system calls with explicit error checking that preserves the original <code>errno</code> value. The Go standard library&#39;s <code>syscall</code> package returns error types that include the raw errno, which should be inspected for precise diagnosis.</p>\n<h4 id=\"resource-exhaustion-failures\">Resource Exhaustion Failures</h4>\n<p>The runtime itself, or containers it manages, can exhaust system resources. These failures often manifest as &quot;soft&quot; failures where operations succeed but with degraded performance, eventually leading to &quot;hard&quot; failures.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Strategy</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory exhaustion during image extraction</strong></td>\n<td>Monitor <code>extractLayer</code> for <code>ENOSPC</code> on disk write or <code>ENOMEM</code> when decompressing</td>\n<td>Partial layer extraction; incomplete root filesystem</td>\n</tr>\n<tr>\n<td><strong>Inode or file descriptor exhaustion</strong></td>\n<td>Check for <code>EMFILE</code> (process FD limit) or <code>ENFILE</code> (system FD limit)</td>\n<td>Cannot create pipes, sockets, or open files; runtime becomes inoperable</td>\n</tr>\n<tr>\n<td><strong>PID exhaustion in cgroup</strong></td>\n<td>Monitor <code>fork()</code>/<code>clone()</code> for <code>EAGAIN</code> when cgroup pids.max reached</td>\n<td>Cannot create new processes in container; fork bombs partially contained</td>\n</tr>\n<tr>\n<td><strong>IP address pool exhaustion</strong></td>\n<td><code>IPAM.Allocate()</code> returns error when subnet exhausted</td>\n<td>Container cannot get network connectivity; start fails</td>\n</tr>\n<tr>\n<td><strong>Disk space for upper layer (OverlayFS)</strong></td>\n<td>Write to upper layer fails with <code>ENOSPC</code></td>\n<td>Container filesystem becomes read-only; writes fail</td>\n</tr>\n</tbody></table>\n<p><strong>Detection Implementation</strong>: Proactive monitoring is better than reactive failure. The runtime should check resource availability before operations: <code>CgroupManager</code> should read cgroup limits and current usage before container start; <code>IPAM</code> should track free addresses; <code>FilesystemManager</code> should check available disk space in storage directories.</p>\n<h4 id=\"user-configuration-and-input-errors\">User Configuration and Input Errors</h4>\n<p>These failures stem from invalid user input, misconfigured images, or incompatible system configurations.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Strategy</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Invalid image reference format</strong></td>\n<td>Parse image reference with OCI distribution spec regex</td>\n<td>Cannot pull image; operation fails early</td>\n</tr>\n<tr>\n<td><strong>Missing or malformed OCI manifest</strong></td>\n<td>Validate JSON schema, required fields, and layer digests</td>\n<td>Image cannot be used; rootfs cannot be constructed</td>\n</tr>\n<tr>\n<td><strong>Invalid resource limits</strong> (negative memory, zero CPU shares)</td>\n<td>Validate <code>ResourceLimits</code> fields with range checks</td>\n<td>cgroup setup fails or applies incorrect limits</td>\n</tr>\n<tr>\n<td><strong>Conflicting port mappings</strong></td>\n<td>Check <code>PortMappings</code> for duplicate <code>HostPort</code> values</td>\n<td>Network setup fails or creates conflicting iptables rules</td>\n</tr>\n<tr>\n<td><strong>Missing capabilities for requested isolation</strong></td>\n<td>Check <code>CAP_SYS_ADMIN</code>, <code>CAP_NET_ADMIN</code>, etc. at runtime start</td>\n<td>Namespace creation fails with <code>EPERM</code></td>\n</tr>\n</tbody></table>\n<p><strong>Detection Implementation</strong>: Comprehensive validation at API boundaries. The <code>ContainerRuntime.CreateContainer</code> method should validate all fields of <code>ContainerConfig</code> before any side effects. Image validation should occur during <code>ImageStore.StoreManifest</code> and layer extraction.</p>\n<h4 id=\"race-conditions-and-state-inconsistencies\">Race Conditions and State Inconsistencies</h4>\n<p>Concurrent operations or unexpected external state changes can cause failures even when individual operations succeed.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Strategy</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container already running when start attempted</strong></td>\n<td>Check <code>Container.State</code> in <code>StateManager.Transition()</code></td>\n<td>State transition rejected; prevents double execution</td>\n</tr>\n<tr>\n<td><strong>Container removed while being stopped</strong></td>\n<td>Check container exists after acquiring lock</td>\n<td>Orphaned resources; potential use-after-free</td>\n</tr>\n<tr>\n<td><strong>Network namespace deleted by OS before cleanup</strong></td>\n<td>Check <code>/proc/self/ns/net</code> existence before join</td>\n<td>Runtime crash when trying to operate on non-existent namespace</td>\n</tr>\n<tr>\n<td><strong>Image layer garbage collected while container running</strong></td>\n<td>Reference counting in <code>LayerCache</code> prevents deletion</td>\n<td>Container rootfs becomes broken; read operations fail</td>\n</tr>\n<tr>\n<td><strong>cgroup directory removed externally</strong></td>\n<td>Stat cgroup path before writing control files</td>\n<td>Resource limits lost; process escapes constraints</td>\n</tr>\n</tbody></table>\n<p><strong>Detection Implementation</strong>: State must be protected by synchronization primitives. The <code>StateManager</code> uses <code>sync.RWMutex</code> to serialize state transitions. Resource managers should verify resource existence before operations (defensive programming). Reference counting (<code>LayerCache.AddReference/ReleaseReference</code>) prevents premature deletion of shared resources.</p>\n<h4 id=\"external-dependency-failures\">External Dependency Failures</h4>\n<p>The runtime depends on external systems (Docker registry, DNS, internet connectivity) that may be unavailable.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Strategy</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Registry authentication failure</strong></td>\n<td>HTTP 401/403 from registry API</td>\n<td>Cannot pull private images</td>\n</tr>\n<tr>\n<td><strong>Registry network timeout</strong></td>\n<td>HTTP client timeout with context deadline</td>\n<td>Image pull hangs or fails after retries</td>\n</tr>\n<tr>\n<td><strong>DNS resolution failure during network setup</strong></td>\n<td><code>resolv.conf</code> creation fails if nameservers unreachable</td>\n<td>Container has network but cannot resolve hostnames</td>\n</tr>\n<tr>\n<td><strong>iptables lock contention or missing modules</strong></td>\n<td>Check <code>iptables</code> command exit code</td>\n<td>NAT or port forwarding not configured</td>\n</tr>\n<tr>\n<td><strong>OverlayFS kernel module not loaded</strong></td>\n<td>Check <code>/proc/filesystems</code> for overlay entry</td>\n<td>Layered filesystem unavailable; must fall back to plain directory</td>\n</tr>\n</tbody></table>\n<p><strong>Detection Implementation</strong>: Network operations should use contexts with timeouts. Registry client should implement exponential backoff for transient failures. System dependency checks should occur at runtime initialization (<code>NewContainerRuntime</code> should validate kernel features and available commands).</p>\n<h3 id=\"recovery-and-cleanup-strategies\">Recovery and Cleanup Strategies</h3>\n<p>The container runtime must implement <strong>compensating transactions</strong>—for every operation that modifies system state, there must be a corresponding cleanup operation that can be executed even after partial failures. The strategy follows a <strong>cleanup stack</strong> pattern where operations push cleanup functions onto a stack as they succeed, and failures unwind the stack.</p>\n<h4 id=\"state-driven-cleanup-orchestration\">State-Driven Cleanup Orchestration</h4>\n<p>Each container has a well-defined state machine (<code>ContainerState</code>: <code>Created</code>, <code>Running</code>, <code>Paused</code>, <code>Stopped</code>, <code>Removed</code>). The cleanup strategy differs by which state transition fails:</p>\n<table>\n<thead>\n<tr>\n<th>Failed Transition</th>\n<th>Cleanup Strategy</th>\n<th>Rollback Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Nothing → Created</strong> (container creation fails)</td>\n<td>Delete all allocated resources</td>\n<td>1. Delete cgroup directory<br>2. Delete container metadata from <code>ContainerStore</code><br>3. Release IP address from <code>IPAM</code></td>\n</tr>\n<tr>\n<td><strong>Created → Running</strong> (start fails)</td>\n<td>Roll back to <code>Created</code> state, keep resources allocated</td>\n<td>1. Kill any partially started process<br>2. Leave namespaces, cgroups, network intact for retry<br>3. Unmount any temporary mounts (e.g., /proc in wrong namespace)</td>\n</tr>\n<tr>\n<td><strong>Running → Stopped</strong> (stop fails or timeout)</td>\n<td>Force kill with SIGKILL, then cleanup</td>\n<td>1. Send SIGKILL to container process tree<br>2. Wait for process termination<br>3. Perform full cleanup as if stop succeeded</td>\n</tr>\n<tr>\n<td><strong>Stopped → Removed</strong> (remove fails)</td>\n<td>Retry with more aggressive cleanup</td>\n<td>1. Force unmount lingering mounts (MNT_DETACH)<br>2. Force delete cgroup directory (write <code>cgroup.kill</code> for cgroup v2)<br>3. Force remove network namespace by killing processes inside</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Pattern</strong>: The <code>createContainerSequence</code> function (from Milestone 6) should implement the cleanup stack:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Pseudo-code structure (actual code in Implementation Guidance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> cleanupTasks []</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">defer</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Execute cleanup in reverse order (LIFO)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cleanupTasks)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            cleanupTasks</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">i</span><span style=\"color:#E1E4E8\">]()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Each successful operation pushes its cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">cleanupTasks </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cleanupTasks, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() { cgroupManager.</span><span style=\"color:#B392F0\">RemoveCgroup</span><span style=\"color:#E1E4E8\">(containerID) })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">cleanupTasks </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cleanupTasks, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() { networkManager.</span><span style=\"color:#B392F0\">CleanupNetwork</span><span style=\"color:#E1E4E8\">(containerID, config) })</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... etc</span></span></code></pre></div>\n\n<h4 id=\"idempotent-cleanup-operations\">Idempotent Cleanup Operations</h4>\n<p>All cleanup operations must be <strong>idempotent</strong>—calling them multiple times or calling them when resources no longer exist should not error. This property is crucial for recovery after crashes where the runtime doesn&#39;t know which cleanup operations have already completed.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Idempotent Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>cgroup deletion</strong></td>\n<td>Check if cgroup directory exists before removal; ignore <code>ENOENT</code> errors</td>\n</tr>\n<tr>\n<td><strong>network namespace cleanup</strong></td>\n<td>Check if network namespace path exists; skip if already gone</td>\n</tr>\n<tr>\n<td><strong>mount unmounting</strong></td>\n<td>Try unmount, ignore <code>EINVAL</code> (not mounted) and <code>ENOENT</code> (mount point gone)</td>\n</tr>\n<tr>\n<td><strong>IP address release</strong></td>\n<td><code>IPAM.Release</code> should check if IP was allocated; no-op if not in allocated map</td>\n</tr>\n<tr>\n<td><strong>filesystem cleanup</strong></td>\n<td><code>RemoveAll</code> on container directory, tolerate missing directories</td>\n</tr>\n</tbody></table>\n<p><strong>Rationale</strong>: After a runtime crash and restart, the recovery routine will attempt to clean up all containers that were in progress. Idempotent cleanup ensures the system converges to a clean state regardless of how many times cleanup is attempted.</p>\n<h4 id=\"orphan-detection-and-garbage-collection\">Orphan Detection and Garbage Collection</h4>\n<p>Despite best efforts, some resources may become orphaned (e.g., if runtime is SIGKILLed during namespace creation). The runtime must include a <strong>garbage collection</strong> system that runs at startup and periodically to reclaim lost resources.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Orphan Detection Method</th>\n<th>Cleanup Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>cgroups</strong></td>\n<td>Scan cgroup filesystem for directories matching container ID pattern</td>\n<td>Remove directory if no processes inside</td>\n</tr>\n<tr>\n<td><strong>network namespaces</strong></td>\n<td>Scan <code>/var/run/netns</code> for namespaces not referenced by any container</td>\n<td>Unlink namespace file (only removes reference, not namespace with processes)</td>\n</tr>\n<tr>\n<td><strong>mounts</strong></td>\n<td>Parse <code>/proc/self/mountinfo</code> for mounts under runtime storage path</td>\n<td>Unmount with <code>MNT_DETACH</code> flag</td>\n</tr>\n<tr>\n<td><strong>OverlayFS layers</strong></td>\n<td>Scan layer cache for unreferenced layers</td>\n<td>Delete layer directories after ensuring no containers reference them</td>\n</tr>\n<tr>\n<td><strong>veth interfaces</strong></td>\n<td>Scan network interfaces for veth* interfaces not in any bridge</td>\n<td>Delete interface with <code>ip link delete</code></td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Approach</strong>: The <code>ContainerRuntime</code> should maintain a <strong>reaper</strong> goroutine that periodically scans for orphans. At startup, before any new container operations, the runtime should run a full garbage collection to clean up from previous crashes.</p>\n<h4 id=\"transaction-logging-for-crash-recovery\">Transaction Logging for Crash Recovery</h4>\n<p>For critical multi-step operations (like container creation), the runtime can write intentions to a <strong>transaction log</strong> before performing operations. If the runtime crashes mid-operation, upon restart it reads the log to know which operations were in progress and can complete or roll them back.</p>\n<table>\n<thead>\n<tr>\n<th>Operation Phase</th>\n<th>Log Entry</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Start container creation</strong></td>\n<td><code>{&quot;op&quot;: &quot;create&quot;, &quot;id&quot;: &quot;abc&quot;, &quot;state&quot;: &quot;allocating&quot;}</code></td>\n<td>If found at recovery, container was being created; run cleanup</td>\n</tr>\n<tr>\n<td><strong>After cgroup created</strong></td>\n<td><code>{&quot;op&quot;: &quot;create&quot;, &quot;id&quot;: &quot;abc&quot;, &quot;state&quot;: &quot;cgroup_created&quot;}</code></td>\n<td>Cleanup must remove cgroup</td>\n</tr>\n<tr>\n<td><strong>After network setup</strong></td>\n<td><code>{&quot;op&quot;: &quot;create&quot;, &quot;id&quot;: &quot;abc&quot;, &quot;state&quot;: &quot;network_created&quot;}</code></td>\n<td>Cleanup must remove network resources</td>\n</tr>\n<tr>\n<td><strong>After rootfs prepared</strong></td>\n<td><code>{&quot;op&quot;: &quot;create&quot;, &quot;id&quot;: &quot;abc&quot;, &quot;state&quot;: &quot;rootfs_ready&quot;}</code></td>\n<td>Cleanup must unmount rootfs</td>\n</tr>\n<tr>\n<td><strong>Completion</strong></td>\n<td>Remove log entry</td>\n<td>No recovery needed</td>\n</tr>\n</tbody></table>\n<p><strong>Trade-off</strong>: While transaction logging provides robust recovery, it adds complexity. For this educational implementation, we opt for the simpler cleanup stack approach, noting that production systems would need transaction logging.</p>\n<h3 id=\"edge-case-scenarios\">Edge Case Scenarios</h3>\n<p>Edge cases represent unusual but possible situations that the runtime must handle gracefully. These often involve boundary conditions, unusual user behavior, or unexpected system configurations.</p>\n<h4 id=\"container-process-behavior-edge-cases\">Container Process Behavior Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container init process exits immediately</strong> (echo &quot;hello&quot;)</td>\n<td>Container starts and stops within milliseconds</td>\n<td>Runtime must still capture exit code, trigger cleanup, transition to <code>Stopped</code> state</td>\n</tr>\n<tr>\n<td><strong>Container process forks daemon children and exits</strong></td>\n<td>PID 1 exits but other processes remain in namespace</td>\n<td>Runtime should kill entire process tree when stopping container; use cgroup process tracking</td>\n</tr>\n<tr>\n<td><strong>Container process calls <code>unshare()</code> itself</strong></td>\n<td>Nested namespaces inside container</td>\n<td>Runtime&#39;s namespaces remain outer layer; child namespaces are container&#39;s business</td>\n</tr>\n<tr>\n<td><strong>Container process mounts /proc over container /proc</strong></td>\n<td>Overwrites runtime&#39;s /proc mount</td>\n<td>Runtime should mount /proc with <code>MS_PRIVATE</code> to prevent propagation, but cannot prevent container from remounting</td>\n</tr>\n<tr>\n<td><strong>Container process writes to /sys files that affect host</strong></td>\n<td>e.g., writing to /sys/class/backlight</td>\n<td>Runtime should mount /sys as read-only (<code>MS_RDONLY</code>) where possible</td>\n</tr>\n<tr>\n<td><strong>Container runs setuid binary that escapes namespace</strong></td>\n<td>Without user namespace, setuid binaries run with host privileges</td>\n<td>Consider implementing user namespace mapping (advanced) or warn users</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Guidance</strong>: The runtime should place the container process in a cgroup and use the cgroup&#39;s process tracking to ensure all descendant processes are accounted for. When stopping, signal should be sent to the entire process tree (using negative PID to process group).</p>\n<h4 id=\"filesystem-edge-cases\">Filesystem Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Base image has broken symlinks</strong></td>\n<td>Symlinks pointing outside rootfs or to non-existent files</td>\n<td>Preserve symlinks as-is; container will get ENOENT when following</td>\n</tr>\n<tr>\n<td><strong>OverlayFS copy-up on directory rename</strong></td>\n<td>Renaming a directory requires copying entire directory tree</td>\n<td>Accept performance hit; OverlayFS handles this automatically</td>\n</tr>\n<tr>\n<td><strong>Multiple containers sharing same image layer</strong></td>\n<td>Concurrent write to same file in shared layer</td>\n<td>OverlayFS ensures each container gets its own copy in upper layer</td>\n</tr>\n<tr>\n<td><strong>Container writes to lower-layer whiteout file</strong></td>\n<td>Writing to <code>.wh..wh..opq</code> or <code>.wh.&lt;filename&gt;</code></td>\n<td>OverlayFS prevents this; runtime doesn&#39;t need special handling</td>\n</tr>\n<tr>\n<td><strong>Rootfs contains mount points</strong> (bind mounts in image)</td>\n<td>These mounts propagate to container if not properly isolated</td>\n<td>Runtime should ensure mount namespace is created before rootfs setup</td>\n</tr>\n<tr>\n<td><strong>/proc mounted but shows host processes</strong></td>\n<td>Forgot to mount /proc after <code>CLONE_NEWPID</code></td>\n<td>Runtime must mount new /proc inside container after PID namespace creation</td>\n</tr>\n</tbody></table>\n<p><strong>Critical Insight</strong>: The order of filesystem operations matters tremendously. The sequence must be: 1) Create mount namespace, 2) Mount rootfs, 3) Mount /proc, /sys, /dev, 4) <code>pivot_root()</code>, 5) Unmount old root. Deviations cause visibility of host processes or files.</p>\n<h4 id=\"networking-edge-cases\">Networking Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container tries to configure its own IP address</strong></td>\n<td>Process inside calls <code>ip addr add</code> on veth interface</td>\n<td>Allowed; container owns its network namespace</td>\n</tr>\n<tr>\n<td><strong>Host network namespace disappears</strong> (unlikely)</td>\n<td>Bridge or veth host-side deleted by admin</td>\n<td>Container loses connectivity; runtime cannot repair external changes</td>\n</tr>\n<tr>\n<td><strong>Container uses raw sockets to send spoofed packets</strong></td>\n<td>Without dropping capabilities, container can send arbitrary packets</td>\n<td>Drop <code>CAP_NET_RAW</code> capability from container by default</td>\n</tr>\n<tr>\n<td><strong>DNS resolution inside container fails but host DNS works</strong></td>\n<td>/etc/resolv.conf not properly configured</td>\n<td>Runtime should copy host&#39;s resolv.conf or use well-known DNS servers</td>\n</tr>\n<tr>\n<td><strong>Port mapping conflict with host service</strong></td>\n<td>Container port 80 maps to host port 80 already in use</td>\n<td>Check host port availability before setting up iptables rule; fail fast</td>\n</tr>\n<tr>\n<td><strong>Multiple containers requesting same static IP</strong></td>\n<td>Two containers configured with same <code>IPAddress</code></td>\n<td><code>IPAM.Allocate</code> should detect conflict and return error</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Note</strong>: Network isolation is only as strong as the capability dropping. The runtime should drop dangerous capabilities (<code>CAP_NET_RAW</code>, <code>CAP_NET_ADMIN</code>) from the container unless explicitly requested by the user.</p>\n<h4 id=\"image-and-storage-edge-cases\">Image and Storage Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Image layer tar has same file in multiple layers</strong></td>\n<td>Last layer wins; lower layer files are obscured</td>\n<td>OverlayFS correctly handles this; file from upper layer (later layer) appears</td>\n</tr>\n<tr>\n<td><strong>Image manifest lists multiple architectures</strong></td>\n<td>Manifest list contains amd64, arm64, etc. entries</td>\n<td>Runtime should select based on host architecture or fail with clear error</td>\n</tr>\n<tr>\n<td><strong>Layer download interrupted and partially written</strong></td>\n<td>Partial .tar file in cache</td>\n<td>Validate SHA256 digest after download; redownload if mismatch</td>\n</tr>\n<tr>\n<td><strong>Image config specifies invalid entrypoint</strong> (non-existent binary)</td>\n<td><code>execve</code> fails at container start</td>\n<td>Container fails to start; return meaningful error about missing binary</td>\n</tr>\n<tr>\n<td><strong>Two images share layers with different digests</strong> (impossible by definition)</td>\n<td>Content-addressable storage ensures same content = same digest</td>\n<td>If digests differ, content differs; treat as different layers</td>\n</tr>\n<tr>\n<td><strong>Image with :latest tag updates while container running</strong></td>\n<td>New image pulled doesn&#39;t affect running containers</td>\n<td>Running containers use extracted layers; new containers use new image</td>\n</tr>\n</tbody></table>\n<p><strong>Content Integrity</strong>: The runtime must verify layer digests after download and after extraction. A corrupted layer should be re-downloaded automatically.</p>\n<h4 id=\"security-and-permission-edge-cases\">Security and Permission Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Non-root user runs runtime</strong></td>\n<td>Most operations require <code>CAP_SYS_ADMIN</code></td>\n<td>Fail early with clear message about needing root/sudo</td>\n</tr>\n<tr>\n<td><strong>Container process gains root via setuid binary</strong></td>\n<td>Root inside container ≠ root on host (without user ns)</td>\n<td>Without user namespace, container root can do damage; warn users</td>\n</tr>\n<tr>\n<td><strong>Host filesystem mounted inside container</strong> (bind mount)</td>\n<td>Container can modify host files if mounted rw</td>\n<td>Only allow bind mounts from explicit host paths with user consent</td>\n</tr>\n<tr>\n<td><strong>Container escapes via /proc/self/ns/ join</strong></td>\n<td>Process joins host namespace via leaked fd</td>\n<td>Keep namespace fds private to runtime; don&#39;t expose to container</td>\n</tr>\n<tr>\n<td><strong>Resource limit bypass via fork bomb</strong></td>\n<td>Process creates many children quickly</td>\n<td>cgroup pids.max prevents this; ensure limit is set before process starts</td>\n</tr>\n</tbody></table>\n<p><strong>Security Principle</strong>: The runtime should follow the principle of least privilege. Drop all capabilities not explicitly needed, mount filesystems as read-only where possible, and use user namespaces if implemented.</p>\n<h4 id=\"cross-milestone-integration-edge-cases\">Cross-Milestone Integration Edge Cases</h4>\n<p>These edge cases emerge when components from different milestones interact in unexpected ways:</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Affected Milestones</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Network namespace created but bridge not set up</strong></td>\n<td>Milestone 1 + 5</td>\n<td>Container has isolated network but no connectivity; runtime should ensure bridge exists or create it</td>\n</tr>\n<tr>\n<td><strong>cgroup limits set but process not moved into cgroup</strong></td>\n<td>Milestone 2 + 1</td>\n<td>Process escapes limits; must call <code>cgroupManager.AddProcess</code> after fork but before exec</td>\n</tr>\n<tr>\n<td><strong>Rootfs mounted but /proc not mounted in PID ns</strong></td>\n<td>Milestone 3 + 1</td>\n<td>ps, top show host processes; must mount /proc after entering PID namespace</td>\n</tr>\n<tr>\n<td><strong>OverlayFS mounted but workdir not empty</strong></td>\n<td>Milestone 4</td>\n<td>mount fails with <code>ENOTEMPTY</code>; runtime should create fresh workdir or clear it</td>\n</tr>\n<tr>\n<td><strong>Image pulled but layers extracted to wrong location</strong></td>\n<td>Milestone 6 + 4</td>\n<td>OverlayFS can&#39;t find lowerdirs; use consistent paths: <code>/var/lib/runtime/layers/&lt;digest&gt;</code></td>\n</tr>\n<tr>\n<td><strong>Container stopped but network namespace not cleaned up</strong></td>\n<td>Milestone 5 + 6</td>\n<td>veth interface orphaned; cleanup must be part of container removal, not just stop</td>\n</tr>\n</tbody></table>\n<p><strong>Integration Testing</strong>: The runtime needs comprehensive integration tests that verify all milestones work together correctly. Each edge case should have a corresponding test case.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete implementation patterns for error handling and cleanup in Go, with complete starter code for the cleanup stack pattern.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Propagation</td>\n<td>Return <code>error</code> with context using <code>fmt.Errorf</code> and <code>%w</code></td>\n<td>Structured errors with custom error types implementing <code>Is()</code> and <code>As()</code></td>\n</tr>\n<tr>\n<td>Cleanup Orchestration</td>\n<td>Defer-based cleanup stack</td>\n<td>Transaction log with recovery scanner</td>\n</tr>\n<tr>\n<td>Resource Tracking</td>\n<td>In-memory maps with mutexes</td>\n<td>Database (SQLite) for persistent state</td>\n</tr>\n<tr>\n<td>Orphan Detection</td>\n<td>Periodic scanner goroutine</td>\n<td>inotify watches on resource directories</td>\n</tr>\n<tr>\n<td>State Recovery</td>\n<td>Rebuild state from container directories</td>\n<td>Write-ahead log of all state changes</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/\n    runtime/\n      errors.go              # Custom error types and error handling utilities\n      cleanup.go             # Cleanup stack implementation\n      recovery.go            # Orphan detection and garbage collection\n      state_manager.go       # State transitions with error handling\n    cgroup/\n      manager.go             # cgroup operations with idempotent cleanup\n    network/\n      manager.go             # Network setup/cleanup with rollback\n    filesystem/\n      manager.go             # Mount operations with proper unmount on error\n    image/\n      store.go               # Image validation and integrity checking\n  cmd/\n    runtime/\n      main.go               # Runtime initialization with startup recovery</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Here&#39;s complete, working code for the cleanup stack pattern that can be used throughout the runtime:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/runtime/cleanup.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupFunc is a function that cleans up resources.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It should be idempotent (safe to call multiple times).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CleanupFunc</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupStack manages a stack of cleanup functions to be executed in reverse order.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CleanupStack</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tfuncs []</span><span style=\"color:#B392F0\">CleanupFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu    </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tdone  </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCleanupStack creates a new CleanupStack.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCleanupStack</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupStack</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CleanupStack</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tfuncs: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">CleanupFunc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Push adds a cleanup function to the stack.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cs </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupStack</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">f</span><span style=\"color:#B392F0\"> CleanupFunc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcs.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> cs.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> cs.done {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\t\tpanic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cleanup stack already executed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcs.funcs </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cs.funcs, f)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute runs all cleanup functions in reverse order (LIFO).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// After execution, the stack is marked as done and cannot be used again.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cs </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupStack</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcs.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> cs.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> cs.done {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\treturn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcs.done </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Execute in reverse order (LIFO)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cs.funcs) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tcs.</span><span style=\"color:#B392F0\">funcs</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">i</span><span style=\"color:#E1E4E8\">]()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcs.funcs </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Allow garbage collection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DeferOnError returns a function that executes the cleanup stack if the error is non-nil.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Usage: defer cleanup.DeferOnError(&#x26;err)()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cs </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupStack</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeferOnError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> *error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\t\tif</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t\tcs.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupManager orchestrates cleanup across the entire runtime.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CleanupManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainerStacks </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupStack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tglobalStack     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupStack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu              </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCleanupManager creates a new CleanupManager.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCleanupManager</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CleanupManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tcontainerStacks: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupStack</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tglobalStack:     </span><span style=\"color:#B392F0\">NewCleanupStack</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterContainerCleanup creates a cleanup stack for a container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterContainerCleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupStack</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> cm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tstack </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewCleanupStack</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcm.containerStacks[containerID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecuteContainerCleanup runs cleanup for a specific container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteContainerCleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> cm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> stack, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cm.containerStacks[containerID]; ok {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tstack.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\t\tdelete</span><span style=\"color:#E1E4E8\">(cm.containerStacks, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecuteAllCleanup runs cleanup for all containers and global resources.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteAllCleanup</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> cm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Clean up all containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tfor</span><span style=\"color:#E1E4E8\"> containerID, stack </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> cm.containerStacks {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tstack.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\t\tdelete</span><span style=\"color:#E1E4E8\">(cm.containerStacks, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Clean up global resources</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcm.globalStack.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>Here&#39;s the skeleton for the container creation sequence with integrated error handling and cleanup:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/runtime/container_creation.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/your-username/container-runtime/internal/cgroup</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/your-username/container-runtime/internal/network</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/your-username/container-runtime/internal/filesystem</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/your-username/container-runtime/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">createContainerSequence</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tvar</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainerID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> uuid.</span><span style=\"color:#B392F0\">Generate</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Create cleanup stack for this container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcleanupStack </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.cleanupManager.</span><span style=\"color:#B392F0\">RegisterContainerCleanup</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#E1E4E8\"> cleanupStack.</span><span style=\"color:#B392F0\">DeferOnError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">err)()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Step 1: Validate configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Check all fields of config for validity (positive memory, valid image ref, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Check if container name is unique</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Check if image exists locally; if not, return error (caller should pull first)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Step 2: Create container metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcontainer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tID:   containerID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tName: name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tState: types.StateCreated,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tConfig: config,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tCreatedAt: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Step 3: Save container to persistent storage (so we know about it even if crash)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Call r.containerStore.Save(container)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcleanupStack.</span><span style=\"color:#B392F0\">Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// If creation fails, delete the container record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tr.containerStore.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Step 4: Create cgroup for container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Call r.cgroupManager.CreateCgroup(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Apply resource limits from config.Limits using r.cgroupManager.ApplyLimits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcleanupStack.</span><span style=\"color:#B392F0\">Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Idempotent cgroup cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tr.cgroupManager.</span><span style=\"color:#B392F0\">RemoveCgroup</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Step 5: Setup network namespace and interfaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Call r.networkManager.SetupNetwork with containerID and config.Network</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcleanupStack.</span><span style=\"color:#B392F0\">Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Idempotent network cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tr.networkManager.</span><span style=\"color:#B392F0\">CleanupNetwork</span><span style=\"color:#E1E4E8\">(containerID, config.Network)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Step 6: Prepare root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Get image from image store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: Call r.filesystemManager.SetupRootfs to extract layers and prepare rootfs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tcleanupStack.</span><span style=\"color:#B392F0\">Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Idempotent filesystem cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tr.filesystemManager.</span><span style=\"color:#B392F0\">CleanupFilesystem</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Step 7: All additional preparations (mounts, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 10: Setup additional mounts, /proc, /sys, /dev inside container rootfs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Step 8: Container is ready to start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 11: Update container state to StateCreated (if not already)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Clear cleanup stack since creation succeeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// We'll create a new stack for the start operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tr.cleanupManager.</span><span style=\"color:#B392F0\">ExecuteContainerCleanup</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#E1E4E8\"> container, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Error wrapping in Go</strong>: Use <code>fmt.Errorf(&quot;context: %w&quot;, err)</code> to wrap errors while preserving the original error for inspection with <code>errors.Is()</code> and <code>errors.As()</code>.</p>\n</li>\n<li><p><strong>Checking syscall errors</strong>: Use the <code>os</code> and <code>syscall</code> packages:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> syscall.EPERM {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"need CAP_SYS_ADMIN: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount proc failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Idempotent cleanup functions</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> idempotentUnmount</span><span style=\"color:#E1E4E8\">(path </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Unmount</span><span style=\"color:#E1E4E8\">(path, syscall.MNT_DETACH); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">           // Ignore \"not mounted\" errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> syscall.EINVAL </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> syscall.ENOENT {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               log.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Warning: unmount </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> failed: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Context for timeouts</strong>: Use <code>context.WithTimeout</code> for network operations:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithTimeout</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   defer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   manifest, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.registryClient.</span><span style=\"color:#B392F0\">PullManifest</span><span style=\"color:#E1E4E8\">(ctx, imageRef, tag)</span></span></code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Atomic file writes</strong>: To avoid partial writes during image layer download:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Write to temp file first, then rename atomically</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   tmpPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> destPath </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \".tmp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   defer</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(tmpPath)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   // ... download to tmpPath ...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Rename</span><span style=\"color:#E1E4E8\">(tmpPath, destPath); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"atomic rename failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing error handling, you should be able to test:</p>\n<ol>\n<li><strong>Container creation failure recovery</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run with invalid image reference</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./runtime</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --memory</span><span style=\"color:#9ECBFF\"> 100m</span><span style=\"color:#9ECBFF\"> nonexistent/image:latest</span><span style=\"color:#9ECBFF\"> echo</span><span style=\"color:#9ECBFF\"> \"hello\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should fail cleanly with error message, no orphaned resources</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Resource cleanup verification</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start container, then kill runtime process (Ctrl+Z, kill -9)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./runtime</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --memory</span><span style=\"color:#9ECBFF\"> 50m</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> sleep</span><span style=\"color:#79B8FF\"> 60</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Kill runtime in another terminal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Restart runtime - it should detect and clean up orphaned container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./runtime</span><span style=\"color:#9ECBFF\"> cleanup</span><span style=\"color:#79B8FF\"> --all</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check no cgroups, mounts, or network interfaces remain</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Edge case testing</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Test immediate exit container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./runtime</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> echo</span><span style=\"color:#9ECBFF\"> \"done\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Container should stop cleanly and be removable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Test fork bomb with pids limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> ./runtime</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --pids-limit</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> /bin/sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"forkbomb() { forkbomb | forkbomb &#x26; }; forkbomb\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should be contained and not affect host</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container starts but immediately exits with code 127</strong></td>\n<td>Entrypoint binary not found in rootfs</td>\n<td>Check container logs, verify image layers extracted correctly</td>\n<td>Ensure image has correct entrypoint, extract layers fully</td>\n</tr>\n<tr>\n<td><strong>Mount operation fails with &quot;invalid argument&quot;</strong></td>\n<td>OverlayFS not supported or missing kernel module</td>\n<td>Check <code>/proc/filesystems</code> for overlay entry</td>\n<td>Load overlay module: <code>sudo modprobe overlay</code></td>\n</tr>\n<tr>\n<td><strong>cgroup creation fails with &quot;permission denied&quot;</strong></td>\n<td>cgroup filesystem mounted read-only or wrong permissions</td>\n<td>Check <code>/sys/fs/cgroup</code> mount options</td>\n<td>Remount as rw: <code>sudo mount -o remount,rw /sys/fs/cgroup</code></td>\n</tr>\n<tr>\n<td><strong>Network connectivity broken inside container</strong></td>\n<td>veth interface not added to bridge or iptables rules missing</td>\n<td>Check <code>ip link</code>, <code>brctl show</code>, <code>iptables -L -n -t nat</code></td>\n<td>Ensure network setup completes all steps</td>\n</tr>\n<tr>\n<td><strong>Container can see host processes in /proc</strong></td>\n<td>/proc not mounted after entering PID namespace</td>\n<td>Check mount namespace and order of operations</td>\n<td>Mount /proc inside container after <code>CLONE_NEWPID</code></td>\n</tr>\n<tr>\n<td><strong>Orphaned resources after runtime crash</strong></td>\n<td>Cleanup not executed due to crash</td>\n<td>Run runtime with <code>cleanup --all</code> flag</td>\n<td>Implement startup garbage collection</td>\n</tr>\n<tr>\n<td><strong>Image layer download fails with 404</strong></td>\n<td>Wrong digest or registry authentication issue</td>\n<td>Check manifest for correct layer digests</td>\n<td>Ensure authentication tokens are valid</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (testing is essential for validating each component and the integrated system)</p>\n</blockquote>\n<p>This section outlines a comprehensive testing strategy for the container runtime. Given the complexity of interacting with low-level Linux kernel features, testing must be approached at multiple levels—from unit tests of individual components to full system integration tests. The strategy prioritizes <strong>safety</strong> (preventing host system contamination), <strong>reproducibility</strong> (consistent test environments), and <strong>progressive validation</strong> (each milestone builds on tested foundations).</p>\n<h3 id=\"verification-approaches-and-properties\">Verification Approaches and Properties</h3>\n<p>Testing a container runtime presents unique challenges because it directly manipulates kernel primitives that affect system state. We employ a layered testing pyramid with specific verification approaches for each level:</p>\n<h4 id=\"1-unit-testing-component-isolation-and-mocking\">1. Unit Testing: Component Isolation and Mocking</h4>\n<p><strong>Mental Model: Testing Individual Machine Parts Before Assembly</strong>\nThink of unit testing as testing each component of an engine (fuel pump, spark plugs, pistons) on a workbench before assembling the entire engine. Each component is tested in isolation with simulated inputs and dependencies.</p>\n<p>Unit tests focus on the business logic of each component, mocking all external system interactions. This allows rapid iteration and validation of control flow, error handling, and data transformations without requiring root privileges or creating actual kernel resources.</p>\n<p><strong>Core Verification Properties for Unit Tests:</strong></p>\n<ul>\n<li><strong>Data Structure Integrity:</strong> All fields are correctly initialized, serialized, and deserialized</li>\n<li><strong>State Machine Transitions:</strong> Container state changes follow allowed paths with proper validation</li>\n<li><strong>Configuration Processing:</strong> User input is validated and merged with defaults correctly</li>\n<li><strong>Error Propagation:</strong> Errors from lower layers are properly wrapped and returned</li>\n<li><strong>Resource Management:</strong> Reference counting and cleanup logic work correctly</li>\n</ul>\n<p><strong>Mocking Strategy Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Mocked Dependencies</th>\n<th>Verification Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ContainerStore</code></td>\n<td>Filesystem I/O</td>\n<td>Persistence operations, JSON marshaling/unmarshaling</td>\n</tr>\n<tr>\n<td><code>CgroupManager</code></td>\n<td><code>/sys/fs/cgroup</code> files</td>\n<td>Limit validation, path construction, controller detection</td>\n</tr>\n<tr>\n<td><code>NamespaceManager</code></td>\n<td><code>syscall.Clone</code>, <code>syscall.Unshare</code></td>\n<td>Flag composition, error condition simulation</td>\n</tr>\n<tr>\n<td><code>FilesystemManager</code></td>\n<td><code>syscall.Mount</code>, <code>syscall.PivotRoot</code></td>\n<td>Path validation, mount option construction</td>\n</tr>\n<tr>\n<td><code>NetworkManager</code></td>\n<td><code>netlink</code>, <code>iptables</code></td>\n<td>IP allocation, bridge setup, rule generation</td>\n</tr>\n<tr>\n<td><code>ImageStore</code></td>\n<td>Filesystem, HTTP client</td>\n<td>Digest verification, layer extraction logic</td>\n</tr>\n<tr>\n<td><code>RegistryClient</code></td>\n<td>HTTP transport</td>\n<td>Manifest parsing, authentication flow, retry logic</td>\n</tr>\n</tbody></table>\n<p><strong>Example Unit Test Scenarios:</strong></p>\n<ul>\n<li><code>ContainerStore.Save()</code> with invalid container state should return an error</li>\n<li><code>CgroupManager.SetLimits()</code> with negative memory value should validate and reject</li>\n<li><code>StateManager.Transition()</code> from <code>StateRunning</code> to <code>StateCreated</code> should be blocked</li>\n<li><code>CleanupStack.Execute()</code> should run functions in reverse order and handle panics</li>\n</ul>\n<h4 id=\"2-integration-testing-component-interaction-with-real-dependencies\">2. Integration Testing: Component Interaction with Real Dependencies</h4>\n<p><strong>Mental Model: Assembling Engine Subsystems on a Test Stand</strong>\nIntegration tests assemble related components and test them against real (but isolated) kernel interfaces. This is like testing the fuel system with real gasoline but in a controlled test chamber.</p>\n<p>These tests require root privileges and create actual kernel resources but within isolated scopes (temporary directories, test-specific cgroup hierarchies). Each test is responsible for complete cleanup to avoid leaving system state.</p>\n<p><strong>Key Integration Testing Patterns:</strong></p>\n<p><strong>Test Isolation Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Isolation Technique</th>\n<th>Implementation</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Temporary Directory</strong></td>\n<td><code>os.MkdirTemp()</code></td>\n<td>Provides scratch space for root filesystems, layer storage</td>\n</tr>\n<tr>\n<td><strong>Test-specific Cgroup</strong></td>\n<td>Create under <code>/sys/fs/cgroup/test-*</code></td>\n<td>Contains cgroup operations to test hierarchy</td>\n</tr>\n<tr>\n<td><strong>Private Mount Namespace</strong></td>\n<td><code>unshare(CLONE_NEWNS)</code></td>\n<td>Isolate mount operations from host filesystem</td>\n</tr>\n<tr>\n<td><strong>Network Namespace Sandbox</strong></td>\n<td><code>netns.New()</code> at test start</td>\n<td>Test networking without affecting host interfaces</td>\n</tr>\n<tr>\n<td><strong>Process Namespace Tracking</strong></td>\n<td>Track PIDs created during test</td>\n<td>Ensure all child processes are terminated</td>\n</tr>\n</tbody></table>\n<p><strong>Integration Test Categories:</strong></p>\n<ol>\n<li><strong>Filesystem Integration Tests:</strong> Mount operations, OverlayFS setup, pivot_root behavior</li>\n<li><strong>Cgroup Integration Tests:</strong> Limit enforcement, process migration, statistic collection</li>\n<li><strong>Namespace Integration Tests:</strong> Process isolation, hostname setting, mount propagation</li>\n<li><strong>Network Integration Tests:</strong> veth pair creation, bridge attachment, iptables rules</li>\n<li><strong>Image Management Tests:</strong> Layer extraction, manifest parsing, registry communication</li>\n</ol>\n<p><strong>Verification Properties for Integration Tests:</strong></p>\n<ul>\n<li><strong>Kernel Interface Correctness:</strong> System calls behave as expected with given parameters</li>\n<li><strong>Resource Cleanup:</strong> All created resources (mounts, cgroups, network interfaces) are removed</li>\n<li><strong>Isolation Integrity:</strong> Operations in test environment don&#39;t leak to host</li>\n<li><strong>Error Recovery:</strong> Partial failures are cleaned up properly (no orphan resources)</li>\n<li><strong>Concurrent Safety:</strong> Multiple test runs don&#39;t interfere with each other</li>\n</ul>\n<h4 id=\"3-system-testing-end-to-end-container-execution\">3. System Testing: End-to-End Container Execution</h4>\n<p><strong>Mental Model: Test Driving the Complete Vehicle</strong>\nSystem tests run actual containers with realistic configurations and verify the entire stack works together correctly. This is like taking the fully assembled car for a test drive on a closed track.</p>\n<p>These tests require full root privileges and create complete container environments. They validate the user-facing CLI commands and the complete container lifecycle.</p>\n<p><strong>System Test Architecture:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Test Runner (as root)\n    ├── Creates temporary runtime root directory\n    ├── Initializes all managers with test paths\n    ├── Executes container operations via CLI\n    └── Verifies container behavior and isolation</code></pre></div>\n\n<p><strong>System Test Scenarios Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Verification Points</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Simple Container Run</strong></td>\n<td>Process starts, runs, exits cleanly</td>\n<td>Exit code 0, logs captured</td>\n</tr>\n<tr>\n<td><strong>Isolation Verification</strong></td>\n<td>Check PID, hostname, filesystem view</td>\n<td>Cannot see host processes, has own hostname, limited filesystem</td>\n</tr>\n<tr>\n<td><strong>Resource Limit Enforcement</strong></td>\n<td>Exceed memory limit, fork bomb with PID limit</td>\n<td>OOM kill, fork failure</td>\n</tr>\n<tr>\n<td><strong>Network Connectivity</strong></td>\n<td>Ping gateway, external IP, other containers</td>\n<td>Network works with NAT, inter-container communication</td>\n</tr>\n<tr>\n<td><strong>Filesystem Persistence</strong></td>\n<td>Write to filesystem, restart container</td>\n<td>Data persists in writable layer</td>\n</tr>\n<tr>\n<td><strong>Image Pull and Run</strong></td>\n<td>Pull from registry, create container</td>\n<td>Image layers extracted, container runs with correct entrypoint</td>\n</tr>\n<tr>\n<td><strong>Cleanup After Crash</strong></td>\n<td>Kill runtime process mid-operation</td>\n<td>No orphaned mounts, cgroups, or network interfaces</td>\n</tr>\n</tbody></table>\n<p><strong>System Test Properties:</strong></p>\n<ul>\n<li><strong>End-to-End Correctness:</strong> The complete user workflow works as documented</li>\n<li><strong>Idempotent Cleanup:</strong> Repeated cleanup operations don&#39;t fail</li>\n<li><strong>State Persistence:</strong> Container state survives runtime restarts</li>\n<li><strong>Performance Baselines:</strong> Operations complete within expected time bounds</li>\n<li><strong>Security Boundaries:</strong> Container cannot escape isolation or affect host</li>\n</ul>\n<h4 id=\"4-property-based-and-fuzz-testing\">4. Property-Based and Fuzz Testing</h4>\n<p><strong>Mental Model: Stress Testing with Random Inputs</strong>\nProperty-based testing generates random but valid inputs to test edge cases that manual test cases might miss. This is like using a vibration table to find weak points in the assembly.</p>\n<p><strong>Areas for Property-Based Testing:</strong></p>\n<ul>\n<li><strong>Configuration Generation:</strong> Random but valid <code>ContainerConfig</code> instances</li>\n<li><strong>Path Manipulation:</strong> Edge cases in filesystem path handling</li>\n<li><strong>Network Configuration:</strong> Various IP addresses, subnet masks, port combinations</li>\n<li><strong>Image Layer Combinations:</strong> Different layer counts, sizes, extraction scenarios</li>\n</ul>\n<p><strong>Fuzz Testing Targets:</strong></p>\n<ul>\n<li><strong>Image Manifest Parsers:</strong> Malformed JSON, unexpected fields, large inputs</li>\n<li><strong>CLI Argument Processing:</strong> Special characters, extremely long strings</li>\n<li><strong>Environment Variable Handling:</strong> Injection attempts, null bytes, Unicode</li>\n</ul>\n<h4 id=\"5-negative-testing-error-paths-and-edge-cases\">5. Negative Testing: Error Paths and Edge Cases</h4>\n<p><strong>Mental Model: Deliberately Pushing the System to Failure</strong>\nNegative tests verify the system handles errors gracefully rather than crashing or leaving the system in an inconsistent state. This is like testing safety systems by intentionally creating failure conditions.</p>\n<p><strong>Critical Negative Test Cases:</strong></p>\n<ol>\n<li><strong>Insufficient Privileges:</strong> Run operations as non-root user</li>\n<li><strong>Resource Exhaustion:</strong> Fill disk, memory, PID space during operations</li>\n<li><strong>Concurrent Modification:</strong> Multiple processes manipulating same container</li>\n<li><strong>Partial Failures:</strong> Kill processes mid-operation, disconnect network during pull</li>\n<li><strong>Malicious Inputs:</strong> Attempt path traversal, symlink attacks, privilege escalation</li>\n</ol>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone has specific acceptance criteria that must be verified through testing. These checkpoints serve as gates—the implementation should pass all tests for a milestone before proceeding to the next.</p>\n<h4 id=\"milestone-1-process-isolation-namespaces-checkpoints\">Milestone 1: Process Isolation (Namespaces) Checkpoints</h4>\n<p><strong>Verification Tests:</strong></p>\n<p><strong>Unit Tests:</strong></p>\n<ul>\n<li><code>NamespaceManager.CreateNamespaces()</code> correctly composes clone flags from requested namespace types</li>\n<li>State machine prevents starting containers without required namespaces</li>\n<li>Configuration validation rejects invalid namespace combinations</li>\n</ul>\n<p><strong>Integration Tests:</strong></p>\n<ol>\n<li><strong>PID Namespace Isolation:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run container with /bin/sh and check PID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --pid-isolation</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> /bin/sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"echo </span><span style=\"color:#79B8FF\">\\$\\$</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Outputs</span><span style=\"color:#9ECBFF\"> \"1\"</span><span style=\"color:#E1E4E8\"> (not </span><span style=\"color:#9ECBFF\">the</span><span style=\"color:#9ECBFF\"> host</span><span style=\"color:#9ECBFF\"> PID</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n<ol start=\"2\">\n<li><strong>UTS Namespace Hostname:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Set custom hostname in container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --hostname</span><span style=\"color:#9ECBFF\"> mycontainer</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> hostname</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Outputs</span><span style=\"color:#9ECBFF\"> \"mycontainer\"</span><span style=\"color:#E1E4E8\"> (host </span><span style=\"color:#9ECBFF\">hostname</span><span style=\"color:#9ECBFF\"> unchanged</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Mount Namespace Isolation:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Mount tmpfs inside container, check host doesn't see it</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"mount -t tmpfs none /tmp &#x26;&#x26; mount | grep tmpfs\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Shows</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#9ECBFF\"> mount</span><span style=\"color:#9ECBFF\"> inside</span><span style=\"color:#9ECBFF\"> container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> mount</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#6A737D\">  # On host</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> No</span><span style=\"color:#9ECBFF\"> output</span><span style=\"color:#E1E4E8\"> (or </span><span style=\"color:#9ECBFF\">different</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#9ECBFF\"> mounts</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>System Test Checklist:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Process in container cannot see host processes via <code>ps aux</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>unshare</code> and <code>nsenter</code> can attach to container namespaces</li>\n<li><input disabled=\"\" type=\"checkbox\"> Container processes are properly reaped when container exits</li>\n<li><input disabled=\"\" type=\"checkbox\"> Orphaned namespaces are cleaned up after container removal</li>\n</ul>\n<h4 id=\"milestone-2-resource-limits-cgroups-checkpoints\">Milestone 2: Resource Limits (cgroups) Checkpoints</h4>\n<p><strong>Verification Tests:</strong></p>\n<p><strong>Unit Tests:</strong></p>\n<ul>\n<li><code>CgroupManager.DetectCgroupInfo()</code> correctly identifies cgroup v1 vs v2</li>\n<li><code>CgroupManager.SetLimits()</code> validates and converts units correctly</li>\n<li>Error handling for missing controllers or permission denied</li>\n</ul>\n<p><strong>Integration Tests:</strong></p>\n<ol>\n<li><strong>Memory Limit Enforcement:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run container that allocates more than limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --memory</span><span style=\"color:#9ECBFF\"> 10m</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"tail /dev/zero\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Process</span><span style=\"color:#9ECBFF\"> killed</span><span style=\"color:#9ECBFF\"> by</span><span style=\"color:#9ECBFF\"> OOM</span><span style=\"color:#9ECBFF\"> killer</span><span style=\"color:#9ECBFF\"> within</span><span style=\"color:#9ECBFF\"> seconds</span></span></code></pre></div>\n<ol start=\"2\">\n<li><strong>CPU Limit Throttling:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run CPU-intensive task, check throttling statistics</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --cpu-shares</span><span style=\"color:#79B8FF\"> 512</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> md5sum</span><span style=\"color:#9ECBFF\"> /dev/urandom</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Monitor via: cat /sys/fs/cgroup/byod-&#x3C;id>/cpu.stat</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> `</span><span style=\"color:#B392F0\">nr_throttled</span><span style=\"color:#9ECBFF\">`</span><span style=\"color:#B392F0\"> count</span><span style=\"color:#9ECBFF\"> increases</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>PID Limit Prevention:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Attempt fork bomb with PID limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --pids-limit</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \":(){ :|:&#x26; };:\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Fork</span><span style=\"color:#9ECBFF\"> fails</span><span style=\"color:#9ECBFF\"> after</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#9ECBFF\"> processes,</span><span style=\"color:#9ECBFF\"> container</span><span style=\"color:#9ECBFF\"> remains</span><span style=\"color:#9ECBFF\"> stable</span></span></code></pre></div>\n\n<p><strong>System Test Checklist:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Cgroup directory created with correct hierarchy</li>\n<li><input disabled=\"\" type=\"checkbox\"> Control files contain specified limit values</li>\n<li><input disabled=\"\" type=\"checkbox\"> Process moved to cgroup before execution starts</li>\n<li><input disabled=\"\" type=\"checkbox\"> Cgroup removed when container is removed</li>\n<li><input disabled=\"\" type=\"checkbox\"> Statistics collection works (<code>GetStats()</code> returns valid data)</li>\n</ul>\n<h4 id=\"milestone-3-filesystem-isolation-chrootpivot_root-checkpoints\">Milestone 3: Filesystem Isolation (chroot/pivot_root) Checkpoints</h4>\n<p><strong>Verification Tests:</strong></p>\n<p><strong>Unit Tests:</strong></p>\n<ul>\n<li><code>FilesystemManager.SetupRootfs()</code> validates rootfs directory structure</li>\n<li>Mount option construction for proc, sys, dev</li>\n<li>Error handling for missing essential directories</li>\n</ul>\n<p><strong>Integration Tests:</strong></p>\n<ol>\n<li><strong>Root Filesystem Isolation:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Try to access host files from container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --rootfs</span><span style=\"color:#9ECBFF\"> /path/to/rootfs</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#9ECBFF\"> /host</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> No</span><span style=\"color:#9ECBFF\"> such</span><span style=\"color:#9ECBFF\"> file</span><span style=\"color:#9ECBFF\"> or</span><span style=\"color:#9ECBFF\"> directory</span><span style=\"color:#E1E4E8\"> (host </span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#9ECBFF\"> not</span><span style=\"color:#9ECBFF\"> visible</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Proc Filesystem Mount:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Check /proc shows container processes only</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"ls /proc | grep -E '^[0-9]+$' | wc -l\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Small</span><span style=\"color:#9ECBFF\"> number</span><span style=\"color:#E1E4E8\"> (1-2), not host process count</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Basic Filesystem Operations:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Create, read, delete files in container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"echo test > /tmp/file &#x26;&#x26; cat /tmp/file &#x26;&#x26; rm /tmp/file\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Successfully</span><span style=\"color:#9ECBFF\"> creates,</span><span style=\"color:#9ECBFF\"> reads,</span><span style=\"color:#9ECBFF\"> and</span><span style=\"color:#9ECBFF\"> deletes</span><span style=\"color:#9ECBFF\"> file</span></span></code></pre></div>\n\n<p><strong>System Test Checklist:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Container cannot access host files via path traversal</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>/proc</code>, <code>/sys</code>, <code>/dev</code> mounted with correct options</li>\n<li><input disabled=\"\" type=\"checkbox\"> Essential device nodes (<code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/random</code>) exist</li>\n<li><input disabled=\"\" type=\"checkbox\"> Working directory is set correctly per image configuration</li>\n<li><input disabled=\"\" type=\"checkbox\"> Old root is properly unmounted after <code>pivot_root</code></li>\n</ul>\n<h4 id=\"milestone-4-layered-filesystem-overlayfs-checkpoints\">Milestone 4: Layered Filesystem (OverlayFS) Checkpoints</h4>\n<p><strong>Verification Tests:</strong></p>\n<p><strong>Unit Tests:</strong></p>\n<ul>\n<li><code>OverlayManager.MountOverlay()</code> validates layer ordering and directories</li>\n<li><code>LayerCache</code> reference counting maintains correct counts</li>\n<li>Error handling for incompatible lower layer combinations</li>\n</ul>\n<p><strong>Integration Tests:</strong></p>\n<ol>\n<li><strong>Copy-on-Write Behavior:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Modify file from lower layer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"echo modified > /etc/hostname &#x26;&#x26; cat /etc/hostname\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Shows</span><span style=\"color:#9ECBFF\"> \"modified\"</span><span style=\"color:#E1E4E8\"> (change </span><span style=\"color:#9ECBFF\">in</span><span style=\"color:#9ECBFF\"> upper</span><span style=\"color:#9ECBFF\"> layer</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check lower layer unchanged</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#9ECBFF\"> /path/to/lower-layer/etc/hostname</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Original</span><span style=\"color:#9ECBFF\"> content</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Layer Sharing Between Containers:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run two containers from same image</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"touch /shared-test\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /shared-test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> File</span><span style=\"color:#9ECBFF\"> not</span><span style=\"color:#9ECBFF\"> found</span><span style=\"color:#9ECBFF\"> in</span><span style=\"color:#9ECBFF\"> second</span><span style=\"color:#9ECBFF\"> container</span><span style=\"color:#E1E4E8\"> (isolated </span><span style=\"color:#9ECBFF\">upper</span><span style=\"color:#9ECBFF\"> layers</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Whiteout File Deletion:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Delete file from lower layer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"rm /etc/hostname &#x26;&#x26; ls /etc/hostname\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> No</span><span style=\"color:#9ECBFF\"> such</span><span style=\"color:#9ECBFF\"> file</span><span style=\"color:#9ECBFF\"> or</span><span style=\"color:#9ECBFF\"> directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check whiteout created in upper layer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /path/to/upper-layer/etc/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Character</span><span style=\"color:#9ECBFF\"> device</span><span style=\"color:#9ECBFF\"> with</span><span style=\"color:#9ECBFF\"> major/minor</span><span style=\"color:#9ECBFF\"> 0/0</span><span style=\"color:#E1E4E8\"> (whiteout)</span></span></code></pre></div>\n\n<p><strong>System Test Checklist:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Multiple lower layers merged correctly (order preserved)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Upper layer captures all writes</li>\n<li><input disabled=\"\" type=\"checkbox\"> Work directory used correctly for atomic operations</li>\n<li><input disabled=\"\" type=\"checkbox\"> Unmount cleans up all mount points</li>\n<li><input disabled=\"\" type=\"checkbox\"> Layer cache prevents duplicate extraction of same layer</li>\n</ul>\n<h4 id=\"milestone-5-container-networking-checkpoints\">Milestone 5: Container Networking Checkpoints</h4>\n<p><strong>Verification Tests:</strong></p>\n<p><strong>Unit Tests:</strong></p>\n<ul>\n<li><code>IPAM.Allocate()</code> prevents duplicate IP allocation</li>\n<li><code>NetlinkHelper</code> command generation for bridge, veth, iptables</li>\n<li>Network configuration validation (CIDR, port ranges)</li>\n</ul>\n<p><strong>Integration Tests:</strong></p>\n<ol>\n<li><strong>Basic Network Connectivity:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Ping external address</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network</span><span style=\"color:#9ECBFF\"> bridge</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#79B8FF\"> 8.8.8.8</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Successful</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#9ECBFF\"> response</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Inter-Container Communication:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start two containers on same bridge</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> container1=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network</span><span style=\"color:#9ECBFF\"> bridge</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sleep</span><span style=\"color:#79B8FF\"> 60</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> ip1=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#E1E4E8\"> $container1 </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> .network.ip_address</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network</span><span style=\"color:#9ECBFF\"> bridge</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $ip1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Successful</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#9ECBFF\"> between</span><span style=\"color:#9ECBFF\"> containers</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Port Forwarding:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Forward host port to container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --port</span><span style=\"color:#9ECBFF\"> 8080:80</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> nc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 80</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Connection</span><span style=\"color:#9ECBFF\"> succeeds</span><span style=\"color:#E1E4E8\"> (or </span><span style=\"color:#9ECBFF\">times</span><span style=\"color:#9ECBFF\"> out</span><span style=\"color:#9ECBFF\"> waiting</span><span style=\"color:#9ECBFF\"> for</span><span style=\"color:#9ECBFF\"> response</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>System Test Checklist:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Network namespace created and isolated</li>\n<li><input disabled=\"\" type=\"checkbox\"> veth pair connects container to bridge</li>\n<li><input disabled=\"\" type=\"checkbox\"> IP address assigned from configured subnet</li>\n<li><input disabled=\"\" type=\"checkbox\"> NAT masquerading allows internet access</li>\n<li><input disabled=\"\" type=\"checkbox\"> iptables rules cleaned up on container removal</li>\n<li><input disabled=\"\" type=\"checkbox\"> Loopback interface up and working inside container</li>\n</ul>\n<h4 id=\"milestone-6-image-format-and-cli-checkpoints\">Milestone 6: Image Format and CLI Checkpoints</h4>\n<p><strong>Verification Tests:</strong></p>\n<p><strong>Unit Tests:</strong></p>\n<ul>\n<li><code>RegistryClient</code> handles authentication errors and retries</li>\n<li>OCI manifest parsing with various schema versions</li>\n<li>CLI command flag parsing and validation</li>\n</ul>\n<p><strong>Integration Tests:</strong></p>\n<ol>\n<li><strong>Image Pull and Run:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Pull image and run it</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> pull</span><span style=\"color:#9ECBFF\"> alpine:latest</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Downloads</span><span style=\"color:#9ECBFF\"> layers,</span><span style=\"color:#9ECBFF\"> verifies</span><span style=\"color:#9ECBFF\"> digests,</span><span style=\"color:#9ECBFF\"> stores</span><span style=\"color:#9ECBFF\"> locally</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> echo</span><span style=\"color:#9ECBFF\"> \"Hello from container\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Runs</span><span style=\"color:#9ECBFF\"> container</span><span style=\"color:#9ECBFF\"> with</span><span style=\"color:#9ECBFF\"> correct</span><span style=\"color:#9ECBFF\"> entrypoint,</span><span style=\"color:#9ECBFF\"> outputs</span><span style=\"color:#9ECBFF\"> message</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Container Lifecycle Management:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Full lifecycle test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> id=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#E1E4E8\"> $id</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> stop</span><span style=\"color:#E1E4E8\"> $id</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> remove</span><span style=\"color:#E1E4E8\"> $id</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Each</span><span style=\"color:#9ECBFF\"> command</span><span style=\"color:#9ECBFF\"> succeeds,</span><span style=\"color:#9ECBFF\"> state</span><span style=\"color:#9ECBFF\"> transitions</span><span style=\"color:#9ECBFF\"> correctly</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Configuration Merging:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Override image entrypoint with CLI command</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> /bin/ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   Expected:</span><span style=\"color:#9ECBFF\"> Runs</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#9ECBFF\"> instead</span><span style=\"color:#9ECBFF\"> of</span><span style=\"color:#9ECBFF\"> default</span><span style=\"color:#9ECBFF\"> shell,</span><span style=\"color:#9ECBFF\"> shows</span><span style=\"color:#9ECBFF\"> root</span><span style=\"color:#9ECBFF\"> directory</span></span></code></pre></div>\n\n<p><strong>System Test Checklist:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Image layers stored in content-addressable storage</li>\n<li><input disabled=\"\" type=\"checkbox\"> Manifest and config parsed correctly</li>\n<li><input disabled=\"\" type=\"checkbox\"> Container state persisted across runtime restarts</li>\n<li><input disabled=\"\" type=\"checkbox\"> CLI commands produce expected output format</li>\n<li><input disabled=\"\" type=\"checkbox\"> Error messages are user-friendly and actionable</li>\n<li><input disabled=\"\" type=\"checkbox\"> All resources cleaned up after container removal</li>\n</ul>\n<h3 id=\"cross-cutting-testing-concerns\">Cross-Cutting Testing Concerns</h3>\n<p><strong>Performance Testing:</strong></p>\n<ul>\n<li>Container startup time should be &lt; 100ms for small images</li>\n<li>Memory overhead per container should be &lt; 5MB</li>\n<li>Concurrent container creation should scale linearly up to resource limits</li>\n</ul>\n<p><strong>Security Testing:</strong></p>\n<ul>\n<li>No privilege escalation opportunities</li>\n<li>No information leakage between containers</li>\n<li>Resource exhaustion doesn&#39;t affect host stability</li>\n<li>All user input properly sanitized and validated</li>\n</ul>\n<p><strong>Compatibility Testing:</strong></p>\n<ul>\n<li>Works with multiple base images (Alpine, Ubuntu, BusyBox)</li>\n<li>Compatible with different Linux distributions (Ubuntu, Fedora, CentOS)</li>\n<li>Kernel version compatibility (4.4+ for basic features, 5.4+ for cgroup v2)</li>\n</ul>\n<h3 id=\"test-environment-requirements\">Test Environment Requirements</h3>\n<p><strong>Minimum Test Environment Setup:</strong></p>\n<ul>\n<li>Linux kernel 4.4 or higher (5.10+ recommended for cgroup v2)</li>\n<li>Root privileges (via sudo or root user)</li>\n<li>1GB free disk space for test images</li>\n<li>Network connectivity for pulling images</li>\n<li>Go 1.18+ for building and testing</li>\n</ul>\n<p><strong>Test Isolation Recommendations:</strong></p>\n<ul>\n<li>Use separate temporary directory for each test run</li>\n<li>Run tests in disposable VMs or containers for complete isolation</li>\n<li>Implement test tags to separate unit, integration, and system tests</li>\n<li>Cleanup routines that run even on test failure (defer pattern)</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing the testing strategy in Go, with a focus on making tests reliable, isolated, and maintainable.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Unit Testing</strong></td>\n<td>Standard Go <code>testing</code> package with <code>testify/mock</code></td>\n<td>Custom mock generators, property-based testing with <code>gopter</code></td>\n</tr>\n<tr>\n<td><strong>Integration Testing</strong></td>\n<td>Root-requiring tests with <code>skip</code> unless flag set</td>\n<td>Test containers that run tests in isolated environments</td>\n</tr>\n<tr>\n<td><strong>System Testing</strong></td>\n<td>Bash scripts calling CLI</td>\n<td>Go tests that exec CLI and verify output</td>\n</tr>\n<tr>\n<td><strong>Network Testing</strong></td>\n<td>Loopback interface only, skip real network tests</td>\n<td><code>github.com/vishvananda/netns</code> for namespace testing</td>\n</tr>\n<tr>\n<td><strong>Filesystem Testing</strong></td>\n<td>Temp directories with cleanup</td>\n<td>Mount namespace isolation for safe mount operations</td>\n</tr>\n<tr>\n<td><strong>Cgroup Testing</strong></td>\n<td>Skip unless in CI with specific permissions</td>\n<td>Detect available controllers and test only supported ones</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   └── byod/                    # CLI entry point\n│       └── main.go\n├── internal/\n│   ├── runtime/                 # Core runtime logic\n│   │   ├── runtime.go\n│   │   ├── runtime_test.go      # Unit tests\n│   │   └── runtime_integration_test.go  # Integration tests\n│   ├── container/               # Container management\n│   │   ├── store.go\n│   │   ├── state.go\n│   │   └── store_test.go\n│   ├── cgroups/                 # cgroup management\n│   │   ├── manager.go\n│   │   ├── manager_integration_test.go\n│   │   └── mock_manager.go      # Mock for unit tests\n│   ├── namespaces/              # Namespace management\n│   │   ├── manager.go\n│   │   └── manager_test.go\n│   ├── filesystem/              # Filesystem isolation\n│   │   ├── manager.go\n│   │   ├── overlay.go\n│   │   └── manager_integration_test.go\n│   ├── network/                 # Network management\n│   │   ├── manager.go\n│   │   ├── iptables.go\n│   │   └── manager_integration_test.go\n│   ├── image/                   # Image handling\n│   │   ├── store.go\n│   │   ├── registry.go\n│   │   └── store_test.go\n│   └── cli/                     # CLI command implementations\n│       ├── commands.go\n│       └── commands_test.go\n├── tests/                       # System and end-to-end tests\n│   ├── system/                  # Full system tests\n│   │   ├── container_lifecycle_test.go\n│   │   └── network_test.go\n│   └── fixtures/                # Test fixtures (small rootfs, etc.)\n│       └── busybox-rootfs.tar\n├── pkg/                         # Public APIs (if any)\n│   └── types/                   # Shared types\n│       ├── container.go\n│       └── image.go\n└── scripts/                     # Test support scripts\n    ├── setup-test-env.sh\n    └── cleanup-test-resources.sh</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Test Helper for Root-Requiring Tests:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/testutil/root_required.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> testutil</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SkipIfNotRoot skips the test if not running as root.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Use: defer testutil.SkipIfNotRoot(t)()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SkipIfNotRoot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Geteuid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test requires root privileges\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {} </span><span style=\"color:#6A737D\">// No-op cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TempCgroupPath creates a temporary directory for cgroup testing.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Automatically cleans up after test.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TempCgroupPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation creates test-specific cgroup path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithTestNamespace runs test code in a new mount namespace.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WithTestNamespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fn</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation uses unshare to isolate mounts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Mock Cgroup Manager for Unit Tests:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/cgroups/mock_manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cgroups</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/stretchr/testify/mock</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MockCgroupManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mock</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mock</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockCgroupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.</span><span style=\"color:#B392F0\">Called</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> args.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MockCgroupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetLimits</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limits</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.</span><span style=\"color:#B392F0\">Called</span><span style=\"color:#E1E4E8\">(containerID, limits)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> args.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... implement all methods with mock.Called</span></span></code></pre></div>\n\n<p><strong>Test Fixture Setup Helper:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/fixtures/setup.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> fixtures</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">archive/tar</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">compress/gzip</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateTestRootFS creates a minimal rootfs for testing.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CreateTestRootFS</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create essential directories</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dirs </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"bin\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"dev\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"etc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sys\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"tmp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"usr/bin\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, d </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> dirs {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(dir, d), </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create minimal /etc/passwd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    passwdContent </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"root:x:0:0:root:/root:/bin/sh</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(dir, </span><span style=\"color:#9ECBFF\">\"etc/passwd\"</span><span style=\"color:#E1E4E8\">), </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(passwdContent), </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create /bin/sh as symlink (or copy busybox if available)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(dir, </span><span style=\"color:#9ECBFF\">\"bin/sh\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/bin/sh\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Copy host's sh (for testing only)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/bin/sh\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(shPath, data, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create dummy executable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(shPath, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"#!/bin/sh</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">exit 0\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Chmod</span><span style=\"color:#E1E4E8\">(shPath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code-for-tests\">D. Core Logic Skeleton Code for Tests</h4>\n<p><strong>Integration Test for PID Namespace Isolation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/namespaces/manager_integration_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> namespaces</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/internal/testutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPIDNamespaceIsolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> testutil.</span><span style=\"color:#B392F0\">SkipIfNotRoot</span><span style=\"color:#E1E4E8\">(t)()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create a temporary directory for test artifacts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize NamespaceManager with test configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Use RunInNamespaces with CLONE_NEWPID flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: In child function, check that PID is 1 via os.Getpid()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: In parent, verify child process had correct namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Clean up all test resources (process, namespaces)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify no orphaned processes or namespaces remain</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>System Test for Container Lifecycle:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/system/container_lifecycle_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> system</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os/exec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/internal/testutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestContainerCreateStartStopRemove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> testutil.</span><span style=\"color:#B392F0\">SkipIfNotRoot</span><span style=\"color:#E1E4E8\">(t)()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Build the CLI binary if not already built</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create a test container with minimal image</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify container appears in list with 'created' state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start the container and verify state changes to 'running'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check container process is running with correct namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Stop the container and verify state changes to 'stopped'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Remove the container and verify it's gone from list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Verify all resources cleaned up (cgroups, mounts, network)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Property-Based Test for Configuration Validation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/container/config_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> container</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter/gen</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter/prop</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestContainerConfigValidation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> gopter.</span><span style=\"color:#B392F0\">DefaultTestParameters</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters.MinSuccessfulTests </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> gopter.</span><span style=\"color:#B392F0\">NewProperties</span><span style=\"color:#E1E4E8\">(parameters)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Define generator for valid ContainerConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configGen </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> gen.</span><span style=\"color:#B392F0\">Struct</span><span style=\"color:#E1E4E8\">(reflect.</span><span style=\"color:#B392F0\">TypeOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ContainerConfig</span><span style=\"color:#E1E4E8\">{}), </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">gopter</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Gen</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"MemoryMB\"</span><span style=\"color:#E1E4E8\">:  gen.</span><span style=\"color:#B392F0\">IntRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">),  </span><span style=\"color:#6A737D\">// 1MB to 1GB</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CPUShares\"</span><span style=\"color:#E1E4E8\">: gen.</span><span style=\"color:#B392F0\">IntRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"PidsLimit\"</span><span style=\"color:#E1E4E8\">: gen.</span><span style=\"color:#B392F0\">IntRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Test property: valid config should pass validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties.</span><span style=\"color:#B392F0\">Property</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Valid config passes validation\"</span><span style=\"color:#E1E4E8\">, prop.</span><span style=\"color:#B392F0\">ForAll</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ValidateConfig</span><span style=\"color:#E1E4E8\">(config)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        configGen,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test property: config with negative memory should fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties.</span><span style=\"color:#B392F0\">Property</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Negative memory fails validation\"</span><span style=\"color:#E1E4E8\">, prop.</span><span style=\"color:#B392F0\">ForAll</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">memory</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            config </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ContainerConfig</span><span style=\"color:#E1E4E8\">{MemoryMB: memory}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ValidateConfig</span><span style=\"color:#E1E4E8\">(config)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (memory </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> (memory </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gen.</span><span style=\"color:#B392F0\">IntRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties.</span><span style=\"color:#B392F0\">TestingRun</span><span style=\"color:#E1E4E8\">(t)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-for-go-testing\">E. Language-Specific Hints for Go Testing</h4>\n<ol>\n<li><strong>Use <code>t.Cleanup()</code> for test resource cleanup:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestWithCleanup</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.T) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       dir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">TempDir</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// Automatically cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Or manually:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       f, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">CreateTemp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"test-\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> { t.</span><span style=\"color:#B392F0\">Fatal</span><span style=\"color:#E1E4E8\">(err) }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       t.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() { os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(f.</span><span style=\"color:#B392F0\">Name</span><span style=\"color:#E1E4E8\">()) })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Parallelize safe tests with <code>t.Parallel()</code>:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestParallel</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.T) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       t.</span><span style=\"color:#B392F0\">Parallel</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// Runs concurrently with other parallel tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Test code that doesn't share global state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Use table-driven tests for multiple test cases:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestNamespaceFlags</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.T) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           name </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           input []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           want </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           {</span><span style=\"color:#9ECBFF\">\"PID only\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"pid\"</span><span style=\"color:#E1E4E8\">}, syscall.CLONE_NEWPID},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           {</span><span style=\"color:#9ECBFF\">\"PID and NET\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"pid\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"net\"</span><span style=\"color:#E1E4E8\">}, syscall.CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> syscall.CLONE_NEWNET},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       for</span><span style=\"color:#E1E4E8\"> _, tt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tests {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           t.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(tt.name, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               got </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> flagsFromNames</span><span style=\"color:#E1E4E8\">(tt.input)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               if</span><span style=\"color:#E1E4E8\"> got </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> tt.want {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   t.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"got </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">, want </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, got, tt.want)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Test CLI commands with <code>exec.Command</code>:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestCLICommand</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.T) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       cmd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> exec.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"./byod\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"run\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"alpine\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"echo\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       output, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cmd.</span><span style=\"color:#B392F0\">CombinedOutput</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> { t.</span><span style=\"color:#B392F0\">Fatalf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"command failed: </span><span style=\"color:#79B8FF\">%v\\n%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err, output) }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">strings.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(output), </span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           t.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected output: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, output)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint-validation-commands\">F. Milestone Checkpoint Validation Commands</h4>\n<p>After completing each milestone, run these validation commands:</p>\n<p><strong>Milestone 1 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run namespace isolation tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./internal/namespaces/...</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestPIDNamespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests pass, showing PID isolation works</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --pid-isolation</span><span style=\"color:#79B8FF\"> --uts-isolation</span><span style=\"color:#9ECBFF\"> test/fixtures/minimal-rootfs</span><span style=\"color:#9ECBFF\"> /bin/sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"echo </span><span style=\"color:#79B8FF\">\\$\\$</span><span style=\"color:#9ECBFF\"> &#x26;&#x26; hostname\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Outputs \"1\" and a hostname (not the host's)</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run cgroup integration tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./internal/cgroups/...</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestMemoryLimit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tests pass, showing OOM kill triggers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification of memory limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --memory</span><span style=\"color:#9ECBFF\"> 10m</span><span style=\"color:#9ECBFF\"> test/fixtures/minimal-rootfs</span><span style=\"color:#9ECBFF\"> /bin/sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"tail /dev/zero\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sleep</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -5</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"Memory cgroup out of memory\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: OOM killer message appears in dmesg</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run filesystem isolation tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./internal/filesystem/...</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestPivotRoot</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tests pass, showing filesystem isolation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --rootfs</span><span style=\"color:#9ECBFF\"> test/fixtures/busybox-rootfs</span><span style=\"color:#9ECBFF\"> /bin/ls</span><span style=\"color:#9ECBFF\"> /</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Shows container root directory, not host root</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run OverlayFS tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./internal/filesystem/...</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestOverlayMount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tests pass, showing copy-on-write behavior</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> /bin/sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"echo test > /modified &#x26;&#x26; ls /\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: File created successfully, visible in container</span></span></code></pre></div>\n\n<p><strong>Milestone 5 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run network tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./internal/network/...</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestBridgeNetwork</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tests pass, showing network connectivity</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network</span><span style=\"color:#9ECBFF\"> bridge</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#79B8FF\"> 8.8.8.8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Ping successful (requires internet connection)</span></span></code></pre></div>\n\n<p><strong>Milestone 6 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run full system tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./tests/system/...</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestContainerLifecycle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests pass, showing complete workflow</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># End-to-end validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> pull</span><span style=\"color:#9ECBFF\"> alpine:latest</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> sudo</span><span style=\"color:#9ECBFF\"> ./byod</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine:latest</span><span style=\"color:#9ECBFF\"> echo</span><span style=\"color:#9ECBFF\"> \"Hello, world!\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Image downloads, container runs, outputs message</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips-for-tests\">G. Debugging Tips for Tests</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Test passes locally but fails in CI</strong></td>\n<td>Different kernel version, missing kernel features</td>\n<td>Check kernel version, available cgroup controllers</td>\n<td>Skip test if feature unavailable, document requirements</td>\n</tr>\n<tr>\n<td><strong>Tests leave orphaned resources</strong></td>\n<td>Cleanup not running on test failure</td>\n<td>Use <code>t.Cleanup()</code>, check <code>/proc/mounts</code>, <code>/sys/fs/cgroup</code> after test</td>\n<td>Ensure cleanup runs even on panic, use defer with named return values</td>\n</tr>\n<tr>\n<td><strong>Intermittent test failures</strong></td>\n<td>Race conditions, timing issues</td>\n<td>Run with <code>-race</code> flag, add retries for eventual consistency</td>\n<td>Use proper synchronization, increase timeouts for slow operations</td>\n</tr>\n<tr>\n<td><strong>Permission denied even as root</strong></td>\n<td>AppArmor/SELinux restrictions, namespace permissions</td>\n<td>Check audit logs (<code>dmesg</code>, <code>journalctl</code>), test in permissive mode</td>\n<td>Adjust security policies, use correct flags for namespace operations</td>\n</tr>\n<tr>\n<td><strong>Network tests fail</strong></td>\n<td>Firewall rules, network namespace leaks</td>\n<td>List iptables rules, check network namespace count in <code>/proc</code></td>\n<td>Ensure proper cleanup, disable firewall temporarily for tests</td>\n</tr>\n<tr>\n<td><strong>Mount tests fail</strong></td>\n<td>Mount propagation, shared subtrees</td>\n<td>Check <code>/proc/self/mountinfo</code> for propagation flags</td>\n<td>Use <code>MS_PRIVATE</code> or <code>MS_SLAVE</code> for test mounts</td>\n</tr>\n<tr>\n<td><strong>Cgroup tests fail on cgroup v2</strong></td>\n<td>Different API, controller availability</td>\n<td>Check cgroup version at <code>/sys/fs/cgroup/cgroup.controllers</code></td>\n<td>Implement both v1 and v2 support, detect and adapt</td>\n</tr>\n<tr>\n<td><strong>Image pull tests timeout</strong></td>\n<td>Network issues, registry rate limiting</td>\n<td>Check HTTP logs, use smaller test images</td>\n<td>Mock registry for unit tests, use local image fixtures</td>\n</tr>\n</tbody></table>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (debugging is essential throughout all implementation stages)</p>\n</blockquote>\n<p>Debugging a container runtime presents unique challenges because we&#39;re interacting with multiple Linux kernel subsystems that create complex, layered isolation boundaries. When something goes wrong, the symptoms can manifest in unexpected ways—processes failing to start, resource limits not being enforced, network connectivity issues, or mysterious permission errors. This guide provides a systematic approach to diagnosing and fixing common problems you&#39;ll encounter while building your container runtime. Think of debugging a container runtime as being a building superintendent who can&#39;t enter the apartments directly—you have to use specialized tools to inspect what&#39;s happening inside each isolated unit without breaking the isolation itself.</p>\n<h3 id=\"symptom-cause-fix-tables\">Symptom → Cause → Fix Tables</h3>\n<p>These tables map observable symptoms to their root causes and provide concrete fixes. They&#39;re organized by the milestone areas where problems typically occur.</p>\n<h4 id=\"namespace-isolation-issues\">Namespace Isolation Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Process inside container can still see host processes</strong> (ps, top show host PIDs)</td>\n<td>PID namespace not properly set up or <code>/proc</code> not mounted in container&#39;s mount namespace</td>\n<td>Run <code>ls -la /proc/self/ns/pid</code> inside container to check namespace ID; compare with host&#39;s PID namespace. Check if <code>/proc</code> is mounted with <code>mount | grep proc</code>.</td>\n<td>Ensure <code>CLONE_NEWPID</code> flag is passed to <code>clone()</code> or <code>unshare()</code>. Use <code>pivot_root()</code> followed by mounting <code>/proc</code> inside the container with <code>mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;&quot;)</code>.</td>\n</tr>\n<tr>\n<td><strong>Container cannot set its own hostname</strong> (hostname command fails or shows host&#39;s hostname)</td>\n<td>Missing <code>CLONE_NEWUTS</code> flag or UTS namespace not created</td>\n<td>Check <code>/proc/self/ns/uts</code> inside container vs host. Try running <code>hostname newname</code>—if it succeeds but isn&#39;t isolated, UTS namespace is missing.</td>\n<td>Add <code>CLONE_NEWUTS</code> to namespace creation flags. Verify the <code>sethostname()</code> syscall is called after namespace creation but before <code>execve()</code>.</td>\n</tr>\n<tr>\n<td><strong>Mount/unmount operations in container affect host filesystem</strong></td>\n<td>Missing <code>CLONE_NEWNS</code> (mount namespace) flag</td>\n<td>Create a temporary directory, mount a tmpfs inside container, then check if it appears on host with <code>mount | grep tmpfs</code>.</td>\n<td>Ensure <code>CLONE_NEWNS</code> is included. Note: In Go, this is <code>syscall.CLONE_NEWNS</code> (all mount namespace operations use this single flag).</td>\n</tr>\n<tr>\n<td><strong>Container cannot create shared memory segments</strong></td>\n<td>IPC namespace not isolated (<code>CLONE_NEWIPC</code> missing)</td>\n<td>Try creating a shared memory segment with <code>shmget()</code> inside container and check if host processes can see it with <code>ipcs -m</code>.</td>\n<td>Add <code>CLONE_NEWIPC</code> flag. Also ensure semaphore and message queue isolation if those are needed.</td>\n</tr>\n<tr>\n<td><strong>User ID mapping issues</strong> (permission denied on files that should be accessible)</td>\n<td>User namespace not set up or <code>/etc/passwd</code> not mapped correctly</td>\n<td>Check <code>/proc/self/uid_map</code> and <code>/proc/self/gid_map</code> inside container. Verify files have correct ownership.</td>\n<td>Implement user namespace with <code>CLONE_NEWUSER</code>, write appropriate mappings to <code>/proc/self/uid_map</code> and <code>/proc/self/gid_map</code> before executing container process.</td>\n</tr>\n<tr>\n<td><strong>Container process exits immediately with &quot;operation not permitted&quot;</strong></td>\n<td>Insufficient capabilities when using namespaces</td>\n<td>Check <code>dmesg | tail</code> for kernel capability warnings. Try running container runtime as root.</td>\n<td>Grant necessary capabilities (CAP_SYS_ADMIN for mount operations, CAP_NET_ADMIN for network setup) or run as root during development.</td>\n</tr>\n</tbody></table>\n<h4 id=\"cgroup-resource-limit-issues\">cgroup Resource Limit Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory limit not enforced</strong> (container uses more memory than specified)</td>\n<td>Memory cgroup controller not enabled or limits written to wrong file</td>\n<td>Check <code>/sys/fs/cgroup/memory/memory.limit_in_bytes</code> (v1) or <code>/sys/fs/cgroup/container-&lt;id&gt;/memory.max</code> (v2). Verify controller is available: <code>cat /proc/cgroups | grep memory</code>.</td>\n<td>Ensure memory controller is mounted and available. Write limit in bytes to correct control file. For v2, also check <code>memory.swap.max</code>.</td>\n</tr>\n<tr>\n<td><strong>Container not OOM-killed when exceeding memory limit</strong></td>\n<td>Memory limit set but OOM killer disabled or swap allowed</td>\n<td>Check <code>memory.oom_control</code> (v1) or <code>memory.oom.group</code> (v2). Verify swap limit: <code>memory.memsw.limit_in_bytes</code> (v1) or <code>memory.swap.max</code> (v2).</td>\n<td>Disable swap by setting swap limit equal to memory limit. Enable OOM killer: <code>echo 1 &gt; memory.oom_control</code> (v1) or set <code>memory.oom.group</code> (v2).</td>\n</tr>\n<tr>\n<td><strong>CPU limit not respected</strong> (container uses 100% CPU despite shares/quota)</td>\n<td>CPU controller not enabled or wrong control files used</td>\n<td>Check CPU usage via <code>top</code> or <code>cat /sys/fs/cgroup/cpu,cpuacct/cpuacct.usage</code>. Verify <code>cpu.shares</code> (v1) or <code>cpu.weight</code> (v2) values.</td>\n<td>For v1, set <code>cpu.cfs_period_us</code> and <code>cpu.cfs_quota_us</code>. For v2, set <code>cpu.max</code> with format <code>max 100000</code>.</td>\n</tr>\n<tr>\n<td><strong>PIDs limit not working</strong> (container can fork unlimited processes)</td>\n<td><code>pids</code> controller not enabled or limit not set</td>\n<td>Check <code>pids.current</code> vs <code>pids.max</code> in cgroup directory. Verify controller is in <code>/proc/cgroups</code>.</td>\n<td>Enable <code>pids</code> controller. Write limit to <code>pids.max</code> (both v1 and v2 use same interface).</td>\n</tr>\n<tr>\n<td><strong>cgroup cleanup fails</strong> (&quot;device or resource busy&quot; error)</td>\n<td>Processes still running in cgroup or subcgroups exist</td>\n<td>Check <code>cgroup.procs</code> and <code>tasks</code> files for remaining PIDs. Look for nested cgroups: <code>ls /sys/fs/cgroup/memory/&lt;container-id&gt;/</code>.</td>\n<td>Kill all processes in cgroup before removal. Use <code>cgdelete</code> or recursively remove subdirectories.</td>\n</tr>\n<tr>\n<td><strong>cgroup v2 vs v1 detection fails</strong></td>\n<td>Hybrid or mixed hierarchy on system</td>\n<td>Check <code>/proc/filesystems</code> for <code>cgroup2</code>. Examine mount points: <code>mount | grep cgroup</code>.</td>\n<td>Use <code>CgroupManager.DetectCgroupInfo()</code> to detect version and available controllers. Support both versions with fallback.</td>\n</tr>\n</tbody></table>\n<h4 id=\"filesystem-isolation-issues\">Filesystem Isolation Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container cannot see /proc or /sys</strong> (ps, top fail)</td>\n<td><code>/proc</code> and <code>/sys</code> not mounted after <code>pivot_root()</code></td>\n<td>Run <code>mount | grep -E &quot;proc|sys&quot;</code> inside container. Check if directories exist in rootfs.</td>\n<td>Call <code>MountProc()</code> and <code>MountSys()</code> after <code>pivot_root()</code> but before <code>execve()</code>.</td>\n</tr>\n<tr>\n<td><strong>Container can still access host filesystem</strong></td>\n<td><code>pivot_root()</code> succeeded but old root not unmounted</td>\n<td>Check <code>mount | grep /oldroot</code> or try accessing <code>/oldroot/etc/passwd</code> from container.</td>\n<td>Unmount old root with <code>MNT_DETACH</code>: <code>unmount(&quot;/oldroot&quot;, MNT_DETACH)</code>.</td>\n</tr>\n<tr>\n<td><strong>Permission denied on device nodes</strong> (<code>/dev/null</code>, <code>/dev/zero</code>)</td>\n<td>Device nodes not created in container&#39;s <code>/dev</code></td>\n<td>Try <code>ls -la /dev/null</code> inside container. Check if major/minor numbers are correct.</td>\n<td>Call <code>SetupDev()</code> to create basic device nodes with <code>mknod()</code> using appropriate major/minor numbers.</td>\n</tr>\n<tr>\n<td><strong>Container startup fails with &quot;no such file or directory&quot;</strong> on binary</td>\n<td>Rootfs missing shared libraries or binary not in <code>PATH</code></td>\n<td>Use <code>ldd</code> on binary inside rootfs to check missing libraries. Verify <code>PATH</code> environment variable.</td>\n<td>Use complete rootfs from base image (alpine, ubuntu). Set correct <code>PATH</code> in <code>ContainerConfig.Env</code>.</td>\n</tr>\n<tr>\n<td><strong>Files created in container disappear after exit</strong></td>\n<td>Using <code>chroot()</code> without mount namespace or wrong upperdir in OverlayFS</td>\n<td>Check if files exist in upperdir of OverlayFS after container stops. Verify mount propagation.</td>\n<td>Use <code>pivot_root()</code> with mount namespace. For OverlayFS, ensure writes go to upperdir and it&#39;s preserved.</td>\n</tr>\n<tr>\n<td><strong>Mount propagation doesn&#39;t work</strong> (mounts in container not visible in sub-mounts)</td>\n<td>Mount namespace setup with wrong propagation flags</td>\n<td>Check <code>/proc/self/mountinfo</code> for propagation flags (<code>shared</code>, <code>private</code>, <code>slave</code>).</td>\n<td>Set root mount as <code>MS_PRIVATE</code> before <code>pivot_root()</code>: <code>mount(&quot;&quot;, &quot;/&quot;, &quot;&quot;, MS_REC|MS_PRIVATE, &quot;&quot;)</code>.</td>\n</tr>\n</tbody></table>\n<h4 id=\"overlayfs-issues\">OverlayFS Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>&quot;Invalid argument&quot; when mounting OverlayFS</strong></td>\n<td>Missing lowerdir, upperdir, or workdir directories</td>\n<td>Check <code>dmesg | tail</code> for kernel OverlayFS errors. Verify all directories exist with correct permissions.</td>\n<td>Create lowerdir, upperdir, workdir directories before mount. Ensure workdir is empty.</td>\n</tr>\n<tr>\n<td><strong>File modifications not persisted</strong> (writes disappear)</td>\n<td>Upperdir not writable or OverlayFS mounted read-only</td>\n<td>Check mount options: <code>mount | grep overlay</code>. Verify permissions on upperdir: <code>ls -ld upperdir</code>.</td>\n<td>Ensure upperdir has write permissions. Include <code>lowerdir=...,upperdir=...,workdir=...</code> in mount options.</td>\n</tr>\n<tr>\n<td><strong>Whiteout files not working</strong> (deleted files reappear)</td>\n<td>Whiteout special files not created properly</td>\n<td>Check upperdir for files with <code>chardev 0:0</code> (whiteout). Use <code>ls -la upperdir</code> and look for character devices.</td>\n<td>When deleting files in container, create whiteout device in upperdir: <code>mknod(&quot;whiteout&quot;, S_IFCHR, 0)</code>.</td>\n</tr>\n<tr>\n<td><strong>Copy-on-write causes high CPU/I/O</strong></td>\n<td>Too many small files triggering copy-up</td>\n<td>Monitor <code>cp</code> operations during container run. Check if upperdir grows unexpectedly.</td>\n<td>This is expected behavior; consider using <code>nocopy</code> mount option for read-only lower layers where appropriate.</td>\n</tr>\n<tr>\n<td><strong>OverlayFS mount fails on certain filesystems</strong> (e.g., NFS)</td>\n<td>Underlying filesystem not supporting OverlayFS features</td>\n<td>Check kernel logs: <code>dmesg | grep overlay</code>. Test with ext4 or xfs as backing filesystem.</td>\n<td>Use supported filesystem (ext4, xfs, btrfs) for storage directory.</td>\n</tr>\n<tr>\n<td><strong>Multiple containers sharing layers cause conflicts</strong></td>\n<td>Same upperdir used by multiple containers</td>\n<td>Check if upperdir paths are unique per container. Verify containers don&#39;t share workdir.</td>\n<td>Generate unique upperdir and workdir per container using container ID in path.</td>\n</tr>\n</tbody></table>\n<h4 id=\"container-networking-issues\">Container Networking Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container has no network connectivity</strong> (ping fails)</td>\n<td>veth pair not set up correctly or no default route</td>\n<td>Check interfaces inside container: <code>ip link show</code>. Verify default route: <code>ip route show</code>.</td>\n<td>Ensure veth pair created, moved to container namespace, and configured with IP. Add default route to gateway.</td>\n</tr>\n<tr>\n<td><strong>Container cannot reach external internet</strong></td>\n<td>NAT masquerading not configured</td>\n<td>Check iptables rules: <code>iptables -t nat -L -n</code>. Verify <code>FORWARD</code> chain policy is <code>ACCEPT</code>.</td>\n<td>Call <code>IPTablesManager.SetupMasquerade()</code> to add <code>POSTROUTING</code> masquerade rule. Enable IP forwarding: <code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code>.</td>\n</tr>\n<tr>\n<td><strong>Port forwarding not working</strong> (can&#39;t connect to host port)</td>\n<td>iptables rules missing or wrong interface</td>\n<td>Check DNAT rules: <code>iptables -t nat -L PREROUTING -n</code>. Verify traffic reaches bridge interface.</td>\n<td>Add rule with <code>IPTablesManager.AddPortForwarding()</code> that matches protocol, host port, and redirects to container IP:port.</td>\n</tr>\n<tr>\n<td><strong>DNS resolution fails inside container</strong></td>\n<td><code>/etc/resolv.conf</code> not configured</td>\n<td>Try <code>nslookup google.com</code> inside container. Check <code>/etc/resolv.conf</code> contents.</td>\n<td>Copy host&#39;s <code>/etc/resolv.conf</code> or create one with nameserver <code>8.8.8.8</code> in container rootfs before start.</td>\n</tr>\n<tr>\n<td><strong>Containers on same bridge cannot ping each other</strong></td>\n<td>Bridge not set up or firewall blocking</td>\n<td>Check bridge membership: <code>brctl show</code>. Verify containers have IPs in same subnet.</td>\n<td>Ensure both veth ends are connected to same bridge. Disable firewall or add accept rules for bridge traffic.</td>\n</tr>\n<tr>\n<td><strong>Network namespace cleanup fails</strong> (veth left on host)</td>\n<td>veth not deleted when container stops</td>\n<td>Check leftover veth interfaces: <code>ip link show | grep veth</code>.</td>\n<td>Delete veth pair in host namespace during <code>NetworkManager.CleanupNetwork()</code>.</td>\n</tr>\n<tr>\n<td><strong>&quot;Network is unreachable&quot; for loopback</strong></td>\n<td>Loopback interface not up in container</td>\n<td>Check <code>ip link show lo</code> inside container—should be <code>UP</code>.</td>\n<td>Bring loopback up: <code>ip link set lo up</code> inside network namespace.</td>\n</tr>\n</tbody></table>\n<h4 id=\"image-and-cli-issues\">Image and CLI Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Image pull fails with &quot;manifest not found&quot;</strong></td>\n<td>Wrong image reference format or tag missing</td>\n<td>Check image ref parsing. Verify tag exists on registry: <code>curl -L https://registry.hub.docker.com/v2/library/alpine/tags/list</code>.</td>\n<td>Use standard format: <code>image:tag</code> (default to <code>latest</code>). Handle Docker Hub vs other registries.</td>\n</tr>\n<tr>\n<td><strong>Layer extraction fails with &quot;invalid tar header&quot;</strong></td>\n<td>Corrupted layer download or wrong compression</td>\n<td>Verify layer digest matches. Check file type: <code>file layer.tar</code>.</td>\n<td>Use <code>ImageStore.StoreBlob()</code> which verifies digest. Support multiple compression formats (gzip, zstd).</td>\n</tr>\n<tr>\n<td><strong>Container starts but immediately exits</strong></td>\n<td>Entrypoint command not found or fails</td>\n<td>Check container logs (stdout/stderr). Verify <code>ImageConfig.Entrypoint</code> and <code>Cmd</code> are valid.</td>\n<td>Provide fallback to <code>/bin/sh</code> if no command specified. Log exit code and signal.</td>\n</tr>\n<tr>\n<td><strong>State file corruption after crash</strong></td>\n<td>Concurrent writes to container state or partial write</td>\n<td>Check <code>ContainerStore.Save()</code> for atomic write pattern. Verify file permissions.</td>\n<td>Use atomic file write: write to temp file then rename. Add file locking with <code>sync.Mutex</code>.</td>\n</tr>\n<tr>\n<td><strong>CLI command hangs indefinitely</strong></td>\n<td>Container process waiting for input or deadlock</td>\n<td>Check if process is running with <code>ps aux | grep &lt;container-id&gt;</code>. Look for open file descriptors.</td>\n<td>Implement timeout for <code>StartCommand()</code>. Ensure stdin is properly handled (close or connect to terminal).</td>\n</tr>\n<tr>\n<td><strong>&quot;Container already exists&quot; error</strong></td>\n<td>Container ID collision or stale state file</td>\n<td>Check if container ID already in <code>StateManager.containers</code> map. Look for leftover directories.</td>\n<td>Use UUID with <code>uuid.Generate()</code> for uniqueness. Clean up stale state on startup with orphan detection.</td>\n</tr>\n</tbody></table>\n<h3 id=\"domain-specific-debugging-techniques\">Domain-Specific Debugging Techniques</h3>\n<p>Debugging container runtimes requires specialized techniques that account for the layered isolation. These methods allow you to peer inside containers without breaking their isolation boundaries.</p>\n<h4 id=\"the-quotinceptionquot-debugging-method\">The &quot;Inception&quot; Debugging Method</h4>\n<blockquote>\n<p><strong>Mental Model:</strong> Think of debugging containers like the movie Inception—you need to enter nested dream levels (namespaces) to see what&#39;s really happening. But unlike the movie, you can use special kernel APIs to project yourself into these isolated spaces without actually entering them.</p>\n</blockquote>\n<p>The key insight is that you can attach to namespaces from outside using <code>/proc</code> filesystem entries. Every process has a symbolic link for each namespace type at <code>/proc/&lt;pid&gt;/ns/&lt;type&gt;</code>. By opening these files, you can perform operations in the context of that namespace.</p>\n<p><strong>Technique 1: Inspecting Namespace Membership</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># From host, find container process PID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CONTAINER_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"container-id\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check which namespaces it's in</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$CONTAINER_PID</span><span style=\"color:#9ECBFF\">/ns/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Compare namespace IDs with host</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">readlink</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$CONTAINER_PID</span><span style=\"color:#9ECBFF\">/ns/pid</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">readlink</span><span style=\"color:#9ECBFF\"> /proc/self/ns/pid</span></span></code></pre></div>\n<p>If the namespace IDs match, isolation isn&#39;t working. Each namespace should have a unique ID.</p>\n<p><strong>Technique 2: Entering Network Namespace for Debugging</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Use nsenter to run commands in container's network namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nsenter</span><span style=\"color:#79B8FF\"> --net=/proc/</span><span style=\"color:#E1E4E8\">$CONTAINER_PID</span><span style=\"color:#79B8FF\">/ns/net</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> addr</span><span style=\"color:#9ECBFF\"> show</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nsenter</span><span style=\"color:#79B8FF\"> --net=/proc/</span><span style=\"color:#E1E4E8\">$CONTAINER_PID</span><span style=\"color:#79B8FF\">/ns/net</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#79B8FF\"> 8.8.8.8</span></span></code></pre></div>\n<p>This lets you see exactly what network interfaces and routes the container sees.</p>\n<p><strong>Technique 3: Mount Namespace Inspection</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># View container's mount table from outside</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nsenter</span><span style=\"color:#79B8FF\"> --mount=/proc/</span><span style=\"color:#E1E4E8\">$CONTAINER_PID</span><span style=\"color:#79B8FF\">/ns/mnt</span><span style=\"color:#9ECBFF\"> mount</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$CONTAINER_PID</span><span style=\"color:#9ECBFF\">/mountinfo</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> overlay</span></span></code></pre></div>\n<p>The <code>mountinfo</code> file shows the complete mount tree with propagation flags.</p>\n<h4 id=\"the-quotresource-accountingquot-audit\">The &quot;Resource Accounting&quot; Audit</h4>\n<p>When cgroups aren&#39;t working properly, you need to audit the entire resource control hierarchy.</p>\n<p><strong>Technique 4: cgroup Hierarchy Walk</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># For cgroup v2</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">find</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup</span><span style=\"color:#79B8FF\"> -name</span><span style=\"color:#9ECBFF\"> \"container-*\"</span><span style=\"color:#79B8FF\"> -type</span><span style=\"color:#9ECBFF\"> d</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> xargs</span><span style=\"color:#79B8FF\"> -I</span><span style=\"color:#9ECBFF\"> {}</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> 'echo {}; cat {}/cgroup.procs'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check specific controller limits</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/container-abc123/memory.max</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/container-abc123/cpu.max</span></span></code></pre></div>\n\n<p><strong>Technique 5: Real-time Resource Monitoring</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Watch memory usage of container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">watch</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#9ECBFF\"> 'cat /sys/fs/cgroup/container-abc123/memory.current'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor CPU usage via cpuacct</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"CPU usage (nanoseconds): $(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/container-abc123/cpu.stat </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> usage_usec)\"</span></span></code></pre></div>\n\n<h4 id=\"the-quotfilesystem-forensicsquot-approach\">The &quot;Filesystem Forensics&quot; Approach</h4>\n<p>When filesystem isolation fails, you need to understand the exact mount hierarchy and where writes are actually going.</p>\n<p><strong>Technique 6: OverlayFS Layer Inspection</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Find container's merged directory</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">find</span><span style=\"color:#9ECBFF\"> /var/lib/container-runtime</span><span style=\"color:#79B8FF\"> -name</span><span style=\"color:#9ECBFF\"> \"merged\"</span><span style=\"color:#79B8FF\"> -type</span><span style=\"color:#9ECBFF\"> d</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> container-id</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check what's in each layer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /var/lib/container-runtime/layers/sha256:abc123/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /var/lib/container-runtime/containers/container-id/upper/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># See copy-on-write in action</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">strace</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> openat,rename,unlink,write</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">container-process-pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> overlay</span></span></code></pre></div>\n\n<p><strong>Technique 7: Bind Mount Debugging</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create a debug bind mount from host into container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> /tmp/container-debug</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#79B8FF\"> --bind</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$CONTAINER_PID</span><span style=\"color:#9ECBFF\">/root</span><span style=\"color:#9ECBFF\"> /tmp/container-debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Now inspect container rootfs from host</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /tmp/container-debug/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /tmp/container-debug/etc/os-release</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Clean up</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">umount</span><span style=\"color:#9ECBFF\"> /tmp/container-debug</span></span></code></pre></div>\n\n<h4 id=\"the-quotnetwork-packet-surgeryquot\">The &quot;Network Packet Surgery&quot;</h4>\n<p>For networking issues, you need to trace packets through the entire network stack—from container interface to host bridge to external network.</p>\n<p><strong>Technique 8: Packet Tracing with tcpdump</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Capture on container veth interface</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">tcpdump</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> vethabc123</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Capture on bridge interface</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">tcpdump</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> br0</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Capture in container namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nsenter</span><span style=\"color:#79B8FF\"> --net=/proc/</span><span style=\"color:#E1E4E8\">$CONTAINER_PID</span><span style=\"color:#79B8FF\">/ns/net</span><span style=\"color:#9ECBFF\"> tcpdump</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> eth0</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Technique 9: iptables Rule Tracing</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Add trace rule for specific traffic</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> raw</span><span style=\"color:#79B8FF\"> -A</span><span style=\"color:#9ECBFF\"> PREROUTING</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> tcp</span><span style=\"color:#79B8FF\"> --dport</span><span style=\"color:#79B8FF\"> 80</span><span style=\"color:#79B8FF\"> -j</span><span style=\"color:#9ECBFF\"> TRACE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Watch kernel logs for trace output</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#79B8FF\"> -w</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> TRACE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check packet flow through chains</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> filter</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<h4 id=\"the-quotprocess-relationship-mappingquot\">The &quot;Process Relationship Mapping&quot;</h4>\n<p>Understanding parent-child relationships and process trees across namespaces is critical for PID namespace issues.</p>\n<p><strong>Technique 10: Cross-Namespace Process Tree</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Show process tree with namespace contexts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> ax</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> pid,ppid,pgid,sid,tty,time,comm,ns</span><span style=\"color:#79B8FF\"> --forest</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Find all processes in specific PID namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> '^[0-9]'</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-e</span><span style=\"color:#E1E4E8\"> /proc/$pid/ns/pid ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ns</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">readlink</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$pid</span><span style=\"color:#9ECBFF\">/ns/pid</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$ns</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$CONTAINER_NS</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      echo</span><span style=\"color:#9ECBFF\"> \"PID </span><span style=\"color:#E1E4E8\">$pid</span><span style=\"color:#9ECBFF\"> is in container namespace\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      cat</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$pid</span><span style=\"color:#9ECBFF\">/cmdline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n\n<h3 id=\"tools-for-inspecting-system-state\">Tools for Inspecting System State</h3>\n<p>The Linux ecosystem provides powerful tools for inspecting the kernel state that underpins container isolation. Mastering these tools is essential for effective debugging.</p>\n<h4 id=\"namespace-inspection-tools\">Namespace Inspection Tools</h4>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Purpose</th>\n<th>Example Command</th>\n<th>What It Reveals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>lsns</code></strong></td>\n<td>List all namespaces on system</td>\n<td><code>lsns -t pid</code></td>\n<td>Shows PID namespaces with process counts and PIDs</td>\n</tr>\n<tr>\n<td><strong><code>nsenter</code></strong></td>\n<td>Enter one or more namespaces</td>\n<td><code>nsenter -t $PID -m -u -n -p /bin/bash</code></td>\n<td>Spawns shell in container&#39;s combined namespaces</td>\n</tr>\n<tr>\n<td><strong><code>unshare</code></strong></td>\n<td>Run program in new namespaces</td>\n<td><code>unshare --pid --fork --mount-proc=/proc /bin/bash</code></td>\n<td>Tests namespace creation independently of runtime</td>\n</tr>\n<tr>\n<td><strong><code>/proc/&lt;pid&gt;/ns/</code></strong></td>\n<td>Namespace file descriptors</td>\n<td><code>readlink /proc/self/ns/mnt</code></td>\n<td>Gets namespace ID for comparison</td>\n</tr>\n<tr>\n<td><strong><code>/proc/&lt;pid&gt;/status</code></strong></td>\n<td>Namespace membership</td>\n<td><code>grep NSpid /proc/$PID/status</code></td>\n<td>Shows PID in each ancestor PID namespace</td>\n</tr>\n</tbody></table>\n<h4 id=\"cgroup-inspection-tools\">cgroup Inspection Tools</h4>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Purpose</th>\n<th>Example Command</th>\n<th>What It Reveals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>systemd-cgls</code></strong></td>\n<td>Show cgroup hierarchy</td>\n<td><code>systemd-cgls -u</code></td>\n<td>Visual tree of cgroups and their processes</td>\n</tr>\n<tr>\n<td><strong><code>systemd-cgtop</code></strong></td>\n<td>Resource usage per cgroup</td>\n<td><code>systemd-cgtop</code></td>\n<td>Real-time CPU/memory usage by cgroup</td>\n</tr>\n<tr>\n<td><strong><code>cgget</code></strong></td>\n<td>Get cgroup parameters</td>\n<td><code>cgget -g memory:container-id</code></td>\n<td>Reads control file values for specific cgroup</td>\n</tr>\n<tr>\n<td><strong><code>cat /proc/cgroups</code></strong></td>\n<td>List available controllers</td>\n<td><code>cat /proc/cgroups</code></td>\n<td>Shows which controllers are enabled and hierarchy count</td>\n</tr>\n<tr>\n<td><strong><code>findmnt cgroup</code></strong></td>\n<td>Find cgroup mount points</td>\n<td><code>findmnt -t cgroup2</code></td>\n<td>Shows where cgroup filesystems are mounted</td>\n</tr>\n</tbody></table>\n<h4 id=\"filesystem-inspection-tools\">Filesystem Inspection Tools</h4>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Purpose</th>\n<th>Example Command</th>\n<th>What It Reveals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>findmnt</code></strong></td>\n<td>Show mount tree</td>\n<td><code>findmnt -R /var/lib/container-runtime</code></td>\n<td>Complete mount hierarchy with options and propagation</td>\n</tr>\n<tr>\n<td><strong><code>mount</code></strong></td>\n<td>List mounted filesystems</td>\n<td><code>mount | grep overlay</code></td>\n<td>All active mounts with their types and options</td>\n</tr>\n<tr>\n<td><strong><code>lsof</code></strong></td>\n<td>List open files</td>\n<td><code>lsof +D /var/lib/container-runtime/containers/</code></td>\n<td>Which processes have files open in container directories</td>\n</tr>\n<tr>\n<td><strong><code>strace</code></strong></td>\n<td>Trace system calls</td>\n<td><code>strace -f -e mount,pivot_root,chdir &lt;pid&gt;</code></td>\n<td>Exact sequence of filesystem operations performed</td>\n</tr>\n<tr>\n<td><strong><code>inotifywait</code></strong></td>\n<td>Monitor filesystem events</td>\n<td><code>inotifywait -rm /var/lib/container-runtime/</code></td>\n<td>Real-time notifications of file creation, deletion, modification</td>\n</tr>\n</tbody></table>\n<h4 id=\"network-inspection-tools\">Network Inspection Tools</h4>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Purpose</th>\n<th>Example Command</th>\n<th>What It Reveals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>ip netns</code></strong></td>\n<td>Network namespace management</td>\n<td><code>ip netns list</code></td>\n<td>All network namespaces and their associated PIDs</td>\n</tr>\n<tr>\n<td><strong><code>ip link</code></strong></td>\n<td>Network interface listing</td>\n<td><code>ip -o link show | grep veth</code></td>\n<td>All veth interfaces and their peer indices</td>\n</tr>\n<tr>\n<td><strong><code>bridge</code></strong></td>\n<td>Bridge management</td>\n<td><code>bridge link show</code></td>\n<td>Which interfaces are connected to bridges</td>\n</tr>\n<tr>\n<td><strong><code>conntrack</code></strong></td>\n<td>Connection tracking</td>\n<td><code>conntrack -L | grep container-ip</code></td>\n<td>NAT translations and connection states</td>\n</tr>\n<tr>\n<td><strong><code>ss</code></strong></td>\n<td>Socket statistics</td>\n<td><code>ss -tulpn | grep $CONTAINER_PID</code></td>\n<td>Open ports and sockets in container</td>\n</tr>\n</tbody></table>\n<h4 id=\"process-and-container-specific-tools\">Process and Container-Specific Tools</h4>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Purpose</th>\n<th>Example Command</th>\n<th>What It Reveals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>pstree</code></strong></td>\n<td>Process tree visualization</td>\n<td><code>pstree -p $CONTAINER_PID</code></td>\n<td>Parent-child relationships across namespaces</td>\n</tr>\n<tr>\n<td><strong><code>cat /proc/&lt;pid&gt;/cgroup</code></strong></td>\n<td>Process cgroup membership</td>\n<td><code>cat /proc/$PID/cgroup</code></td>\n<td>Which cgroups the process belongs to for each controller</td>\n</tr>\n<tr>\n<td><strong><code>cat /proc/&lt;pid&gt;/mountinfo</code></strong></td>\n<td>Process mount namespace</td>\n<td><code>cat /proc/$PID/mountinfo | head -20</code></td>\n<td>Mount points visible to the process with IDs and options</td>\n</tr>\n<tr>\n<td><strong><code>capsh</code></strong></td>\n<td>Capability inspection</td>\n<td><code>capsh --decode=$(cat /proc/$PID/status | grep CapEff | awk &#39;{print $2}&#39;)</code></td>\n<td>Effective capabilities of the process</td>\n</tr>\n<tr>\n<td><strong><code>runc</code></strong></td>\n<td>Reference OCI runtime</td>\n<td><code>runc events container-id</code></td>\n<td>Container lifecycle events from reference implementation</td>\n</tr>\n</tbody></table>\n<h4 id=\"custom-debugging-utilities-for-your-runtime\">Custom Debugging Utilities for Your Runtime</h4>\n<p>You should build these debugging aids directly into your container runtime:</p>\n<ol>\n<li><p><strong>Debug Mode Flag</strong>: Add <code>--debug</code> flag to CLI that enables verbose logging of all system calls and operations.</p>\n</li>\n<li><p><strong>Inspection Subcommands</strong>:</p>\n<ul>\n<li><code>container-runtime inspect &lt;container-id&gt;</code>: Show complete container state including namespace IDs, cgroup paths, mount points, and network configuration.</li>\n<li><code>container-runtime debug exec &lt;container-id&gt; &lt;command&gt;</code>: Execute command in container namespaces without starting the container process.</li>\n<li><code>container-runtime logs &lt;container-id&gt;</code>: Capture and display stdout/stderr from container process.</li>\n</ul>\n</li>\n<li><p><strong>State Dump on Failure</strong>: When a container fails to start, automatically dump:</p>\n<ul>\n<li>Current namespace IDs</li>\n<li>cgroup hierarchy</li>\n<li>Mount table</li>\n<li>Network interfaces</li>\n<li>Last 20 lines of kernel log (<code>dmesg</code>)</li>\n</ul>\n</li>\n<li><p><strong>Orphan Detection Cleanup</strong>: Periodically scan for resources (cgroups, network namespaces, mount points) that don&#39;t have corresponding container state records and clean them up.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> The most powerful debugging technique is building observability directly into your runtime. Instrument every major operation with structured logging that includes the container ID, namespace IDs, and resource paths. When something fails, you&#39;ll have a complete audit trail of what was attempted and where it went wrong.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides practical implementation guidance for adding debugging capabilities to your container runtime.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Logging</strong></td>\n<td>Structured logging with <code>logrus</code> or <code>zap</code></td>\n<td>OpenTelemetry tracing with Jaeger</td>\n</tr>\n<tr>\n<td><strong>Inspection</strong></td>\n<td>CLI commands using <code>nsenter</code> and <code>cgget</code></td>\n<td>HTTP API with WebSocket for real-time metrics</td>\n</tr>\n<tr>\n<td><strong>Tracing</strong></td>\n<td><code>strace</code> wrapper for system call tracing</td>\n<td>eBPF-based tracing with <code>bcc</code> tools</td>\n</tr>\n<tr>\n<td><strong>Metrics</strong></td>\n<td>Reading cgroup stats files directly</td>\n<td>Prometheus metrics exporter</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    container-runtime/\n      main.go              # CLI entry point with debug flags\n      debug.go             # Debug subcommands implementation\n  internal/\n    debug/\n      inspector.go         # Container state inspection logic\n      tracer.go            # System call tracing wrapper\n      metrics.go           # Metrics collection from cgroups\n    runtime/\n      container.go         # Add debug methods to Container type\n      manager.go           # Add inspection methods to ContainerRuntime\n    utils/\n      nsenter.go           # Wrapper for nsenter operations\n      cgroup-inspect.go    # cgroup inspection utilities</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Here&#39;s a complete, ready-to-use debugging inspector that can be integrated into your runtime:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/debug/inspector.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io/ioutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/sirupsen/logrus</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerInspector provides methods to inspect container state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerInspector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    basePath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">logrus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewContainerInspector creates a new inspector instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewContainerInspector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">basePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerInspector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ContainerInspector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        basePath: basePath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger:   logrus.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InspectContainer gathers comprehensive debugging information about a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ci </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InspectContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    info </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Basic container info</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    info[</span><span style=\"color:#9ECBFF\">\"container_id\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> containerID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    info[</span><span style=\"color:#9ECBFF\">\"timestamp\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(time.RFC3339)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to find container process</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pid, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ci.</span><span style=\"color:#B392F0\">findContainerPID</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ci.logger.</span><span style=\"color:#B392F0\">Warnf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Could not find container process: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        info[</span><span style=\"color:#9ECBFF\">\"pid\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Collect namespace information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nsInfo, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ci.</span><span style=\"color:#B392F0\">collectNamespaceInfo</span><span style=\"color:#E1E4E8\">(pid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ci.logger.</span><span style=\"color:#B392F0\">Warnf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Could not collect namespace info: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            info[</span><span style=\"color:#9ECBFF\">\"namespaces\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nsInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Collect cgroup information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cgroupInfo, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ci.</span><span style=\"color:#B392F0\">collectCgroupInfo</span><span style=\"color:#E1E4E8\">(pid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ci.logger.</span><span style=\"color:#B392F0\">Warnf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Could not collect cgroup info: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            info[</span><span style=\"color:#9ECBFF\">\"cgroups\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cgroupInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Collect mount information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mountInfo, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ci.</span><span style=\"color:#B392F0\">collectMountInfo</span><span style=\"color:#E1E4E8\">(pid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ci.logger.</span><span style=\"color:#B392F0\">Warnf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Could not collect mount info: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            info[</span><span style=\"color:#9ECBFF\">\"mounts\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mountInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Collect container filesystem information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fsInfo, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ci.</span><span style=\"color:#B392F0\">collectFilesystemInfo</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ci.logger.</span><span style=\"color:#B392F0\">Warnf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Could not collect filesystem info: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        info[</span><span style=\"color:#9ECBFF\">\"filesystem\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fsInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Collect network information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    netInfo, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ci.</span><span style=\"color:#B392F0\">collectNetworkInfo</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ci.logger.</span><span style=\"color:#B392F0\">Warnf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Could not collect network info: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        info[</span><span style=\"color:#9ECBFF\">\"network\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> netInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> info, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// findContainerPID searches for the container's main process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ci </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">findContainerPID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check in container state directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(ci.basePath, </span><span style=\"color:#9ECBFF\">\"containers\"</span><span style=\"color:#E1E4E8\">, containerID, </span><span style=\"color:#9ECBFF\">\"state.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(statePath); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(statePath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> state </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Pid </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"pid\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> state.Pid </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Verify process still exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, state.Pid))); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> state.Pid, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fallback: search through all processes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ci.</span><span style=\"color:#B392F0\">scanProcessesForContainer</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// collectNamespaceInfo reads namespace IDs from /proc/&#x3C;pid>/ns/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ci </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">collectNamespaceInfo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nsInfo </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nsTypes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"pid\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"mnt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"net\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"uts\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ipc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, nsType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> nsTypes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nsPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid), </span><span style=\"color:#9ECBFF\">\"ns\"</span><span style=\"color:#E1E4E8\">, nsType)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        target, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Readlink</span><span style=\"color:#E1E4E8\">(nsPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nsInfo[nsType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> target</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> nsInfo, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DumpToFile writes inspection results to a JSON file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ci </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DumpToFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">outputPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    info, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ci.</span><span style=\"color:#B392F0\">InspectContainer</span><span style=\"color:#E1E4E8\">(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">MarshalIndent</span><span style=\"color:#E1E4E8\">(info, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(outputPath, data, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>Here&#39;s skeleton code for adding debug commands to your CLI:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cmd/container-runtime/debug.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/spf13/cobra</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/debug</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDebugCommand creates the debug command tree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDebugCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cobra</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cmd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">cobra</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Use:   </span><span style=\"color:#9ECBFF\">\"debug\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Short: </span><span style=\"color:#9ECBFF\">\"Debugging commands for container inspection\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Long:  </span><span style=\"color:#9ECBFF\">\"Commands to inspect container state, namespaces, cgroups, and other low-level details\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cmd.</span><span style=\"color:#B392F0\">AddCommand</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        newDebugInspectCommand</span><span style=\"color:#E1E4E8\">(r),</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        newDebugExecCommand</span><span style=\"color:#E1E4E8\">(r),</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        newDebugLogsCommand</span><span style=\"color:#E1E4E8\">(r),</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        newDebugTraceCommand</span><span style=\"color:#E1E4E8\">(r),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cmd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// newDebugInspectCommand creates the inspect subcommand</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> newDebugInspectCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cobra</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">cobra</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Use:   </span><span style=\"color:#9ECBFF\">\"inspect [container-id]\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Short: </span><span style=\"color:#9ECBFF\">\"Inspect container state and configuration\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Args:  cobra.</span><span style=\"color:#B392F0\">ExactArgs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RunE: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cmd</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">cobra</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            containerID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Get the container from runtime state manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // container, err := r.GetContainer(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // if err != nil { return fmt.Errorf(\"container not found: %v\", err) }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Create a ContainerInspector instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // inspector := debug.NewContainerInspector(r.StorePath())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Collect inspection data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // info, err := inspector.InspectContainer(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // if err != nil { return fmt.Errorf(\"inspection failed: %v\", err) }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Output as JSON or formatted text based on --format flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // if jsonOutput { json.NewEncoder(os.Stdout).Encode(info) }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // else { printFormattedInfo(info) }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: If --output flag specified, write to file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // if outputFile != \"\" { inspector.DumpToFile(containerID, outputFile) }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// newDebugExecCommand creates the exec subcommand for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> newDebugExecCommand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cobra</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">cobra</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Use:   </span><span style=\"color:#9ECBFF\">\"exec [container-id] [command]\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Short: </span><span style=\"color:#9ECBFF\">\"Execute command in container namespaces\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Long:  </span><span style=\"color:#9ECBFF\">\"Run a command in the container's namespaces for debugging purposes\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Args:  cobra.</span><span style=\"color:#B392F0\">MinimumNArgs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RunE: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cmd</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">cobra</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            containerID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            command </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Get container process PID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // pid, err := getContainerPID(containerID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // if err != nil { return err }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Build namespace paths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // nsPaths := []string{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //     fmt.Sprintf(\"/proc/%d/ns/pid\", pid),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //     fmt.Sprintf(\"/proc/%d/ns/mnt\", pid),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //     fmt.Sprintf(\"/proc/%d/ns/net\", pid),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Use nsenter to execute command in those namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // cmd := exec.Command(\"nsenter\", append([]string{\"-t\", fmt.Sprintf(\"%d\", pid), \"--mount\", \"--net\", \"--pid\"}, command...)...)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // cmd.Stdin = os.Stdin</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // cmd.Stdout = os.Stdout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // cmd.Stderr = os.Stderr</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // return cmd.Run()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li><p><strong>Go-specific tips for debugging:</strong></p>\n<ul>\n<li>Use <code>syscall.PtraceAttach()</code> and <code>syscall.PtraceDetach()</code> for low-level process tracing</li>\n<li>The <code>os/exec</code> package&#39;s <code>Cmd.SysProcAttr</code> field lets you set namespace flags for child processes</li>\n<li>Use <code>gops</code> (Go process inspector) to debug the runtime itself: <code>import &quot;github.com/google/gops/agent&quot;</code></li>\n<li>For logging, use structured logging with fields: <code>logrus.WithField(&quot;container_id&quot;, containerID).Error(&quot;Failed to start&quot;)</code></li>\n<li>Use <code>runtime.Caller()</code> to add stack trace information to error messages</li>\n</ul>\n</li>\n<li><p><strong>System call tracing in Go:</strong></p>\n</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">  // Wrap system calls with logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  func</span><span style=\"color:#B392F0\"> tracedSyscall</span><span style=\"color:#E1E4E8\">(name </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, fn </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      logrus.</span><span style=\"color:#B392F0\">WithField</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"syscall\"</span><span style=\"color:#E1E4E8\">, name).</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Enter\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> fn</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      elapsed </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      logrus.</span><span style=\"color:#B392F0\">WithFields</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">logrus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fields</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">          \"syscall\"</span><span style=\"color:#E1E4E8\">: name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">          \"elapsed\"</span><span style=\"color:#E1E4E8\">: elapsed,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">          \"error\"</span><span style=\"color:#E1E4E8\">:   err,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }).</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Exit\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Usage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  tracedSyscall</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pivot_root\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">PivotRoot</span><span style=\"color:#E1E4E8\">(newroot, putold)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  })</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing debugging features, verify them with these tests:</p>\n<ol>\n<li><strong>Basic Inspection Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start a container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./container-runtime</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> echo</span><span style=\"color:#9ECBFF\"> \"hello\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Get the container ID from output or list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   CONTAINER_ID</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">./container-runtime</span><span style=\"color:#9ECBFF\"> list</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> awk</span><span style=\"color:#9ECBFF\"> 'NR==2 {print $1}'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Inspect it</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./container-runtime</span><span style=\"color:#9ECBFF\"> debug</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#E1E4E8\"> $CONTAINER_ID </span><span style=\"color:#79B8FF\">--format</span><span style=\"color:#9ECBFF\"> json</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: JSON output with namespace IDs, cgroup paths, mount points</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # If empty or error, check that the inspector can find the container process</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Namespace Debugging Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start a container with network</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./container-runtime</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --network</span><span style=\"color:#9ECBFF\"> bridge</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sleep</span><span style=\"color:#79B8FF\"> 60</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Inspect network namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./container-runtime</span><span style=\"color:#9ECBFF\"> debug</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#E1E4E8\"> $CONTAINER_ID </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -A5</span><span style=\"color:#9ECBFF\"> \"network\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: Shows network namespace ID, interfaces, IP address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # If missing, check /proc/&#x3C;pid>/ns/net exists and is readable</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Filesystem Debugging Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Create a file in container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./container-runtime</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#9ECBFF\"> sh</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"echo test > /tmp/debug.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Inspect filesystem layers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./container-runtime</span><span style=\"color:#9ECBFF\"> debug</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#E1E4E8\"> $CONTAINER_ID </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -A10</span><span style=\"color:#9ECBFF\"> \"filesystem\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: Shows overlayfs layers, upperdir path, merged view</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check that upperdir exists and contains the debug.txt file</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips-implementation\">Debugging Tips Implementation</h4>\n<p>Add these debugging helpers directly to your components:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/runtime/manager.go (add to ContainerRuntime)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EnableDebugLogging</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.debugMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set verbose logging for all components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Enable system call tracing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Log all state transitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerRuntime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CollectDebugInfo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Gather dmesg output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Capture iptables rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Dump cgroup hierarchies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Save to timestamped debug directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> debugDir, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Remember to build debugging capabilities incrementally—start with basic inspection commands, then add more sophisticated tracing as you encounter specific problems. The most valuable debugging tool is the one you build to solve your current problem.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (future extensions build upon the foundation established by all six implementation milestones)</p>\n</blockquote>\n<p>This section explores potential enhancements to our container runtime beyond the core implementation. While the current design provides a functional container runtime with all essential isolation primitives, real-world container systems include numerous additional features for security, usability, and production readiness. Understanding these extensions helps contextualize how our educational implementation compares to production systems like Docker and Kubernetes, and provides a roadmap for continued learning.</p>\n<h3 id=\"potential-enhancement-ideas\">Potential Enhancement Ideas</h3>\n<p>The following extensions represent natural evolution points for the container runtime, categorized by their primary focus area:</p>\n<h4 id=\"security-hardening\">Security Hardening</h4>\n<p><strong>User Namespace Support</strong>: Currently, our container runs with the same user privileges as the host process (typically root). User namespaces would allow mapping host user IDs to different user IDs within the container, enabling containers to run as &quot;root&quot; inside while being non-root on the host.</p>\n<p><strong>Seccomp BPF Filters</strong>: System call filtering using seccomp would restrict the container&#39;s ability to make dangerous system calls (like <code>reboot</code>, <code>mount</code>, or <code>ptrace</code>), significantly reducing the attack surface.</p>\n<p><strong>Capabilities Management</strong>: Instead of running containers with all Linux capabilities, we could drop dangerous capabilities (like <code>CAP_SYS_ADMIN</code>, <code>CAP_NET_RAW</code>) and grant only necessary ones based on the container&#39;s purpose.</p>\n<p><strong>SELinux/AppArmor Integration</strong>: Mandatory Access Control (MAC) systems provide additional security boundaries beyond namespace isolation, enforcing fine-grained policies on file access, network operations, and process interactions.</p>\n<h4 id=\"container-orchestration-features\">Container Orchestration Features</h4>\n<p><strong>Container Health Checks</strong>: Periodic execution of user-defined health check commands within the container, with automatic container restart if checks fail repeatedly.</p>\n<p><strong>Logging Driver Infrastructure</strong>: Support for multiple logging backends (syslog, journald, fluentd) with configurable log rotation, formatting, and aggregation.</p>\n<p><strong>Metrics Collection</strong>: Automatic collection and export of container resource usage statistics (CPU, memory, network, block I/O) via cgroup metrics and process monitoring.</p>\n<p><strong>Container Dependency Management</strong>: Start order coordination for containers that depend on services provided by other containers (e.g., database container must be ready before web application container).</p>\n<h4 id=\"storage-and-networking-enhancements\">Storage and Networking Enhancements</h4>\n<p><strong>Volume Management</strong>: First-class support for persistent storage volumes with configurable drivers (local directories, NFS, cloud storage) and lifecycle management.</p>\n<p><strong>Network Plugins</strong>: Extensible network architecture supporting multiple network drivers (bridge, host, macvlan, ipvlan, overlay networks) via a plugin interface.</p>\n<p><strong>IPv6 Support</strong>: Full dual-stack IPv4/IPv6 networking with proper address allocation, routing, and firewall rules for IPv6.</p>\n<p><strong>Service Discovery</strong>: Built-in DNS-based service discovery allowing containers to find each other by name without static IP configuration.</p>\n<h4 id=\"usability-and-production-features\">Usability and Production Features</h4>\n<p><strong>Container Pause/Resume</strong>: Support for freezing and thawing container execution using cgroup freezer controller, enabling live migration scenarios and debugging.</p>\n<p><strong>Container Checkpoint/Restore</strong>: Save container state to disk and restore it later, possibly on a different host, using CRIU (Checkpoint/Restore In Userspace).</p>\n<p><strong>Build System</strong>: Dockerfile-like build system for creating container images from source code with layer caching and dependency tracking.</p>\n<p><strong>Registry Authentication</strong>: Support for authenticated access to private container registries with token-based authentication and credential storage.</p>\n<p><strong>Windows Container Support</strong>: Cross-platform runtime supporting Windows containers using Windows-native isolation primitives (job objects, namespace, Hyper-V isolation).</p>\n<p>The following table compares these enhancements by their implementation complexity and educational value:</p>\n<table>\n<thead>\n<tr>\n<th>Enhancement</th>\n<th>Implementation Complexity</th>\n<th>Educational Value</th>\n<th>Production Relevance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>User Namespace Support</td>\n<td>Medium</td>\n<td>High (deepens namespace understanding)</td>\n<td>Critical</td>\n</tr>\n<tr>\n<td>Seccomp BPF Filters</td>\n<td>Low-Medium</td>\n<td>Medium (system call security)</td>\n<td>Critical</td>\n</tr>\n<tr>\n<td>Volume Management</td>\n<td>Medium</td>\n<td>High (storage architecture)</td>\n<td>Critical</td>\n</tr>\n<tr>\n<td>Network Plugins</td>\n<td>High</td>\n<td>Medium (plugin architecture)</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Health Checks</td>\n<td>Low</td>\n<td>Low (orchestration patterns)</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Container Pause/Resume</td>\n<td>Low</td>\n<td>Medium (cgroup freezer)</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Build System</td>\n<td>High</td>\n<td>High (image construction)</td>\n<td>Critical</td>\n</tr>\n<tr>\n<td>Checkpoint/Restore</td>\n<td>High</td>\n<td>High (process state serialization)</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<h4 id=\"architecture-decision-incremental-vs-complete-rewrite\">Architecture Decision: Incremental vs. Complete Rewrite</h4>\n<blockquote>\n<p><strong>Decision: Incremental Enhancement Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: As an educational project, we want to maximize learning while maintaining a codebase that can evolve. Some enhancements require significant architectural changes that might conflict with the current simple design.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Incremental additions</strong>: Add features to the existing codebase with minimal refactoring</li>\n<li><strong>Modular plugin architecture</strong>: Refactor core components to support pluggable implementations</li>\n<li><strong>Complete rewrite</strong>: Start fresh with a more extensible architecture incorporating lessons learned</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use incremental additions for simple enhancements and a gradual move toward plugin architecture for complex subsystems (networking, storage).</li>\n<li><strong>Rationale</strong>: The educational value comes from understanding the underlying Linux primitives, not building enterprise-grade extensibility. Incremental additions allow focused learning on specific features without overwhelming complexity. However, introducing plugin interfaces for networking and storage teaches important architectural patterns.</li>\n<li><strong>Consequences</strong>: Some refactoring will be needed when adding certain features, but the core isolation logic remains stable. The codebase may become slightly less elegant but remains approachable for learners.</li>\n</ul>\n</blockquote>\n<h3 id=\"design-accommodations-for-extensions\">Design Accommodations for Extensions</h3>\n<p>The current design includes several intentional accommodations that make future extensions easier. However, some enhancements require significant architectural changes.</p>\n<h4 id=\"security-hardening-accommodations\">Security Hardening Accommodations</h4>\n<p><strong>Current Design Accommodations</strong>:</p>\n<ul>\n<li>The <code>ContainerConfig</code> type includes fields for security settings that are currently unimplemented</li>\n<li>The <code>NamespaceManager.CreateNamespaces</code> method accepts flags as a bitmask, making it easy to add <code>CLONE_NEWUSER</code></li>\n<li>The cleanup stack pattern ensures resources are properly released even when security features fail</li>\n</ul>\n<p><strong>Required Modifications for User Namespaces</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Current State</th>\n<th>Required Changes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NamespaceManager</code></td>\n<td>Supports PID, UTS, mount, network, IPC namespaces</td>\n<td>Add <code>CLONE_NEWUSER</code> support and uid/gid mapping</td>\n</tr>\n<tr>\n<td><code>ContainerConfig</code></td>\n<td>Has basic security fields</td>\n<td>Add <code>UserNamespaceConfig</code> with uidMaps and gidMaps</td>\n</tr>\n<tr>\n<td><code>FilesystemManager</code></td>\n<td>Assumes root access for mount operations</td>\n<td>Handle file ownership when running as non-root user</td>\n</tr>\n<tr>\n<td>CLI</td>\n<td>No user namespace flags</td>\n<td>Add <code>--user</code> flag and uid/gid mapping options</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Approach</strong>:</p>\n<ol>\n<li>Add <code>UserNamespaceConfig</code> to <code>ContainerConfig</code> with slice of <code>UIDMap</code> and <code>GIDMap</code> structs</li>\n<li>Modify <code>NamespaceManager.CreateNamespaces</code> to handle <code>CLONE_NEWUSER</code> flag</li>\n<li>Write uid/gid maps to <code>/proc/[pid]/uid_map</code> and <code>/proc/[pid]/gid_map</code> after clone</li>\n<li>Update <code>FilesystemManager</code> to use <code>syscall.Chown</code> for critical directories when running mapped</li>\n</ol>\n<p><strong>Seccomp Integration Strategy</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Current ContainerConfig would expand to include:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecurityConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SeccompProfile  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SeccompProfile</span><span style=\"color:#9ECBFF\"> `json:\"seccomp,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AppArmorProfile </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"apparmor,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Capabilities    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Capabilities</span><span style=\"color:#9ECBFF\">   `json:\"capabilities,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NoNewPrivileges </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">            `json:\"noNewPrivileges,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReadonlyRootfs  </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">            `json:\"readonlyRootfs,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"storage-system-extensions\">Storage System Extensions</h4>\n<p><strong>Volume Management Architecture</strong>:</p>\n<p>The current filesystem isolation uses OverlayFS for the root filesystem but lacks persistent volume support. A volume system would require:</p>\n<ol>\n<li><strong>Volume Abstraction Layer</strong>: Interface defining volume operations (create, mount, unmount, delete)</li>\n<li><strong>Volume Drivers</strong>: Pluggable implementations for different storage backends</li>\n<li><strong>Volume Lifecycle</strong>: Integration with container lifecycle (mount before start, unmount after stop)</li>\n<li><strong>Volume Specification</strong>: Extended <code>ContainerConfig</code> to declare volume mounts</li>\n</ol>\n<p><strong>Proposed Volume Data Model</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VolumeMount</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Source      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">   // Volume name or host path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Destination </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">   // Container path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type        </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">   // \"bind\", \"volume\", \"tmpfs\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Options     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // \"ro\", \"rw\", \"z\", \"Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VolumeDriver</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">opts</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Volume</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Remove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// returns mount path</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Unmount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VolumeManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    drivers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">VolumeDriver</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    volumes </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Volume</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Integration Points</strong>:</p>\n<ul>\n<li>Modify <code>FilesystemManager.SetupRootfs</code> to handle volume mounts after rootfs setup</li>\n<li>Extend <code>ContainerRuntime.createContainerSequence</code> to call volume mounting in phase 4 (filesystem preparation)</li>\n<li>Add volume cleanup to <code>CleanupManager</code> for proper resource cleanup</li>\n</ul>\n<h4 id=\"networking-plugin-architecture\">Networking Plugin Architecture</h4>\n<p><strong>Current Network Limitations</strong>:\nThe <code>NetworkManager</code> implements a single bridge network driver hardcoded into the component. A plugin architecture would allow multiple network types (host, none, macvlan, overlay).</p>\n<p><strong>Proposed Plugin Interface</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkDriver</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">opts</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#B392F0\">Network</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    DeleteNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SetupContainerNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">netnsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TeardownContainerNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">netnsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    drivers   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">NetworkDriver</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ipam      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPAM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... existing fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">nm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterDriver</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">driver</span><span style=\"color:#B392F0\"> NetworkDriver</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nm.drivers[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> driver</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Required Refactoring</strong>:</p>\n<ol>\n<li>Extract current bridge network logic into <code>BridgeDriver</code> implementing <code>NetworkDriver</code></li>\n<li>Modify <code>NetworkManager.SetupNetwork</code> to delegate to the appropriate driver based on <code>NetworkConfig.Mode</code></li>\n<li>Add driver discovery and loading mechanism (static compilation or dynamic loading)</li>\n<li>Update CLI to support network driver selection via <code>--network</code> flag</li>\n</ol>\n<p><strong>Network Configuration Evolution</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Current NetworkConfig</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Mode         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"mode\"`</span><span style=\"color:#6A737D\">           // \"bridge\", \"host\", \"none\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BridgeName   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"bridgeName\"`</span><span style=\"color:#6A737D\">     // \"byod-bridge\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"ipAddress\"`</span><span style=\"color:#6A737D\">      // \"10.0.0.2\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#9ECBFF\"> `json:\"portMappings\"`</span><span style=\"color:#6A737D\">   // port forwards</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Enhanced NetworkConfig with plugin support</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Driver       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"driver\"`</span><span style=\"color:#6A737D\">       // \"bridge\", \"macvlan\", \"overlay\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NetworkName  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"networkName\"`</span><span style=\"color:#6A737D\">  // \"byod-network\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Options      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"options\"`</span><span style=\"color:#6A737D\">      // driver-specific options</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"ipAddress\"`</span><span style=\"color:#6A737D\">     // optional override</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#9ECBFF\">          `json:\"portMappings\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"orchestration-features-integration\">Orchestration Features Integration</h4>\n<p><strong>Health Check Implementation</strong>:</p>\n<p>Health checks require periodic execution of commands within the container and state tracking:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HealthCheckConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Test        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"test\"`</span><span style=\"color:#6A737D\">        // [\"CMD\", \"curl\", \"-f\", \"http://localhost/health\"]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Interval    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"interval\"`</span><span style=\"color:#6A737D\">    // 30s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timeout     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"timeout\"`</span><span style=\"color:#6A737D\">     // 30s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartPeriod </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"startPeriod\"`</span><span style=\"color:#6A737D\"> // 0s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Retries     </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `json:\"retries\"`</span><span style=\"color:#6A737D\">     // 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerHealth</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"status\"`</span><span style=\"color:#6A737D\">      // \"starting\", \"healthy\", \"unhealthy\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FailingStreak </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">     `json:\"failingStreak\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Log         []</span><span style=\"color:#B392F0\">HealthCheckResult</span><span style=\"color:#9ECBFF\"> `json:\"log\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HealthMonitor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerHealthTracker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    executor   </span><span style=\"color:#B392F0\">HealthCheckExecutor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Integration Challenges</strong>:</p>\n<ol>\n<li><strong>Namespace Access</strong>: Health check commands must execute within the container&#39;s namespaces</li>\n<li><strong>Resource Isolation</strong>: Health checks should respect container resource limits</li>\n<li><strong>State Management</strong>: Health status must be stored and accessible via CLI/API</li>\n<li><strong>Automatic Remediation</strong>: Unhealthy containers might need automatic restart</li>\n</ol>\n<p><strong>Design Accommodation</strong>: The current <code>ContainerRuntime</code> tracks container state but would need to extend <code>Container</code> struct with health fields and add a background monitoring goroutine.</p>\n<h4 id=\"metrics-collection-system\">Metrics Collection System</h4>\n<p><strong>Current Capabilities</strong>: The <code>CgroupManager.GetStats</code> method already collects basic resource usage statistics. This could be extended and exposed.</p>\n<p><strong>Enhanced Metrics Architecture</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerMetrics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPU         </span><span style=\"color:#B392F0\">CPUMetrics</span><span style=\"color:#9ECBFF\">             `json:\"cpu\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Memory      </span><span style=\"color:#B392F0\">MemoryMetrics</span><span style=\"color:#9ECBFF\">          `json:\"memory\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlockIO     </span><span style=\"color:#B392F0\">BlockIOMetrics</span><span style=\"color:#9ECBFF\">         `json:\"blockIO\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Network     </span><span style=\"color:#B392F0\">NetworkMetrics</span><span style=\"color:#9ECBFF\">         `json:\"network\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PIDs        </span><span style=\"color:#B392F0\">PIDMetrics</span><span style=\"color:#9ECBFF\">             `json:\"pids\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricsCollector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroupManager </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    networkManager </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    interval      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscribers   []</span><span style=\"color:#B392F0\">MetricsSubscriber</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerMetricsHistory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricsSubscriber</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    OnMetrics</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">metrics</span><span style=\"color:#B392F0\"> ContainerMetrics</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Integration Points</strong>:</p>\n<ol>\n<li>Extend <code>CgroupManager.GetStats</code> to collect additional metrics (throttling, pressure)</li>\n<li>Add network statistics collection via <code>/sys/class/net</code> or netlink</li>\n<li>Create metrics aggregation goroutine in <code>ContainerRuntime</code></li>\n<li>Add CLI command <code>byod stats</code> to display live metrics</li>\n<li>Optional: Export metrics via Prometheus endpoint or OpenMetrics format</li>\n</ol>\n<h4 id=\"build-system-implementation\">Build System Implementation</h4>\n<p><strong>Current Image Handling</strong>: The runtime pulls and extracts existing images but doesn&#39;t build them from source.</p>\n<p><strong>Build System Components</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Integration Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dockerfile Parser</td>\n<td>Parse build instructions into execution graph</td>\n<td>Standalone component, outputs build spec</td>\n</tr>\n<tr>\n<td>Layer Builder</td>\n<td>Execute build steps, creating new layers</td>\n<td>Uses <code>FilesystemManager</code> for layer creation</td>\n</tr>\n<tr>\n<td>Build Cache</td>\n<td>Cache intermediate layers for faster rebuilds</td>\n<td>Integrates with <code>LayerCache</code></td>\n</tr>\n<tr>\n<td>Image Assembler</td>\n<td>Create final image manifest and config</td>\n<td>Uses <code>ImageStore</code> to save final image</td>\n</tr>\n</tbody></table>\n<p><strong>Build Process Flow</strong>:</p>\n<ol>\n<li>Parse Dockerfile into sequence of build stages</li>\n<li>For each stage, start with base image or scratch</li>\n<li>Execute instructions (RUN, COPY, ADD, etc.) in temporary container</li>\n<li>Commit each successful step as a new layer</li>\n<li>Apply layer to next step (like OverlayFS during build)</li>\n<li>Finalize image with metadata and entrypoint</li>\n</ol>\n<p><strong>Key Technical Challenge</strong>: The build process needs to execute commands in isolated environments (containers) but also needs to copy files between build stages and host. This requires temporary container creation and filesystem snapshotting after each step.</p>\n<h4 id=\"windows-container-support\">Windows Container Support</h4>\n<p><strong>Architectural Implications</strong>: Windows containers use fundamentally different isolation primitives, requiring a complete abstraction layer.</p>\n<p><strong>Proposed Platform Abstraction</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IsolationProvider</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateIsolatedProcess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> ProcessConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">IsolatedProcess</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SetupFilesystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">layers</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SetupNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">netConfig</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">NetworkEndpoint</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ApplyResourceLimits</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limits</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ResourceStats</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LinuxIsolationProvider</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Uses namespaces, cgroups, pivot_root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WindowsIsolationProvider</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Uses job objects, silos, Windows namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerRuntime</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isolationProvider </span><span style=\"color:#B392F0\">IsolationProvider</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... other fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Design Impact</strong>: This represents a major architectural shift from the current Linux-specific implementation. The abstraction would need to cover all isolation primitives while maintaining consistent behavior across platforms.</p>\n<h4 id=\"registry-authentication-system\">Registry Authentication System</h4>\n<p><strong>Current Limitation</strong>: The <code>RegistryClient</code> assumes anonymous access to public registries.</p>\n<p><strong>Authentication Flow</strong>:</p>\n<ol>\n<li>Attempt anonymous pull</li>\n<li>If 401/403, check for credentials in config file</li>\n<li>Request authentication token from registry auth service</li>\n<li>Retry request with Bearer token</li>\n<li>Cache token for subsequent requests</li>\n</ol>\n<p><strong>Required Changes</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RegistryAuth</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Username </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"username\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Password </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"password\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Auth     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"auth\"`</span><span style=\"color:#6A737D\"> // Base64 encoded \"username:password\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Server   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"server\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuthStore</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCredentials</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">registry</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">RegistryAuth</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SetCredentials</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">registry</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">auth</span><span style=\"color:#B392F0\"> RegistryAuth</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuthenticatedRegistryClient</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseClient    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RegistryClient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    authStore     </span><span style=\"color:#B392F0\">AuthStore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokenCache    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // registry -> token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu            </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Integration Points</strong>: Modify <code>RegistryClient.PullManifest</code> and <code>RegistryClient.PullLayer</code> to handle authentication challenges and token acquisition.</p>\n<h3 id=\"summary-of-extension-readiness\">Summary of Extension Readiness</h3>\n<p>The current design accommodates extensions through several key characteristics:</p>\n<ol>\n<li><p><strong>Modular Component Design</strong>: Each manager (Namespace, Cgroup, Filesystem, Network) operates independently, allowing replacement or enhancement of individual components.</p>\n</li>\n<li><p><strong>Clean Separation of Concerns</strong>: The 8-phase container creation sequence provides clear hooks for adding new preparation steps (e.g., volume mounting between phases 4 and 5).</p>\n</li>\n<li><p><strong>Cleanup Stack Pattern</strong>: The <code>CleanupManager</code> ensures resources are properly released, which is essential when adding complex features that might fail mid-operation.</p>\n</li>\n<li><p><strong>Config-Driven Architecture</strong>: The <code>ContainerConfig</code> type can be extended with new fields without breaking existing functionality.</p>\n</li>\n<li><p><strong>State Machine Foundation</strong>: The container state machine provides a framework for adding new states (e.g., &quot;Paused&quot;, &quot;Unhealthy&quot;) and transitions.</p>\n</li>\n</ol>\n<p>However, some extensions would require significant refactoring:</p>\n<ul>\n<li>Plugin architectures for networking and storage</li>\n<li>Cross-platform support</li>\n<li>Build system integration</li>\n<li>Comprehensive security features</li>\n</ul>\n<p>For educational purposes, implementing selected extensions (like user namespaces or volume support) provides excellent learning opportunities while keeping the project manageable. Production container runtimes have evolved over years with contributions from hundreds of developers—our implementation captures the essential essence while remaining approachable for learning.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-for-extensions\">Technology Recommendations for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Implementation</th>\n<th>Advanced Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Security Hardening</td>\n<td>Basic seccomp profiles from OCI spec</td>\n<td>Dynamic BPF program generation based on container behavior</td>\n</tr>\n<tr>\n<td>Volume Management</td>\n<td>Local bind mounts with configurable propagation</td>\n<td>Plugin system with NFS, iSCSI, cloud storage drivers</td>\n</tr>\n<tr>\n<td>Network Plugins</td>\n<td>Hardcoded bridge and host modes</td>\n<td>CNI (Container Network Interface) compatible plugin loader</td>\n</tr>\n<tr>\n<td>Health Checks</td>\n<td>Simple command execution via <code>exec</code> in container</td>\n<td>Integrated with process supervision and automatic restart</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Periodic cgroup stats polling</td>\n<td>Real-time metrics via eBPF and Prometheus endpoint</td>\n</tr>\n<tr>\n<td>Build System</td>\n<td>Simple layer-by-layer execution without cache</td>\n<td>Full Dockerfile support with smart caching and multi-stage builds</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure-for-extensions\">Recommended File Structure for Extensions</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>byod/\n  internal/\n    security/                    # Security enhancements\n      seccomp/\n        seccomp.go              # Seccomp profile parsing and application\n        default-profile.json    # Default seccomp profile\n      capabilities/\n        capabilities.go         # Linux capabilities management\n      apparmor/\n        apparmor.go             # AppArmor profile loading\n    volumes/                    # Volume management system\n      volume.go                 # Volume interface and types\n      localdriver.go            # Local volume driver\n      manager.go                # Volume manager\n      mount.go                  # Mount helpers\n    networking/\n      drivers/                  # Network driver implementations\n        bridge.go               # Existing bridge driver (refactored)\n        host.go                 # Host network driver\n        macvlan.go              # Macvlan driver\n        plugin.go               # Plugin interface\n      cni/                      # CNI integration\n        cni.go                  # CNI plugin executor\n    health/                     # Health check system\n      checker.go                # Health check execution\n      monitor.go                # Background health monitoring\n      executor.go               # Command execution in container\n    metrics/                    # Metrics collection\n      collector.go              # Metrics collection goroutine\n      prometheus.go             # Prometheus exporter\n      types.go                  # Metrics data structures\n    build/                      # Build system\n      dockerfile/\n        parser.go               # Dockerfile parser\n        instructions.go         # Instruction implementations\n      builder.go                # Build orchestration\n      cache.go                  # Build cache\n      executor.go               # Build step execution in container\n    registry/                   # Enhanced registry client\n      auth/\n        authenticator.go        # Registry authentication\n        credentialstore.go      # Credential storage (∼/.docker/config.json)\n        token.go                # Token management\n    platform/                   # Cross-platform abstractions\n      isolation.go              # IsolationProvider interface\n      linux/                    # Linux implementation\n        isolation_linux.go\n      windows/                  # Windows implementation (stub)\n        isolation_windows.go\n  cmd/\n    byod-build/                 # Build command\n      main.go</code></pre></div>\n\n<h4 id=\"security-hardening-starter-code\">Security Hardening Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/security/seccomp/seccomp.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> seccomp</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/seccomp/libseccomp-golang</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">golang.org/x/sys/unix</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SeccompProfile represents a seccomp filter configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SeccompProfile</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DefaultAction </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">           `json:\"defaultAction\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Architectures []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"architectures\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Syscalls      []</span><span style=\"color:#B392F0\">SyscallRule</span><span style=\"color:#9ECBFF\">    `json:\"syscalls\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SyscallRule defines allowed/disallowed syscalls</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SyscallRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Names  []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"names\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Action </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"action\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Args   []</span><span style=\"color:#B392F0\">Arg</span><span style=\"color:#9ECBFF\">    `json:\"args,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadProfile loads a seccomp profile from JSON file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadProfile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SeccompProfile</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"read seccomp profile: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> profile </span><span style=\"color:#B392F0\">SeccompProfile</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">profile); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"parse seccomp profile: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">profile, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ApplyProfile applies the seccomp profile to the current process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ApplyProfile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">profile</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SeccompProfile</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> profile </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // No profile to apply</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filter, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> seccomp.</span><span style=\"color:#B392F0\">NewFilter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">parseAction</span><span style=\"color:#E1E4E8\">(profile.DefaultAction))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"create seccomp filter: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> filter.</span><span style=\"color:#B392F0\">Release</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add architecture support</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, arch </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> profile.Architectures {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> addArchitecture</span><span style=\"color:#E1E4E8\">(filter, arch); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"add architecture </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, arch, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add syscall rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, rule </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> profile.Syscalls {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, name </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> rule.Names {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sc, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> seccomp.</span><span style=\"color:#B392F0\">GetSyscallFromName</span><span style=\"color:#E1E4E8\">(name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Syscall might not exist on this architecture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filter.</span><span style=\"color:#B392F0\">AddRule</span><span style=\"color:#E1E4E8\">(sc, </span><span style=\"color:#B392F0\">parseAction</span><span style=\"color:#E1E4E8\">(rule.Action)); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"add rule for </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, name, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> filter.</span><span style=\"color:#B392F0\">Load</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseAction converts string action to seccomp.Action</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> parseAction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">action</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">seccomp</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Action</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> action {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ACT_ALLOW\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> seccomp.ActAllow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ACT_ERRNO\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> seccomp.ActErrno.</span><span style=\"color:#B392F0\">SetReturnCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int16</span><span style=\"color:#E1E4E8\">(unix.EPERM))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ACT_KILL\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> seccomp.ActKill</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ACT_KILL_PROCESS\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> seccomp.ActKillProcess</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ACT_TRACE\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> seccomp.ActTrace.</span><span style=\"color:#B392F0\">SetReturnCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> seccomp.ActErrno.</span><span style=\"color:#B392F0\">SetReturnCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int16</span><span style=\"color:#E1E4E8\">(unix.EPERM))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// addArchitecture adds architecture support to filter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> addArchitecture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filter</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">seccomp</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ScmpFilter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">arch</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> arch {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ARCH_X86_64\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> filter.</span><span style=\"color:#B392F0\">AddArch</span><span style=\"color:#E1E4E8\">(seccomp.ArchAMD64)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ARCH_X86\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> filter.</span><span style=\"color:#B392F0\">AddArch</span><span style=\"color:#E1E4E8\">(seccomp.ArchX86)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ARCH_ARM\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> filter.</span><span style=\"color:#B392F0\">AddArch</span><span style=\"color:#E1E4E8\">(seccomp.ArchARM)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"SCMP_ARCH_AARCH64\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> filter.</span><span style=\"color:#B392F0\">AddArch</span><span style=\"color:#E1E4E8\">(seccomp.ArchARM64)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unsupported architecture: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, arch)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DefaultProfile returns a default seccomp profile for containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DefaultProfile</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SeccompProfile</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns a sensible default profile similar to Docker's default</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This would include the actual JSON profile</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SeccompProfile</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        DefaultAction: </span><span style=\"color:#9ECBFF\">\"SCMP_ACT_ERRNO\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Architectures: []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"SCMP_ARCH_X86_64\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Syscalls: []</span><span style=\"color:#B392F0\">SyscallRule</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Names:  []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"accept\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"accept4\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"access\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"alarm\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"bind\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Action: </span><span style=\"color:#9ECBFF\">\"SCMP_ACT_ALLOW\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // ... more syscalls</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"volume-management-skeleton\">Volume Management Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/volumes/volume.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> volumes</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourusername/byod/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Volume represents a persistent storage volume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Volume</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Driver     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"driver\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Mountpoint </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"mountpoint\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Options    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"options\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Labels     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"labels\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"createdAt\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VolumeDriver is the interface for volume driver implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VolumeDriver</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create creates a new volume with the given name and options</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">opts</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#B392F0\">Volume</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove deletes a volume</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Remove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mount mounts the volume and returns the mount path</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unmount unmounts the volume</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Unmount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Path returns the path where the volume is stored (for bind mounts)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // DriverName returns the driver's name</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    DriverName</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VolumeManager manages all volumes and their drivers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VolumeManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    drivers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">VolumeDriver</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    volumes </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Volume</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseDir </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu      </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewVolumeManager creates a new volume manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewVolumeManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">baseDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VolumeManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create base directory if it doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize drivers map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Load existing volumes from persistence file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Register default \"local\" driver</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return initialized manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateVolume creates a new volume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VolumeManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">driver</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">opts</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#B392F0\">Volume</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate volume name (alphanumeric, underscores, hyphens)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if volume already exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Get driver implementation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call driver.Create() with name and options</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store volume metadata in volumes map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Persist volume metadata to disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return created volume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Volume</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MountVolume mounts a volume for use by a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VolumeManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MountVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up volume by name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Get volume driver</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call driver.Mount() to mount the volume</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return mount path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UnmountVolume unmounts a volume after container stops</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VolumeManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UnmountVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up volume by name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if any other containers are using this volume</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If no other users, call driver.Unmount()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update usage tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetVolume returns volume information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VolumeManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Volume</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up volume in volumes map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return volume if found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return error if not found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Volume</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ListVolumes returns all volumes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VolumeManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ListVolumes</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">Volume</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through volumes map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Collect all volumes into slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return slice</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveVolume removes a volume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VolumeManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if volume exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if volume is in use by any container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Get volume driver</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call driver.Remove()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove from volumes map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Persist changes to disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LocalDriver implements VolumeDriver for local directories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LocalDriver</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseDir </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ld </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LocalDriver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">opts</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#B392F0\">Volume</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create directory at filepath.Join(ld.baseDir, name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Apply options (size limits, permissions)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return Volume with Mountpoint set to directory path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Volume</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ld </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LocalDriver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if directory exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove directory and all contents</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ld </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LocalDriver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Return path to volume directory (already mounted as filesystem)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ld </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LocalDriver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Unmount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: For local driver, nothing to unmount</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ld </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LocalDriver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Return path to volume directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ld </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LocalDriver</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DriverName</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"local\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-extensions\">Language-Specific Hints for Extensions</h4>\n<p><strong>Go-Specific Implementation Tips</strong>:</p>\n<ol>\n<li><strong>Security Context</strong>: Use <code>golang.org/x/sys/unix</code> package for seccomp and capabilities operations</li>\n<li><strong>Plugin Loading</strong>: For dynamic network/storage plugins, consider <code>plugin</code> package or compile-time registration</li>\n<li><strong>Concurrent Health Checks</strong>: Use <code>context.Context</code> with timeouts for health check execution</li>\n<li><strong>Metrics Collection</strong>: Use <code>prometheus/client_golang</code> for Prometheus integration if desired</li>\n<li><strong>Windows Support</strong>: Use build tags (<code>//go:build windows</code>) for platform-specific implementations</li>\n<li><strong>Authentication</strong>: Use <code>golang.org/x/oauth2</code> for registry token authentication flows</li>\n<li><strong>Build Caching</strong>: Use content-addressable storage with SHA256 digests for build cache keys</li>\n</ol>\n<p><strong>Integration Testing for Extensions</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example test for volume management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestVolumeManagerIntegration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tmpDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">TempDir</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> volumes.</span><span style=\"color:#B392F0\">NewVolumeManager</span><span style=\"color:#E1E4E8\">(tmpDir)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vol, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">CreateVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"testvol\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"local\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"size\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"1GB\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"testvol\"</span><span style=\"color:#E1E4E8\">, vol.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mountPath, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">MountVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"testvol\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"test-container\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">DirExists</span><span style=\"color:#E1E4E8\">(t, mountPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write test file to volume</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testFile </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(mountPath, </span><span style=\"color:#9ECBFF\">\"test.txt\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(testFile, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, vm.</span><span style=\"color:#B392F0\">UnmountVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"testvol\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"test-container\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Volume should still exist</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vol2, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">GetVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"testvol\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, vol.Name, vol2.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, vm.</span><span style=\"color:#B392F0\">RemoveVolume</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"testvol\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints-for-extensions\">Milestone Checkpoints for Extensions</h4>\n<p><strong>After Implementing Volume Support</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>$ ./byod volume create mydata --driver=local\nVolume &quot;mydata&quot; created successfully\n\n$ ./byod run -v mydata:/data alpine ls /data\n(should show contents of empty volume)\n\n$ ./byod run -v mydata:/data alpine touch /data/test.txt\n\n$ ./byod run -v mydata:/data alpine ls /data\ntest.txt\n\n$ ./byod volume ls\nNAME    DRIVER    MOUNTPOINT\nmydata  local     /var/lib/byod/volumes/mydata/_data</code></pre></div>\n\n<p><strong>After Implementing User Namespaces</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>$ ./byod run --user 1000:1000 alpine id\nuid=1000 gid=1000 groups=1000\n\n$ ps aux | grep alpine\n(container process should run as non-root user on host)\n\n$ ./byod run --user 0:0 --cap-add=ALL alpine sh\n(should fail if capabilities are properly dropped)</code></pre></div>\n\n<p><strong>After Implementing Health Checks</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>$ ./byod run --health-cmd=&quot;curl -f http://localhost/health&quot; \\\n             --health-interval=5s \\\n             --health-retries=3 \\\n             myapp\n\n$ ./byod inspect mycontainer | jq .State.Health\n{\n  &quot;Status&quot;: &quot;healthy&quot;,\n  &quot;FailingStreak&quot;: 0,\n  &quot;Log&quot;: [...]\n}</code></pre></div>\n\n<h4 id=\"debugging-tips-for-extensions\">Debugging Tips for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Volume mount fails with &quot;permission denied&quot;</td>\n<td>SELinux/AppArmor blocking mount</td>\n<td>Check <code>dmesg</code> for SELinux/AppArmor denials</td>\n<td>Use <code>z</code> or <code>Z</code> volume option for SELinux labeling</td>\n</tr>\n<tr>\n<td>Container with user namespace can&#39;t write to mounted volume</td>\n<td>UID/GID mismatch between host and container</td>\n<td>Check file ownership on host with <code>ls -la</code></td>\n<td>Use <code>:uid=1000,gid=1000</code> volume option or ensure UID mapping</td>\n</tr>\n<tr>\n<td>Health checks always fail</td>\n<td>Command not found in container image</td>\n<td>Run health command manually in container</td>\n<td>Ensure health command exists in container PATH</td>\n</tr>\n<tr>\n<td>Metrics collection causes high CPU usage</td>\n<td>Too frequent polling of cgroup files</td>\n<td>Check metrics collection interval</td>\n<td>Increase collection interval or use more efficient polling</td>\n</tr>\n<tr>\n<td>Build cache not working</td>\n<td>Cache keys not matching actual inputs</td>\n<td>Check cache key generation logic</td>\n<td>Include all build context files in cache key hash</td>\n</tr>\n<tr>\n<td>Registry authentication fails</td>\n<td>Token expired or invalid</td>\n<td>Enable debug logging in registry client</td>\n<td>Implement token refresh logic with retry</td>\n</tr>\n<tr>\n<td>Network plugin fails to load</td>\n<td>Missing dependencies or wrong ABI</td>\n<td>Check plugin logs and required symbols</td>\n<td>Ensure plugin is built with compatible Go version and imports</td>\n</tr>\n</tbody></table>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (this section provides a reference for all technical terms used throughout the design document)</p>\n</blockquote>\n<h3 id=\"terms-and-definitions\">Terms and Definitions</h3>\n<p>This glossary defines all key technical terms, acronyms, and domain-specific vocabulary used throughout the Build Your Own Docker design document. Terms are organized by conceptual domain to facilitate understanding of related concepts.</p>\n<h4 id=\"container-runtime-core-concepts\">Container Runtime Core Concepts</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container</strong></td>\n<td>An isolated, resource-controlled process environment that appears to the process as a complete operating system but shares the host kernel with other containers.</td>\n</tr>\n<tr>\n<td><strong>Container Runtime</strong></td>\n<td>The software responsible for creating, managing, and destroying containers using Linux primitives like namespaces and cgroups.</td>\n</tr>\n<tr>\n<td><strong>Process Isolation</strong></td>\n<td>The technique of using kernel features to prevent processes from seeing or interfering with processes, filesystems, network interfaces, and other system resources belonging to other containers or the host system.</td>\n</tr>\n<tr>\n<td><strong>Linux Kernel</strong></td>\n<td>The core operating system component that provides namespaces, cgroups, and other containerization primitives as system calls and kernel features.</td>\n</tr>\n<tr>\n<td><strong>System Call (syscall)</strong></td>\n<td>A programmatic way for a userspace program to request services from the Linux kernel, such as creating new processes, managing memory, or interacting with filesystems.</td>\n</tr>\n<tr>\n<td><strong>State Machine</strong></td>\n<td>A mathematical model of computation with a finite number of states, where the system transitions between states in response to events or inputs. Our container runtime uses a state machine to manage container lifecycle states (<code>Created</code>, <code>Running</code>, <code>Paused</code>, <code>Stopped</code>, <code>Removed</code>).</td>\n</tr>\n<tr>\n<td><strong>Content-Addressable Storage (CAS)</strong></td>\n<td>A storage paradigm where content is retrieved based on its cryptographic hash (digest) rather than its location. This ensures integrity and enables deduplication of identical content across multiple images.</td>\n</tr>\n<tr>\n<td><strong>Copy-on-Write (CoW)</strong></td>\n<td>An optimization strategy where multiple callers share the same resource until one needs to modify it, at which point a private copy is created. Used extensively in container filesystems to share base image layers.</td>\n</tr>\n<tr>\n<td><strong>Reference Counting</strong></td>\n<td>A technique for tracking the number of references to a shared resource, allowing the resource to be safely freed when the count reaches zero. Used for managing layer cache entries and container resources.</td>\n</tr>\n<tr>\n<td><strong>Configuration Merging</strong></td>\n<td>The process of combining settings from multiple sources (image configuration, user configuration, default values) with well-defined precedence rules to produce the final container configuration.</td>\n</tr>\n<tr>\n<td><strong>Compensating Transactions</strong></td>\n<td>A design pattern where for every operation that modifies system state, there is a corresponding cleanup operation that can undo or clean up that modification in case of failure.</td>\n</tr>\n<tr>\n<td><strong>Cleanup Stack</strong></td>\n<td>A pattern where operations push cleanup functions onto a stack as they succeed, ensuring resources are properly released in reverse order of acquisition if an error occurs.</td>\n</tr>\n<tr>\n<td><strong>Idempotent Cleanup</strong></td>\n<td>Cleanup operations that can be safely called multiple times without causing errors or side effects, crucial for robust error recovery in distributed systems.</td>\n</tr>\n<tr>\n<td><strong>Orphan Detection</strong></td>\n<td>The process of finding resources (cgroups, network interfaces, mount points) not associated with any known container, typically during system startup or cleanup operations.</td>\n</tr>\n<tr>\n<td><strong>Transaction Logging</strong></td>\n<td>Writing intentions to a log before performing operations, enabling crash recovery by replaying or compensating logged operations after a system failure.</td>\n</tr>\n<tr>\n<td><strong>Content Integrity</strong></td>\n<td>Ensuring that downloaded or stored content hasn&#39;t been corrupted, typically verified using cryptographic hashes (SHA-256 digests) before use.</td>\n</tr>\n<tr>\n<td><strong>Structured Logging</strong></td>\n<td>Logging with key-value fields instead of plain text messages, enabling better filtering, searching, and analysis of runtime events.</td>\n</tr>\n<tr>\n<td><strong>Debug Mode</strong></td>\n<td>A runtime mode with verbose logging, additional diagnostics, and potentially slower execution for troubleshooting container runtime issues.</td>\n</tr>\n</tbody></table>\n<h4 id=\"process-isolation-namespaces\">Process Isolation (Namespaces)</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Namespace</strong></td>\n<td>A Linux kernel feature that isolates global system resources so that processes in one namespace have their own independent view of system resources like process IDs, hostnames, user IDs, mount points, and network interfaces.</td>\n</tr>\n<tr>\n<td><strong>PID Namespace</strong></td>\n<td>A namespace that isolates process IDs, allowing processes in different namespaces to have the same PID. The first process in a PID namespace gets PID 1 and typically acts as an init process for that namespace.</td>\n</tr>\n<tr>\n<td><strong>Network Namespace</strong></td>\n<td>A namespace that isolates network stack resources including network interfaces, IP addresses, routing tables, and firewall rules. Each network namespace has its own private loopback interface and can be connected to other namespaces via virtual Ethernet pairs.</td>\n</tr>\n<tr>\n<td><strong>Mount Namespace</strong></td>\n<td>A namespace that isolates mount points, allowing processes in different namespaces to have different views of the filesystem hierarchy. Mount operations (mount, unmount) in one namespace do not affect other namespaces.</td>\n</tr>\n<tr>\n<td><strong>UTS Namespace</strong></td>\n<td>A namespace that isolates system identifiers, specifically the hostname and domain name, allowing containers to have their own hostname independent of the host system.</td>\n</tr>\n<tr>\n<td><strong>IPC Namespace</strong></td>\n<td>A namespace that isolates inter-process communication resources such as System V IPC objects and POSIX message queues.</td>\n</tr>\n<tr>\n<td><strong>User Namespace</strong></td>\n<td>A namespace that isolates user and group ID mappings, allowing a process to have root privileges inside the namespace while being an unprivileged user outside.</td>\n</tr>\n<tr>\n<td><strong>Namespace ID</strong></td>\n<td>A unique identifier for a Linux namespace instance, visible as an inode number in <code>/proc/[pid]/ns/[type]</code> and used with the <code>setns()</code> system call to join existing namespaces.</td>\n</tr>\n<tr>\n<td><strong>clone()</strong></td>\n<td>A Linux system call that creates a new process (child) that may share parts of its execution context with the calling process (parent). Flags like <code>CLONE_NEWPID</code>, <code>CLONE_NEWNET</code> specify which namespaces to create for the new process.</td>\n</tr>\n<tr>\n<td><strong>unshare()</strong></td>\n<td>A Linux system call that allows a process to disassociate parts of its execution context that were previously shared with other processes, effectively creating new namespaces for the calling process without creating a new process.</td>\n</tr>\n<tr>\n<td><strong>setns()</strong></td>\n<td>A Linux system call that allows a process to join an existing namespace specified by a file descriptor, typically obtained from <code>/proc/[pid]/ns/[type]</code>.</td>\n</tr>\n<tr>\n<td><strong>SysProcAttr</strong></td>\n<td>A Go struct in the <code>syscall</code> package that allows setting process creation attributes, including namespace configuration flags for the <code>clone()</code> system call when creating new processes.</td>\n</tr>\n<tr>\n<td><strong>/proc/self/exe</strong></td>\n<td>A symbolic link in the proc filesystem that points to the current executable. Used in container runtimes to re-execute the runtime binary with different arguments for the child process in new namespaces.</td>\n</tr>\n</tbody></table>\n<h4 id=\"resource-limits-cgroups\">Resource Limits (cgroups)</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>cgroup (Control Group)</strong></td>\n<td>A Linux kernel feature for limiting, accounting for, and isolating resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.</td>\n</tr>\n<tr>\n<td><strong>cgroup v1</strong></td>\n<td>The original cgroup implementation with separate hierarchies for different resource controllers (memory, cpu, blkio, etc.), allowing different process groupings for each controller.</td>\n</tr>\n<tr>\n<td><strong>cgroup v2</strong></td>\n<td>The unified cgroup hierarchy that provides a consistent interface with all controllers mounted under a single filesystem hierarchy, offering improved consistency and new features.</td>\n</tr>\n<tr>\n<td><strong>Controller</strong></td>\n<td>A cgroup subsystem that manages a specific resource type, such as <code>memory</code> for memory limits, <code>cpu</code> for CPU scheduling, or <code>pids</code> for process count limits.</td>\n</tr>\n<tr>\n<td><strong>cgroup Hierarchy</strong></td>\n<td>A tree structure of cgroups where child cgroups inherit resource limits from parent cgroups, with further restrictions possible at each level.</td>\n</tr>\n<tr>\n<td><strong>OOM Killer (Out-Of-Memory Killer)</strong></td>\n<td>A kernel mechanism that selects and terminates processes when the system is critically low on memory. cgroups can trigger the OOM killer within specific cgroups when memory limits are exceeded.</td>\n</tr>\n<tr>\n<td><strong>RSS (Resident Set Size)</strong></td>\n<td>The portion of a process&#39;s memory held in physical RAM (as opposed to swapped out to disk). cgroup memory limits typically apply to RSS plus kernel memory allocations.</td>\n</tr>\n<tr>\n<td><strong>CPU Shares</strong></td>\n<td>A relative weight in the CPU controller that determines the proportion of CPU time available to a cgroup relative to sibling cgroups when the system is under contention.</td>\n</tr>\n<tr>\n<td><strong>CPU Quota</strong></td>\n<td>An absolute limit in the CPU controller that caps the amount of CPU time a cgroup can consume within a specified period, expressed as <code>quota/period</code> microseconds.</td>\n</tr>\n<tr>\n<td><strong>PIDs Limit</strong></td>\n<td>A cgroup controller that restricts the maximum number of processes (including threads) that can be created within a cgroup, preventing fork bombs and runaway process creation.</td>\n</tr>\n</tbody></table>\n<h4 id=\"filesystem-isolation\">Filesystem Isolation</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>rootfs (Root Filesystem)</strong></td>\n<td>The filesystem mounted at the root directory (<code>/</code>) of a container, containing all binaries, libraries, and configuration files needed for the containerized process to run.</td>\n</tr>\n<tr>\n<td><strong>chroot</strong></td>\n<td>A system call that changes the root directory for the calling process and its children, restricting filesystem access to the subtree under the new root. Without mount namespace isolation, chroot is considered escapable.</td>\n</tr>\n<tr>\n<td><strong>pivot_root</strong></td>\n<td>A system call that atomically swaps the root filesystem of the calling process with a new root filesystem, then unmounts the old root. This provides stronger isolation than chroot when combined with mount namespaces.</td>\n</tr>\n<tr>\n<td><strong>Mount Propagation</strong></td>\n<td>Determines how mount and unmount events propagate between mount namespaces. <code>MS_SHARED</code> mounts propagate to peer namespaces, <code>MS_PRIVATE</code> mounts do not, and <code>MS_SLAVE</code> mounts receive but do not send propagation events.</td>\n</tr>\n<tr>\n<td><strong>procfs (proc Filesystem)</strong></td>\n<td>A virtual filesystem mounted at <code>/proc</code> that provides information about processes and other system information in a hierarchical file-like structure. Containers need their own procfs mount to see their own processes.</td>\n</tr>\n<tr>\n<td><strong>sysfs (sys Filesystem)</strong></td>\n<td>A virtual filesystem mounted at <code>/sys</code> that provides a hierarchical view of kernel devices, drivers, and other kernel parameters. Typically mounted read-only in containers.</td>\n</tr>\n<tr>\n<td><strong>tmpfs (Temporary Filesystem)</strong></td>\n<td>A temporary in-memory filesystem that uses RAM and/or swap space. Used for <code>/dev</code>, <code>/run</code>, and other temporary directories in containers.</td>\n</tr>\n<tr>\n<td><strong>Bind Mount</strong></td>\n<td>A mount operation that makes an existing directory or file available at another location in the filesystem hierarchy. Changes to the bind mount are reflected at the original location and vice versa.</td>\n</tr>\n<tr>\n<td><strong>Device Node</strong></td>\n<td>A special file in <code>/dev</code> that represents a hardware or virtual device. Containers typically need a minimal set of device nodes (<code>null</code>, <code>zero</code>, <code>random</code>, <code>urandom</code>, <code>tty</code>, <code>console</code>) for applications to function.</td>\n</tr>\n</tbody></table>\n<h4 id=\"layered-filesystem-overlayfs\">Layered Filesystem (OverlayFS)</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>OverlayFS</strong></td>\n<td>A union filesystem that layers multiple directories (called layers) into a single unified view, commonly used in container runtimes to stack image layers efficiently.</td>\n</tr>\n<tr>\n<td><strong>Lower Directory (lowerdir)</strong></td>\n<td>In OverlayFS, one or more read-only directories that form the base layers of the union. Files are read from the highest priority lower directory where they exist.</td>\n</tr>\n<tr>\n<td><strong>Upper Directory (upperdir)</strong></td>\n<td>In OverlayFS, a writable directory where all modifications (creates, writes, deletes) are stored. This layer captures container filesystem changes without modifying the read-only lower layers.</td>\n</tr>\n<tr>\n<td><strong>Work Directory (workdir)</strong></td>\n<td>In OverlayFS, an empty directory used by the kernel for preparing files before moving them to the upper directory during copy-on-write operations. Must be on the same filesystem as the upper directory.</td>\n</tr>\n<tr>\n<td><strong>Merged View</strong></td>\n<td>The unified filesystem view presented to the container process, combining files from all lower directories with modifications from the upper directory.</td>\n</tr>\n<tr>\n<td><strong>Whiteout</strong></td>\n<td>A special file (character device with device numbers 0,0) in the upper directory that marks a file or directory in a lower layer as deleted. Named <code>.wh.&lt;filename&gt;</code> in OverlayFS.</td>\n</tr>\n<tr>\n<td><strong>Opaque Directory</strong></td>\n<td>A special extended attribute (<code>trusted.overlay.opaque=&quot;y&quot;</code>) or directory named <code>overlay-opaque</code> that marks a directory in the upper layer as opaque, hiding all contents from lower layers within that directory.</td>\n</tr>\n<tr>\n<td><strong>Layer</strong></td>\n<td>A read-only filesystem snapshot representing a set of filesystem changes. Container images are composed of stacked layers, each representing a step in the image build process.</td>\n</tr>\n<tr>\n<td><strong>Copy-on-Write (CoW)</strong></td>\n<td>In filesystem context, a technique where a file is copied from a lower (read-only) layer to the upper (writable) layer only when it is modified, conserving disk space and reducing write amplification.</td>\n</tr>\n<tr>\n<td><strong>Union Mount</strong></td>\n<td>A mount that presents a composite view of multiple directories, with precedence rules determining which file appears when the same path exists in multiple source directories. OverlayFS is one implementation of union mounting.</td>\n</tr>\n</tbody></table>\n<h4 id=\"container-networking\">Container Networking</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Network Namespace</strong></td>\n<td>A Linux namespace that provides an isolated network stack with its own network interfaces, IP addresses, routing tables, and firewall rules.</td>\n</tr>\n<tr>\n<td><strong>Virtual Ethernet Pair (veth pair)</strong></td>\n<td>A pair of virtual network devices that act as a tunnel between network namespaces. Packets transmitted on one device are received on the other, connecting namespaces like a virtual network cable.</td>\n</tr>\n<tr>\n<td><strong>Linux Bridge</strong></td>\n<td>A virtual switch implemented in the kernel that forwards packets between multiple network interfaces (physical or virtual). Used to connect multiple container veth endpoints on the same subnet.</td>\n</tr>\n<tr>\n<td><strong>iptables</strong></td>\n<td>A userspace utility for configuring Linux kernel firewall rules (netfilter). Used in container networking for NAT masquerading, port forwarding, and network policy enforcement.</td>\n</tr>\n<tr>\n<td><strong>NAT Masquerading</strong></td>\n<td>A form of network address translation where outbound packets from containers have their source IP address replaced with the host&#39;s IP address, allowing containers to reach external networks without publicly routable IPs.</td>\n</tr>\n<tr>\n<td><strong>Port Forwarding</strong></td>\n<td>The mapping of a port on the host to a port inside a container, allowing external connections to reach services running inside containers. Implemented via iptables DNAT (Destination Network Address Translation) rules.</td>\n</tr>\n<tr>\n<td><strong>IPAM (IP Address Management)</strong></td>\n<td>The process of allocating, tracking, and assigning IP addresses to containers from defined subnets, ensuring no address conflicts and efficient utilization of address space.</td>\n</tr>\n<tr>\n<td><strong>Dual-Stack Networking</strong></td>\n<td>Support for both IPv4 and IPv6 addressing simultaneously in container networks, requiring configuration of both address families in network namespaces and routing tables.</td>\n</tr>\n</tbody></table>\n<h4 id=\"image-format-and-oci\">Image Format and OCI</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>OCI (Open Container Initiative)</strong></td>\n<td>An open governance structure for creating open industry standards around container formats and runtimes, maintaining specifications for container images and runtime behavior.</td>\n</tr>\n<tr>\n<td><strong>OCI Image Specification</strong></td>\n<td>A specification that defines the format for container images, including the manifest, configuration, and layer descriptors, ensuring interoperability between different container tools.</td>\n</tr>\n<tr>\n<td><strong>OCI Runtime Specification</strong></td>\n<td>A specification that defines the configuration, execution environment, and lifecycle of containers, ensuring consistent behavior across different container runtimes.</td>\n</tr>\n<tr>\n<td><strong>Manifest</strong></td>\n<td>A JSON document describing the components of a container image, including layer digests, image configuration, and metadata. Serves as the entry point for locating and verifying image contents.</td>\n</tr>\n<tr>\n<td><strong>Digest</strong></td>\n<td>A cryptographic hash (typically SHA-256) used to uniquely and content-addressably identify a blob (layer, config, manifest) in an OCI image. Expressed as <code>algorithm:hex</code> (e.g., <code>sha256:abc123...</code>).</td>\n</tr>\n<tr>\n<td><strong>Blob</strong></td>\n<td>A binary large object stored in an OCI registry, such as a layer tar archive, image configuration JSON, or manifest JSON. Identified by its digest.</td>\n</tr>\n<tr>\n<td><strong>Tag</strong></td>\n<td>A human-readable alias that points to a specific image manifest in a registry, allowing users to reference images with names like <code>ubuntu:latest</code> rather than cryptographic digests.</td>\n</tr>\n<tr>\n<td><strong>Registry</strong></td>\n<td>A server that stores and distributes container images, implementing the OCI Distribution Specification. Docker Hub is a popular public registry; private registries can be deployed internally.</td>\n</tr>\n<tr>\n<td><strong>Authentication Flow</strong></td>\n<td>The process of obtaining and presenting credentials (username/password, tokens) to a registry to authenticate requests for pulling or pushing images.</td>\n</tr>\n<tr>\n<td><strong>Token Authentication</strong></td>\n<td>A bearer token-based authentication mechanism where the registry returns a short-lived token after initial authentication, used for subsequent API requests.</td>\n</tr>\n</tbody></table>\n<h4 id=\"cli-and-user-interface\">CLI and User Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>CLI (Command Line Interface)</strong></td>\n<td>The text-based interface through which users interact with the container runtime by typing commands, options, and arguments in a terminal or shell.</td>\n</tr>\n<tr>\n<td><strong>Inspection Command</strong></td>\n<td>A CLI subcommand (e.g., <code>inspect</code>) that gathers and displays detailed information about a container&#39;s configuration, state, network settings, and resource usage.</td>\n</tr>\n<tr>\n<td><strong>Sequence Diagram</strong></td>\n<td>A visual representation of component interactions over time, showing messages passed between actors and components in a specific sequence. Used in design documents to illustrate complex workflows.</td>\n</tr>\n<tr>\n<td><strong>State Transition</strong></td>\n<td>A change from one state to another in a state machine, triggered by an event or condition. In our container runtime, transitions like <code>Created</code> → <code>Running</code> occur when the user issues a <code>start</code> command.</td>\n</tr>\n</tbody></table>\n<h4 id=\"state-management-and-data-structures\">State Management and Data Structures</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Container</strong></td>\n<td>The primary data structure representing a container instance, containing fields for <code>ID</code>, <code>Name</code>, <code>State</code>, <code>Config</code>, <code>Pid</code>, and <code>CreatedAt</code>.</td>\n</tr>\n<tr>\n<td><strong>ContainerConfig</strong></td>\n<td>Configuration settings for a container, including <code>Image</code> name, command (<code>Cmd</code>), environment variables (<code>Env</code>), working directory (<code>WorkingDir</code>), hostname (<code>Hostname</code>), resource limits (<code>Limits</code>), and network settings (<code>Network</code>).</td>\n</tr>\n<tr>\n<td><strong>ContainerState</strong></td>\n<td>An enumeration representing the current lifecycle state of a container: <code>Created</code>, <code>Running</code>, <code>Paused</code>, <code>Stopped</code>, or <code>Removed</code>.</td>\n</tr>\n<tr>\n<td><strong>ResourceLimits</strong></td>\n<td>Configuration for container resource constraints, including memory limit in megabytes (<code>MemoryMB</code>), CPU shares (<code>CPUShares</code>), and maximum process count (<code>PidsLimit</code>).</td>\n</tr>\n<tr>\n<td><strong>NetworkConfig</strong></td>\n<td>Network configuration for a container, specifying the network mode (<code>Mode</code>), bridge name (<code>BridgeName</code>), IP address (<code>IPAddress</code>), and port mappings (<code>PortMappings</code>).</td>\n</tr>\n<tr>\n<td><strong>PortMapping</strong></td>\n<td>A mapping between a host port and a container port with a specified protocol (TCP/UDP), allowing external access to containerized services.</td>\n</tr>\n<tr>\n<td><strong>Image</strong></td>\n<td>A data structure representing a container image, containing fields for <code>Name</code>, <code>Digest</code>, <code>Layers</code>, and <code>Config</code>.</td>\n</tr>\n<tr>\n<td><strong>ImageLayer</strong></td>\n<td>A single layer in a container image, identified by its <code>Digest</code>, with <code>Size</code> in bytes and local filesystem <code>Path</code> where the extracted layer contents are stored.</td>\n</tr>\n<tr>\n<td><strong>ImageConfig</strong></td>\n<td>Configuration embedded in an image, specifying the default <code>Entrypoint</code>, <code>Cmd</code>, <code>Env</code>, and <code>WorkingDir</code> for containers created from this image.</td>\n</tr>\n<tr>\n<td><strong>ContainerStore</strong></td>\n<td>A component responsible for persisting container state to disk, typically storing JSON representations in a directory structure under a <code>basePath</code>.</td>\n</tr>\n</tbody></table>\n<h4 id=\"error-handling-and-debugging\">Error Handling and Debugging</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Property-Based Testing</strong></td>\n<td>A testing methodology that verifies properties hold for automatically generated inputs, using frameworks like QuickCheck to generate thousands of test cases and find edge cases.</td>\n</tr>\n<tr>\n<td><strong>Fuzz Testing</strong></td>\n<td>A testing technique that provides random, unexpected, or invalid inputs to a program to uncover security vulnerabilities, crashes, or incorrect behavior.</td>\n</tr>\n<tr>\n<td><strong>Integration Test</strong></td>\n<td>A test that combines multiple components to verify they work together correctly, often involving actual system calls and external dependencies.</td>\n</tr>\n<tr>\n<td><strong>System Test</strong></td>\n<td>An end-to-end test of the complete system from user command to container execution, verifying the entire workflow matches expected behavior.</td>\n</tr>\n<tr>\n<td><strong>Mock</strong></td>\n<td>A test double that simulates the behavior of a real component, allowing isolated testing of a component without its dependencies.</td>\n</tr>\n<tr>\n<td><strong>Test Fixture</strong></td>\n<td>A fixed state used as a baseline for running tests, ensuring tests start with known, reproducible conditions.</td>\n</tr>\n<tr>\n<td><strong>Race Condition</strong></td>\n<td>A defect where the output or behavior depends on the sequence or timing of uncontrollable events, often occurring in concurrent programming when multiple threads access shared data without proper synchronization.</td>\n</tr>\n<tr>\n<td><strong>Test Pyramid</strong></td>\n<td>A concept describing the ideal distribution of tests: many fast, isolated unit tests; fewer integration tests; and even fewer slow, expensive system tests.</td>\n</tr>\n<tr>\n<td><strong>Packet Tracing</strong></td>\n<td>Monitoring network packets through the networking stack using tools like <code>tcpdump</code>, <code>Wireshark</code>, or kernel tracing facilities to diagnose container networking issues.</td>\n</tr>\n<tr>\n<td><strong>Process Tree</strong></td>\n<td>The hierarchical relationship between parent and child processes, visible via commands like <code>pstree</code>. Container runtimes must manage process trees within containers to properly handle orphaned processes.</td>\n</tr>\n<tr>\n<td><strong>System Call Tracing</strong></td>\n<td>Monitoring system calls made by a process using tools like <code>strace</code> or <code>sysdig</code> to understand behavior, diagnose failures, or detect security issues.</td>\n</tr>\n<tr>\n<td><strong>Resource Accounting</strong></td>\n<td>Tracking resource usage (CPU, memory, I/O) by containers over time, enabling monitoring, billing, and capacity planning.</td>\n</tr>\n</tbody></table>\n<h4 id=\"security\">Security</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>seccomp (Secure Computing Mode)</strong></td>\n<td>A Linux kernel feature for filtering system calls available to a process, allowing restriction of the kernel surface area exposed to containers to reduce attack vectors.</td>\n</tr>\n<tr>\n<td><strong>Capabilities</strong></td>\n<td>Fine-grained permissions that divide the omnipotent root privilege into distinct units, allowing containers to be granted specific privileges (e.g., <code>CAP_NET_ADMIN</code> for network configuration) without full root access.</td>\n</tr>\n<tr>\n<td><strong>Seccomp Profile</strong></td>\n<td>A JSON configuration defining which system calls are allowed, which are restricted, and what action to take (allow, error, kill) for filtered calls.</td>\n</tr>\n<tr>\n<td><strong>SyscallRule</strong></td>\n<td>A rule within a seccomp profile specifying system call names, action, and optional argument constraints.</td>\n</tr>\n<tr>\n<td><strong>User Namespace</strong></td>\n<td>A namespace that isolates user and group IDs, enabling privilege escalation within the namespace while maintaining unprivileged execution on the host—a key security feature for rootless containers.</td>\n</tr>\n</tbody></table>\n<h4 id=\"storage-and-volumes\">Storage and Volumes</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Volume</strong></td>\n<td>A unit of persistent storage that can be mounted into containers, surviving container lifecycle operations (stop, remove). Volumes can be backed by host directories, network storage, or other storage drivers.</td>\n</tr>\n<tr>\n<td><strong>VolumeDriver</strong></td>\n<td>An interface defining operations for volume management: <code>Create</code>, <code>Remove</code>, <code>Mount</code>, <code>Unmount</code>, <code>Path</code>, and <code>DriverName</code>. Different drivers implement storage for different backends (local, NFS, cloud storage).</td>\n</tr>\n<tr>\n<td><strong>VolumeManager</strong></td>\n<td>A component that manages volumes using registered drivers, tracking volume state and providing a unified API for volume operations.</td>\n</tr>\n<tr>\n<td><strong>VolumeMount</strong></td>\n<td>A specification for mounting a volume into a container, including <code>Source</code> (volume name or host path), <code>Destination</code> (container mount path), <code>Type</code> (bind, volume), and mount <code>Options</code>.</td>\n</tr>\n<tr>\n<td><strong>Bind Mount</strong></td>\n<td>A type of volume mount that maps a host directory or file directly into a container, with changes reflected both directions.</td>\n</tr>\n<tr>\n<td><strong>tmpfs Mount</strong></td>\n<td>A mount of a temporary in-memory filesystem into a container, useful for sensitive data that shouldn&#39;t persist on disk.</td>\n</tr>\n</tbody></table>\n<h4 id=\"health-and-metrics\">Health and Metrics</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Health Check</strong></td>\n<td>A periodic command execution or HTTP request to verify that a containerized application is functioning correctly, with configurable interval, timeout, retries, and start period.</td>\n</tr>\n<tr>\n<td><strong>HealthCheckConfig</strong></td>\n<td>Configuration for health checks: <code>Test</code> command, <code>Interval</code> between checks, <code>Timeout</code> for each check, <code>StartPeriod</code> before checks begin, and <code>Retries</code> before marking unhealthy.</td>\n</tr>\n<tr>\n<td><strong>ContainerHealth</strong></td>\n<td>Current health status of a container: <code>Status</code> (healthy, unhealthy, starting), <code>FailingStreak</code> count, and <code>Log</code> of recent health check results.</td>\n</tr>\n<tr>\n<td><strong>HealthMonitor</strong></td>\n<td>A component that periodically executes health checks for running containers and updates their health status.</td>\n</tr>\n<tr>\n<td><strong>Metrics</strong></td>\n<td>Quantitative measurements of container resource usage, including CPU, memory, block I/O, network, and process counts.</td>\n</tr>\n<tr>\n<td><strong>ContainerMetrics</strong></td>\n<td>A snapshot of container metrics at a specific <code>Timestamp</code>, with detailed <code>CPU</code>, <code>Memory</code>, <code>BlockIO</code>, <code>Network</code>, and <code>PIDs</code> measurements.</td>\n</tr>\n<tr>\n<td><strong>MetricsCollector</strong></td>\n<td>A component that periodically gathers metrics from cgroups, network interfaces, and process information for running containers.</td>\n</tr>\n</tbody></table>\n<h4 id=\"future-extensions\">Future Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>CNI (Container Network Interface)</strong></td>\n<td>A plugin standard for configuring container networking, allowing interchangeable network implementations (bridge, macvlan, ipvlan, etc.) via executable plugins.</td>\n</tr>\n<tr>\n<td><strong>Plugin Architecture</strong></td>\n<td>A system design that supports interchangeable components via defined interfaces, allowing third-party extensions for networking, volumes, logging, and other functionality.</td>\n</tr>\n<tr>\n<td><strong>Dual-Stack</strong></td>\n<td>Networking that supports both IPv4 and IPv6 simultaneously, requiring configuration of both address families in container network namespaces.</td>\n</tr>\n<tr>\n<td><strong>Credential Store</strong></td>\n<td>Secure storage for authentication credentials (e.g., Docker config.json, keychain) used to authenticate with container registries.</td>\n</tr>\n<tr>\n<td><strong>Build System</strong></td>\n<td>A toolchain for creating container images from source code (Dockerfiles, Buildpacks) rather than pulling pre-built images from registries.</td>\n</tr>\n<tr>\n<td><strong>Checkpoint/Restore</strong></td>\n<td>The process of saving a container&#39;s state (memory, CPU registers, open files) to disk and later restoring it to resume execution from the saved point, enabling live migration and faster startups.</td>\n</tr>\n</tbody></table>\n<hr>\n","toc":[{"level":1,"text":"Build Your Own Docker: Design Document","id":"build-your-own-docker-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: Apartments in a Building","id":"mental-model-apartments-in-a-building"},{"level":3,"text":"The Isolation Problem in Concrete Terms","id":"the-isolation-problem-in-concrete-terms"},{"level":3,"text":"Existing Isolation Approaches Comparison","id":"existing-isolation-approaches-comparison"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Must-Have Goals","id":"must-have-goals"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview and Relationships","id":"component-overview-and-relationships"},{"level":4,"text":"Core Components and Their Responsibilities","id":"core-components-and-their-responsibilities"},{"level":4,"text":"Component Communication Patterns","id":"component-communication-patterns"},{"level":4,"text":"Key Architectural Decisions","id":"key-architectural-decisions"},{"level":4,"text":"System Entry Points and Control Flow","id":"system-entry-points-and-control-flow"},{"level":4,"text":"Data Persistence and State Management","id":"data-persistence-and-state-management"},{"level":3,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Project Root Layout","id":"project-root-layout"},{"level":4,"text":"Module Dependencies and Import Relationships","id":"module-dependencies-and-import-relationships"},{"level":4,"text":"Component Interface Definitions","id":"component-interface-definitions"},{"level":4,"text":"State Directory Structure","id":"state-directory-structure"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure (Starter Implementation)","id":"b-recommended-filemodule-structure-starter-implementation"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Key Types and Structures","id":"key-types-and-structures"},{"level":4,"text":"Container Lifecycle State (ContainerState)","id":"container-lifecycle-state-containerstate"},{"level":4,"text":"Container Configuration (ContainerConfig)","id":"container-configuration-containerconfig"},{"level":4,"text":"Resource Limits (ResourceLimits)","id":"resource-limits-resourcelimits"},{"level":4,"text":"Network Configuration (NetworkConfig and PortMapping)","id":"network-configuration-networkconfig-and-portmapping"},{"level":4,"text":"Container Runtime Instance (Container)","id":"container-runtime-instance-container"},{"level":4,"text":"Image Metadata (Image and ImageLayer)","id":"image-metadata-image-and-imagelayer"},{"level":3,"text":"Relationships Between Entities","id":"relationships-between-entities"},{"level":4,"text":"Container-Image Relationship","id":"container-image-relationship"},{"level":4,"text":"Container State Transitions","id":"container-state-transitions"},{"level":4,"text":"Layer Composition and Sharing","id":"layer-composition-and-sharing"},{"level":4,"text":"Network Configuration Inheritance","id":"network-configuration-inheritance"},{"level":4,"text":"Data Persistence Relationships","id":"data-persistence-relationships"},{"level":4,"text":"Component Ownership Relationships","id":"component-ownership-relationships"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component Design: Process Isolation (Milestone 1)","id":"component-design-process-isolation-milestone-1"},{"level":3,"text":"Mental Model: Private Rooms with Mirrored Walls","id":"mental-model-private-rooms-with-mirrored-walls"},{"level":3,"text":"Architecture Decision Records for Namespace Strategy","id":"architecture-decision-records-for-namespace-strategy"},{"level":3,"text":"Common Pitfalls in Namespace Implementation","id":"common-pitfalls-in-namespace-implementation"},{"level":3,"text":"Implementation Guidance for Namespace Isolation","id":"implementation-guidance-for-namespace-isolation"},{"level":2,"text":"Component Design: Resource Limits via cgroups (Milestone 2)","id":"component-design-resource-limits-via-cgroups-milestone-2"},{"level":3,"text":"Mental Model: Resource Quotas in an Apartment Building","id":"mental-model-resource-quotas-in-an-apartment-building"},{"level":3,"text":"Architecture Decision Records for cgroup Version","id":"architecture-decision-records-for-cgroup-version"},{"level":4,"text":"Decision: cgroup v2 as Primary Target with v1 Fallback","id":"decision-cgroup-v2-as-primary-target-with-v1-fallback"},{"level":4,"text":"Decision: Hierarchical cgroup Organization by Container ID","id":"decision-hierarchical-cgroup-organization-by-container-id"},{"level":3,"text":"Component Responsibilities and Interfaces","id":"component-responsibilities-and-interfaces"},{"level":4,"text":"Data Structures","id":"data-structures"},{"level":4,"text":"Interface Methods","id":"interface-methods"},{"level":3,"text":"Common Pitfalls in cgroup Implementation","id":"common-pitfalls-in-cgroup-implementation"},{"level":4,"text":"⚠️ Pitfall: Forgetting to Add the Process to the cgroup","id":"-pitfall-forgetting-to-add-the-process-to-the-cgroup"},{"level":4,"text":"⚠️ Pitfall: Not Handling cgroup v1 Controller Mounts","id":"-pitfall-not-handling-cgroup-v1-controller-mounts"},{"level":4,"text":"⚠️ Pitfall: Memory Limits Don&#39;t Account for Kernel Memory","id":"-pitfall-memory-limits-don39t-account-for-kernel-memory"},{"level":4,"text":"⚠️ Pitfall: Not Cleaning Up cgroups on Container Exit","id":"-pitfall-not-cleaning-up-cgroups-on-container-exit"},{"level":4,"text":"⚠️ Pitfall: Misunderstanding CPU Shares vs Quota/Period","id":"-pitfall-misunderstanding-cpu-shares-vs-quotaperiod"},{"level":3,"text":"Implementation Algorithm","id":"implementation-algorithm"},{"level":3,"text":"Integration with Container Creation Sequence","id":"integration-with-container-creation-sequence"},{"level":3,"text":"Error Handling and Recovery","id":"error-handling-and-recovery"},{"level":3,"text":"Example Walkthrough: Memory Limit Enforcement","id":"example-walkthrough-memory-limit-enforcement"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips Table","id":"g-debugging-tips-table"},{"level":2,"text":"Component Design: Filesystem Isolation (Milestone 3)","id":"component-design-filesystem-isolation-milestone-3"},{"level":3,"text":"Mental Model: Giving Each Apartment Its Own Furniture","id":"mental-model-giving-each-apartment-its-own-furniture"},{"level":3,"text":"Architecture Decision Records: pivot_root vs chroot","id":"architecture-decision-records-pivot_root-vs-chroot"},{"level":3,"text":"Common Pitfalls in Filesystem Isolation","id":"common-pitfalls-in-filesystem-isolation"},{"level":3,"text":"Implementation Guidance for Root Filesystem Setup","id":"implementation-guidance-for-root-filesystem-setup"},{"level":4,"text":"Step-by-Step Filesystem Isolation Procedure","id":"step-by-step-filesystem-isolation-procedure"},{"level":4,"text":"Component Responsibilities","id":"component-responsibilities"},{"level":4,"text":"Data Structures for Filesystem Management","id":"data-structures-for-filesystem-management"},{"level":4,"text":"Sequence of Operations","id":"sequence-of-operations"},{"level":4,"text":"Security Considerations","id":"security-considerations"},{"level":4,"text":"Example Walkthrough: Alpine Container Startup","id":"example-walkthrough-alpine-container-startup"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Component Design: Layered Filesystem (Milestone 4)","id":"component-design-layered-filesystem-milestone-4"},{"level":3,"text":"Mental Model: Transparent Overlays on a Projector","id":"mental-model-transparent-overlays-on-a-projector"},{"level":3,"text":"Architecture Decision Records: OverlayFS vs Alternatives","id":"architecture-decision-records-overlayfs-vs-alternatives"},{"level":4,"text":"Decision: OverlayFS for Layered Filesystem Implementation","id":"decision-overlayfs-for-layered-filesystem-implementation"},{"level":4,"text":"Decision: Multiple Lower Layer Support","id":"decision-multiple-lower-layer-support"},{"level":3,"text":"Common Pitfalls in OverlayFS Implementation","id":"common-pitfalls-in-overlayfs-implementation"},{"level":3,"text":"Implementation Guidance for Layered Filesystem","id":"implementation-guidance-for-layered-filesystem"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Component Design: Container Networking (Milestone 5)","id":"component-design-container-networking-milestone-5"},{"level":3,"text":"Mental Model: Private Phone Lines with a Switchboard","id":"mental-model-private-phone-lines-with-a-switchboard"},{"level":3,"text":"Architecture Decision Records: Network Topology","id":"architecture-decision-records-network-topology"},{"level":4,"text":"Decision: Bridge Network with NAT for Default Connectivity","id":"decision-bridge-network-with-nat-for-default-connectivity"},{"level":4,"text":"Decision: veth Pair for Container-Host Connectivity","id":"decision-veth-pair-for-container-host-connectivity"},{"level":4,"text":"Decision: iptables for NAT and Firewalling","id":"decision-iptables-for-nat-and-firewalling"},{"level":3,"text":"Common Pitfalls in Container Networking","id":"common-pitfalls-in-container-networking"},{"level":3,"text":"Implementation Guidance for Network Setup","id":"implementation-guidance-for-network-setup"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Component Design: Image Format and CLI (Milestone 6)","id":"component-design-image-format-and-cli-milestone-6"},{"level":3,"text":"Mental Model: Recipe Cards and Ingredient Boxes","id":"mental-model-recipe-cards-and-ingredient-boxes"},{"level":3,"text":"Architecture Decision Records: OCI Compatibility","id":"architecture-decision-records-oci-compatibility"},{"level":3,"text":"Common Pitfalls in Image Handling and CLI","id":"common-pitfalls-in-image-handling-and-cli"},{"level":3,"text":"Implementation Guidance for Image Format and CLI","id":"implementation-guidance-for-image-format-and-cli"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Container Creation Sequence","id":"container-creation-sequence"},{"level":3,"text":"Image Pull and Preparation Flow","id":"image-pull-and-preparation-flow"},{"level":3,"text":"Message and Configuration Formats","id":"message-and-configuration-formats"},{"level":4,"text":"Internal Component Communication","id":"internal-component-communication"},{"level":4,"text":"Persistent Storage Formats","id":"persistent-storage-formats"},{"level":4,"text":"External Protocol: OCI Registry API","id":"external-protocol-oci-registry-api"},{"level":4,"text":"Configuration Inheritance and Overrides","id":"configuration-inheritance-and-overrides"},{"level":4,"text":"Inter-Process Communication","id":"inter-process-communication"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Common Failure Modes and Detection","id":"common-failure-modes-and-detection"},{"level":4,"text":"System Call and Kernel Interface Failures","id":"system-call-and-kernel-interface-failures"},{"level":4,"text":"Resource Exhaustion Failures","id":"resource-exhaustion-failures"},{"level":4,"text":"User Configuration and Input Errors","id":"user-configuration-and-input-errors"},{"level":4,"text":"Race Conditions and State Inconsistencies","id":"race-conditions-and-state-inconsistencies"},{"level":4,"text":"External Dependency Failures","id":"external-dependency-failures"},{"level":3,"text":"Recovery and Cleanup Strategies","id":"recovery-and-cleanup-strategies"},{"level":4,"text":"State-Driven Cleanup Orchestration","id":"state-driven-cleanup-orchestration"},{"level":4,"text":"Idempotent Cleanup Operations","id":"idempotent-cleanup-operations"},{"level":4,"text":"Orphan Detection and Garbage Collection","id":"orphan-detection-and-garbage-collection"},{"level":4,"text":"Transaction Logging for Crash Recovery","id":"transaction-logging-for-crash-recovery"},{"level":3,"text":"Edge Case Scenarios","id":"edge-case-scenarios"},{"level":4,"text":"Container Process Behavior Edge Cases","id":"container-process-behavior-edge-cases"},{"level":4,"text":"Filesystem Edge Cases","id":"filesystem-edge-cases"},{"level":4,"text":"Networking Edge Cases","id":"networking-edge-cases"},{"level":4,"text":"Image and Storage Edge Cases","id":"image-and-storage-edge-cases"},{"level":4,"text":"Security and Permission Edge Cases","id":"security-and-permission-edge-cases"},{"level":4,"text":"Cross-Milestone Integration Edge Cases","id":"cross-milestone-integration-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Verification Approaches and Properties","id":"verification-approaches-and-properties"},{"level":4,"text":"1. Unit Testing: Component Isolation and Mocking","id":"1-unit-testing-component-isolation-and-mocking"},{"level":4,"text":"2. Integration Testing: Component Interaction with Real Dependencies","id":"2-integration-testing-component-interaction-with-real-dependencies"},{"level":4,"text":"3. System Testing: End-to-End Container Execution","id":"3-system-testing-end-to-end-container-execution"},{"level":4,"text":"4. Property-Based and Fuzz Testing","id":"4-property-based-and-fuzz-testing"},{"level":4,"text":"5. Negative Testing: Error Paths and Edge Cases","id":"5-negative-testing-error-paths-and-edge-cases"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Milestone 1: Process Isolation (Namespaces) Checkpoints","id":"milestone-1-process-isolation-namespaces-checkpoints"},{"level":4,"text":"Milestone 2: Resource Limits (cgroups) Checkpoints","id":"milestone-2-resource-limits-cgroups-checkpoints"},{"level":4,"text":"Milestone 3: Filesystem Isolation (chroot/pivot_root) Checkpoints","id":"milestone-3-filesystem-isolation-chrootpivot_root-checkpoints"},{"level":4,"text":"Milestone 4: Layered Filesystem (OverlayFS) Checkpoints","id":"milestone-4-layered-filesystem-overlayfs-checkpoints"},{"level":4,"text":"Milestone 5: Container Networking Checkpoints","id":"milestone-5-container-networking-checkpoints"},{"level":4,"text":"Milestone 6: Image Format and CLI Checkpoints","id":"milestone-6-image-format-and-cli-checkpoints"},{"level":3,"text":"Cross-Cutting Testing Concerns","id":"cross-cutting-testing-concerns"},{"level":3,"text":"Test Environment Requirements","id":"test-environment-requirements"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code for Tests","id":"d-core-logic-skeleton-code-for-tests"},{"level":4,"text":"E. Language-Specific Hints for Go Testing","id":"e-language-specific-hints-for-go-testing"},{"level":4,"text":"F. Milestone Checkpoint Validation Commands","id":"f-milestone-checkpoint-validation-commands"},{"level":4,"text":"G. Debugging Tips for Tests","id":"g-debugging-tips-for-tests"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Symptom → Cause → Fix Tables","id":"symptom-cause-fix-tables"},{"level":4,"text":"Namespace Isolation Issues","id":"namespace-isolation-issues"},{"level":4,"text":"cgroup Resource Limit Issues","id":"cgroup-resource-limit-issues"},{"level":4,"text":"Filesystem Isolation Issues","id":"filesystem-isolation-issues"},{"level":4,"text":"OverlayFS Issues","id":"overlayfs-issues"},{"level":4,"text":"Container Networking Issues","id":"container-networking-issues"},{"level":4,"text":"Image and CLI Issues","id":"image-and-cli-issues"},{"level":3,"text":"Domain-Specific Debugging Techniques","id":"domain-specific-debugging-techniques"},{"level":4,"text":"The &quot;Inception&quot; Debugging Method","id":"the-quotinceptionquot-debugging-method"},{"level":4,"text":"The &quot;Resource Accounting&quot; Audit","id":"the-quotresource-accountingquot-audit"},{"level":4,"text":"The &quot;Filesystem Forensics&quot; Approach","id":"the-quotfilesystem-forensicsquot-approach"},{"level":4,"text":"The &quot;Network Packet Surgery&quot;","id":"the-quotnetwork-packet-surgeryquot"},{"level":4,"text":"The &quot;Process Relationship Mapping&quot;","id":"the-quotprocess-relationship-mappingquot"},{"level":3,"text":"Tools for Inspecting System State","id":"tools-for-inspecting-system-state"},{"level":4,"text":"Namespace Inspection Tools","id":"namespace-inspection-tools"},{"level":4,"text":"cgroup Inspection Tools","id":"cgroup-inspection-tools"},{"level":4,"text":"Filesystem Inspection Tools","id":"filesystem-inspection-tools"},{"level":4,"text":"Network Inspection Tools","id":"network-inspection-tools"},{"level":4,"text":"Process and Container-Specific Tools","id":"process-and-container-specific-tools"},{"level":4,"text":"Custom Debugging Utilities for Your Runtime","id":"custom-debugging-utilities-for-your-runtime"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips Implementation","id":"debugging-tips-implementation"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Potential Enhancement Ideas","id":"potential-enhancement-ideas"},{"level":4,"text":"Security Hardening","id":"security-hardening"},{"level":4,"text":"Container Orchestration Features","id":"container-orchestration-features"},{"level":4,"text":"Storage and Networking Enhancements","id":"storage-and-networking-enhancements"},{"level":4,"text":"Usability and Production Features","id":"usability-and-production-features"},{"level":4,"text":"Architecture Decision: Incremental vs. Complete Rewrite","id":"architecture-decision-incremental-vs-complete-rewrite"},{"level":3,"text":"Design Accommodations for Extensions","id":"design-accommodations-for-extensions"},{"level":4,"text":"Security Hardening Accommodations","id":"security-hardening-accommodations"},{"level":4,"text":"Storage System Extensions","id":"storage-system-extensions"},{"level":4,"text":"Networking Plugin Architecture","id":"networking-plugin-architecture"},{"level":4,"text":"Orchestration Features Integration","id":"orchestration-features-integration"},{"level":4,"text":"Metrics Collection System","id":"metrics-collection-system"},{"level":4,"text":"Build System Implementation","id":"build-system-implementation"},{"level":4,"text":"Windows Container Support","id":"windows-container-support"},{"level":4,"text":"Registry Authentication System","id":"registry-authentication-system"},{"level":3,"text":"Summary of Extension Readiness","id":"summary-of-extension-readiness"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations for Extensions","id":"technology-recommendations-for-extensions"},{"level":4,"text":"Recommended File Structure for Extensions","id":"recommended-file-structure-for-extensions"},{"level":4,"text":"Security Hardening Starter Code","id":"security-hardening-starter-code"},{"level":4,"text":"Volume Management Skeleton","id":"volume-management-skeleton"},{"level":4,"text":"Language-Specific Hints for Extensions","id":"language-specific-hints-for-extensions"},{"level":4,"text":"Milestone Checkpoints for Extensions","id":"milestone-checkpoints-for-extensions"},{"level":4,"text":"Debugging Tips for Extensions","id":"debugging-tips-for-extensions"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Terms and Definitions","id":"terms-and-definitions"},{"level":4,"text":"Container Runtime Core Concepts","id":"container-runtime-core-concepts"},{"level":4,"text":"Process Isolation (Namespaces)","id":"process-isolation-namespaces"},{"level":4,"text":"Resource Limits (cgroups)","id":"resource-limits-cgroups"},{"level":4,"text":"Filesystem Isolation","id":"filesystem-isolation"},{"level":4,"text":"Layered Filesystem (OverlayFS)","id":"layered-filesystem-overlayfs"},{"level":4,"text":"Container Networking","id":"container-networking"},{"level":4,"text":"Image Format and OCI","id":"image-format-and-oci"},{"level":4,"text":"CLI and User Interface","id":"cli-and-user-interface"},{"level":4,"text":"State Management and Data Structures","id":"state-management-and-data-structures"},{"level":4,"text":"Error Handling and Debugging","id":"error-handling-and-debugging"},{"level":4,"text":"Security","id":"security"},{"level":4,"text":"Storage and Volumes","id":"storage-and-volumes"},{"level":4,"text":"Health and Metrics","id":"health-and-metrics"},{"level":4,"text":"Future Extensions","id":"future-extensions"}],"title":"Build Your Own Docker: Design Document","markdown":"# Build Your Own Docker: Design Document\n\n\n## Overview\n\nThis document outlines the architecture for a container runtime that isolates processes using Linux primitives like namespaces, cgroups, and union filesystems. The key architectural challenge is orchestrating these low-level OS features into a coherent, secure, and user-friendly containerization system while maintaining compatibility with OCI standards.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** All milestones (provides foundational understanding)\n\n### Mental Model: Apartments in a Building\n\nThink of your computer's operating system as a large apartment building. Each **process** (a running program like a web server or database) is a **tenant** living in this building. By default, all tenants share common spaces and resources:\n\n- They see the same **directory of residents** (process table)\n- They share the same **mailroom and packages** (filesystem)\n- They use the same **utility meters** (CPU, memory)\n- They're connected to the same **phone system** (network)\n- They have the same **building nameplate** (hostname)\n\nThis shared arrangement causes problems. A noisy tenant (a buggy process consuming all memory) disturbs everyone. A tenant rummaging through the mailroom (a process reading sensitive files) violates privacy. If one tenant changes the building's nameplate (hostname), it changes for everyone.\n\n**Containerization** is like giving each tenant their own fully-contained apartment unit within the same building:\n\n| Apartment Feature | Container Equivalent | Why It Matters |\n|------------------|----------------------|----------------|\n| Private walls | **Namespaces** (PID, network, mount) | Tenants can't see or interfere with each other's activities |\n| Individual utility meters | **cgroups** (CPU, memory limits) | No single tenant can monopolize building resources |\n| Custom furniture layout | **Root filesystem** (chroot/pivot_root) | Each tenant can decorate their space without affecting others |\n| Layered wallpaper | **Union filesystems** (OverlayFS) | Common decorative elements are shared, saving space |\n| Private phone line | **Network namespace** (veth pairs) | Tenants have separate phone numbers and can't eavesdrop |\n\nThe key architectural challenge is that while these apartments exist within the same physical building (the same Linux kernel), they must appear to be completely independent living spaces. The building superintendent (our container runtime) must:\n1. Construct these apartments on demand\n2. Install appropriate isolation features\n3. Connect utilities while maintaining separation\n4. Clean up when tenants leave\n\nThis mental model helps understand why we need multiple Linux primitives working together: namespaces provide the walls, cgroups provide the resource meters, and filesystem isolation provides the private furnishings.\n\n### The Isolation Problem in Concrete Terms\n\nConsider a typical deployment scenario: you need to run a web application consisting of a Node.js API server, a PostgreSQL database, and a Redis cache on a single physical server. Without isolation, these three processes:\n\n1. **See each other's processes** - The Node.js process can see and send signals to PostgreSQL workers\n2. **Share filesystem access** - A bug in Redis could delete PostgreSQL data files\n3. **Compete for resources** - A memory leak in Node.js could starve PostgreSQL of memory\n4. **Conflict on network ports** - All three try to listen on port 80 or use the same loopback interface\n5. **Share host identity** - All three report the same hostname to monitoring systems\n\nThe isolation problem manifests in these concrete technical requirements:\n\n**Requirement 1: Process Visibility Isolation**\n- **Problem**: `ps aux` run from within the Node.js process shows PostgreSQL and Redis workers\n- **Consequence**: Accidental termination, security exposure of process arguments\n- **Solution Needed**: Private process ID space where the containerized process sees itself as PID 1\n\n**Requirement 2: Filesystem Boundary Enforcement**\n- **Problem**: A path traversal bug in the web application allows reading `/etc/shadow`\n- **Consequence**: Complete system compromise via credential theft\n- **Solution Needed**: A virtual root directory that appears to be the entire filesystem\n\n**Requirement 3: Resource Fairness Guarantees**\n- **Problem**: Redis cache grows uncontrollably and triggers system-wide Out-Of-Memory killer\n- **Consequence**: Random important processes (SSH daemon, system logger) get killed\n- **Solution Needed**: Hard memory limits that only affect the offending container\n\n**Requirement 4: Network Stack Separation**\n- **Problem**: Redis binds to `127.0.0.1:6379`, preventing PostgreSQL from using loopback for replication\n- **Consequence**: Service conflicts, inability to run multiple instances\n- **Solution Needed**: Private network interfaces and routing tables per container\n\n**Requirement 5: Host Identity Segregation**\n- **Problem**: All services report the same hostname to centralized logging\n- **Consequence**: Debugging nightmare, monitoring confusion\n- **Solution Needed**: Independent UTS (Unix Timesharing System) namespace\n\nThe following table illustrates how these isolation failures manifest in practice:\n\n| Isolation Failure | Symptom | Attack Vector | Business Impact |\n|------------------|---------|---------------|-----------------|\n| PID namespace | Container process kills host `systemd` | Malicious container sends `SIGKILL` to PID 1 | System crash, requiring physical access |\n| Mount namespace | Container modifies host `/etc/passwd` | Path traversal or symlink attack | Complete system compromise |\n| Network namespace | Container sniffs other containers' traffic | ARP spoofing in shared network | Data breach across tenants |\n| cgroup failure | Container triggers host OOM killer | Memory exhaustion attack | Service outage for all containers |\n| UTS namespace | Container changes system hostname | Service masquerading | Monitoring/alerting system failure |\n\n> **Key Insight**: Isolation isn't just about security—it's about predictability. The fundamental value proposition of containers is that they provide **predictable, reproducible execution environments** regardless of the underlying host system configuration.\n\n### Existing Isolation Approaches Comparison\n\nBefore containers became mainstream, several approaches addressed isolation with different trade-offs in security, performance, and complexity. Understanding these alternatives clarifies why the Linux namespace+cgroup approach prevailed for application packaging and deployment.\n\n**Approach 1: Physical Servers**\nThe most complete isolation but maximum overhead.\n\n| Aspect | Physical Server | Container |\n|--------|-----------------|-----------|\n| **Isolation Level** | Complete physical separation | Kernel-level logical separation |\n| **Startup Time** | Minutes to hours | Milliseconds to seconds |\n| **Resource Efficiency** | Poor (idle resources wasted) | Excellent (shared kernel, dynamic allocation) |\n| **Density** | 1 application per server | 10s-100s per server |\n| **Operational Overhead** | High (individual maintenance) | Low (orchestrated management) |\n| **Use Case** | Legacy applications, maximum security | Microservices, CI/CD, PaaS |\n\n**Approach 2: Virtual Machines (VMs)**\nHardware-level virtualization with guest operating systems.\n\n| Aspect | Virtual Machine | Container |\n|--------|-----------------|-----------|\n| **Abstraction Level** | Hardware (CPU, memory, devices) | Operating system (processes, files, network) |\n| **Guest OS** | Full independent kernel | Shared host kernel |\n| **Isolation Mechanism** | Hypervisor + VM boundaries | Linux namespaces + cgroups |\n| **Overhead** | Higher (full OS + virtualization) | Lower (direct syscalls) |\n| **Image Size** | GBs (entire OS) | MBs (app + dependencies) |\n| **Boot Time** | Seconds to minutes | Sub-second |\n| **Security Boundary** | Strong (hardware isolation) | Weaker (kernel shared) |\n| **Use Case** | Multi-OS environments, strong isolation | Single-OS app packaging, high density |\n\n**Approach 3: chroot Jails**\nFilesystem isolation only—the historical precursor.\n\n| Aspect | chroot Jail | Container |\n|--------|-------------|-----------|\n| **Filesystem Isolation** | Yes (but escapable) | Yes (with mount namespace) |\n| **Process Isolation** | No (shared PID space) | Yes (PID namespace) |\n| **Network Isolation** | No (shared stack) | Yes (network namespace) |\n| **Resource Limits** | No | Yes (cgroups) |\n| **Security** | Weak (many escape vectors) | Moderate (with seccomp, SELinux) |\n| **Complexity** | Low | Moderate |\n| **Modern Relevance** | Legacy, specialized use cases | Standard application deployment |\n\n**Approach 4: BSD Jails / Solaris Zones**\nOS-level containerization in other Unix variants.\n\n| Aspect | BSD Jails | Linux Containers |\n|--------|-----------|------------------|\n| **OS Family** | BSD derivatives (FreeBSD) | Linux |\n| **Isolation Model** | Single unified jail mechanism | Composition of independent namespaces |\n| **Configuration** | Centralized jail configuration | Distributed across multiple subsystems |\n| **Ecosystem** | Smaller tooling ecosystem | Vast (Docker, Kubernetes, etc.) |\n| **Adoption** | Niche, specialized deployments | Industry standard |\n\n**Approach 5: Application Sandboxing (Firejail, Bubblewrap)**\nUser-space containment for desktop applications.\n\n| Aspect | Application Sandbox | System Container |\n|--------|---------------------|------------------|\n| **Target Use Case** | Desktop applications | Server applications |\n| **Privilege Level** | Often user namespace only | Full root capabilities |\n| **Orchestration** | Manual, per-application | Automated, cluster-wide |\n| **Networking** | Typically shared | Configurable topologies |\n| **Image Format** | None (uses host files) | Standardized (OCI) |\n\n> **Architecture Decision Record: Choosing Linux Primitives Over Alternatives**\n\n**Decision: Use Linux namespaces + cgroups for container isolation**\n\n**Context**: We need to build a container runtime for educational purposes that demonstrates real-world containerization principles while running efficiently on commodity Linux systems.\n\n**Options Considered**:\n1. **Full virtualization (KVM/QEMU)** - Complete isolation via hardware virtualization\n2. **User-space virtualization (gVisor)** - Syscall interception for stronger security\n3. **Linux namespaces + cgroups** - Native kernel features for OS-level virtualization\n\n**Decision**: Implement using Linux namespaces and cgroups.\n\n**Rationale**:\n1. **Educational value**: Namespaces and cgroups are the foundational primitives underlying Docker, LXC, and Kubernetes, making this knowledge transferable to production systems.\n2. **Minimal overhead**: No hypervisor layer or syscall translation means near-native performance for learning resource management concepts.\n3. **Incremental complexity**: Each primitive (PID, mount, network namespaces) can be implemented and tested independently, matching our milestone-based approach.\n4. **Ubiquitous availability**: Available on any modern Linux kernel without special hardware support (VT-x/AMD-V).\n5. **Compatibility with OCI**: The Open Container Initiative runtime specification expects these Linux primitives.\n\n**Consequences**:\n- **Positive**: Learners understand the actual mechanisms used by Docker, can debug production container issues, and gain low-level Linux systems knowledge.\n- **Negative**: Limited to Linux hosts, requires root privileges, and provides weaker security boundaries than virtualization (though can be enhanced with seccomp, SELinux).\n- **Trade-off**: We accept platform limitation for deeper understanding of the dominant containerization technology.\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| **Full Virtualization** | Strong isolation, multi-OS support, mature security model | High overhead, slow startup, complex implementation | Overkill for application packaging, obscures the Linux primitives we want to teach |\n| **User-space Virtualization** | Strong security via syscall filtering, no kernel sharing | Performance overhead, compatibility issues with some syscalls | Adds abstraction layer that hides the underlying Linux mechanisms |\n| **Linux Primitives** | Native performance, direct kernel interaction, industry standard | Weaker isolation, Linux-only, requires privileged operations | **CHOSEN**: Best for educational goals, matches real-world container runtimes |\n\n**The Evolution to Modern Containers**:\n\nThe containerization approach we're implementing represents an evolutionary convergence of several historical threads:\n\n1. **2000: FreeBSD Jails** - Introduced the concept of OS-level virtualization\n2. **2005: Solaris Zones** - Commercial implementation with resource controls\n3. **2008: LXC (Linux Containers)** - First complete container implementation for Linux\n4. **2013: Docker** - Developer-friendly tooling and image format\n5. **2015: OCI Specification** - Standardization of runtime and image formats\n6. **2017: Kubernetes dominance** - Orchestration ecosystem maturation\n\nOur implementation follows the architectural pattern established by LXC and standardized by OCI: composing discrete Linux kernel features into a coherent isolation boundary. This composition is both a strength (flexibility, incremental adoption) and a complexity (multiple subsystems to configure correctly).\n\n**Common Misconceptions About Container Isolation**:\n\n⚠️ **Pitfall: Assuming containers provide VM-level security**\n- **Misconception**: \"My containers are as isolated as virtual machines\"\n- **Reality**: Containers share the kernel, making kernel exploits catastrophic\n- **Fix**: Use additional hardening (seccomp profiles, SELinux, user namespaces) for production\n\n⚠️ **Pitfall: Believing cgroups prevent all resource exhaustion**\n- **Misconception**: \"Memory limit protects against all memory issues\"\n- **Reality**: cgroups memory limit doesn't cover page cache, swap, or kernel memory\n- **Fix**: Set multiple limits (`memory.limit_in_bytes`, `memory.kmem.limit_in_bytes`)\n\n⚠️ **Pitfall: Thinking network namespace equals network security**\n- **Misconception**: \"Network namespace prevents all network attacks\"\n- **Reality**: Containers on same bridge can ARP spoof each other\n- **Fix**: Use network policies, ebtables rules, or separate bridges\n\nThe following table summarizes how our container runtime addresses these historical approaches' limitations:\n\n| Historical Limitation | Our Solution | Implementation Component |\n|----------------------|--------------|--------------------------|\n| chroot escape via `..` | Mount namespace + pivot_root | Milestone 3 |\n| Resource monopolization | cgroups with memory/CPU limits | Milestone 2 |\n| Process visibility | PID namespace | Milestone 1 |\n| Network port conflicts | Network namespace + veth pairs | Milestone 5 |\n| Storage inefficiency | OverlayFS layered filesystem | Milestone 4 |\n| Non-standard formats | OCI image specification | Milestone 6 |\n\nBy understanding this context, learners appreciate that containerization isn't a revolutionary new technology but rather a clever composition of existing Linux features with developer-friendly tooling. This composition approach is what makes containers simultaneously powerful (leveraging decades of OS research) and accessible (hiding the complexity behind simple commands).\n\n---\n\n\n> **Milestone(s):** All milestones (providing foundational requirements and scope boundaries)\n\n## Goals and Non-Goals\n\nThis section establishes clear boundaries for what our container runtime will and will not accomplish. Building a production-grade container runtime like Docker involves immense complexity; our educational implementation focuses on the core isolation primitives while deliberately excluding enterprise features. These definitions serve as guardrails throughout development, ensuring we build something complete enough to demonstrate containerization concepts while remaining achievable within educational constraints.\n\n### Must-Have Goals\n\nThe following capabilities represent the non-negotiable requirements for our container runtime. Each goal maps directly to one or more milestones and implements a fundamental containerization concept.\n\n| Goal | Milestone | Concept Demonstrated | User Benefit | Implementation Requirements |\n|------|-----------|----------------------|--------------|-----------------------------|\n| **Process Isolation via Namespaces** | 1 | Kernel-level isolation of global system resources | Processes cannot see or interfere with other containers or the host system | Create PID, UTS, mount, network, and IPC namespaces using `clone()` or `unshare()` system calls |\n| **Resource Limiting via cgroups** | 2 | Enforce CPU, memory, and process count limits | Prevent any single container from monopolizing system resources | Create cgroup hierarchy, write limit values to control files, attach container processes |\n| **Filesystem Isolation via pivot_root** | 3 | Provide containers with their own root filesystem | Container sees only its own files, cannot access host filesystem | Extract base image, set up mount namespace, call `pivot_root()`, mount `/proc` and `/sys` |\n| **Copy-on-Write Layers via OverlayFS** | 4 | Efficient storage and sharing of container images | Multiple containers can share common base layers, saving disk space | Configure OverlayFS mounts with lower (read-only), upper (writable), and work directories |\n| **Container Networking via veth pairs** | 5 | Isolated network stack with external connectivity | Containers get private IP addresses and can communicate with each other and the internet | Create network namespace, set up veth pair, configure bridge, add iptables NAT rules |\n| **OCI Image Compatibility** | 6 | Standardized container image format | Can run containers from images built by Docker and other OCI-compliant tools | Parse OCI image manifests, download layers from registries, follow layer extraction specifications |\n| **Basic CLI Lifecycle Management** | 6 | Command-line interface for container operations | Users can create, start, stop, and remove containers with simple commands | Implement `create`, `start`, `stop`, `remove` commands with appropriate state transitions |\n| **Clean Resource Cleanup** | All | Proper cleanup of all isolation primitives | No orphaned namespaces, cgroups, or network interfaces after container removal | Track all created resources and implement cleanup handlers for all termination paths |\n| **Educational Clarity** | All | Code demonstrates concepts clearly | Learners understand how each Linux primitive contributes to containerization | Well-commented code, minimal abstraction layers, explicit error handling |\n\n> **Key Insight:** These goals form a **minimum viable container runtime**—enough to demonstrate how Docker works under the hood without implementing the complete feature set of production container runtimes. Each goal directly corresponds to a specific Linux kernel feature that containers rely upon.\n\n**Architecture Decision Record: Scope of Implementation**\n\n**Decision: Build an Educational Implementation Rather Than Production-Grade**\n- **Context**: This project aims to teach container internals, not to compete with Docker, containerd, or runc. Learners need to understand the fundamental Linux primitives without getting overwhelmed by enterprise features.\n- **Options Considered**:\n  1. **Full OCI Runtime Implementation**: Implement complete OCI runtime specification including all optional features, hooks, and security configurations.\n  2. **Educational Subset**: Implement only the core primitives that demonstrate container concepts, skipping complex edge cases and optimization.\n  3. **Docker-Compatible CLI**: Build a Docker CLI clone with identical command structure and flags.\n- **Decision**: Choose option 2 (Educational Subset) with basic OCI compatibility for image handling.\n- **Rationale**: \n  - Learning objectives focus on understanding namespaces, cgroups, and filesystem isolation, not production deployment concerns.\n  - A simpler implementation reduces cognitive load, allowing learners to focus on core concepts.\n  - Basic OCI compatibility demonstrates real-world standards without requiring full spec compliance.\n- **Consequences**:\n  - Cannot run all Docker images (some require features we don't implement).\n  - Performance and security are not production-grade.\n  - Learners gain deep understanding of fundamentals that apply to all container runtimes.\n\n**The Must-Have Goals in Practice:**\n\nFor each goal, we define concrete success criteria:\n\n1. **Process Isolation Success**: When running `ps aux` inside a container, the process list shows only processes within that container, with the container process as PID 1. Changing the hostname inside the container (`hostname mycontainer`) doesn't affect the host.\n   \n2. **Resource Limiting Success**: A container configured with 100MB memory limit gets terminated by the OOM killer when it allocates 101MB. A container with CPU shares of 512 gets approximately half the CPU time of a container with 1024 shares under contention.\n\n3. **Filesystem Isolation Success**: A container cannot read `/etc/hostname` from the host filesystem. The container's `/` directory shows files from the container image, not host files.\n\n4. **Layered Filesystem Success**: Two containers using the same base Ubuntu image share the read-only layers on disk. When one container modifies a file, the other container still sees the original version.\n\n5. **Networking Success**: Containers get IP addresses like `172.17.0.2` and can ping each other. Containers can access the internet via NAT. Host can forward port 8080 to a container's port 80.\n\n6. **Image Compatibility Success**: Can pull and run `alpine:latest` from Docker Hub. The container runs the correct entrypoint command with the expected environment.\n\n7. **CLI Success**: Users can run `./byod run -it ubuntu:latest /bin/bash` and get an interactive shell in a container, then exit and clean up with `./byod rm <container-id>`.\n\n### Explicit Non-Goals\n\nThe following capabilities are explicitly **not** part of our implementation. Understanding what we're omitting is as important as understanding what we're including—it defines the boundaries of our learning exercise.\n\n| Non-Goal | Reason for Exclusion | Real-World Implementation (for context) | What We Do Instead |\n|----------|----------------------|------------------------------------------|---------------------|\n| **Production Security Hardening** | Security is a complex domain requiring expertise beyond educational scope. Our implementation runs as root and doesn't implement security best practices. | Docker uses seccomp, SELinux/AppArmor, capabilities dropping, user namespaces with ID mapping | Run containers as root without additional security constraints; assume trusted environment |\n| **Orchestration Features** | Container orchestration (scheduling, service discovery, load balancing) is a separate domain from container runtime fundamentals. | Kubernetes, Docker Swarm, Nomad manage container lifecycle across hosts | Single-host runtime only; no clustering or scheduling |\n| **Volume Management** | Persistent storage involves complex lifecycle management and driver plugins beyond core isolation concepts. | Docker volumes with various storage drivers (local, NFS, cloud storage) | No persistent volume support; all container filesystem changes are ephemeral (in upper layer) |\n| **Container Registry Server** | Building a registry server duplicates effort and doesn't teach container runtime fundamentals. | Docker Registry, Amazon ECR, Google Container Registry | Client-only implementation that pulls from existing registries (Docker Hub) |\n| **Windows/MacOS Support** | Container internals differ fundamentally on non-Linux systems; our focus is Linux primitives. | Docker Desktop uses Linux VMs on Windows/Mac | Linux-only implementation requiring Linux kernel features |\n| **GPU/Device Passthrough** | Specialized hardware access requires complex driver integration and security considerations. | NVIDIA Container Toolkit, device plugins in Kubernetes | No device passthrough; containers access only standard virtual devices |\n| **Live Migration** | Process migration across hosts involves complex memory and filesystem synchronization beyond educational scope. | CRIU (Checkpoint/Restore In Userspace) for container migration | Single-host containers that cannot be checkpointed or migrated |\n| **Logging and Monitoring Infrastructure** | Production observability requires distributed systems design for log aggregation and metrics collection. | Docker logging drivers, Prometheus metrics, Fluentd log forwarding | Simple stdout/stderr capture to terminal; no log persistence or metrics |\n| **Image Build System** | Building images involves Dockerfile parsing, layer caching, and optimization strategies that warrant separate focus. | Docker Build, BuildKit, Kaniko | Pull and run pre-built images only; no `docker build` equivalent |\n| **Networking Plugins** | Advanced networking (overlay networks, service mesh, network policies) requires complex network virtualization. | CNI plugins, Calico, Flannel, Weave Net | Single bridge network with NAT; no plugin system or advanced topologies |\n| **Resource Quota Enforcement** | Fine-grained resource accounting (disk I/O, network bandwidth) requires complex cgroup controllers. | Docker uses blkio, net_cls, and net_prio cgroup controllers | Basic CPU and memory limits only; no I/O or network bandwidth limiting |\n| **Health Checks and Liveness Probes** | Container health monitoring requires process supervision and restart policies beyond simple process execution. | Docker HEALTHCHECK instruction, Kubernetes liveness/readiness probes | No health monitoring; container runs until main process exits |\n\n> **Important Boundary:** By explicitly stating these non-goals, we acknowledge that real container runtimes are far more complex than our implementation. This allows learners to focus on the fundamentals while understanding where additional complexity would be needed for production use.\n\n**Common Pitfalls to Avoid Given Our Non-Goals:**\n\n1. ⚠️ **Pitfall: Attempting to Implement Security Features Prematurely**\n   - **Description**: Learners might try to add user namespace mapping or seccomp profiles before mastering basic namespace isolation.\n   - **Why It's Wrong**: Adds unnecessary complexity when we're still learning fundamentals. Security without understanding the base isolation is fragile.\n   - **Fix**: Focus on making basic isolation work first. Add security features only after core functionality is stable.\n\n2. ⚠️ **Pitfall: Over-Engineering the CLI**\n   - **Description**: Spending excessive time building a Docker-compatible CLI with all flags and subcommands.\n   - **Why It's Wrong**: Distracts from the core learning objective of understanding Linux primitives. The CLI is just an interface to the runtime.\n   - **Fix**: Implement minimal CLI with just `run`, `ps`, `stop`, and `rm` commands. Use simple flag parsing.\n\n3. ⚠️ **Pitfall: Adding Orchestration Features**\n   - **Description**: Trying to implement multi-container applications or inter-container networking beyond basic bridge networking.\n   - **Why It's Wrong**: Orchestration builds upon container runtime fundamentals but is a separate layer of abstraction.\n   - **Fix**: Focus on single-container isolation. Multi-container coordination is out of scope.\n\n**Design Accommodations for Future Extensions:**\n\nWhile these are non-goals for the initial implementation, our architecture should not preclude adding them later:\n\n1. **Security Features**: The `ContainerConfig` type includes fields that could be extended for security settings (capabilities, seccomp profiles, user namespace mappings).\n\n2. **Volume Support**: The `FilesystemManager.SetupRootfs` method could be extended to mount additional volumes before container start.\n\n3. **Advanced Networking**: The `NetworkConfig` type's `Mode` field could support values beyond \"bridge\" (e.g., \"host\", \"none\", \"overlay\").\n\n4. **Logging**: The `Container` struct could include log file paths, and the runtime could redirect stdout/stderr to files.\n\nThese accommodations mean we choose extensible designs even for features we don't implement, following good software design principles while maintaining focus on educational objectives.\n\n### Implementation Guidance\n\n**Technology Recommendations Table:**\n\n| Component | Simple Option (Recommended) | Advanced Option (If Time Permits) |\n|-----------|----------------------------|-----------------------------------|\n| CLI Parsing | `flag` package (Go standard library) | `cobra` library for richer CLI experience |\n| Image Registry Client | HTTP client with basic auth for Docker Hub | Full OCI distribution client with token auth |\n| JSON Parsing | `encoding/json` for OCI manifests | Streaming JSON parser for large manifests |\n| Process Management | `os/exec` for host process management | Direct syscall usage for finer control |\n| Network Configuration | `netlink` library for veth creation | Raw socket operations for custom networking |\n\n**Recommended File/Module Structure:**\n\n```\nbuild-your-own-docker/\n├── cmd/\n│   └── byod/                    # CLI entry point\n│       └── main.go              # CLI command parsing and routing\n├── internal/\n│   ├── runtime/                 # Core container runtime\n│   │   ├── runtime.go           # ContainerRuntime implementation\n│   │   ├── container.go         # Container struct and lifecycle methods\n│   │   └── state.go             # ContainerState enum and state machine logic\n│   ├── namespaces/              # Milestone 1: Process isolation\n│   │   ├── manager.go           # NamespaceManager implementation\n│   │   └── flags.go             # Namespace flag constants and helpers\n│   ├── cgroups/                 # Milestone 2: Resource limits\n│   │   ├── manager.go           # CgroupManager implementation\n│   │   ├── v1/                  # cgroup v1 implementation\n│   │   └── v2/                  # cgroup v2 implementation\n│   ├── filesystem/              # Milestones 3 & 4: Filesystem isolation\n│   │   ├── manager.go           # FilesystemManager implementation\n│   │   ├── rootfs.go            # pivot_root and mount setup\n│   │   └── overlay.go           # OverlayFS layer management\n│   ├── network/                 # Milestone 5: Container networking\n│   │   ├── manager.go           # NetworkManager implementation\n│   │   ├── veth.go              # Virtual ethernet pair creation\n│   │   └── bridge.go            # Bridge network setup\n│   ├── image/                   # Milestone 6: OCI image handling\n│   │   ├── manager.go           # Image pull and parse\n│   │   ├── oci/                 # OCI spec structures\n│   │   └── registry/            # Registry client\n│   └── storage/                 # Container and image storage\n│       ├── store.go             # Persistent storage interface\n│       └── jsonfile/            # JSON file-based storage implementation\n├── pkg/\n│   └── types/                   # Shared data types\n│       ├── container.go         # Container, ContainerConfig types\n│       ├── image.go             # Image, ImageLayer types\n│       └── network.go           # NetworkConfig, PortMapping types\n└── scripts/                     # Helper scripts for testing\n    ├── test-isolation.sh        # Test namespace isolation\n    └── setup-bridge.sh          # Setup bridge network for testing\n```\n\n**Infrastructure Starter Code (Complete, ready to use):**\n\n```go\n// pkg/types/container.go\npackage types\n\nimport \"time\"\n\ntype ContainerState string\n\nconst (\n    StateCreated ContainerState = \"created\"\n    StateRunning ContainerState = \"running\"\n    StatePaused  ContainerState = \"paused\"\n    StateStopped ContainerState = \"stopped\"\n    StateRemoved ContainerState = \"removed\"\n)\n\ntype Container struct {\n    ID        string         `json:\"id\"`\n    Name      string         `json:\"name\"`\n    State     ContainerState `json:\"state\"`\n    Config    ContainerConfig `json:\"config\"`\n    Pid       int           `json:\"pid,omitempty\"`\n    CreatedAt time.Time     `json:\"created_at\"`\n}\n\ntype ContainerConfig struct {\n    Image      string         `json:\"image\"`\n    Cmd        []string       `json:\"cmd\"`\n    Env        []string       `json:\"env\"`\n    WorkingDir string         `json:\"working_dir\"`\n    Hostname   string         `json:\"hostname\"`\n    Limits     ResourceLimits `json:\"limits\"`\n    Network    NetworkConfig  `json:\"network\"`\n}\n\ntype ResourceLimits struct {\n    MemoryMB  int `json:\"memory_mb\"`\n    CPUShares int `json:\"cpu_shares\"`\n    PidsLimit int `json:\"pids_limit\"`\n}\n\ntype NetworkConfig struct {\n    Mode         string        `json:\"mode\"`\n    BridgeName   string        `json:\"bridge_name\"`\n    IPAddress    string        `json:\"ip_address\"`\n    PortMappings []PortMapping `json:\"port_mappings\"`\n}\n\ntype PortMapping struct {\n    HostPort      int    `json:\"host_port\"`\n    ContainerPort int    `json:\"container_port\"`\n    Protocol      string `json:\"protocol\"`\n}\n```\n\n**Core Logic Skeleton Code:**\n\n```go\n// internal/runtime/runtime.go\npackage runtime\n\nimport (\n    \"errors\"\n    \"github.com/your-org/byod/pkg/types\"\n)\n\ntype ContainerRuntime struct {\n    containers map[string]*types.Container\n    // TODO: Add other managers as fields\n}\n\nfunc NewContainerRuntime() *ContainerRuntime {\n    // TODO 1: Initialize the ContainerRuntime struct\n    // TODO 2: Set up the containers map\n    // TODO 3: Initialize any sub-managers (namespace, cgroup, filesystem, network)\n    // TODO 4: Return the initialized runtime\n    return nil\n}\n\nfunc (r *ContainerRuntime) CreateContainer(config types.ContainerConfig) (types.Container, error) {\n    // TODO 1: Validate the ContainerConfig (check required fields)\n    // TODO 2: Generate a unique container ID (use UUID or hash)\n    // TODO 3: Create Container struct with initial state (StateCreated)\n    // TODO 4: Store the container in runtime's container map\n    // TODO 5: Set up container root directory in filesystem\n    // TODO 6: Return the created container or error\n    return types.Container{}, errors.New(\"not implemented\")\n}\n\nfunc (r *ContainerRuntime) StartContainer(id string) error {\n    // TODO 1: Look up container by ID, return error if not found\n    // TODO 2: Check container is in StateCreated or StateStopped (valid start states)\n    // TODO 3: Update container state to StateRunning\n    // TODO 4: Create namespaces for the container (using NamespaceManager)\n    // TODO 5: Set up cgroups with resource limits (using CgroupManager)\n    // TODO 6: Set up root filesystem with pivot_root (using FilesystemManager)\n    // TODO 7: Configure network namespace (using NetworkManager)\n    // TODO 8: Execute the container's entrypoint command inside the namespaces\n    // TODO 9: Record the container's PID\n    // TODO 10: Handle errors and cleanup if any step fails\n    return errors.New(\"not implemented\")\n}\n\nfunc (r *ContainerRuntime) StopContainer(id string) error {\n    // TODO 1: Look up container by ID, return error if not found\n    // TODO 2: Check container is in StateRunning (can't stop non-running containers)\n    // TODO 3: Send SIGTERM to container process (use the recorded PID)\n    // TODO 4: Wait for process to exit (with timeout)\n    // TODO 5: If timeout, send SIGKILL\n    // TODO 6: Update container state to StateStopped\n    // TODO 7: Clean up network namespace (but keep other resources for possible restart)\n    // TODO 8: Handle errors appropriately\n    return errors.New(\"not implemented\")\n}\n\nfunc (r *ContainerRuntime) RemoveContainer(id string) error {\n    // TODO 1: Look up container by ID, return error if not found\n    // TODO 2: Check container is in StateStopped or StateCreated (can't remove running)\n    // TODO 3: If container has root filesystem, clean it up\n    // TODO 4: Remove cgroup hierarchy\n    // TODO 5: Remove container from runtime's container map\n    // TODO 6: Update container state to StateRemoved\n    // TODO 7: Handle errors and ensure cleanup is idempotent\n    return errors.New(\"not implemented\")\n}\n```\n\n**Language-Specific Hints:**\n\n1. **Go syscall Package**: Use `syscall.Syscall` or `syscall.RawSyscall` for direct system calls like `clone()`, `unshare()`, and `pivot_root()`.\n\n2. **Namespace Flags**: Use the exact constants from the naming conventions: `syscall.CLONE_NEWPID`, `syscall.CLONE_NEWNET`, etc.\n\n3. **Process Execution**: Use `syscall.Exec` to replace the current process with the container's entrypoint, not `os/exec.Command` which creates a child process.\n\n4. **Error Handling**: Check `errno` values after syscalls using `syscall.Errno` type to determine specific failure reasons.\n\n5. **File Operations**: Use `os` package for file operations, but remember `os.RemoveAll` for cleanup of container directories.\n\n6. **JSON Serialization**: Use `encoding/json` with struct tags for OCI manifest parsing and container state persistence.\n\n**Milestone Checkpoint - Goals Validation:**\n\nAfter implementing all six milestones, verify our must-have goals by running:\n\n```bash\n# Test process isolation\nsudo ./byod run --hostname mycontainer alpine:latest hostname\n# Should output: mycontainer (not the host's hostname)\n\n# Test resource limits\nsudo ./byod run --memory 100m alpine:latest sh -c \"tail /dev/zero\"\n# Should be OOM-killed within a few seconds\n\n# Test filesystem isolation\nsudo ./byod run alpine:latest ls /\n# Should show alpine rootfs contents, not host root files\n\n# Test layered filesystem\nsudo ./byod run alpine:latest touch /testfile\nsudo ./byod run alpine:latest ls /testfile\n# First command creates file, second should NOT see it (separate containers)\n\n# Test networking\nsudo ./byod run --net bridge alpine:latest ip addr show\n# Should show veth interface with private IP (172.17.0.x)\n\n# Test OCI image compatibility\nsudo ./byod pull ubuntu:latest\nsudo ./byod run ubuntu:latest echo \"Hello from Ubuntu\"\n# Should successfully download and run Ubuntu image\n```\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Container exits immediately | Missing or incorrect entrypoint command | Check OCI image config for `Entrypoint` and `Cmd` | Use image's entrypoint or provide command in `ContainerConfig.Cmd` |\n| `ps aux` shows host processes | PID namespace not properly isolated | Check `clone()` flags include `CLONE_NEWPID` | Ensure PID namespace is created before process starts |\n| Container cannot access internet | Missing NAT rules or DNS | Check `iptables -t nat -L` for MASQUERADE rule | Add iptables masquerade rule for bridge network |\n| \"Operation not permitted\" errors | Running without root privileges | Check `id` command output | Run container runtime with `sudo` |\n| OverlayFS mount fails | Missing kernel module or incorrect options | Check `dmesg \\| grep overlay` | Load overlay module: `sudo modprobe overlay` |\n\n---\n\n\n## High-Level Architecture\n\n> **Milestone(s):** All milestones (this section provides the overall architectural framework that unifies all six implementation milestones)\n\nThis section describes the macro-architecture of our container runtime—how all the Linux primitives (namespaces, cgroups, filesystem isolation) come together into a cohesive system. Think of this as the blueprint for a **container factory** with specialized assembly stations: each component handles one aspect of isolation, and the runtime orchestrates them in the correct sequence to produce fully isolated container environments.\n\n### Component Overview and Relationships\n\nImagine our container runtime as a **specialized manufacturing assembly line** for creating isolated process environments. Each workstation in this factory has a specific job:\n\n1. **The Design Office (CLI)** - Takes customer orders (commands) and translates them into work orders\n2. **The Factory Manager (Container Manager)** - Coordinates all workstations and ensures the assembly line flows correctly\n3. **The Privacy Room Constructor (Namespace Manager)** - Builds private rooms with mirrored walls (isolated views of system resources)\n4. **The Resource Meter (cgroup Manager)** - Installs smart meters that limit electricity, water, and occupancy in each room\n5. **The Furniture Installer (Filesystem Manager)** - Delivers and arranges customized furniture sets (root filesystems)\n6. **The Telephone System Technician (Network Manager)** - Sets up private phone lines with switchboards and external connections\n7. **The Inventory and Parts Department (Image Handler)** - Manages prefabricated furniture kits (container images) and their assembly instructions\n\nEach component has a single responsibility and communicates through well-defined interfaces managed by the Container Manager. The overall architecture follows a **coordinator pattern**: the Container Manager orchestrates all other components but delegates specific technical work to specialized managers.\n\n![System Component Diagram](./diagrams/system-component.svg)\n\n#### Core Components and Their Responsibilities\n\n| Component | Primary Responsibility | Key Data Owned | Collaborates With |\n|-----------|-----------------------|----------------|-------------------|\n| **CLI (Command Line Interface)** | User interaction, command parsing, output formatting | Command arguments, flags | Container Manager (via API) |\n| **Container Manager** | Container lifecycle orchestration, state management | `Container` registry, state transitions | All managers (delegates work) |\n| **Namespace Manager** | Linux namespace creation and isolation | Namespace file descriptors, isolation flags | Container Manager, Network Manager |\n| **cgroup Manager** | Resource limit enforcement via control groups | cgroup hierarchy paths, limit configurations | Container Manager, OS kernel |\n| **Filesystem Manager** | Root filesystem setup, layer management, mount operations | Rootfs paths, layer directories, mount points | Image Handler, Container Manager |\n| **Network Manager** | Network namespace configuration, virtual networking | veth pairs, bridge interfaces, IP allocations | Namespace Manager, Container Manager |\n| **Image Handler** | OCI image downloading, parsing, layer extraction | Image cache, layer manifests, configuration | Filesystem Manager, external registries |\n\n#### Component Communication Patterns\n\nThe system uses two primary communication patterns:\n\n1. **Orchestration Flow (Top-Down)**: The Container Manager receives requests from the CLI and sequentially invokes specialized managers in a specific order:\n   ```\n   CLI → Container Manager → Namespace Manager → cgroup Manager → \n   Filesystem Manager → Network Manager → Process Execution\n   ```\n\n2. **Data Flow (Configuration Passing)**: Each component receives a subset of the `ContainerConfig` relevant to its domain:\n   - `NamespaceManager` receives namespace flags\n   - `CgroupManager` receives `ResourceLimits`\n   - `FilesystemManager` receives `Image` and mount specifications\n   - `NetworkManager` receives `NetworkConfig`\n\n> **Architectural Insight**: The Container Manager acts as a **facade** over the complex Linux kernel interfaces. Users and the CLI interact with a simple container abstraction while the manager translates these operations into the appropriate sequence of low-level system calls and configurations.\n\n#### Key Architectural Decisions\n\n> **Decision: Coordinator Pattern Over Microservices**\n> - **Context**: We need to manage multiple Linux isolation primitives that must be applied in a specific sequence during container creation. The system runs on a single host and doesn't require distributed coordination.\n> - **Options Considered**:\n>   1. **Microservices architecture**: Each manager runs as a separate process with IPC\n>   2. **Monolithic runtime**: All logic in a single binary with internal modules\n>   3. **Coordinator pattern**: Main orchestrator with pluggable manager components\n> - **Decision**: Coordinator pattern with in-process managers\n> - **Rationale**: \n>   - Microservices add unnecessary IPC overhead for operations that require tight sequencing\n>   - Monolithic design makes testing and replacement of components difficult\n>   - Coordinator pattern provides clear separation of concerns while maintaining performance\n>   - In-process communication avoids serialization overhead for configuration passing\n> - **Consequences**:\n>   - Easier to test components in isolation via mock interfaces\n>   - Can swap implementations (e.g., cgroup v1 vs v2) without changing the coordinator\n>   - All components share the same memory space and life cycle\n>   - Single point of failure (if the coordinator crashes, all operations halt)\n\n| Architecture Option | Pros | Cons | Why Chosen? |\n|-------------------|------|------|-------------|\n| **Microservices** | Fault isolation, independent scaling, language polyglot | IPC overhead, complex deployment, sequencing difficulty | Overkill for single-host container runtime |\n| **Monolithic** | Performance, simplicity, no IPC | Hard to test, tight coupling, difficult to extend | Too rigid for educational project with clear component boundaries |\n| **Coordinator Pattern** | Clear separation, testable components, flexible implementations | Still single process, coordinator can become complex | **CHOSEN**: Balances separation with practical sequencing needs |\n\n> **Decision: Immutable Container Configuration**\n> - **Context**: Container properties (resource limits, network setup) must be established before process execution and shouldn't change during runtime for predictability and security.\n> - **Options Considered**:\n>   1. **Mutable configuration**: Allow runtime modifications to limits, network, etc.\n>   2. **Immutable configuration**: Freeze configuration after container creation\n> - **Decision**: Immutable `ContainerConfig` after container creation\n> - **Rationale**:\n>   - Changing cgroup limits during runtime can cause unpredictable behavior\n>   - Network reconfiguration while processes are running is complex and error-prone\n>   - Matches Docker/OCI runtime behavior (config changes require container restart)\n>   - Simplifies state management and validation\n> - **Consequences**:\n>   - Users must recreate containers to change most settings\n>   - Runtime code doesn't need to handle reconfiguration edge cases\n>   - Clearer audit trail of container properties\n\n#### System Entry Points and Control Flow\n\nThe system has three primary entry points that users interact with:\n\n1. **Container Lifecycle Commands**: `create`, `start`, `stop`, `remove`\n2. **Image Management Commands**: `pull`, `images`, `rmi`\n3. **System Inspection Commands**: `ps`, `inspect`, `logs`\n\nEach command follows a similar flow through the architecture:\n\n1. **CLI Parsing**: User command → flag parsing → validation\n2. **Request Routing**: CLI invokes appropriate method on `ContainerRuntime`\n3. **Orchestration**: `ContainerManager` sequences the required operations\n4. **Specialist Execution**: Specialized managers perform their isolated tasks\n5. **State Management**: Results are recorded in the container registry\n6. **Response**: Status/errors returned to user\n\n#### Data Persistence and State Management\n\nThe runtime maintains two primary forms of persistent state:\n\n| State Type | Storage Location | Purpose | Managed By |\n|------------|-----------------|---------|------------|\n| **Container Metadata** | JSON files in `/var/lib/container-runtime/containers/` | Track container state, configuration, PID | `ContainerManager` |\n| **Image Layers** | Directory structure in `/var/lib/container-runtime/images/` | Cache downloaded image layers for reuse | `ImageHandler` |\n| **cgroup Hierarchies** | Virtual filesystem at `/sys/fs/cgroup/` | Enforce resource limits across restarts | `cgroupManager` (with OS) |\n| **Network Namespaces** | Persistent references in `/var/run/netns/` | Maintain network isolation across processes | `NetworkManager` |\n\n> **Critical Design Insight**: The `ContainerManager` serves as the **system of record** for container state. All other managers are stateless relative to container lifecycle—they apply configurations when requested but don't track what they've applied. This centralization simplifies recovery and cleanup.\n\n### Recommended File/Module Structure\n\nOrganizing the codebase clearly from the start is crucial for managing the complexity of interacting with multiple Linux kernel subsystems. Think of this structure as **department offices in our factory**—each team (component) has its own workspace with clear boundaries and defined interfaces for collaboration.\n\n#### Project Root Layout\n\n```\nbuild-your-own-docker/\n├── cmd/\n│   └── containerd/                    # Main CLI binary (named to avoid confusion with actual Docker)\n│       └── main.go                    # Entry point: CLI parsing and routing\n├── internal/                          # Private application code (not for external use)\n│   ├── runtime/                       # Container Manager and core orchestration\n│   │   ├── container.go               # Container struct and state management\n│   │   ├── manager.go                 # ContainerManager implementation\n│   │   ├── runtime.go                 # ContainerRuntime interface implementation\n│   │   └── registry.go                # Container storage and retrieval\n│   ├── namespaces/                    # Namespace Manager\n│   │   ├── manager.go                 # NamespaceManager implementation\n│   │   ├── flags.go                   # Namespace flag constants and helpers\n│   │   └── unix.go                    # Low-level syscall wrappers\n│   ├── cgroups/                       # cgroup Manager\n│   │   ├── manager.go                 # CgroupManager implementation\n│   │   ├── v1/                        # cgroup v1 implementation\n│   │   │   └── controller.go          # v1-specific controller logic\n│   │   ├── v2/                        # cgroup v2 implementation\n│   │   │   └── controller.go          # v2-specific controller logic\n│   │   └── common.go                  # Shared cgroup utilities\n│   ├── filesystem/                    # Filesystem Manager\n│   │   ├── manager.go                 # FilesystemManager implementation\n│   │   ├── rootfs.go                  # Root filesystem setup (pivot_root)\n│   │   ├── overlay.go                 # OverlayFS mounting and management\n│   │   └── mounts.go                  /proc, /sys, /dev mounting\n│   ├── network/                       # Network Manager\n│   │   ├── manager.go                 # NetworkManager implementation\n│   │   ├── veth.go                    # Virtual ethernet pair creation\n│   │   ├── bridge.go                  # Linux bridge setup and management\n│   │   ├── iptables.go                # NAT and firewall rules\n│   │   └── dns.go                     # DNS/resolv.conf configuration\n│   └── image/                         # Image Handler\n│       ├── manager.go                 # ImageHandler implementation\n│       ├── oci/                       # OCI specification handling\n│       │   ├── manifest.go            # Manifest parsing and validation\n│       │   └── config.go              # Image config parsing\n│       ├── registry/                  # Registry client\n│       │   ├── client.go              # HTTP client for Docker Registry API\n│       │   └── auth.go                # Authentication handling\n│       └── storage.go                 # Layer storage and extraction\n├── pkg/                               # Public libraries (potentially reusable)\n│   ├── spec/                          # OCI specification types\n│   │   ├── container.go               # Container runtime spec types\n│   │   └── image.go                   # Image spec types\n│   └── utils/                         # General utilities\n│       ├── exec.go                    # Process execution helpers\n│       └── signal.go                  # Signal handling utilities\n├── var/                               # Runtime data (created at runtime)\n│   ├── lib/container-runtime/         # Persistent data\n│   │   ├── containers/                # Container state JSON files\n│   │   ├── images/                    # Extracted image layers\n│   │   └── overlay/                   # OverlayFS work and upper directories\n│   └── run/container-runtime/         # Ephemeral runtime data\n│       └── netns/                     # Network namespace bind mounts\n├── scripts/                           # Build and development scripts\n│   ├── setup.sh                       # Environment setup\n│   └── test.sh                        # Test runner\n├── examples/                          # Example configurations and usage\n│   ├── simple-container/              # Minimal container example\n│   └── custom-network/                # Network configuration example\n├── go.mod                             # Go module definition\n└── README.md                          # Project documentation\n```\n\n#### Module Dependencies and Import Relationships\n\nThe dependency flow follows the orchestration pattern: higher-level modules import lower-level ones, but not vice versa.\n\n```\ncmd/containerd/ → internal/runtime/ → [all other internal/ components]\n                                ↳ internal/namespaces/\n                                ↳ internal/cgroups/\n                                ↳ internal/filesystem/\n                                ↳ internal/network/\n                                ↳ internal/image/\n```\n\n**Key Dependency Rules:**\n1. **Horizontal dependencies are forbidden**: `internal/namespaces/` cannot import `internal/network/`\n2. **Upward dependencies are forbidden**: No internal component imports `cmd/`\n3. **Shared types live in `pkg/spec/`**: All managers import common types from here\n4. **Utilities are shared via `pkg/utils/`**: Common helpers used by multiple components\n\n#### Component Interface Definitions\n\nEach manager component implements a well-defined interface that the `ContainerManager` uses:\n\n| Interface | File Location | Key Methods | Used By |\n|-----------|---------------|-------------|---------|\n| `NamespaceManager` | `internal/namespaces/manager.go` | `CreateNamespaces(flags int) (int, error)` | `ContainerManager` during container creation |\n| `CgroupManager` | `internal/cgroups/manager.go` | `CreateGroup(path string) error`, `SetLimits(path string, limits ResourceLimits) error` | `ContainerManager` after namespace creation |\n| `FilesystemManager` | `internal/filesystem/manager.go` | `SetupRootfs(image Image, containerID string) (string, error)` | `ContainerManager` before process execution |\n| `NetworkManager` | `internal/network/manager.go` | `SetupNetwork(nsPath string, config NetworkConfig) error` | `ContainerManager` after filesystem setup |\n| `ImageHandler` | `internal/image/manager.go` | `Pull(imageName string) (Image, error)`, `Extract(image Image) error` | `ContainerManager` and `FilesystemManager` |\n\n> **Design Principle**: Each interface represents a **capability** not an implementation. This allows us to swap implementations (e.g., cgroup v1 vs v2) without changing the orchestration logic.\n\n#### State Directory Structure\n\nAt runtime, the system creates and manages the following directory structure under `/var/lib/container-runtime/`:\n\n```\n/var/lib/container-runtime/\n├── containers/                    # One subdirectory per container\n│   ├── {container-id}/           # Container-specific data\n│   │   ├── config.json           # ContainerConfig serialized\n│   │   ├── state.json            # Current ContainerState, PID, etc.\n│   │   └── rootfs/               # Container's root filesystem (if not using overlay)\n│   └── metadata.db               # Optional: SQLite for faster lookups\n├── images/                       # Extracted image layers\n│   ├── {image-digest}/           # One directory per image layer\n│   │   ├── layer.tar             # Original layer archive\n│   │   └── fs/                   # Extracted files\n│   └── manifests/                # Downloaded image manifests\n└── overlay/                      # OverlayFS directories\n    ├── {container-id}/           # Per-container overlay directories\n    │   ├── upper/                # Writable layer (changes)\n    │   ├── work/                 # Work directory for OverlayFS\n    │   └── merged/               # Unified view (actual rootfs)\n    └── layers/                   # Shared read-only lower layers\n```\n\nThis structure ensures:\n- **Isolation**: Each container's data is separate\n- **Persistence**: Container state survives runtime restarts\n- **Sharing**: Image layers are shared between containers\n- **Cleanup**: Removing a container deletes its directory entirely\n\n### Implementation Guidance\n\n> **Transition Note**: The following implementation guidance bridges the gap between architectural design and actual code. It provides concrete starting points for implementing the high-level structure described above.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option | Recommendation for Learning |\n|-----------|---------------|-----------------|-----------------------------|\n| **CLI Framework** | Standard `flag` package | `cobra` or `urfave/cli` | **Standard `flag`** (minimal dependencies, focuses on concepts) |\n| **Configuration Storage** | JSON files in directories | SQLite database | **JSON files** (transparent, easy to debug, matches OCI spec) |\n| **Image Registry Client** | Basic HTTP with `net/http` | Full OCI distribution client | **Basic HTTP** with authentication support (teaches registry API) |\n| **Process Management** | `os/exec` package | Direct syscall wrappers | **Mix**: `os/exec` for orchestration, syscalls for isolation |\n| **File System Operations** | `os` and `io` packages | Lower-level syscalls | **Standard library** (safer, portable across Unix-like systems) |\n| **Networking Setup** | `net` package + `exec` for `ip` commands | Direct netlink socket calls | **`exec` for `ip` and `iptables`** (simpler, mirrors actual admin work) |\n\n#### B. Recommended File/Module Structure (Starter Implementation)\n\nLet's begin with the minimal viable structure to get started. Create these files first:\n\n```\nbuild-your-own-docker/\n├── cmd/\n│   └── byod/                         # \"Build Your Own Docker\" CLI\n│       └── main.go                   # Start here - basic CLI skeleton\n├── internal/\n│   └── runtime/\n│       ├── container.go              # Core data structures\n│       └── manager.go                # ContainerManager skeleton\n├── pkg/\n│   └── spec/\n│       └── types.go                  # All type definitions\n└── go.mod                            # Initialize with: go mod init build-your-own-docker\n```\n\n#### C. Infrastructure Starter Code\n\n**File: `pkg/spec/types.go`** - Complete type definitions matching the naming conventions:\n\n```go\n// Package spec defines the core data types for the container runtime.\npackage spec\n\nimport (\n    \"time\"\n)\n\n// ContainerState represents the lifecycle state of a container.\ntype ContainerState string\n\nconst (\n    StateCreated ContainerState = \"created\"\n    StateRunning ContainerState = \"running\"\n    StatePaused  ContainerState = \"paused\"\n    StateStopped ContainerState = \"stopped\"\n    StateRemoved ContainerState = \"removed\"\n)\n\n// ResourceLimits defines resource constraints for a container.\ntype ResourceLimits struct {\n    MemoryMB  int // Memory limit in megabytes\n    CPUShares int // CPU shares (relative weight)\n    PidsLimit int // Maximum number of processes\n}\n\n// PortMapping defines a port forwarding rule.\ntype PortMapping struct {\n    HostPort      int    // Port on the host\n    ContainerPort int    // Port in the container\n    Protocol      string // \"tcp\" or \"udp\"\n}\n\n// NetworkConfig defines network settings for a container.\ntype NetworkConfig struct {\n    Mode         string       // \"bridge\", \"host\", \"none\"\n    BridgeName   string       // Name of the bridge interface\n    IPAddress    string       // Container IP address (optional)\n    PortMappings []PortMapping // Port forwarding rules\n}\n\n// ContainerConfig defines the configuration for creating a container.\ntype ContainerConfig struct {\n    Image      string         // Image name or ID\n    Cmd        []string       // Command to run (overrides image entrypoint)\n    Env        []string       // Environment variables\n    WorkingDir string         // Working directory inside container\n    Hostname   string         // Container hostname\n    Limits     ResourceLimits // Resource limits\n    Network    NetworkConfig  // Network configuration\n}\n\n// Container represents a running or stopped container.\ntype Container struct {\n    ID        string          // Unique container identifier\n    Name      string          // Human-readable name\n    State     ContainerState  // Current state\n    Config    ContainerConfig // Creation configuration\n    Pid       int             // Process ID of container process (if running)\n    CreatedAt time.Time       // Creation timestamp\n}\n\n// ImageLayer represents a single filesystem layer in an image.\ntype ImageLayer struct {\n    Digest string // SHA256 digest of layer content\n    Size   int64  // Size in bytes\n    Path   string // Local filesystem path to extracted layer\n}\n\n// ImageConfig defines the runtime configuration from an image.\ntype ImageConfig struct {\n    Entrypoint []string // Entrypoint command\n    Cmd        []string // Default arguments to entrypoint\n    Env        []string // Default environment variables\n    WorkingDir string   // Default working directory\n}\n\n// Image represents a container image.\ntype Image struct {\n    Name   string        // Image name (e.g., \"alpine:latest\")\n    Digest string        // SHA256 digest of image manifest\n    Layers []ImageLayer  // Filesystem layers\n    Config ImageConfig   // Image configuration\n}\n```\n\n**File: `cmd/byod/main.go`** - Basic CLI skeleton:\n\n```go\n// Package main implements the Build Your Own Docker CLI.\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \n    \"build-your-own-docker/internal/runtime\"\n)\n\nfunc main() {\n    // Initialize the container runtime\n    rt := runtime.NewContainerRuntime()\n    \n    // Parse command line arguments\n    if len(os.Args) < 2 {\n        printUsage()\n        os.Exit(1)\n    }\n    \n    command := os.Args[1]\n    args := os.Args[2:]\n    \n    switch command {\n    case \"run\":\n        runCommand(rt, args)\n    case \"create\":\n        createCommand(rt, args)\n    case \"start\":\n        startCommand(rt, args)\n    case \"stop\":\n        stopCommand(rt, args)\n    case \"rm\":\n        rmCommand(rt, args)\n    case \"ps\":\n        psCommand(rt, args)\n    case \"pull\":\n        pullCommand(rt, args)\n    case \"images\":\n        imagesCommand(rt, args)\n    default:\n        fmt.Printf(\"Unknown command: %s\\n\", command)\n        printUsage()\n        os.Exit(1)\n    }\n}\n\nfunc printUsage() {\n    fmt.Println(`Build Your Own Docker - A minimal container runtime\n\nUsage:\n  byod run [OPTIONS] IMAGE [COMMAND] [ARG...]\n  byod create [OPTIONS] IMAGE [COMMAND] [ARG...]\n  byod start [OPTIONS] CONTAINER\n  byod stop [OPTIONS] CONTAINER\n  byod rm [OPTIONS] CONTAINER\n  byod ps [OPTIONS]\n  byod pull [OPTIONS] IMAGE\n  byod images [OPTIONS]\n\nExamples:\n  byod run alpine:latest /bin/sh\n  byod ps\n  byod pull ubuntu:20.04`)\n}\n\n// TODO: Implement individual command handlers\nfunc runCommand(rt runtime.ContainerRuntime, args []string) {\n    log.Fatal(\"run command not yet implemented\")\n}\n\nfunc createCommand(rt runtime.ContainerRuntime, args []string) {\n    log.Fatal(\"create command not yet implemented\")\n}\n\nfunc startCommand(rt runtime.ContainerRuntime, args []string) {\n    log.Fatal(\"start command not yet implemented\")\n}\n\nfunc stopCommand(rt runtime.ContainerRuntime, args []string) {\n    log.Fatal(\"stop command not yet implemented\")\n}\n\nfunc rmCommand(rt runtime.ContainerRuntime, args []string) {\n    log.Fatal(\"rm command not yet implemented\")\n}\n\nfunc psCommand(rt runtime.ContainerRuntime, args []string) {\n    log.Fatal(\"ps command not yet implemented\")\n}\n\nfunc pullCommand(rt runtime.ContainerRuntime, args []string) {\n    log.Fatal(\"pull command not yet implemented\")\n}\n\nfunc imagesCommand(rt runtime.ContainerRuntime, args []string) {\n    log.Fatal(\"images command not yet implemented\")\n}\n```\n\n**File: `internal/runtime/container.go`** - Container registry and state management:\n\n```go\n// Package runtime implements the container lifecycle manager.\npackage runtime\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"sync\"\n    \"time\"\n    \n    \"build-your-own-docker/pkg/spec\"\n)\n\n// containerStore manages persistent container state.\ntype containerStore struct {\n    sync.RWMutex\n    baseDir string               // Directory for container state files\n    containers map[string]*spec.Container // In-memory cache\n}\n\n// newContainerStore creates a new container store.\nfunc newContainerStore(baseDir string) (*containerStore, error) {\n    // Ensure base directory exists\n    if err := os.MkdirAll(baseDir, 0755); err != nil {\n        return nil, fmt.Errorf(\"failed to create container store directory: %w\", err)\n    }\n    \n    return &containerStore{\n        baseDir:    baseDir,\n        containers: make(map[string]*spec.Container),\n    }, nil\n}\n\n// save writes a container's state to disk.\nfunc (s *containerStore) save(container *spec.Container) error {\n    s.Lock()\n    defer s.Unlock()\n    \n    // Create container directory\n    containerDir := filepath.Join(s.baseDir, container.ID)\n    if err := os.MkdirAll(containerDir, 0755); err != nil {\n        return fmt.Errorf(\"failed to create container directory: %w\", err)\n    }\n    \n    // Write config.json\n    configPath := filepath.Join(containerDir, \"config.json\")\n    configData, err := json.MarshalIndent(container.Config, \"\", \"  \")\n    if err != nil {\n        return fmt.Errorf(\"failed to marshal container config: %w\", err)\n    }\n    \n    if err := os.WriteFile(configPath, configData, 0644); err != nil {\n        return fmt.Errorf(\"failed to write container config: %w\", err)\n    }\n    \n    // Write state.json\n    statePath := filepath.Join(containerDir, \"state.json\")\n    stateData, err := json.MarshalIndent(struct {\n        ID        string\n        Name      string\n        State     spec.ContainerState\n        Pid       int\n        CreatedAt time.Time\n    }{\n        ID:        container.ID,\n        Name:      container.Name,\n        State:     container.State,\n        Pid:       container.Pid,\n        CreatedAt: container.CreatedAt,\n    }, \"\", \"  \")\n    \n    if err != nil {\n        return fmt.Errorf(\"failed to marshal container state: %w\", err)\n    }\n    \n    if err := os.WriteFile(statePath, stateData, 0644); err != nil {\n        return fmt.Errorf(\"failed to write container state: %w\", err)\n    }\n    \n    // Update in-memory cache\n    s.containers[container.ID] = container\n    \n    return nil\n}\n\n// load reads all containers from disk into memory.\nfunc (s *containerStore) load() error {\n    s.Lock()\n    defer s.Unlock()\n    \n    entries, err := os.ReadDir(s.baseDir)\n    if err != nil {\n        return fmt.Errorf(\"failed to read container store directory: %w\", err)\n    }\n    \n    for _, entry := range entries {\n        if !entry.IsDir() {\n            continue\n        }\n        \n        containerID := entry.Name()\n        containerDir := filepath.Join(s.baseDir, containerID)\n        \n        // Load config\n        configPath := filepath.Join(containerDir, \"config.json\")\n        configData, err := os.ReadFile(configPath)\n        if err != nil {\n            // Skip corrupt containers\n            continue\n        }\n        \n        var config spec.ContainerConfig\n        if err := json.Unmarshal(configData, &config); err != nil {\n            continue\n        }\n        \n        // Load state\n        statePath := filepath.Join(containerDir, \"state.json\")\n        stateData, err := os.ReadFile(statePath)\n        if err != nil {\n            continue\n        }\n        \n        var state struct {\n            ID        string\n            Name      string\n            State     spec.ContainerState\n            Pid       int\n            CreatedAt time.Time\n        }\n        \n        if err := json.Unmarshal(stateData, &state); err != nil {\n            continue\n        }\n        \n        container := &spec.Container{\n            ID:        state.ID,\n            Name:      state.Name,\n            State:     state.State,\n            Config:    config,\n            Pid:       state.Pid,\n            CreatedAt: state.CreatedAt,\n        }\n        \n        s.containers[container.ID] = container\n    }\n    \n    return nil\n}\n\n// get retrieves a container by ID.\nfunc (s *containerStore) get(id string) (*spec.Container, error) {\n    s.RLock()\n    defer s.RUnlock()\n    \n    container, exists := s.containers[id]\n    if !exists {\n        return nil, fmt.Errorf(\"container %s not found\", id)\n    }\n    \n    return container, nil\n}\n\n// list returns all containers.\nfunc (s *containerStore) list() []*spec.Container {\n    s.RLock()\n    defer s.RUnlock()\n    \n    containers := make([]*spec.Container, 0, len(s.containers))\n    for _, container := range s.containers {\n        containers = make([]*spec.Container, 0, len(s.containers))\n        for _, container := range s.containers {\n            containers = append(containers, container)\n        }\n    }\n    \n    return containers\n}\n\n// remove deletes a container from the store.\nfunc (s *containerStore) remove(id string) error {\n    s.Lock()\n    defer s.Unlock()\n    \n    // Delete from filesystem\n    containerDir := filepath.Join(s.baseDir, id)\n    if err := os.RemoveAll(containerDir); err != nil {\n        return fmt.Errorf(\"failed to remove container directory: %w\", err)\n    }\n    \n    // Delete from memory\n    delete(s.containers, id)\n    \n    return nil\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**File: `internal/runtime/manager.go`** - ContainerManager skeleton with detailed TODOs:\n\n```go\npackage runtime\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n    \n    \"build-your-own-docker/pkg/spec\"\n)\n\n// ContainerRuntime defines the interface for container operations.\ntype ContainerRuntime interface {\n    CreateContainer(config spec.ContainerConfig) (spec.Container, error)\n    StartContainer(id string) error\n    StopContainer(id string) error\n    RemoveContainer(id string) error\n    ListContainers() ([]spec.Container, error)\n}\n\n// ContainerManager implements ContainerRuntime.\ntype ContainerManager struct {\n    store *containerStore\n    // TODO: Add references to specialized managers as fields\n    // namespaceMgr namespaces.NamespaceManager\n    // cgroupMgr    cgroups.CgroupManager\n    // fsMgr        filesystem.FilesystemManager\n    // networkMgr   network.NetworkManager\n    // imageMgr     image.ImageHandler\n}\n\n// NewContainerRuntime creates a new container runtime instance.\nfunc NewContainerRuntime() ContainerRuntime {\n    // TODO 1: Initialize container store with default path (/var/lib/container-runtime)\n    // TODO 2: Load existing containers from disk\n    // TODO 3: Initialize specialized managers (nil for now)\n    \n    return &ContainerManager{\n        store: nil, // Will be initialized in TODO 1\n    }\n}\n\n// CreateContainer creates a new container with given configuration.\nfunc (m *ContainerManager) CreateContainer(config spec.ContainerConfig) (spec.Container, error) {\n    // TODO 1: Generate unique container ID (e.g., random 12-character hex string)\n    // TODO 2: Create Container struct with initial state (StateCreated)\n    // TODO 3: Validate configuration (check image exists, valid resource limits, etc.)\n    // TODO 4: Pull image if not already available locally\n    // TODO 5: Setup container directory in store\n    // TODO 6: Save container to store\n    // TODO 7: Return the created container\n    \n    return spec.Container{}, fmt.Errorf(\"not implemented\")\n}\n\n// StartContainer starts a created container.\nfunc (m *ContainerManager) StartContainer(id string) error {\n    // TODO 1: Retrieve container from store by ID\n    // TODO 2: Validate container is in StateCreated state\n    // TODO 3: Create Linux namespaces (PID, UTS, mount, network, IPC)\n    // TODO 4: Create and configure cgroup for container\n    // TODO 5: Setup root filesystem using image layers\n    // TODO 6: Configure network namespace (veth pair, bridge, IP, etc.)\n    // TODO 7: Execute the container process inside the namespaces\n    // TODO 8: Update container state to StateRunning and save PID\n    // TODO 9: Monitor container process (in goroutine) to detect exit\n    \n    return fmt.Errorf(\"not implemented\")\n}\n\n// StopContainer stops a running container.\nfunc (m *ContainerManager) StopContainer(id string) error {\n    // TODO 1: Retrieve container from store by ID\n    // TODO 2: Validate container is in StateRunning state\n    // TODO 3: Send SIGTERM to container process (PID)\n    // TODO 4: Wait for process termination with timeout\n    // TODO 5: If timeout, send SIGKILL\n    // TODO 6: Cleanup network namespace\n    // TODO 7: Remove cgroup\n    // TODO 8: Update container state to StateStopped\n    // TODO 9: Save updated state to store\n    \n    return fmt.Errorf(\"not implemented\")\n}\n\n// RemoveContainer removes a stopped container.\nfunc (m *ContainerManager) RemoveContainer(id string) error {\n    // TODO 1: Retrieve container from store by ID\n    // TODO 2: Validate container is in StateStopped state\n    // TODO 3: Remove container root filesystem (if not using overlay)\n    // TODO 4: Remove container directory from store\n    // TODO 5: Update container state to StateRemoved in memory (optional)\n    // TODO 6: Return success\n    \n    return fmt.Errorf(\"not implemented\")\n}\n\n// ListContainers returns all containers.\nfunc (m *ContainerManager) ListContainers() ([]spec.Container, error) {\n    // TODO 1: Retrieve all containers from store\n    // TODO 2: Convert to slice of spec.Container\n    // TODO 3: Return containers\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// generateID creates a unique container ID.\nfunc generateID() string {\n    const letters = \"abcdef0123456789\"\n    const idLength = 12\n    \n    rand.Seed(time.Now().UnixNano())\n    b := make([]byte, idLength)\n    for i := range b {\n        b[i] = letters[rand.Intn(len(letters))]\n    }\n    return string(b)\n}\n```\n\n#### E. Language-Specific Hints\n\n**Go-Specific Implementation Tips:**\n\n1. **Syscall vs. Exec**: Use the `syscall` package for namespace creation (`unshare`, `setns`, `clone`), but prefer `exec.Command` for configuring network (`ip`, `iptables`) to avoid reimplementing complex logic.\n\n2. **Process Management**: Use `os.StartProcess` instead of `os/exec` when you need fine-grained control over process attributes (like clone flags for namespaces).\n\n3. **File Operations**: Always use absolute paths when dealing with mount operations and namespace references to avoid confusion about which namespace you're operating in.\n\n4. **Error Handling**: Use `fmt.Errorf(\"... %w\", err)` to wrap errors with context, especially for syscalls where the raw error message might be unclear.\n\n5. **Concurrency**: Use `sync.RWMutex` for the container store since multiple goroutines might read container state while only one modifies it.\n\n6. **JSON Serialization**: Use `json.MarshalIndent` for debugging but regular `json.Marshal` for production to save space.\n\n#### F. Milestone Checkpoint\n\n**After implementing the basic structure above, verify your setup:**\n\n1. **Build the project**:\n   ```bash\n   go build ./cmd/byod\n   ```\n\n2. **Run the CLI without arguments** to see usage:\n   ```bash\n   ./byod\n   ```\n   Expected output: The usage message defined in `printUsage()`\n\n3. **Test each command stub**:\n   ```bash\n   ./byod run alpine:latest /bin/sh\n   ```\n   Expected: \"run command not yet implemented\" error\n\n4. **Check that types compile correctly**:\n   ```bash\n   go test ./pkg/spec/...\n   ```\n   Expected: No compilation errors (even with no tests)\n\n**Signs of correct setup:**\n- Binary compiles without errors\n- Each command shows appropriate \"not implemented\" message\n- Directory structure matches the blueprint\n- `go mod tidy` runs without dependency issues\n\n**Common setup problems:**\n- **\"cannot find module\"**: Run `go mod init build-your-own-docker` in project root\n- **Import path errors**: Ensure `go.mod` module name matches import paths\n- **Permission errors**: You'll need root/sudo for later milestones but not for this structure\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **\"Command not found\" when running ./byod** | File not executable or wrong path | Run `ls -la ./byod` | `chmod +x ./byod` or use `go run cmd/byod/main.go` |\n| **Import errors in Go files** | Incorrect module name or missing dependencies | Check `go.mod` first line matches import paths | Update `go.mod` or fix import statements |\n| **JSON marshaling fails** | Struct fields not exported (capitalized) | Check field names start with uppercase | Export fields: `Name` not `name` |\n| **Store directory not created** | Permission issues or parent doesn't exist | Check `os.MkdirAll` error return | Run with appropriate permissions or create parent directory |\n\n---\n\n\n## Data Model\n> **Milestone(s):** All milestones (this section defines the core data structures that every component will use to represent containers, images, and runtime state)\n\nThis section defines the foundational data structures that our container runtime uses to represent the state of the system. Think of these structures as **blueprints and records** in a construction project: the blueprints (`ContainerConfig`, `Image`) specify what to build, while the records (`Container`, runtime state) track what's actually been built and its current condition. These data models serve as the single source of truth that coordinates all our components—from namespace isolation to network configuration.\n\n### Key Types and Structures\n\nThe container runtime manipulates several core entity types, each with specific responsibilities and lifecycle. These structures capture everything from container configuration and runtime state to image metadata and network settings.\n\n#### Container Lifecycle State (`ContainerState`)\n\nContainers transition through a well-defined lifecycle, much like processes in an operating system. The `ContainerState` enumeration tracks where a container is in this lifecycle, enabling proper management operations and preventing invalid state transitions (like trying to start an already running container).\n\n| State | Description | Allowed Next States |\n|-------|-------------|---------------------|\n| `Created` | Container configuration has been validated and persisted, but the isolated process hasn't started yet. Namespaces, cgroups, and filesystems may be partially prepared. | `Running`, `Stopped` (if cleanup fails) |\n| `Running` | Container process is actively executing inside its isolated environment. All resources (namespaces, cgroups, network) are active and being used. | `Paused`, `Stopped` |\n| `Paused` | Container process is suspended (via cgroup freezer). The process exists but isn't scheduled for CPU time. Memory and other resources remain allocated. | `Running` (resumed), `Stopped` |\n| `Stopped` | Container process has terminated (either normally or via signal). Resources are still allocated but can be cleaned up. This is a terminal state before removal. | `Removed` |\n| `Removed` | All container resources have been released (namespaces destroyed, cgroups deleted, filesystems unmounted). Only metadata may remain for historical tracking. | (terminal state) |\n\nThe state machine ensures that operations like `StartContainer` can only be called on `Created` containers, while `RemoveContainer` requires a `Stopped` container, preventing resource leaks or inconsistent states.\n\n#### Container Configuration (`ContainerConfig`)\n\nThe `ContainerConfig` structure serves as the **recipe** for creating a container—it specifies what to run, with what resources, and in what environment. This is the primary input from users (via CLI or API) and contains all the settings needed to create an isolated environment.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Image` | `string` | Reference to the container image (e.g., \"alpine:latest\" or \"ubuntu:22.04\"). This identifies which root filesystem and default configuration to use. |\n| `Cmd` | `[]string` | Command and arguments to execute inside the container (overrides the image's default `Cmd`). Example: `[\"/bin/sh\", \"-c\", \"echo hello\"]`. |\n| `Env` | `[]string` | Environment variables in \"KEY=VALUE\" format that will be available to the container process. These are merged with (and can override) the image's environment variables. |\n| `WorkingDir` | `string` | Initial working directory for the container process. If empty, defaults to the image's `WorkingDir` or root (\"/\"). |\n| `Hostname` | `string` | Hostname to set inside the container's UTS namespace. If empty, defaults to the container ID or a generated name. |\n| `Limits` | `ResourceLimits` | Resource constraints (CPU, memory, process count) to apply via cgroups. Zero values typically mean \"no limit.\" |\n| `Network` | `NetworkConfig` | Network isolation and connectivity settings, including IP address, port mappings, and network mode. |\n\nThis configuration is **immutable** after container creation—runtime changes to resource limits or network settings would require complex live updates and are beyond our scope.\n\n#### Resource Limits (`ResourceLimits`)\n\nResource limits enforce **quotas** on container resource consumption, preventing any single container from monopolizing system resources. Think of these as utility caps in an apartment building—each unit gets a maximum allocation of water, electricity, and gas.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `MemoryMB` | `int` | Maximum resident memory (RAM) in megabytes that the container can use. When exceeded, the OOM killer terminates container processes. |\n| `CPUShares` | `int` | Relative CPU weight (in the cgroups v1 \"cpu.shares\" scheme). Default is 1024; values are proportional to other containers' shares. |\n| `PidsLimit` | `int` | Maximum number of processes (including threads) the container can create. Prevents fork bombs and process exhaustion attacks. |\n\n> **Design Insight:** We use simple integer fields rather than more complex types (like `uint64` or custom units) to keep the API straightforward for learners. In production systems, you'd want finer-grained controls (CPU quotas, memory+swap limits, I/O bandwidth), but these three limits cover the essential isolation concerns.\n\n#### Network Configuration (`NetworkConfig` and `PortMapping`)\n\nNetwork configuration defines how the container connects to networks—whether it's fully isolated, bridged to a host network, or uses host networking directly. The `PortMapping` structure enables **port forwarding**, similar to how a hotel switchboard directs external calls to specific room extensions.\n\n**`NetworkConfig` structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Mode` | `string` | Network isolation mode: \"bridge\" (default, private network with NAT), \"host\" (share host's network namespace), \"none\" (no network interfaces). |\n| `BridgeName` | `string` | Name of the Linux bridge to connect to (for \"bridge\" mode). Defaults to \"byob0\" (Build Your Own Bridge). |\n| `IPAddress` | `string` | Static IPv4 address to assign to the container (e.g., \"172.17.0.2\"). If empty, uses DHCP or automatic allocation from bridge subnet. |\n| `PortMappings` | `[]PortMapping` | List of port forwardings from host to container (e.g., host port 8080 → container port 80). |\n\n**`PortMapping` structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `HostPort` | `int` | Port number on the host interface (0-65535). Ports below 1024 typically require root privileges. |\n| `ContainerPort` | `int` | Port number inside the container network namespace (0-65535). |\n| `Protocol` | `string` | Transport protocol: \"tcp\" or \"udp\". Determines which iptables rule chain to modify. |\n\n> **Architecture Decision: Network Configuration Simplicity**\n> \n> **Context:** We need to provide network connectivity options for containers while keeping implementation complexity manageable for learners.\n> \n> **Options Considered:**\n> 1. **Full OCI network specification** with CNI plugins, multiple network interfaces, DNS configurations\n> 2. **Simple bridge-only model** with static IP assignment and basic port forwarding\n> 3. **Host-only networking** (simplest, but no isolation)\n> \n> **Decision:** Option 2 (simple bridge model) with extensible `Mode` field.\n> \n> **Rationale:** Bridge networking provides practical isolation while being implementable with standard Linux tools (ip, brctl, iptables). The `Mode` field allows future extension to \"host\" and \"none\" modes without breaking existing configurations. We avoid CNI complexity as it's a significant learning curve beyond core container concepts.\n> \n> **Consequences:** Containers get reasonable network isolation out-of-the-box, but advanced networking features (multiple networks, custom DNS, IPv6) would require significant extensions to the data model and implementation.\n\n#### Container Runtime Instance (`Container`)\n\nThe `Container` structure represents an **actual running or runnable instance**—it's the runtime manifestation of a `ContainerConfig`. Think of it as the difference between an architectural blueprint (`ContainerConfig`) and the actual constructed building (`Container`).\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ID` | `string` | Unique identifier (typically a random 64-bit hex string). Used to reference the container in all operations. |\n| `Name` | `string` | Human-readable name for the container (e.g., \"my-web-server\"). Must be unique across running containers. |\n| `State` | `ContainerState` | Current lifecycle state (Created, Running, etc.). Determines which operations are valid. |\n| `Config` | `ContainerConfig` | Immutable configuration used to create this container. Stored for reference and potential restart. |\n| `Pid` | `int` | Process ID of the container's init process on the host. Zero if container isn't running. Used to manage cgroup membership and send signals. |\n| `CreatedAt` | `time.Time` | Timestamp when the container was first created. Used for display (e.g., `docker ps`) and cleanup of old containers. |\n\nThe `Container` object is persisted to disk (typically as JSON) so the runtime can recover state after a restart. This is critical for operations like `StopContainer` to work—the runtime needs to know which host PID to signal.\n\n#### Image Metadata (`Image` and `ImageLayer`)\n\nImages are **immutable templates** for container filesystems. An image consists of multiple layers (like a layered cake) that are stacked together using OverlayFS. The `Image` structure represents a downloaded and extracted image, ready to be instantiated into containers.\n\n**`Image` structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Name` | `string` | Image reference including registry, repository, and tag (e.g., \"docker.io/library/alpine:latest\"). |\n| `Digest` | `string` | Cryptographic hash of the image manifest (SHA256). Uniquely identifies this exact image version. |\n| `Layers` | `[]ImageLayer` | Ordered list of filesystem layers (bottom to top) that make up the image's root filesystem. |\n| `Config` | `ImageConfig` | Default runtime configuration from the image (entrypoint, environment, working directory). |\n\n**`ImageLayer` structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Digest` | `string` | Content-addressable hash (SHA256) of the layer tarball. Used for caching and verification. |\n| `Size` | `int64` | Size of the layer tarball in bytes. Used for download progress reporting and disk space management. |\n| `Path` | `string` | Filesystem path where this layer's extracted contents are stored (typically in a content-addressable store). |\n\n**`ImageConfig` structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Entrypoint` | `[]string` | Default executable and arguments to run when container starts (e.g., `[\"/bin/myapp\"]`). |\n| `Cmd` | `[]string` | Default arguments to `Entrypoint` (overridden by container's `Cmd`). |\n| `Env` | `[]string` | Default environment variables (e.g., `[\"PATH=/usr/bin\", \"HOME=/root\"]`). |\n| `WorkingDir` | `string` | Default working directory if none specified in container config. |\n\n> **Design Insight:** The separation between `Image` metadata and `ContainerConfig` allows for inheritance and override patterns. When a container is created, its `ContainerConfig` merges with the `ImageConfig`—explicit container settings override image defaults, similar to how subclass methods override parent class methods in object-oriented programming.\n\n### Relationships Between Entities\n\nThe data model entities relate to each other in specific ways that define the overall system architecture. Understanding these relationships is crucial for implementing correct lifecycle management and resource cleanup.\n\n#### Container-Image Relationship\n\nA container **instantiates** an image, much like an object instantiates a class in programming. The relationship is directional: containers reference images, but images don't know about their running instances.\n\n```\nImage (template)\n    ↑ referenced by\nContainer (instance)\n```\n\n**Key behaviors:**\n- Multiple containers can reference the same image (sharing layers via OverlayFS)\n- Images are immutable; containers add writable layers on top\n- Deleting an image fails if any containers still reference it\n- Container configuration (`ContainerConfig`) overrides image defaults (`ImageConfig`)\n\nThis relationship is managed through the `ContainerConfig.Image` field, which contains the image name or digest. The runtime resolves this to an actual `Image` object during container creation.\n\n#### Container State Transitions\n\nThe container lifecycle defines a **state machine** where each transition corresponds to a management operation. The following table shows all valid transitions and the operations that trigger them:\n\n| Current State | Event/Operation | Next State | Actions Performed During Transition |\n|---------------|----------------|------------|-------------------------------------|\n| (nonexistent) | `CreateContainer` | `Created` | Validate config, allocate ID, persist metadata, prepare namespaces and rootfs |\n| `Created` | `StartContainer` | `Running` | Create cgroups, apply limits, setup network, start init process |\n| `Created` | `RemoveContainer` | `Removed` | Clean up any prepared resources (namespaces, rootfs) |\n| `Running` | `StopContainer` (or process exits) | `Stopped` | Send termination signal, wait for exit, update state |\n| `Running` | `PauseContainer` | `Paused` | Freeze cgroup, suspend all processes |\n| `Paused` | `ResumeContainer` | `Running` | Unfreeze cgroup, resume processes |\n| `Stopped` | `RemoveContainer` | `Removed` | Delete cgroups, network namespace, mounted filesystems |\n| Any | Error during operation | `Stopped` | Clean up partially created resources, log error |\n\n> **Critical Implementation Detail:** The transition from `Stopped` to `Removed` is irreversible and must clean up **all** resources (cgroups, network interfaces, mount points). Resource leaks occur if any resource isn't properly released during this transition.\n\n#### Layer Composition and Sharing\n\nImages use a **layered composition** model where each layer builds upon previous ones. Containers then add a writable layer on top of the image stack:\n\n```\nContainer Writable Layer (upperdir)\n    ↑\nImage Layer N (topmost read-only layer)\n    ↑\nImage Layer N-1\n    ↑\n...\n    ↑\nImage Layer 1 (base layer)\n    ↑\nBase Filesystem (scratch)\n```\n\n**Sharing implications:**\n- Identical layers across images are stored once and referenced multiple times (content-addressable storage)\n- When a container modifies a file from a read-only layer, OverlayFS performs **copy-on-write** to the writable layer\n- Deleting an image only removes its unique layers; shared layers remain until all referencing images are deleted\n- The runtime must track layer reference counts to implement garbage collection\n\nThis relationship is captured through the `Image.Layers` field (ordered list) and the filesystem manager's layer stacking logic.\n\n#### Network Configuration Inheritance\n\nNetwork settings follow a **hierarchical override** pattern where container-specific settings override network defaults:\n\n```\nNetwork Defaults (bridge: byob0, subnet: 172.17.0.0/16)\n    ↑ can be overridden by\nContainer NetworkConfig\n    ↑ can be overridden by\nRuntime State (actual assigned IP, port mappings in iptables)\n```\n\nFor example, if the container doesn't specify an `IPAddress`, the network manager assigns one from the bridge's DHCP range. If no `BridgeName` is specified, the default bridge is used. This inheritance chain ensures sensible defaults while allowing customization.\n\n#### Data Persistence Relationships\n\nDifferent parts of the data model have different persistence requirements:\n\n| Entity | Storage Location | Format | Lifetime |\n|--------|-----------------|--------|----------|\n| `Container` metadata | `/var/lib/byob/containers/{id}/config.json` | JSON | Until explicit removal |\n| `Container` runtime state | In-memory + above JSON | Go struct + JSON | Runtime + persisted |\n| `Image` metadata | `/var/lib/byob/images/{digest}/manifest.json` | JSON | Until all referencing containers removed and image deleted |\n| `ImageLayer` contents | `/var/lib/byob/layers/{digest}/` | Extracted files | Until all referencing images removed |\n| Network allocation state | `/var/lib/byob/network/allocations.json` | JSON | Until host reboot or network cleanup |\n\nThese persistence relationships ensure the runtime can:\n1. Recover container state after a restart (critical for managing long-running containers)\n2. Share images across multiple containers efficiently\n3. Avoid IP address conflicts by tracking allocations\n4. Implement garbage collection for unused layers\n\n#### Component Ownership Relationships\n\nEach component in the high-level architecture owns specific parts of the data model:\n\n| Component | Owned Data | Responsibility |\n|-----------|------------|----------------|\n| Container Manager | `Container` objects, state transitions | Lifecycle management, persistence |\n| Image Handler | `Image` objects, layer storage | Image download, extraction, caching |\n| Filesystem Manager | Layer directories, mount points | OverlayFS stacking, rootfs preparation |\n| Network Manager | IP allocations, veth interfaces | Network namespace setup, connectivity |\n| cgroup Manager | cgroup directories, process memberships | Resource limit enforcement |\n\nThis ownership model prevents data races and ensures each component has authority over its domain. For example, only the cgroup Manager should write to cgroup control files, while only the Network Manager should modify iptables rules.\n\n![Data Model Type Relationships](./diagrams/data-model-types.svg)\n\n### Implementation Guidance\n\nThis section provides concrete implementation starting points for the data model structures and their persistence.\n\n**Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Data serialization | JSON (`encoding/json`) | Protocol Buffers (`google.golang.org/protobuf`) |\n| Unique ID generation | Random hex (`crypto/rand`) | ULID or UUID v4 |\n| Time handling | `time.Time` with `time.RFC3339` | Monotonic timestamps for ordering |\n| File storage | Direct filesystem I/O | Embedded database (BoltDB, SQLite) |\n\n**Recommended File/Module Structure:**\n\n```\nproject-root/\n  cmd/byob/                       # CLI entry point\n    main.go\n  internal/\n    runtime/                      # Container Manager component\n      container.go                # Container struct and methods\n      manager.go                  # Runtime interface implementation\n      state.go                    # State machine logic\n    image/                        # Image Handler component  \n      image.go                    # Image struct and methods\n      store.go                    # Image storage and retrieval\n    config/                       # Configuration structures\n      types.go                    # All data model structs (ContainerConfig, etc.)\n    storage/                      # Persistence layer\n      persistence.go              # JSON serialization/deserialization\n      paths.go                    # Filesystem path management\n  pkg/\n    uuid/                         # ID generation utilities\n      uuid.go\n```\n\n**Infrastructure Starter Code (Complete):**\n\nHere's a complete, ready-to-use implementation for the core data structures and their JSON persistence:\n\n```go\n// internal/config/types.go\npackage config\n\nimport (\n    \"encoding/json\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n)\n\ntype ContainerState string\n\nconst (\n    StateCreated ContainerState = \"created\"\n    StateRunning ContainerState = \"running\"\n    StatePaused  ContainerState = \"paused\"\n    StateStopped ContainerState = \"stopped\"\n    StateRemoved ContainerState = \"removed\"\n)\n\ntype ContainerConfig struct {\n    Image      string         `json:\"image\"`\n    Cmd        []string       `json:\"cmd,omitempty\"`\n    Env        []string       `json:\"env,omitempty\"`\n    WorkingDir string         `json:\"working_dir,omitempty\"`\n    Hostname   string         `json:\"hostname,omitempty\"`\n    Limits     ResourceLimits `json:\"limits\"`\n    Network    NetworkConfig  `json:\"network\"`\n}\n\ntype ResourceLimits struct {\n    MemoryMB  int `json:\"memory_mb\"`\n    CPUShares int `json:\"cpu_shares\"`\n    PidsLimit int `json:\"pids_limit\"`\n}\n\ntype NetworkConfig struct {\n    Mode         string        `json:\"mode\"`\n    BridgeName   string        `json:\"bridge_name,omitempty\"`\n    IPAddress    string        `json:\"ip_address,omitempty\"`\n    PortMappings []PortMapping `json:\"port_mappings,omitempty\"`\n}\n\ntype PortMapping struct {\n    HostPort      int    `json:\"host_port\"`\n    ContainerPort int    `json:\"container_port\"`\n    Protocol      string `json:\"protocol\"` // \"tcp\" or \"udp\"\n}\n\ntype Container struct {\n    ID        string          `json:\"id\"`\n    Name      string          `json:\"name\"`\n    State     ContainerState  `json:\"state\"`\n    Config    ContainerConfig `json:\"config\"`\n    Pid       int             `json:\"pid,omitempty\"` // 0 if not running\n    CreatedAt time.Time       `json:\"created_at\"`\n}\n\ntype Image struct {\n    Name   string       `json:\"name\"`\n    Digest string       `json:\"digest\"`\n    Layers []ImageLayer `json:\"layers\"`\n    Config ImageConfig  `json:\"config\"`\n}\n\ntype ImageLayer struct {\n    Digest string `json:\"digest\"`\n    Size   int64  `json:\"size\"`\n    Path   string `json:\"path\"` // Filesystem path to extracted layer\n}\n\ntype ImageConfig struct {\n    Entrypoint []string `json:\"entrypoint,omitempty\"`\n    Cmd        []string `json:\"cmd,omitempty\"`\n    Env        []string `json:\"env,omitempty\"`\n    WorkingDir string   `json:\"working_dir,omitempty\"`\n}\n\n// internal/storage/persistence.go\npackage storage\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \n    \"github.com/yourusername/byob/internal/config\"\n)\n\ntype ContainerStore struct {\n    basePath string\n}\n\nfunc NewContainerStore(basePath string) *ContainerStore {\n    return &ContainerStore{basePath: basePath}\n}\n\nfunc (s *ContainerStore) Save(container *config.Container) error {\n    containerPath := filepath.Join(s.basePath, container.ID)\n    if err := os.MkdirAll(containerPath, 0755); err != nil {\n        return fmt.Errorf(\"create container directory: %w\", err)\n    }\n    \n    configPath := filepath.Join(containerPath, \"config.json\")\n    data, err := json.MarshalIndent(container, \"\", \"  \")\n    if err != nil {\n        return fmt.Errorf(\"marshal container config: %w\", err)\n    }\n    \n    if err := os.WriteFile(configPath, data, 0644); err != nil {\n        return fmt.Errorf(\"write container config: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (s *ContainerStore) Load(id string) (*config.Container, error) {\n    configPath := filepath.Join(s.basePath, id, \"config.json\")\n    data, err := os.ReadFile(configPath)\n    if err != nil {\n        return nil, fmt.Errorf(\"read container config: %w\", err)\n    }\n    \n    var container config.Container\n    if err := json.Unmarshal(data, &container); err != nil {\n        return nil, fmt.Errorf(\"unmarshal container config: %w\", err)\n    }\n    \n    return &container, nil\n}\n\nfunc (s *ContainerStore) Delete(id string) error {\n    containerPath := filepath.Join(s.basePath, id)\n    // Only delete if container is in \"removed\" state\n    configPath := filepath.Join(containerPath, \"config.json\")\n    data, err := os.ReadFile(configPath)\n    if err != nil && !os.IsNotExist(err) {\n        return fmt.Errorf(\"check container state: %w\", err)\n    }\n    \n    if err == nil {\n        var container config.Container\n        if err := json.Unmarshal(data, &container); err == nil {\n            if container.State != config.StateRemoved {\n                return fmt.Errorf(\"container %s is not in removed state\", id)\n            }\n        }\n    }\n    \n    return os.RemoveAll(containerPath)\n}\n\n// pkg/uuid/uuid.go\npackage uuid\n\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"fmt\"\n)\n\nfunc Generate() (string, error) {\n    bytes := make([]byte, 16)\n    if _, err := rand.Read(bytes); err != nil {\n        return \"\", fmt.Errorf(\"generate random bytes: %w\", err)\n    }\n    return hex.EncodeToString(bytes), nil\n}\n\nfunc Short() string {\n    bytes := make([]byte, 8)\n    if _, err := rand.Read(bytes); err != nil {\n        // Fallback to timestamp-based ID if crypto fails\n        return fmt.Sprintf(\"%x\", time.Now().UnixNano())\n    }\n    return hex.EncodeToString(bytes)\n}\n```\n\n**Core Logic Skeleton Code:**\n\n```go\n// internal/runtime/manager.go\npackage runtime\n\nimport (\n    \"fmt\"\n    \"time\"\n    \n    \"github.com/yourusername/byob/internal/config\"\n    \"github.com/yourusername/byob/pkg/uuid\"\n)\n\ntype ContainerRuntime struct {\n    store *storage.ContainerStore\n    // Other component managers will be added here\n}\n\nfunc NewContainerRuntime(storePath string) (*ContainerRuntime, error) {\n    store := storage.NewContainerStore(storePath)\n    // TODO 1: Create store directory if it doesn't exist\n    // TODO 2: Initialize other managers (network, cgroup, filesystem)\n    // TODO 3: Load existing containers and restore their state\n    return &ContainerRuntime{store: store}, nil\n}\n\nfunc (r *ContainerRuntime) CreateContainer(containerConfig config.ContainerConfig, name string) (*config.Container, error) {\n    // TODO 1: Validate containerConfig (check image exists, valid resource limits)\n    // TODO 2: Generate unique container ID using uuid.Generate()\n    // TODO 3: Merge image config with container config (image defaults → container overrides)\n    // TODO 4: Create Container struct with State = StateCreated\n    // TODO 5: Set CreatedAt to current time\n    // TODO 6: Save container to persistence store\n    // TODO 7: Prepare root filesystem (but don't start process yet)\n    // TODO 8: Return the created container object\n    return nil, fmt.Errorf(\"not implemented\")\n}\n\nfunc (r *ContainerRuntime) StartContainer(id string) error {\n    // TODO 1: Load container from store\n    // TODO 2: Validate container is in StateCreated state\n    // TODO 3: Create namespaces using namespace manager\n    // TODO 4: Setup cgroups with limits from container.Config.Limits\n    // TODO 5: Configure network using network manager\n    // TODO 6: Fork/exec the container process inside the namespaces\n    // TODO 7: Update container State = StateRunning, set Pid to child PID\n    // TODO 8: Save updated container to store\n    // TODO 9: Monitor container process for exit (in goroutine)\n    return fmt.Errorf(\"not implemented\")\n}\n\nfunc (r *ContainerRuntime) StopContainer(id string, force bool) error {\n    // TODO 1: Load container from store\n    // TODO 2: Validate container is in StateRunning or StatePaused state\n    // TODO 3: Send SIGTERM (or SIGKILL if force) to container.Pid\n    // TODO 4: Wait for process to exit with timeout\n    // TODO 5: Clean up resources (cgroups, network, etc.)\n    // TODO 6: Update container State = StateStopped, clear Pid field\n    // TODO 7: Save updated container to store\n    return fmt.Errorf(\"not implemented\")\n}\n\nfunc (r *ContainerRuntime) RemoveContainer(id string) error {\n    // TODO 1: Load container from store\n    // TODO 2: Validate container is in StateStopped or StateCreated state\n    // TODO 3: If StateCreated, clean up prepared resources\n    // TODO 4: Delete container root filesystem\n    // TODO 5: Update container State = StateRemoved\n    // TODO 6: Save updated container to store\n    // TODO 7: Delete container directory from store (optional cleanup)\n    return fmt.Errorf(\"not implemented\")\n}\n```\n\n**Language-Specific Hints:**\n\n1. **JSON serialization:** Use `json.MarshalIndent(container, \"\", \"  \")` for human-readable config files. The `omitempty` tag prevents zero values from cluttering the JSON.\n\n2. **Time handling:** Always use `time.Now().UTC()` for timestamps to ensure consistency across timezones. Store as RFC3339 format in JSON.\n\n3. **Error wrapping:** Use `fmt.Errorf(\"operation: %w\", err)` pattern throughout to create actionable error messages with context.\n\n4. **File permissions:** Use `0755` for directories, `0644` for config files, and `0700` for sensitive data.\n\n5. **Path construction:** Always use `filepath.Join()` instead of string concatenation for cross-platform compatibility.\n\n**Milestone Checkpoint (Data Model):**\n\nAfter implementing the data model structures and persistence layer, verify functionality with:\n\n```bash\n# Create and run a simple test\ncd project-root\ngo test ./internal/config/... ./internal/storage/... -v\n\n# Expected output should show:\n# PASS: TestContainerSaveLoad\n# PASS: TestImageSerialization\n# PASS: TestStateTransitions\n\n# Manual verification:\nmkdir -p /tmp/byob-test\ngo run cmd/byob/main.go create --name test-container alpine:latest echo \"hello\"\n# Check that /tmp/byob-test/containers/ contains a directory with config.json\n# The config.json should have all fields properly serialized\n```\n\n**Debugging Tips for Data Model Issues:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Container config fails to save | Permission denied on store directory | Check `os.MkdirAll` error return | Ensure runtime has write permissions to store path |\n| JSON unmarshal fails | Type mismatch or extra fields | Print raw JSON before unmarshaling | Ensure struct tags match JSON fields exactly |\n| Container ID collisions | Poor random number generation | Test `uuid.Generate()` in a loop | Use crypto/rand with proper error handling |\n| State transitions violating rules | Missing validation logic | Add state transition matrix check | Implement `canTransition(from, to State) bool` helper |\n| Resource leaks on removal | Missing cleanup in RemoveContainer | Add logging for each resource cleanup step | Ensure all managers have cleanup methods called |\n\n---\n\n\n> **Milestone(s):** Milestone 1: Process Isolation (Namespaces)\n\n## Component Design: Process Isolation (Milestone 1)\n\nProcess isolation is the foundational component of our container runtime. It leverages Linux namespaces to create separate, isolated environments for containerized processes, providing the illusion that each container is running on its own system. This section details the design of the namespace isolation component.\n\n### Mental Model: Private Rooms with Mirrored Walls\n\nImagine a large, open-plan office (the host operating system). To create private work areas, we build enclosed rooms (containers) with special \"mirrored walls\" (namespaces). Each room has:\n\n1.  **Private Bulletin Board (PID Namespace):** A list of everyone in the room (processes). People inside only see their own list. The person who enters first is designated as the \"Manager\" (PID 1).\n2.  **Private Nameplate (UTS Namespace):** The room has its own name and company sign (hostname and NIS domain name), independent of the building's main signage.\n3.  **Private Furniture & Layout (Mount Namespace):** The room can have its own furniture arrangement (filesystem mount points). Adding or removing a desk (mounting/unmounting) in this room doesn't affect the open-plan office or other rooms.\n4.  **Private Phone System (Network Namespace):** The room has its own phone lines, internal extensions, and switchboard. Calls within the room are private, and external calls must go through the building's main reception (host network).\n5.  **Private Meeting Room (IPC Namespace):** The room has its own whiteboards and message boards (System V IPC objects, POSIX message queues) that only its occupants can use.\n\nThese \"mirrored walls\" create a powerful illusion: from inside the room, it appears you are in your own, self-contained building. The namespace component is responsible for constructing these private rooms for each container.\n\n### Architecture Decision Records for Namespace Strategy\n\n> **Decision: Use the `clone()` Syscall with Combined Flags for Initial Process Isolation**\n>\n> - **Context:** We need to launch the container's initial process (the `init` process) in a set of isolated namespaces. The two primary Linux APIs for namespace creation are `clone()` (creates a new process in new namespaces) and `unshare()` (moves the calling process into new namespaces). We must choose the primary method for the initial container launch.\n> - **Options Considered:**\n>     1.  **`clone()` with namespace flags:** Create the container process directly in new namespaces.\n>     2.  **`fork()` + `unshare()`:** Fork the current process, then have the child call `unshare()` to enter new namespaces before executing the container command.\n>     3.  **Combination (clone for most, user ns first):** Use `clone()` with `CLONE_NEWUSER` first, then use `setns()` to join other namespaces for enhanced security.\n> - **Decision:** Use `clone()` with a combined set of namespace flags (e.g., `CLONE_NEWPID | CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWNET`) to create the container's first process. This is a single, atomic operation.\n> - **Rationale:** The `clone()` approach is simpler, more atomic, and aligns with the standard pattern used by runc and other OCI runtimes. It cleanly creates a new process that is immediately isolated, without the intermediate state and potential race conditions of a `fork()`+`unshare()` sequence. It also provides a clear parent-child relationship between the runtime manager and the container `init` process.\n> - **Consequences:** This decision centralizes namespace creation logic at process launch. It requires the runtime process to have appropriate privileges (typically root) to create most namespaces. It also means the container `init` process will be the direct child of the runtime, simplifying state tracking and signal forwarding.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| `clone()` with flags | Atomic, simple, standard pattern. | Requires CAP_SYS_ADMIN for most namespaces (except user). | **Yes** |\n| `fork()` + `unshare()` | More flexibility in multi-stage setup. | Non-atomic, complex state management, potential for leaks. | No |\n| User ns first | Enhanced security via privilege dropping. | Significantly more complex, requires mapping UIDs/GIDs. | No (considered for future extension) |\n\n![Namespace Hierarchy](./diagrams/namespace-hierarchy.svg)\n\n> **Decision: Implement a `NamespaceManager` Component for Lifecycle Operations**\n>\n> - **Context:** Namespace creation, management, and cleanup are distinct operations that must be coordinated with the container's lifecycle. These operations also differ for the initial `init` process versus subsequent `exec` operations (like `docker exec`).\n> - **Options Considered:**\n>     1.  **Inline in `StartContainer`:** Place all namespace logic directly within the container start sequence.\n>     2.  **Dedicated `NamespaceManager`:** Create a component responsible for namespace operations, providing a clean API.\n> - **Decision:** Implement a dedicated `NamespaceManager` component. It will expose methods like `CreateNamespaces(flags int)` to launch processes in namespaces and `JoinNetworkNamespace(path string)` for attaching to existing namespaces.\n> - **Rationale:** A dedicated manager promotes separation of concerns, testability, and code reuse. It encapsulates the low-level syscall details and provides a clear interface for the `ContainerManager`. This pattern also aligns with our other managers (`CgroupManager`, `FilesystemManager`).\n> - **Consequences:** Introduces an additional component to the architecture but creates a cleaner, more modular design. The `ContainerManager` orchestrates the managers but does not need to know the specifics of `clone()` flags or `/proc/<pid>/ns` file handling.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| Inline Logic | Fewer components, direct control. | Blurs responsibilities, harder to test and reuse. | No |\n| Dedicated Manager | Separation of concerns, testable, reusable API. | Slight increase in architectural complexity. | **Yes** |\n\n### Common Pitfalls in Namespace Implementation\n\n⚠️ **Pitfall: Incorrect PID Namespace Setup Leading to Host PID Visibility**\n- **Description:** A process is placed in a new PID namespace (`CLONE_NEWPID`), but running `ps aux` or `ls /proc` inside the container still shows all host processes.\n- **Why it's Wrong:** The `/proc` filesystem is a view into the kernel's process information. A new PID namespace only controls the PID numbers; you must also have a separate mount namespace and (re-)mount `/proc` *inside* that namespace for `ps` to reflect the isolated PID view.\n- **Fix:** Ensure the container has its own mount namespace (`CLONE_NEWNS`) and mount a new `proc` filesystem on `/proc` after setting up the root filesystem. Do this before executing the final container command.\n\n⚠️ **Pitfall: Forgetting to Isolate the Mount Namespace (`CLONE_NEWNS`)**\n- **Description:** The container can mount or unmount filesystems, and these changes are visible and affect the host and other containers.\n- **Why it's Wrong:** Mount operations should be contained within the container. Without `CLONE_NEWNS`, the container shares the global mount table, breaking isolation and creating a security risk.\n- **Fix:** Always include `CLONE_NEWNS` in the set of flags passed to `clone()` or `unshare()`. Note: The flag's name is historical; it is the flag for creating a new mount namespace.\n\n⚠️ **Pitfall: `CLONE_NEWPID` and the Parent's View**\n- **Description:** A developer expects the parent process (the container runtime) to see the container's `init` process as PID 1. Instead, the parent still sees the child with a regular host PID.\n- **Why it's Wrong:** PID namespaces are hierarchical. A process's PID is relative to its namespace. The parent resides in the *initial* PID namespace, so it sees the child's PID in that namespace. The child, inside the new PID namespace, sees itself as PID 1.\n- **Fix:** This is not a bug but a key property to understand. The runtime must track the child's host PID for signaling and cgroup management. Use the PID returned by `clone()` (or `fork()`).\n\n⚠️ **Pitfall: Not Cleaning Up Orphaned Namespaces**\n- **Description:** When a container exits, its network namespace (or others) might persist if not explicitly cleaned up, leading to resource leaks (dangling veth interfaces, IP addresses).\n- **Why it's Wrong:** Linux maintains a namespace as long as at least one process remains inside or a reference (like an open file descriptor) exists. The runtime must ensure all references are closed.\n- **Fix:** The `NamespaceManager` or `ContainerManager` should be responsible for cleaning up. This includes terminating all processes in the namespace and closing any open file descriptors to `/proc/<pid>/ns/*` that were kept for later `setns()` operations.\n\n### Implementation Guidance for Namespace Isolation\n\nThis section bridges the design concepts to concrete Go code. We'll structure the namespace management logic within a dedicated component.\n\n**A. Technology Recommendations Table**\n| Component | Simple Option | Advanced Option |\n| :--- | :--- | :--- |\n| Namespace Creation | `syscall.SysProcAttr` in `cmd.SysProcAttr` for `clone()` | Raw `syscall.Clone()` with more granular control |\n| Namespace File Handling | `os.Open` on `/proc/self/ns/*` | `syscall.Open` with `O_CLOEXEC` for safer file descriptors |\n| Process Execution | `exec.Command` with `SysProcAttr` | Low-level `syscall.ForkExec` |\n\n**B. Recommended File/Module Structure**\nIntegrate the `NamespaceManager` into the project structure defined in the High-Level Architecture.\n```\nbuild-your-own-docker/\n├── cmd/\n│   └── byod/                         # CLI entry point\n├── internal/\n│   ├── container/                    # Container lifecycle and state management\n│   │   ├── manager.go                # ContainerManager (orchestrator)\n│   │   └── store.go                  # ContainerStore (persistence)\n│   ├── namespaces/                   # Namespace isolation component (NEW)\n│   │   ├── manager.go                # NamespaceManager\n│   │   └── util.go                   # Helpers for ns paths, flags\n│   ├── cgroups/                      # Resource limits (Milestone 2)\n│   ├── fs/                           # Filesystem isolation (Milestone 3,4)\n│   ├── network/                      # Networking (Milestone 5)\n│   └── image/                        # Image handling (Milestone 6)\n└── pkg/\n    └── uuid/                         # ID generation utilities\n```\n\n**C. Infrastructure Starter Code**\nThe following is a complete, reusable helper for executing a function in a new set of namespaces. It handles the `clone()` call and the transition into the child's context.\n\n```go\n// internal/namespaces/runner.go\npackage namespaces\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n    \"syscall\"\n)\n\n// ChildFunc is a function to be executed inside the new namespaces.\n// The return value will be passed back to the parent as the exit status.\ntype ChildFunc func() int\n\n// RunInNamespaces runs the provided childFunc in a new set of Linux namespaces.\n// The flags parameter is a bitmask of CLONE_NEW* flags (e.g., syscall.CLONE_NEWPID).\n// It returns the exit status of the child process as seen by the parent.\nfunc RunInNamespaces(flags int, childFunc ChildFunc) (int, error) {\n    // Create a pipe for the child to communicate its exit status.\n    // This avoids relying on the child's process exit status which can be\n    // ambiguous with signals.\n    r, w, err := os.Pipe()\n    if err != nil {\n        return -1, fmt.Errorf(\"create pipe: %w\", err)\n    }\n    defer r.Close()\n    defer w.Close()\n\n    cmd := &exec.Cmd{\n        Path: \"/proc/self/exe\", // Re-execute the current program\n        Args: []string{\"byod-child\"}, // Special argument for child mode\n        SysProcAttr: &syscall.SysProcAttr{\n            Cloneflags: syscall.Cloneflags(flags),\n        },\n        ExtraFiles: []*os.File{w}, // Pipe write end is passed to child\n        Stdin:      os.Stdin,\n        Stdout:     os.Stdout,\n        Stderr:     os.Stderr,\n    }\n\n    // Start the child process. It will execute the code path for \"byod-child\".\n    if err := cmd.Start(); err != nil {\n        return -1, fmt.Errorf(\"start child process: %w\", err)\n    }\n\n    // Parent: close our copy of the write end.\n    w.Close()\n\n    // Wait for the child to finish and read its exit code from the pipe.\n    var childStatus int\n    if _, err := fmt.Fscanf(r, \"%d\", &childStatus); err != nil {\n        // If the pipe read fails, fall back to cmd.Wait().\n        waitErr := cmd.Wait()\n        if waitErr != nil {\n            if exitErr, ok := waitErr.(*exec.ExitError); ok {\n                childStatus = exitErr.ExitCode()\n            } else {\n                childStatus = -1\n            }\n        }\n    }\n    // Ensure the child process is reaped.\n    cmd.Wait()\n    return childStatus, nil\n}\n\n// ChildEntryPoint is called from the main function when args[0] == \"byod-child\".\n// It reads the exit status from the child function and writes it to the pipe.\nfunc ChildEntryPoint(childFunc ChildFunc) {\n    // The pipe write end is file descriptor 3 (ExtraFiles[0]).\n    pipe := os.NewFile(3, \"pipe\")\n    if pipe == nil {\n        os.Exit(255)\n    }\n    defer pipe.Close()\n\n    status := childFunc()\n    fmt.Fprintf(pipe, \"%d\\n\", status)\n    os.Exit(status)\n}\n```\n\n**D. Core Logic Skeleton Code**\nThe main logic for the `NamespaceManager` involves creating namespaces and providing a way to launch processes within them.\n\n```go\n// internal/namespaces/manager.go\npackage namespaces\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"syscall\"\n)\n\n// Manager handles creation and management of Linux namespaces.\ntype Manager struct {\n    // We may store paths to namespace files for later joining (e.g., for exec).\n    // For simplicity, this initial version focuses on creation.\n}\n\n// NewManager creates a new NamespaceManager.\nfunc NewManager() *Manager {\n    return &Manager{}\n}\n\n// CreateNamespaces launches a process in new namespaces.\n// It configures the provided exec.Cmd to run inside the specified namespaces.\n// Returns the host PID of the created process.\nfunc (m *Manager) CreateNamespaces(cmd *exec.Cmd, flags int) (int, error) {\n    if cmd.SysProcAttr == nil {\n        cmd.SysProcAttr = &syscall.SysProcAttr{}\n    }\n    cmd.SysProcAttr.Cloneflags = syscall.Cloneflags(flags)\n\n    // TODO 1: Ensure the process will have a controlling terminal if needed.\n    // TODO 2: Set the Pdeathsig attribute to ensure child dies if parent dies (optional).\n    // TODO 3: Start the process using cmd.Start().\n    // TODO 4: Return the process's PID (cmd.Process.Pid).\n\n    return 0, fmt.Errorf(\"not implemented\")\n}\n\n// GetNamespacePath returns the path to a namespace file for a given process.\n// Example: GetNamespacePath(pid, \"pid\") returns \"/proc/pid/ns/pid\".\nfunc (m *Manager) GetNamespacePath(pid int, nsType string) (string, error) {\n    // TODO 1: Validate nsType against known types: pid, net, mnt, uts, ipc, user.\n    // TODO 2: Construct the path: fmt.Sprintf(\"/proc/%d/ns/%s\", pid, nsType).\n    // TODO 3: Check if the path exists (os.Stat).\n    // TODO 4: Return the path.\n\n    return \"\", fmt.Errorf(\"not implemented\")\n}\n\n// JoinNetworkNamespace configures an exec.Cmd to join an existing network namespace.\n// This is used for operations like `docker exec`.\nfunc (m *Manager) JoinNetworkNamespace(cmd *exec.Cmd, nsPath string) error {\n    // TODO 1: Open the namespace file at nsPath with syscall.Open.\n    // TODO 2: Ensure the file descriptor is closed on exec (FD_CLOEXEC).\n    // TODO 3: Set the cmd.SysProcAttr.Cloneflags to avoid creating new namespaces.\n    // TODO 4: Set the cmd.SysProcAttr.Setns to the opened file descriptor.\n    // TODO 5: Close the file descriptor after cmd.Start().\n\n    return fmt.Errorf(\"not implemented\")\n}\n```\n\n**E. Language-Specific Hints**\n- **Syscall Flags:** Use the constants from the `syscall` package: `syscall.CLONE_NEWPID`, `syscall.CLONE_NEWNS`, `syscall.CLONE_NEWUTS`, `syscall.CLONE_NEWIPC`, `syscall.CLONE_NEWNET`.\n- **Process Execution:** The standard `exec.Command` combined with `cmd.SysProcAttr` is sufficient for most namespace operations. For very advanced scenarios (like `clone()` with a custom stack), you would use `syscall.Clone()` directly.\n- **Namespace Files:** You can open `/proc/<pid>/ns/<type>` as a regular file. Holding an open file descriptor keeps the namespace alive, which is useful for keeping a network namespace alive after the `init` process dies.\n\n**F. Milestone Checkpoint**\nAfter implementing the namespace isolation component, you should be able to run a simple test program inside an isolated environment.\n\n1.  **Expected Output:** Create a test program that prints its PID, hostname, and list of mount points.\n2.  **Test Command:** Run it using your `RunInNamespaces` helper with flags for PID, UTS, and Mount namespaces.\n3.  **Verification:**\n    *   The program should report its PID as 1.\n    *   It should be able to change its hostname without affecting the host.\n    *   Running `mount -t proc proc /proc` and then `ls /proc` should only show PIDs 1 and maybe a few kernel threads.\n4.  **Signs of Trouble:**\n    *   **PID is not 1:** Ensure you included `syscall.CLONE_NEWPID`.\n    *   **Host hostname changes:** You forgot `syscall.CLONE_NEWUTS`.\n    *   **Cannot mount /proc:** You likely need `syscall.CLONE_NEWNS` (mount namespace). Also, the process needs `CAP_SYS_ADMIN` capability (run as root).\n\n**G. Debugging Tips**\n| Symptom | Likely Cause | How to Diagnose | Fix |\n| :--- | :--- | :--- | :--- |\n| Child process exits immediately with no output. | The child function is not being executed, or the `exec.Command` arguments are wrong. | Add debug prints before and inside the child function. Check `cmd.Path` and `cmd.Args`. | Ensure `ChildEntryPoint` is called correctly in your main function when the special argument is present. |\n| `ps aux` inside container shows all host processes. | `/proc` is not remounted inside the new PID namespace. | Check if you have `CLONE_NEWNS` and are mounting proc after `chroot`/`pivot_root`. | Mount a new procfs: `syscall.Mount(\"proc\", \"/proc\", \"proc\", 0, \"\")` inside the container's mount namespace. |\n| Container can still see host network interfaces. | `CLONE_NEWNET` flag was not included. | Check the flags passed to `RunInNamespaces` or `CreateNamespaces`. | Add `syscall.CLONE_NEWNET` to the flag set. |\n| Getting \"operation not permitted\" errors. | Insufficient privileges (not running as root). | Run your runtime with `sudo`. | Ensure the binary is executed as root (or has the necessary capabilities via `setcap`). |\n\n---\n\n\n> **Milestone(s):** Milestone 2: Resource Limits (cgroups)\n\n## Component Design: Resource Limits via cgroups (Milestone 2)\n\nThis component is responsible for enforcing resource constraints on containerized processes using Linux **cgroups** (control groups). While namespaces provide isolation boundaries, cgroups provide the resource accounting and limiting mechanisms that prevent any single container from monopolizing system resources like CPU, memory, or process slots. This component translates the abstract `ResourceLimits` configuration into concrete kernel-level resource controls.\n\n### Mental Model: Resource Quotas in an Apartment Building\n\nImagine an apartment building where each tenant (container) has access to shared building resources. Without controls, one tenant could:\n1. Use all the building's water pressure (CPU)\n2. Generate so much garbage that the dumpsters overflow (memory)\n3. Invite hundreds of guests who block the hallways (processes)\n\nThe building manager (cgroup manager) solves this by installing:\n- **Individual water meters with flow restrictors** (CPU limits): Each apartment gets a maximum flow rate\n- **Designated garbage bin capacity** (memory limits): Each apartment gets a specific bin size; overflowing bins get removed (OOM-killed)\n- **Guest limit per apartment** (PIDs limit): Each apartment can only register a set number of residents\n\nThese quotas apply collectively to everyone in the apartment, not per person. If you have five roommates sharing an apartment, they collectively share the apartment's quotas. Similarly, all processes within a container (including child processes and their descendants) share the container's cgroup resource limits.\n\nThe key insight is that cgroups don't just monitor resource usage—they actively enforce hard limits through kernel mechanisms that throttle, deny, or terminate processes that exceed their allocations. This enforcement happens at the kernel level, making it both efficient and unavoidable for processes within the cgroup.\n\n### Architecture Decision Records for cgroup Version\n\n#### Decision: cgroup v2 as Primary Target with v1 Fallback\n\n**Context**: Linux has two major cgroup implementations: the original cgroup v1 (with multiple, sometimes inconsistent controllers) and the unified hierarchy of cgroup v2. Modern distributions (Ubuntu 22.04+, Fedora 31+, RHEL 8+) default to cgroup v2, but many production systems still run cgroup v1. Our container runtime must work reliably across both versions.\n\n**Options Considered**:\n\n1. **Exclusive cgroup v2 support**: Assume modern Linux and only implement v2 interfaces\n2. **Exclusive cgroup v1 support**: Target older systems but miss modern features like memory pressure notifications\n3. **Dual-stack with automatic detection**: Detect available cgroup version and use appropriate implementation\n4. **User-configurable with automatic fallback**: Allow explicit configuration but fall back based on system detection\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Exclusive cgroup v2 | Cleaner API, unified hierarchy, better memory management | Doesn't work on older systems (~30% of production) | No |\n| Exclusive cgroup v1 | Maximum compatibility with existing systems | Misses v2 improvements, inconsistent controller mounting | No |\n| Dual-stack auto-detection | Works everywhere, uses best available version | More complex implementation, testing burden | **Yes** |\n| Configurable with fallback | User control when needed, still works automatically | Complexity of config parsing and validation | No |\n\n**Decision**: Implement dual-stack cgroup management with automatic version detection. The runtime will check `/sys/fs/cgroup/cgroup.controllers` to determine if cgroup v2 is mounted; if present, use v2 interfaces; otherwise, fall back to cgroup v1 with separate controller hierarchies.\n\n**Rationale**:\n1. **User experience**: Most users won't know or care about cgroup versions; they expect containers to \"just work\"\n2. **Forward compatibility**: As systems upgrade to cgroup v2, our runtime automatically uses the better API\n3. **Maintainability**: We can implement a common interface with version-specific backends, keeping logic clean\n4. **Production readiness**: Many container orchestration systems (Kubernetes, Docker) already use this approach\n\n**Consequences**:\n- We must implement and test two code paths\n- Resource limit configuration may need translation between versions (e.g., CPU shares vs CPU weight)\n- Some advanced features (like cgroup v2's memory pressure stall information) may only be available in v2 mode\n- The implementation must handle mixed systems where some controllers are v1 and others v2 (hybrid mode)\n\n#### Decision: Hierarchical cgroup Organization by Container ID\n\n**Context**: cgroups can be organized in hierarchies. We need to decide how to structure our cgroups relative to each other and to system cgroups.\n\n**Options Considered**:\n\n1. **Flat organization**: All containers at the same level under a runtime parent\n2. **Hierarchical by container ID**: Each container gets its own nested cgroup\n3. **Pool-based organization**: Group containers by resource class (high-memory, low-CPU, etc.)\n4. **Integration with systemd**: Delegate cgroup management to systemd via `systemd-run`\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Flat organization | Simple to implement, easy to enumerate | No hierarchy for resource delegation, messy cleanup | No |\n| Hierarchical by container ID | Clean isolation, natural cleanup path, supports delegation | Slightly more complex to create nested groups | **Yes** |\n| Pool-based | Could optimize resource allocation | Complex to manage, requires scheduling logic | No |\n| systemd integration | Leverages system's cgroup manager, consistent with OS | Adds systemd dependency, harder to debug | No |\n\n**Decision**: Create hierarchical cgroups using the container ID as the cgroup name, nested under a runtime-managed parent cgroup (e.g., `/sys/fs/cgroup/container_runtime/{container_id}` for v2 or per-controller paths for v1).\n\n**Rationale**:\n1. **Clean resource accounting**: Each container's resource usage is clearly isolated and measurable\n2. **Simplified cleanup**: Removing the container cgroup recursively removes all resource tracking\n3. **Delegation support**: Future extensions could delegate sub-cgroups to containers (for nested containers)\n4. **Consistency with Docker**: Docker uses similar hierarchical organization, aiding user familiarity\n\n**Consequences**:\n- Must ensure proper cleanup on container exit to avoid \"cgroup leakage\"\n- Need to handle cgroup filesystem permissions (typically require root)\n- Nested cgroups add path complexity that must be managed in both v1 and v2\n\n### Component Responsibilities and Interfaces\n\nThe cgroup management component has three primary responsibilities:\n\n1. **cgroup Creation and Configuration**: Establish cgroup hierarchies and apply resource limits before process execution\n2. **Process Attachment**: Move processes (and their future descendants) into the appropriate cgroups\n3. **Cleanup and Resource Reclamation**: Remove cgroups when containers are destroyed\n\n#### Data Structures\n\n| Type | Fields | Description |\n|------|--------|-------------|\n| `CgroupManager` | `version int`, `basePath string`, `controllers map[string]bool` | Manages cgroup operations, detects version, tracks available controllers |\n| `ResourceLimits` | `MemoryMB int`, `CPUShares int`, `PidsLimit int` | User-specified resource constraints (from `ContainerConfig`) |\n| `CgroupStats` | `MemoryUsage int64`, `CPUUsage int64`, `PidCount int` | Runtime statistics collected from cgroup interface files |\n\n#### Interface Methods\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `NewCgroupManager()` | none | `(*CgroupManager, error)` | Factory function that detects cgroup version and available controllers |\n| `CreateCgroup(containerID string)` | `containerID string` | `error` | Creates cgroup hierarchy for the container |\n| `ApplyLimits(containerID string, limits ResourceLimits)` | `containerID string`, `limits ResourceLimits` | `error` | Writes resource limits to cgroup control files |\n| `AddProcess(containerID string, pid int)` | `containerID string`, `pid int` | `error` | Moves a process (and its future children) into the container's cgroup |\n| `RemoveCgroup(containerID string)` | `containerID string` | `error` | Recursively removes the container's cgroup and all sub-cgroups |\n| `GetStats(containerID string)` | `containerID string` | `(*CgroupStats, error)` | Reads current resource usage statistics from cgroup interface |\n\n### Common Pitfalls in cgroup Implementation\n\n#### ⚠️ **Pitfall: Forgetting to Add the Process to the cgroup**\n\n**Description**: Creating cgroups and setting limits but never actually moving the container process into them.\n\n**Why it's wrong**: cgroup limits only apply to processes within the cgroup. If the container process remains in the root cgroup (or a different cgroup), it won't be subject to the limits you configured.\n\n**How to fix**: Always call `AddProcess` with the container's PID **after** `fork` but **before** `exec` in the child process. Better yet, use the cgroup's `cgroup.procs` file (v2) or `tasks` file (v1) which automatically includes all child processes.\n\n#### ⚠️ **Pitfall: Not Handling cgroup v1 Controller Mounts**\n\n**Description**: Assuming all cgroup controllers are mounted in standard locations in cgroup v1.\n\n**Why it's wrong**: In cgroup v1, each controller (cpu, memory, pids) can be mounted separately, and systems may have different mount points or hierarchies. Some controllers might not be mounted at all.\n\n**How to fix**: Parse `/proc/mounts` to find controller mount points, check `/proc/cgroups` for available controllers, and provide clear error messages if required controllers are missing.\n\n#### ⚠️ **Pitfall: Memory Limits Don't Account for Kernel Memory**\n\n**Description**: Setting only `memory.limit_in_bytes` without considering `memory.kmem.limit_in_bytes` in cgroup v1.\n\n**Why it's wrong**: Containers can use kernel memory (page cache, sockets, etc.) that isn't counted against the normal memory limit. A container could exceed total memory through kernel allocations and not be OOM-killed.\n\n**How to fix**: In cgroup v1, also set `memory.kmem.limit_in_bytes` (typically to the same value as `memory.limit_in_bytes`). In cgroup v2, the unified `memory.max` includes both user and kernel memory.\n\n#### ⚠️ **Pitfall: Not Cleaning Up cgroups on Container Exit**\n\n**Description**: Leaving cgroup directories after container termination.\n\n**Why it's wrong**: Accumulating empty cgroups wastes inodes, complicates monitoring, and may hit filesystem limits. It also leaks information about past containers.\n\n**How to fix**: Implement `RemoveCgroup` and call it during container removal. Use `SetFinalizer` or defer statements to ensure cleanup even on unexpected exits. Consider using cgroup notification to detect when all processes in a cgroup have exited.\n\n#### ⚠️ **Pitfall: Misunderstanding CPU Shares vs Quota/Period**\n\n**Description**: Confusing the relative `cpu.shares` with the absolute `cpu.cfs_quota_us`/`cpu.cfs_period_us`.\n\n**Why it's wrong**: CPU shares only matter when there's contention; a container with 1024 shares gets twice as much CPU as one with 512 shares **only when the CPU is saturated**. Quota/period provides absolute limits (e.g., 0.5 CPU cores maximum).\n\n**How to fix**: Understand your use case: use shares for fair sharing among containers, use quota for hard limits. Document this clearly for users configuring `ResourceLimits`.\n\n### Implementation Algorithm\n\nThe cgroup setup follows this sequence during container creation:\n\n1. **Version Detection** (once at runtime initialization):\n   1. Check if `/sys/fs/cgroup/cgroup.controllers` exists\n   2. If yes, parse it to determine available controllers (cgroup v2)\n   3. If no, check `/proc/cgroups` and `/proc/mounts` for cgroup v1 controllers\n\n2. **cgroup Creation** (per container):\n   1. Generate cgroup path: `/sys/fs/cgroup/container_runtime/{container_id}` (v2) or per-controller paths (v1)\n   2. Create directory with appropriate permissions (typically 0755)\n   3. For cgroup v1, repeat for each required controller (cpu, memory, pids)\n\n3. **Limit Application**:\n   1. Convert `ResourceLimits` to cgroup-specific values:\n      - Memory: MB → bytes (multiply by 1,048,576)\n      - CPU shares: Keep as is (1024 = default weight)\n      - PIDs limit: Set directly\n   2. Write to appropriate control files:\n      - cgroup v2: `memory.max`, `cpu.weight`, `pids.max`\n      - cgroup v1: `memory.limit_in_bytes`, `memory.kmem.limit_in_bytes`, `cpu.shares`, `pids.max`\n   3. Verify writes by reading back and comparing\n\n4. **Process Attachment**:\n   1. After `fork` but before `exec` in the child, get the child's PID\n   2. Write PID to `cgroup.procs` (v2) or each controller's `tasks` file (v1)\n   3. Verify the process appears in the cgroup by reading the file back\n\n5. **Cleanup** (on container removal):\n   1. Kill all processes in the cgroup (if not already dead)\n   2. Remove all subdirectories recursively\n   3. Remove the container's cgroup directory\n   4. Verify removal by checking directory existence\n\n> **Design Insight**: The critical timing requirement is that processes must be added to cgroups **before they start executing user code**. If you add them after `exec`, there's a race window where the process could allocate memory or fork child processes outside the limits. Always use the pattern: `fork` → `add to cgroup` → `apply namespaces` → `exec`.\n\n### Integration with Container Creation Sequence\n\nReferencing the ![Container Creation Sequence Diagram](./diagrams/container-creation-sequence.svg), cgroup operations occur between namespace creation and filesystem setup:\n\n1. CLI receives `run` command with `--memory`, `--cpus` flags\n2. Container Manager creates `ContainerConfig` with `ResourceLimits`\n3. Namespace Manager creates new namespaces via `clone()` or `unshare()`\n4. **Cgroup Manager creates cgroup and applies limits**\n5. **Cgroup Manager adds the forked child process to the cgroup**\n6. Filesystem Manager sets up rootfs with `pivot_root()`\n7. Network Manager configures veth pair and network namespace\n8. Container process executes entrypoint within all constraints\n\nThis ordering ensures that:\n- Resource limits are active before the process starts meaningful work\n- The process inherits the cgroup membership, so all its children are automatically in the same cgroup\n- If cgroup setup fails, we can abort before setting up more complex resources like network\n\n### Error Handling and Recovery\n\n| Failure Mode | Detection | Recovery |\n|--------------|-----------|----------|\n| cgroup filesystem not mounted | `open()` on cgroup path returns `ENOENT` or `EACCES` | Check `/proc/mounts`, suggest mounting cgroups, or fall back to no resource limits (with warning) |\n| Insufficient permissions | `open()` or `write()` returns `EACCES` | Require root/sudo, or suggest configuring cgroup delegation |\n| Invalid limit value | `write()` succeeds but kernel rejects value (may be silent) | Read back after write to verify, validate limits against system capacity first |\n| Controller not available | Controller file doesn't exist in cgroup directory | Skip that controller, warn user, continue without that limit |\n| Process already in cgroup | `write()` to `cgroup.procs` returns `EBUSY` (v2) | Check if PID is already in correct cgroup, continue if so |\n| cgroup cleanup fails | `rmdir()` returns `EBUSY` (processes still exist) | Attempt to kill remaining processes, retry removal |\n\n### Example Walkthrough: Memory Limit Enforcement\n\nConsider a container configured with `MemoryMB: 100` (100MB memory limit):\n\n1. **Configuration**: `ResourceLimits{MemoryMB: 100, CPUShares: 512, PidsLimit: 100}` is created\n2. **Translation**: CgroupManager converts 100MB to 104,857,600 bytes\n3. **Writing**: For cgroup v2, writes \"104857600\" to `/sys/fs/cgroup/container_runtime/abc123/memory.max`\n4. **Enforcement**: Kernel tracks container's resident memory usage via RSS (Resident Set Size)\n5. **Exceedance**: If container allocates 101MB, kernel invokes OOM killer on processes in the cgroup\n6. **Notification**: CgroupManager could watch `memory.events` file for \"oom_kill\" events\n7. **Cleanup**: When container exits, cgroup directory is removed\n\n> **Key Insight**: Memory limits in cgroups use RSS, which measures physical memory pages. This differs from virtual memory size (which can be much larger due to memory-mapped files, shared libraries, and swap). A container with 100MB limit might have 200MB of virtual memory but only 80MB of RSS.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| cgroup Detection | Parse `/proc/mounts` manually | Use `github.com/containerd/cgroups` library |\n| File Operations | Standard `os.Open`, `os.WriteFile` | Memory-mapped files for frequent stats polling |\n| Process Tracking | Periodic scanning of `cgroup.procs` | Inotify on cgroup directory for real-time updates |\n| Statistics Collection | Read interface files on demand | Background goroutine with caching for dashboard |\n\n#### B. Recommended File/Module Structure\n\n```\nproject-root/\n  cmd/\n    runtime/           # CLI entry point\n      main.go\n  internal/\n    cgroup/            # cgroup management component\n      manager.go       # Main CgroupManager implementation\n      detector.go      # cgroup version and controller detection\n      v1/              # cgroup v1 specific implementation\n        controller.go  # Per-controller operations\n      v2/              # cgroup v2 specific implementation  \n        unified.go     # Unified hierarchy operations\n      common.go        # Shared utilities and types\n      manager_test.go  # Unit tests\n    container/         # Container lifecycle management\n      manager.go\n    namespace/         # Namespace isolation\n      manager.go\n    # ... other components\n```\n\n#### C. Infrastructure Starter Code\n\nHere's a complete, ready-to-use cgroup detector that handles both v1 and v2:\n\n```go\n// internal/cgroup/detector.go\npackage cgroup\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// CgroupVersion represents detected cgroup version\ntype CgroupVersion int\n\nconst (\n\tCgroupV1 CgroupVersion = 1\n\tCgroupV2 CgroupVersion = 2\n\tCgroupUnknown CgroupVersion = 0\n)\n\n// ControllerInfo holds detected controller availability\ntype ControllerInfo struct {\n\tVersion     CgroupVersion\n\tControllers map[string]bool  // Available controllers\n\tMountPoints map[string]string // Controller -> mount path (v1 only)\n}\n\n// DetectCgroupInfo detects cgroup version and available controllers\nfunc DetectCgroupInfo() (*ControllerInfo, error) {\n\tinfo := &ControllerInfo{\n\t\tControllers: make(map[string]bool),\n\t\tMountPoints: make(map[string]string),\n\t}\n\t\n\t// Check for cgroup v2 unified hierarchy\n\tcgroupV2Path := \"/sys/fs/cgroup\"\n\tif controllers, err := ioutil.ReadFile(filepath.Join(cgroupV2Path, \"cgroup.controllers\")); err == nil {\n\t\tinfo.Version = CgroupV2\n\t\tfor _, controller := range strings.Fields(string(controllers)) {\n\t\t\tinfo.Controllers[controller] = true\n\t\t}\n\t\treturn info, nil\n\t}\n\t\n\t// Fall back to cgroup v1 detection\n\tinfo.Version = CgroupV1\n\t\n\t// Parse /proc/cgroups for available controllers\n\tprocCgroups, err := ioutil.ReadFile(\"/proc/cgroups\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot read /proc/cgroups: %v\", err)\n\t}\n\t\n\tlines := strings.Split(string(procCgroups), \"\\n\")\n\tfor _, line := range lines[1:] { // Skip header\n\t\tfields := strings.Fields(line)\n\t\tif len(fields) >= 4 && fields[3] == \"1\" { // Enabled controller\n\t\t\tcontroller := fields[0]\n\t\t\tinfo.Controllers[controller] = true\n\t\t}\n\t}\n\t\n\t// Find mount points from /proc/mounts\n\tmounts, err := ioutil.ReadFile(\"/proc/mounts\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot read /proc/mounts: %v\", err)\n\t}\n\t\n\tfor _, line := range strings.Split(string(mounts), \"\\n\") {\n\t\tfields := strings.Fields(line)\n\t\tif len(fields) >= 3 && fields[2] == \"cgroup\" {\n\t\t\toptions := strings.Split(fields[3], \",\")\n\t\t\tfor _, opt := range options {\n\t\t\t\tif opt != \"cgroup\" && !strings.HasPrefix(opt, \"__\") {\n\t\t\t\t\tinfo.MountPoints[opt] = fields[1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Verify we have required controllers\n\trequired := []string{\"memory\", \"cpu\", \"pids\"}\n\tfor _, req := range required {\n\t\tif !info.Controllers[req] {\n\t\t\treturn nil, fmt.Errorf(\"required cgroup controller %s not available\", req)\n\t\t}\n\t\tif _, mounted := info.MountPoints[req]; !mounted && info.Version == CgroupV1 {\n\t\t\treturn nil, fmt.Errorf(\"cgroup controller %s not mounted\", req)\n\t\t}\n\t}\n\t\n\treturn info, nil\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n```go\n// internal/cgroup/manager.go\npackage cgroup\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n)\n\n// CgroupManager manages cgroup operations for containers\ntype CgroupManager struct {\n\tversion      CgroupVersion\n\tbasePath     string            // Base path for cgroup v2 or parent for v1\n\tcontrollers  map[string]bool   // Available controllers\n\tmountPoints  map[string]string // Controller mount points (v1 only)\n}\n\n// NewCgroupManager creates a new cgroup manager with auto-detection\nfunc NewCgroupManager() (*CgroupManager, error) {\n\tinfo, err := DetectCgroupInfo()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to detect cgroup info: %v\", err)\n\t}\n\t\n\tmanager := &CgroupManager{\n\t\tversion:     info.Version,\n\t\tcontrollers: info.Controllers,\n\t\tmountPoints: info.MountPoints,\n\t}\n\t\n\t// Set base path based on version\n\tif manager.version == CgroupV2 {\n\t\tmanager.basePath = \"/sys/fs/cgroup\"\n\t} else {\n\t\t// For v1, we'll use a parent directory under each controller\n\t\tmanager.basePath = \"/sys/fs/cgroup\"\n\t}\n\t\n\treturn manager, nil\n}\n\n// CreateCgroup creates a cgroup for the given container ID\nfunc (m *CgroupManager) CreateCgroup(containerID string) error {\n\tif m.version == CgroupV2 {\n\t\t// TODO 1: Construct full path: filepath.Join(m.basePath, \"container_runtime\", containerID)\n\t\t// TODO 2: Create directory with os.MkdirAll, permissions 0755\n\t\t// TODO 3: Verify directory was created and is writable\n\t\t// TODO 4: For v2, enable controllers by writing to cgroup.subtree_control\n\t} else {\n\t\t// TODO 5: For v1, create directory under each controller's mount point\n\t\t// TODO 6: For each required controller (memory, cpu, pids):\n\t\t//   - Build path: filepath.Join(mountPoints[controller], \"container_runtime\", containerID)\n\t\t//   - Create directory with os.MkdirAll\n\t\t// TODO 7: Verify all required controller directories were created\n\t}\n\treturn nil\n}\n\n// ApplyLimits writes resource limits to the container's cgroup\nfunc (m *CgroupManager) ApplyLimits(containerID string, limits ResourceLimits) error {\n\tif m.version == CgroupV2 {\n\t\t// TODO 8: Build cgroup path for this container\n\t\t// TODO 9: Apply memory limit: convert MB to bytes, write to \"memory.max\"\n\t\t// TODO 10: Apply CPU weight: convert CPUShares to v2 weight (1-10000), write to \"cpu.weight\"\n\t\t// TODO 11: Apply PIDs limit: write to \"pids.max\"\n\t\t// TODO 12: Verify each write by reading back and comparing\n\t} else {\n\t\t// TODO 13: For v1, apply limits to each controller separately\n\t\t// TODO 14: Memory: write to memory.limit_in_bytes and memory.kmem.limit_in_bytes\n\t\t// TODO 15: CPU: write cpu.shares to cpu directory\n\t\t// TODO 16: PIDs: write to pids.max in pids directory\n\t\t// TODO 17: Handle memory swappiness (optional): write to memory.swappiness\n\t}\n\treturn nil\n}\n\n// AddProcess adds a process to the container's cgroup\nfunc (m *CgroupManager) AddProcess(containerID string, pid int) error {\n\tpidStr := strconv.Itoa(pid)\n\t\n\tif m.version == CgroupV2 {\n\t\t// TODO 18: Write PID to cgroup.procs file in container's cgroup\n\t\t// TODO 19: Verify write succeeded by checking if PID appears in file\n\t} else {\n\t\t// TODO 20: For v1, write PID to tasks file in each controller's cgroup\n\t\t// TODO 21: Write to memory, cpu, and pids controller tasks files\n\t\t// TODO 22: Handle case where process might already be in a cgroup\n\t}\n\treturn nil\n}\n\n// RemoveCgroup recursively removes the container's cgroup\nfunc (m *CgroupManager) RemoveCgroup(containerID string) error {\n\tif m.version == CgroupV2 {\n\t\t// TODO 23: Build full cgroup path\n\t\t// TODO 24: Kill any remaining processes in cgroup (read cgroup.procs, send SIGKILL)\n\t\t// TODO 25: Remove directory with os.RemoveAll\n\t\t// TODO 26: Retry a few times if directory is busy (EBUSY)\n\t} else {\n\t\t// TODO 27: For v1, remove directory under each controller\n\t\t// TODO 28: For each controller, kill processes, then remove directory\n\t}\n\treturn nil\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **File Operations**: Use `ioutil.WriteFile` for atomic writes to cgroup control files. The kernel expects entire content at once, not partial writes.\n2. **Error Handling**: Check for `os.IsPermission` and `os.IsNotExist` to provide helpful error messages about cgroup configuration.\n3. **Concurrency**: Use a mutex (`sync.Mutex`) in `CgroupManager` if multiple goroutines might create cgroups concurrently.\n4. **Cleanup**: Implement `RemoveCgroup` as an idempotent operation—calling it multiple times should be safe.\n5. **Path Safety**: Always use `filepath.Join` instead of string concatenation to handle path separators correctly across systems.\n\n#### F. Milestone Checkpoint\n\n**Test Command**: \n```bash\nsudo go test ./internal/cgroup/... -v\n```\n\n**Expected Output**:\n```\n=== RUN   TestCgroupDetection\n--- PASS: TestCgroupDetection (0.01s)\n=== RUN   TestCreateCgroup\n--- PASS: TestCreateCgroup (0.02s)\n=== RUN   TestApplyMemoryLimit\n--- PASS: TestApplyMemoryLimit (0.03s)\n=== RUN   TestAddProcess\n--- PASS: TestAddProcess (0.05s)\nPASS\n```\n\n**Manual Verification**:\n1. Run a container with memory limit: `sudo ./runtime run --memory 50 alpine echo \"hello\"`\n2. Check cgroup exists: `sudo cat /sys/fs/cgroup/container_runtime/{container_id}/memory.max`\n3. Should show `52428800` (50MB in bytes)\n4. Run a memory-hungry process in container and verify OOM kill occurs when exceeding limit\n\n**Debugging Tips**:\n- If cgroup creation fails with \"permission denied\", ensure running as root\n- If memory limit isn't enforced, check if you're using cgroup v1 but forgot `memory.kmem.limit_in_bytes`\n- If `AddProcess` fails with \"no such process\", ensure you're using the correct PID (the child's PID, not the parent's)\n\n#### G. Debugging Tips Table\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Container not subject to memory limit | Process not in cgroup | Check `cat /sys/fs/cgroup/container_runtime/{id}/cgroup.procs` | Call `AddProcess` before `exec` |\n| Memory limit enforced but container uses more | Kernel memory not limited (v1) | Check `cat /sys/fs/cgroup/memory/container_runtime/{id}/memory.kmem.usage_in_bytes` | Set `memory.kmem.limit_in_bytes` |\n| CPU limit has no effect | CPU not saturated on host | Check `top` to see if system CPU usage is low | Shares only matter during contention; use quota/period for hard limits |\n| cgroup cleanup fails | Processes still running in cgroup | `ls -la /proc/{pid}/cgroup` for PIDs in cgroup | Kill processes before removing cgroup |\n| \"no such file\" errors | cgroup v2 not mounted | Check `mount | grep cgroup` | Mount cgroup2: `mount -t cgroup2 none /sys/fs/cgroup` |\n\n---\n\n\n> **Milestone(s):** Milestone 3: Filesystem Isolation (chroot/pivot_root)\n\n## Component Design: Filesystem Isolation (Milestone 3)\n\nThis component is responsible for giving each container its own private view of the filesystem, completely isolated from the host's filesystem hierarchy. While namespaces provide process isolation, filesystem isolation ensures the container can only see and modify files within its designated root filesystem (`rootfs`). This creates the illusion for the containerized process that it's running on a complete, independent operating system with its own `/bin`, `/lib`, `/etc`, and other directories, even though these are just directories on the host.\n\n### Mental Model: Giving Each Apartment Its Own Furniture\n\nThink of the host filesystem as a massive, fully-furnished mansion. When we create containers, we're setting up individual apartments within this mansion. Without filesystem isolation, each apartment resident would have access to the entire mansion's furniture, appliances, and personal belongings—a clear security and privacy problem.\n\nFilesystem isolation is like giving each apartment its own complete set of furniture and appliances that only that tenant can see and use:\n\n1. **Private Furniture (Root Filesystem)**: Each container gets its own `/` (root directory) containing all the files it needs to operate. This `rootfs` is typically extracted from a container image (like Alpine or Ubuntu). The container can install packages, create files, and modify configuration within this space without affecting other containers or the host.\n\n2. **Mirrored Utilities (Essential Filesystems)**: While the container has its own furniture, it still needs access to certain \"utilities\" provided by the building. We mount special filesystems like `/proc` and `/sys` inside the container so it can see its own processes and system information, not the host's. This is like providing each apartment with electricity and water connections that are metered separately.\n\n3. **Locked Doors (Unmounting Host Access)**: After moving the container into its private apartment, we lock the door to the rest of the mansion. This is achieved by unmounting the host's root filesystem from within the container's mount namespace, ensuring the container cannot access any host files even if it knows their paths.\n\n4. **Shared Storage Areas (Bind Mounts)**: Sometimes tenants need access to shared storage areas, like a communal laundry room. We can provide this through bind mounts—taking specific directories from the host and making them available at specific locations within the container. This is controlled and explicit, unlike the unrestricted access of `chroot` without mount namespaces.\n\nThe key insight is that filesystem isolation isn't about creating physical copies of files (that would be wasteful), but about creating a **virtual view** where the container sees only its assigned directory tree as the entire filesystem universe.\n\n### Architecture Decision Records: pivot_root vs chroot\n\n> **Decision: Use pivot_root with Mount Namespaces Instead of chroot**\n> - **Context**: We need to give containers an isolated view of the filesystem. The traditional approach is `chroot`, which changes the root directory for a process and its children. However, `chroot` has security limitations and doesn't play well with modern container requirements like proper `/proc` mounting and clean separation from the host.\n> - **Options Considered**:\n>   1. **chroot only**: Simple system call that changes the root directory\n>   2. **chroot with mount namespace**: chroot inside a mount namespace\n>   3. **pivot_root with mount namespace**: Modern approach that completely swaps root filesystems\n> - **Decision**: Use `pivot_root` combined with a mount namespace (`CLONE_NEWNS`).\n> - **Rationale**: \n>   - `pivot_root` is designed for containerization and allows us to completely replace the root filesystem while keeping the old root accessible for cleanup\n>   - It works atomically and avoids race conditions that `chroot` can have\n>   - Combined with a mount namespace, it allows us to unmount the old root entirely, preventing any access to host files\n>   - The OCI runtime specification recommends `pivot_root` for proper isolation\n> - **Consequences**:\n>   - Slightly more complex implementation than `chroot`\n>   - Requires creating a mount namespace first\n>   - Provides stronger security guarantees and cleaner isolation\n>   - Compatible with overlayfs and other union filesystems\n\n**Comparison Table: Filesystem Isolation Approaches**\n\n| Option | Pros | Cons | Why Not Chosen? |\n|--------|------|------|-----------------|\n| **chroot only** | Simple single system call, widely understood | Process can escape via file descriptors or procfs, doesn't isolate mounts, old root remains accessible | Security vulnerabilities, insufficient isolation for containers |\n| **chroot + mount namespace** | Better isolation than chroot alone, allows private mount points | Still uses chroot which has escape vectors, old root remains mounted somewhere | `pivot_root` is more secure and designed for this purpose |\n| **pivot_root + mount namespace** (CHOSEN) | Complete root replacement, old root can be unmounted, atomic operation, OCI-recommended | More complex, requires temporary directories | Best practice for container runtimes, provides proper isolation |\n\n### Common Pitfalls in Filesystem Isolation\n\n⚠️ **Pitfall 1: Using chroot Without Mount Namespace**\n- **Description**: Using only `chroot()` to change the root directory without first creating a mount namespace.\n- **Why it's wrong**: The process can escape the chroot jail using various techniques: keeping file descriptors to host directories, using `..` paths with `/proc/self/fd`, or mounting new filesystems. The host's `/proc` is still visible unless remounted.\n- **How to fix**: Always create a mount namespace (`CLONE_NEWNS`) before calling `chroot`, or better yet, use `pivot_root` which requires a mount namespace.\n\n⚠️ **Pitfall 2: Forgetting to Mount /proc Inside Container**\n- **Description**: After isolating the filesystem, not mounting a new `/proc` filesystem inside the container.\n- **Why it's wrong**: Many utilities (`ps`, `top`, `ls /proc`) will fail or show host processes. The container's PID namespace needs its own `/proc` to reflect container PIDs, not host PIDs.\n- **How to fix**: After `pivot_root`, mount a new proc filesystem at `/proc` inside the container with appropriate options (`nosuid,nodev,noexec`).\n\n⚠️ **Pitfall 3: Not Unmounting the Old Root**\n- **Description**: After `pivot_root`, leaving the old root filesystem accessible at the pivot directory.\n- **Why it's wrong**: The container could access host files through the old root mount point, breaking isolation.\n- **How to fix**: Always unmount the old root directory (with `MNT_DETACH` flag) after successful `pivot_root` and changing directory to the new root.\n\n⚠️ **Pitfall 4: Using Relative Paths for pivot_root**\n- **Description**: Passing relative paths to `pivot_root` instead of absolute paths.\n- **Why it's wrong**: `pivot_root` system call requires both arguments to be absolute paths. Relative paths cause the call to fail with `EINVAL`.\n- **How to fix**: Always convert paths to absolute using `filepath.Abs()` or similar before calling `pivot_root`.\n\n⚠️ **Pitfall 5: Incomplete Root Filesystem**\n- **Description**: The extracted `rootfs` doesn't contain essential binaries or libraries needed by the container's entrypoint.\n- **Why it's wrong**: Container process fails to start with \"executable not found\" or shared library errors, even though the binary exists in the path.\n- **How to fix**: Ensure the container image is properly extracted with all dependencies. Use minimal but complete base images like Alpine, and verify that required dynamic libraries are present with `ldd`.\n\n### Implementation Guidance for Root Filesystem Setup\n\nThe filesystem isolation component orchestrates multiple steps to prepare and switch to the container's root filesystem. Here's the complete procedure:\n\n#### Step-by-Step Filesystem Isolation Procedure\n\n1. **Prepare Container Directories**:\n   - Create a unique directory for the container under the runtime's storage path (e.g., `/var/lib/container-runtime/containers/<id>/`)\n   - Create subdirectories: `rootfs` (for the final merged view), `workdir` (for OverlayFS), `oldroot` (for pivot temporary)\n\n2. **Extract or Prepare Root Filesystem**:\n   - If using a container image, extract all layers to create the `rootfs` (using OverlayFS for Milestone 4)\n   - If using a direct rootfs directory, copy or bind mount it to the container's `rootfs` directory\n   - Ensure the rootfs contains essential directories (`/dev`, `/proc`, `/sys`, `/tmp` will be created or mounted later)\n\n3. **Create Mount Namespace**:\n   - Use `CLONE_NEWNS` flag when creating the container process to give it a private mount namespace\n   - This ensures all subsequent mount operations only affect the container, not the host\n\n4. **Mount Essential Virtual Filesystems**:\n   Before `pivot_root`, mount essential filesystems that should be available in the new root:\n   - Mount `tmpfs` at `/dev` for device nodes (or bind mount `/dev/null`, `/dev/zero`, `/dev/random`, etc.)\n   - Create basic device nodes if needed (`mknod` for console, null, etc.)\n   - Mount `proc` at `rootfs/proc` with `nosuid,nodev,noexec` flags\n   - Mount `sysfs` at `rootfs/sys` with `nosuid,nodev,noexec,ro` flags (read-only for security)\n   - Mount `tmpfs` at `rootfs/tmp` with appropriate size limits\n\n5. **Perform pivot_root**:\n   - Change to the container's `rootfs` directory\n   - Create a temporary directory (e.g., `.pivot_root`) inside `rootfs` to hold the old root\n   - Call `pivot_root` with arguments: new root = `rootfs`, put old = `.pivot_root`\n   - Change directory to the new root (`/`)\n   - Unmount the old root directory (now at `/.pivot_root`) with `MNT_DETACH`\n   - Remove the temporary `.pivot_root` directory\n\n6. **Final Mount Adjustments**:\n   - Remount `/` as private if needed (to prevent mount propagation to host)\n   - Ensure `/proc` is mounted correctly (remount if needed)\n   - Set up any bind mounts specified in container configuration (for volumes)\n\n7. **Change Working Directory**:\n   - Change to the working directory specified in the container configuration (or default to `/`)\n   - This ensures the process starts in the correct location within the container\n\n#### Component Responsibilities\n\nThe `FilesystemManager` component handles these responsibilities:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `SetupRootfs(image Image, containerID string)` | `image`: Image metadata, `containerID`: Unique container identifier | `string` (path to rootfs), `error` | Extracts image layers and prepares root filesystem for container |\n| `IsolateFilesystem(rootfsPath string)` | `rootfsPath`: Path to prepared root filesystem | `error` | Performs pivot_root and mounts essential filesystems inside container |\n| `CleanupFilesystem(containerID string)` | `containerID`: Container to clean up | `error` | Unmounts and removes container filesystem resources |\n| `MountProc(rootfsPath string)` | `rootfsPath`: Path to root filesystem | `error` | Mounts proc filesystem at rootfsPath/proc with proper options |\n| `MountSys(rootfsPath string)` | `rootfsPath`: Path to root filesystem | `error` | Mounts sysfs at rootfsPath/sys with read-only options |\n\n#### Data Structures for Filesystem Management\n\n| Name | Type | Description |\n|------|------|-------------|\n| `FilesystemManager` | struct | Manages container filesystem lifecycle |\n| `MountInfo` | struct | Information about a mount operation |\n| `MountConfig` | struct | Configuration for mounting virtual filesystems |\n\nThe `FilesystemManager` struct will contain:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `basePath` | `string` | Base directory for container storage |\n| `imageStore` | `ImageStore` | Reference to image storage component |\n| `useOverlay` | `bool` | Whether to use OverlayFS (Milestone 4) |\n\n#### Sequence of Operations\n\nReferencing the container creation sequence diagram ![Container Creation Sequence](./diagrams/container-creation-sequence.svg), the filesystem isolation occurs at this point in the flow:\n\n1. **User** runs `container run` command with an image name\n2. **CLI** parses command and calls `Runtime.CreateContainer()`\n3. **Container Manager** creates `Container` record in `StateCreated`\n4. **Container Manager** calls `FilesystemManager.SetupRootfs()` to extract image\n5. **Container Manager** creates namespaces including `CLONE_NEWNS`\n6. **Inside container process**, `FilesystemManager.IsolateFilesystem()` is called\n7. **Container process** performs `pivot_root` and mounts `/proc`, `/sys`\n8. **Container process** executes the entrypoint command inside isolated rootfs\n\n#### Security Considerations\n\n1. **Mount Flags**: Always use `nosuid,nodev,noexec` on non-essential mounts to prevent privilege escalation\n2. **Read-Only Mounts**: Mount `/sys` and potentially other directories as read-only when possible\n3. **Private Propagation**: Set mount propagation to `MS_PRIVATE` to prevent mount leaks between containers\n4. **Capabilities**: The container process needs `CAP_SYS_ADMIN` for mount operations, which should be dropped after setup\n\n#### Example Walkthrough: Alpine Container Startup\n\nLet's trace through a concrete example: starting an Alpine Linux container with `/bin/sh` as the entrypoint:\n\n1. **Image Extraction**: Alpine image layers are extracted to `/var/lib/container-runtime/containers/abc123/rootfs`\n2. **Namespace Creation**: Container process created with `CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUTS`\n3. **Mount Setup Inside Container**:\n   - Mount new `proc` at `/var/lib/.../abc123/rootfs/proc`\n   - Mount new `sysfs` at `/var/lib/.../abc123/rootfs/sys` (read-only)\n   - Mount `tmpfs` at `/var/lib/.../abc123/rootfs/tmp`\n4. **pivot_root**:\n   - `pivot_root(\"/var/lib/.../abc123/rootfs\", \"/var/lib/.../abc123/rootfs/.pivot_root\")`\n   - `chdir(\"/\")`\n   - `umount2(\"/.pivot_root\", MNT_DETACH)`\n   - `rmdir(\"/.pivot_root\")`\n5. **Process Execution**: `execve(\"/bin/sh\", [\"/bin/sh\"], container_env)`\n\nThe container now sees `/` as its Alpine root filesystem, `/proc` shows only container processes, and it cannot access any host files outside its rootfs.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| RootFS Preparation | Direct directory copy | OverlayFS union mount (Milestone 4) |\n| pivot_root Wrapper | Direct syscall.Syscall | Use `github.com/moby/sys/mount` package |\n| Mount Management | Manual mount/unmount calls | Use `golang.org/x/sys/unix` for mount constants |\n| ProcFS Setup | Simple mount with default options | Fine-tuned options (hidepid, gid, etc.) |\n\n#### B. Recommended File/Module Structure\n\n```\nproject-root/\n  cmd/\n    byod/                      # CLI entry point\n      main.go\n  internal/\n    container/\n      container.go             # Container struct and methods\n      store.go                 # ContainerStore implementation\n    runtime/\n      runtime.go              # ContainerRuntime main logic\n    filesystem/\n      manager.go              # FilesystemManager implementation\n      pivot.go                # pivot_root logic\n      mounts.go               # Mount/unmount helpers\n      overlay.go              # OverlayFS (for Milestone 4)\n    namespace/\n      manager.go              # NamespaceManager\n    cgroup/\n      manager.go              # CgroupManager\n    network/\n      manager.go              # NetworkManager\n    image/\n      manager.go              # Image handling\n  pkg/\n    syscall/                  # System call wrappers\n      pivot_root.go\n      mount.go\n```\n\n#### C. Infrastructure Starter Code\n\nHere's a complete, working `FilesystemManager` skeleton with helper functions:\n\n```go\npackage filesystem\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// FilesystemManager handles container filesystem operations\ntype FilesystemManager struct {\n\tbasePath   string      // Base directory for container storage\n\timageStore ImageStore  // Reference to image storage\n}\n\n// NewFilesystemManager creates a new filesystem manager\nfunc NewFilesystemManager(basePath string, imageStore ImageStore) *FilesystemManager {\n\treturn &FilesystemManager{\n\t\tbasePath:   basePath,\n\t\timageStore: imageStore,\n\t}\n}\n\n// ContainerPath returns the path to a container's directory\nfunc (fm *FilesystemManager) ContainerPath(containerID string) string {\n\treturn filepath.Join(fm.basePath, \"containers\", containerID)\n}\n\n// RootfsPath returns the path to a container's root filesystem\nfunc (fm *FilesystemManager) RootfsPath(containerID string) string {\n\treturn filepath.Join(fm.ContainerPath(containerID), \"rootfs\")\n}\n\n// SetupRootfs extracts image layers and prepares root filesystem\nfunc (fm *FilesystemManager) SetupRootfs(image Image, containerID string) (string, error) {\n\tcontainerPath := fm.ContainerPath(containerID)\n\trootfsPath := fm.RootfsPath(containerID)\n\t\n\t// Create container directory structure\n\tif err := os.MkdirAll(rootfsPath, 0755); err != nil {\n\t\treturn \"\", fmt.Errorf(\"creating container directory: %w\", err)\n\t}\n\t\n\t// TODO 1: Extract image layers to rootfsPath\n\t// For Milestone 3, you can start with a simple rootfs directory\n\t// For Milestone 4, implement OverlayFS mounting here\n\t\n\treturn rootfsPath, nil\n}\n\n// IsolateFilesystem performs pivot_root and mounts essential filesystems\n// This function is called from inside the container process after clone()\nfunc (fm *FilesystemManager) IsolateFilesystem(rootfsPath string) error {\n\t// TODO 2: Mount proc filesystem at rootfsPath/proc\n\tif err := MountProc(rootfsPath); err != nil {\n\t\treturn fmt.Errorf(\"mounting proc: %w\", err)\n\t}\n\t\n\t// TODO 3: Mount sysfs at rootfsPath/sys (read-only)\n\tif err := MountSys(rootfsPath); err != nil {\n\t\treturn fmt.Errorf(\"mounting sys: %w\", err)\n\t}\n\t\n\t// TODO 4: Create /dev directory and basic device nodes\n\tif err := SetupDev(rootfsPath); err != nil {\n\t\treturn fmt.Errorf(\"setting up /dev: %w\", err)\n\t}\n\t\n\t// TODO 5: Perform pivot_root to switch to the new root filesystem\n\tif err := PivotRoot(rootfsPath); err != nil {\n\t\treturn fmt.Errorf(\"pivot_root: %w\", err)\n\t}\n\t\n\treturn nil\n}\n\n// MountProc mounts proc filesystem at the given path\nfunc MountProc(rootfsPath string) error {\n\tprocPath := filepath.Join(rootfsPath, \"proc\")\n\tif err := os.MkdirAll(procPath, 0755); err != nil {\n\t\treturn err\n\t}\n\t\n\t// Mount proc with safe options: nosuid, nodev, noexec\n\tflags := uintptr(syscall.MS_NOSUID | syscall.MS_NODEV | syscall.MS_NOEXEC)\n\treturn syscall.Mount(\"proc\", procPath, \"proc\", flags, \"\")\n}\n\n// MountSys mounts sysfs at the given path (read-only)\nfunc MountSys(rootfsPath string) error {\n\tsysPath := filepath.Join(rootfsPath, \"sys\")\n\tif err := os.MkdirAll(sysPath, 0755); err != nil {\n\t\treturn err\n\t}\n\t\n\t// Mount sysfs read-only with safe options\n\tflags := uintptr(syscall.MS_NOSUID | syscall.MS_NODEV | syscall.MS_NOEXEC | syscall.MS_RDONLY)\n\treturn syscall.Mount(\"sysfs\", sysPath, \"sysfs\", flags, \"\")\n}\n\n// SetupDev creates /dev directory and essential device nodes\nfunc SetupDev(rootfsPath string) error {\n\tdevPath := filepath.Join(rootfsPath, \"dev\")\n\tif err := os.MkdirAll(devPath, 0755); err != nil {\n\t\treturn err\n\t}\n\t\n\t// Create basic device nodes\n\tdevices := []struct {\n\t\tpath  string\n\t\tmajor uint32\n\t\tminor uint32\n\t\tmode  uint32\n\t}{\n\t\t{\"/dev/null\", 1, 3, syscall.S_IFCHR | 0666},\n\t\t{\"/dev/zero\", 1, 5, syscall.S_IFCHR | 0666},\n\t\t{\"/dev/random\", 1, 8, syscall.S_IFCHR | 0666},\n\t\t{\"/dev/urandom\", 1, 9, syscall.S_IFCHR | 0666},\n\t}\n\t\n\tfor _, dev := range devices {\n\t\tfullPath := filepath.Join(rootfsPath, dev.path)\n\t\tif err := syscall.Mknod(fullPath, dev.mode, int(unix.Mkdev(dev.major, dev.minor))); err != nil && !os.IsExist(err) {\n\t\t\treturn fmt.Errorf(\"creating device node %s: %w\", dev.path, err)\n\t\t}\n\t}\n\t\n\treturn nil\n}\n\n// PivotRoot switches to a new root filesystem using pivot_root syscall\nfunc PivotRoot(rootfs string) error {\n\t// pivot_root requires both paths to be absolute\n\trootfs, err := filepath.Abs(rootfs)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"getting absolute path: %w\", err)\n\t}\n\t\n\t// Create temporary directory for old root\n\tpivotDir := filepath.Join(rootfs, \".pivot_root\")\n\tif err := os.Mkdir(pivotDir, 0755); err != nil {\n\t\treturn fmt.Errorf(\"creating pivot directory: %w\", err)\n\t}\n\t\n\t// Change to rootfs directory\n\tif err := syscall.Chdir(rootfs); err != nil {\n\t\treturn fmt.Errorf(\"chdir to rootfs: %w\", err)\n\t}\n\t\n\t// Call pivot_root system call\n\t// new_root = rootfs, put_old = pivotDir\n\tif err := syscall.PivotRoot(rootfs, pivotDir); err != nil {\n\t\treturn fmt.Errorf(\"pivot_root system call: %w\", err)\n\t}\n\t\n\t// Change directory to new root\n\tif err := syscall.Chdir(\"/\"); err != nil {\n\t\treturn fmt.Errorf(\"chdir to new root: %w\", err)\n\t}\n\t\n\t// Unmount old root (now at /.pivot_root)\n\toldRoot := \"/.pivot_root\"\n\tif err := syscall.Unmount(oldRoot, syscall.MNT_DETACH); err != nil {\n\t\treturn fmt.Errorf(\"unmounting old root: %w\", err)\n\t}\n\t\n\t// Remove temporary directory\n\tif err := os.Remove(oldRoot); err != nil {\n\t\treturn fmt.Errorf(\"removing old root directory: %w\", err)\n\t}\n\t\n\treturn nil\n}\n\n// CleanupFilesystem unmounts and removes container filesystem\nfunc (fm *FilesystemManager) CleanupFilesystem(containerID string) error {\n\trootfsPath := fm.RootfsPath(containerID)\n\t\n\t// Try to unmount any mounted filesystems\n\tmounts := []string{\n\t\tfilepath.Join(rootfsPath, \"proc\"),\n\t\tfilepath.Join(rootfsPath, \"sys\"),\n\t\tfilepath.Join(rootfsPath, \"dev\"),\n\t}\n\t\n\tfor _, mountPoint := range mounts {\n\t\tif _, err := os.Stat(mountPoint); err == nil {\n\t\t\t// Best-effort unmount, ignore errors if not mounted\n\t\t\tsyscall.Unmount(mountPoint, syscall.MNT_DETACH)\n\t\t}\n\t}\n\t\n\t// Remove container directory\n\tcontainerPath := fm.ContainerPath(containerID)\n\treturn os.RemoveAll(containerPath)\n}\n```\n\n#### D. Core Logic Skeleton Code\n\nHere's the skeleton for the main container entry point that orchestrates filesystem isolation:\n\n```go\npackage main\n\n// ChildEntryPoint is the function executed inside the container namespaces\n// This is called after clone() from the parent process\nfunc ChildEntryPoint(childFunc ChildFunc) {\n\t// TODO 1: Parse container configuration from command-line arguments or pipe\n\t\n\t// TODO 2: Setup root filesystem isolation\n\t// fsManager.IsolateFilesystem(rootfsPath)\n\t\n\t// TODO 3: Set hostname if UTS namespace is isolated\n\t// syscall.Sethostname([]byte(config.Hostname))\n\t\n\t// TODO 4: Setup container networking if network namespace is isolated\n\t// networkManager.SetupContainerNetwork()\n\t\n\t// TODO 5: Drop capabilities if running as root\n\t// Apply security restrictions\n\t\n\t// TODO 6: Execute the container command\n\t// syscall.Exec(command, args, env)\n\t\n\t// TODO 7: If exec fails, exit with error code\n}\n\n// setupContainerFilesystem orchestrates all filesystem isolation steps\nfunc setupContainerFilesystem(containerID string, config ContainerConfig) error {\n\t// TODO 1: Get FilesystemManager instance\n\t\n\t// TODO 2: Extract image and prepare rootfs if not already done\n\t// rootfsPath, err := fsManager.SetupRootfs(image, containerID)\n\t\n\t// TODO 3: Mount /proc inside container rootfs\n\t// fsManager.MountProc(rootfsPath)\n\t\n\t// TODO 4: Mount /sys inside container rootfs (read-only)\n\t// fsManager.MountSys(rootfsPath)\n\t\n\t// TODO 5: Setup /dev directory with essential device nodes\n\t// fsManager.SetupDev(rootfsPath)\n\t\n\t// TODO 6: Apply any bind mounts specified in config\n\t\n\t// TODO 7: Change working directory to container's WorkingDir\n\t\n\treturn nil\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Syscall Package**: Use `golang.org/x/sys/unix` for system call constants and `syscall` package for actual calls. Note that Go's `syscall` package is frozen but still works for basic operations.\n\n2. **Mount Flags**: Pay attention to mount flag differences between systems. Use `unix.MS_NOSUID | unix.MS_NODEV | unix.MS_NOEXEC` for safety.\n\n3. **Error Handling**: Many filesystem operations can fail with `EBUSY` if something is still using the filesystem. Use `MNT_DETACH` flag when unmounting to force detachment.\n\n4. **Path Handling**: Always use `filepath.Abs()` to convert to absolute paths before system calls, as many syscalls (including `pivot_root`) require absolute paths.\n\n5. **Cleanup on Failure**: Implement proper cleanup in case of partial failure. Use `defer` statements strategically to clean up temporary directories and mounts.\n\n#### F. Milestone Checkpoint\n\nAfter implementing filesystem isolation, you should be able to:\n\n1. **Test Basic Container**:\n   ```\n   $ sudo ./byod run --rootfs /path/to/alpine-rootfs /bin/sh\n   ```\n   Should start a shell inside an isolated filesystem.\n\n2. **Verify Isolation**:\n   ```bash\n   # Inside container\n   $ ls /           # Should show container rootfs, not host root\n   $ ps aux         # Should only show container processes (initially just sh)\n   $ hostname       # Should be container hostname, not host\n   ```\n\n3. **Test pivot_root Success**:\n   ```bash\n   # From host, check mounts\n   $ mount | grep container-id\n   # Should show container's proc mount\n   \n   # Try to access host files from container\n   $ sudo ./byod run --rootfs /path/to/alpine-rootfs /bin/sh -c \"ls /host\"\n   # Should fail: /host doesn't exist in container\n   ```\n\n4. **Common Failure Signs**:\n   - **\"Invalid argument\" error**: Likely wrong paths to `pivot_root` (not absolute)\n   - **\"Permission denied\"**: Need root privileges for mount operations\n   - **\"No such file or directory\"**: Missing essential directories in rootfs\n   - **/proc shows host processes**: Forgot to mount new proc after pivot_root\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Container can't find `/bin/sh` | Incomplete rootfs or wrong path | Check `ls -la /path/to/rootfs/bin/` from host | Ensure rootfs contains all needed binaries |\n| `pivot_root` returns EINVAL | Paths not absolute or rootfs not a mount point | Print paths before calling pivot_root | Use `filepath.Abs()` and ensure rootfs is a mount |\n| Can still see host files in container | Old root not unmounted or mount propagation issues | Check `mount` output inside container | Ensure unmount old root with `MNT_DETACH` |\n| `/proc` shows host PIDs | Proc not mounted or mounted incorrectly | Check `ls /proc` inside container | Mount proc after pivot_root with correct options |\n| Container exits immediately | Entrypoint binary missing libraries | Run `ldd /path/to/rootfs/bin/sh` from host | Include all shared libraries in rootfs |\n| \"Operation not permitted\" | Missing `CAP_SYS_ADMIN` capability | Check effective capabilities | Run as root or grant appropriate capabilities |\n\n\n> **Milestone(s):** Milestone 4: Layered Filesystem (OverlayFS)\n\n## Component Design: Layered Filesystem (Milestone 4)\n\nThis component is responsible for implementing copy-on-write layered filesystems, a cornerstone technology that enables efficient container image storage and sharing. While the previous filesystem isolation component (`FilesystemManager`) provides each container with its own private root filesystem, this component revolutionizes how those root filesystems are constructed by stacking multiple read-only layers and a single writable layer into a unified view, enabling the container to see a complete filesystem while writes are captured separately.\n\n### Mental Model: Transparent Overlays on a Projector\n\nThink of layered filesystems as a **stack of transparent acetate sheets on an overhead projector**. Each sheet (layer) contains drawings (files and directories) that can overlap. When projected together, you see a unified image where upper sheets obscure portions of lower sheets. The crucial property is that you can only draw on the top sheet—any modifications go there while preserving the original drawings on lower sheets for everyone else.\n\nIn technical terms:\n- **Lower layers** are read-only acetate sheets containing base operating system files, installed packages, and application code.\n- **Upper layer** is the writable top sheet where all container modifications (created files, deleted files, modified files) are recorded.\n- **Work directory** acts as a temporary scratch pad that the filesystem uses internally to manage atomic operations.\n- **Merged view** is the projected image—what the container process actually sees when it looks at its root filesystem.\n\nThe critical insight is that **identical lower layers can be shared across hundreds of containers**, just as multiple classrooms can use the same set of base acetate sheets. Each container gets its own writable top sheet for modifications, but the vast majority of data (OS files, libraries) is stored once and referenced many times, achieving tremendous storage efficiency.\n\n### Architecture Decision Records: OverlayFS vs Alternatives\n\n![Overlayfs Layout](./diagrams/overlayfs-layout.svg)\n\n#### Decision: OverlayFS for Layered Filesystem Implementation\n\n**Context**: We need a union filesystem that supports multiple read-only lower layers and a single writable upper layer with copy-on-write semantics. The solution must be kernel-based (for performance), widely available in modern Linux distributions, and support the OCI image standard's layer model. We must choose between kernel union filesystem implementations and userspace alternatives.\n\n**Options Considered**:\n1. **OverlayFS**: Kernel-based union filesystem merged into Linux mainline since kernel 3.18.\n2. **AUFS (Another Union File System)**: Older kernel patchset popular in early Docker versions.\n3. **Device Mapper + thin-provisioning**: Block-level snapshot mechanism used by Docker's devicemapper storage driver.\n4. **FUSE-based union filesystems (mergerfs, unionfs-fuse)**: Userspace implementations that don't require kernel support.\n\n**Decision**: We will implement OverlayFS as our layered filesystem technology.\n\n**Rationale**:\n- **Mainstream adoption**: OverlayFS is the default storage driver in Docker and recommended by the OCI community.\n- **Kernel integration**: As a kernel filesystem, it offers superior performance over FUSE-based solutions with lower CPU overhead.\n- **Minimal dependencies**: Available in stock Linux kernels since 3.18 (2015), requiring no additional kernel modules or patches.\n- **Simplicity**: The mount options and directory structure are straightforward, with clear documentation.\n- **Copy-on-write efficiency**: Provides true copy-on-write at the file level without block-level complexity.\n\n**Consequences**:\n- **Positive**: Excellent performance, widespread compatibility, and alignment with industry standards.\n- **Negative**: Requires Linux kernel ≥3.18 with OverlayFS enabled (CONFIG_OVERLAY_FS). Some advanced features (like recursive directory operations) have edge cases.\n- **Maintenance**: OverlayFS behavior is consistent across distributions, reducing platform-specific bugs.\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| OverlayFS | Kernel-native, excellent performance, default in Docker | Requires kernel ≥3.18, some edge cases with rename/delete | **CHOSEN** - Best balance of performance and availability |\n| AUFS | Mature, feature-rich | Not in mainline kernel, requires patching, less maintained | Not in mainline kernel, distribution support inconsistent |\n| Device Mapper | Block-level efficiency, snapshot support | Complex setup, requires LVM/thin-provisioning tools | Overkill for our educational container runtime, complex |\n| FUSE unionfs | Works on any kernel, no special privileges | High CPU overhead, slower performance, userspace complexity | Performance penalty too high for container workloads |\n\n#### Decision: Multiple Lower Layer Support\n\n**Context**: OCI images consist of multiple layers (often 10-20 for a typical application image). We need to decide how to represent these layers in our OverlayFS mount—either flattening them into a single directory or supporting true multi-layer stacking.\n\n**Options Considered**:\n1. **True multi-layer OverlayFS**: Pass all lower directories as a colon-separated list to the `lowerdir` mount option.\n2. **Two-layer flattening**: Extract and merge all read-only layers into a single directory, then use it as the only lower layer.\n3. **Incremental mounting**: Mount layers sequentially, with each layer becoming the lowerdir for the next.\n\n**Decision**: We will implement true multi-layer OverlayFS with colon-separated `lowerdir`.\n\n**Rationale**:\n- **Preserves layer identity**: Each layer remains distinct, enabling efficient layer sharing across containers.\n- **Optimized storage**: Identical layers aren't duplicated on disk when multiple images share them.\n- **OCI compliance**: Matches the standard image format where layers are applied sequentially.\n- **Efficient pull/update**: When pulling updated images, only changed layers need downloading; unchanged layers remain shared.\n\n**Consequences**:\n- **Implementation complexity**: Must manage layer ordering (lowest layer first in list) and handle potentially long `lowerdir` strings.\n- **Path length limitations**: Linux has PATH_MAX (4096) limitations for mount options; many layers could exceed this.\n- **Performance**: Kernel handles layer traversal efficiently without userspace merging overhead.\n\n### Common Pitfalls in OverlayFS Implementation\n\n⚠️ **Pitfall 1: Incorrect layer ordering in lowerdir**\n\n**Description**: Placing layers in the wrong order (newest first instead of oldest first) causes files from upper layers to be hidden by lower ones, breaking the image.\n\n**Why it's wrong**: OverlayFS renders files from the **last** lowerdir entry as the \"lowest\" layer. The base OS layer must be first in the list, with application layers appended in the order they were added during image build.\n\n**How to fix**: Always order layers chronologically from base to top. When parsing an OCI image manifest, layers are listed in application order—the first in the list is applied to the base, so it should be nearest to the upper layer in `lowerdir`.\n\n```\n# CORRECT: base layer first, then intermediate layers, then top read-only layer last\nlowerdir=/layers/layer4:/layers/layer3:/layers/layer2:/layers/layer1\n\n# WRONG: reversed order hides application files under OS files\nlowerdir=/layers/layer1:/layers/layer2:/layers/layer3:/layers/layer4\n```\n\n⚠️ **Pitfall 2: Forgetting the work directory**\n\n**Description**: Omitting the `workdir` mount option or pointing it to a non-empty directory.\n\n**Why it's wrong**: OverlayFS requires a dedicated `workdir` for atomic rename operations during copy-up. If absent or non-empty, the mount fails with \"invalid argument.\"\n\n**How to fix**: Always create an empty `workdir` adjacent to the `upperdir`. Use a unique subdirectory per container to prevent collisions.\n\n```go\n// Create work directory alongside upper\nworkDir := filepath.Join(containerDir, \"work\")\nif err := os.MkdirAll(workDir, 0755); err != nil { ... }\n```\n\n⚠️ **Pitfall 3: Not handling whiteouts properly**\n\n**Description**: When a container deletes a file from a lower layer, OverlayFS creates a \"whiteout\" (character device with major/minor 0/0) in the upper layer. Userspace tools must interpret these when exporting layers.\n\n**Why it's wrong**: If you later commit the container's upper layer to create a new image layer, you must convert whiteout devices back to OCI whiteout format (`.wh.<filename>` files) for compatibility with other tools.\n\n**How to fix**: When traversing the upper layer for layer creation, check for device files with `stat.Rdev == 0`. Convert them to whiteout entries in the layer tar archive.\n\n⚠️ **Pitfall 4: Mount propagation leaking between containers**\n\n**Description**: Without proper mount namespace isolation, an OverlayFS mount in one container might become visible in another container's filesystem view.\n\n**Why it's wrong**: This violates filesystem isolation—containers could see each other's OverlayFS mount points or, worse, modify them.\n\n**How to fix**: Ensure the container process runs in its own mount namespace (`CLONE_NEWNS`). Set mount propagation to `MS_PRIVATE` before creating OverlayFS mounts so they don't propagate to other namespaces.\n\n```go\n// In the container setup, before mounting OverlayFS\nsyscall.Mount(\"none\", \"/\", \"\", syscall.MS_PRIVATE|syscall.MS_REC, \"\")\n```\n\n⚠️ **Pitfall 5: Open file handles surviving unmount**\n\n**Description**: If a process inside the container holds open file descriptors to files in the OverlayFS, unmounting will fail with \"device busy.\"\n\n**Why it's wrong**: During container cleanup, you need to unmount the OverlayFS to release resources. Open files prevent this, causing resource leaks.\n\n**How to fix**: Before unmounting, ensure all processes in the container namespace have terminated. Use `MNT_DETACH` flag for lazy unmount as a fallback, but prefer proper process termination.\n\n```go\n// Force unmount with detach if regular unmount fails\nif err := syscall.Unmount(mountPath, 0); err != nil {\n    syscall.Unmount(mountPath, syscall.MNT_DETACH)\n}\n```\n\n### Implementation Guidance for Layered Filesystem\n\nThis section bridges the design concepts to concrete Go implementation, providing the scaffolding and key algorithms for the layered filesystem component.\n\n#### Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Union Filesystem | OverlayFS with `mount` syscall | Multiple backing stores (btrfs, zfs snapshots) |\n| Layer Storage | Plain directories with extracted tar layers | Content-addressable storage with deduplication |\n| Image Layer Cache | In-memory map of layer digests to paths | Database with reference counting and GC |\n| Whiteout Handling | Basic device node detection | Full OCI whiteout spec with opaque directories |\n\n#### Recommended File/Module Structure\n\nExtend the existing project structure with overlay-specific modules:\n\n```\nproject-root/\n├── cmd/\n│   └── byod/                    # CLI entry point\n├── internal/\n│   ├── container/               # Container management\n│   ├── cgroup/                  # Resource limits\n│   ├── namespace/               # Namespace isolation\n│   ├── network/                 # Networking\n│   ├── image/                   # Image handling (from Milestone 6)\n│   └── storage/                 # NEW: Storage and layered filesystems\n│       ├── storage.go           # Storage interface definitions\n│       ├── overlay.go           # OverlayFS implementation\n│       ├── layer.go             # Layer management\n│       ├── cache.go             # Layer caching\n│       └── whiteout.go          # Whiteout handling utilities\n└── pkg/\n    └── oci/                     # OCI image spec types\n```\n\n#### Infrastructure Starter Code\n\n**Complete OverlayFS Mount Helper** (ready to use):\n\n```go\n// internal/storage/overlay.go\npackage storage\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/byod/pkg/oci\"\n)\n\n// OverlayManager handles OverlayFS mounts for container root filesystems\ntype OverlayManager struct {\n\tstorageBase string  // Base directory for layer storage (e.g., /var/lib/byod/storage)\n}\n\n// NewOverlayManager creates a new OverlayFS manager\nfunc NewOverlayManager(storageBase string) (*OverlayManager, error) {\n\tif err := os.MkdirAll(storageBase, 0755); err != nil {\n\t\treturn nil, fmt.Errorf(\"creating storage base: %w\", err)\n\t}\n\treturn &OverlayManager{storageBase: storageBase}, nil\n}\n\n// MountOverlay creates an OverlayFS mount for a container\n// Returns the path to the merged directory (container's rootfs view)\nfunc (om *OverlayManager) MountOverlay(containerID string, lowerDirs []string, upperDir, workDir string) (string, error) {\n\t// Create necessary directories\n\tif err := os.MkdirAll(upperDir, 0755); err != nil {\n\t\treturn \"\", fmt.Errorf(\"creating upper dir: %w\", err)\n\t}\n\tif err := os.MkdirAll(workDir, 0755); err != nil {\n\t\treturn \"\", fmt.Errorf(\"creating work dir: %w\", err)\n\t}\n\t\n\tmergedDir := filepath.Join(filepath.Dir(upperDir), \"merged\")\n\tif err := os.MkdirAll(mergedDir, 0755); err != nil {\n\t\treturn \"\", fmt.Errorf(\"creating merged dir: %w\", err)\n\t}\n\t\n\t// Build lowerdir string (oldest layer first)\n\tlowerdir := strings.Join(lowerDirs, \":\")\n\t\n\t// OverlayFS mount options\n\toptions := fmt.Sprintf(\"lowerdir=%s,upperdir=%s,workdir=%s\", lowerdir, upperDir, workDir)\n\t\n\t// Mount OverlayFS\n\tif err := syscall.Mount(\"overlay\", mergedDir, \"overlay\", 0, options); err != nil {\n\t\treturn \"\", fmt.Errorf(\"mounting overlayfs: %w\", err)\n\t}\n\t\n\treturn mergedDir, nil\n}\n\n// UnmountOverlay unmounts and cleans up OverlayFS mount\nfunc (om *OverlayManager) UnmountOverlay(mergedDir string) error {\n\t// Try normal unmount first\n\tif err := syscall.Unmount(mergedDir, 0); err != nil {\n\t\t// Fallback to lazy unmount if busy\n\t\tsyscall.Unmount(mergedDir, syscall.MNT_DETACH)\n\t}\n\t\n\t// Clean up merged directory (safe after unmount)\n\tos.RemoveAll(mergedDir)\n\treturn nil\n}\n\n// GetLayerPath returns the path where a layer with given digest is stored\nfunc (om *OverlayManager) GetLayerPath(digest string) string {\n\t// Convert digest to safe filesystem path\n\t// OCI digests are like \"sha256:abc123...\" - use just the hash part\n\tparts := strings.SplitN(digest, \":\", 2)\n\thash := parts[1] if len(parts) > 1 else digest\n\treturn filepath.Join(om.storageBase, \"layers\", hash[:2], hash) // Sharding by first 2 chars\n}\n```\n\n**Layer Cache with Reference Counting** (ready to use):\n\n```go\n// internal/storage/cache.go\npackage storage\n\nimport (\n\t\"sync\"\n)\n\n// LayerCache tracks which layers are in use by containers\ntype LayerCache struct {\n\tmu     sync.RWMutex\n\tlayers map[string]int // digest -> reference count\n}\n\n// NewLayerCache creates a new layer cache\nfunc NewLayerCache() *LayerCache {\n\treturn &LayerCache{\n\t\tlayers: make(map[string]int),\n\t}\n}\n\n// AddReference increments reference count for a layer\nfunc (lc *LayerCache) AddReference(digest string) {\n\tlc.mu.Lock()\n\tdefer lc.mu.Unlock()\n\tlc.layers[digest]++\n}\n\n// ReleaseReference decrements reference count, returns true if count reaches zero\nfunc (lc *LayerCache) ReleaseReference(digest string) bool {\n\tlc.mu.Lock()\n\tdefer lc.mu.Unlock()\n\t\n\tif count, exists := lc.layers[digest]; exists {\n\t\tif count <= 1 {\n\t\t\tdelete(lc.layers, digest)\n\t\t\treturn true // Layer is no longer referenced\n\t\t}\n\t\tlc.layers[digest] = count - 1\n\t}\n\treturn false\n}\n\n// IsLayerCached checks if a layer exists in the cache\nfunc (lc *LayerCache) IsLayerCached(digest string) bool {\n\tlc.mu.RLock()\n\tdefer lc.mu.RUnlock()\n\t_, exists := lc.layers[digest]\n\treturn exists\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Layer Extraction and Preparation** (learner implements):\n\n```go\n// internal/storage/layer.go\npackage storage\n\nimport (\n\t\"archive/tar\"\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/byod/pkg/oci\"\n)\n\n// ExtractLayer extracts a compressed tar layer to the destination directory\n// layerPath: path to the .tar.gz layer file\n// destDir: directory to extract contents to\n// Returns the digest of the extracted layer for verification\nfunc ExtractLayer(layerPath, destDir string) (string, error) {\n\t// TODO 1: Open the layer file for reading\n\t// Hint: os.Open(layerPath)\n\t\n\t// TODO 2: Create a gzip reader to decompress the tar\n\t// Hint: gzip.NewReader(file)\n\t\n\t// TODO 3: Create a tar reader from the gzip reader\n\t// Hint: tar.NewReader(gzipReader)\n\t\n\t// TODO 4: Iterate through tar headers\n\t// for {\n\t//   header, err := tarReader.Next()\n\t//   if err == io.EOF { break }\n\t//   if err != nil { return \"\", err }\n\t\n\t// TODO 5: For each header, construct the full destination path\n\t// targetPath := filepath.Join(destDir, header.Name)\n\t\n\t// TODO 6: Handle different tar entry types:\n\t//   - TypeDir: Create directory with header.Mode permissions\n\t//   - TypeReg/TypeRegA: Create file, copy contents from tarReader\n\t//   - TypeSymlink: Create symbolic link\n\t//   - TypeLink: Create hard link\n\t//   - TypeChar/TypeBlock: Create device node with header.Devmajor/Devminor\n\t\n\t// TODO 7: Set proper ownership (header.Uid, header.Gid) using syscall.Chown\n\t// Note: This may require root privileges or user namespace setup\n\t\n\t// TODO 8: Set modification time from header.ModTime\n\t\n\t// TODO 9: Handle whiteout files (header.Name starts with \".wh.\")\n\t//   - Remove the corresponding file/directory from destination\n\t//   - For \".wh..wh..opq\" (opaque directory), mark directory as opaque\n\t\n\t// TODO 10: Close all readers and return nil if successful\n\t\n\treturn \"\", fmt.Errorf(\"not implemented\")\n}\n\n// PrepareLayersForContainer prepares all layers for a container's rootfs\n// image: The OCI image containing layer descriptors\n// containerID: Unique container identifier for storage paths\n// Returns: paths to lower directories (oldest first), upper dir, work dir, error\nfunc (om *OverlayManager) PrepareLayersForContainer(image *oci.Image, containerID string) ([]string, string, string, error) {\n\tcontainerDir := filepath.Join(om.storageBase, \"containers\", containerID)\n\t\n\t// TODO 1: Create container directories: upper, work, layers\n\t// upperDir := filepath.Join(containerDir, \"upper\")\n\t// workDir := filepath.Join(containerDir, \"work\")\n\t// layersDir := filepath.Join(containerDir, \"layers\")\n\t\n\t// TODO 2: For each layer in image.Layers (in order they appear in manifest):\n\t//   a. Check if layer already extracted in cache (use GetLayerPath)\n\t//   b. If not cached, download layer (from image store) and extract to cache\n\t//   c. Add layer reference to LayerCache\n\t//   d. Add layer path to lowerDirs slice\n\t\n\t// TODO 3: IMPORTANT: Reverse the lowerDirs slice for OverlayFS\n\t// OverlayFS expects oldest layer first, but OCI lists layers in application order\n\t// So layer[0] is applied on top of base, should be last in lowerdir list\n\t\n\t// TODO 4: Return lowerDirs (reversed), upperDir, workDir, nil\n\t\n\treturn nil, \"\", \"\", fmt.Errorf(\"not implemented\")\n}\n```\n\n**Updated FilesystemManager Integration** (learner implements):\n\n```go\n// internal/container/filesystem.go\npackage container\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\n\t\"github.com/byod/internal/storage\"\n\t\"github.com/byod/pkg/oci\"\n)\n\n// setupLayeredRootfs sets up a container rootfs using OverlayFS\nfunc (fm *FilesystemManager) setupLayeredRootfs(image *oci.Image, containerID string) (string, error) {\n\t// TODO 1: Initialize OverlayManager if not already done\n\t// if fm.overlayManager == nil {\n\t//   fm.overlayManager = storage.NewOverlayManager(fm.basePath)\n\t// }\n\t\n\t// TODO 2: Prepare layers using OverlayManager.PrepareLayersForContainer\n\t// lowerDirs, upperDir, workDir, err := fm.overlayManager.PrepareLayersForContainer(image, containerID)\n\t\n\t// TODO 3: Mount OverlayFS to create merged view\n\t// mergedDir, err := fm.overlayManager.MountOverlay(containerID, lowerDirs, upperDir, workDir)\n\t\n\t// TODO 4: Mount essential filesystems inside the merged directory\n\t//   - Mount /proc at mergedDir/proc\n\t//   - Mount /sys at mergedDir/sys (read-only)\n\t//   - Create /dev entries in mergedDir/dev\n\t\n\t// TODO 5: Return path to merged directory (will become container's rootfs)\n\t\n\treturn \"\", fmt.Errorf(\"not implemented\")\n}\n\n// cleanupLayeredRootfs cleans up OverlayFS mount and references\nfunc (fm *FilesystemManager) cleanupLayeredRootfs(containerID string) error {\n\t// TODO 1: Unmount essential filesystems (/proc, /sys, /dev) inside container rootfs\n\t\n\t// TODO 2: Get path to merged directory\n\t// mergedDir := filepath.Join(fm.basePath, \"containers\", containerID, \"merged\")\n\t\n\t// TODO 3: Unmount OverlayFS using OverlayManager.UnmountOverlay\n\t\n\t// TODO 4: Release references to all layers in LayerCache\n\t\n\t// TODO 5: Clean up container directories (upper, work, layers)\n\t// Note: Don't delete cached layers - they might be used by other containers\n\t\n\treturn fmt.Errorf(\"not implemented\")\n}\n```\n\n#### Language-Specific Hints\n\n1. **Mount Syscall**: Use `syscall.Mount(\"overlay\", target, \"overlay\", 0, options)` where options is a comma-separated string like `\"lowerdir=/a:/b,upperdir=/c,workdir=/d\"`.\n\n2. **Tar Extraction**: Use `archive/tar` and `compress/gzip` packages. Remember to handle symlinks and device files specially—regular file copying won't work for them.\n\n3. **Whiteout Detection**: Check if tar header name starts with `.wh.`. The OCI spec uses `.wh.<filename>` for whiteouts and `.wh..wh..opq` for opaque directories.\n\n4. **Path Length Limits**: Linux kernel has a 4096-byte limit for mount options. If your `lowerdir` string exceeds this, consider using the `volatile` lowerdir feature (kernel 4.13+) or workaround with intermediate mounts.\n\n5. **Error Handling**: OverlayFS mount can fail with specific errno values:\n   - `EINVAL`: Invalid options (check lowerdir/upperdir/workdir paths exist)\n   - `ENODEV`: OverlayFS not enabled in kernel (`CONFIG_OVERLAY_FS`)\n   - `EBUSY`: Mount point is busy (unmount previous mounts first)\n\n#### Milestone Checkpoint\n\nAfter implementing the layered filesystem component, verify it works correctly:\n\n**Test Command:**\n```bash\n# Build and run a test that creates a container with layered rootfs\ngo test ./internal/storage/... -v -run TestOverlayFS\n```\n\n**Expected Behavior:**\n1. An OCI image with multiple layers should be correctly assembled into a single rootfs.\n2. Files from upper layers should override files from lower layers with the same path.\n3. Creating a file in the container should appear only in the upper layer directory.\n4. Deleting a file from a lower layer should create a whiteout in the upper layer.\n5. After container cleanup, the merged directory should unmount successfully.\n\n**Manual Verification:**\n```bash\n# 1. Create a container with an alpine image\nsudo ./byod run --name test-layers alpine:latest /bin/sh\n\n# 2. Inside container, create a file\necho \"test\" > /myfile.txt\n\n# 3. Exit container and inspect layers\nls -la /var/lib/byod/storage/containers/test-layers/\n# Should show: upper/, work/, merged/, layers/\n\n# 4. Check upper layer contains the new file\nls -la /var/lib/byod/storage/containers/test-layers/upper/\n# Should show myfile.txt\n\n# 5. Check lower layers remain unchanged\n```\n\n**Signs of Problems:**\n- Container fails to start with \"invalid argument\": Check OverlayFS mount options format.\n- Files from base layer not visible: Lower layer order is reversed.\n- \"Device busy\" on cleanup: Processes still running in container namespace.\n- Permission errors: User namespace mapping incorrect or extraction ownership issues.\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Mount fails with \"invalid argument\" | Missing work directory or non-empty workdir | Check `dmesg \\| tail` for kernel messages | Create empty work directory before mount |\n| Files from application layer not visible | Lowerdir order incorrect | Print lowerdir string, verify chronological order | Reverse the lowerdir list (oldest first) |\n| \"Operation not permitted\" on mount | Missing capabilities or user namespace | Check `cat /proc/self/status \\| grep CapEff` | Run as root or grant CAP_SYS_ADMIN |\n| Container sees wrong file contents | Upper layer not properly separated | Check if upperdir is shared between containers | Use unique upperdir per container |\n| Unmount fails with \"device busy\" | Open file handles in container | `lsof +D /var/lib/byod/containers/<id>/merged` | Ensure all container processes terminated |\n| Whiteouts appear as character devices | Upper layer not interpreting whiteouts | Check `ls -l` in upperdir for device files with 0,0 | Implement whiteout handling in layer extraction |\n| Copy-up causes high CPU | Many small files copying up | Monitor with `inotifywait -rm /merged` | Consider tuning overlay kernel module params |\n\n---\n\n\n> **Milestone(s):** Milestone 5: Container Networking\n\n## Component Design: Container Networking (Milestone 5)\n\nContainer networking is the component that provides each container with an isolated network environment while enabling controlled connectivity to the host, other containers, and external networks. This involves creating a private network stack, establishing virtual network links, and configuring routing and firewall rules. The key architectural challenge is to provide useful network connectivity while maintaining the security and isolation guarantees of containers.\n\n### Mental Model: Private Phone Lines with a Switchboard\n\nImagine an office building with private phone lines. Each office (container) has its own private telephone network with a unique phone number and internal extensions. These private networks are connected to a central switchboard (bridge) in the building's telecom room (host). The switchboard can:\n\n1. **Connect offices internally**: When an office calls another office's extension, the switchboard routes the call directly between their private lines.\n2. **Route external calls**: When an office calls an outside number, the switchboard forwards the call through the building's main trunk line (host's physical interface), making it appear as if the call originated from the building's main number (host IP).\n3. **Receive incoming calls**: The switchboard can route calls from the main trunk to specific offices by mapping the building's main number plus an extension (host port) to an office's internal line (container port).\n\nThe private phone lines are **virtual ethernet (veth) pairs**—twin cables where one end plugs into the office's phone system and the other into the switchboard. The switchboard is a **Linux bridge**—a virtual switch that connects multiple veth ends. The building's firewall rules (**iptables**) determine which calls are allowed and how they're translated.\n\nThis model illustrates the complete isolation (each office has its own phone system), controlled connectivity (via the switchboard), and network address translation (external calls appear from the building) that container networking provides.\n\n### Architecture Decision Records: Network Topology\n\n#### Decision: Bridge Network with NAT for Default Connectivity\n\n**Context**: Containers need network isolation but also practical connectivity. We must choose a default network topology that balances isolation, ease of use, and compatibility with existing Docker workflows.\n\n**Options Considered**:\n1. **Host network mode**: Containers share the host's network namespace, providing maximum performance but zero network isolation.\n2. **Bridge network with NAT**: Each container gets its own network namespace, connected via veth pair to a Linux bridge, with NAT for external connectivity (Docker's default).\n3. **Macvlan**: Containers get direct MAC addresses on the physical network, appearing as separate physical devices but requiring switch configuration.\n4. **None**: No network connectivity at all—complete isolation.\n\n**Decision**: Bridge network with NAT as the default topology.\n\n**Rationale**: \n- **Isolation**: Each container gets a full isolated network stack (own interfaces, routing, iptables).\n- **Practicality**: NAT allows containers to access external networks without requiring public IPs for each container.\n- **Port mapping**: Host port forwarding enables services inside containers to be accessible from outside the host.\n- **Inter-container communication**: Containers on the same bridge can communicate directly via their private IPs.\n- **Established pattern**: Matches Docker's default `bridge` driver, providing familiar behavior for users.\n\n**Consequences**:\n- **Performance overhead**: Extra hop through bridge and NAT layer introduces minor latency.\n- **IP address management**: Requires IPAM (IP Address Management) to allocate unique IPs to containers.\n- **NAT complexities**: Requires iptables rules for masquerading and port forwarding.\n- **Bridge setup**: Requires creating and managing a Linux bridge device.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Host network | Maximum performance, no setup required | Zero network isolation, port conflicts | No |\n| **Bridge with NAT** | **Good isolation, external access via NAT, port mapping, inter-container communication** | **NAT overhead, IPAM required, bridge setup** | **Yes** |\n| Macvlan | Direct physical network access, no NAT overhead | Requires network support, no port mapping, less isolation | No |\n| None | Maximum isolation | No network connectivity | No |\n\n#### Decision: veth Pair for Container-Host Connectivity\n\n**Context**: We need to connect the container's isolated network namespace to the host's network namespace to provide connectivity.\n\n**Options Considered**:\n1. **veth pair**: Virtual Ethernet device pair—one end in container, one end in host, connected like a virtual network cable.\n2. **macvlan**: Assigns a unique MAC address to container, attaching directly to physical interface.\n3. **ipvlan**: Similar to macvlan but shares MAC address, differing only in IP configuration.\n\n**Decision**: veth pair.\n\n**Rationale**:\n- **Simplicity**: Well-understood, stable Linux primitive.\n- **Bridge compatibility**: veth endpoints can be added to Linux bridges easily.\n- **Isolation**: Complete layer 2 separation between container and host.\n- **Debugging**: Easy to inspect with `ip link` on both ends.\n\n**Consequences**:\n- Requires creating and configuring two devices per container.\n- Must manage lifecycle (create, move to namespace, delete).\n- Bridge acts as a virtual switch connecting multiple veth ends.\n\n#### Decision: iptables for NAT and Firewalling\n\n**Context**: Containers with private IPs need to communicate with external networks, and we need to forward host ports to container ports.\n\n**Options Considered**:\n1. **iptables**: Traditional Linux firewall/NAT tool using netfilter hooks.\n2. **nftables**: Newer replacement for iptables with unified syntax.\n3. **Userspace proxy**: Proxy connections in userspace (like Docker's legacy mode).\n\n**Decision**: iptables.\n\n**Rationale**:\n- **Ubiquity**: Available on virtually all Linux systems.\n- **Docker compatibility**: Docker uses iptables, ensuring consistent behavior.\n- **Performance**: Kernel-space packet processing, minimal overhead.\n- **Mature**: Well-documented with extensive community knowledge.\n\n**Consequences**:\n- Complex rule management (must add/remove rules per container).\n- Potential conflicts with existing host iptables rules.\n- Requires understanding of netfilter chains and traversal order.\n\n![Container Network Topology](./diagrams/network-topology.svg)\n\n### Common Pitfalls in Container Networking\n\n⚠️ **Pitfall: DNS Resolution Failures Inside Container**\n\n**Description**: The container can ping IP addresses but cannot resolve hostnames (e.g., `curl https://google.com` fails). This occurs because the container's `/etc/resolv.conf` is either missing, empty, or contains invalid DNS servers.\n\n**Why it's wrong**: Network connectivity without DNS is severely limited—most applications rely on hostname resolution.\n\n**How to fix**: \n1. Copy the host's `/etc/resolv.conf` into the container rootfs (but note this may leak host DNS configuration).\n2. Use a known public DNS server like `8.8.8.8` (Google) or `1.1.1.1` (Cloudflare).\n3. Better: Detect the host's DNS configuration via `systemd-resolve` or `/run/systemd/resolve/resolv.conf` and use those nameservers.\n\n**Prevention**: Always configure `/etc/resolv.conf` as part of container filesystem setup. Use a template that includes fallback nameservers.\n\n⚠️ **Pitfall: iptables Rules Blocking Inter-Container Communication**\n\n**Description**: Containers on the same bridge cannot ping each other, though they have IP addresses on the same subnet. This often happens because the host's firewall rules (particularly in the `FORWARD` chain) are dropping packets between bridge interfaces.\n\n**Why it's wrong**: The bridge device forwards at layer 2, but iptables filters at layer 3. Default policies may block forwarded traffic.\n\n**How to fix**: \n1. Ensure `net.ipv4.ip_forward=1` is set on the host.\n2. Add iptables rules to allow forwarded traffic between bridge interfaces: `iptables -I FORWARD -i br0 -o br0 -j ACCEPT`.\n3. Check that the bridge's `FORWARD` chain policy is `ACCEPT`.\n\n**Prevention**: During bridge creation, configure iptables rules to allow traffic between containers on the same bridge and set appropriate forward policies.\n\n⚠️ **Pitfall: Host Port Conflict on Container Start**\n\n**Description**: Starting a container with port mapping fails with \"bind: address already in use\" because the host port is already occupied by another process.\n\n**Why it's wrong**: The container runtime should detect this before attempting to start the container and provide a clear error message.\n\n**How to fix**: \n1. Before setting up port forwarding, check if the host port is available by attempting to listen on it (with `SO_REUSEADDR`).\n2. If occupied, either fail with a clear error or automatically select an alternative port (if configured to do so).\n\n**Prevention**: Implement port availability checking in the `NetworkManager.SetupNetwork` method before adding iptables rules.\n\n⚠️ **Pitfall: Orphaned Network Resources After Container Crash**\n\n**Description**: When a container crashes or is killed, its network namespace and veth pair may remain on the host, accumulating over time and causing resource leaks.\n\n**Why it's wrong**: Orphaned network namespaces consume kernel resources and may interfere with subsequent containers (e.g., IP address conflicts).\n\n**How to fix**: \n1. Always implement cleanup in a `defer` statement or signal handler.\n2. On container start, record the network namespace handle and veth pair names for later cleanup.\n3. During container removal, forcefully delete the network namespace if it still exists (`ip netns delete <ns>`).\n\n**Prevention**: Design the `NetworkManager` to track created resources and provide a `CleanupNetwork` method that is called during container removal, even after failures.\n\n⚠️ **Pitfall: MTU Mismatch Causing Packet Fragmentation**\n\n**Description**: Network performance is poor, with high latency and dropped packets. This can occur when the MTU (Maximum Transmission Unit) of the veth interface differs from the host's physical interface or bridge.\n\n**Why it's wrong**: Packets exceeding the MTU will be fragmented (reducing performance) or dropped.\n\n**How to fix**: \n1. Set the MTU on veth interfaces to match the host's physical interface (typically 1500 for Ethernet).\n2. Consider lowering MTU if using overlay networks or VPNs.\n\n**Prevention**: During veth creation, explicitly set the MTU based on the host's default route interface MTU.\n\n### Implementation Guidance for Network Setup\n\nThis section provides concrete implementation guidance for the networking component. The primary challenge is orchestrating multiple Linux networking primitives while handling errors and cleanup properly.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Network Namespace Creation | `unshare(CLONE_NEWNET)` via Go's `syscall` package | `ip netns add` via exec for better tool compatibility |\n| Interface Management | `netlink` library (e.g., `github.com/vishvananda/netlink`) | Raw syscalls via `syscall` package |\n| Bridge Creation | `netlink` library or `ip link add br0 type bridge` via exec | Direct ioctl calls |\n| iptables Rules | `exec.Command(\"iptables\", ...)` | `github.com/coreos/go-iptables/iptables` library |\n| Port Forwarding | iptables DNAT rules | Userspace proxy (like socat) for complex scenarios |\n| IP Address Management | Static allocation from a predefined subnet | DHCP server or IPAM library |\n\n#### B. Recommended File/Module Structure\n\nAdd networking-specific files to the project structure:\n\n```\nproject-root/\n├── cmd/\n│   └── byod/                         # CLI entry point\n├── internal/\n│   ├── container/                    # Container management\n│   ├── cgroup/                       # cgroup management\n│   ├── image/                        # Image handling\n│   ├── filesystem/                   # Filesystem isolation\n│   ├── network/                      # NEW: Network component\n│   │   ├── manager.go                # NetworkManager implementation\n│   │   ├── bridge.go                 # Bridge creation and management\n│   │   ├── veth.go                   # veth pair operations\n│   │   ├── iptables.go               # iptables rule management\n│   │   ├── ipam.go                   # IP Address Management\n│   │   └── network_test.go           # Network tests\n│   └── runtime/                      # Main runtime coordination\n└── pkg/\n    └── netutil/                      # Reusable networking utilities\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete `netlink` wrapper for basic operations** (import and use as-is):\n\n```go\n// internal/network/netlink_helper.go\npackage network\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"runtime\"\n\n\t\"github.com/vishvananda/netlink\"\n\t\"github.com/vishvananda/netns\"\n)\n\n// NetlinkHelper provides convenience methods for common network operations\ntype NetlinkHelper struct{}\n\n// NewNetlinkHelper creates a new helper instance\nfunc NewNetlinkHelper() *NetlinkHelper {\n\treturn &NetlinkHelper{}\n}\n\n// CreateBridge creates a Linux bridge with the given name and IP address\nfunc (h *NetlinkHelper) CreateBridge(name string, ipNet *net.IPNet) error {\n\t// Check if bridge already exists\n\t_, err := netlink.LinkByName(name)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"bridge %s already exists\", name)\n\t}\n\n\t// Create bridge attributes\n\tla := netlink.NewLinkAttrs()\n\tla.Name = name\n\tbridge := &netlink.Bridge{LinkAttrs: la}\n\n\t// Add bridge\n\tif err := netlink.LinkAdd(bridge); err != nil {\n\t\treturn fmt.Errorf(\"failed to create bridge %s: %v\", name, err)\n\t}\n\n\t// Set bridge UP\n\tif err := netlink.LinkSetUp(bridge); err != nil {\n\t\t// Clean up on failure\n\t\tnetlink.LinkDel(bridge)\n\t\treturn fmt.Errorf(\"failed to set bridge %s up: %v\", name, err)\n\t}\n\n\t// Assign IP address if provided\n\tif ipNet != nil {\n\t\taddr := &netlink.Addr{IPNet: ipNet}\n\t\tif err := netlink.AddrAdd(bridge, addr); err != nil {\n\t\t\tnetlink.LinkDel(bridge)\n\t\t\treturn fmt.Errorf(\"failed to add IP %s to bridge %s: %v\", ipNet.String(), name, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// CreateVethPair creates a veth pair with the given names\nfunc (h *NetlinkHelper) CreateVethPair(hostVethName, containerVethName string, mtu int) error {\n\t// Create veth pair attributes\n\tveth := &netlink.Veth{\n\t\tLinkAttrs: netlink.LinkAttrs{\n\t\t\tName: hostVethName,\n\t\t\tMTU:  mtu,\n\t\t},\n\t\tPeerName: containerVethName,\n\t}\n\n\t// Add veth pair\n\tif err := netlink.LinkAdd(veth); err != nil {\n\t\treturn fmt.Errorf(\"failed to create veth pair %s-%s: %v\", hostVethName, containerVethName, err)\n\t}\n\n\t// Set host veth UP\n\thostVeth, err := netlink.LinkByName(hostVethName)\n\tif err != nil {\n\t\tnetlink.LinkDel(veth)\n\t\treturn fmt.Errorf(\"failed to find host veth %s: %v\", hostVethName, err)\n\t}\n\tif err := netlink.LinkSetUp(hostVeth); err != nil {\n\t\tnetlink.LinkDel(veth)\n\t\treturn fmt.Errorf(\"failed to set host veth %s up: %v\", hostVethName, err)\n\t}\n\n\treturn nil\n}\n\n// MoveInterfaceToNamespace moves a network interface to the specified network namespace\nfunc (h *NetlinkHelper) MoveInterfaceToNamespace(ifaceName string, nsPath string) error {\n\t// Get the interface\n\tiface, err := netlink.LinkByName(ifaceName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to find interface %s: %v\", ifaceName, err)\n\t}\n\n\t// Get the target namespace\n\tnsHandle, err := netns.GetFromPath(nsPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get namespace from path %s: %v\", nsPath, err)\n\t}\n\tdefer nsHandle.Close()\n\n\t// Move the interface\n\tif err := netlink.LinkSetNsFd(iface, int(nsHandle)); err != nil {\n\t\treturn fmt.Errorf(\"failed to move interface %s to namespace: %v\", ifaceName, err)\n\t}\n\n\treturn nil\n}\n\n// ConfigureInterfaceInNamespace configures an interface inside a network namespace\n// Must be called from within the namespace context\nfunc (h *NetlinkHelper) ConfigureInterfaceInNamespace(ifaceName string, ipNet *net.IPNet, gateway net.IP) error {\n\t// Get the interface\n\tiface, err := netlink.LinkByName(ifaceName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to find interface %s in namespace: %v\", ifaceName, err)\n\t}\n\n\t// Set interface UP\n\tif err := netlink.LinkSetUp(iface); err != nil {\n\t\treturn fmt.Errorf(\"failed to set interface %s up: %v\", ifaceName, err)\n\t}\n\n\t// Add IP address\n\tif ipNet != nil {\n\t\taddr := &netlink.Addr{IPNet: ipNet}\n\t\tif err := netlink.AddrAdd(iface, addr); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to add IP %s to interface %s: %v\", ipNet.String(), ifaceName, err)\n\t\t}\n\t}\n\n\t// Add default route if gateway provided\n\tif gateway != nil {\n\t\tdefaultRoute := &netlink.Route{\n\t\t\tDst: nil, // Default route\n\t\t\tGw:  gateway,\n\t\t}\n\t\tif err := netlink.RouteAdd(defaultRoute); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to add default route via %s: %v\", gateway.String(), err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// LockOSThreadAndExecute locks the OS thread and executes fn in the specified namespace\nfunc (h *NetlinkHelper) LockOSThreadAndExecute(nsPath string, fn func() error) error {\n\t// Lock the goroutine to its current OS thread\n\truntime.LockOSThread()\n\tdefer runtime.UnlockOSThread()\n\n\t// Get current namespace\n\toriginalNS, err := netns.Get()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get current namespace: %v\", err)\n\t}\n\tdefer originalNS.Close()\n\n\t// Get target namespace\n\ttargetNS, err := netns.GetFromPath(nsPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get target namespace %s: %v\", nsPath, err)\n\t}\n\tdefer targetNS.Close()\n\n\t// Switch to target namespace\n\tif err := netns.Set(targetNS); err != nil {\n\t\treturn fmt.Errorf(\"failed to enter namespace %s: %v\", nsPath, err)\n\t}\n\n\t// Execute function\n\terr = fn()\n\n\t// Switch back to original namespace\n\tif setErr := netns.Set(originalNS); setErr != nil {\n\t\t// Log but return original error if any\n\t\tif err == nil {\n\t\t\terr = fmt.Errorf(\"failed to return to original namespace: %v\", setErr)\n\t\t}\n\t}\n\n\treturn err\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**NetworkManager implementation** (to be completed by the learner):\n\n```go\n// internal/network/manager.go\npackage network\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\n\t\"your-project/internal/container\"\n)\n\n// NetworkManager handles container network setup and teardown\ntype NetworkManager struct {\n\tbaseBridgeName string\n\tbridgeIPNet    *net.IPNet\n\tipam           *IPAM\n\thelper         *NetlinkHelper\n}\n\n// NewNetworkManager creates a new NetworkManager with default bridge configuration\nfunc NewNetworkManager() (*NetworkManager, error) {\n\t// Default bridge subnet: 172.17.0.0/16 (Docker-compatible)\n\t_, ipNet, err := net.ParseCIDR(\"172.17.0.1/16\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse default subnet: %v\", err)\n\t}\n\n\treturn &NetworkManager{\n\t\tbaseBridgeName: \"byod0\",\n\t\tbridgeIPNet:    ipNet,\n\t\tipam:           NewIPAM(ipNet),\n\t\thelper:         NewNetlinkHelper(),\n\t}, nil\n}\n\n// SetupNetwork configures the network namespace for a container\nfunc (nm *NetworkManager) SetupNetwork(nsPath string, config container.NetworkConfig) error {\n\t// TODO 1: Validate network configuration\n\t//   - Check NetworkConfig.Mode is supported (e.g., \"bridge\", \"none\", \"host\")\n\t//   - For bridge mode, ensure BridgeName is set or use default\n\t//   - Validate IPAddress if provided (must be within bridge subnet)\n\t//   - Validate PortMappings (host port > 0, container port > 0)\n\n\t// TODO 2: Create or ensure bridge exists\n\t//   - Use nm.helper.CreateBridge() to create bridge if it doesn't exist\n\t//   - Set bridge IP address (first IP in subnet, e.g., 172.17.0.1/16)\n\t//   - Enable IP forwarding on host: sysctl net.ipv4.ip_forward=1\n\n\t// TODO 3: Allocate IP address for container\n\t//   - Use nm.ipam.Allocate() to get an available IP\n\t//   - If config.IPAddress is provided, try to allocate that specific IP\n\t//   - Store allocation for later cleanup\n\n\t// TODO 4: Create veth pair\n\t//   - Generate unique names: host veth \"veth<containerID[:8]>\", container veth \"eth0\"\n\t//   - Use nm.helper.CreateVethPair() with MTU 1500\n\t//   - Move container veth end to container's network namespace using nm.helper.MoveInterfaceToNamespace()\n\n\t// TODO 5: Configure container veth inside namespace\n\t//   - Use nm.helper.LockOSThreadAndExecute() to enter container namespace\n\t//   - Inside namespace:\n\t//     a. Rename container veth to \"eth0\"\n\t//     b. Configure IP address and default gateway (bridge IP)\n\t//     c. Set interface UP\n\t//     d. Configure loopback interface (set UP)\n\n\t// TODO 6: Attach host veth to bridge\n\t//   - Use netlink to attach host veth end to bridge\n\n\t// TODO 7: Setup iptables rules\n\t//   - Masquerading: Allow container outbound traffic via NAT\n\t//   - Port forwarding: DNAT rules for each PortMapping\n\t//   - Inter-container communication: Allow FORWARD traffic between bridge interfaces\n\n\t// TODO 8: Configure DNS in container\n\t//   - Create /etc/resolv.conf in container rootfs with nameservers (e.g., 8.8.8.8)\n\n\t// TODO 9: Record network configuration for later cleanup\n\t//   - Store veth names, IP allocation, iptables rule identifiers\n\n\treturn nil\n}\n\n// CleanupNetwork removes all network resources for a container\nfunc (nm *NetworkManager) CleanupNetwork(containerID string, config container.NetworkConfig) error {\n\t// TODO 1: Retrieve saved network configuration for this container\n\n\t// TODO 2: Remove iptables rules\n\t//   - Delete masquerading rule\n\t//   - Delete port forwarding rules\n\t//   - Delete inter-container communication rules if this is the last container\n\n\t// TODO 3: Remove veth pair from bridge and delete it\n\n\t// TODO 4: Release IP address back to IPAM pool\n\n\t// TODO 5: If this is the last container using the bridge, optionally remove bridge\n\n\treturn nil\n}\n\n// IPAM manages IP address allocation within a subnet\ntype IPAM struct {\n\tsubnet    *net.IPNet\n\tallocated map[string]bool\n}\n\n// NewIPAM creates a new IPAM for the given subnet\nfunc NewIPAM(subnet *net.IPNet) *IPAM {\n\treturn &IPAM{\n\t\tsubnet:    subnet,\n\t\tallocated: make(map[string]bool),\n\t}\n}\n\n// Allocate allocates an available IP address from the subnet\nfunc (i *IPAM) Allocate(requestedIP string) (net.IP, error) {\n\t// TODO 1: If requestedIP is provided, validate it's within subnet and not allocated\n\t// TODO 2: If no requestedIP, find first available IP in subnet (skip network and broadcast addresses)\n\t// TODO 3: Mark IP as allocated in the map\n\t// TODO 4: Return allocated IP\n\treturn nil, nil\n}\n\n// Release returns an IP address to the pool\nfunc (i *IPAM) Release(ip net.IP) error {\n\t// TODO 1: Validate IP is within subnet\n\t// TODO 2: Check if IP is actually allocated\n\t// TODO 3: Remove from allocated map\n\treturn nil\n}\n```\n\n**iptables rule management** (skeleton):\n\n```go\n// internal/network/iptables.go\npackage network\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\t\"strconv\"\n)\n\n// IPTablesManager manages iptables rules for container networking\ntype IPTablesManager struct{}\n\n// SetupMasquerade sets up NAT masquerading for containers to reach external networks\nfunc (im *IPTablesManager) SetupMasquerade(bridgeName string) error {\n\t// TODO 1: Check if masquerade rule already exists in nat table POSTROUTING chain\n\t// TODO 2: If not, add rule: iptables -t nat -A POSTROUTING -s <bridgeSubnet> ! -o <bridgeName> -j MASQUERADE\n\t// TODO 3: Also ensure FORWARD chain accepts traffic from and to bridge\n\treturn nil\n}\n\n// AddPortForwarding adds DNAT rule to forward host port to container port\nfunc (im *IPTablesManager) AddPortForwarding(hostPort, containerPort int, protocol, containerIP string) error {\n\t// TODO 1: Validate protocol is \"tcp\" or \"udp\"\n\t// TODO 2: Add rule: iptables -t nat -A PREROUTING -p <protocol> --dport <hostPort> -j DNAT --to-destination <containerIP>:<containerPort>\n\t// TODO 3: Add rule: iptables -A FORWARD -p <protocol> -d <containerIP> --dport <containerPort> -j ACCEPT\n\treturn nil\n}\n\n// RemovePortForwarding removes the DNAT rule\nfunc (im *IPTablesManager) RemovePortForwarding(hostPort, containerPort int, protocol, containerIP string) error {\n\t// TODO 1: Construct the exact rule that was added\n\t// TODO 2: Use iptables -t nat -D PREROUTING ... to delete the rule\n\t// TODO 3: Delete the corresponding FORWARD rule\n\treturn nil\n}\n\n// runIptablesCommand is a helper to execute iptables commands\nfunc runIptablesCommand(args ...string) error {\n\tcmd := exec.Command(\"iptables\", args...)\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"iptables %v failed: %v, output: %s\", args, err, output)\n\t}\n\treturn nil\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Namespace Handling**: Use `runtime.LockOSThread()` when switching network namespaces with `netns.Set()`. The Go scheduler may move goroutines between threads, causing namespace switches to affect other goroutines.\n\n2. **Netlink Library**: The `github.com/vishvananda/netlink` and `github.com/vishvananda/netns` packages are de facto standards for Go container networking. They wrap complex netlink socket operations.\n\n3. **Error Cleanup**: Use defer statements strategically. When creating multiple resources (bridge, veth, iptables rules), create a cleanup function that can be called on failure.\n\n4. **Concurrent Access**: The `NetworkManager` may be called concurrently for multiple containers. Use a mutex to protect the IPAM allocation map and bridge creation.\n\n5. **File Descriptors**: When working with network namespaces via file descriptors (`/proc/<pid>/ns/net`), ensure they're closed properly to avoid resource leaks.\n\n#### F. Milestone Checkpoint\n\n**Verification Steps**:\n\n1. **Basic Network Isolation**:\n   ```bash\n   # Run a container with network isolation\n   sudo ./byod run --network=bridge --hostname=testcontainer alpine ip addr\n   ```\n   **Expected**: The container should show only `lo` and `eth0` interfaces, not host interfaces.\n\n2. **External Connectivity**:\n   ```bash\n   # Run a container and test external connectivity\n   sudo ./byod run --network=bridge alpine ping -c 3 8.8.8.8\n   ```\n   **Expected**: Ping succeeds with 3 packets transmitted and received.\n\n3. **DNS Resolution**:\n   ```bash\n   # Test DNS inside container\n   sudo ./byod run --network=bridge alpine nslookup google.com\n   ```\n   **Expected**: Returns IP addresses for google.com.\n\n4. **Port Forwarding**:\n   ```bash\n   # In one terminal, run a web server in container\n   sudo ./byod run --network=bridge -p 8080:80 alpine nc -l -p 80\n   \n   # In another terminal, connect via host port\n   echo \"test\" | nc localhost 8080\n   ```\n   **Expected**: The connection succeeds; the first terminal receives \"test\".\n\n5. **Inter-Container Communication**:\n   ```bash\n   # Start first container with custom hostname\n   sudo ./byod run --network=bridge --name=container1 alpine sleep 30 &\n   CONTAINER1_PID=$!\n   \n   # Get its IP address (you'll need to implement `byod inspect` or check bridge)\n   CONTAINER1_IP=172.17.0.2  # Adjust based on actual allocation\n   \n   # Start second container and ping first\n   sudo ./byod run --network=bridge alpine ping -c 2 $CONTAINER1_IP\n   ```\n   **Expected**: Ping succeeds between containers.\n\n**Signs of Problems**:\n- `ping: bad address 'google.com'` → DNS misconfiguration\n- `connect: Network is unreachable` → Default route missing or bridge not configured\n- `bind: address already in use` → Host port conflict\n- `ping: sendmsg: operation not permitted` → Missing NAT masquerading rule\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Container has no network interfaces | Network namespace not created or veth not moved | Check `/proc/<pid>/ns/net` symlink target; run `ip netns list` | Ensure `CLONE_NEWNET` flag is used and veth is moved to namespace |\n| Container cannot ping external IPs | Missing NAT masquerading or IP forwarding disabled | Check `sysctl net.ipv4.ip_forward`; check iptables `POSTROUTING` chain | Enable IP forwarding; add masquerade rule |\n| Container cannot resolve DNS | Missing/incorrect `/etc/resolv.conf` | Check container's `/etc/resolv.conf` contents | Copy host's resolv.conf or use public DNS (8.8.8.8) |\n| Host cannot connect to container port | Missing port forwarding rule or wrong iptables chain | Check `iptables -t nat -L PREROUTING -n` for DNAT rule | Add correct DNAT rule and ensure FORWARD chain allows traffic |\n| Containers on same bridge cannot ping each other | FORWARD chain dropping packets between bridge interfaces | Check `iptables -L FORWARD -n`; check bridge STP settings | Add `iptables -I FORWARD -i br0 -o br0 -j ACCEPT` |\n| veth interface disappears after container exit | Not properly cleaning up network namespace | Check if network namespace still exists: `ip netns list` | Ensure cleanup deletes namespace or moves veth back before deleting |\n\n**Diagnostic Commands**:\n```bash\n# Inspect network namespaces\nsudo ip netns list\nsudo ls -la /proc/<container-pid>/ns/\n\n# Check bridge configuration\nsudo brctl show  # or ip link show type bridge\nsudo ip addr show br0\n\n# Check iptables rules\nsudo iptables -t nat -L -n -v\nsudo iptables -L FORWARD -n -v\n\n# Check routing inside container namespace\nsudo nsenter -t <pid> -n ip route show\nsudo nsenter -t <pid> -n ip addr show\n\n# Check DNS configuration\nsudo nsenter -t <pid> -n cat /etc/resolv.conf\n```\n\n---\n\n\n> **Milestone(s):** Milestone 6: Image Format and CLI\n\n## Component Design: Image Format and CLI (Milestone 6)\n\nThis component is the user-facing interface and the image management engine of the container runtime. It transforms user commands into containerized processes by orchestrating all the underlying isolation primitives and managing the lifecycle of container images according to the OCI (Open Container Initiative) specification. While the previous components (`NamespaceManager`, `CgroupManager`, `FilesystemManager`, `NetworkManager`) provide the raw isolation capabilities, this component provides the cohesive user experience and image distribution model that make containers usable and portable.\n\n### Mental Model: Recipe Cards and Ingredient Boxes\n\nThink of a container image as a **recipe card** for creating a standardized environment. The card (`ImageConfig`) lists the ingredients (`ImageLayers` - tar archives of filesystem diffs) and the instructions (`Entrypoint`, `Cmd`, `Env`) for what to run. The **ingredient boxes** are stored in a shared pantry (`image store`), where each box is labeled with a unique hash (`Digest`) of its contents. When you want to run the recipe, you don't copy all the boxes to your kitchen; instead, you create a thin, writable overlay on top of the stacked boxes (`OverlayFS merged view`) to cook in. If multiple people are making the same dish, they can all reference the same read-only ingredient boxes, saving immense space and time.\n\nThe **CLI (Command Line Interface)** is like the head chef who reads the recipe card, gathers the ingredients from the pantry (or orders them online from a `registry`), sets up a new, private kitchen station (`namespaces`, `cgroups`, `network`), and then hands over control to the recipe's instructions to cook the meal (run the `Entrypoint`). The chef also keeps a logbook (`ContainerStore`) of all the kitchen stations currently set up, their status, and who is cooking what.\n\nThis mental model clarifies the separation of concerns: **images are immutable, content-addressed templates**, and **containers are runtime instances** of those templates with added writable state, resource limits, and network connectivity. The CLI is the orchestration layer that glues these concepts together into a coherent workflow.\n\n### Architecture Decision Records: OCI Compatibility\n\n> **Decision: Implement OCI Image and Runtime Specs for Maximum Compatibility**\n> - **Context**: Our runtime must be able to run standard container images (like those from Docker Hub) and interoperate with existing ecosystem tools. We need to choose an image format and runtime interface.\n> - **Options Considered**:\n>     1. **Proprietary, Simple Format**: Define a custom, minimal tarball and JSON config format.\n>     2. **Docker v1 Image Format**: Implement Docker's older, legacy image manifest format.\n>     3. **OCI Image & Runtime Specifications**: Implement the open standards defined by the Open Container Initiative.\n> - **Decision**: Implement a subset of the **OCI Image Specification (v1.0.2)** and adhere to the **OCI Runtime Specification** for the low-level container execution.\n> - **Rationale**: The OCI specs are industry standards, ensuring our runtime can pull and run any OCI-compliant image (including those built by Docker, Podman, and buildah). This maximizes utility and educational value by connecting to the real-world container ecosystem. While more complex than a proprietary format, the specs are well-documented and designed for interoperability.\n> - **Consequences**: We must parse multi-layer manifests, handle content-addressable storage via layer digests, and structure our container creation process to match the OCI runtime lifecycle. This adds implementation complexity but yields a tool with real-world relevance.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Proprietary Format** | Simple to implement and understand; total control. | Cannot run existing images; not useful beyond the project. | ❌ |\n| **Docker v1 Format** | Wide historical image base; well-understood. | Legacy, deprecated format; less future-proof. | ❌ |\n| **OCI Specifications** | Industry standard; interoperable; future-proof; well-documented. | More complex; larger spec surface area. | ✅ |\n\nA second critical decision involves the client-registry protocol:\n\n> **Decision: Implement Basic OCI Distribution API for Image Pull**\n> - **Context**: To get images, we need to communicate with a registry (like Docker Hub). The protocol must support authentication, manifest fetching, and layer downloads.\n> - **Options Considered**:\n>     1. **Local Images Only**: Only support loading images from tar files on disk.\n>     2. **Implement Docker Registry HTTP API V2**: The protocol Docker uses.\n>     3. **Implement OCI Distribution Spec**: The standardized protocol for distributing OCI images.\n> - **Decision**: Implement the core of the **OCI Distribution Specification** (which is largely compatible with Docker Registry API v2) for pulling images.\n> - **Rationale**: The OCI Distribution Spec is the standardized, non-proprietary way to fetch OCI images. Its overlap with Docker's API means we can pull from `docker.io` and other compliant registries. Supporting only local archives would severely limit the tool's usefulness.\n> - **Consequences**: We must handle HTTP `GET` requests for manifests and blob (layer) downloads, parse authentication realms from `WWW-Authenticate` headers for public images (and optionally support token-based auth), and respect layer `Content-Type` headers. We will not initially support pushing (`PUT`) images.\n\n### Common Pitfalls in Image Handling and CLI\n\n⚠️ **Pitfall: Assuming Manifest is a Single JSON File**\n- **Description**: An OCI image index or manifest is not a simple JSON file sitting alone. It's part of a **content-addressable store** where the digest (hash) of the manifest's content is used as its address. The `index.json` points to a platform-specific manifest, which then points to a config and layers.\n- **Why it's wrong**: Trying to fetch `index.json` as a static file will fail. You must use the digest (or tag) to request the manifest blob from the `/manifests/` endpoint. The registry returns the manifest's content *and* a `Docker-Content-Digest` header, which you must verify.\n- **How to fix**: Always treat manifests as blobs. Use the `Accept: application/vnd.oci.image.manifest.v1+json` header. After downloading, compute the SHA256 of the received content and verify it matches the digest in the response header or the one you requested.\n\n⚠️ **Pitfall: Not Managing Layer Cache References**\n- **Description**: When multiple containers use the same base image layer, the layer should exist only once on disk. If you simply extract layers to a container-specific directory each time, you duplicate storage.\n- **Why it's wrong**: This defeats the primary efficiency of container images. It wastes disk space and makes container creation slower.\n- **How to fix**: Implement a **content-addressable layer cache** (using the `LayerCache` type). Store layers keyed by their digest. When setting up a container rootfs, create hard links or copy-on-write references from the cache to the container's OverlayFS lower directories. Use a reference count to know when a layer can be safely garbage-collected.\n\n⚠️ **Pitfall: Ignoring Image Configuration**\n- **Description**: The `ImageConfig` (a separate JSON blob referenced by the manifest) contains critical runtime information: the default `Entrypoint`, `Cmd`, `Env`, `WorkingDir`, and `Volumes`. Ignoring it and just extracting layers results in a container that may not start correctly.\n- **Why it's wrong**: The container's intended command and environment won't be set. The user would have to specify the full command every time, breaking compatibility with standard images.\n- **How to fix**: Parse the `ImageConfig` and use its fields to populate the `ContainerConfig`. The `Entrypoint` and `Cmd` from the image should be combined (following OCI rules) to form the final `argv` for the container process. The `Env` should be merged with any user-provided environment variables.\n\n⚠️ **Pitfall: Poor CLI State Management**\n- **Description**: The CLI's `start`, `stop`, `remove` commands must track the container's state precisely. For example, trying to `start` an already `running` container should be an error, and `remove` should only work on `stopped` containers.\n- **Why it's wrong**: Without a clear state machine, you can get into inconsistent states (e.g., a \"removed\" container whose cgroups and network are still active). This leads to resource leaks and confusing user experience.\n- **How to fix**: Model the container lifecycle as a **state machine** (see diagram below). The `ContainerStore` should persist the `ContainerState`. Every state transition (`start`, `stop`, `remove`) must validate the current state, perform the transition, and update the persisted state atomically. Use file locks or a simple database to prevent concurrent modifications.\n\n![Container Lifecycle State Machine](./diagrams/container-lifecycle.svg)\n\n### Implementation Guidance for Image Format and CLI\n\nThis section bridges the high-level design to concrete implementation in Go. We'll structure the code into clear modules for image handling and CLI commands.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n| :--- | :--- | :--- |\n| **Image Registry Client** | HTTP GET with `net/http`, basic token auth | Full OCI distribution client with auth challenges, retries, progress bars |\n| **Manifest/Layer Storage** | Filesystem in a directory tree (`<store>/blobs/sha256/<digest>`) | Content-addressable storage with integrity verification and garbage collection |\n| **CLI Framework** | Standard library `flag` package for parsing | `cobra` or `urfave/cli` for structured subcommands, help generation |\n| **State Persistence** | JSON files in a directory (`<store>/containers/<id>/config.json`) | Embedded SQLite database for atomic transactions and queries |\n| **Image Cache** | In-memory map of digest to path with file-based refcount | Deduplicated storage with reflinks (if filesystem supports) |\n\n#### B. Recommended File/Module Structure\n\nThe Image and CLI components integrate with the existing runtime components. Create a new `internal` directory for them.\n\n```\nproject-root/\n├── cmd/\n│   └── byod/                          # CLI entry point\n│       └── main.go                    # Parses flags, calls runtime\n├── internal/\n│   ├── cli/                           # CLI command implementations\n│   │   ├── commands.go                # run, start, stop, ps, rm commands\n│   │   └── utils.go                   # Table output, formatting helpers\n│   ├── image/                         # OCI image handling\n│   │   ├── image.go                   # Image, ImageConfig, ImageLayer types\n│   │   ├── store.go                   # ImageStore (local cache of images)\n│   │   ├── registry/                  # Client for remote registries\n│   │   │   ├── client.go              # RegistryClient, pull logic\n│   │   │   ├── auth.go                # Token authentication\n│   │   │   └── types.go               # Manifest, Descriptor types\n│   │   └── oci/                       # OCI spec structs (can be generated)\n│   │       ├── manifest.go            # OCI Manifest and Index structs\n│   │       └── config.go              # OCI Image Config structs\n│   └── runtime/                       # Existing components (from prev. milestones)\n│       ├── container.go               # Container, ContainerConfig, etc.\n│       ├── store.go                   # ContainerStore\n│       ├── manager.go                 # ContainerRuntime (orchestrates all managers)\n│       ├── namespace/\n│       ├── cgroup/\n│       ├── filesystem/\n│       ├── network/\n│       └── overlay/\n└── storage/                           # Default storage directory\n    ├── containers/\n    │   └── <id>/\n    │       ├── config.json\n    │       └── rootfs/                # OverlayFS merged directory\n    └── images/\n        ├── <image-name>/\n        │   └── manifest.json          # Cached manifest\n        └── blobs/\n            └── sha256/\n                ├── <digest1>          # Layer tar.gz\n                ├── <digest2>          # Config json\n                └── ...\n```\n\n#### C. Infrastructure Starter Code\n\nHere is complete, working starter code for the **ImageStore** (local cache) and the **RegistryClient**'s core HTTP fetching logic. These are prerequisites that learners can copy and use directly.\n\n**File: `internal/image/store.go`**\n```go\npackage image\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yourproject/internal/image/oci\"\n)\n\n// ImageStore manages the local cache of OCI images.\ntype ImageStore struct {\n\tbasePath string // e.g., \"/var/lib/byod/images\"\n}\n\n// NewImageStore creates a new store at the given base directory.\nfunc NewImageStore(basePath string) (*ImageStore, error) {\n\tif err := os.MkdirAll(basePath, 0755); err != nil {\n\t\treturn nil, fmt.Errorf(\"creating image store directory: %w\", err)\n\t}\n\t// Create blob directory structure\n\tblobsPath := filepath.Join(basePath, \"blobs\", \"sha256\")\n\tif err := os.MkdirAll(blobsPath, 0755); err != nil {\n\t\treturn nil, fmt.Errorf(\"creating blobs directory: %w\", err)\n\t}\n\treturn &ImageStore{basePath: basePath}, nil\n}\n\n// blobPath returns the filesystem path for a blob with the given digest.\n// Digest must be of the form \"sha256:abcdef...\"\nfunc (s *ImageStore) blobPath(digest string) (string, error) {\n\tif len(digest) < 9 || digest[:7] != \"sha256:\" {\n\t\treturn \"\", fmt.Errorf(\"invalid digest format: %s\", digest)\n\t}\n\thash := digest[7:]\n\treturn filepath.Join(s.basePath, \"blobs\", \"sha256\", hash), nil\n}\n\n// StoreBlob saves a blob (layer tar, config json, manifest) to the store.\n// It computes the SHA256 digest of the content as it's written and verifies it matches the provided digest.\n// Returns the digest (sha256:...) on success.\nfunc (s *ImageStore) StoreBlob(src io.Reader, expectedDigest string) (string, error) {\n\tpath, err := s.blobPath(expectedDigest)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// If already exists, verify? For simplicity, assume it's correct.\n\tif _, err := os.Stat(path); err == nil {\n\t\treturn expectedDigest, nil\n\t}\n\n\t// Write to temporary file first, then rename atomically.\n\ttmpPath := path + \".tmp\"\n\ttmpFile, err := os.Create(tmpPath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"creating temp blob file: %w\", err)\n\t}\n\tdefer tmpFile.Close()\n\tdefer os.Remove(tmpPath)\n\n\thash := sha256.New()\n\tmultiWriter := io.MultiWriter(tmpFile, hash)\n\n\tif _, err := io.Copy(multiWriter, src); err != nil {\n\t\treturn \"\", fmt.Errorf(\"copying blob data: %w\", err)\n\t}\n\tif err := tmpFile.Close(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tcomputedDigest := \"sha256:\" + hex.EncodeToString(hash.Sum(nil))\n\tif computedDigest != expectedDigest {\n\t\treturn \"\", fmt.Errorf(\"digest mismatch: expected %s, got %s\", expectedDigest, computedDigest)\n\t}\n\n\tif err := os.Rename(tmpPath, path); err != nil {\n\t\treturn \"\", fmt.Errorf(\"renaming blob to final location: %w\", err)\n\t}\n\treturn computedDigest, nil\n}\n\n// GetBlob returns a ReadCloser for the blob with the given digest.\nfunc (s *ImageStore) GetBlob(digest string) (io.ReadCloser, error) {\n\tpath, err := s.blobPath(digest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn os.Open(path)\n}\n\n// GetManifest reads and parses an OCI manifest for a given image reference (tag or digest).\nfunc (s *ImageStore) GetManifest(ref string) (*oci.Manifest, error) {\n\t// For simplicity, assume ref is a digest. In a real implementation,\n\t// you'd resolve tags to digests via an index.\n\tpath, err := s.blobPath(ref)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading manifest blob: %w\", err)\n\t}\n\tvar manifest oci.Manifest\n\tif err := json.Unmarshal(data, &manifest); err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshaling manifest: %w\", err)\n\t}\n\treturn &manifest, nil\n}\n\n// StoreManifest saves a manifest and associates it with a tag (image reference).\nfunc (s *ImageStore) StoreManifest(ref string, manifest *oci.Manifest) error {\n\tdata, err := json.Marshal(manifest)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"marshaling manifest: %w\", err)\n\t}\n\t// Store as a blob first.\n\tdigest, err := s.StoreBlob(bytes.NewReader(data), \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Then create a tag file pointing to the digest.\n\t// In OCI, tags are usually managed by an index. Simplified here.\n\ttagPath := filepath.Join(s.basePath, \"refs\", ref)\n\tif err := os.MkdirAll(filepath.Dir(tagPath), 0755); err != nil {\n\t\treturn err\n\t}\n\treturn os.WriteFile(tagPath, []byte(digest+\"\\n\"), 0644)\n}\n```\n\n**File: `internal/image/registry/client.go`**\n```go\npackage registry\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"yourproject/internal/image/oci\"\n)\n\n// RegistryClient can pull images from an OCI-compliant registry.\ntype RegistryClient struct {\n\tbaseURL    string // e.g., \"https://registry-1.docker.io\"\n\thttpClient *http.Client\n}\n\n// NewRegistryClient creates a client for a given registry host.\nfunc NewRegistryClient(host string) *RegistryClient {\n\treturn &RegistryClient{\n\t\tbaseURL:    \"https://\" + host,\n\t\thttpClient: &http.Client{},\n\t}\n}\n\n// getManifest fetches the manifest for a given image reference (e.g., \"library/alpine:latest\").\n// It returns the raw manifest bytes and its digest (from Docker-Content-Digest header).\nfunc (c *RegistryClient) getManifest(imageRef, tag string) ([]byte, string, error) {\n\t// URL path: /v2/<image>/manifests/<tag>\n\tpath := fmt.Sprintf(\"/v2/%s/manifests/%s\", imageRef, tag)\n\treq, err := http.NewRequest(\"GET\", c.baseURL+path, nil)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\t// Accept OCI manifest format\n\treq.Header.Set(\"Accept\", \"application/vnd.oci.image.manifest.v1+json\")\n\t// For Docker Hub, also accept Docker's manifest schema.\n\treq.Header.Add(\"Accept\", \"application/vnd.docker.distribution.manifest.v2+json\")\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, \"\", fmt.Errorf(\"HTTP request failed: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, \"\", fmt.Errorf(\"unexpected status %d for manifest\", resp.StatusCode)\n\t}\n\n\tdata, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tdigest := resp.Header.Get(\"Docker-Content-Digest\")\n\tif digest == \"\" {\n\t\t// Fallback: compute digest locally if header missing.\n\t\tdigest = computeSHA256Digest(data)\n\t}\n\treturn data, digest, nil\n}\n\n// PullManifest fetches and parses the manifest for an image.\nfunc (c *RegistryClient) PullManifest(imageRef, tag string) (*oci.Manifest, string, error) {\n\tdata, digest, err := c.getManifest(imageRef, tag)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tvar manifest oci.Manifest\n\tif err := json.Unmarshal(data, &manifest); err != nil {\n\t\treturn nil, \"\", fmt.Errorf(\"unmarshaling manifest: %w\", err)\n\t}\n\treturn &manifest, digest, nil\n}\n\n// PullLayer downloads a layer blob identified by digest and writes it to the provided writer.\nfunc (c *RegistryClient) PullLayer(imageRef, digest string, w io.Writer) error {\n\t// URL path: /v2/<image>/blobs/<digest>\n\tpath := fmt.Sprintf(\"/v2/%s/blobs/%s\", imageRef, digest)\n\treq, err := http.NewRequest(\"GET\", c.baseURL+path, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"HTTP request failed: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected status %d for layer %s\", resp.StatusCode, digest)\n\t}\n\t_, err = io.Copy(w, resp.Body)\n\treturn err\n}\n\n// Helper function to compute SHA256 digest.\nfunc computeSHA256Digest(data []byte) string {\n\t// Implementation omitted for brevity; use crypto/sha256.\n\treturn \"sha256:...\"\n}\n```\n\n#### D. Core Logic Skeleton Code\n\nNow, the core logic that learners should implement themselves: the `ContainerRuntime` methods that orchestrate image pull and container creation, and the CLI command handlers.\n\n**File: `internal/runtime/manager.go` (additions)**\n```go\n// PullImage downloads an image from a registry, stores it locally, and returns an Image object.\n// imageRef format: [registry/]repository[:tag|@digest] (e.g., \"alpine:latest\", \"docker.io/library/nginx:alpine\")\nfunc (r *ContainerRuntime) PullImage(imageRef string) (*image.Image, error) {\n\t// TODO 1: Parse the image reference into registry host, repository, and tag/digest.\n\t//         Default registry to \"docker.io\" and tag to \"latest\" if not specified.\n\t// TODO 2: Create a RegistryClient for the registry host.\n\t// TODO 3: Call PullManifest to fetch the manifest and its digest.\n\t// TODO 4: Download the config blob (manifest.Config.Digest) using PullLayer and store it via ImageStore.StoreBlob.\n\t// TODO 5: For each layer descriptor in manifest.Layers:\n\t//   a. Check if the layer already exists in the local ImageStore (by digest).\n\t//   b. If not, download it via PullLayer, writing to a temporary file or pipe.\n\t//   c. Store the downloaded layer blob using ImageStore.StoreBlob.\n\t//   d. Optionally, update a progress bar for the user.\n\t// TODO 6: Create and return an image.Image struct populated with the manifest data and local layer paths.\n\treturn nil, nil\n}\n\n// CreateContainerFromImage creates a new container from a locally stored image.\n// It performs all isolation setup but does not start the process.\nfunc (r *ContainerRuntime) CreateContainerFromImage(imageName string, userConfig ContainerConfig) (*Container, error) {\n\t// TODO 1: Look up the image by name in the ImageStore. If not found, return error (or pull?).\n\t// TODO 2: Merge the image's configuration (ImageConfig) with the user's ContainerConfig.\n\t//         Rules: user-specified Cmd overrides image's Entrypoint+Cmd; user Env extends image Env.\n\t// TODO 3: Generate a unique container ID (e.g., using uuid.Generate()).\n\t// TODO 4: Create a Container struct with the merged config, ID, and state StateCreated.\n\t// TODO 5: Call FilesystemManager.SetupRootfs (which internally uses OverlayManager) to prepare the container's root filesystem.\n\t// TODO 6: Create namespaces for the container (using NamespaceManager.CreateNamespaces). This may involve forking a child process that pauses.\n\t// TODO 7: Create cgroups for the container and apply resource limits (CgroupManager.CreateGroup, SetLimits).\n\t// TODO 8: Setup network namespace (NetworkManager.SetupNetwork) if network mode is not \"none\".\n\t// TODO 9: Save the container state to ContainerStore (ContainerStore.Save).\n\t// TODO 10: Return the created Container object.\n\treturn nil, nil\n}\n```\n\n**File: `internal/cli/commands.go`**\n```go\npackage cli\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"yourproject/internal/runtime\"\n)\n\n// RunCommand handles `byod run <image> [command...]`\nfunc RunCommand(r *runtime.ContainerRuntime, imageRef string, userCmd []string) error {\n\t// TODO 1: Check if image exists locally; if not, call runtime.PullImage to download it.\n\t// TODO 2: Create a ContainerConfig, populating Cmd with userCmd (if provided), and other defaults.\n\t// TODO 3: Call runtime.CreateContainerFromImage to create a container in StateCreated.\n\t// TODO 4: Call runtime.StartContainer to start the container process (which will transition to StateRunning).\n\t// TODO 5: If the run is detached (--detach flag), print the container ID and return.\n\t// TODO 6: If attached (foreground), wait for the container process to exit (by monitoring its PID).\n\t// TODO 7: After the process exits, call runtime.StopContainer to transition to StateStopped.\n\t// TODO 8: Optionally, remove the container automatically if --rm flag is set.\n\treturn nil\n}\n\n// StartCommand handles `byod start <container-id>`\nfunc StartCommand(r *runtime.ContainerRuntime, containerID string) error {\n\t// TODO 1: Load the container from ContainerStore by ID.\n\t// TODO 2: Validate that the container state is StateCreated (or StateStopped if we support restart).\n\t// TODO 3: Call runtime.StartContainer.\n\t// TODO 4: If attached, wait for the process and then update state to StateStopped.\n\treturn nil\n}\n\n// StopCommand handles `byod stop <container-id>`\nfunc StopCommand(r *runtime.ContainerRuntime, containerID string, force bool) error {\n\t// TODO 1: Load the container from ContainerStore.\n\t// TODO 2: Validate state is StateRunning (or StatePaused).\n\t// TODO 3: If force is true, send SIGKILL to the container's init process. Otherwise, send SIGTERM, wait, then SIGKILL.\n\t// TODO 4: Call runtime.StopContainer to update state to StateStopped.\n\treturn nil\n}\n\n// RemoveCommand handles `byod rm <container-id>`\nfunc RemoveCommand(r *runtime.ContainerRuntime, containerID string) error {\n\t// TODO 1: Load the container.\n\t// TODO 2: Validate state is StateStopped (cannot remove running containers).\n\t// TODO 3: Call runtime.RemoveContainer which will:\n\t//   a. Clean up network resources (NetworkManager.CleanupNetwork).\n\t//   b. Remove cgroups (CgroupManager.RemoveCgroup).\n\t//   c. Unmount and clean up the root filesystem (FilesystemManager.CleanupFilesystem).\n\t//   d. Delete the container from ContainerStore.\n\t// TODO 4: If successful, print confirmation.\n\treturn nil\n}\n```\n\n#### E. Language-Specific Hints\n\n1.  **Go's `net/http` for Registry Client**: Use `http.Client` with a custom `Transport` if you need to add authentication headers globally. Remember to close response bodies (`defer resp.Body.Close()`). For downloading large layers, consider using `io.Copy` with a buffer to provide progress updates.\n\n2.  **JSON Parsing**: Use `encoding/json` with struct tags that match the OCI spec field names. You can generate Go structs from the OCI JSON schema using tools like `quicktype`. For flexibility with unknown fields, use `json.RawMessage` for parts you don't need to parse immediately.\n\n3.  **Concurrent Layer Downloads**: To speed up image pull, you can download multiple layers concurrently using goroutines and a `sync.WaitGroup`. Be mindful of registry rate limits. Use a semaphore pattern (buffered channel) to limit concurrency.\n\n4.  **CLI Flag Parsing**: The standard `flag` package supports subcommands via `flag.NewFlagSet`. For a more structured CLI, consider using `cobra`. Remember to define persistent flags (like `--storage-path`) and local flags for each command.\n\n5.  **State Machine Implementation**: Implement the container state transitions as methods on `Container` or `ContainerRuntime`. Use a `sync.Mutex` to protect state changes if the CLI could be called concurrently (e.g., from multiple terminals). The state should be persisted after each transition.\n\n6.  **Error Handling**: Use Go's error wrapping with `fmt.Errorf(\"... %w\", err)`. Provide meaningful error messages to the user (e.g., \"image 'foo:latest' not found locally and pulling from registry failed: connection refused\").\n\n#### F. Milestone Checkpoint\n\nAfter implementing Milestone 6, you should be able to perform the following workflow:\n\n1.  **Pull an image**: `sudo ./byod pull alpine:latest`\n    - **Expected**: Output showing layer download progress (e.g., \"Layer sha256:abc... downloaded\"). The image should be stored in the configured storage directory (e.g., `/var/lib/byod/images`).\n    - **Verification**: Check `ls -la /var/lib/byod/images/blobs/sha256/` to see downloaded layer files.\n\n2.  **Run a container**: `sudo ./byod run alpine:latest echo \"hello world\"`\n    - **Expected**: The command outputs \"hello world\" and exits. The container should be created, started, execute the command, stop, and (if `--rm` is used) be removed.\n    - **Verification**: Use `./byod ps -a` to see the container (if not removed) in `Stopped` state.\n\n3.  **Run a detached container**: `sudo ./byod run -d --name myapp nginx:alpine`\n    - **Expected**: Prints a container ID. The container stays running in the background.\n    - **Verification**: `./byod ps` shows the container in `Running` state. `curl http://<container-ip>` should return the nginx welcome page (if networking is set up).\n\n4.  **Container lifecycle**: `sudo ./byod stop myapp`, then `sudo ./byod rm myapp`\n    - **Expected**: `stop` terminates the container, `rm` removes it.\n    - **Verification**: `./byod ps -a` no longer lists the container. Check that the container's rootfs directory and cgroup are cleaned up.\n\n**Signs something is wrong:**\n- **\"manifest unknown\" error**: Likely an incorrect image reference format or registry authentication issue. Verify the image exists on Docker Hub.\n- **Container exits immediately with code 127**: The `Entrypoint` or `Cmd` binary not found in the image. Check that the image config was parsed correctly and the rootfs was set up properly.\n- **Resource leaks (cgroups, mounts) after `rm`**: The `RemoveContainer` method is not cleaning up all resources. Add logging to each cleanup step and verify they are called.\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n| :--- | :--- | :--- | :--- |\n| **Pull fails with \"unauthorized\"** | Registry requires authentication, even for public images. | Check the `WWW-Authenticate` header in the HTTP response. | Implement token authentication: request a token from the auth service URL, then retry the request with `Authorization: Bearer <token>`. |\n| **Container runs but cannot resolve DNS** | `/etc/resolv.conf` is not set up inside the container. | `cat` the container's rootfs `/etc/resolv.conf`; it may be empty or missing. | Copy the host's `/etc/resolv.conf` into the container rootfs during filesystem setup, or bind-mount it. |\n| **`byod ps` shows empty list** | Container state is not being persisted to disk. | Check the storage directory for container config JSON files. | Ensure `ContainerStore.Save` is called after creating/updating a container, and that it writes valid JSON. |\n| **Image layers are re-downloaded every time** | Layer cache is not being checked or used. | Check if `ImageStore.StoreBlob` is skipping already-existing blobs. | Implement a layer cache with reference counting. Before downloading, check if the blob file exists and matches the digest. |\n| **CLI command hangs after container start** | The parent process is waiting for the child but the child might have died. | Check the container's init process status with `ps aux \\| grep <container-pid>`. | Ensure the child process is correctly reparented to PID 1 after the parent exits. Use double-fork or proper signal handling. |\n\n\n> **Milestone(s):** All milestones (this section describes the dynamic interactions between components across the entire system)\n\n## Interactions and Data Flow\n\nThis section describes the dynamic orchestration between the architectural components defined in previous sections. While component design explains *what* each part does, interactions and data flow explain *how* and *when* they work together to achieve container lifecycle operations. Understanding these sequences is critical for implementing a cohesive runtime where isolation primitives are applied in the correct order with proper cleanup on failure.\n\n### Container Creation Sequence\n\nThe container creation sequence transforms a user's request (`container run`) into an isolated, resource-limited process with its own filesystem and network. Think of this as a **restaurant kitchen preparing a complex dish**: the chef (Container Manager) coordinates specialized stations (Namespace, Cgroup, Filesystem managers) in a precise sequence, where timing matters (network must be set up before the process starts, cgroups must be applied before the process forks). If any station fails, the entire order must be rolled back cleanly.\n\nThe complete sequence involves 8 major phases, with error handling and rollback at each step:\n\n1. **Request Validation and Preparation** (CLI → Container Manager)\n   - The CLI parses user command (image name, command, flags) into a `ContainerConfig`\n   - Container Manager validates the configuration (e.g., image exists locally, resource limits are sane)\n   - A unique `containerID` is generated (via `uuid.Generate()`)\n   - Container entry is created in `ContainerStore` with state `StateCreated`\n\n2. **Image Preparation** (Container Manager → Image Store → Filesystem Manager)\n   - If the specified image isn't locally available, trigger the image pull flow (described separately)\n   - `ImageStore` loads the `Image` object with its layers and configuration\n   - `FilesystemManager.SetupRootfs()` is called with the image and containerID\n     - This delegates to `OverlayManager` to create layered rootfs (Milestone 4)\n     - Returns path to the prepared root filesystem\n\n3. **Namespace Creation** (Container Manager → Namespace Manager)\n   - `NamespaceManager.CreateNamespaces()` is called with flags for `CLONE_NEWPID|CLONE_NEWUTS|CLONE_NEWNS|CLONE_NEWNET|CLONE_NEWIPC`\n   - The manager creates a new child process via `clone()` or `unshare()` with these namespace flags\n   - This child will eventually become the container's PID 1\n   - The function returns the host PID of this child process (still in a suspended state)\n\n4. **Cgroup Configuration** (Container Manager → Cgroup Manager)\n   - `CgroupManager.CreateGroup(containerID)` creates the cgroup hierarchy\n   - `CgroupManager.SetLimits(containerID, config.Limits)` writes memory, CPU, and PID limits to control files\n   - `CgroupManager.AddProcess(containerID, pid)` moves the child process (from step 3) into the cgroup\n   - This ensures resource limits are enforced from the moment the child process starts executing\n\n5. **Network Namespace Setup** (Container Manager → Network Manager)\n   - `NetworkManager.SetupNetwork()` is called with the path to the container's network namespace (`/proc/<pid>/ns/net`)\n   - Network Manager creates veth pair, attaches one end to bridge, configures IP addresses, sets up iptables rules\n   - This happens *outside* the container namespace but affects the namespace by moving interfaces into it\n   - Port forwarding rules are established if specified in `NetworkConfig`\n\n6. **Filesystem Isolation Finalization** (Container Manager → Filesystem Manager, inside the child process)\n   - The child process (still suspended) executes `ChildEntryPoint()` which calls:\n     - `FilesystemManager.IsolateFilesystem(rootfsPath)` to perform `pivot_root()` and mount `/proc`, `/sys`\n     - `syscall.Sethostname(config.Hostname)` to set UTS namespace hostname\n     - Environment variable setup and working directory change\n   - This happens *inside* the container's namespaces, so mount operations only affect the container\n\n7. **Process Execution** (Inside the child process)\n   - The child process performs `exec()` to replace itself with the container's entry point command\n   - Command is taken from `ImageConfig.Entrypoint` and `ImageConfig.Cmd`, overridden by user's `config.Cmd`\n   - The process becomes PID 1 in the container's PID namespace\n\n8. **State Transition and Monitoring** (Container Manager)\n   - Container state transitions from `StateCreated` to `StateRunning`\n   - `ContainerStore.Save()` persists the updated state\n   - Container Manager begins monitoring the container process (via `waitpid()` or cgroup notifications)\n   - On process exit, state transitions to `StateStopped` and cleanup is scheduled\n\nThe following table details the key interactions between components during container creation:\n\n| Step | Triggering Component | Target Component | Data Passed | Expected Outcome | Error Rollback |\n|------|----------------------|------------------|-------------|------------------|----------------|\n| 1. Validation | CLI | Container Manager | `ContainerConfig` | Validated config, generated containerID | Return error to user |\n| 2. Image Prep | Container Manager | Filesystem Manager | `Image`, containerID | Prepared rootfs path | Cleanup any extracted layers |\n| 3. Namespace | Container Manager | Namespace Manager | namespace flags | Child process PID | Kill child process if created |\n| 4. Cgroup | Container Manager | Cgroup Manager | containerID, `ResourceLimits` | Process in cgroup with limits | Remove cgroup hierarchy |\n| 5. Network | Container Manager | Network Manager | nsPath, `NetworkConfig` | Network namespace configured | Remove veth, iptables rules, release IP |\n| 6. Filesystem | Container Manager | Filesystem Manager | rootfsPath (inside child) | `pivot_root()` completed, mounts setup | Cannot rollback child - it exits with error |\n| 7. Execution | Child process | OS kernel | command, args, env | Container process running | Child exits with error code |\n| 8. Monitoring | Container Manager | Container Store | updated `Container` state | State saved as `StateRunning` | Revert to previous state |\n\n> **Key Insight:** The sequence must preserve the **principle of least privilege escalation** - once the child process enters the container's namespaces and drops privileges (if user namespaces are implemented), it should not perform operations requiring host root privileges. That's why network setup and cgroup configuration happen *outside* the container namespace before the child starts.\n\nThe state transitions during this sequence follow a strict state machine:\n\n![Container Lifecycle State Machine](./diagrams/container-lifecycle.svg)\n\nFor a visual representation of the component interactions, refer to the sequence diagram:\n\n![Container Creation Sequence Diagram](./diagrams/container-creation-sequence.svg)\n\n**Critical Error Handling Considerations:**\n- **Rollback must be comprehensive:** If network setup fails after cgroups are created, both must be cleaned up\n- **Orphan prevention:** If the Container Manager crashes mid-creation, restart should detect and clean up partially created resources (via containerID scanning)\n- **Atomic state transitions:** The `ContainerStore.Save()` operation should be atomic; partial writes could leave the container in an undefined state\n\n### Image Pull and Preparation Flow\n\nImage preparation is the process of transforming a named image reference (e.g., `ubuntu:latest`) into a ready-to-use root filesystem. Think of this as a **warehouse fulfillment system**: the clerk (Image Handler) receives an order, checks local inventory (layer cache), requests missing items from suppliers (registry), verifies shipments (digest validation), and assembles the complete package (layered rootfs) for the kitchen (container creation).\n\nThe flow involves both remote registry interaction and local filesystem operations:\n\n1. **Reference Parsing** (CLI → Registry Client)\n   - Parse `imageRef` (e.g., `docker.io/library/ubuntu:latest`) into registry URL, repository, and tag\n   - Default to `latest` tag if not specified\n   - Check local `ImageStore` for existing image with same digest\n\n2. **Manifest Fetching** (Registry Client → OCI Registry)\n   - `RegistryClient.PullManifest()` makes HTTP request to registry API\n   - For Docker Hub: `GET /v2/library/ubuntu/manifests/latest`\n   - Registry returns OCI manifest (JSON) with media type and layer digests\n   - Client verifies manifest structure and extracts layer descriptors\n\n3. **Layer Download and Verification** (Registry Client → Image Store, per layer)\n   - For each layer descriptor in the manifest:\n     - Check `LayerCache.IsLayerCached(digest)` - if present, skip download\n     - `RegistryClient.PullLayer()` downloads layer blob with progress reporting\n     - `ImageStore.StoreBlob()` saves with content-addressable naming (digest as filename)\n     - SHA256 verification ensures downloaded content matches digest\n     - Layer is marked as cached in `LayerCache.AddReference(digest)`\n\n4. **Image Configuration** (Registry Client → Image Store)\n   - Download image configuration blob (referenced in manifest)\n   - Parse into `ImageConfig` (entrypoint, env, working directory, etc.)\n   - Create and store complete `Image` object with references to all layers\n\n5. **Root Filesystem Preparation** (Container Manager → Filesystem Manager, on demand)\n   - When container creation requires the image, `FilesystemManager.SetupRootfs()` is called\n   - `OverlayManager.PrepareLayersForContainer()` assembles layers:\n     - Lower directories: all read-only layers in order (base → top)\n     - Upper directory: writable layer for this container\n     - Work directory: internal OverlayFS work area\n   - `OverlayManager.MountOverlay()` creates the merged view\n   - Returns path to merged directory ready for `pivot_root()`\n\nThe decision flow for image handling can be visualized:\n\n![Image Pull and Extraction Flowchart](./diagrams/image-pull-flowchart.svg)\n\nThe following table details the data transformations at each stage:\n\n| Stage | Input | Processing | Output | Storage Location |\n|-------|-------|------------|--------|------------------|\n| Reference Parsing | `\"ubuntu:latest\"` | Parse registry, repo, tag | `{Registry: \"docker.io\", Repository: \"library/ubuntu\", Tag: \"latest\"}` | In-memory struct |\n| Manifest Fetch | Repository, tag | HTTP GET to registry, parse JSON | `Manifest` with layer digests, config digest | `ImageStore` as blob (digest) |\n| Layer Download | Layer digest | HTTP GET blob, SHA256 verify | Compressed tar blob | `ImageStore/base/blobs/sha256/<digest>` |\n| Image Assembly | Manifest, all layers | Create `Image` with layer paths, config | Complete `Image` object | `ImageStore/index/<name>/image.json` |\n| Rootfs Prep | `Image`, containerID | OverlayFS mount with layers | Merged directory path | `OverlayManager` temporary mount |\n\n> **Critical Insight:** Image layers are **content-addressable** and **immutable**. The same layer digest (SHA256 of its content) will always produce identical files. This enables global deduplication: if two images share a base layer (e.g., `alpine` base), it's stored once and referenced by both images, significantly saving disk space.\n\n**Common Failure Modes and Recovery:**\n\n| Failure Mode | Detection | Recovery Strategy |\n|--------------|-----------|-------------------|\n| Network timeout during layer pull | HTTP client timeout | Retry with exponential backoff (max 3 attempts) |\n| Digest mismatch | SHA256 comparison fails | Delete corrupted blob, retry download |\n| Disk full during extraction | `io.ErrShortWrite` or `ENOSPC` | Clean up partial extraction, return error |\n| Registry authentication required | HTTP 401 Unauthorized | Prompt for credentials or use configured auth |\n| Manifest not found | HTTP 404 | Check tag exists, suggest alternative tags |\n\n**Optimization: Layer Caching Strategy**\n- **Reference counting:** `LayerCache` tracks how many images/containers use each layer\n- **LRU eviction:** When cache exceeds size limit, remove least recently used layers with zero references\n- **Shared layers:** Multiple containers from same image share the same read-only lower layers, with separate upper writable layers\n- **Concurrent pulls:** Download different layers in parallel, but serialize writes to same layer\n\n### Message and Configuration Formats\n\nThe container runtime uses three primary formats for communication: 1) **Internal Go structs** for component interaction, 2) **Persistent JSON files** for state and configuration storage, and 3) **External protocols** (OCI registry API) for image distribution. Understanding these formats is essential for implementing serialization, deserialization, and interoperability.\n\n#### Internal Component Communication\n\nComponents communicate through method calls with the structured types defined in the Data Model section. The following table summarizes key method signatures and their data flows:\n\n| Method | Calling Component | Target Component | Input Data | Output Data | Purpose |\n|--------|------------------|------------------|------------|-------------|---------|\n| `CreateContainer(config)` | CLI/User | Container Manager | `ContainerConfig` | `Container` | Initiate container creation |\n| `SetupRootfs(image, id)` | Container Manager | Filesystem Manager | `Image`, containerID | rootfs path (string) | Prepare container filesystem |\n| `CreateNamespaces(flags)` | Container Manager | Namespace Manager | namespace flags (int) | child PID (int) | Create isolated namespaces |\n| `SetupNetwork(nsPath, config)` | Container Manager | Network Manager | nsPath (string), `NetworkConfig` | error | Configure container networking |\n| `SetLimits(path, limits)` | Container Manager | Cgroup Manager | cgroup path (string), `ResourceLimits` | error | Apply resource constraints |\n| `PullManifest(imageRef, tag)` | Image Handler | Registry Client | image reference, tag | `Manifest`, digest | Fetch image metadata |\n| `StoreBlob(reader, digest)` | Registry Client | Image Store | io.Reader, expected digest | actual digest | Store and verify layer blob |\n\n**Method Invocation Patterns:**\n- **Synchronous blocking:** Most methods block until completion (network setup, filesystem mount)\n- **Error propagation:** All methods return `error`; callers must handle failures appropriately\n- **Context passing:** Some long operations (image pull) accept `context.Context` for cancellation\n\n#### Persistent Storage Formats\n\nThe runtime persists state in JSON files within the `CONTAINER_RUNTIME_ROOT` directory (typically `/var/lib/byd`). These files survive process restarts and enable recovery.\n\n**1. Container State File (`/containers/<id>/state.json`):**\n```json\n{\n  \"ID\": \"a1b2c3d4e5f6\",\n  \"Name\": \"my-ubuntu\",\n  \"State\": \"running\",\n  \"Config\": {\n    \"Image\": \"ubuntu:latest\",\n    \"Cmd\": [\"/bin/bash\"],\n    \"Env\": [\"PATH=/usr/bin\"],\n    \"WorkingDir\": \"/\",\n    \"Hostname\": \"mycontainer\",\n    \"Limits\": {\n      \"MemoryMB\": 100,\n      \"CPUShares\": 512,\n      \"PidsLimit\": 100\n    },\n    \"Network\": {\n      \"Mode\": \"bridge\",\n      \"BridgeName\": \"byd0\",\n      \"IPAddress\": \"10.0.0.2\",\n      \"PortMappings\": [\n        {\"HostPort\": 8080, \"ContainerPort\": 80, \"Protocol\": \"tcp\"}\n      ]\n    }\n  },\n  \"Pid\": 12345,\n  \"CreatedAt\": \"2023-10-01T12:00:00Z\"\n}\n```\n\n**2. Image Manifest File (`/images/<repo>/<tag>/manifest.json`):**\nThis follows the OCI Image Manifest Specification v1.0.2:\n\n| Field | Type | Description | Example |\n|-------|------|-------------|---------|\n| `schemaVersion` | int | OCI spec version | `2` |\n| `mediaType` | string | MIME type of manifest | `application/vnd.oci.image.manifest.v1+json` |\n| `config` | object | Descriptor for image config | `{\"mediaType\": \"...\", \"digest\": \"sha256:...\", \"size\": 1234}` |\n| `layers` | array | Array of layer descriptors | `[{\"mediaType\": \"...\", \"digest\": \"...\", \"size\": ...}]` |\n| `annotations` | object | Optional metadata | `{\"org.opencontainers.image.created\": \"2023-10-01\"}` |\n\n**3. Image Configuration (`/blobs/sha256/<digest>`):**\nThis is the OCI Image Configuration JSON, parsed into our `ImageConfig` struct:\n\n| Field | Type | Description | Maps to `ImageConfig` Field |\n|-------|------|-------------|-----------------------------|\n| `architecture` | string | Target CPU architecture | (Not directly used) |\n| `os` | string | Target OS | (Not directly used) |\n| `config.Entrypoint` | array | Default executable | `Entrypoint` |\n| `config.Cmd` | array | Default arguments | `Cmd` |\n| `config.Env` | array | Environment variables | `Env` |\n| `config.WorkingDir` | string | Working directory | `WorkingDir` |\n| `rootfs.diff_ids` | array | Layer digests (uncompressed) | Used for layer verification |\n\n#### External Protocol: OCI Registry API\n\nThe runtime communicates with OCI/Docker registries using the Distribution Specification API:\n\n**Registry Endpoints:**\n- `GET /v2/` - Registry version check\n- `GET /v2/<name>/manifests/<reference>` - Fetch manifest (reference can be tag or digest)\n- `GET /v2/<name>/blobs/<digest>` - Fetch layer/blob content\n- `HEAD /v2/<name>/blobs/<digest>` - Check if blob exists (layer cache validation)\n\n**HTTP Headers for Content Negotiation:**\n- `Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json`\n- `Authorization: Bearer <token>` (for authenticated registries)\n- `Docker-Content-Digest: sha256:...` (in responses, for verification)\n\n**Authentication Flow:**\n1. Initial request often returns `401 Unauthorized` with `WWW-Authenticate` header\n2. Parse header for realm, service, scope\n3. Request bearer token from authentication server\n4. Retry original request with `Authorization: Bearer <token>`\n\n**Message Flow Example (Pull Manifest):**\n```\nClient → GET /v2/library/ubuntu/manifests/latest\nRegistry → 200 OK\n            Content-Type: application/vnd.oci.image.manifest.v1+json\n            Docker-Content-Digest: sha256:abc123...\n            \n            {\n              \"schemaVersion\": 2,\n              \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n              \"config\": {\"digest\": \"sha256:def456...\", \"size\": 1234},\n              \"layers\": [\n                {\"digest\": \"sha256:layer1...\", \"size\": 567890}\n              ]\n            }\n```\n\n#### Configuration Inheritance and Overrides\n\nThe runtime merges configuration from multiple sources with clear precedence:\n\n1. **Base Image Configuration** (`ImageConfig` from OCI image) - Lowest priority\n2. **Container Defaults** (runtime defaults for security, resources) - Medium priority  \n3. **User Configuration** (`ContainerConfig` from CLI/flags) - Highest priority\n4. **Runtime Enforcement** (security hardening, required mounts) - Overrides all\n\nExample merge for command execution:\n- Image defines: `Entrypoint: [\"/bin/sh\"]`, `Cmd: [\"-c\", \"echo hello\"]`\n- User provides: `Cmd: [\"/bin/bash\"]`\n- Result: `[\"/bin/sh\", \"/bin/bash\"]` (Docker behavior: user `Cmd` replaces image `Cmd`, not `Entrypoint`)\n\nThe configuration resolution is implemented in `ContainerRuntime.CreateContainerFromImage()`:\n\n```go\n// Pseudo-code for configuration merging\nfunc mergeConfig(imageConfig ImageConfig, userConfig ContainerConfig) ContainerConfig {\n    result := ContainerConfig{}\n    \n    // Command: user Cmd overrides image Cmd, but Entrypoint from image unless user specifies\n    if len(userConfig.Cmd) > 0 {\n        result.Cmd = userConfig.Cmd\n        // Keep image Entrypoint unless user provided both\n    } else {\n        result.Cmd = imageConfig.Cmd\n    }\n    \n    // Environment: merge with user values overriding image values\n    result.Env = mergeEnv(imageConfig.Env, userConfig.Env)\n    \n    // Working directory: user overrides image\n    if userConfig.WorkingDir != \"\" {\n        result.WorkingDir = userConfig.WorkingDir\n    } else {\n        result.WorkingDir = imageConfig.WorkingDir\n    }\n    \n    return result\n}\n```\n\n#### Inter-Process Communication\n\nFor the parent-child coordination during container creation, the runtime uses:\n\n1. **`/proc/self/exe` re-execution:** The parent re-executes itself with a `--child` flag and the containerID\n2. **Environment variables:** Parent passes configuration via `BYD_CONTAINER_ID`, `BYD_ROOTFS_PATH`\n3. **File descriptors:** Network namespace path, cgroup directories can be passed via inherited FDs\n4. **Signals:** Parent monitors child via `SIGCHLD`, sends `SIGTERM`/`SIGKILL` for stop operations\n\nThis IPC approach avoids complex serialization and maintains simplicity while crossing privilege boundaries.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Component Communication | Direct method calls (in-process) | gRPC with Protocol Buffers (for daemon mode) |\n| Persistent Storage | JSON files with `encoding/json` | SQLite database with migrations |\n| Registry Protocol | HTTP/1.1 with net/http | HTTP/2 with connection pooling, parallel downloads |\n| Configuration Merging | Manual field-by-field merging | JSON Merge Patch (RFC 7396) or strategic merge |\n\n**B. Recommended File/Module Structure:**\n\n```\nbyd/                           # Project root\n├── cmd/\n│   └── byd/                   # CLI entry point\n│       └── main.go\n├── internal/\n│   ├── runtime/               # Container Manager component\n│   │   ├── runtime.go         # ContainerRuntime type and main logic\n│   │   ├── state_manager.go   # Container state transitions\n│   │   └── sequence.go        # Container creation sequence (this section)\n│   ├── store/                 # Persistent storage\n│   │   ├── container_store.go # ContainerStore implementation\n│   │   ├── image_store.go     # ImageStore implementation\n│   │   └── layer_cache.go     # LayerCache implementation\n│   ├── images/                # Image handling (Milestone 6)\n│   │   ├── registry.go        # RegistryClient\n│   │   ├── oci_parser.go      # OCI manifest/config parsing\n│   │   └── pull_sequence.go   # Image pull flow\n│   └── utils/\n│       └── uuid.go            # ID generation helpers\n└── pkg/                       # Public API (if needed)\n    └── types/\n        └── types.go           # All data model structs\n```\n\n**C. Infrastructure Starter Code:**\n\n**Complete UUID Generator (`pkg/utils/uuid.go`):**\n```go\npackage utils\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar (\n\tmu        sync.Mutex\n\tshortID   string\n\tshortOnce sync.Once\n)\n\n// Generate creates a random 128-bit hex ID (32 characters)\nfunc Generate() (string, error) {\n\tbytes := make([]byte, 16)\n\tif _, err := rand.Read(bytes); err != nil {\n\t\treturn \"\", fmt.Errorf(\"generate uuid: %w\", err)\n\t}\n\treturn hex.EncodeToString(bytes), nil\n}\n\n// Short generates a random 64-bit hex ID (16 characters) with caching\nfunc Short() string {\n\tshortOnce.Do(func() {\n\t\tbytes := make([]byte, 8)\n\t\tif _, err := rand.Read(bytes); err != nil {\n\t\t\t// Fallback to timestamp-based ID if crypto fails\n\t\t\tshortID = fmt.Sprintf(\"%x\", time.Now().UnixNano())\n\t\t\treturn\n\t\t}\n\t\tshortID = hex.EncodeToString(bytes)\n\t})\n\treturn shortID\n}\n```\n\n**Container State Manager (`internal/runtime/state_manager.go`):**\n```go\npackage runtime\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\t\n\t\"byd/pkg/types\"\n)\n\ntype StateManager struct {\n\tmu         sync.RWMutex\n\tcontainers map[string]*types.Container\n\tstore      ContainerStore\n}\n\nfunc NewStateManager(storePath string) (*StateManager, error) {\n\tstore, err := NewContainerStore(storePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create state manager: %w\", err)\n\t}\n\t\n\t// Load existing containers from disk\n\tcontainers := make(map[string]*types.Container)\n\t// Implementation: scan store directory, load each container\n\t\n\treturn &StateManager{\n\t\tcontainers: containers,\n\t\tstore:      store,\n\t}, nil\n}\n\n// Transition validates and executes state changes\nfunc (sm *StateManager) Transition(containerID string, \n\t\tfromState, toState types.ContainerState) error {\n\tsm.mu.Lock()\n\tdefer sm.mu.Unlock()\n\t\n\tcontainer, exists := sm.containers[containerID]\n\tif !exists {\n\t\treturn fmt.Errorf(\"container %s not found\", containerID)\n\t}\n\t\n\tif container.State != fromState {\n\t\treturn fmt.Errorf(\"invalid state transition: current %s, expected %s\", \n\t\t\tcontainer.State, fromState)\n\t}\n\t\n\t// Validate transition\n\tif !isValidTransition(fromState, toState) {\n\t\treturn fmt.Errorf(\"invalid transition from %s to %s\", fromState, toState)\n\t}\n\t\n\t// Update state\n\tcontainer.State = toState\n\tif toState == types.StateRunning {\n\t\t// Set started timestamp if needed\n\t}\n\t\n\t// Persist\n\tif err := sm.store.Save(container); err != nil {\n\t\t// Revert in-memory state on persistence failure\n\t\tcontainer.State = fromState\n\t\treturn fmt.Errorf(\"save container state: %w\", err)\n\t}\n\t\n\treturn nil\n}\n\nfunc isValidTransition(from, to types.ContainerState) bool {\n\t// Define valid transitions based on state machine diagram\n\ttransitions := map[types.ContainerState][]types.ContainerState{\n\t\ttypes.StateCreated:  {types.StateRunning, types.StateStopped},\n\t\ttypes.StateRunning:  {types.StatePaused, types.StateStopped},\n\t\ttypes.StatePaused:   {types.StateRunning, types.StateStopped},\n\t\ttypes.StateStopped:  {types.StateRemoved},\n\t\ttypes.StateRemoved:  {}, // Terminal state\n\t}\n\t\n\tfor _, validTo := range transitions[from] {\n\t\tif validTo == to {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n```\n\n**D. Core Logic Skeleton Code:**\n\n**Container Creation Sequence (`internal/runtime/sequence.go`):**\n```go\npackage runtime\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\n\t\"byd/pkg/types\"\n)\n\n// createContainerSequence orchestrates the 8-phase container creation\n// Returns the created Container and any error encountered\nfunc (cr *ContainerRuntime) createContainerSequence(\n\tconfig types.ContainerConfig, \n\tname string) (*types.Container, error) {\n\t\n\t// Phase 1: Validation and Preparation\n\t// TODO 1: Validate config fields (image exists, limits positive, etc.)\n\t// TODO 2: Generate containerID using utils.Generate()\n\t// TODO 3: Create container entry with StateCreated\n\t// TODO 4: Save to ContainerStore\n\t\n\t// Phase 2: Image Preparation  \n\t// TODO 5: Check if image exists locally via ImageStore\n\t// TODO 6: If not, call cr.PullImage() (this may be long-running)\n\t// TODO 7: Load Image object from store\n\t// TODO 8: Call FilesystemManager.SetupRootfs() to prepare root filesystem\n\t\n\t// Phase 3: Namespace Creation\n\t// TODO 9: Determine namespace flags from config (PID, UTS, mount, network, IPC)\n\t// TODO 10: Call NamespaceManager.CreateNamespaces() with flags\n\t// TODO 11: Capture returned child PID\n\t\n\t// Phase 4: Cgroup Configuration\n\t// TODO 12: Call CgroupManager.CreateGroup() with containerID\n\t// TODO 13: Call CgroupManager.SetLimits() with config.Limits\n\t// TODO 14: Call CgroupManager.AddProcess() to move child PID into cgroup\n\t\n\t// Phase 5: Network Setup\n\t// TODO 15: Construct network namespace path: fmt.Sprintf(\"/proc/%d/ns/net\", childPID)\n\t// TODO 16: Call NetworkManager.SetupNetwork() with nsPath and config.Network\n\t// TODO 17: Handle error - if fails, roll back previous phases\n\t\n\t// Phase 6: Filesystem Isolation (inside child)\n\t// This is handled by the child process via ChildEntryPoint\n\t// The parent just waits for child to signal ready or error\n\t\n\t// Phase 7: Process Execution (inside child)\n\t// Handled by ChildEntryPoint which calls exec()\n\t\n\t// Phase 8: State Transition\n\t// TODO 18: Update container state to StateRunning\n\t// TODO 19: Set container.Pid = childPID\n\t// TODO 20: Save updated container to store\n\t// TODO 21: Start monitoring goroutine for container exit\n\t\n\t// Error handling: implement rollback for each phase\n\t// Use defer with named return values to track if sequence succeeded\n\t\n\treturn nil, fmt.Errorf(\"not implemented\")\n}\n\n// ChildEntryPoint is the function executed inside the new namespaces\n// It's called via re-execution of the binary with --child flag\nfunc ChildEntryPoint() int {\n\t// TODO 1: Parse containerID from environment (BYD_CONTAINER_ID)\n\t// TODO 2: Load container from store\n\t// TODO 3: Call FilesystemManager.IsolateFilesystem() with container's rootfs\n\t// TODO 4: Set hostname using syscall.Sethostname()\n\t// TODO 5: Set up environment variables from container.Config.Env\n\t// TODO 6: Change working directory to container.Config.WorkingDir\n\t// TODO 7: Determine command to execute (merge image and user config)\n\t// TODO 8: Perform syscall.Exec() to replace this process with container command\n\t// TODO 9: If exec fails, exit with error code; otherwise never returns\n\t\n\treturn 1 // Error exit if we reach here\n}\n```\n\n**Image Pull Sequence (`internal/images/pull_sequence.go`):**\n```go\npackage images\n\n// PullImage orchestrates downloading an image from registry\nfunc (ih *ImageHandler) PullImage(imageRef string) (*types.Image, error) {\n\t// TODO 1: Parse image reference into registry, repository, tag\n\t// TODO 2: Check local cache for existing image with same digest\n\t// TODO 3: Fetch manifest from registry using RegistryClient.PullManifest()\n\t// TODO 4: Verify manifest structure and media type\n\t// TODO 5: For each layer in manifest.Layers:\n\t//   TODO 5a: Check LayerCache for existing layer with same digest\n\t//   TODO 5b: If not cached, download using RegistryClient.PullLayer()\n\t//   TODO 5c: Verify SHA256 digest matches\n\t//   TODO 5d: Store blob in ImageStore.StoreBlob()\n\t//   TODO 5e: Add to LayerCache with AddReference()\n\t// TODO 6: Download image configuration blob\n\t// TODO 7: Parse into ImageConfig struct\n\t// TODO 8: Create Image object with all layers and config\n\t// TODO 9: Store image in ImageStore with tag reference\n\t// TODO 10: Return complete Image object\n\t\n\treturn nil, fmt.Errorf(\"not implemented\")\n}\n```\n\n**E. Language-Specific Hints:**\n- **Go concurrency:** Use goroutines for parallel layer downloads but limit concurrency with a worker pool\n- **Error wrapping:** Use `fmt.Errorf(\"step: %w\", err)` for error chains that show the sequence of failures\n- **JSON serialization:** Use struct tags: `` `json:\"fieldName,omitempty\"` `` for proper serialization\n- **File locking:** Use `flock` or directory-based locking for atomic operations on container state\n- **Context propagation:** Pass `context.Context` through long operations (network downloads) for cancellation\n- **Cleanup with defer:** Structure functions with `defer cleanup()` pattern, but be careful with early returns\n\n**F. Milestone Checkpoint:**\nAfter implementing the container creation sequence, verify with:\n```bash\n# Build and test\ngo build ./cmd/byd\nsudo ./byd run --rm alpine:latest echo \"Hello from container\"\n\n# Expected behavior:\n# 1. Downloads alpine image (if first time)\n# 2. Creates container with isolated namespaces\n# 3. Runs echo command\n# 4. Prints \"Hello from container\"\n# 5. Container exits and is cleaned up (due to --rm)\n\n# Verification commands:\nps aux | grep byd          # Should show only the byd process, not container processes\nls /sys/fs/cgroup/         # Should see byd-* cgroups created and cleaned up\nip link show               # Should see veth interfaces created and removed\n```\n\n**G. Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Container exits immediately with code 1 | `exec()` failure in child | Check child logs, verify binary exists in rootfs | Ensure rootfs has the executable at correct path |\n| Network setup fails with \"device busy\" | veth interface already exists | `ip link show` to see conflicting names | Use unique interface names, clean up old interfaces |\n| Cgroup limits not enforced | Process not in cgroup | Check `/proc/<pid>/cgroup` file | Ensure `AddProcess()` is called before process starts |\n| Rootfs appears empty after mount | OverlayFS mount failed | Check `dmesg` for overlay errors | Verify lowerdir paths exist, work dir is empty |\n| Registry pull returns 404 | Invalid image reference | Check registry API response | Use full image name: `docker.io/library/alpine:latest` |\n| State file corruption | Concurrent writes to same file | Check file timestamps, use file locking | Implement atomic writes (write to temp, then rename) |\n\n\n## Error Handling and Edge Cases\n> **Milestone(s):** All milestones (error handling and edge cases are relevant throughout the entire system, from low-level system calls to high-level user operations)\n\nThis section defines the comprehensive error handling philosophy and edge case management strategy for the container runtime. Unlike application-level software that can often rely on the operating system to clean up after failures, container runtimes operate at the system level where partial failures can leave resources (namespaces, cgroups, mounts, network interfaces) orphaned and system state inconsistent. The key architectural challenge is designing **idempotent, atomic, and recoverable operations** despite the inherent statefulness of Linux kernel primitives.\n\n### Common Failure Modes and Detection\n\nContainer runtime failures can be categorized by their **origin layer**: kernel/system call failures, resource exhaustion, user configuration errors, race conditions, and external dependencies. Each category requires distinct detection strategies.\n\n> **Design Insight**: The runtime must assume that any operation can fail at any point, and the failure detection must be **immediate and precise**. Delayed or vague error detection leads to resource leaks and security vulnerabilities.\n\n#### System Call and Kernel Interface Failures\n\nThese are the most fundamental failures, occurring when Linux kernel interfaces reject our requests due to permissions, invalid arguments, or resource constraints.\n\n| Failure Mode | Detection Strategy | Impact |\n|--------------|-------------------|--------|\n| **Namespace creation failure** (`clone()`, `unshare()` returns -1) | Check `errno` after syscall: `EPERM` (no privileges), `EINVAL` (invalid flags), `ENOMEM` (kernel memory) | Container cannot start; partial isolation may leave process in host namespace |\n| **cgroup filesystem operations fail** (`mkdir`, `write` to control files) | Check file operation errors: `EACCES` (permissions), `ENOSPC` (device full), `EROFS` (read-only) | Resource limits not applied; container may consume unbounded resources |\n| **Mount operations fail** (`mount()`, `pivot_root()`, `umount()`) | Check mount return value and `errno`: `EINVAL` (invalid option), `EPERM` (no CAP_SYS_ADMIN), `EBUSY` (busy mount) | Filesystem isolation incomplete; container may access host filesystem |\n| **Network namespace operations fail** (`socket()`, `ioctl()`, netlink errors) | Check network syscall returns and netlink error codes | Network connectivity broken; container may be unreachable or have incorrect routing |\n| **Process execution fails** (`execve()` returns -1) | Check `errno`: `ENOENT` (binary not found), `EACCES` (permission denied), `ENOTDIR` (path component not directory) | Container starts but immediately exits; init process fails |\n\n**Detection Implementation**: Each component manager (`NamespaceManager`, `CgroupManager`, `FilesystemManager`, `NetworkManager`) must wrap system calls with explicit error checking that preserves the original `errno` value. The Go standard library's `syscall` package returns error types that include the raw errno, which should be inspected for precise diagnosis.\n\n#### Resource Exhaustion Failures\n\nThe runtime itself, or containers it manages, can exhaust system resources. These failures often manifest as \"soft\" failures where operations succeed but with degraded performance, eventually leading to \"hard\" failures.\n\n| Failure Mode | Detection Strategy | Impact |\n|--------------|-------------------|--------|\n| **Memory exhaustion during image extraction** | Monitor `extractLayer` for `ENOSPC` on disk write or `ENOMEM` when decompressing | Partial layer extraction; incomplete root filesystem |\n| **Inode or file descriptor exhaustion** | Check for `EMFILE` (process FD limit) or `ENFILE` (system FD limit) | Cannot create pipes, sockets, or open files; runtime becomes inoperable |\n| **PID exhaustion in cgroup** | Monitor `fork()`/`clone()` for `EAGAIN` when cgroup pids.max reached | Cannot create new processes in container; fork bombs partially contained |\n| **IP address pool exhaustion** | `IPAM.Allocate()` returns error when subnet exhausted | Container cannot get network connectivity; start fails |\n| **Disk space for upper layer (OverlayFS)** | Write to upper layer fails with `ENOSPC` | Container filesystem becomes read-only; writes fail |\n\n**Detection Implementation**: Proactive monitoring is better than reactive failure. The runtime should check resource availability before operations: `CgroupManager` should read cgroup limits and current usage before container start; `IPAM` should track free addresses; `FilesystemManager` should check available disk space in storage directories.\n\n#### User Configuration and Input Errors\n\nThese failures stem from invalid user input, misconfigured images, or incompatible system configurations.\n\n| Failure Mode | Detection Strategy | Impact |\n|--------------|-------------------|--------|\n| **Invalid image reference format** | Parse image reference with OCI distribution spec regex | Cannot pull image; operation fails early |\n| **Missing or malformed OCI manifest** | Validate JSON schema, required fields, and layer digests | Image cannot be used; rootfs cannot be constructed |\n| **Invalid resource limits** (negative memory, zero CPU shares) | Validate `ResourceLimits` fields with range checks | cgroup setup fails or applies incorrect limits |\n| **Conflicting port mappings** | Check `PortMappings` for duplicate `HostPort` values | Network setup fails or creates conflicting iptables rules |\n| **Missing capabilities for requested isolation** | Check `CAP_SYS_ADMIN`, `CAP_NET_ADMIN`, etc. at runtime start | Namespace creation fails with `EPERM` |\n\n**Detection Implementation**: Comprehensive validation at API boundaries. The `ContainerRuntime.CreateContainer` method should validate all fields of `ContainerConfig` before any side effects. Image validation should occur during `ImageStore.StoreManifest` and layer extraction.\n\n#### Race Conditions and State Inconsistencies\n\nConcurrent operations or unexpected external state changes can cause failures even when individual operations succeed.\n\n| Failure Mode | Detection Strategy | Impact |\n|--------------|-------------------|--------|\n| **Container already running when start attempted** | Check `Container.State` in `StateManager.Transition()` | State transition rejected; prevents double execution |\n| **Container removed while being stopped** | Check container exists after acquiring lock | Orphaned resources; potential use-after-free |\n| **Network namespace deleted by OS before cleanup** | Check `/proc/self/ns/net` existence before join | Runtime crash when trying to operate on non-existent namespace |\n| **Image layer garbage collected while container running** | Reference counting in `LayerCache` prevents deletion | Container rootfs becomes broken; read operations fail |\n| **cgroup directory removed externally** | Stat cgroup path before writing control files | Resource limits lost; process escapes constraints |\n\n**Detection Implementation**: State must be protected by synchronization primitives. The `StateManager` uses `sync.RWMutex` to serialize state transitions. Resource managers should verify resource existence before operations (defensive programming). Reference counting (`LayerCache.AddReference/ReleaseReference`) prevents premature deletion of shared resources.\n\n#### External Dependency Failures\n\nThe runtime depends on external systems (Docker registry, DNS, internet connectivity) that may be unavailable.\n\n| Failure Mode | Detection Strategy | Impact |\n|--------------|-------------------|--------|\n| **Registry authentication failure** | HTTP 401/403 from registry API | Cannot pull private images |\n| **Registry network timeout** | HTTP client timeout with context deadline | Image pull hangs or fails after retries |\n| **DNS resolution failure during network setup** | `resolv.conf` creation fails if nameservers unreachable | Container has network but cannot resolve hostnames |\n| **iptables lock contention or missing modules** | Check `iptables` command exit code | NAT or port forwarding not configured |\n| **OverlayFS kernel module not loaded** | Check `/proc/filesystems` for overlay entry | Layered filesystem unavailable; must fall back to plain directory |\n\n**Detection Implementation**: Network operations should use contexts with timeouts. Registry client should implement exponential backoff for transient failures. System dependency checks should occur at runtime initialization (`NewContainerRuntime` should validate kernel features and available commands).\n\n### Recovery and Cleanup Strategies\n\nThe container runtime must implement **compensating transactions**—for every operation that modifies system state, there must be a corresponding cleanup operation that can be executed even after partial failures. The strategy follows a **cleanup stack** pattern where operations push cleanup functions onto a stack as they succeed, and failures unwind the stack.\n\n#### State-Driven Cleanup Orchestration\n\nEach container has a well-defined state machine (`ContainerState`: `Created`, `Running`, `Paused`, `Stopped`, `Removed`). The cleanup strategy differs by which state transition fails:\n\n| Failed Transition | Cleanup Strategy | Rollback Actions |\n|-------------------|------------------|------------------|\n| **Nothing → Created** (container creation fails) | Delete all allocated resources | 1. Delete cgroup directory<br>2. Delete container metadata from `ContainerStore`<br>3. Release IP address from `IPAM` |\n| **Created → Running** (start fails) | Roll back to `Created` state, keep resources allocated | 1. Kill any partially started process<br>2. Leave namespaces, cgroups, network intact for retry<br>3. Unmount any temporary mounts (e.g., /proc in wrong namespace) |\n| **Running → Stopped** (stop fails or timeout) | Force kill with SIGKILL, then cleanup | 1. Send SIGKILL to container process tree<br>2. Wait for process termination<br>3. Perform full cleanup as if stop succeeded |\n| **Stopped → Removed** (remove fails) | Retry with more aggressive cleanup | 1. Force unmount lingering mounts (MNT_DETACH)<br>2. Force delete cgroup directory (write `cgroup.kill` for cgroup v2)<br>3. Force remove network namespace by killing processes inside |\n\n**Implementation Pattern**: The `createContainerSequence` function (from Milestone 6) should implement the cleanup stack:\n\n```go\n// Pseudo-code structure (actual code in Implementation Guidance)\nvar cleanupTasks []func()\ndefer func() {\n    if err != nil {\n        // Execute cleanup in reverse order (LIFO)\n        for i := len(cleanupTasks)-1; i >= 0; i-- {\n            cleanupTasks[i]()\n        }\n    }\n}()\n\n// Each successful operation pushes its cleanup\ncleanupTasks = append(cleanupTasks, func() { cgroupManager.RemoveCgroup(containerID) })\ncleanupTasks = append(cleanupTasks, func() { networkManager.CleanupNetwork(containerID, config) })\n// ... etc\n```\n\n#### Idempotent Cleanup Operations\n\nAll cleanup operations must be **idempotent**—calling them multiple times or calling them when resources no longer exist should not error. This property is crucial for recovery after crashes where the runtime doesn't know which cleanup operations have already completed.\n\n| Operation | Idempotent Implementation |\n|-----------|---------------------------|\n| **cgroup deletion** | Check if cgroup directory exists before removal; ignore `ENOENT` errors |\n| **network namespace cleanup** | Check if network namespace path exists; skip if already gone |\n| **mount unmounting** | Try unmount, ignore `EINVAL` (not mounted) and `ENOENT` (mount point gone) |\n| **IP address release** | `IPAM.Release` should check if IP was allocated; no-op if not in allocated map |\n| **filesystem cleanup** | `RemoveAll` on container directory, tolerate missing directories |\n\n**Rationale**: After a runtime crash and restart, the recovery routine will attempt to clean up all containers that were in progress. Idempotent cleanup ensures the system converges to a clean state regardless of how many times cleanup is attempted.\n\n#### Orphan Detection and Garbage Collection\n\nDespite best efforts, some resources may become orphaned (e.g., if runtime is SIGKILLed during namespace creation). The runtime must include a **garbage collection** system that runs at startup and periodically to reclaim lost resources.\n\n| Resource Type | Orphan Detection Method | Cleanup Action |\n|---------------|-------------------------|----------------|\n| **cgroups** | Scan cgroup filesystem for directories matching container ID pattern | Remove directory if no processes inside |\n| **network namespaces** | Scan `/var/run/netns` for namespaces not referenced by any container | Unlink namespace file (only removes reference, not namespace with processes) |\n| **mounts** | Parse `/proc/self/mountinfo` for mounts under runtime storage path | Unmount with `MNT_DETACH` flag |\n| **OverlayFS layers** | Scan layer cache for unreferenced layers | Delete layer directories after ensuring no containers reference them |\n| **veth interfaces** | Scan network interfaces for veth* interfaces not in any bridge | Delete interface with `ip link delete` |\n\n**Implementation Approach**: The `ContainerRuntime` should maintain a **reaper** goroutine that periodically scans for orphans. At startup, before any new container operations, the runtime should run a full garbage collection to clean up from previous crashes.\n\n#### Transaction Logging for Crash Recovery\n\nFor critical multi-step operations (like container creation), the runtime can write intentions to a **transaction log** before performing operations. If the runtime crashes mid-operation, upon restart it reads the log to know which operations were in progress and can complete or roll them back.\n\n| Operation Phase | Log Entry | Recovery Action |\n|-----------------|-----------|-----------------|\n| **Start container creation** | `{\"op\": \"create\", \"id\": \"abc\", \"state\": \"allocating\"}` | If found at recovery, container was being created; run cleanup |\n| **After cgroup created** | `{\"op\": \"create\", \"id\": \"abc\", \"state\": \"cgroup_created\"}` | Cleanup must remove cgroup |\n| **After network setup** | `{\"op\": \"create\", \"id\": \"abc\", \"state\": \"network_created\"}` | Cleanup must remove network resources |\n| **After rootfs prepared** | `{\"op\": \"create\", \"id\": \"abc\", \"state\": \"rootfs_ready\"}` | Cleanup must unmount rootfs |\n| **Completion** | Remove log entry | No recovery needed |\n\n**Trade-off**: While transaction logging provides robust recovery, it adds complexity. For this educational implementation, we opt for the simpler cleanup stack approach, noting that production systems would need transaction logging.\n\n### Edge Case Scenarios\n\nEdge cases represent unusual but possible situations that the runtime must handle gracefully. These often involve boundary conditions, unusual user behavior, or unexpected system configurations.\n\n#### Container Process Behavior Edge Cases\n\n| Scenario | Behavior | Handling Strategy |\n|----------|----------|-------------------|\n| **Container init process exits immediately** (echo \"hello\") | Container starts and stops within milliseconds | Runtime must still capture exit code, trigger cleanup, transition to `Stopped` state |\n| **Container process forks daemon children and exits** | PID 1 exits but other processes remain in namespace | Runtime should kill entire process tree when stopping container; use cgroup process tracking |\n| **Container process calls `unshare()` itself** | Nested namespaces inside container | Runtime's namespaces remain outer layer; child namespaces are container's business |\n| **Container process mounts /proc over container /proc** | Overwrites runtime's /proc mount | Runtime should mount /proc with `MS_PRIVATE` to prevent propagation, but cannot prevent container from remounting |\n| **Container process writes to /sys files that affect host** | e.g., writing to /sys/class/backlight | Runtime should mount /sys as read-only (`MS_RDONLY`) where possible |\n| **Container runs setuid binary that escapes namespace** | Without user namespace, setuid binaries run with host privileges | Consider implementing user namespace mapping (advanced) or warn users |\n\n**Implementation Guidance**: The runtime should place the container process in a cgroup and use the cgroup's process tracking to ensure all descendant processes are accounted for. When stopping, signal should be sent to the entire process tree (using negative PID to process group).\n\n#### Filesystem Edge Cases\n\n| Scenario | Behavior | Handling Strategy |\n|----------|----------|-------------------|\n| **Base image has broken symlinks** | Symlinks pointing outside rootfs or to non-existent files | Preserve symlinks as-is; container will get ENOENT when following |\n| **OverlayFS copy-up on directory rename** | Renaming a directory requires copying entire directory tree | Accept performance hit; OverlayFS handles this automatically |\n| **Multiple containers sharing same image layer** | Concurrent write to same file in shared layer | OverlayFS ensures each container gets its own copy in upper layer |\n| **Container writes to lower-layer whiteout file** | Writing to `.wh..wh..opq` or `.wh.<filename>` | OverlayFS prevents this; runtime doesn't need special handling |\n| **Rootfs contains mount points** (bind mounts in image) | These mounts propagate to container if not properly isolated | Runtime should ensure mount namespace is created before rootfs setup |\n| **/proc mounted but shows host processes** | Forgot to mount /proc after `CLONE_NEWPID` | Runtime must mount new /proc inside container after PID namespace creation |\n\n**Critical Insight**: The order of filesystem operations matters tremendously. The sequence must be: 1) Create mount namespace, 2) Mount rootfs, 3) Mount /proc, /sys, /dev, 4) `pivot_root()`, 5) Unmount old root. Deviations cause visibility of host processes or files.\n\n#### Networking Edge Cases\n\n| Scenario | Behavior | Handling Strategy |\n|----------|----------|-------------------|\n| **Container tries to configure its own IP address** | Process inside calls `ip addr add` on veth interface | Allowed; container owns its network namespace |\n| **Host network namespace disappears** (unlikely) | Bridge or veth host-side deleted by admin | Container loses connectivity; runtime cannot repair external changes |\n| **Container uses raw sockets to send spoofed packets** | Without dropping capabilities, container can send arbitrary packets | Drop `CAP_NET_RAW` capability from container by default |\n| **DNS resolution inside container fails but host DNS works** | /etc/resolv.conf not properly configured | Runtime should copy host's resolv.conf or use well-known DNS servers |\n| **Port mapping conflict with host service** | Container port 80 maps to host port 80 already in use | Check host port availability before setting up iptables rule; fail fast |\n| **Multiple containers requesting same static IP** | Two containers configured with same `IPAddress` | `IPAM.Allocate` should detect conflict and return error |\n\n**Implementation Note**: Network isolation is only as strong as the capability dropping. The runtime should drop dangerous capabilities (`CAP_NET_RAW`, `CAP_NET_ADMIN`) from the container unless explicitly requested by the user.\n\n#### Image and Storage Edge Cases\n\n| Scenario | Behavior | Handling Strategy |\n|----------|----------|-------------------|\n| **Image layer tar has same file in multiple layers** | Last layer wins; lower layer files are obscured | OverlayFS correctly handles this; file from upper layer (later layer) appears |\n| **Image manifest lists multiple architectures** | Manifest list contains amd64, arm64, etc. entries | Runtime should select based on host architecture or fail with clear error |\n| **Layer download interrupted and partially written** | Partial .tar file in cache | Validate SHA256 digest after download; redownload if mismatch |\n| **Image config specifies invalid entrypoint** (non-existent binary) | `execve` fails at container start | Container fails to start; return meaningful error about missing binary |\n| **Two images share layers with different digests** (impossible by definition) | Content-addressable storage ensures same content = same digest | If digests differ, content differs; treat as different layers |\n| **Image with :latest tag updates while container running** | New image pulled doesn't affect running containers | Running containers use extracted layers; new containers use new image |\n\n**Content Integrity**: The runtime must verify layer digests after download and after extraction. A corrupted layer should be re-downloaded automatically.\n\n#### Security and Permission Edge Cases\n\n| Scenario | Behavior | Handling Strategy |\n|----------|----------|-------------------|\n| **Non-root user runs runtime** | Most operations require `CAP_SYS_ADMIN` | Fail early with clear message about needing root/sudo |\n| **Container process gains root via setuid binary** | Root inside container ≠ root on host (without user ns) | Without user namespace, container root can do damage; warn users |\n| **Host filesystem mounted inside container** (bind mount) | Container can modify host files if mounted rw | Only allow bind mounts from explicit host paths with user consent |\n| **Container escapes via /proc/self/ns/ join** | Process joins host namespace via leaked fd | Keep namespace fds private to runtime; don't expose to container |\n| **Resource limit bypass via fork bomb** | Process creates many children quickly | cgroup pids.max prevents this; ensure limit is set before process starts |\n\n**Security Principle**: The runtime should follow the principle of least privilege. Drop all capabilities not explicitly needed, mount filesystems as read-only where possible, and use user namespaces if implemented.\n\n#### Cross-Milestone Integration Edge Cases\n\nThese edge cases emerge when components from different milestones interact in unexpected ways:\n\n| Scenario | Affected Milestones | Handling Strategy |\n|----------|---------------------|-------------------|\n| **Network namespace created but bridge not set up** | Milestone 1 + 5 | Container has isolated network but no connectivity; runtime should ensure bridge exists or create it |\n| **cgroup limits set but process not moved into cgroup** | Milestone 2 + 1 | Process escapes limits; must call `cgroupManager.AddProcess` after fork but before exec |\n| **Rootfs mounted but /proc not mounted in PID ns** | Milestone 3 + 1 | ps, top show host processes; must mount /proc after entering PID namespace |\n| **OverlayFS mounted but workdir not empty** | Milestone 4 | mount fails with `ENOTEMPTY`; runtime should create fresh workdir or clear it |\n| **Image pulled but layers extracted to wrong location** | Milestone 6 + 4 | OverlayFS can't find lowerdirs; use consistent paths: `/var/lib/runtime/layers/<digest>` |\n| **Container stopped but network namespace not cleaned up** | Milestone 5 + 6 | veth interface orphaned; cleanup must be part of container removal, not just stop |\n\n**Integration Testing**: The runtime needs comprehensive integration tests that verify all milestones work together correctly. Each edge case should have a corresponding test case.\n\n### Implementation Guidance\n\nThis section provides concrete implementation patterns for error handling and cleanup in Go, with complete starter code for the cleanup stack pattern.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Propagation | Return `error` with context using `fmt.Errorf` and `%w` | Structured errors with custom error types implementing `Is()` and `As()` |\n| Cleanup Orchestration | Defer-based cleanup stack | Transaction log with recovery scanner |\n| Resource Tracking | In-memory maps with mutexes | Database (SQLite) for persistent state |\n| Orphan Detection | Periodic scanner goroutine | inotify watches on resource directories |\n| State Recovery | Rebuild state from container directories | Write-ahead log of all state changes |\n\n#### B. Recommended File/Module Structure\n\n```\nproject-root/\n  internal/\n    runtime/\n      errors.go              # Custom error types and error handling utilities\n      cleanup.go             # Cleanup stack implementation\n      recovery.go            # Orphan detection and garbage collection\n      state_manager.go       # State transitions with error handling\n    cgroup/\n      manager.go             # cgroup operations with idempotent cleanup\n    network/\n      manager.go             # Network setup/cleanup with rollback\n    filesystem/\n      manager.go             # Mount operations with proper unmount on error\n    image/\n      store.go               # Image validation and integrity checking\n  cmd/\n    runtime/\n      main.go               # Runtime initialization with startup recovery\n```\n\n#### C. Infrastructure Starter Code\n\nHere's complete, working code for the cleanup stack pattern that can be used throughout the runtime:\n\n```go\n// internal/runtime/cleanup.go\npackage runtime\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// CleanupFunc is a function that cleans up resources.\n// It should be idempotent (safe to call multiple times).\ntype CleanupFunc func()\n\n// CleanupStack manages a stack of cleanup functions to be executed in reverse order.\ntype CleanupStack struct {\n\tfuncs []CleanupFunc\n\tmu    sync.Mutex\n\tdone  bool\n}\n\n// NewCleanupStack creates a new CleanupStack.\nfunc NewCleanupStack() *CleanupStack {\n\treturn &CleanupStack{\n\t\tfuncs: make([]CleanupFunc, 0),\n\t}\n}\n\n// Push adds a cleanup function to the stack.\nfunc (cs *CleanupStack) Push(f CleanupFunc) {\n\tcs.mu.Lock()\n\tdefer cs.mu.Unlock()\n\tif cs.done {\n\t\tpanic(\"cleanup stack already executed\")\n\t}\n\tcs.funcs = append(cs.funcs, f)\n}\n\n// Execute runs all cleanup functions in reverse order (LIFO).\n// After execution, the stack is marked as done and cannot be used again.\nfunc (cs *CleanupStack) Execute() {\n\tcs.mu.Lock()\n\tdefer cs.mu.Unlock()\n\tif cs.done {\n\t\treturn\n\t}\n\tcs.done = true\n\t\n\t// Execute in reverse order (LIFO)\n\tfor i := len(cs.funcs) - 1; i >= 0; i-- {\n\t\tcs.funcs[i]()\n\t}\n\tcs.funcs = nil // Allow garbage collection\n}\n\n// DeferOnError returns a function that executes the cleanup stack if the error is non-nil.\n// Usage: defer cleanup.DeferOnError(&err)()\nfunc (cs *CleanupStack) DeferOnError(err *error) func() {\n\treturn func() {\n\t\tif *err != nil {\n\t\t\tcs.Execute()\n\t\t}\n\t}\n}\n\n// CleanupManager orchestrates cleanup across the entire runtime.\ntype CleanupManager struct {\n\tcontainerStacks map[string]*CleanupStack\n\tglobalStack     *CleanupStack\n\tmu              sync.RWMutex\n}\n\n// NewCleanupManager creates a new CleanupManager.\nfunc NewCleanupManager() *CleanupManager {\n\treturn &CleanupManager{\n\t\tcontainerStacks: make(map[string]*CleanupStack),\n\t\tglobalStack:     NewCleanupStack(),\n\t}\n}\n\n// RegisterContainerCleanup creates a cleanup stack for a container.\nfunc (cm *CleanupManager) RegisterContainerCleanup(containerID string) *CleanupStack {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\tstack := NewCleanupStack()\n\tcm.containerStacks[containerID] = stack\n\treturn stack\n}\n\n// ExecuteContainerCleanup runs cleanup for a specific container.\nfunc (cm *CleanupManager) ExecuteContainerCleanup(containerID string) {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\tif stack, ok := cm.containerStacks[containerID]; ok {\n\t\tstack.Execute()\n\t\tdelete(cm.containerStacks, containerID)\n\t}\n}\n\n// ExecuteAllCleanup runs cleanup for all containers and global resources.\nfunc (cm *CleanupManager) ExecuteAllCleanup() {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\t\n\t// Clean up all containers\n\tfor containerID, stack := range cm.containerStacks {\n\t\tstack.Execute()\n\t\tdelete(cm.containerStacks, containerID)\n\t}\n\t\n\t// Clean up global resources\n\tcm.globalStack.Execute()\n}\n```\n\n#### D. Core Logic Skeleton Code\n\nHere's the skeleton for the container creation sequence with integrated error handling and cleanup:\n\n```go\n// internal/runtime/container_creation.go\npackage runtime\n\nimport (\n\t\"fmt\"\n\t\n\t\"github.com/your-username/container-runtime/internal/cgroup\"\n\t\"github.com/your-username/container-runtime/internal/network\"\n\t\"github.com/your-username/container-runtime/internal/filesystem\"\n\t\"github.com/your-username/container-runtime/internal/types\"\n)\n\nfunc (r *ContainerRuntime) createContainerSequence(config types.ContainerConfig, name string) (*types.Container, error) {\n\tvar err error\n\tcontainerID := uuid.Generate()\n\t\n\t// Create cleanup stack for this container\n\tcleanupStack := r.cleanupManager.RegisterContainerCleanup(containerID)\n\tdefer cleanupStack.DeferOnError(&err)()\n\t\n\t// Step 1: Validate configuration\n\t// TODO 1: Check all fields of config for validity (positive memory, valid image ref, etc.)\n\t// TODO 2: Check if container name is unique\n\t// TODO 3: Check if image exists locally; if not, return error (caller should pull first)\n\t\n\t// Step 2: Create container metadata\n\tcontainer := &types.Container{\n\t\tID:   containerID,\n\t\tName: name,\n\t\tState: types.StateCreated,\n\t\tConfig: config,\n\t\tCreatedAt: time.Now(),\n\t}\n\t\n\t// Step 3: Save container to persistent storage (so we know about it even if crash)\n\t// TODO 4: Call r.containerStore.Save(container)\n\tcleanupStack.Push(func() {\n\t\t// If creation fails, delete the container record\n\t\tr.containerStore.Delete(containerID)\n\t})\n\t\n\t// Step 4: Create cgroup for container\n\t// TODO 5: Call r.cgroupManager.CreateCgroup(containerID)\n\t// TODO 6: Apply resource limits from config.Limits using r.cgroupManager.ApplyLimits\n\tcleanupStack.Push(func() {\n\t\t// Idempotent cgroup cleanup\n\t\tr.cgroupManager.RemoveCgroup(containerID)\n\t})\n\t\n\t// Step 5: Setup network namespace and interfaces\n\t// TODO 7: Call r.networkManager.SetupNetwork with containerID and config.Network\n\tcleanupStack.Push(func() {\n\t\t// Idempotent network cleanup\n\t\tr.networkManager.CleanupNetwork(containerID, config.Network)\n\t})\n\t\n\t// Step 6: Prepare root filesystem\n\t// TODO 8: Get image from image store\n\t// TODO 9: Call r.filesystemManager.SetupRootfs to extract layers and prepare rootfs\n\tcleanupStack.Push(func() {\n\t\t// Idempotent filesystem cleanup\n\t\tr.filesystemManager.CleanupFilesystem(containerID)\n\t})\n\t\n\t// Step 7: All additional preparations (mounts, etc.)\n\t// TODO 10: Setup additional mounts, /proc, /sys, /dev inside container rootfs\n\t\n\t// Step 8: Container is ready to start\n\t// TODO 11: Update container state to StateCreated (if not already)\n\t\n\t// Clear cleanup stack since creation succeeded\n\t// We'll create a new stack for the start operation\n\tr.cleanupManager.ExecuteContainerCleanup(containerID)\n\t\n\treturn container, nil\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Error wrapping in Go**: Use `fmt.Errorf(\"context: %w\", err)` to wrap errors while preserving the original error for inspection with `errors.Is()` and `errors.As()`.\n\n2. **Checking syscall errors**: Use the `os` and `syscall` packages:\n   ```go\n   if err := syscall.Mount(\"proc\", \"/proc\", \"proc\", 0, \"\"); err != nil {\n       if err == syscall.EPERM {\n           return fmt.Errorf(\"need CAP_SYS_ADMIN: %w\", err)\n       }\n       return fmt.Errorf(\"mount proc failed: %w\", err)\n   }\n   ```\n\n3. **Idempotent cleanup functions**:\n   ```go\n   func idempotentUnmount(path string) {\n       if err := syscall.Unmount(path, syscall.MNT_DETACH); err != nil {\n           // Ignore \"not mounted\" errors\n           if err != syscall.EINVAL && err != syscall.ENOENT {\n               log.Printf(\"Warning: unmount %s failed: %v\", path, err)\n           }\n       }\n   }\n   ```\n\n4. **Context for timeouts**: Use `context.WithTimeout` for network operations:\n   ```go\n   ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n   defer cancel()\n   manifest, err := r.registryClient.PullManifest(ctx, imageRef, tag)\n   ```\n\n5. **Atomic file writes**: To avoid partial writes during image layer download:\n   ```go\n   // Write to temp file first, then rename atomically\n   tmpPath := destPath + \".tmp\"\n   defer os.Remove(tmpPath)\n   // ... download to tmpPath ...\n   if err := os.Rename(tmpPath, destPath); err != nil {\n       return fmt.Errorf(\"atomic rename failed: %w\", err)\n   }\n   ```\n\n#### F. Milestone Checkpoint\n\nAfter implementing error handling, you should be able to test:\n\n1. **Container creation failure recovery**:\n   ```bash\n   # Run with invalid image reference\n   sudo ./runtime run --memory 100m nonexistent/image:latest echo \"hello\"\n   # Should fail cleanly with error message, no orphaned resources\n   ```\n\n2. **Resource cleanup verification**:\n   ```bash\n   # Start container, then kill runtime process (Ctrl+Z, kill -9)\n   sudo ./runtime run --memory 50m alpine:latest sleep 60\n   # Kill runtime in another terminal\n   # Restart runtime - it should detect and clean up orphaned container\n   sudo ./runtime cleanup --all\n   # Check no cgroups, mounts, or network interfaces remain\n   ```\n\n3. **Edge case testing**:\n   ```bash\n   # Test immediate exit container\n   sudo ./runtime run alpine:latest echo \"done\"\n   # Container should stop cleanly and be removable\n  \n   # Test fork bomb with pids limit\n   sudo ./runtime run --pids-limit 50 alpine:latest /bin/sh -c \"forkbomb() { forkbomb | forkbomb & }; forkbomb\"\n   # Should be contained and not affect host\n   ```\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Container starts but immediately exits with code 127** | Entrypoint binary not found in rootfs | Check container logs, verify image layers extracted correctly | Ensure image has correct entrypoint, extract layers fully |\n| **Mount operation fails with \"invalid argument\"** | OverlayFS not supported or missing kernel module | Check `/proc/filesystems` for overlay entry | Load overlay module: `sudo modprobe overlay` |\n| **cgroup creation fails with \"permission denied\"** | cgroup filesystem mounted read-only or wrong permissions | Check `/sys/fs/cgroup` mount options | Remount as rw: `sudo mount -o remount,rw /sys/fs/cgroup` |\n| **Network connectivity broken inside container** | veth interface not added to bridge or iptables rules missing | Check `ip link`, `brctl show`, `iptables -L -n -t nat` | Ensure network setup completes all steps |\n| **Container can see host processes in /proc** | /proc not mounted after entering PID namespace | Check mount namespace and order of operations | Mount /proc inside container after `CLONE_NEWPID` |\n| **Orphaned resources after runtime crash** | Cleanup not executed due to crash | Run runtime with `cleanup --all` flag | Implement startup garbage collection |\n| **Image layer download fails with 404** | Wrong digest or registry authentication issue | Check manifest for correct layer digests | Ensure authentication tokens are valid |\n\n\n## Testing Strategy\n> **Milestone(s):** All milestones (testing is essential for validating each component and the integrated system)\n\nThis section outlines a comprehensive testing strategy for the container runtime. Given the complexity of interacting with low-level Linux kernel features, testing must be approached at multiple levels—from unit tests of individual components to full system integration tests. The strategy prioritizes **safety** (preventing host system contamination), **reproducibility** (consistent test environments), and **progressive validation** (each milestone builds on tested foundations).\n\n### Verification Approaches and Properties\n\nTesting a container runtime presents unique challenges because it directly manipulates kernel primitives that affect system state. We employ a layered testing pyramid with specific verification approaches for each level:\n\n#### 1. Unit Testing: Component Isolation and Mocking\n\n**Mental Model: Testing Individual Machine Parts Before Assembly**\nThink of unit testing as testing each component of an engine (fuel pump, spark plugs, pistons) on a workbench before assembling the entire engine. Each component is tested in isolation with simulated inputs and dependencies.\n\nUnit tests focus on the business logic of each component, mocking all external system interactions. This allows rapid iteration and validation of control flow, error handling, and data transformations without requiring root privileges or creating actual kernel resources.\n\n**Core Verification Properties for Unit Tests:**\n- **Data Structure Integrity:** All fields are correctly initialized, serialized, and deserialized\n- **State Machine Transitions:** Container state changes follow allowed paths with proper validation\n- **Configuration Processing:** User input is validated and merged with defaults correctly\n- **Error Propagation:** Errors from lower layers are properly wrapped and returned\n- **Resource Management:** Reference counting and cleanup logic work correctly\n\n**Mocking Strategy Table:**\n| Component | Mocked Dependencies | Verification Focus |\n|-----------|---------------------|-------------------|\n| `ContainerStore` | Filesystem I/O | Persistence operations, JSON marshaling/unmarshaling |\n| `CgroupManager` | `/sys/fs/cgroup` files | Limit validation, path construction, controller detection |\n| `NamespaceManager` | `syscall.Clone`, `syscall.Unshare` | Flag composition, error condition simulation |\n| `FilesystemManager` | `syscall.Mount`, `syscall.PivotRoot` | Path validation, mount option construction |\n| `NetworkManager` | `netlink`, `iptables` | IP allocation, bridge setup, rule generation |\n| `ImageStore` | Filesystem, HTTP client | Digest verification, layer extraction logic |\n| `RegistryClient` | HTTP transport | Manifest parsing, authentication flow, retry logic |\n\n**Example Unit Test Scenarios:**\n- `ContainerStore.Save()` with invalid container state should return an error\n- `CgroupManager.SetLimits()` with negative memory value should validate and reject\n- `StateManager.Transition()` from `StateRunning` to `StateCreated` should be blocked\n- `CleanupStack.Execute()` should run functions in reverse order and handle panics\n\n#### 2. Integration Testing: Component Interaction with Real Dependencies\n\n**Mental Model: Assembling Engine Subsystems on a Test Stand**\nIntegration tests assemble related components and test them against real (but isolated) kernel interfaces. This is like testing the fuel system with real gasoline but in a controlled test chamber.\n\nThese tests require root privileges and create actual kernel resources but within isolated scopes (temporary directories, test-specific cgroup hierarchies). Each test is responsible for complete cleanup to avoid leaving system state.\n\n**Key Integration Testing Patterns:**\n\n**Test Isolation Table:**\n| Isolation Technique | Implementation | Purpose |\n|---------------------|----------------|---------|\n| **Temporary Directory** | `os.MkdirTemp()` | Provides scratch space for root filesystems, layer storage |\n| **Test-specific Cgroup** | Create under `/sys/fs/cgroup/test-*` | Contains cgroup operations to test hierarchy |\n| **Private Mount Namespace** | `unshare(CLONE_NEWNS)` | Isolate mount operations from host filesystem |\n| **Network Namespace Sandbox** | `netns.New()` at test start | Test networking without affecting host interfaces |\n| **Process Namespace Tracking** | Track PIDs created during test | Ensure all child processes are terminated |\n\n**Integration Test Categories:**\n1. **Filesystem Integration Tests:** Mount operations, OverlayFS setup, pivot_root behavior\n2. **Cgroup Integration Tests:** Limit enforcement, process migration, statistic collection\n3. **Namespace Integration Tests:** Process isolation, hostname setting, mount propagation\n4. **Network Integration Tests:** veth pair creation, bridge attachment, iptables rules\n5. **Image Management Tests:** Layer extraction, manifest parsing, registry communication\n\n**Verification Properties for Integration Tests:**\n- **Kernel Interface Correctness:** System calls behave as expected with given parameters\n- **Resource Cleanup:** All created resources (mounts, cgroups, network interfaces) are removed\n- **Isolation Integrity:** Operations in test environment don't leak to host\n- **Error Recovery:** Partial failures are cleaned up properly (no orphan resources)\n- **Concurrent Safety:** Multiple test runs don't interfere with each other\n\n#### 3. System Testing: End-to-End Container Execution\n\n**Mental Model: Test Driving the Complete Vehicle**\nSystem tests run actual containers with realistic configurations and verify the entire stack works together correctly. This is like taking the fully assembled car for a test drive on a closed track.\n\nThese tests require full root privileges and create complete container environments. They validate the user-facing CLI commands and the complete container lifecycle.\n\n**System Test Architecture:**\n```\nTest Runner (as root)\n    ├── Creates temporary runtime root directory\n    ├── Initializes all managers with test paths\n    ├── Executes container operations via CLI\n    └── Verifies container behavior and isolation\n```\n\n**System Test Scenarios Table:**\n| Test Scenario | Verification Points | Expected Outcome |\n|---------------|---------------------|------------------|\n| **Simple Container Run** | Process starts, runs, exits cleanly | Exit code 0, logs captured |\n| **Isolation Verification** | Check PID, hostname, filesystem view | Cannot see host processes, has own hostname, limited filesystem |\n| **Resource Limit Enforcement** | Exceed memory limit, fork bomb with PID limit | OOM kill, fork failure |\n| **Network Connectivity** | Ping gateway, external IP, other containers | Network works with NAT, inter-container communication |\n| **Filesystem Persistence** | Write to filesystem, restart container | Data persists in writable layer |\n| **Image Pull and Run** | Pull from registry, create container | Image layers extracted, container runs with correct entrypoint |\n| **Cleanup After Crash** | Kill runtime process mid-operation | No orphaned mounts, cgroups, or network interfaces |\n\n**System Test Properties:**\n- **End-to-End Correctness:** The complete user workflow works as documented\n- **Idempotent Cleanup:** Repeated cleanup operations don't fail\n- **State Persistence:** Container state survives runtime restarts\n- **Performance Baselines:** Operations complete within expected time bounds\n- **Security Boundaries:** Container cannot escape isolation or affect host\n\n#### 4. Property-Based and Fuzz Testing\n\n**Mental Model: Stress Testing with Random Inputs**\nProperty-based testing generates random but valid inputs to test edge cases that manual test cases might miss. This is like using a vibration table to find weak points in the assembly.\n\n**Areas for Property-Based Testing:**\n- **Configuration Generation:** Random but valid `ContainerConfig` instances\n- **Path Manipulation:** Edge cases in filesystem path handling\n- **Network Configuration:** Various IP addresses, subnet masks, port combinations\n- **Image Layer Combinations:** Different layer counts, sizes, extraction scenarios\n\n**Fuzz Testing Targets:**\n- **Image Manifest Parsers:** Malformed JSON, unexpected fields, large inputs\n- **CLI Argument Processing:** Special characters, extremely long strings\n- **Environment Variable Handling:** Injection attempts, null bytes, Unicode\n\n#### 5. Negative Testing: Error Paths and Edge Cases\n\n**Mental Model: Deliberately Pushing the System to Failure**\nNegative tests verify the system handles errors gracefully rather than crashing or leaving the system in an inconsistent state. This is like testing safety systems by intentionally creating failure conditions.\n\n**Critical Negative Test Cases:**\n1. **Insufficient Privileges:** Run operations as non-root user\n2. **Resource Exhaustion:** Fill disk, memory, PID space during operations\n3. **Concurrent Modification:** Multiple processes manipulating same container\n4. **Partial Failures:** Kill processes mid-operation, disconnect network during pull\n5. **Malicious Inputs:** Attempt path traversal, symlink attacks, privilege escalation\n\n### Milestone Checkpoints\n\nEach milestone has specific acceptance criteria that must be verified through testing. These checkpoints serve as gates—the implementation should pass all tests for a milestone before proceeding to the next.\n\n#### Milestone 1: Process Isolation (Namespaces) Checkpoints\n\n**Verification Tests:**\n\n**Unit Tests:**\n- `NamespaceManager.CreateNamespaces()` correctly composes clone flags from requested namespace types\n- State machine prevents starting containers without required namespaces\n- Configuration validation rejects invalid namespace combinations\n\n**Integration Tests:**\n1. **PID Namespace Isolation:**\n   ```bash\n   # Run container with /bin/sh and check PID\n   $ sudo ./byod run --pid-isolation alpine /bin/sh -c \"echo \\$\\$\"\n   Expected: Outputs \"1\" (not the host PID)\n   ```\n   \n2. **UTS Namespace Hostname:**\n   ```bash\n   # Set custom hostname in container\n   $ sudo ./byod run --hostname mycontainer alpine hostname\n   Expected: Outputs \"mycontainer\" (host hostname unchanged)\n   ```\n\n3. **Mount Namespace Isolation:**\n   ```bash\n   # Mount tmpfs inside container, check host doesn't see it\n   $ sudo ./byod run alpine sh -c \"mount -t tmpfs none /tmp && mount | grep tmpfs\"\n   Expected: Shows tmpfs mount inside container\n   $ mount | grep tmpfs  # On host\n   Expected: No output (or different tmpfs mounts)\n   ```\n\n**System Test Checklist:**\n- [ ] Process in container cannot see host processes via `ps aux`\n- [ ] `unshare` and `nsenter` can attach to container namespaces\n- [ ] Container processes are properly reaped when container exits\n- [ ] Orphaned namespaces are cleaned up after container removal\n\n#### Milestone 2: Resource Limits (cgroups) Checkpoints\n\n**Verification Tests:**\n\n**Unit Tests:**\n- `CgroupManager.DetectCgroupInfo()` correctly identifies cgroup v1 vs v2\n- `CgroupManager.SetLimits()` validates and converts units correctly\n- Error handling for missing controllers or permission denied\n\n**Integration Tests:**\n1. **Memory Limit Enforcement:**\n   ```bash\n   # Run container that allocates more than limit\n   $ sudo ./byod run --memory 10m alpine sh -c \"tail /dev/zero\"\n   Expected: Process killed by OOM killer within seconds\n   ```\n   \n2. **CPU Limit Throttling:**\n   ```bash\n   # Run CPU-intensive task, check throttling statistics\n   $ sudo ./byod run --cpu-shares 512 alpine md5sum /dev/urandom\n   # Monitor via: cat /sys/fs/cgroup/byod-<id>/cpu.stat\n   Expected: `nr_throttled` count increases\n   ```\n\n3. **PID Limit Prevention:**\n   ```bash\n   # Attempt fork bomb with PID limit\n   $ sudo ./byod run --pids-limit 10 alpine sh -c \":(){ :|:& };:\"\n   Expected: Fork fails after 10 processes, container remains stable\n   ```\n\n**System Test Checklist:**\n- [ ] Cgroup directory created with correct hierarchy\n- [ ] Control files contain specified limit values\n- [ ] Process moved to cgroup before execution starts\n- [ ] Cgroup removed when container is removed\n- [ ] Statistics collection works (`GetStats()` returns valid data)\n\n#### Milestone 3: Filesystem Isolation (chroot/pivot_root) Checkpoints\n\n**Verification Tests:**\n\n**Unit Tests:**\n- `FilesystemManager.SetupRootfs()` validates rootfs directory structure\n- Mount option construction for proc, sys, dev\n- Error handling for missing essential directories\n\n**Integration Tests:**\n1. **Root Filesystem Isolation:**\n   ```bash\n   # Try to access host files from container\n   $ sudo ./byod run --rootfs /path/to/rootfs alpine ls /host\n   Expected: No such file or directory (host / not visible)\n   ```\n\n2. **Proc Filesystem Mount:**\n   ```bash\n   # Check /proc shows container processes only\n   $ sudo ./byod run alpine sh -c \"ls /proc | grep -E '^[0-9]+$' | wc -l\"\n   Expected: Small number (1-2), not host process count\n   ```\n\n3. **Basic Filesystem Operations:**\n   ```bash\n   # Create, read, delete files in container\n   $ sudo ./byod run alpine sh -c \"echo test > /tmp/file && cat /tmp/file && rm /tmp/file\"\n   Expected: Successfully creates, reads, and deletes file\n   ```\n\n**System Test Checklist:**\n- [ ] Container cannot access host files via path traversal\n- [ ] `/proc`, `/sys`, `/dev` mounted with correct options\n- [ ] Essential device nodes (`/dev/null`, `/dev/zero`, `/dev/random`) exist\n- [ ] Working directory is set correctly per image configuration\n- [ ] Old root is properly unmounted after `pivot_root`\n\n#### Milestone 4: Layered Filesystem (OverlayFS) Checkpoints\n\n**Verification Tests:**\n\n**Unit Tests:**\n- `OverlayManager.MountOverlay()` validates layer ordering and directories\n- `LayerCache` reference counting maintains correct counts\n- Error handling for incompatible lower layer combinations\n\n**Integration Tests:**\n1. **Copy-on-Write Behavior:**\n   ```bash\n   # Modify file from lower layer\n   $ sudo ./byod run alpine sh -c \"echo modified > /etc/hostname && cat /etc/hostname\"\n   Expected: Shows \"modified\" (change in upper layer)\n   # Check lower layer unchanged\n   $ cat /path/to/lower-layer/etc/hostname\n   Expected: Original content\n   ```\n\n2. **Layer Sharing Between Containers:**\n   ```bash\n   # Run two containers from same image\n   $ sudo ./byod run alpine sh -c \"touch /shared-test\"\n   $ sudo ./byod run alpine ls -la /shared-test\n   Expected: File not found in second container (isolated upper layers)\n   ```\n\n3. **Whiteout File Deletion:**\n   ```bash\n   # Delete file from lower layer\n   $ sudo ./byod run alpine sh -c \"rm /etc/hostname && ls /etc/hostname\"\n   Expected: No such file or directory\n   # Check whiteout created in upper layer\n   $ ls -la /path/to/upper-layer/etc/\n   Expected: Character device with major/minor 0/0 (whiteout)\n   ```\n\n**System Test Checklist:**\n- [ ] Multiple lower layers merged correctly (order preserved)\n- [ ] Upper layer captures all writes\n- [ ] Work directory used correctly for atomic operations\n- [ ] Unmount cleans up all mount points\n- [ ] Layer cache prevents duplicate extraction of same layer\n\n#### Milestone 5: Container Networking Checkpoints\n\n**Verification Tests:**\n\n**Unit Tests:**\n- `IPAM.Allocate()` prevents duplicate IP allocation\n- `NetlinkHelper` command generation for bridge, veth, iptables\n- Network configuration validation (CIDR, port ranges)\n\n**Integration Tests:**\n1. **Basic Network Connectivity:**\n   ```bash\n   # Ping external address\n   $ sudo ./byod run --network bridge alpine ping -c 1 8.8.8.8\n   Expected: Successful ping response\n   ```\n\n2. **Inter-Container Communication:**\n   ```bash\n   # Start two containers on same bridge\n   $ container1=$(sudo ./byod run --network bridge alpine sleep 60)\n   $ ip1=$(sudo ./byod inspect $container1 | jq .network.ip_address)\n   $ sudo ./byod run --network bridge alpine ping -c 1 $ip1\n   Expected: Successful ping between containers\n   ```\n\n3. **Port Forwarding:**\n   ```bash\n   # Forward host port to container\n   $ sudo ./byod run --port 8080:80 alpine nc -l -p 80 &\n   $ curl http://localhost:8080\n   Expected: Connection succeeds (or times out waiting for response)\n   ```\n\n**System Test Checklist:**\n- [ ] Network namespace created and isolated\n- [ ] veth pair connects container to bridge\n- [ ] IP address assigned from configured subnet\n- [ ] NAT masquerading allows internet access\n- [ ] iptables rules cleaned up on container removal\n- [ ] Loopback interface up and working inside container\n\n#### Milestone 6: Image Format and CLI Checkpoints\n\n**Verification Tests:**\n\n**Unit Tests:**\n- `RegistryClient` handles authentication errors and retries\n- OCI manifest parsing with various schema versions\n- CLI command flag parsing and validation\n\n**Integration Tests:**\n1. **Image Pull and Run:**\n   ```bash\n   # Pull image and run it\n   $ sudo ./byod pull alpine:latest\n   Expected: Downloads layers, verifies digests, stores locally\n   $ sudo ./byod run alpine:latest echo \"Hello from container\"\n   Expected: Runs container with correct entrypoint, outputs message\n   ```\n\n2. **Container Lifecycle Management:**\n   ```bash\n   # Full lifecycle test\n   $ id=$(sudo ./byod create alpine:latest)\n   $ sudo ./byod start $id\n   $ sudo ./byod stop $id\n   $ sudo ./byod remove $id\n   Expected: Each command succeeds, state transitions correctly\n   ```\n\n3. **Configuration Merging:**\n   ```bash\n   # Override image entrypoint with CLI command\n   $ sudo ./byod run alpine:latest /bin/ls -la /\n   Expected: Runs ls instead of default shell, shows root directory\n   ```\n\n**System Test Checklist:**\n- [ ] Image layers stored in content-addressable storage\n- [ ] Manifest and config parsed correctly\n- [ ] Container state persisted across runtime restarts\n- [ ] CLI commands produce expected output format\n- [ ] Error messages are user-friendly and actionable\n- [ ] All resources cleaned up after container removal\n\n### Cross-Cutting Testing Concerns\n\n**Performance Testing:**\n- Container startup time should be < 100ms for small images\n- Memory overhead per container should be < 5MB\n- Concurrent container creation should scale linearly up to resource limits\n\n**Security Testing:**\n- No privilege escalation opportunities\n- No information leakage between containers\n- Resource exhaustion doesn't affect host stability\n- All user input properly sanitized and validated\n\n**Compatibility Testing:**\n- Works with multiple base images (Alpine, Ubuntu, BusyBox)\n- Compatible with different Linux distributions (Ubuntu, Fedora, CentOS)\n- Kernel version compatibility (4.4+ for basic features, 5.4+ for cgroup v2)\n\n### Test Environment Requirements\n\n**Minimum Test Environment Setup:**\n- Linux kernel 4.4 or higher (5.10+ recommended for cgroup v2)\n- Root privileges (via sudo or root user)\n- 1GB free disk space for test images\n- Network connectivity for pulling images\n- Go 1.18+ for building and testing\n\n**Test Isolation Recommendations:**\n- Use separate temporary directory for each test run\n- Run tests in disposable VMs or containers for complete isolation\n- Implement test tags to separate unit, integration, and system tests\n- Cleanup routines that run even on test failure (defer pattern)\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing the testing strategy in Go, with a focus on making tests reliable, isolated, and maintainable.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Unit Testing** | Standard Go `testing` package with `testify/mock` | Custom mock generators, property-based testing with `gopter` |\n| **Integration Testing** | Root-requiring tests with `skip` unless flag set | Test containers that run tests in isolated environments |\n| **System Testing** | Bash scripts calling CLI | Go tests that exec CLI and verify output |\n| **Network Testing** | Loopback interface only, skip real network tests | `github.com/vishvananda/netns` for namespace testing |\n| **Filesystem Testing** | Temp directories with cleanup | Mount namespace isolation for safe mount operations |\n| **Cgroup Testing** | Skip unless in CI with specific permissions | Detect available controllers and test only supported ones |\n\n#### B. Recommended File/Module Structure\n\n```\nproject-root/\n├── cmd/\n│   └── byod/                    # CLI entry point\n│       └── main.go\n├── internal/\n│   ├── runtime/                 # Core runtime logic\n│   │   ├── runtime.go\n│   │   ├── runtime_test.go      # Unit tests\n│   │   └── runtime_integration_test.go  # Integration tests\n│   ├── container/               # Container management\n│   │   ├── store.go\n│   │   ├── state.go\n│   │   └── store_test.go\n│   ├── cgroups/                 # cgroup management\n│   │   ├── manager.go\n│   │   ├── manager_integration_test.go\n│   │   └── mock_manager.go      # Mock for unit tests\n│   ├── namespaces/              # Namespace management\n│   │   ├── manager.go\n│   │   └── manager_test.go\n│   ├── filesystem/              # Filesystem isolation\n│   │   ├── manager.go\n│   │   ├── overlay.go\n│   │   └── manager_integration_test.go\n│   ├── network/                 # Network management\n│   │   ├── manager.go\n│   │   ├── iptables.go\n│   │   └── manager_integration_test.go\n│   ├── image/                   # Image handling\n│   │   ├── store.go\n│   │   ├── registry.go\n│   │   └── store_test.go\n│   └── cli/                     # CLI command implementations\n│       ├── commands.go\n│       └── commands_test.go\n├── tests/                       # System and end-to-end tests\n│   ├── system/                  # Full system tests\n│   │   ├── container_lifecycle_test.go\n│   │   └── network_test.go\n│   └── fixtures/                # Test fixtures (small rootfs, etc.)\n│       └── busybox-rootfs.tar\n├── pkg/                         # Public APIs (if any)\n│   └── types/                   # Shared types\n│       ├── container.go\n│       └── image.go\n└── scripts/                     # Test support scripts\n    ├── setup-test-env.sh\n    └── cleanup-test-resources.sh\n```\n\n#### C. Infrastructure Starter Code\n\n**Test Helper for Root-Requiring Tests:**\n\n```go\n// internal/testutil/root_required.go\npackage testutil\n\nimport (\n    \"os\"\n    \"testing\"\n)\n\n// SkipIfNotRoot skips the test if not running as root.\n// Use: defer testutil.SkipIfNotRoot(t)()\nfunc SkipIfNotRoot(t *testing.T) func() {\n    if os.Geteuid() != 0 {\n        t.Skip(\"Test requires root privileges\")\n    }\n    return func() {} // No-op cleanup\n}\n\n// TempCgroupPath creates a temporary directory for cgroup testing.\n// Automatically cleans up after test.\nfunc TempCgroupPath(t *testing.T) string {\n    // Implementation creates test-specific cgroup path\n}\n\n// WithTestNamespace runs test code in a new mount namespace.\nfunc WithTestNamespace(t *testing.T, fn func()) {\n    // Implementation uses unshare to isolate mounts\n}\n```\n\n**Mock Cgroup Manager for Unit Tests:**\n\n```go\n// internal/cgroups/mock_manager.go\npackage cgroups\n\nimport (\n    \"github.com/stretchr/testify/mock\"\n)\n\ntype MockCgroupManager struct {\n    mock.Mock\n}\n\nfunc (m *MockCgroupManager) CreateCgroup(containerID string) error {\n    args := m.Called(containerID)\n    return args.Error(0)\n}\n\nfunc (m *MockCgroupManager) SetLimits(containerID string, limits ResourceLimits) error {\n    args := m.Called(containerID, limits)\n    return args.Error(0)\n}\n\n// ... implement all methods with mock.Called\n```\n\n**Test Fixture Setup Helper:**\n\n```go\n// tests/fixtures/setup.go\npackage fixtures\n\nimport (\n    \"archive/tar\"\n    \"compress/gzip\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n)\n\n// CreateTestRootFS creates a minimal rootfs for testing.\nfunc CreateTestRootFS(dir string) error {\n    // Create essential directories\n    dirs := []string{\"bin\", \"dev\", \"etc\", \"proc\", \"sys\", \"tmp\", \"usr/bin\"}\n    for _, d := range dirs {\n        if err := os.MkdirAll(filepath.Join(dir, d), 0755); err != nil {\n            return err\n        }\n    }\n    \n    // Create minimal /etc/passwd\n    passwdContent := \"root:x:0:0:root:/root:/bin/sh\\n\"\n    if err := os.WriteFile(filepath.Join(dir, \"etc/passwd\"), \n        []byte(passwdContent), 0644); err != nil {\n        return err\n    }\n    \n    // Create /bin/sh as symlink (or copy busybox if available)\n    shPath := filepath.Join(dir, \"bin/sh\")\n    if _, err := os.Stat(\"/bin/sh\"); err == nil {\n        // Copy host's sh (for testing only)\n        data, err := os.ReadFile(\"/bin/sh\")\n        if err == nil {\n            os.WriteFile(shPath, data, 0755)\n        }\n    } else {\n        // Create dummy executable\n        os.WriteFile(shPath, []byte(\"#!/bin/sh\\nexit 0\"), 0755)\n        os.Chmod(shPath, 0755)\n    }\n    \n    return nil\n}\n```\n\n#### D. Core Logic Skeleton Code for Tests\n\n**Integration Test for PID Namespace Isolation:**\n\n```go\n// internal/namespaces/manager_integration_test.go\npackage namespaces\n\nimport (\n    \"os\"\n    \"testing\"\n    \n    \"github.com/yourproject/internal/testutil\"\n)\n\nfunc TestPIDNamespaceIsolation(t *testing.T) {\n    defer testutil.SkipIfNotRoot(t)()\n    \n    // TODO 1: Create a temporary directory for test artifacts\n    // TODO 2: Initialize NamespaceManager with test configuration\n    // TODO 3: Use RunInNamespaces with CLONE_NEWPID flag\n    // TODO 4: In child function, check that PID is 1 via os.Getpid()\n    // TODO 5: In parent, verify child process had correct namespace\n    // TODO 6: Clean up all test resources (process, namespaces)\n    // TODO 7: Verify no orphaned processes or namespaces remain\n}\n```\n\n**System Test for Container Lifecycle:**\n\n```go\n// tests/system/container_lifecycle_test.go\npackage system\n\nimport (\n    \"encoding/json\"\n    \"os/exec\"\n    \"testing\"\n    \n    \"github.com/yourproject/internal/testutil\"\n)\n\nfunc TestContainerCreateStartStopRemove(t *testing.T) {\n    defer testutil.SkipIfNotRoot(t)()\n    \n    // TODO 1: Build the CLI binary if not already built\n    // TODO 2: Create a test container with minimal image\n    // TODO 3: Verify container appears in list with 'created' state\n    // TODO 4: Start the container and verify state changes to 'running'\n    // TODO 5: Check container process is running with correct namespaces\n    // TODO 6: Stop the container and verify state changes to 'stopped'\n    // TODO 7: Remove the container and verify it's gone from list\n    // TODO 8: Verify all resources cleaned up (cgroups, mounts, network)\n}\n```\n\n**Property-Based Test for Configuration Validation:**\n\n```go\n// internal/container/config_test.go\npackage container\n\nimport (\n    \"testing\"\n    \n    \"github.com/leanovate/gopter\"\n    \"github.com/leanovate/gopter/gen\"\n    \"github.com/leanovate/gopter/prop\"\n)\n\nfunc TestContainerConfigValidation(t *testing.T) {\n    parameters := gopter.DefaultTestParameters()\n    parameters.MinSuccessfulTests = 100\n    properties := gopter.NewProperties(parameters)\n    \n    // TODO 1: Define generator for valid ContainerConfig\n    configGen := gen.Struct(reflect.TypeOf(ContainerConfig{}), map[string]gopter.Gen{\n        \"MemoryMB\":  gen.IntRange(1, 1024),  // 1MB to 1GB\n        \"CPUShares\": gen.IntRange(1, 1024),\n        \"PidsLimit\": gen.IntRange(1, 100),\n    })\n    \n    // TODO 2: Test property: valid config should pass validation\n    properties.Property(\"Valid config passes validation\", prop.ForAll(\n        func(config ContainerConfig) bool {\n            err := ValidateConfig(config)\n            return err == nil\n        },\n        configGen,\n    ))\n    \n    // TODO 3: Test property: config with negative memory should fail\n    properties.Property(\"Negative memory fails validation\", prop.ForAll(\n        func(memory int) bool {\n            config := ContainerConfig{MemoryMB: memory}\n            err := ValidateConfig(config)\n            return (memory <= 0 && err != nil) || (memory > 0 && err == nil)\n        },\n        gen.IntRange(-100, 100),\n    ))\n    \n    properties.TestingRun(t)\n}\n```\n\n#### E. Language-Specific Hints for Go Testing\n\n1. **Use `t.Cleanup()` for test resource cleanup:**\n   ```go\n   func TestWithCleanup(t *testing.T) {\n       dir := t.TempDir()  // Automatically cleaned up\n       // Or manually:\n       f, err := os.CreateTemp(\"\", \"test-\")\n       if err != nil { t.Fatal(err) }\n       t.Cleanup(func() { os.Remove(f.Name()) })\n   }\n   ```\n\n2. **Parallelize safe tests with `t.Parallel()`:**\n   ```go\n   func TestParallel(t *testing.T) {\n       t.Parallel()  // Runs concurrently with other parallel tests\n       // Test code that doesn't share global state\n   }\n   ```\n\n3. **Use table-driven tests for multiple test cases:**\n   ```go\n   func TestNamespaceFlags(t *testing.T) {\n       tests := []struct{\n           name string\n           input []string\n           want int\n       }{\n           {\"PID only\", []string{\"pid\"}, syscall.CLONE_NEWPID},\n           {\"PID and NET\", []string{\"pid\", \"net\"}, syscall.CLONE_NEWPID | syscall.CLONE_NEWNET},\n       }\n       for _, tt := range tests {\n           t.Run(tt.name, func(t *testing.T) {\n               got := flagsFromNames(tt.input)\n               if got != tt.want {\n                   t.Errorf(\"got %v, want %v\", got, tt.want)\n               }\n           })\n       }\n   }\n   ```\n\n4. **Test CLI commands with `exec.Command`:**\n   ```go\n   func TestCLICommand(t *testing.T) {\n       cmd := exec.Command(\"./byod\", \"run\", \"alpine\", \"echo\", \"test\")\n       output, err := cmd.CombinedOutput()\n       if err != nil { t.Fatalf(\"command failed: %v\\n%s\", err, output) }\n       if !strings.Contains(string(output), \"test\") {\n           t.Errorf(\"unexpected output: %s\", output)\n       }\n   }\n   ```\n\n#### F. Milestone Checkpoint Validation Commands\n\nAfter completing each milestone, run these validation commands:\n\n**Milestone 1 Checkpoint:**\n```bash\n# Run namespace isolation tests\n$ sudo go test -v ./internal/namespaces/... -run TestPIDNamespace\n# Expected: All tests pass, showing PID isolation works\n\n# Manual verification\n$ sudo ./byod run --pid-isolation --uts-isolation test/fixtures/minimal-rootfs /bin/sh -c \"echo \\$\\$ && hostname\"\n# Expected: Outputs \"1\" and a hostname (not the host's)\n```\n\n**Milestone 2 Checkpoint:**\n```bash\n# Run cgroup integration tests\n$ sudo go test -v ./internal/cgroups/... -run TestMemoryLimit\n# Expected: Tests pass, showing OOM kill triggers\n\n# Manual verification of memory limit\n$ sudo ./byod run --memory 10m test/fixtures/minimal-rootfs /bin/sh -c \"tail /dev/zero\" &\n$ sleep 2\n$ dmesg | tail -5 | grep \"Memory cgroup out of memory\"\n# Expected: OOM killer message appears in dmesg\n```\n\n**Milestone 3 Checkpoint:**\n```bash\n# Run filesystem isolation tests\n$ sudo go test -v ./internal/filesystem/... -run TestPivotRoot\n# Expected: Tests pass, showing filesystem isolation\n\n# Manual verification\n$ sudo ./byod run --rootfs test/fixtures/busybox-rootfs /bin/ls /\n# Expected: Shows container root directory, not host root\n```\n\n**Milestone 4 Checkpoint:**\n```bash\n# Run OverlayFS tests\n$ sudo go test -v ./internal/filesystem/... -run TestOverlayMount\n# Expected: Tests pass, showing copy-on-write behavior\n\n# Manual verification\n$ sudo ./byod run alpine:latest /bin/sh -c \"echo test > /modified && ls /\"\n# Expected: File created successfully, visible in container\n```\n\n**Milestone 5 Checkpoint:**\n```bash\n# Run network tests\n$ sudo go test -v ./internal/network/... -run TestBridgeNetwork\n# Expected: Tests pass, showing network connectivity\n\n# Manual verification\n$ sudo ./byod run --network bridge alpine:latest ping -c 1 8.8.8.8\n# Expected: Ping successful (requires internet connection)\n```\n\n**Milestone 6 Checkpoint:**\n```bash\n# Run full system tests\n$ sudo go test -v ./tests/system/... -run TestContainerLifecycle\n# Expected: All tests pass, showing complete workflow\n\n# End-to-end validation\n$ sudo ./byod pull alpine:latest\n$ sudo ./byod run alpine:latest echo \"Hello, world!\"\n# Expected: Image downloads, container runs, outputs message\n```\n\n#### G. Debugging Tips for Tests\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Test passes locally but fails in CI** | Different kernel version, missing kernel features | Check kernel version, available cgroup controllers | Skip test if feature unavailable, document requirements |\n| **Tests leave orphaned resources** | Cleanup not running on test failure | Use `t.Cleanup()`, check `/proc/mounts`, `/sys/fs/cgroup` after test | Ensure cleanup runs even on panic, use defer with named return values |\n| **Intermittent test failures** | Race conditions, timing issues | Run with `-race` flag, add retries for eventual consistency | Use proper synchronization, increase timeouts for slow operations |\n| **Permission denied even as root** | AppArmor/SELinux restrictions, namespace permissions | Check audit logs (`dmesg`, `journalctl`), test in permissive mode | Adjust security policies, use correct flags for namespace operations |\n| **Network tests fail** | Firewall rules, network namespace leaks | List iptables rules, check network namespace count in `/proc` | Ensure proper cleanup, disable firewall temporarily for tests |\n| **Mount tests fail** | Mount propagation, shared subtrees | Check `/proc/self/mountinfo` for propagation flags | Use `MS_PRIVATE` or `MS_SLAVE` for test mounts |\n| **Cgroup tests fail on cgroup v2** | Different API, controller availability | Check cgroup version at `/sys/fs/cgroup/cgroup.controllers` | Implement both v1 and v2 support, detect and adapt |\n| **Image pull tests timeout** | Network issues, registry rate limiting | Check HTTP logs, use smaller test images | Mock registry for unit tests, use local image fixtures |\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones (debugging is essential throughout all implementation stages)\n\nDebugging a container runtime presents unique challenges because we're interacting with multiple Linux kernel subsystems that create complex, layered isolation boundaries. When something goes wrong, the symptoms can manifest in unexpected ways—processes failing to start, resource limits not being enforced, network connectivity issues, or mysterious permission errors. This guide provides a systematic approach to diagnosing and fixing common problems you'll encounter while building your container runtime. Think of debugging a container runtime as being a building superintendent who can't enter the apartments directly—you have to use specialized tools to inspect what's happening inside each isolated unit without breaking the isolation itself.\n\n### Symptom → Cause → Fix Tables\n\nThese tables map observable symptoms to their root causes and provide concrete fixes. They're organized by the milestone areas where problems typically occur.\n\n#### Namespace Isolation Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Process inside container can still see host processes** (ps, top show host PIDs) | PID namespace not properly set up or `/proc` not mounted in container's mount namespace | Run `ls -la /proc/self/ns/pid` inside container to check namespace ID; compare with host's PID namespace. Check if `/proc` is mounted with `mount \\| grep proc`. | Ensure `CLONE_NEWPID` flag is passed to `clone()` or `unshare()`. Use `pivot_root()` followed by mounting `/proc` inside the container with `mount(\"proc\", \"/proc\", \"proc\", 0, \"\")`. |\n| **Container cannot set its own hostname** (hostname command fails or shows host's hostname) | Missing `CLONE_NEWUTS` flag or UTS namespace not created | Check `/proc/self/ns/uts` inside container vs host. Try running `hostname newname`—if it succeeds but isn't isolated, UTS namespace is missing. | Add `CLONE_NEWUTS` to namespace creation flags. Verify the `sethostname()` syscall is called after namespace creation but before `execve()`. |\n| **Mount/unmount operations in container affect host filesystem** | Missing `CLONE_NEWNS` (mount namespace) flag | Create a temporary directory, mount a tmpfs inside container, then check if it appears on host with `mount \\| grep tmpfs`. | Ensure `CLONE_NEWNS` is included. Note: In Go, this is `syscall.CLONE_NEWNS` (all mount namespace operations use this single flag). |\n| **Container cannot create shared memory segments** | IPC namespace not isolated (`CLONE_NEWIPC` missing) | Try creating a shared memory segment with `shmget()` inside container and check if host processes can see it with `ipcs -m`. | Add `CLONE_NEWIPC` flag. Also ensure semaphore and message queue isolation if those are needed. |\n| **User ID mapping issues** (permission denied on files that should be accessible) | User namespace not set up or `/etc/passwd` not mapped correctly | Check `/proc/self/uid_map` and `/proc/self/gid_map` inside container. Verify files have correct ownership. | Implement user namespace with `CLONE_NEWUSER`, write appropriate mappings to `/proc/self/uid_map` and `/proc/self/gid_map` before executing container process. |\n| **Container process exits immediately with \"operation not permitted\"** | Insufficient capabilities when using namespaces | Check `dmesg \\| tail` for kernel capability warnings. Try running container runtime as root. | Grant necessary capabilities (CAP_SYS_ADMIN for mount operations, CAP_NET_ADMIN for network setup) or run as root during development. |\n\n#### cgroup Resource Limit Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Memory limit not enforced** (container uses more memory than specified) | Memory cgroup controller not enabled or limits written to wrong file | Check `/sys/fs/cgroup/memory/memory.limit_in_bytes` (v1) or `/sys/fs/cgroup/container-<id>/memory.max` (v2). Verify controller is available: `cat /proc/cgroups \\| grep memory`. | Ensure memory controller is mounted and available. Write limit in bytes to correct control file. For v2, also check `memory.swap.max`. |\n| **Container not OOM-killed when exceeding memory limit** | Memory limit set but OOM killer disabled or swap allowed | Check `memory.oom_control` (v1) or `memory.oom.group` (v2). Verify swap limit: `memory.memsw.limit_in_bytes` (v1) or `memory.swap.max` (v2). | Disable swap by setting swap limit equal to memory limit. Enable OOM killer: `echo 1 > memory.oom_control` (v1) or set `memory.oom.group` (v2). |\n| **CPU limit not respected** (container uses 100% CPU despite shares/quota) | CPU controller not enabled or wrong control files used | Check CPU usage via `top` or `cat /sys/fs/cgroup/cpu,cpuacct/cpuacct.usage`. Verify `cpu.shares` (v1) or `cpu.weight` (v2) values. | For v1, set `cpu.cfs_period_us` and `cpu.cfs_quota_us`. For v2, set `cpu.max` with format `max 100000`. |\n| **PIDs limit not working** (container can fork unlimited processes) | `pids` controller not enabled or limit not set | Check `pids.current` vs `pids.max` in cgroup directory. Verify controller is in `/proc/cgroups`. | Enable `pids` controller. Write limit to `pids.max` (both v1 and v2 use same interface). |\n| **cgroup cleanup fails** (\"device or resource busy\" error) | Processes still running in cgroup or subcgroups exist | Check `cgroup.procs` and `tasks` files for remaining PIDs. Look for nested cgroups: `ls /sys/fs/cgroup/memory/<container-id>/`. | Kill all processes in cgroup before removal. Use `cgdelete` or recursively remove subdirectories. |\n| **cgroup v2 vs v1 detection fails** | Hybrid or mixed hierarchy on system | Check `/proc/filesystems` for `cgroup2`. Examine mount points: `mount \\| grep cgroup`. | Use `CgroupManager.DetectCgroupInfo()` to detect version and available controllers. Support both versions with fallback. |\n\n#### Filesystem Isolation Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Container cannot see /proc or /sys** (ps, top fail) | `/proc` and `/sys` not mounted after `pivot_root()` | Run `mount \\| grep -E \"proc\\|sys\"` inside container. Check if directories exist in rootfs. | Call `MountProc()` and `MountSys()` after `pivot_root()` but before `execve()`. |\n| **Container can still access host filesystem** | `pivot_root()` succeeded but old root not unmounted | Check `mount \\| grep /oldroot` or try accessing `/oldroot/etc/passwd` from container. | Unmount old root with `MNT_DETACH`: `unmount(\"/oldroot\", MNT_DETACH)`. |\n| **Permission denied on device nodes** (`/dev/null`, `/dev/zero`) | Device nodes not created in container's `/dev` | Try `ls -la /dev/null` inside container. Check if major/minor numbers are correct. | Call `SetupDev()` to create basic device nodes with `mknod()` using appropriate major/minor numbers. |\n| **Container startup fails with \"no such file or directory\"** on binary | Rootfs missing shared libraries or binary not in `PATH` | Use `ldd` on binary inside rootfs to check missing libraries. Verify `PATH` environment variable. | Use complete rootfs from base image (alpine, ubuntu). Set correct `PATH` in `ContainerConfig.Env`. |\n| **Files created in container disappear after exit** | Using `chroot()` without mount namespace or wrong upperdir in OverlayFS | Check if files exist in upperdir of OverlayFS after container stops. Verify mount propagation. | Use `pivot_root()` with mount namespace. For OverlayFS, ensure writes go to upperdir and it's preserved. |\n| **Mount propagation doesn't work** (mounts in container not visible in sub-mounts) | Mount namespace setup with wrong propagation flags | Check `/proc/self/mountinfo` for propagation flags (`shared`, `private`, `slave`). | Set root mount as `MS_PRIVATE` before `pivot_root()`: `mount(\"\", \"/\", \"\", MS_REC\\|MS_PRIVATE, \"\")`. |\n\n#### OverlayFS Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **\"Invalid argument\" when mounting OverlayFS** | Missing lowerdir, upperdir, or workdir directories | Check `dmesg \\| tail` for kernel OverlayFS errors. Verify all directories exist with correct permissions. | Create lowerdir, upperdir, workdir directories before mount. Ensure workdir is empty. |\n| **File modifications not persisted** (writes disappear) | Upperdir not writable or OverlayFS mounted read-only | Check mount options: `mount \\| grep overlay`. Verify permissions on upperdir: `ls -ld upperdir`. | Ensure upperdir has write permissions. Include `lowerdir=...,upperdir=...,workdir=...` in mount options. |\n| **Whiteout files not working** (deleted files reappear) | Whiteout special files not created properly | Check upperdir for files with `chardev 0:0` (whiteout). Use `ls -la upperdir` and look for character devices. | When deleting files in container, create whiteout device in upperdir: `mknod(\"whiteout\", S_IFCHR, 0)`. |\n| **Copy-on-write causes high CPU/I/O** | Too many small files triggering copy-up | Monitor `cp` operations during container run. Check if upperdir grows unexpectedly. | This is expected behavior; consider using `nocopy` mount option for read-only lower layers where appropriate. |\n| **OverlayFS mount fails on certain filesystems** (e.g., NFS) | Underlying filesystem not supporting OverlayFS features | Check kernel logs: `dmesg \\| grep overlay`. Test with ext4 or xfs as backing filesystem. | Use supported filesystem (ext4, xfs, btrfs) for storage directory. |\n| **Multiple containers sharing layers cause conflicts** | Same upperdir used by multiple containers | Check if upperdir paths are unique per container. Verify containers don't share workdir. | Generate unique upperdir and workdir per container using container ID in path. |\n\n#### Container Networking Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Container has no network connectivity** (ping fails) | veth pair not set up correctly or no default route | Check interfaces inside container: `ip link show`. Verify default route: `ip route show`. | Ensure veth pair created, moved to container namespace, and configured with IP. Add default route to gateway. |\n| **Container cannot reach external internet** | NAT masquerading not configured | Check iptables rules: `iptables -t nat -L -n`. Verify `FORWARD` chain policy is `ACCEPT`. | Call `IPTablesManager.SetupMasquerade()` to add `POSTROUTING` masquerade rule. Enable IP forwarding: `echo 1 > /proc/sys/net/ipv4/ip_forward`. |\n| **Port forwarding not working** (can't connect to host port) | iptables rules missing or wrong interface | Check DNAT rules: `iptables -t nat -L PREROUTING -n`. Verify traffic reaches bridge interface. | Add rule with `IPTablesManager.AddPortForwarding()` that matches protocol, host port, and redirects to container IP:port. |\n| **DNS resolution fails inside container** | `/etc/resolv.conf` not configured | Try `nslookup google.com` inside container. Check `/etc/resolv.conf` contents. | Copy host's `/etc/resolv.conf` or create one with nameserver `8.8.8.8` in container rootfs before start. |\n| **Containers on same bridge cannot ping each other** | Bridge not set up or firewall blocking | Check bridge membership: `brctl show`. Verify containers have IPs in same subnet. | Ensure both veth ends are connected to same bridge. Disable firewall or add accept rules for bridge traffic. |\n| **Network namespace cleanup fails** (veth left on host) | veth not deleted when container stops | Check leftover veth interfaces: `ip link show \\| grep veth`. | Delete veth pair in host namespace during `NetworkManager.CleanupNetwork()`. |\n| **\"Network is unreachable\" for loopback** | Loopback interface not up in container | Check `ip link show lo` inside container—should be `UP`. | Bring loopback up: `ip link set lo up` inside network namespace. |\n\n#### Image and CLI Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Image pull fails with \"manifest not found\"** | Wrong image reference format or tag missing | Check image ref parsing. Verify tag exists on registry: `curl -L https://registry.hub.docker.com/v2/library/alpine/tags/list`. | Use standard format: `image:tag` (default to `latest`). Handle Docker Hub vs other registries. |\n| **Layer extraction fails with \"invalid tar header\"** | Corrupted layer download or wrong compression | Verify layer digest matches. Check file type: `file layer.tar`. | Use `ImageStore.StoreBlob()` which verifies digest. Support multiple compression formats (gzip, zstd). |\n| **Container starts but immediately exits** | Entrypoint command not found or fails | Check container logs (stdout/stderr). Verify `ImageConfig.Entrypoint` and `Cmd` are valid. | Provide fallback to `/bin/sh` if no command specified. Log exit code and signal. |\n| **State file corruption after crash** | Concurrent writes to container state or partial write | Check `ContainerStore.Save()` for atomic write pattern. Verify file permissions. | Use atomic file write: write to temp file then rename. Add file locking with `sync.Mutex`. |\n| **CLI command hangs indefinitely** | Container process waiting for input or deadlock | Check if process is running with `ps aux \\| grep <container-id>`. Look for open file descriptors. | Implement timeout for `StartCommand()`. Ensure stdin is properly handled (close or connect to terminal). |\n| **\"Container already exists\" error** | Container ID collision or stale state file | Check if container ID already in `StateManager.containers` map. Look for leftover directories. | Use UUID with `uuid.Generate()` for uniqueness. Clean up stale state on startup with orphan detection. |\n\n### Domain-Specific Debugging Techniques\n\nDebugging container runtimes requires specialized techniques that account for the layered isolation. These methods allow you to peer inside containers without breaking their isolation boundaries.\n\n#### The \"Inception\" Debugging Method\n\n> **Mental Model:** Think of debugging containers like the movie Inception—you need to enter nested dream levels (namespaces) to see what's really happening. But unlike the movie, you can use special kernel APIs to project yourself into these isolated spaces without actually entering them.\n\nThe key insight is that you can attach to namespaces from outside using `/proc` filesystem entries. Every process has a symbolic link for each namespace type at `/proc/<pid>/ns/<type>`. By opening these files, you can perform operations in the context of that namespace.\n\n**Technique 1: Inspecting Namespace Membership**\n```bash\n# From host, find container process PID\nCONTAINER_PID=$(pgrep -f \"container-id\")\n\n# Check which namespaces it's in\nls -la /proc/$CONTAINER_PID/ns/\n\n# Compare namespace IDs with host\nreadlink /proc/$CONTAINER_PID/ns/pid\nreadlink /proc/self/ns/pid\n```\nIf the namespace IDs match, isolation isn't working. Each namespace should have a unique ID.\n\n**Technique 2: Entering Network Namespace for Debugging**\n```bash\n# Use nsenter to run commands in container's network namespace\nnsenter --net=/proc/$CONTAINER_PID/ns/net ip addr show\nnsenter --net=/proc/$CONTAINER_PID/ns/net ping -c 3 8.8.8.8\n```\nThis lets you see exactly what network interfaces and routes the container sees.\n\n**Technique 3: Mount Namespace Inspection**\n```bash\n# View container's mount table from outside\nnsenter --mount=/proc/$CONTAINER_PID/ns/mnt mount\ncat /proc/$CONTAINER_PID/mountinfo | grep -v overlay\n```\nThe `mountinfo` file shows the complete mount tree with propagation flags.\n\n#### The \"Resource Accounting\" Audit\n\nWhen cgroups aren't working properly, you need to audit the entire resource control hierarchy.\n\n**Technique 4: cgroup Hierarchy Walk**\n```bash\n# For cgroup v2\nfind /sys/fs/cgroup -name \"container-*\" -type d | xargs -I {} sh -c 'echo {}; cat {}/cgroup.procs'\n\n# Check specific controller limits\ncat /sys/fs/cgroup/container-abc123/memory.max\ncat /sys/fs/cgroup/container-abc123/cpu.max\n```\n\n**Technique 5: Real-time Resource Monitoring**\n```bash\n# Watch memory usage of container\nwatch -n 1 'cat /sys/fs/cgroup/container-abc123/memory.current'\n\n# Monitor CPU usage via cpuacct\necho \"CPU usage (nanoseconds): $(cat /sys/fs/cgroup/container-abc123/cpu.stat | grep usage_usec)\"\n```\n\n#### The \"Filesystem Forensics\" Approach\n\nWhen filesystem isolation fails, you need to understand the exact mount hierarchy and where writes are actually going.\n\n**Technique 6: OverlayFS Layer Inspection**\n```bash\n# Find container's merged directory\nfind /var/lib/container-runtime -name \"merged\" -type d | grep container-id\n\n# Check what's in each layer\nls -la /var/lib/container-runtime/layers/sha256:abc123/\nls -la /var/lib/container-runtime/containers/container-id/upper/\n\n# See copy-on-write in action\nstrace -e openat,rename,unlink,write <container-process-pid> 2>&1 | grep -i overlay\n```\n\n**Technique 7: Bind Mount Debugging**\n```bash\n# Create a debug bind mount from host into container\nmkdir -p /tmp/container-debug\nmount --bind /proc/$CONTAINER_PID/root /tmp/container-debug\n\n# Now inspect container rootfs from host\nls -la /tmp/container-debug/\ncat /tmp/container-debug/etc/os-release\n\n# Clean up\numount /tmp/container-debug\n```\n\n#### The \"Network Packet Surgery\"\n\nFor networking issues, you need to trace packets through the entire network stack—from container interface to host bridge to external network.\n\n**Technique 8: Packet Tracing with tcpdump**\n```bash\n# Capture on container veth interface\ntcpdump -i vethabc123 -n -v\n\n# Capture on bridge interface\ntcpdump -i br0 -n -v\n\n# Capture in container namespace\nnsenter --net=/proc/$CONTAINER_PID/ns/net tcpdump -i eth0 -n -v\n```\n\n**Technique 9: iptables Rule Tracing**\n```bash\n# Add trace rule for specific traffic\niptables -t raw -A PREROUTING -p tcp --dport 80 -j TRACE\n\n# Watch kernel logs for trace output\ndmesg -w | grep TRACE\n\n# Check packet flow through chains\niptables -t nat -L -n -v\niptables -t filter -L -n -v\n```\n\n#### The \"Process Relationship Mapping\"\n\nUnderstanding parent-child relationships and process trees across namespaces is critical for PID namespace issues.\n\n**Technique 10: Cross-Namespace Process Tree**\n```bash\n# Show process tree with namespace contexts\nps ax -o pid,ppid,pgid,sid,tty,time,comm,ns --forest\n\n# Find all processes in specific PID namespace\nfor pid in $(ls /proc/ | grep '^[0-9]'); do\n  if [ -e /proc/$pid/ns/pid ]; then\n    ns=$(readlink /proc/$pid/ns/pid)\n    if [ \"$ns\" = \"$CONTAINER_NS\" ]; then\n      echo \"PID $pid is in container namespace\"\n      cat /proc/$pid/cmdline\n    fi\n  fi\ndone\n```\n\n### Tools for Inspecting System State\n\nThe Linux ecosystem provides powerful tools for inspecting the kernel state that underpins container isolation. Mastering these tools is essential for effective debugging.\n\n#### Namespace Inspection Tools\n\n| Tool | Purpose | Example Command | What It Reveals |\n|------|---------|----------------|-----------------|\n| **`lsns`** | List all namespaces on system | `lsns -t pid` | Shows PID namespaces with process counts and PIDs |\n| **`nsenter`** | Enter one or more namespaces | `nsenter -t $PID -m -u -n -p /bin/bash` | Spawns shell in container's combined namespaces |\n| **`unshare`** | Run program in new namespaces | `unshare --pid --fork --mount-proc=/proc /bin/bash` | Tests namespace creation independently of runtime |\n| **`/proc/<pid>/ns/`** | Namespace file descriptors | `readlink /proc/self/ns/mnt` | Gets namespace ID for comparison |\n| **`/proc/<pid>/status`** | Namespace membership | `grep NSpid /proc/$PID/status` | Shows PID in each ancestor PID namespace |\n\n#### cgroup Inspection Tools\n\n| Tool | Purpose | Example Command | What It Reveals |\n|------|---------|----------------|-----------------|\n| **`systemd-cgls`** | Show cgroup hierarchy | `systemd-cgls -u` | Visual tree of cgroups and their processes |\n| **`systemd-cgtop`** | Resource usage per cgroup | `systemd-cgtop` | Real-time CPU/memory usage by cgroup |\n| **`cgget`** | Get cgroup parameters | `cgget -g memory:container-id` | Reads control file values for specific cgroup |\n| **`cat /proc/cgroups`** | List available controllers | `cat /proc/cgroups` | Shows which controllers are enabled and hierarchy count |\n| **`findmnt cgroup`** | Find cgroup mount points | `findmnt -t cgroup2` | Shows where cgroup filesystems are mounted |\n\n#### Filesystem Inspection Tools\n\n| Tool | Purpose | Example Command | What It Reveals |\n|------|---------|----------------|-----------------|\n| **`findmnt`** | Show mount tree | `findmnt -R /var/lib/container-runtime` | Complete mount hierarchy with options and propagation |\n| **`mount`** | List mounted filesystems | `mount \\| grep overlay` | All active mounts with their types and options |\n| **`lsof`** | List open files | `lsof +D /var/lib/container-runtime/containers/` | Which processes have files open in container directories |\n| **`strace`** | Trace system calls | `strace -f -e mount,pivot_root,chdir <pid>` | Exact sequence of filesystem operations performed |\n| **`inotifywait`** | Monitor filesystem events | `inotifywait -rm /var/lib/container-runtime/` | Real-time notifications of file creation, deletion, modification |\n\n#### Network Inspection Tools\n\n| Tool | Purpose | Example Command | What It Reveals |\n|------|---------|----------------|-----------------|\n| **`ip netns`** | Network namespace management | `ip netns list` | All network namespaces and their associated PIDs |\n| **`ip link`** | Network interface listing | `ip -o link show \\| grep veth` | All veth interfaces and their peer indices |\n| **`bridge`** | Bridge management | `bridge link show` | Which interfaces are connected to bridges |\n| **`conntrack`** | Connection tracking | `conntrack -L \\| grep container-ip` | NAT translations and connection states |\n| **`ss`** | Socket statistics | `ss -tulpn \\| grep $CONTAINER_PID` | Open ports and sockets in container |\n\n#### Process and Container-Specific Tools\n\n| Tool | Purpose | Example Command | What It Reveals |\n|------|---------|----------------|-----------------|\n| **`pstree`** | Process tree visualization | `pstree -p $CONTAINER_PID` | Parent-child relationships across namespaces |\n| **`cat /proc/<pid>/cgroup`** | Process cgroup membership | `cat /proc/$PID/cgroup` | Which cgroups the process belongs to for each controller |\n| **`cat /proc/<pid>/mountinfo`** | Process mount namespace | `cat /proc/$PID/mountinfo \\| head -20` | Mount points visible to the process with IDs and options |\n| **`capsh`** | Capability inspection | `capsh --decode=$(cat /proc/$PID/status \\| grep CapEff \\| awk '{print $2}')` | Effective capabilities of the process |\n| **`runc`** | Reference OCI runtime | `runc events container-id` | Container lifecycle events from reference implementation |\n\n#### Custom Debugging Utilities for Your Runtime\n\nYou should build these debugging aids directly into your container runtime:\n\n1. **Debug Mode Flag**: Add `--debug` flag to CLI that enables verbose logging of all system calls and operations.\n\n2. **Inspection Subcommands**:\n   - `container-runtime inspect <container-id>`: Show complete container state including namespace IDs, cgroup paths, mount points, and network configuration.\n   - `container-runtime debug exec <container-id> <command>`: Execute command in container namespaces without starting the container process.\n   - `container-runtime logs <container-id>`: Capture and display stdout/stderr from container process.\n\n3. **State Dump on Failure**: When a container fails to start, automatically dump:\n   - Current namespace IDs\n   - cgroup hierarchy\n   - Mount table\n   - Network interfaces\n   - Last 20 lines of kernel log (`dmesg`)\n\n4. **Orphan Detection Cleanup**: Periodically scan for resources (cgroups, network namespaces, mount points) that don't have corresponding container state records and clean them up.\n\n> **Key Insight:** The most powerful debugging technique is building observability directly into your runtime. Instrument every major operation with structured logging that includes the container ID, namespace IDs, and resource paths. When something fails, you'll have a complete audit trail of what was attempted and where it went wrong.\n\n### Implementation Guidance\n\nThis subsection provides practical implementation guidance for adding debugging capabilities to your container runtime.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Logging** | Structured logging with `logrus` or `zap` | OpenTelemetry tracing with Jaeger |\n| **Inspection** | CLI commands using `nsenter` and `cgget` | HTTP API with WebSocket for real-time metrics |\n| **Tracing** | `strace` wrapper for system call tracing | eBPF-based tracing with `bcc` tools |\n| **Metrics** | Reading cgroup stats files directly | Prometheus metrics exporter |\n\n#### Recommended File/Module Structure\n\n```\nproject-root/\n  cmd/\n    container-runtime/\n      main.go              # CLI entry point with debug flags\n      debug.go             # Debug subcommands implementation\n  internal/\n    debug/\n      inspector.go         # Container state inspection logic\n      tracer.go            # System call tracing wrapper\n      metrics.go           # Metrics collection from cgroups\n    runtime/\n      container.go         # Add debug methods to Container type\n      manager.go           # Add inspection methods to ContainerRuntime\n    utils/\n      nsenter.go           # Wrapper for nsenter operations\n      cgroup-inspect.go    # cgroup inspection utilities\n```\n\n#### Infrastructure Starter Code\n\nHere's a complete, ready-to-use debugging inspector that can be integrated into your runtime:\n\n```go\n// internal/debug/inspector.go\npackage debug\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n    \"syscall\"\n\n    \"github.com/sirupsen/logrus\"\n)\n\n// ContainerInspector provides methods to inspect container state\ntype ContainerInspector struct {\n    basePath string\n    logger   *logrus.Logger\n}\n\n// NewContainerInspector creates a new inspector instance\nfunc NewContainerInspector(basePath string) *ContainerInspector {\n    return &ContainerInspector{\n        basePath: basePath,\n        logger:   logrus.New(),\n    }\n}\n\n// InspectContainer gathers comprehensive debugging information about a container\nfunc (ci *ContainerInspector) InspectContainer(containerID string) (map[string]interface{}, error) {\n    info := make(map[string]interface{})\n    \n    // Basic container info\n    info[\"container_id\"] = containerID\n    info[\"timestamp\"] = time.Now().Format(time.RFC3339)\n    \n    // Try to find container process\n    pid, err := ci.findContainerPID(containerID)\n    if err != nil {\n        ci.logger.Warnf(\"Could not find container process: %v\", err)\n    } else {\n        info[\"pid\"] = pid\n        \n        // Collect namespace information\n        nsInfo, err := ci.collectNamespaceInfo(pid)\n        if err != nil {\n            ci.logger.Warnf(\"Could not collect namespace info: %v\", err)\n        } else {\n            info[\"namespaces\"] = nsInfo\n        }\n        \n        // Collect cgroup information\n        cgroupInfo, err := ci.collectCgroupInfo(pid)\n        if err != nil {\n            ci.logger.Warnf(\"Could not collect cgroup info: %v\", err)\n        } else {\n            info[\"cgroups\"] = cgroupInfo\n        }\n        \n        // Collect mount information\n        mountInfo, err := ci.collectMountInfo(pid)\n        if err != nil {\n            ci.logger.Warnf(\"Could not collect mount info: %v\", err)\n        } else {\n            info[\"mounts\"] = mountInfo\n        }\n    }\n    \n    // Collect container filesystem information\n    fsInfo, err := ci.collectFilesystemInfo(containerID)\n    if err != nil {\n        ci.logger.Warnf(\"Could not collect filesystem info: %v\", err)\n    } else {\n        info[\"filesystem\"] = fsInfo\n    }\n    \n    // Collect network information\n    netInfo, err := ci.collectNetworkInfo(containerID)\n    if err != nil {\n        ci.logger.Warnf(\"Could not collect network info: %v\", err)\n    } else {\n        info[\"network\"] = netInfo\n    }\n    \n    return info, nil\n}\n\n// findContainerPID searches for the container's main process\nfunc (ci *ContainerInspector) findContainerPID(containerID string) (int, error) {\n    // Check in container state directory\n    statePath := filepath.Join(ci.basePath, \"containers\", containerID, \"state.json\")\n    if _, err := os.Stat(statePath); err == nil {\n        data, err := ioutil.ReadFile(statePath)\n        if err != nil {\n            return 0, err\n        }\n        \n        var state struct {\n            Pid int `json:\"pid\"`\n        }\n        if err := json.Unmarshal(data, &state); err != nil {\n            return 0, err\n        }\n        \n        if state.Pid > 0 {\n            // Verify process still exists\n            if _, err := os.Stat(filepath.Join(\"/proc\", fmt.Sprintf(\"%d\", state.Pid))); err == nil {\n                return state.Pid, nil\n            }\n        }\n    }\n    \n    // Fallback: search through all processes\n    return ci.scanProcessesForContainer(containerID)\n}\n\n// collectNamespaceInfo reads namespace IDs from /proc/<pid>/ns/\nfunc (ci *ContainerInspector) collectNamespaceInfo(pid int) (map[string]string, error) {\n    nsInfo := make(map[string]string)\n    nsTypes := []string{\"pid\", \"mnt\", \"net\", \"uts\", \"ipc\", \"user\"}\n    \n    for _, nsType := range nsTypes {\n        nsPath := filepath.Join(\"/proc\", fmt.Sprintf(\"%d\", pid), \"ns\", nsType)\n        target, err := os.Readlink(nsPath)\n        if err != nil {\n            return nil, err\n        }\n        nsInfo[nsType] = target\n    }\n    \n    return nsInfo, nil\n}\n\n// DumpToFile writes inspection results to a JSON file\nfunc (ci *ContainerInspector) DumpToFile(containerID string, outputPath string) error {\n    info, err := ci.InspectContainer(containerID)\n    if err != nil {\n        return err\n    }\n    \n    data, err := json.MarshalIndent(info, \"\", \"  \")\n    if err != nil {\n        return err\n    }\n    \n    return ioutil.WriteFile(outputPath, data, 0644)\n}\n```\n\n#### Core Logic Skeleton Code\n\nHere's skeleton code for adding debug commands to your CLI:\n\n```go\n// cmd/container-runtime/debug.go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \n    \"github.com/spf13/cobra\"\n    \"your-project/internal/debug\"\n    \"your-project/internal/runtime\"\n)\n\n// NewDebugCommand creates the debug command tree\nfunc NewDebugCommand(r *runtime.ContainerRuntime) *cobra.Command {\n    cmd := &cobra.Command{\n        Use:   \"debug\",\n        Short: \"Debugging commands for container inspection\",\n        Long:  \"Commands to inspect container state, namespaces, cgroups, and other low-level details\",\n    }\n    \n    cmd.AddCommand(\n        newDebugInspectCommand(r),\n        newDebugExecCommand(r),\n        newDebugLogsCommand(r),\n        newDebugTraceCommand(r),\n    )\n    \n    return cmd\n}\n\n// newDebugInspectCommand creates the inspect subcommand\nfunc newDebugInspectCommand(r *runtime.ContainerRuntime) *cobra.Command {\n    return &cobra.Command{\n        Use:   \"inspect [container-id]\",\n        Short: \"Inspect container state and configuration\",\n        Args:  cobra.ExactArgs(1),\n        RunE: func(cmd *cobra.Command, args []string) error {\n            containerID := args[0]\n            \n            // TODO 1: Get the container from runtime state manager\n            // container, err := r.GetContainer(containerID)\n            // if err != nil { return fmt.Errorf(\"container not found: %v\", err) }\n            \n            // TODO 2: Create a ContainerInspector instance\n            // inspector := debug.NewContainerInspector(r.StorePath())\n            \n            // TODO 3: Collect inspection data\n            // info, err := inspector.InspectContainer(containerID)\n            // if err != nil { return fmt.Errorf(\"inspection failed: %v\", err) }\n            \n            // TODO 4: Output as JSON or formatted text based on --format flag\n            // if jsonOutput { json.NewEncoder(os.Stdout).Encode(info) }\n            // else { printFormattedInfo(info) }\n            \n            // TODO 5: If --output flag specified, write to file\n            // if outputFile != \"\" { inspector.DumpToFile(containerID, outputFile) }\n            \n            return nil\n        },\n    }\n}\n\n// newDebugExecCommand creates the exec subcommand for debugging\nfunc newDebugExecCommand(r *runtime.ContainerRuntime) *cobra.Command {\n    return &cobra.Command{\n        Use:   \"exec [container-id] [command]\",\n        Short: \"Execute command in container namespaces\",\n        Long:  \"Run a command in the container's namespaces for debugging purposes\",\n        Args:  cobra.MinimumNArgs(2),\n        RunE: func(cmd *cobra.Command, args []string) error {\n            containerID := args[0]\n            command := args[1:]\n            \n            // TODO 1: Get container process PID\n            // pid, err := getContainerPID(containerID)\n            // if err != nil { return err }\n            \n            // TODO 2: Build namespace paths\n            // nsPaths := []string{\n            //     fmt.Sprintf(\"/proc/%d/ns/pid\", pid),\n            //     fmt.Sprintf(\"/proc/%d/ns/mnt\", pid),\n            //     fmt.Sprintf(\"/proc/%d/ns/net\", pid),\n            // }\n            \n            // TODO 3: Use nsenter to execute command in those namespaces\n            // cmd := exec.Command(\"nsenter\", append([]string{\"-t\", fmt.Sprintf(\"%d\", pid), \"--mount\", \"--net\", \"--pid\"}, command...)...)\n            // cmd.Stdin = os.Stdin\n            // cmd.Stdout = os.Stdout\n            // cmd.Stderr = os.Stderr\n            // return cmd.Run()\n            \n            return nil\n        },\n    }\n}\n```\n\n#### Language-Specific Hints\n\n- **Go-specific tips for debugging:**\n  - Use `syscall.PtraceAttach()` and `syscall.PtraceDetach()` for low-level process tracing\n  - The `os/exec` package's `Cmd.SysProcAttr` field lets you set namespace flags for child processes\n  - Use `gops` (Go process inspector) to debug the runtime itself: `import \"github.com/google/gops/agent\"`\n  - For logging, use structured logging with fields: `logrus.WithField(\"container_id\", containerID).Error(\"Failed to start\")`\n  - Use `runtime.Caller()` to add stack trace information to error messages\n\n- **System call tracing in Go:**\n  ```go\n  // Wrap system calls with logging\n  func tracedSyscall(name string, fn func() error) error {\n      logrus.WithField(\"syscall\", name).Debug(\"Enter\")\n      start := time.Now()\n      err := fn()\n      elapsed := time.Since(start)\n      logrus.WithFields(logrus.Fields{\n          \"syscall\": name,\n          \"elapsed\": elapsed,\n          \"error\":   err,\n      }).Debug(\"Exit\")\n      return err\n  }\n  \n  // Usage\n  tracedSyscall(\"pivot_root\", func() error {\n      return syscall.PivotRoot(newroot, putold)\n  })\n  ```\n\n#### Milestone Checkpoint\n\nAfter implementing debugging features, verify them with these tests:\n\n1. **Basic Inspection Test:**\n   ```bash\n   # Start a container\n   ./container-runtime run alpine echo \"hello\"\n   \n   # Get the container ID from output or list\n   CONTAINER_ID=$(./container-runtime list | awk 'NR==2 {print $1}')\n   \n   # Inspect it\n   ./container-runtime debug inspect $CONTAINER_ID --format json\n   \n   # Expected: JSON output with namespace IDs, cgroup paths, mount points\n   # If empty or error, check that the inspector can find the container process\n   ```\n\n2. **Namespace Debugging Test:**\n   ```bash\n   # Start a container with network\n   ./container-runtime run --network bridge alpine sleep 60 &\n   \n   # Inspect network namespace\n   ./container-runtime debug inspect $CONTAINER_ID | grep -A5 \"network\"\n   \n   # Expected: Shows network namespace ID, interfaces, IP address\n   # If missing, check /proc/<pid>/ns/net exists and is readable\n   ```\n\n3. **Filesystem Debugging Test:**\n   ```bash\n   # Create a file in container\n   ./container-runtime run alpine sh -c \"echo test > /tmp/debug.txt\"\n   \n   # Inspect filesystem layers\n   ./container-runtime debug inspect $CONTAINER_ID | grep -A10 \"filesystem\"\n   \n   # Expected: Shows overlayfs layers, upperdir path, merged view\n   # Check that upperdir exists and contains the debug.txt file\n   ```\n\n#### Debugging Tips Implementation\n\nAdd these debugging helpers directly to your components:\n\n```go\n// internal/runtime/manager.go (add to ContainerRuntime)\nfunc (r *ContainerRuntime) EnableDebugLogging() {\n    r.debugMode = true\n    // TODO: Set verbose logging for all components\n    // TODO: Enable system call tracing\n    // TODO: Log all state transitions\n}\n\nfunc (r *ContainerRuntime) CollectDebugInfo(containerID string) (string, error) {\n    // TODO: Gather dmesg output\n    // TODO: Capture iptables rules\n    // TODO: Dump cgroup hierarchies\n    // TODO: Save to timestamped debug directory\n    return debugDir, nil\n}\n```\n\nRemember to build debugging capabilities incrementally—start with basic inspection commands, then add more sophisticated tracing as you encounter specific problems. The most valuable debugging tool is the one you build to solve your current problem.\n\n\n## Future Extensions\n\n> **Milestone(s):** All milestones (future extensions build upon the foundation established by all six implementation milestones)\n\nThis section explores potential enhancements to our container runtime beyond the core implementation. While the current design provides a functional container runtime with all essential isolation primitives, real-world container systems include numerous additional features for security, usability, and production readiness. Understanding these extensions helps contextualize how our educational implementation compares to production systems like Docker and Kubernetes, and provides a roadmap for continued learning.\n\n### Potential Enhancement Ideas\n\nThe following extensions represent natural evolution points for the container runtime, categorized by their primary focus area:\n\n#### Security Hardening\n\n**User Namespace Support**: Currently, our container runs with the same user privileges as the host process (typically root). User namespaces would allow mapping host user IDs to different user IDs within the container, enabling containers to run as \"root\" inside while being non-root on the host.\n\n**Seccomp BPF Filters**: System call filtering using seccomp would restrict the container's ability to make dangerous system calls (like `reboot`, `mount`, or `ptrace`), significantly reducing the attack surface.\n\n**Capabilities Management**: Instead of running containers with all Linux capabilities, we could drop dangerous capabilities (like `CAP_SYS_ADMIN`, `CAP_NET_RAW`) and grant only necessary ones based on the container's purpose.\n\n**SELinux/AppArmor Integration**: Mandatory Access Control (MAC) systems provide additional security boundaries beyond namespace isolation, enforcing fine-grained policies on file access, network operations, and process interactions.\n\n#### Container Orchestration Features\n\n**Container Health Checks**: Periodic execution of user-defined health check commands within the container, with automatic container restart if checks fail repeatedly.\n\n**Logging Driver Infrastructure**: Support for multiple logging backends (syslog, journald, fluentd) with configurable log rotation, formatting, and aggregation.\n\n**Metrics Collection**: Automatic collection and export of container resource usage statistics (CPU, memory, network, block I/O) via cgroup metrics and process monitoring.\n\n**Container Dependency Management**: Start order coordination for containers that depend on services provided by other containers (e.g., database container must be ready before web application container).\n\n#### Storage and Networking Enhancements\n\n**Volume Management**: First-class support for persistent storage volumes with configurable drivers (local directories, NFS, cloud storage) and lifecycle management.\n\n**Network Plugins**: Extensible network architecture supporting multiple network drivers (bridge, host, macvlan, ipvlan, overlay networks) via a plugin interface.\n\n**IPv6 Support**: Full dual-stack IPv4/IPv6 networking with proper address allocation, routing, and firewall rules for IPv6.\n\n**Service Discovery**: Built-in DNS-based service discovery allowing containers to find each other by name without static IP configuration.\n\n#### Usability and Production Features\n\n**Container Pause/Resume**: Support for freezing and thawing container execution using cgroup freezer controller, enabling live migration scenarios and debugging.\n\n**Container Checkpoint/Restore**: Save container state to disk and restore it later, possibly on a different host, using CRIU (Checkpoint/Restore In Userspace).\n\n**Build System**: Dockerfile-like build system for creating container images from source code with layer caching and dependency tracking.\n\n**Registry Authentication**: Support for authenticated access to private container registries with token-based authentication and credential storage.\n\n**Windows Container Support**: Cross-platform runtime supporting Windows containers using Windows-native isolation primitives (job objects, namespace, Hyper-V isolation).\n\nThe following table compares these enhancements by their implementation complexity and educational value:\n\n| Enhancement | Implementation Complexity | Educational Value | Production Relevance |\n|-------------|---------------------------|-------------------|---------------------|\n| User Namespace Support | Medium | High (deepens namespace understanding) | Critical |\n| Seccomp BPF Filters | Low-Medium | Medium (system call security) | Critical |\n| Volume Management | Medium | High (storage architecture) | Critical |\n| Network Plugins | High | Medium (plugin architecture) | High |\n| Health Checks | Low | Low (orchestration patterns) | High |\n| Container Pause/Resume | Low | Medium (cgroup freezer) | Medium |\n| Build System | High | High (image construction) | Critical |\n| Checkpoint/Restore | High | High (process state serialization) | Medium |\n\n#### Architecture Decision: Incremental vs. Complete Rewrite\n\n> **Decision: Incremental Enhancement Strategy**\n> - **Context**: As an educational project, we want to maximize learning while maintaining a codebase that can evolve. Some enhancements require significant architectural changes that might conflict with the current simple design.\n> - **Options Considered**:\n>   1. **Incremental additions**: Add features to the existing codebase with minimal refactoring\n>   2. **Modular plugin architecture**: Refactor core components to support pluggable implementations\n>   3. **Complete rewrite**: Start fresh with a more extensible architecture incorporating lessons learned\n> - **Decision**: Use incremental additions for simple enhancements and a gradual move toward plugin architecture for complex subsystems (networking, storage).\n> - **Rationale**: The educational value comes from understanding the underlying Linux primitives, not building enterprise-grade extensibility. Incremental additions allow focused learning on specific features without overwhelming complexity. However, introducing plugin interfaces for networking and storage teaches important architectural patterns.\n> - **Consequences**: Some refactoring will be needed when adding certain features, but the core isolation logic remains stable. The codebase may become slightly less elegant but remains approachable for learners.\n\n### Design Accommodations for Extensions\n\nThe current design includes several intentional accommodations that make future extensions easier. However, some enhancements require significant architectural changes.\n\n#### Security Hardening Accommodations\n\n**Current Design Accommodations**:\n- The `ContainerConfig` type includes fields for security settings that are currently unimplemented\n- The `NamespaceManager.CreateNamespaces` method accepts flags as a bitmask, making it easy to add `CLONE_NEWUSER`\n- The cleanup stack pattern ensures resources are properly released even when security features fail\n\n**Required Modifications for User Namespaces**:\n\n| Component | Current State | Required Changes |\n|-----------|---------------|------------------|\n| `NamespaceManager` | Supports PID, UTS, mount, network, IPC namespaces | Add `CLONE_NEWUSER` support and uid/gid mapping |\n| `ContainerConfig` | Has basic security fields | Add `UserNamespaceConfig` with uidMaps and gidMaps |\n| `FilesystemManager` | Assumes root access for mount operations | Handle file ownership when running as non-root user |\n| CLI | No user namespace flags | Add `--user` flag and uid/gid mapping options |\n\n**Implementation Approach**:\n1. Add `UserNamespaceConfig` to `ContainerConfig` with slice of `UIDMap` and `GIDMap` structs\n2. Modify `NamespaceManager.CreateNamespaces` to handle `CLONE_NEWUSER` flag\n3. Write uid/gid maps to `/proc/[pid]/uid_map` and `/proc/[pid]/gid_map` after clone\n4. Update `FilesystemManager` to use `syscall.Chown` for critical directories when running mapped\n\n**Seccomp Integration Strategy**:\n```go\n// Current ContainerConfig would expand to include:\ntype SecurityConfig struct {\n    SeccompProfile  *SeccompProfile `json:\"seccomp,omitempty\"`\n    AppArmorProfile string          `json:\"apparmor,omitempty\"`\n    Capabilities    *Capabilities   `json:\"capabilities,omitempty\"`\n    NoNewPrivileges bool            `json:\"noNewPrivileges,omitempty\"`\n    ReadonlyRootfs  bool            `json:\"readonlyRootfs,omitempty\"`\n}\n```\n\n#### Storage System Extensions\n\n**Volume Management Architecture**:\n\nThe current filesystem isolation uses OverlayFS for the root filesystem but lacks persistent volume support. A volume system would require:\n\n1. **Volume Abstraction Layer**: Interface defining volume operations (create, mount, unmount, delete)\n2. **Volume Drivers**: Pluggable implementations for different storage backends\n3. **Volume Lifecycle**: Integration with container lifecycle (mount before start, unmount after stop)\n4. **Volume Specification**: Extended `ContainerConfig` to declare volume mounts\n\n**Proposed Volume Data Model**:\n```go\ntype VolumeMount struct {\n    Source      string   // Volume name or host path\n    Destination string   // Container path\n    Type        string   // \"bind\", \"volume\", \"tmpfs\"\n    Options     []string // \"ro\", \"rw\", \"z\", \"Z\"\n}\n\ntype VolumeDriver interface {\n    Create(name string, opts map[string]string) (Volume, error)\n    Remove(name string) error\n    Mount(name string) (string, error)  // returns mount path\n    Unmount(name string) error\n}\n\ntype VolumeManager struct {\n    drivers map[string]VolumeDriver\n    volumes map[string]Volume\n}\n```\n\n**Integration Points**:\n- Modify `FilesystemManager.SetupRootfs` to handle volume mounts after rootfs setup\n- Extend `ContainerRuntime.createContainerSequence` to call volume mounting in phase 4 (filesystem preparation)\n- Add volume cleanup to `CleanupManager` for proper resource cleanup\n\n#### Networking Plugin Architecture\n\n**Current Network Limitations**:\nThe `NetworkManager` implements a single bridge network driver hardcoded into the component. A plugin architecture would allow multiple network types (host, none, macvlan, overlay).\n\n**Proposed Plugin Interface**:\n```go\ntype NetworkDriver interface {\n    CreateNetwork(name string, opts map[string]interface{}) (Network, error)\n    DeleteNetwork(name string) error\n    SetupContainerNetwork(containerID string, netnsPath string, config NetworkConfig) error\n    TeardownContainerNetwork(containerID string, netnsPath string, config NetworkConfig) error\n}\n\ntype NetworkManager struct {\n    drivers   map[string]NetworkDriver\n    ipam      *IPAM\n    // ... existing fields\n}\n\nfunc (nm *NetworkManager) RegisterDriver(name string, driver NetworkDriver) {\n    nm.drivers[name] = driver\n}\n```\n\n**Required Refactoring**:\n1. Extract current bridge network logic into `BridgeDriver` implementing `NetworkDriver`\n2. Modify `NetworkManager.SetupNetwork` to delegate to the appropriate driver based on `NetworkConfig.Mode`\n3. Add driver discovery and loading mechanism (static compilation or dynamic loading)\n4. Update CLI to support network driver selection via `--network` flag\n\n**Network Configuration Evolution**:\n```go\n// Current NetworkConfig\ntype NetworkConfig struct {\n    Mode         string        `json:\"mode\"`           // \"bridge\", \"host\", \"none\"\n    BridgeName   string        `json:\"bridgeName\"`     // \"byod-bridge\"\n    IPAddress    string        `json:\"ipAddress\"`      // \"10.0.0.2\"\n    PortMappings []PortMapping `json:\"portMappings\"`   // port forwards\n}\n\n// Enhanced NetworkConfig with plugin support\ntype NetworkConfig struct {\n    Driver       string                 `json:\"driver\"`       // \"bridge\", \"macvlan\", \"overlay\"\n    NetworkName  string                 `json:\"networkName\"`  // \"byod-network\"\n    Options      map[string]interface{} `json:\"options\"`      // driver-specific options\n    IPAddress    string                 `json:\"ipAddress\"`     // optional override\n    PortMappings []PortMapping          `json:\"portMappings\"`\n}\n```\n\n#### Orchestration Features Integration\n\n**Health Check Implementation**:\n\nHealth checks require periodic execution of commands within the container and state tracking:\n\n```go\ntype HealthCheckConfig struct {\n    Test        []string      `json:\"test\"`        // [\"CMD\", \"curl\", \"-f\", \"http://localhost/health\"]\n    Interval    time.Duration `json:\"interval\"`    // 30s\n    Timeout     time.Duration `json:\"timeout\"`     // 30s\n    StartPeriod time.Duration `json:\"startPeriod\"` // 0s\n    Retries     int           `json:\"retries\"`     // 3\n}\n\ntype ContainerHealth struct {\n    Status      string    `json:\"status\"`      // \"starting\", \"healthy\", \"unhealthy\"\n    FailingStreak int     `json:\"failingStreak\"`\n    Log         []HealthCheckResult `json:\"log\"`\n}\n\ntype HealthMonitor struct {\n    containers map[string]*ContainerHealthTracker\n    executor   HealthCheckExecutor\n    mu         sync.RWMutex\n}\n```\n\n**Integration Challenges**:\n1. **Namespace Access**: Health check commands must execute within the container's namespaces\n2. **Resource Isolation**: Health checks should respect container resource limits\n3. **State Management**: Health status must be stored and accessible via CLI/API\n4. **Automatic Remediation**: Unhealthy containers might need automatic restart\n\n**Design Accommodation**: The current `ContainerRuntime` tracks container state but would need to extend `Container` struct with health fields and add a background monitoring goroutine.\n\n#### Metrics Collection System\n\n**Current Capabilities**: The `CgroupManager.GetStats` method already collects basic resource usage statistics. This could be extended and exposed.\n\n**Enhanced Metrics Architecture**:\n```go\ntype ContainerMetrics struct {\n    Timestamp   time.Time              `json:\"timestamp\"`\n    CPU         CPUMetrics             `json:\"cpu\"`\n    Memory      MemoryMetrics          `json:\"memory\"`\n    BlockIO     BlockIOMetrics         `json:\"blockIO\"`\n    Network     NetworkMetrics         `json:\"network\"`\n    PIDs        PIDMetrics             `json:\"pids\"`\n}\n\ntype MetricsCollector struct {\n    cgroupManager *CgroupManager\n    networkManager *NetworkManager\n    interval      time.Duration\n    subscribers   []MetricsSubscriber\n    containers    map[string]*ContainerMetricsHistory\n}\n\ntype MetricsSubscriber interface {\n    OnMetrics(containerID string, metrics ContainerMetrics)\n}\n```\n\n**Integration Points**:\n1. Extend `CgroupManager.GetStats` to collect additional metrics (throttling, pressure)\n2. Add network statistics collection via `/sys/class/net` or netlink\n3. Create metrics aggregation goroutine in `ContainerRuntime`\n4. Add CLI command `byod stats` to display live metrics\n5. Optional: Export metrics via Prometheus endpoint or OpenMetrics format\n\n#### Build System Implementation\n\n**Current Image Handling**: The runtime pulls and extracts existing images but doesn't build them from source.\n\n**Build System Components**:\n\n| Component | Responsibility | Integration Points |\n|-----------|----------------|-------------------|\n| Dockerfile Parser | Parse build instructions into execution graph | Standalone component, outputs build spec |\n| Layer Builder | Execute build steps, creating new layers | Uses `FilesystemManager` for layer creation |\n| Build Cache | Cache intermediate layers for faster rebuilds | Integrates with `LayerCache` |\n| Image Assembler | Create final image manifest and config | Uses `ImageStore` to save final image |\n\n**Build Process Flow**:\n1. Parse Dockerfile into sequence of build stages\n2. For each stage, start with base image or scratch\n3. Execute instructions (RUN, COPY, ADD, etc.) in temporary container\n4. Commit each successful step as a new layer\n5. Apply layer to next step (like OverlayFS during build)\n6. Finalize image with metadata and entrypoint\n\n**Key Technical Challenge**: The build process needs to execute commands in isolated environments (containers) but also needs to copy files between build stages and host. This requires temporary container creation and filesystem snapshotting after each step.\n\n#### Windows Container Support\n\n**Architectural Implications**: Windows containers use fundamentally different isolation primitives, requiring a complete abstraction layer.\n\n**Proposed Platform Abstraction**:\n```go\ntype IsolationProvider interface {\n    CreateIsolatedProcess(config ProcessConfig) (IsolatedProcess, error)\n    SetupFilesystem(rootfs string, layers []string) (string, error)\n    SetupNetwork(netConfig NetworkConfig) (NetworkEndpoint, error)\n    ApplyResourceLimits(pid int, limits ResourceLimits) error\n    GetStats(pid int) (ResourceStats, error)\n}\n\ntype LinuxIsolationProvider struct {\n    // Uses namespaces, cgroups, pivot_root\n}\n\ntype WindowsIsolationProvider struct {\n    // Uses job objects, silos, Windows namespace\n}\n\ntype ContainerRuntime struct {\n    isolationProvider IsolationProvider\n    // ... other fields\n}\n```\n\n**Design Impact**: This represents a major architectural shift from the current Linux-specific implementation. The abstraction would need to cover all isolation primitives while maintaining consistent behavior across platforms.\n\n#### Registry Authentication System\n\n**Current Limitation**: The `RegistryClient` assumes anonymous access to public registries.\n\n**Authentication Flow**:\n1. Attempt anonymous pull\n2. If 401/403, check for credentials in config file\n3. Request authentication token from registry auth service\n4. Retry request with Bearer token\n5. Cache token for subsequent requests\n\n**Required Changes**:\n```go\ntype RegistryAuth struct {\n    Username string `json:\"username\"`\n    Password string `json:\"password\"`\n    Auth     string `json:\"auth\"` // Base64 encoded \"username:password\"\n    Server   string `json:\"server\"`\n}\n\ntype AuthStore interface {\n    GetCredentials(registry string) (RegistryAuth, error)\n    SetCredentials(registry string, auth RegistryAuth) error\n}\n\ntype AuthenticatedRegistryClient struct {\n    baseClient    *RegistryClient\n    authStore     AuthStore\n    tokenCache    map[string]string // registry -> token\n    mu            sync.RWMutex\n}\n```\n\n**Integration Points**: Modify `RegistryClient.PullManifest` and `RegistryClient.PullLayer` to handle authentication challenges and token acquisition.\n\n### Summary of Extension Readiness\n\nThe current design accommodates extensions through several key characteristics:\n\n1. **Modular Component Design**: Each manager (Namespace, Cgroup, Filesystem, Network) operates independently, allowing replacement or enhancement of individual components.\n\n2. **Clean Separation of Concerns**: The 8-phase container creation sequence provides clear hooks for adding new preparation steps (e.g., volume mounting between phases 4 and 5).\n\n3. **Cleanup Stack Pattern**: The `CleanupManager` ensures resources are properly released, which is essential when adding complex features that might fail mid-operation.\n\n4. **Config-Driven Architecture**: The `ContainerConfig` type can be extended with new fields without breaking existing functionality.\n\n5. **State Machine Foundation**: The container state machine provides a framework for adding new states (e.g., \"Paused\", \"Unhealthy\") and transitions.\n\nHowever, some extensions would require significant refactoring:\n- Plugin architectures for networking and storage\n- Cross-platform support\n- Build system integration\n- Comprehensive security features\n\nFor educational purposes, implementing selected extensions (like user namespaces or volume support) provides excellent learning opportunities while keeping the project manageable. Production container runtimes have evolved over years with contributions from hundreds of developers—our implementation captures the essential essence while remaining approachable for learning.\n\n### Implementation Guidance\n\n#### Technology Recommendations for Extensions\n\n| Extension Category | Simple Implementation | Advanced Implementation |\n|--------------------|-----------------------|-------------------------|\n| Security Hardening | Basic seccomp profiles from OCI spec | Dynamic BPF program generation based on container behavior |\n| Volume Management | Local bind mounts with configurable propagation | Plugin system with NFS, iSCSI, cloud storage drivers |\n| Network Plugins | Hardcoded bridge and host modes | CNI (Container Network Interface) compatible plugin loader |\n| Health Checks | Simple command execution via `exec` in container | Integrated with process supervision and automatic restart |\n| Metrics Collection | Periodic cgroup stats polling | Real-time metrics via eBPF and Prometheus endpoint |\n| Build System | Simple layer-by-layer execution without cache | Full Dockerfile support with smart caching and multi-stage builds |\n\n#### Recommended File Structure for Extensions\n\n```\nbyod/\n  internal/\n    security/                    # Security enhancements\n      seccomp/\n        seccomp.go              # Seccomp profile parsing and application\n        default-profile.json    # Default seccomp profile\n      capabilities/\n        capabilities.go         # Linux capabilities management\n      apparmor/\n        apparmor.go             # AppArmor profile loading\n    volumes/                    # Volume management system\n      volume.go                 # Volume interface and types\n      localdriver.go            # Local volume driver\n      manager.go                # Volume manager\n      mount.go                  # Mount helpers\n    networking/\n      drivers/                  # Network driver implementations\n        bridge.go               # Existing bridge driver (refactored)\n        host.go                 # Host network driver\n        macvlan.go              # Macvlan driver\n        plugin.go               # Plugin interface\n      cni/                      # CNI integration\n        cni.go                  # CNI plugin executor\n    health/                     # Health check system\n      checker.go                # Health check execution\n      monitor.go                # Background health monitoring\n      executor.go               # Command execution in container\n    metrics/                    # Metrics collection\n      collector.go              # Metrics collection goroutine\n      prometheus.go             # Prometheus exporter\n      types.go                  # Metrics data structures\n    build/                      # Build system\n      dockerfile/\n        parser.go               # Dockerfile parser\n        instructions.go         # Instruction implementations\n      builder.go                # Build orchestration\n      cache.go                  # Build cache\n      executor.go               # Build step execution in container\n    registry/                   # Enhanced registry client\n      auth/\n        authenticator.go        # Registry authentication\n        credentialstore.go      # Credential storage (∼/.docker/config.json)\n        token.go                # Token management\n    platform/                   # Cross-platform abstractions\n      isolation.go              # IsolationProvider interface\n      linux/                    # Linux implementation\n        isolation_linux.go\n      windows/                  # Windows implementation (stub)\n        isolation_windows.go\n  cmd/\n    byod-build/                 # Build command\n      main.go\n```\n\n#### Security Hardening Starter Code\n\n```go\n// internal/security/seccomp/seccomp.go\npackage seccomp\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \n    \"github.com/seccomp/libseccomp-golang\"\n    \"golang.org/x/sys/unix\"\n)\n\n// SeccompProfile represents a seccomp filter configuration\ntype SeccompProfile struct {\n    DefaultAction string           `json:\"defaultAction\"`\n    Architectures []string         `json:\"architectures\"`\n    Syscalls      []SyscallRule    `json:\"syscalls\"`\n}\n\n// SyscallRule defines allowed/disallowed syscalls\ntype SyscallRule struct {\n    Names  []string `json:\"names\"`\n    Action string   `json:\"action\"`\n    Args   []Arg    `json:\"args,omitempty\"`\n}\n\n// LoadProfile loads a seccomp profile from JSON file\nfunc LoadProfile(path string) (*SeccompProfile, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"read seccomp profile: %w\", err)\n    }\n    \n    var profile SeccompProfile\n    if err := json.Unmarshal(data, &profile); err != nil {\n        return nil, fmt.Errorf(\"parse seccomp profile: %w\", err)\n    }\n    \n    return &profile, nil\n}\n\n// ApplyProfile applies the seccomp profile to the current process\nfunc ApplyProfile(profile *SeccompProfile) error {\n    if profile == nil {\n        return nil // No profile to apply\n    }\n    \n    filter, err := seccomp.NewFilter(parseAction(profile.DefaultAction))\n    if err != nil {\n        return fmt.Errorf(\"create seccomp filter: %w\", err)\n    }\n    defer filter.Release()\n    \n    // Add architecture support\n    for _, arch := range profile.Architectures {\n        if err := addArchitecture(filter, arch); err != nil {\n            return fmt.Errorf(\"add architecture %s: %w\", arch, err)\n        }\n    }\n    \n    // Add syscall rules\n    for _, rule := range profile.Syscalls {\n        for _, name := range rule.Names {\n            sc, err := seccomp.GetSyscallFromName(name)\n            if err != nil {\n                // Syscall might not exist on this architecture\n                continue\n            }\n            \n            if err := filter.AddRule(sc, parseAction(rule.Action)); err != nil {\n                return fmt.Errorf(\"add rule for %s: %w\", name, err)\n            }\n        }\n    }\n    \n    return filter.Load()\n}\n\n// parseAction converts string action to seccomp.Action\nfunc parseAction(action string) seccomp.Action {\n    switch action {\n    case \"SCMP_ACT_ALLOW\":\n        return seccomp.ActAllow\n    case \"SCMP_ACT_ERRNO\":\n        return seccomp.ActErrno.SetReturnCode(int16(unix.EPERM))\n    case \"SCMP_ACT_KILL\":\n        return seccomp.ActKill\n    case \"SCMP_ACT_KILL_PROCESS\":\n        return seccomp.ActKillProcess\n    case \"SCMP_ACT_TRACE\":\n        return seccomp.ActTrace.SetReturnCode(0)\n    default:\n        return seccomp.ActErrno.SetReturnCode(int16(unix.EPERM))\n    }\n}\n\n// addArchitecture adds architecture support to filter\nfunc addArchitecture(filter *seccomp.ScmpFilter, arch string) error {\n    switch arch {\n    case \"SCMP_ARCH_X86_64\":\n        return filter.AddArch(seccomp.ArchAMD64)\n    case \"SCMP_ARCH_X86\":\n        return filter.AddArch(seccomp.ArchX86)\n    case \"SCMP_ARCH_ARM\":\n        return filter.AddArch(seccomp.ArchARM)\n    case \"SCMP_ARCH_AARCH64\":\n        return filter.AddArch(seccomp.ArchARM64)\n    default:\n        return fmt.Errorf(\"unsupported architecture: %s\", arch)\n    }\n}\n\n// DefaultProfile returns a default seccomp profile for containers\nfunc DefaultProfile() *SeccompProfile {\n    // Returns a sensible default profile similar to Docker's default\n    // This would include the actual JSON profile\n    return &SeccompProfile{\n        DefaultAction: \"SCMP_ACT_ERRNO\",\n        Architectures: []string{\"SCMP_ARCH_X86_64\"},\n        Syscalls: []SyscallRule{\n            {\n                Names:  []string{\"accept\", \"accept4\", \"access\", \"alarm\", \"bind\"},\n                Action: \"SCMP_ACT_ALLOW\",\n            },\n            // ... more syscalls\n        },\n    }\n}\n```\n\n#### Volume Management Skeleton\n\n```go\n// internal/volumes/volume.go\npackage volumes\n\nimport (\n    \"fmt\"\n    \"path/filepath\"\n    \n    \"github.com/yourusername/byod/internal/types\"\n)\n\n// Volume represents a persistent storage volume\ntype Volume struct {\n    Name       string                 `json:\"name\"`\n    Driver     string                 `json:\"driver\"`\n    Mountpoint string                 `json:\"mountpoint\"`\n    Options    map[string]interface{} `json:\"options\"`\n    Labels     map[string]string      `json:\"labels\"`\n    CreatedAt  time.Time              `json:\"createdAt\"`\n}\n\n// VolumeDriver is the interface for volume driver implementations\ntype VolumeDriver interface {\n    // Create creates a new volume with the given name and options\n    Create(name string, opts map[string]interface{}) (Volume, error)\n    \n    // Remove deletes a volume\n    Remove(name string) error\n    \n    // Mount mounts the volume and returns the mount path\n    Mount(name string) (string, error)\n    \n    // Unmount unmounts the volume\n    Unmount(name string) error\n    \n    // Path returns the path where the volume is stored (for bind mounts)\n    Path(name string) (string, error)\n    \n    // DriverName returns the driver's name\n    DriverName() string\n}\n\n// VolumeManager manages all volumes and their drivers\ntype VolumeManager struct {\n    drivers map[string]VolumeDriver\n    volumes map[string]Volume\n    baseDir string\n    mu      sync.RWMutex\n}\n\n// NewVolumeManager creates a new volume manager\nfunc NewVolumeManager(baseDir string) (*VolumeManager, error) {\n    // TODO 1: Create base directory if it doesn't exist\n    // TODO 2: Initialize drivers map\n    // TODO 3: Load existing volumes from persistence file\n    // TODO 4: Register default \"local\" driver\n    // TODO 5: Return initialized manager\n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// CreateVolume creates a new volume\nfunc (vm *VolumeManager) CreateVolume(name, driver string, opts map[string]interface{}) (Volume, error) {\n    // TODO 1: Validate volume name (alphanumeric, underscores, hyphens)\n    // TODO 2: Check if volume already exists\n    // TODO 3: Get driver implementation\n    // TODO 4: Call driver.Create() with name and options\n    // TODO 5: Store volume metadata in volumes map\n    // TODO 6: Persist volume metadata to disk\n    // TODO 7: Return created volume\n    return Volume{}, fmt.Errorf(\"not implemented\")\n}\n\n// MountVolume mounts a volume for use by a container\nfunc (vm *VolumeManager) MountVolume(name, containerID string) (string, error) {\n    // TODO 1: Look up volume by name\n    // TODO 2: Get volume driver\n    // TODO 3: Call driver.Mount() to mount the volume\n    // TODO 4: Return mount path\n    return \"\", fmt.Errorf(\"not implemented\")\n}\n\n// UnmountVolume unmounts a volume after container stops\nfunc (vm *VolumeManager) UnmountVolume(name, containerID string) error {\n    // TODO 1: Look up volume by name\n    // TODO 2: Check if any other containers are using this volume\n    // TODO 3: If no other users, call driver.Unmount()\n    // TODO 4: Update usage tracking\n    return fmt.Errorf(\"not implemented\")\n}\n\n// GetVolume returns volume information\nfunc (vm *VolumeManager) GetVolume(name string) (Volume, error) {\n    // TODO 1: Look up volume in volumes map\n    // TODO 2: Return volume if found\n    // TODO 3: Return error if not found\n    return Volume{}, fmt.Errorf(\"not implemented\")\n}\n\n// ListVolumes returns all volumes\nfunc (vm *VolumeManager) ListVolumes() []Volume {\n    // TODO 1: Iterate through volumes map\n    // TODO 2: Collect all volumes into slice\n    // TODO 3: Return slice\n    return nil\n}\n\n// RemoveVolume removes a volume\nfunc (vm *VolumeManager) RemoveVolume(name string) error {\n    // TODO 1: Check if volume exists\n    // TODO 2: Check if volume is in use by any container\n    // TODO 3: Get volume driver\n    // TODO 4: Call driver.Remove()\n    // TODO 5: Remove from volumes map\n    // TODO 6: Persist changes to disk\n    return fmt.Errorf(\"not implemented\")\n}\n\n// LocalDriver implements VolumeDriver for local directories\ntype LocalDriver struct {\n    baseDir string\n}\n\nfunc (ld *LocalDriver) Create(name string, opts map[string]interface{}) (Volume, error) {\n    // TODO 1: Create directory at filepath.Join(ld.baseDir, name)\n    // TODO 2: Apply options (size limits, permissions)\n    // TODO 3: Return Volume with Mountpoint set to directory path\n    return Volume{}, fmt.Errorf(\"not implemented\")\n}\n\nfunc (ld *LocalDriver) Remove(name string) error {\n    // TODO 1: Check if directory exists\n    // TODO 2: Remove directory and all contents\n    return fmt.Errorf(\"not implemented\")\n}\n\nfunc (ld *LocalDriver) Mount(name string) (string, error) {\n    // TODO 1: Return path to volume directory (already mounted as filesystem)\n    return \"\", fmt.Errorf(\"not implemented\")\n}\n\nfunc (ld *LocalDriver) Unmount(name string) error {\n    // TODO 1: For local driver, nothing to unmount\n    return nil\n}\n\nfunc (ld *LocalDriver) Path(name string) (string, error) {\n    // TODO 1: Return path to volume directory\n    return \"\", fmt.Errorf(\"not implemented\")\n}\n\nfunc (ld *LocalDriver) DriverName() string {\n    return \"local\"\n}\n```\n\n#### Language-Specific Hints for Extensions\n\n**Go-Specific Implementation Tips**:\n\n1. **Security Context**: Use `golang.org/x/sys/unix` package for seccomp and capabilities operations\n2. **Plugin Loading**: For dynamic network/storage plugins, consider `plugin` package or compile-time registration\n3. **Concurrent Health Checks**: Use `context.Context` with timeouts for health check execution\n4. **Metrics Collection**: Use `prometheus/client_golang` for Prometheus integration if desired\n5. **Windows Support**: Use build tags (`//go:build windows`) for platform-specific implementations\n6. **Authentication**: Use `golang.org/x/oauth2` for registry token authentication flows\n7. **Build Caching**: Use content-addressable storage with SHA256 digests for build cache keys\n\n**Integration Testing for Extensions**:\n```go\n// Example test for volume management\nfunc TestVolumeManagerIntegration(t *testing.T) {\n    tmpDir := t.TempDir()\n    vm, err := volumes.NewVolumeManager(tmpDir)\n    require.NoError(t, err)\n    \n    vol, err := vm.CreateVolume(\"testvol\", \"local\", map[string]interface{}{\n        \"size\": \"1GB\",\n    })\n    require.NoError(t, err)\n    require.Equal(t, \"testvol\", vol.Name)\n    \n    mountPath, err := vm.MountVolume(\"testvol\", \"test-container\")\n    require.NoError(t, err)\n    require.DirExists(t, mountPath)\n    \n    // Write test file to volume\n    testFile := filepath.Join(mountPath, \"test.txt\")\n    require.NoError(t, os.WriteFile(testFile, []byte(\"test\"), 0644))\n    \n    require.NoError(t, vm.UnmountVolume(\"testvol\", \"test-container\"))\n    \n    // Volume should still exist\n    vol2, err := vm.GetVolume(\"testvol\")\n    require.NoError(t, err)\n    require.Equal(t, vol.Name, vol2.Name)\n    \n    require.NoError(t, vm.RemoveVolume(\"testvol\"))\n}\n```\n\n#### Milestone Checkpoints for Extensions\n\n**After Implementing Volume Support**:\n```\n$ ./byod volume create mydata --driver=local\nVolume \"mydata\" created successfully\n\n$ ./byod run -v mydata:/data alpine ls /data\n(should show contents of empty volume)\n\n$ ./byod run -v mydata:/data alpine touch /data/test.txt\n\n$ ./byod run -v mydata:/data alpine ls /data\ntest.txt\n\n$ ./byod volume ls\nNAME    DRIVER    MOUNTPOINT\nmydata  local     /var/lib/byod/volumes/mydata/_data\n```\n\n**After Implementing User Namespaces**:\n```\n$ ./byod run --user 1000:1000 alpine id\nuid=1000 gid=1000 groups=1000\n\n$ ps aux | grep alpine\n(container process should run as non-root user on host)\n\n$ ./byod run --user 0:0 --cap-add=ALL alpine sh\n(should fail if capabilities are properly dropped)\n```\n\n**After Implementing Health Checks**:\n```\n$ ./byod run --health-cmd=\"curl -f http://localhost/health\" \\\n             --health-interval=5s \\\n             --health-retries=3 \\\n             myapp\n\n$ ./byod inspect mycontainer | jq .State.Health\n{\n  \"Status\": \"healthy\",\n  \"FailingStreak\": 0,\n  \"Log\": [...]\n}\n```\n\n#### Debugging Tips for Extensions\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Volume mount fails with \"permission denied\" | SELinux/AppArmor blocking mount | Check `dmesg` for SELinux/AppArmor denials | Use `z` or `Z` volume option for SELinux labeling |\n| Container with user namespace can't write to mounted volume | UID/GID mismatch between host and container | Check file ownership on host with `ls -la` | Use `:uid=1000,gid=1000` volume option or ensure UID mapping |\n| Health checks always fail | Command not found in container image | Run health command manually in container | Ensure health command exists in container PATH |\n| Metrics collection causes high CPU usage | Too frequent polling of cgroup files | Check metrics collection interval | Increase collection interval or use more efficient polling |\n| Build cache not working | Cache keys not matching actual inputs | Check cache key generation logic | Include all build context files in cache key hash |\n| Registry authentication fails | Token expired or invalid | Enable debug logging in registry client | Implement token refresh logic with retry |\n| Network plugin fails to load | Missing dependencies or wrong ABI | Check plugin logs and required symbols | Ensure plugin is built with compatible Go version and imports |\n\n\n## Glossary\n> **Milestone(s):** All milestones (this section provides a reference for all technical terms used throughout the design document)\n\n### Terms and Definitions\n\nThis glossary defines all key technical terms, acronyms, and domain-specific vocabulary used throughout the Build Your Own Docker design document. Terms are organized by conceptual domain to facilitate understanding of related concepts.\n\n#### Container Runtime Core Concepts\n\n| Term | Definition |\n|------|------------|\n| **Container** | An isolated, resource-controlled process environment that appears to the process as a complete operating system but shares the host kernel with other containers. |\n| **Container Runtime** | The software responsible for creating, managing, and destroying containers using Linux primitives like namespaces and cgroups. |\n| **Process Isolation** | The technique of using kernel features to prevent processes from seeing or interfering with processes, filesystems, network interfaces, and other system resources belonging to other containers or the host system. |\n| **Linux Kernel** | The core operating system component that provides namespaces, cgroups, and other containerization primitives as system calls and kernel features. |\n| **System Call (syscall)** | A programmatic way for a userspace program to request services from the Linux kernel, such as creating new processes, managing memory, or interacting with filesystems. |\n| **State Machine** | A mathematical model of computation with a finite number of states, where the system transitions between states in response to events or inputs. Our container runtime uses a state machine to manage container lifecycle states (`Created`, `Running`, `Paused`, `Stopped`, `Removed`). |\n| **Content-Addressable Storage (CAS)** | A storage paradigm where content is retrieved based on its cryptographic hash (digest) rather than its location. This ensures integrity and enables deduplication of identical content across multiple images. |\n| **Copy-on-Write (CoW)** | An optimization strategy where multiple callers share the same resource until one needs to modify it, at which point a private copy is created. Used extensively in container filesystems to share base image layers. |\n| **Reference Counting** | A technique for tracking the number of references to a shared resource, allowing the resource to be safely freed when the count reaches zero. Used for managing layer cache entries and container resources. |\n| **Configuration Merging** | The process of combining settings from multiple sources (image configuration, user configuration, default values) with well-defined precedence rules to produce the final container configuration. |\n| **Compensating Transactions** | A design pattern where for every operation that modifies system state, there is a corresponding cleanup operation that can undo or clean up that modification in case of failure. |\n| **Cleanup Stack** | A pattern where operations push cleanup functions onto a stack as they succeed, ensuring resources are properly released in reverse order of acquisition if an error occurs. |\n| **Idempotent Cleanup** | Cleanup operations that can be safely called multiple times without causing errors or side effects, crucial for robust error recovery in distributed systems. |\n| **Orphan Detection** | The process of finding resources (cgroups, network interfaces, mount points) not associated with any known container, typically during system startup or cleanup operations. |\n| **Transaction Logging** | Writing intentions to a log before performing operations, enabling crash recovery by replaying or compensating logged operations after a system failure. |\n| **Content Integrity** | Ensuring that downloaded or stored content hasn't been corrupted, typically verified using cryptographic hashes (SHA-256 digests) before use. |\n| **Structured Logging** | Logging with key-value fields instead of plain text messages, enabling better filtering, searching, and analysis of runtime events. |\n| **Debug Mode** | A runtime mode with verbose logging, additional diagnostics, and potentially slower execution for troubleshooting container runtime issues. |\n\n#### Process Isolation (Namespaces)\n\n| Term | Definition |\n|------|------------|\n| **Namespace** | A Linux kernel feature that isolates global system resources so that processes in one namespace have their own independent view of system resources like process IDs, hostnames, user IDs, mount points, and network interfaces. |\n| **PID Namespace** | A namespace that isolates process IDs, allowing processes in different namespaces to have the same PID. The first process in a PID namespace gets PID 1 and typically acts as an init process for that namespace. |\n| **Network Namespace** | A namespace that isolates network stack resources including network interfaces, IP addresses, routing tables, and firewall rules. Each network namespace has its own private loopback interface and can be connected to other namespaces via virtual Ethernet pairs. |\n| **Mount Namespace** | A namespace that isolates mount points, allowing processes in different namespaces to have different views of the filesystem hierarchy. Mount operations (mount, unmount) in one namespace do not affect other namespaces. |\n| **UTS Namespace** | A namespace that isolates system identifiers, specifically the hostname and domain name, allowing containers to have their own hostname independent of the host system. |\n| **IPC Namespace** | A namespace that isolates inter-process communication resources such as System V IPC objects and POSIX message queues. |\n| **User Namespace** | A namespace that isolates user and group ID mappings, allowing a process to have root privileges inside the namespace while being an unprivileged user outside. |\n| **Namespace ID** | A unique identifier for a Linux namespace instance, visible as an inode number in `/proc/[pid]/ns/[type]` and used with the `setns()` system call to join existing namespaces. |\n| **clone()** | A Linux system call that creates a new process (child) that may share parts of its execution context with the calling process (parent). Flags like `CLONE_NEWPID`, `CLONE_NEWNET` specify which namespaces to create for the new process. |\n| **unshare()** | A Linux system call that allows a process to disassociate parts of its execution context that were previously shared with other processes, effectively creating new namespaces for the calling process without creating a new process. |\n| **setns()** | A Linux system call that allows a process to join an existing namespace specified by a file descriptor, typically obtained from `/proc/[pid]/ns/[type]`. |\n| **SysProcAttr** | A Go struct in the `syscall` package that allows setting process creation attributes, including namespace configuration flags for the `clone()` system call when creating new processes. |\n| **/proc/self/exe** | A symbolic link in the proc filesystem that points to the current executable. Used in container runtimes to re-execute the runtime binary with different arguments for the child process in new namespaces. |\n\n#### Resource Limits (cgroups)\n\n| Term | Definition |\n|------|------------|\n| **cgroup (Control Group)** | A Linux kernel feature for limiting, accounting for, and isolating resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes. |\n| **cgroup v1** | The original cgroup implementation with separate hierarchies for different resource controllers (memory, cpu, blkio, etc.), allowing different process groupings for each controller. |\n| **cgroup v2** | The unified cgroup hierarchy that provides a consistent interface with all controllers mounted under a single filesystem hierarchy, offering improved consistency and new features. |\n| **Controller** | A cgroup subsystem that manages a specific resource type, such as `memory` for memory limits, `cpu` for CPU scheduling, or `pids` for process count limits. |\n| **cgroup Hierarchy** | A tree structure of cgroups where child cgroups inherit resource limits from parent cgroups, with further restrictions possible at each level. |\n| **OOM Killer (Out-Of-Memory Killer)** | A kernel mechanism that selects and terminates processes when the system is critically low on memory. cgroups can trigger the OOM killer within specific cgroups when memory limits are exceeded. |\n| **RSS (Resident Set Size)** | The portion of a process's memory held in physical RAM (as opposed to swapped out to disk). cgroup memory limits typically apply to RSS plus kernel memory allocations. |\n| **CPU Shares** | A relative weight in the CPU controller that determines the proportion of CPU time available to a cgroup relative to sibling cgroups when the system is under contention. |\n| **CPU Quota** | An absolute limit in the CPU controller that caps the amount of CPU time a cgroup can consume within a specified period, expressed as `quota/period` microseconds. |\n| **PIDs Limit** | A cgroup controller that restricts the maximum number of processes (including threads) that can be created within a cgroup, preventing fork bombs and runaway process creation. |\n\n#### Filesystem Isolation\n\n| Term | Definition |\n|------|------------|\n| **rootfs (Root Filesystem)** | The filesystem mounted at the root directory (`/`) of a container, containing all binaries, libraries, and configuration files needed for the containerized process to run. |\n| **chroot** | A system call that changes the root directory for the calling process and its children, restricting filesystem access to the subtree under the new root. Without mount namespace isolation, chroot is considered escapable. |\n| **pivot_root** | A system call that atomically swaps the root filesystem of the calling process with a new root filesystem, then unmounts the old root. This provides stronger isolation than chroot when combined with mount namespaces. |\n| **Mount Propagation** | Determines how mount and unmount events propagate between mount namespaces. `MS_SHARED` mounts propagate to peer namespaces, `MS_PRIVATE` mounts do not, and `MS_SLAVE` mounts receive but do not send propagation events. |\n| **procfs (proc Filesystem)** | A virtual filesystem mounted at `/proc` that provides information about processes and other system information in a hierarchical file-like structure. Containers need their own procfs mount to see their own processes. |\n| **sysfs (sys Filesystem)** | A virtual filesystem mounted at `/sys` that provides a hierarchical view of kernel devices, drivers, and other kernel parameters. Typically mounted read-only in containers. |\n| **tmpfs (Temporary Filesystem)** | A temporary in-memory filesystem that uses RAM and/or swap space. Used for `/dev`, `/run`, and other temporary directories in containers. |\n| **Bind Mount** | A mount operation that makes an existing directory or file available at another location in the filesystem hierarchy. Changes to the bind mount are reflected at the original location and vice versa. |\n| **Device Node** | A special file in `/dev` that represents a hardware or virtual device. Containers typically need a minimal set of device nodes (`null`, `zero`, `random`, `urandom`, `tty`, `console`) for applications to function. |\n\n#### Layered Filesystem (OverlayFS)\n\n| Term | Definition |\n|------|------------|\n| **OverlayFS** | A union filesystem that layers multiple directories (called layers) into a single unified view, commonly used in container runtimes to stack image layers efficiently. |\n| **Lower Directory (lowerdir)** | In OverlayFS, one or more read-only directories that form the base layers of the union. Files are read from the highest priority lower directory where they exist. |\n| **Upper Directory (upperdir)** | In OverlayFS, a writable directory where all modifications (creates, writes, deletes) are stored. This layer captures container filesystem changes without modifying the read-only lower layers. |\n| **Work Directory (workdir)** | In OverlayFS, an empty directory used by the kernel for preparing files before moving them to the upper directory during copy-on-write operations. Must be on the same filesystem as the upper directory. |\n| **Merged View** | The unified filesystem view presented to the container process, combining files from all lower directories with modifications from the upper directory. |\n| **Whiteout** | A special file (character device with device numbers 0,0) in the upper directory that marks a file or directory in a lower layer as deleted. Named `.wh.<filename>` in OverlayFS. |\n| **Opaque Directory** | A special extended attribute (`trusted.overlay.opaque=\"y\"`) or directory named `overlay-opaque` that marks a directory in the upper layer as opaque, hiding all contents from lower layers within that directory. |\n| **Layer** | A read-only filesystem snapshot representing a set of filesystem changes. Container images are composed of stacked layers, each representing a step in the image build process. |\n| **Copy-on-Write (CoW)** | In filesystem context, a technique where a file is copied from a lower (read-only) layer to the upper (writable) layer only when it is modified, conserving disk space and reducing write amplification. |\n| **Union Mount** | A mount that presents a composite view of multiple directories, with precedence rules determining which file appears when the same path exists in multiple source directories. OverlayFS is one implementation of union mounting. |\n\n#### Container Networking\n\n| Term | Definition |\n|------|------------|\n| **Network Namespace** | A Linux namespace that provides an isolated network stack with its own network interfaces, IP addresses, routing tables, and firewall rules. |\n| **Virtual Ethernet Pair (veth pair)** | A pair of virtual network devices that act as a tunnel between network namespaces. Packets transmitted on one device are received on the other, connecting namespaces like a virtual network cable. |\n| **Linux Bridge** | A virtual switch implemented in the kernel that forwards packets between multiple network interfaces (physical or virtual). Used to connect multiple container veth endpoints on the same subnet. |\n| **iptables** | A userspace utility for configuring Linux kernel firewall rules (netfilter). Used in container networking for NAT masquerading, port forwarding, and network policy enforcement. |\n| **NAT Masquerading** | A form of network address translation where outbound packets from containers have their source IP address replaced with the host's IP address, allowing containers to reach external networks without publicly routable IPs. |\n| **Port Forwarding** | The mapping of a port on the host to a port inside a container, allowing external connections to reach services running inside containers. Implemented via iptables DNAT (Destination Network Address Translation) rules. |\n| **IPAM (IP Address Management)** | The process of allocating, tracking, and assigning IP addresses to containers from defined subnets, ensuring no address conflicts and efficient utilization of address space. |\n| **Dual-Stack Networking** | Support for both IPv4 and IPv6 addressing simultaneously in container networks, requiring configuration of both address families in network namespaces and routing tables. |\n\n#### Image Format and OCI\n\n| Term | Definition |\n|------|------------|\n| **OCI (Open Container Initiative)** | An open governance structure for creating open industry standards around container formats and runtimes, maintaining specifications for container images and runtime behavior. |\n| **OCI Image Specification** | A specification that defines the format for container images, including the manifest, configuration, and layer descriptors, ensuring interoperability between different container tools. |\n| **OCI Runtime Specification** | A specification that defines the configuration, execution environment, and lifecycle of containers, ensuring consistent behavior across different container runtimes. |\n| **Manifest** | A JSON document describing the components of a container image, including layer digests, image configuration, and metadata. Serves as the entry point for locating and verifying image contents. |\n| **Digest** | A cryptographic hash (typically SHA-256) used to uniquely and content-addressably identify a blob (layer, config, manifest) in an OCI image. Expressed as `algorithm:hex` (e.g., `sha256:abc123...`). |\n| **Blob** | A binary large object stored in an OCI registry, such as a layer tar archive, image configuration JSON, or manifest JSON. Identified by its digest. |\n| **Tag** | A human-readable alias that points to a specific image manifest in a registry, allowing users to reference images with names like `ubuntu:latest` rather than cryptographic digests. |\n| **Registry** | A server that stores and distributes container images, implementing the OCI Distribution Specification. Docker Hub is a popular public registry; private registries can be deployed internally. |\n| **Authentication Flow** | The process of obtaining and presenting credentials (username/password, tokens) to a registry to authenticate requests for pulling or pushing images. |\n| **Token Authentication** | A bearer token-based authentication mechanism where the registry returns a short-lived token after initial authentication, used for subsequent API requests. |\n\n#### CLI and User Interface\n\n| Term | Definition |\n|------|------------|\n| **CLI (Command Line Interface)** | The text-based interface through which users interact with the container runtime by typing commands, options, and arguments in a terminal or shell. |\n| **Inspection Command** | A CLI subcommand (e.g., `inspect`) that gathers and displays detailed information about a container's configuration, state, network settings, and resource usage. |\n| **Sequence Diagram** | A visual representation of component interactions over time, showing messages passed between actors and components in a specific sequence. Used in design documents to illustrate complex workflows. |\n| **State Transition** | A change from one state to another in a state machine, triggered by an event or condition. In our container runtime, transitions like `Created` → `Running` occur when the user issues a `start` command. |\n\n#### State Management and Data Structures\n\n| Term | Definition |\n|------|------------|\n| **Container** | The primary data structure representing a container instance, containing fields for `ID`, `Name`, `State`, `Config`, `Pid`, and `CreatedAt`. |\n| **ContainerConfig** | Configuration settings for a container, including `Image` name, command (`Cmd`), environment variables (`Env`), working directory (`WorkingDir`), hostname (`Hostname`), resource limits (`Limits`), and network settings (`Network`). |\n| **ContainerState** | An enumeration representing the current lifecycle state of a container: `Created`, `Running`, `Paused`, `Stopped`, or `Removed`. |\n| **ResourceLimits** | Configuration for container resource constraints, including memory limit in megabytes (`MemoryMB`), CPU shares (`CPUShares`), and maximum process count (`PidsLimit`). |\n| **NetworkConfig** | Network configuration for a container, specifying the network mode (`Mode`), bridge name (`BridgeName`), IP address (`IPAddress`), and port mappings (`PortMappings`). |\n| **PortMapping** | A mapping between a host port and a container port with a specified protocol (TCP/UDP), allowing external access to containerized services. |\n| **Image** | A data structure representing a container image, containing fields for `Name`, `Digest`, `Layers`, and `Config`. |\n| **ImageLayer** | A single layer in a container image, identified by its `Digest`, with `Size` in bytes and local filesystem `Path` where the extracted layer contents are stored. |\n| **ImageConfig** | Configuration embedded in an image, specifying the default `Entrypoint`, `Cmd`, `Env`, and `WorkingDir` for containers created from this image. |\n| **ContainerStore** | A component responsible for persisting container state to disk, typically storing JSON representations in a directory structure under a `basePath`. |\n\n#### Error Handling and Debugging\n\n| Term | Definition |\n|------|------------|\n| **Property-Based Testing** | A testing methodology that verifies properties hold for automatically generated inputs, using frameworks like QuickCheck to generate thousands of test cases and find edge cases. |\n| **Fuzz Testing** | A testing technique that provides random, unexpected, or invalid inputs to a program to uncover security vulnerabilities, crashes, or incorrect behavior. |\n| **Integration Test** | A test that combines multiple components to verify they work together correctly, often involving actual system calls and external dependencies. |\n| **System Test** | An end-to-end test of the complete system from user command to container execution, verifying the entire workflow matches expected behavior. |\n| **Mock** | A test double that simulates the behavior of a real component, allowing isolated testing of a component without its dependencies. |\n| **Test Fixture** | A fixed state used as a baseline for running tests, ensuring tests start with known, reproducible conditions. |\n| **Race Condition** | A defect where the output or behavior depends on the sequence or timing of uncontrollable events, often occurring in concurrent programming when multiple threads access shared data without proper synchronization. |\n| **Test Pyramid** | A concept describing the ideal distribution of tests: many fast, isolated unit tests; fewer integration tests; and even fewer slow, expensive system tests. |\n| **Packet Tracing** | Monitoring network packets through the networking stack using tools like `tcpdump`, `Wireshark`, or kernel tracing facilities to diagnose container networking issues. |\n| **Process Tree** | The hierarchical relationship between parent and child processes, visible via commands like `pstree`. Container runtimes must manage process trees within containers to properly handle orphaned processes. |\n| **System Call Tracing** | Monitoring system calls made by a process using tools like `strace` or `sysdig` to understand behavior, diagnose failures, or detect security issues. |\n| **Resource Accounting** | Tracking resource usage (CPU, memory, I/O) by containers over time, enabling monitoring, billing, and capacity planning. |\n\n#### Security\n\n| Term | Definition |\n|------|------------|\n| **seccomp (Secure Computing Mode)** | A Linux kernel feature for filtering system calls available to a process, allowing restriction of the kernel surface area exposed to containers to reduce attack vectors. |\n| **Capabilities** | Fine-grained permissions that divide the omnipotent root privilege into distinct units, allowing containers to be granted specific privileges (e.g., `CAP_NET_ADMIN` for network configuration) without full root access. |\n| **Seccomp Profile** | A JSON configuration defining which system calls are allowed, which are restricted, and what action to take (allow, error, kill) for filtered calls. |\n| **SyscallRule** | A rule within a seccomp profile specifying system call names, action, and optional argument constraints. |\n| **User Namespace** | A namespace that isolates user and group IDs, enabling privilege escalation within the namespace while maintaining unprivileged execution on the host—a key security feature for rootless containers. |\n\n#### Storage and Volumes\n\n| Term | Definition |\n|------|------------|\n| **Volume** | A unit of persistent storage that can be mounted into containers, surviving container lifecycle operations (stop, remove). Volumes can be backed by host directories, network storage, or other storage drivers. |\n| **VolumeDriver** | An interface defining operations for volume management: `Create`, `Remove`, `Mount`, `Unmount`, `Path`, and `DriverName`. Different drivers implement storage for different backends (local, NFS, cloud storage). |\n| **VolumeManager** | A component that manages volumes using registered drivers, tracking volume state and providing a unified API for volume operations. |\n| **VolumeMount** | A specification for mounting a volume into a container, including `Source` (volume name or host path), `Destination` (container mount path), `Type` (bind, volume), and mount `Options`. |\n| **Bind Mount** | A type of volume mount that maps a host directory or file directly into a container, with changes reflected both directions. |\n| **tmpfs Mount** | A mount of a temporary in-memory filesystem into a container, useful for sensitive data that shouldn't persist on disk. |\n\n#### Health and Metrics\n\n| Term | Definition |\n|------|------------|\n| **Health Check** | A periodic command execution or HTTP request to verify that a containerized application is functioning correctly, with configurable interval, timeout, retries, and start period. |\n| **HealthCheckConfig** | Configuration for health checks: `Test` command, `Interval` between checks, `Timeout` for each check, `StartPeriod` before checks begin, and `Retries` before marking unhealthy. |\n| **ContainerHealth** | Current health status of a container: `Status` (healthy, unhealthy, starting), `FailingStreak` count, and `Log` of recent health check results. |\n| **HealthMonitor** | A component that periodically executes health checks for running containers and updates their health status. |\n| **Metrics** | Quantitative measurements of container resource usage, including CPU, memory, block I/O, network, and process counts. |\n| **ContainerMetrics** | A snapshot of container metrics at a specific `Timestamp`, with detailed `CPU`, `Memory`, `BlockIO`, `Network`, and `PIDs` measurements. |\n| **MetricsCollector** | A component that periodically gathers metrics from cgroups, network interfaces, and process information for running containers. |\n\n#### Future Extensions\n\n| Term | Definition |\n|------|------------|\n| **CNI (Container Network Interface)** | A plugin standard for configuring container networking, allowing interchangeable network implementations (bridge, macvlan, ipvlan, etc.) via executable plugins. |\n| **Plugin Architecture** | A system design that supports interchangeable components via defined interfaces, allowing third-party extensions for networking, volumes, logging, and other functionality. |\n| **Dual-Stack** | Networking that supports both IPv4 and IPv6 simultaneously, requiring configuration of both address families in container network namespaces. |\n| **Credential Store** | Secure storage for authentication credentials (e.g., Docker config.json, keychain) used to authenticate with container registries. |\n| **Build System** | A toolchain for creating container images from source code (Dockerfiles, Buildpacks) rather than pulling pre-built images from registries. |\n| **Checkpoint/Restore** | The process of saving a container's state (memory, CPU registers, open files) to disk and later restoring it to resume execution from the saved point, enabling live migration and faster startups. |\n\n---\n"}