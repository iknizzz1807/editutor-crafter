{"html":"<h1 id=\"game-engine-design-document\">Game Engine: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>A modular 2D/3D game engine that manages entity-component systems, graphics rendering, physics simulation, and resource loading through a performance-oriented architecture. The key architectural challenge is designing loosely-coupled systems that can efficiently process thousands of entities per frame while maintaining deterministic behavior.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — foundational understanding needed throughout the project</p>\n</blockquote>\n<p>Game engines represent one of the most architecturally challenging domains in software engineering. Unlike typical business applications that process user requests, return responses, and wait for the next interaction, game engines must continuously simulate an entire virtual world at 60+ frames per second while managing complex interdependent systems. They sit at the intersection of real-time systems, high-performance computing, and interactive media, creating a unique set of constraints that demand careful architectural consideration.</p>\n<p>The complexity stems not just from individual technical challenges like graphics programming or physics simulation, but from the intricate coordination required between multiple subsystems operating under strict timing constraints. A single frame must process user input, update thousands of game entities, simulate physics interactions, manage resource loading, and render the final image to screen — all within approximately 16.67 milliseconds to maintain 60 FPS. Any architectural decision that introduces inefficiency, unpredictable latency, or tight coupling between systems can cascade into performance problems or maintenance nightmares.</p>\n<p>This section establishes the foundational understanding of why game engines are complex systems, explores the key technical challenges that drive architectural decisions, and examines how different architectural approaches address these challenges with varying trade-offs.</p>\n<h3 id=\"mental-model-digital-theater-production\">Mental Model: Digital Theater Production</h3>\n<p>Think of a game engine as the behind-the-scenes infrastructure for a live theater production that never ends. Just as a theater has a stage manager coordinating lighting technicians, sound engineers, prop masters, and actors to create a seamless performance, a game engine coordinates rendering systems, physics simulation, entity management, and resource loading to create an interactive virtual world.</p>\n<p><strong>The Stage Manager (Main Game Loop)</strong> maintains the show&#39;s rhythm, calling cues at precise intervals to ensure everything happens in the right sequence. In theater, this might be &quot;Lights dim, actor enters stage left, sound effect plays, backdrop changes.&quot; In a game engine, it&#39;s &quot;Process input, update entities, simulate physics, render frame&quot; — repeated 60 times per second with clockwork precision.</p>\n<p><strong>The Props Department (Resource Management System)</strong> maintains an inventory of costumes, furniture, and set pieces, ensuring the right props are available when needed and returned to storage when scenes change. Similarly, the game engine&#39;s resource system loads textures, models, and audio files on demand, caches them in memory for quick access, and unloads them when transitioning between game levels.</p>\n<p><strong>The Lighting Crew (Rendering System)</strong> manages spotlights, color filters, and projection systems to create the visual atmosphere. They work with standardized equipment (lighting rigs, control boards) and must coordinate with the set design to avoid shadows falling in wrong places. The game engine&#39;s renderer manages shaders, textures, and draw calls, working within the constraints of graphics APIs (OpenGL, Vulkan) and coordinating with the entity system to know what objects need to be drawn and where.</p>\n<p><strong>The Sound Engineers (Audio System)</strong> manage microphones, speakers, and mixing boards to create the auditory experience, ensuring dialogue is clear, music sets the mood, and sound effects enhance the action. They must synchronize audio cues with visual events and manage multiple audio channels simultaneously without overwhelming the audience.</p>\n<p><strong>The Choreographer (Physics and Entity Systems)</strong> coordinates the movement and interactions of all actors on stage, ensuring collisions look realistic, movements follow natural laws, and multiple actors can share the stage without accidentally interfering with each other&#39;s performances.</p>\n<p>The critical insight from this analogy is that <strong>coordination complexity grows exponentially with the number of systems involved</strong>. A two-person scene requires minimal coordination, but a full-cast musical number with lighting changes, set transitions, and orchestra synchronization demands precise timing and well-defined interfaces between all departments. Similarly, adding new game engine systems creates coordination challenges that must be addressed architecturally.</p>\n<p>Just as a theater production needs clear roles, standardized communication protocols (&quot;Standby cue 47&quot;, &quot;Go cue 47&quot;), and contingency plans for when things go wrong, a game engine needs well-defined system boundaries, standardized data interfaces, and robust error handling to maintain smooth operation under the pressure of real-time constraints.</p>\n<h3 id=\"core-technical-challenges\">Core Technical Challenges</h3>\n<p>Game engines face a unique combination of technical challenges that distinguish them from other software domains. These challenges drive every major architectural decision and create constraints that must be considered when designing each subsystem.</p>\n<h4 id=\"frame-rate-constraints-and-real-time-deadlines\">Frame-Rate Constraints and Real-Time Deadlines</h4>\n<p>The most fundamental challenge is the <strong>frame-time budget</strong>: everything the engine needs to accomplish in a single frame must complete within 16.67 milliseconds (for 60 FPS) or 33.33 milliseconds (for 30 FPS). This creates a hard real-time constraint where missing deadlines results in immediately visible stuttering, frame drops, or input lag that directly impacts the player&#39;s experience.</p>\n<p>Unlike web servers that can queue requests during traffic spikes or database systems that can delay non-critical operations, game engines cannot defer work to future frames without creating noticeable artifacts. Every frame must process input events, update entity logic, simulate physics, manage resource loading, and render the final image within the time budget.</p>\n<p>This constraint forces architectural decisions around <strong>predictable performance</strong> rather than average-case optimization. A system that usually runs in 2ms but occasionally spikes to 50ms is worse than a system that consistently runs in 8ms, because the spikes cause frame drops. This drives design choices toward:</p>\n<ul>\n<li><strong>Cache-friendly memory layouts</strong> that ensure predictable memory access patterns</li>\n<li><strong>Batch processing</strong> that amortizes setup costs across many operations</li>\n<li><strong>Fixed-capacity data structures</strong> that avoid dynamic allocation during frame processing</li>\n<li><strong>System execution ordering</strong> that minimizes data dependencies and cache misses</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Performance Requirement</th>\n<th>Target Value</th>\n<th>Consequences of Missing Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame Time</td>\n<td>16.67ms (60 FPS)</td>\n<td>Visible stuttering, input lag</td>\n</tr>\n<tr>\n<td>Input Latency</td>\n<td>&lt;20ms total</td>\n<td>Unresponsive controls</td>\n</tr>\n<tr>\n<td>Memory Allocation</td>\n<td>&lt;1MB per frame</td>\n<td>Garbage collection pauses</td>\n</tr>\n<tr>\n<td>Cache Misses</td>\n<td>&lt;5% in hot paths</td>\n<td>Unpredictable frame times</td>\n</tr>\n<tr>\n<td>Draw Calls</td>\n<td>&lt;1000 per frame</td>\n<td>GPU bottlenecks</td>\n</tr>\n</tbody></table>\n<h4 id=\"memory-management-and-cache-efficiency\">Memory Management and Cache Efficiency</h4>\n<p>Game engines typically manage thousands of active entities (players, enemies, bullets, particles, UI elements) that must be processed every frame. Traditional object-oriented approaches that scatter related data across the heap create cache miss patterns that make it impossible to process large numbers of entities within frame-time budgets.</p>\n<p>Consider a naive approach where each game entity is a separate object with position, velocity, sprite, and health components stored as individual allocations. To update all entities, the system must traverse a linked list or array of pointers, following each pointer to load the entity data from potentially random memory locations. On modern processors, a cache miss costs 200-400 CPU cycles, meaning that processing 1000 entities with poor cache locality could consume the entire frame budget just on memory access.</p>\n<p>This drives game engines toward <strong>data-oriented design</strong> principles that organize data by access patterns rather than conceptual relationships:</p>\n<ul>\n<li><strong>Struct-of-Arrays (SoA)</strong> organization that stores all position components together, all velocity components together, etc.</li>\n<li><strong>Component storage systems</strong> that enable efficient iteration over entities with specific component combinations  </li>\n<li><strong>Memory pools and custom allocators</strong> that provide predictable allocation patterns and eliminate fragmentation</li>\n<li><strong>Prefetching strategies</strong> that load related data before it&#39;s needed</li>\n</ul>\n<p>The Entity-Component-System (ECS) architectural pattern emerged specifically to address these memory access patterns by organizing game data for efficient system processing rather than conceptual object modeling.</p>\n<table>\n<thead>\n<tr>\n<th>Memory Challenge</th>\n<th>Traditional Approach</th>\n<th>Game Engine Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Storage</td>\n<td>Objects with embedded components</td>\n<td>Components in separate dense arrays</td>\n</tr>\n<tr>\n<td>Memory Allocation</td>\n<td>Dynamic allocation as needed</td>\n<td>Pre-allocated pools with fixed capacity</td>\n</tr>\n<tr>\n<td>Data Access</td>\n<td>Object.getComponent().getValue()</td>\n<td>Direct array indexing</td>\n</tr>\n<tr>\n<td>Cache Utilization</td>\n<td>Random access pattern</td>\n<td>Sequential iteration over component arrays</td>\n</tr>\n</tbody></table>\n<h4 id=\"system-interdependencies-and-update-ordering\">System Interdependencies and Update Ordering</h4>\n<p>Game engine systems exhibit complex interdependencies that create coordination challenges. The rendering system needs transform and sprite components updated by the entity system. The physics system needs to read transform components and write back updated positions. The audio system needs to know entity positions for 3D sound spatialization. The resource system needs to load assets requested by rendering and audio systems.</p>\n<p>These dependencies create <strong>update ordering constraints</strong> that must be carefully managed:</p>\n<ol>\n<li><strong>Input processing</strong> must complete before entity systems can respond to player actions</li>\n<li><strong>Entity logic updates</strong> must complete before physics simulation to ensure consistent state</li>\n<li><strong>Physics simulation</strong> must complete before rendering to display updated positions</li>\n<li><strong>Resource loading</strong> must coordinate with rendering to avoid displaying partially-loaded assets</li>\n</ol>\n<p>The challenge is that naive sequential execution of systems can create unnecessary latency and underutilize available CPU cores. Modern processors have multiple cores that could theoretically process independent systems in parallel, but the interdependencies create synchronization points that limit parallelization opportunities.</p>\n<p>Furthermore, some systems have <strong>circular dependencies</strong> that require careful handling:</p>\n<ul>\n<li>Physics simulation updates entity positions, but entity logic may immediately override those positions based on game rules</li>\n<li>Rendering needs to know current entity positions, but UI rendering may modify entity states (e.g., health bars affecting game logic)</li>\n<li>Resource loading triggered by entity spawning may complete during physics simulation, requiring thread-safe coordination</li>\n</ul>\n<blockquote>\n<p><strong>Critical Design Insight:</strong> The order of system execution in a game engine is not just a performance optimization — it determines the correctness of the simulation. A physics system that reads stale position data or a rendering system that displays inconsistent entity states can create bugs that are extremely difficult to reproduce and debug.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>System Dependency</th>\n<th>Read Data</th>\n<th>Write Data</th>\n<th>Timing Constraint</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Input → Entity Logic</td>\n<td>Input events</td>\n<td>Entity state</td>\n<td>Must complete before entity updates</td>\n</tr>\n<tr>\n<td>Entity Logic → Physics</td>\n<td>Transform, collision bounds</td>\n<td>Velocity, forces</td>\n<td>Must provide consistent state</td>\n</tr>\n<tr>\n<td>Physics → Transform</td>\n<td>Velocity, forces</td>\n<td>Position, rotation</td>\n<td>Must complete before rendering</td>\n</tr>\n<tr>\n<td>Transform → Rendering</td>\n<td>Position, scale, rotation</td>\n<td>Screen coordinates</td>\n<td>Must complete before frame present</td>\n</tr>\n<tr>\n<td>Entity Logic → Audio</td>\n<td>Position, game events</td>\n<td>Audio playback requests</td>\n<td>Can overlap with other systems</td>\n</tr>\n</tbody></table>\n<h4 id=\"resource-loading-and-streaming\">Resource Loading and Streaming</h4>\n<p>Modern games require hundreds of megabytes or gigabytes of assets (textures, models, audio files) that cannot all fit in memory simultaneously. The resource management system must coordinate loading, caching, and unloading of assets while ensuring that systems always have access to the resources they need for rendering or audio playback.</p>\n<p>This creates several architectural challenges:</p>\n<p><strong>Asynchronous Loading Complexity:</strong> Loading assets from disk or network takes much longer than a single frame (often 10-100ms per asset), so resource loading must happen asynchronously while the game continues running. This requires thread-safe coordination between the main game thread and background loading threads, with careful handling of race conditions where a system requests a resource that&#39;s currently being loaded.</p>\n<p><strong>Memory Budget Management:</strong> The engine must balance keeping frequently-used assets in memory for fast access against the limited available memory, requiring sophisticated caching policies that consider both access frequency and asset size. Loading new assets when memory is full requires unloading existing assets, but only if they&#39;re not currently needed by any active systems.</p>\n<p><strong>Asset Dependency Chains:</strong> Many assets have dependencies on other assets (models reference textures, scenes reference models, etc.), creating loading order constraints that must be resolved without creating deadlocks or loading unnecessary assets.</p>\n<p><strong>Format Conversion and Optimization:</strong> Raw asset files are often stored in formats optimized for creation tools rather than runtime efficiency, requiring conversion to GPU-friendly formats (compressed textures, optimized vertex buffers) that may be expensive to compute.</p>\n<h3 id=\"existing-engine-architectures\">Existing Engine Architectures</h3>\n<p>The architectural patterns used in game engines have evolved significantly over the past decades, driven by changing hardware capabilities, game complexity requirements, and lessons learned from shipped projects. Understanding the trade-offs between different architectural approaches provides context for the design decisions made in modern game engines.</p>\n<h4 id=\"monolithic-architecture\">Monolithic Architecture</h4>\n<p>Early game engines often used <strong>monolithic architectures</strong> where all functionality was tightly integrated into a single large system with minimal separation between rendering, gameplay logic, physics, and resource management. This approach prioritized simplicity and direct optimization over modularity and maintainability.</p>\n<p>In a monolithic engine, the main game loop directly calls rendering functions, physics update code, and entity management logic without abstraction layers. Entity data might be stored in global arrays, with systems accessing this data directly by index or pointer. Resource loading happens synchronously when assets are needed, blocking the main thread until loading completes.</p>\n<p><strong>Monolithic Architecture Trade-offs:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Advantages</th>\n<th>Disadvantages</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Simple to understand — all code in one place</td>\n<td>Difficult to modify without breaking other systems</td>\n</tr>\n<tr>\n<td>No abstraction overhead — direct function calls</td>\n<td>Hard to test individual systems in isolation</td>\n</tr>\n<tr>\n<td>Easy to optimize cross-system interactions</td>\n<td>Code reuse requires copying and modifying</td>\n</tr>\n<tr>\n<td>Minimal coordination complexity</td>\n<td>Adding new features affects entire codebase</td>\n</tr>\n<tr>\n<td>Predictable performance characteristics</td>\n<td>Multiple developers cannot work independently</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Why Monolithic Architectures Were Initially Popular</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Early games were developed by small teams (1-5 people) with limited time and hardware constraints that demanded maximum performance  </li>\n<li><strong>Options Considered</strong>: Monolithic vs early modular approaches  </li>\n<li><strong>Decision</strong>: Monolithic architecture for most early engines  </li>\n<li><strong>Rationale</strong>: Small team size eliminated coordination problems, performance requirements exceeded abstraction costs, and game complexity was low enough for single developers to understand entire systems  </li>\n<li><strong>Consequences</strong>: Fast initial development but poor scalability as games became more complex and teams grew larger</li>\n</ul>\n</blockquote>\n<p>Monolithic architectures remain viable for specific contexts: small indie games, game jam projects, or highly specialized engines where the entire system is optimized for one specific type of gameplay. However, they become increasingly problematic as game complexity grows and development teams expand beyond 2-3 programmers.</p>\n<h4 id=\"component-based-architecture\">Component-Based Architecture</h4>\n<p><strong>Component-based architectures</strong> emerged as games became more complex and development teams grew larger. This approach models game entities as containers that hold multiple component objects, each responsible for a specific aspect of entity behavior (rendering, physics, gameplay logic, audio).</p>\n<p>In this architecture, an entity like a &quot;Player&quot; might contain a <code>TransformComponent</code> for position and rotation, a <code>SpriteComponent</code> for visual representation, a <code>PhysicsComponent</code> for collision detection, and a <code>HealthComponent</code> for gameplay state. Systems operate by iterating through entities and processing the components they care about.</p>\n<p>The key insight driving component-based design is <strong>separation of concerns</strong>: rendering logic doesn&#39;t need to understand physics simulation, physics systems don&#39;t need to know about audio playback, and gameplay logic can focus on game rules without managing graphics resources.</p>\n<p><strong>Component-Based Architecture Implementation Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Inheritance</td>\n<td>Base <code>Component</code> class with virtual methods</td>\n<td>Easy to understand, but virtual call overhead</td>\n</tr>\n<tr>\n<td>Component Interfaces</td>\n<td>Components implement specific interfaces</td>\n<td>More flexible, but requires careful interface design</td>\n</tr>\n<tr>\n<td>Message Passing</td>\n<td>Components communicate through events/messages</td>\n<td>Loose coupling, but harder to debug data flow</td>\n</tr>\n<tr>\n<td>Direct Component Access</td>\n<td>Systems directly access component data</td>\n<td>Best performance, but creates coupling</td>\n</tr>\n</tbody></table>\n<p>However, component-based architectures introduced new challenges around <strong>component communication</strong> and <strong>data access patterns</strong>. When the physics system updates an entity&#39;s position, how does the rendering system learn about the change? When gameplay logic needs to spawn a particle effect, how does it communicate with the rendering system? Various solutions emerged:</p>\n<ul>\n<li><strong>Component message systems</strong> where components send events to each other</li>\n<li><strong>Entity event broadcasts</strong> where changes to one component trigger notifications to others  </li>\n<li><strong>System-to-system communication</strong> where systems coordinate directly rather than through entities</li>\n<li><strong>Shared component access</strong> where systems can directly read/write other systems&#39; components</li>\n</ul>\n<blockquote>\n<p><strong>Decision: Component-Based vs Monolithic Trade-offs</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Growing game complexity and team sizes made monolithic architectures unmaintainable  </li>\n<li><strong>Options Considered</strong>: Monolithic, component-based with inheritance, component-based with interfaces  </li>\n<li><strong>Decision</strong>: Component-based with interface-driven design  </li>\n<li><strong>Rationale</strong>: Enabled multiple programmers to work on different systems simultaneously, improved testability by isolating system logic, provided better code reuse across different entity types  </li>\n<li><strong>Consequences</strong>: Improved maintainability and team scalability, but introduced performance overhead from virtual calls and complex component communication patterns</li>\n</ul>\n</blockquote>\n<p>The component-based approach dominated game engine design through the 2000s and early 2010s, forming the foundation for engines like Unity&#39;s early architecture and many custom game engines developed during this period.</p>\n<h4 id=\"entity-component-system-ecs-architecture\">Entity-Component-System (ECS) Architecture</h4>\n<p><strong>Entity-Component-System (ECS) architectures</strong> represent the latest evolution in game engine design, driven by the need to process thousands of entities efficiently while maintaining architectural flexibility. ECS separates the three concerns that were conflated in earlier approaches:</p>\n<ul>\n<li><strong>Entities</strong> are just unique identifiers (typically integers) with no behavior or data  </li>\n<li><strong>Components</strong> are pure data structures with no logic or methods</li>\n<li><strong>Systems</strong> contain all logic and operate on entities that have specific component combinations</li>\n</ul>\n<p>This separation enables <strong>data-oriented design</strong> principles that optimize for CPU cache efficiency and parallel processing. Instead of storing an entity as an object containing components, ECS stores all components of the same type together in dense arrays. Systems iterate over these component arrays, processing all entities with compatible component sets in cache-friendly sequential order.</p>\n<p><strong>ECS Architecture Principles:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Principle</th>\n<th>Traditional OOP</th>\n<th>ECS Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Data Organization</td>\n<td>Objects contain related data</td>\n<td>Components of same type stored together</td>\n</tr>\n<tr>\n<td>Behavior Location</td>\n<td>Methods on objects</td>\n<td>Systems operate on component data</td>\n</tr>\n<tr>\n<td>Entity Representation</td>\n<td>Object instance with identity</td>\n<td>Integer ID with component associations</td>\n</tr>\n<tr>\n<td>System Processing</td>\n<td>Object.update() on each entity</td>\n<td>Process component arrays in batches</td>\n</tr>\n<tr>\n<td>Memory Layout</td>\n<td>Random heap allocation</td>\n<td>Dense arrays with predictable access patterns</td>\n</tr>\n</tbody></table>\n<p>The ECS approach excels when games need to process large numbers of similar entities efficiently. A system updating positions of 10,000 moving entities can iterate through a dense array of <code>PositionComponent</code> structs, performing the same operation on each one with optimal cache utilization and potential for SIMD vectorization.</p>\n<p><strong>ECS Implementation Variations:</strong></p>\n<p>Different ECS implementations make different trade-offs around component storage, query performance, and system execution:</p>\n<table>\n<thead>\n<tr>\n<th>Implementation Style</th>\n<th>Component Storage</th>\n<th>Query Performance</th>\n<th>Memory Overhead</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Archetype-based</td>\n<td>Group entities by component signature</td>\n<td>Very fast iteration</td>\n<td>Higher memory usage</td>\n</tr>\n<tr>\n<td>Sparse Set</td>\n<td>Hash tables mapping entity→component</td>\n<td>Fast random access</td>\n<td>Lower memory usage</td>\n</tr>\n<tr>\n<td>Bitset-based</td>\n<td>Component presence tracked in bitfields</td>\n<td>Medium performance</td>\n<td>Lowest overhead</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Combines multiple approaches</td>\n<td>Balanced performance</td>\n<td>Medium overhead</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: ECS vs Component-Based Architecture</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Modern games require processing thousands of entities per frame with complex interactions, while maintaining code maintainability for large development teams  </li>\n<li><strong>Options Considered</strong>: Enhanced component-based, ECS with archetype storage, ECS with sparse sets  </li>\n<li><strong>Decision</strong>: ECS with archetype-based storage for this educational engine  </li>\n<li><strong>Rationale</strong>: Archetype storage provides optimal iteration performance for the common case of processing many entities with the same component combination, while still supporting complex queries and dynamic component addition/removal  </li>\n<li><strong>Consequences</strong>: Excellent performance for batch processing, clear separation of data and logic, but requires learning curve for developers familiar with OOP approaches and adds complexity around component relationships</li>\n</ul>\n</blockquote>\n<p>However, ECS architectures introduce their own challenges:</p>\n<p><strong>System Dependency Management:</strong> Systems still need to execute in correct order, but the dependencies are now implicit in the component data they read and write. A physics system that writes to <code>PositionComponent</code> must execute before a rendering system that reads from <code>PositionComponent</code>.</p>\n<p><strong>Component Relationships:</strong> Pure ECS prohibits components from referencing each other directly, but games often need relationships like &quot;this weapon belongs to this player&quot; or &quot;this UI element displays this entity&#39;s health.&quot; Various solutions exist, from entity reference components to separate relationship management systems.</p>\n<p><strong>Query Complexity:</strong> As systems need to operate on more complex combinations of components, the query system becomes a critical performance bottleneck. Finding all entities with components A, B, and C but not component D requires efficient data structures and algorithms.</p>\n<p><strong>Dynamic Component Changes:</strong> Adding or removing components from entities during system execution can invalidate iterators or change archetype assignments, requiring careful handling to avoid crashes or inconsistent state.</p>\n<h4 id=\"architecture-selection-criteria\">Architecture Selection Criteria</h4>\n<p>The choice between these architectural approaches depends on several factors that vary by project context:</p>\n<table>\n<thead>\n<tr>\n<th>Factor</th>\n<th>Monolithic</th>\n<th>Component-Based</th>\n<th>ECS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Team Size</td>\n<td>1-3 developers</td>\n<td>3-10 developers</td>\n<td>5+ developers</td>\n</tr>\n<tr>\n<td>Entity Count</td>\n<td>&lt;100 active entities</td>\n<td>100-1000 entities</td>\n<td>1000+ entities</td>\n</tr>\n<tr>\n<td>Performance Requirements</td>\n<td>Platform-specific optimization</td>\n<td>Balanced performance/maintainability</td>\n<td>Maximum performance</td>\n</tr>\n<tr>\n<td>Development Timeline</td>\n<td>Short (weeks/months)</td>\n<td>Medium (months/year)</td>\n<td>Long (year+)</td>\n</tr>\n<tr>\n<td>Code Reuse Needs</td>\n<td>Minimal</td>\n<td>Moderate</td>\n<td>High</td>\n</tr>\n<tr>\n<td>System Complexity</td>\n<td>Simple, well-understood</td>\n<td>Medium complexity</td>\n<td>Complex, evolving</td>\n</tr>\n</tbody></table>\n<p>For this educational project, we&#39;ve chosen an <strong>ECS architecture with archetype-based storage</strong> because:</p>\n<ol>\n<li><strong>Learning Value:</strong> ECS represents current best practices in game engine design and exposes learners to data-oriented programming principles</li>\n<li><strong>Performance Characteristics:</strong> The archetype approach provides excellent iteration performance while remaining conceptually understandable  </li>\n<li><strong>Scalability:</strong> The architecture can handle both simple games with dozens of entities and complex simulations with thousands</li>\n<li><strong>Industry Relevance:</strong> Major engines (Unity DOTS, Unreal Engine 5, custom AAA engines) are moving toward ECS-based approaches</li>\n</ol>\n<blockquote>\n<p><strong>Key Architectural Insight:</strong> The evolution from monolithic to component-based to ECS architectures reflects the gaming industry&#39;s growing understanding that <strong>data access patterns are the primary performance bottleneck in game engines</strong>. Each architectural evolution has optimized data layout and access patterns at the cost of increased conceptual complexity.</p>\n</blockquote>\n<p>The remainder of this design document will detail how each engine subsystem implements ECS principles while addressing the core technical challenges identified in this section.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Window Management</td>\n<td>SDL2 (simple API, good tutorials)</td>\n<td>GLFW (lightweight, more control)</td>\n</tr>\n<tr>\n<td>Graphics API</td>\n<td>OpenGL 3.3+ (mature, well-documented)</td>\n<td>Vulkan (modern, explicit control)</td>\n</tr>\n<tr>\n<td>Math Library</td>\n<td>GLM (C++ header-only)</td>\n<td>Custom implementation (learning value)</td>\n</tr>\n<tr>\n<td>Build System</td>\n<td>CMake (cross-platform, widely used)</td>\n<td>Premake5 (Lua-based, cleaner syntax)</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Catch2 (header-only, minimal setup)</td>\n<td>Google Test (more features)</td>\n</tr>\n<tr>\n<td>Profiling</td>\n<td>Built-in timers (simple debugging)</td>\n<td>Tracy Profiler (advanced analysis)</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>Starting with proper organization prevents the &quot;everything in main.cpp&quot; problem that plagues many learning projects:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>game-engine/\n├── src/\n│   ├── core/                     ← Core engine systems\n│   │   ├── Application.h/cpp     ← Main application loop\n│   │   ├── Window.h/cpp          ← Platform window abstraction\n│   │   └── Timer.h/cpp           ← Frame timing utilities\n│   ├── ecs/                      ← Entity-Component-System\n│   │   ├── Entity.h              ← Entity ID management\n│   │   ├── Component.h           ← Component base types\n│   │   ├── System.h              ← System base class\n│   │   └── World.h/cpp           ← ECS coordinator\n│   ├── rendering/                ← Graphics pipeline\n│   │   ├── Renderer.h/cpp        ← Main rendering interface\n│   │   ├── Shader.h/cpp          ← Shader compilation\n│   │   ├── Texture.h/cpp         ← Texture loading\n│   │   └── Sprite.h/cpp          ← 2D sprite rendering\n│   ├── physics/                  ← Physics simulation\n│   │   ├── RigidBody.h/cpp       ← Physics bodies\n│   │   ├── Collider.h/cpp        ← Collision detection\n│   │   └── PhysicsWorld.h/cpp    ← Physics simulation\n│   └── resources/                ← Asset management\n│       ├── ResourceManager.h/cpp ← Resource loading/caching\n│       ├── Asset.h               ← Asset base types\n│       └── Handle.h              ← Resource handle system\n├── assets/                       ← Game assets\n│   ├── textures/\n│   ├── shaders/\n│   └── scenes/\n├── tests/                        ← Unit tests\n│   ├── ecs_tests.cpp\n│   ├── physics_tests.cpp\n│   └── rendering_tests.cpp\n└── examples/                     ← Sample games\n    ├── simple_2d/\n    └── physics_demo/</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Basic Application Framework</strong> (complete implementation to handle platform details):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/core/Application.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Window</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Renderer</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ECSWorld</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Application</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Application</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> title</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> width</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> height</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~Application</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Run</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">protected:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Render</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Window</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_window;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Renderer</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_renderer;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ECSWorld</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_world;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> m_running;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> InternalInitialize</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ProcessEvents</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> InternalShutdown</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Usage: inherit from Application and override virtual methods</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MyGame</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> Application</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MyGame</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">Application</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"My Game\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1280</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">720</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">protected:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Create entities, load assets, setup systems</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Update game logic, run ECS systems</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Frame Timing Utilities</strong> (complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/core/Timer.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Timer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Timer</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Reset</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetElapsedSeconds</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetElapsedMilliseconds</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::time_point m_startTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FrameTimer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FrameTimer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> targetFPS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> BeginFrame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> EndFrame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetDeltaTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_deltaTime; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetFPS</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_fps; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> ShouldLimitFrameRate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_targetFPS;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_targetFrameTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_deltaTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_fps;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timer m_frameTimer;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::time_point m_lastFrame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"core-learning-skeleton-code\">Core Learning Skeleton Code</h4>\n<p><strong>ECS World Interface</strong> (learner implements the core ECS logic):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/ecs/World.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"Entity.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"Component.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"System.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ECSWorld</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ECSWorld</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~ECSWorld</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity management - LEARNER IMPLEMENTS</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> CreateEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> DestroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsEntityValid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component management - LEARNER IMPLEMENTS  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> AddComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if entity is valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if component type already exists on entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Create component in appropriate storage array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Update entity's component signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update archetype if using archetype-based storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Return reference to created component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if entity has this component type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Remove component from storage array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Update entity's component signature  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Update archetype assignment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Handle component array compaction if needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if entity has this component type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Find component in storage array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return pointer to component data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // HINT: Return nullptr if component doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System management - LEARNER IMPLEMENTS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RegisterSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create system instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Store system in execution order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Set up system's component signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Initialize system with world reference</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> UpdateSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Define data structures for entity storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Define component storage arrays</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Define system execution list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Define entity-to-archetype mapping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HINT: Consider using std::vector for component arrays</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HINT: Consider using std::unordered_map for entity lookups</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>C++ Memory Management:</strong></p>\n<ul>\n<li>Use <code>std::vector</code> for component storage arrays — they provide cache-friendly dense storage</li>\n<li>Use <code>std::unique_ptr</code> for systems to ensure automatic cleanup  </li>\n<li>Consider <code>std::unordered_map&lt;Entity, ComponentMask&gt;</code> for tracking which components each entity has</li>\n<li>Use placement new for custom component construction: <code>new(&amp;storage[index]) ComponentType(args...)</code></li>\n</ul>\n<p><strong>Template Metaprogramming:</strong></p>\n<ul>\n<li>Use <code>std::type_index</code> to get unique identifiers for component types</li>\n<li>Consider <code>typeid(T).hash_code()</code> for component type hashing</li>\n<li>Use SFINAE or <code>std::enable_if</code> to constrain template functions to component types</li>\n</ul>\n<p><strong>Performance Optimization:</strong></p>\n<ul>\n<li>Reserve capacity in vectors during initialization: <code>components.reserve(1000)</code></li>\n<li>Use <code>emplace_back</code> instead of <code>push_back</code> for in-place construction</li>\n<li>Consider using <code>std::array</code> for fixed-size component signatures</li>\n<li>Profile with <code>-O2</code> optimization to see actual performance characteristics</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After completing basic ECS framework:</strong></p>\n<p>Run this test to verify entity creation and component management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test entity lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ECSWorld world;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Entity entity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.</span><span style=\"color:#B392F0\">CreateEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(world.</span><span style=\"color:#B392F0\">IsEntityValid</span><span style=\"color:#E1E4E8\">(entity));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test component addition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> transform </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.AddComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Transform</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity, Vector3{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(world.GetComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Transform</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test component removal  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">world.RemoveComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Transform</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(world.GetComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Transform</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test entity destruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">world.</span><span style=\"color:#B392F0\">DestroyEntity</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">world.</span><span style=\"color:#B392F0\">IsEntityValid</span><span style=\"color:#E1E4E8\">(entity));</span></span></code></pre></div>\n\n<p><strong>Expected behavior:</strong></p>\n<ul>\n<li>Entity IDs should be unique across creation/destruction cycles</li>\n<li>Components should be accessible immediately after addition</li>\n<li>Memory should be released when entities/components are destroyed</li>\n<li>No crashes or memory leaks during normal operation</li>\n</ul>\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li>Segmentation faults during component access → Check bounds and null pointers</li>\n<li>Memory continuously growing → Missing destructors or cleanup logic</li>\n<li>Assertion failures → Entity/component state management issues</li>\n<li>Slow performance → May be using inefficient data structures</li>\n</ul>\n<p><strong>Debugging approach:</strong></p>\n<ol>\n<li>Add logging to entity create/destroy to track ID reuse</li>\n<li>Add assertions to component add/remove to verify state consistency  </li>\n<li>Use AddressSanitizer (<code>-fsanitize=address</code>) to catch memory errors</li>\n<li>Profile with simple timer around ECS operations to identify bottlenecks</li>\n</ol>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — defines the scope and success criteria for the entire project</p>\n</blockquote>\n<p>Building a game engine presents a paradox: the more features you add, the more complex the architecture becomes, yet each new feature seems essential for creating compelling games. This section establishes clear boundaries around what our educational game engine will accomplish, ensuring we build a solid foundation without drowning in scope creep. Think of this as drafting the blueprint for a house — we need to decide whether we&#39;re building a cozy cabin or a mansion before we start laying the foundation.</p>\n<p>The challenge in scoping a game engine lies in balancing educational value with practical constraints. A production game engine like Unreal or Unity represents millions of lines of code and decades of engineering effort. Our goal is to distill the core architectural patterns and engineering challenges into a manageable project that teaches the fundamental concepts without overwhelming complexity. We want learners to experience the &quot;aha moments&quot; of understanding ECS design, graphics pipeline optimization, and physics simulation without getting lost in the weeds of advanced rendering techniques or platform-specific optimizations.</p>\n<p>Our approach follows the principle of &quot;depth over breadth&quot; — rather than building a shallow implementation of dozens of features, we&#39;ll create a robust, well-architected implementation of the core systems that every game engine needs. This means our renderer might not support advanced lighting models, but it will demonstrate proper resource management, batch rendering, and shader compilation. Our physics system might not handle complex constraints, but it will showcase spatial partitioning, collision detection, and deterministic simulation.</p>\n<h3 id=\"functional-requirements\">Functional Requirements</h3>\n<p>The core functional requirements define the minimum viable feature set that transforms our codebase from a graphics demo into a legitimate game engine. These requirements are directly tied to the four project milestones and represent the essential capabilities that any 2D or simple 3D game would need.</p>\n<p><strong>Window and Platform Management</strong> forms the foundation layer that connects our engine to the operating system. The engine must create application windows with configurable dimensions, handle window resize events gracefully, and process input from keyboard and mouse devices. This includes managing the application lifecycle — starting up cleanly, running a stable game loop, and shutting down without resource leaks. The platform layer should abstract away operating system differences, allowing the same engine code to run on Windows, macOS, and Linux without modification.</p>\n<p><strong>Graphics Rendering Pipeline</strong> provides the visual output capabilities that bring game worlds to life. The renderer must initialize a modern graphics context (OpenGL 3.3+ or Vulkan), compile and link shader programs from source files, and render textured sprites and 3D meshes to the screen. The system needs to support basic transformations — translation, rotation, and scaling — applied to individual objects. Texture loading should handle common image formats (PNG, JPEG) and upload pixel data to GPU memory efficiently. The rendering architecture should use batch rendering to minimize draw calls, combining multiple objects with the same shader and texture into single GPU commands.</p>\n<table>\n<thead>\n<tr>\n<th>Rendering Feature</th>\n<th>Requirement</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Window Creation</td>\n<td>Configurable resolution and title</td>\n<td>Window appears with requested dimensions, processes close events</td>\n</tr>\n<tr>\n<td>Graphics Context</td>\n<td>OpenGL 3.3+ or Vulkan initialization</td>\n<td>Context creation succeeds, basic state management works</td>\n</tr>\n<tr>\n<td>Shader System</td>\n<td>Vertex and fragment shader compilation</td>\n<td>Shaders load from files, compilation errors are reported clearly</td>\n</tr>\n<tr>\n<td>Texture Loading</td>\n<td>PNG/JPEG image file support</td>\n<td>Images load from disk, upload to GPU, render correctly</td>\n</tr>\n<tr>\n<td>Sprite Rendering</td>\n<td>2D textured rectangles</td>\n<td>Sprites draw at specified positions with rotation and scaling</td>\n</tr>\n<tr>\n<td>Mesh Rendering</td>\n<td>Basic 3D geometry</td>\n<td>Simple meshes (cubes, spheres) render with textures and transforms</td>\n</tr>\n<tr>\n<td>Batch Rendering</td>\n<td>Multiple objects per draw call</td>\n<td>Performance scales well with hundreds of sprites on screen</td>\n</tr>\n</tbody></table>\n<p><strong>Entity Component System Architecture</strong> enables flexible game object composition and efficient data processing. The ECS must support creating and destroying entities with unique identifiers, adding and removing components dynamically, and executing systems that process entities with specific component combinations. Entity creation should return recyclable IDs to prevent integer overflow in long-running games. Component storage needs to support arbitrary data types while maintaining cache-friendly memory layout. System execution should iterate over entities matching query patterns (e.g., &quot;all entities with Transform and Sprite components&quot;) without scanning irrelevant data.</p>\n<p><strong>Physics and Collision Detection</strong> brings realistic movement and interaction to game objects. The physics system must implement rigid body dynamics with configurable mass, velocity, and acceleration properties. Collision detection needs to identify overlapping objects using both axis-aligned bounding boxes (AABB) and circle colliders. The broad phase should use spatial partitioning to avoid O(n²) collision checks when many objects are present. Collision response must apply realistic impulse forces and position corrections to separate overlapping bodies. The physics timestep should be fixed and deterministic, ensuring consistent behavior regardless of frame rate variations.</p>\n<table>\n<thead>\n<tr>\n<th>Physics Feature</th>\n<th>Requirement</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Rigid Bodies</td>\n<td>Mass, velocity, acceleration simulation</td>\n<td>Objects fall under gravity, respond to forces naturally</td>\n</tr>\n<tr>\n<td>AABB Collision</td>\n<td>Rectangle-rectangle overlap detection</td>\n<td>Fast broad-phase culling of non-overlapping pairs</td>\n</tr>\n<tr>\n<td>Circle Collision</td>\n<td>Circle-circle intersection tests</td>\n<td>Accurate narrow-phase detection with contact points</td>\n</tr>\n<tr>\n<td>Spatial Partitioning</td>\n<td>Grid or quadtree optimization</td>\n<td>Collision performance scales sub-quadratically</td>\n</tr>\n<tr>\n<td>Collision Response</td>\n<td>Impulse-based separation</td>\n<td>Objects bounce and separate realistically after contact</td>\n</tr>\n<tr>\n<td>Fixed Timestep</td>\n<td>Deterministic simulation step</td>\n<td>Physics behaves identically across different frame rates</td>\n</tr>\n</tbody></table>\n<p><strong>Resource and Scene Management</strong> provides the infrastructure for loading game assets and organizing content. The resource system must load textures, audio files, and data files from disk, returning typed handles that remain valid throughout the asset&#39;s lifetime. Resource caching should prevent duplicate loading of the same file and automatically free unused assets when no references remain. Scene management needs to serialize the current game state to files and restore complete scenes from saved data. Scene transitions should cleanly unload previous content and load new assets without memory leaks or dangling references.</p>\n<blockquote>\n<p><strong>Design Principle: Modularity and Extensibility</strong></p>\n<p>Each functional requirement is designed to be independently testable and replaceable. The rendering system doesn&#39;t directly reference physics components, and the ECS doesn&#39;t hard-code specific component types. This separation enables iterative development — learners can build and test the renderer before implementing physics, or experiment with different ECS storage strategies without breaking other systems.</p>\n</blockquote>\n<h3 id=\"performance-and-quality-requirements\">Performance and Quality Requirements</h3>\n<p>Performance requirements establish the quantitative benchmarks that distinguish a usable game engine from an academic exercise. These targets reflect the constraints that real games face — maintaining smooth frame rates, managing limited memory, and providing responsive user interaction. The requirements are aggressive enough to force good architectural decisions but achievable with careful implementation.</p>\n<p><strong>Frame Rate and Timing Constraints</strong> define the real-time performance expectations that games demand. The engine must maintain a stable 60 FPS (16.67ms frame time budget) when rendering scenes with up to 1,000 dynamic sprites or 10,000 static sprites on modern hardware (GTX 1060 / RX 580 class graphics cards). Frame time consistency matters more than peak performance — frame times should stay within ±2ms of the target to avoid visible stuttering. The game loop must support both fixed timestep physics simulation and variable timestep rendering, allowing physics to run at 60Hz even if rendering occasionally drops frames.</p>\n<p>The engine should demonstrate graceful performance degradation rather than sudden frame rate cliffs. When scenes exceed the target complexity, frame rates should decrease gradually while maintaining playable performance above 30 FPS. This requires careful profiling and optimization of the most expensive code paths — typically ECS iteration, collision detection, and draw call submission.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Target</th>\n<th>Minimum Requirement</th>\n<th>Optimal Target</th>\n<th>Measurement Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame Rate</td>\n<td>30 FPS sustained</td>\n<td>60 FPS sustained</td>\n<td>Frame time histogram over 30 seconds</td>\n</tr>\n<tr>\n<td>Frame Time Variance</td>\n<td>±5ms from average</td>\n<td>±2ms from average</td>\n<td>Standard deviation of frame times</td>\n</tr>\n<tr>\n<td>Sprite Capacity</td>\n<td>500 dynamic sprites</td>\n<td>1,000 dynamic sprites</td>\n<td>Stress test with moving textured quads</td>\n</tr>\n<tr>\n<td>Physics Objects</td>\n<td>100 colliding bodies</td>\n<td>500 colliding bodies</td>\n<td>Collision detection benchmark</td>\n</tr>\n<tr>\n<td>Memory Usage</td>\n<td>&lt;100MB for basic scenes</td>\n<td>&lt;50MB for basic scenes</td>\n<td>Process memory monitoring</td>\n</tr>\n<tr>\n<td>Startup Time</td>\n<td>&lt;5 seconds cold start</td>\n<td>&lt;2 seconds cold start</td>\n<td>Time from launch to first rendered frame</td>\n</tr>\n</tbody></table>\n<p><strong>Memory Management and Resource Efficiency</strong> ensure the engine runs reliably on systems with limited RAM and prevents resource leaks that accumulate during long gameplay sessions. Total memory usage should remain under 100MB for typical game scenes containing dozens of textures, hundreds of entities, and thousands of components. Memory allocation patterns should minimize garbage collection pressure in managed languages and avoid memory fragmentation in native languages.</p>\n<p>The ECS component storage should demonstrate cache-friendly data layout, achieving measurable performance improvements over naive array-of-structs organization. System iteration benchmarks should show linear scaling with entity count, not quadratic or worse complexity. Resource loading and caching should prevent duplicate allocations — loading the same texture file multiple times should return the same GPU resource handle without consuming additional memory.</p>\n<p><strong>Code Quality and Maintainability Standards</strong> establish the architectural discipline that makes the codebase a good learning resource and enables future extensions. The engine should demonstrate clear separation of concerns between subsystems, with well-defined interfaces that could theoretically be swapped out independently. Error handling must be comprehensive and informative — graphics context failures, file loading errors, and physics simulation edge cases should produce clear diagnostic messages rather than silent failures or crashes.</p>\n<blockquote>\n<p><strong>Architecture Decision: Performance vs. Simplicity Trade-offs</strong></p>\n<ul>\n<li><strong>Context</strong>: Educational engines can prioritize either maximum performance or code clarity</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Maximum optimization with complex memory management and SIMD intrinsics</li>\n<li>Moderate optimization focusing on algorithmic efficiency and cache-friendly data layout</li>\n<li>Simple implementation prioritizing code readability over performance</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Moderate optimization approach with clear performance measurement</li>\n<li><strong>Rationale</strong>: Learners need to understand why performance matters and experience the impact of architectural decisions, but shouldn&#39;t get lost in low-level optimization techniques that obscure the core concepts</li>\n<li><strong>Consequences</strong>: Performance targets are achievable without heroic optimization efforts, and code remains readable for educational purposes while demonstrating real-world performance considerations</li>\n</ul>\n</blockquote>\n<p>Unit test coverage should reach 80% for critical systems like ECS queries, collision detection algorithms, and resource management. Integration tests should verify end-to-end functionality — creating entities with components, running physics simulation, and rendering the results to screen. Performance regression tests should catch algorithmic complexity increases that might not be obvious during development.</p>\n<h3 id=\"scope-exclusions\">Scope Exclusions</h3>\n<p>Defining what the engine will NOT implement is crucial for maintaining focus and preventing scope creep that could derail the educational objectives. These exclusions represent features that, while valuable in production engines, would add significant complexity without proportional learning benefit for the core architectural concepts.</p>\n<p><strong>Advanced Rendering Features</strong> are explicitly out of scope to keep the graphics pipeline understandable and maintainable. The engine will not implement dynamic lighting systems, shadow mapping, post-processing effects, or modern physically-based rendering (PBR) techniques. Particle systems, skeletal animation, and level-of-detail (LOD) management add substantial complexity to the renderer without teaching fundamentally new architectural patterns. The focus remains on demonstrating proper resource management, batch rendering optimization, and shader compilation rather than advanced graphics techniques.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Feature</th>\n<th>Rationale</th>\n<th>Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dynamic Lighting</td>\n<td>Requires complex shader management and scene graph traversal</td>\n<td>Basic ambient lighting or pre-lit textures</td>\n</tr>\n<tr>\n<td>Shadow Mapping</td>\n<td>Involves render-to-texture and multiple rendering passes</td>\n<td>Simple sprite layering for depth illusion</td>\n</tr>\n<tr>\n<td>Post-Processing</td>\n<td>Needs framebuffer management and effect chaining</td>\n<td>Direct-to-screen rendering only</td>\n</tr>\n<tr>\n<td>Particle Systems</td>\n<td>Complex lifecycle management and instanced rendering</td>\n<td>Static sprite animation</td>\n</tr>\n<tr>\n<td>Skeletal Animation</td>\n<td>Bone hierarchies and vertex skinning calculations</td>\n<td>Sprite-based animation frames</td>\n</tr>\n<tr>\n<td>PBR Materials</td>\n<td>Advanced BRDF calculations and HDR pipeline</td>\n<td>Simple diffuse textures</td>\n</tr>\n</tbody></table>\n<p><strong>Audio System Implementation</strong> is deferred to keep the project focused on the core engine architecture patterns. While audio is essential for complete games, implementing 3D positional audio, mixing, and format decoding would require substantial additional infrastructure that doesn&#39;t reinforce the ECS, physics, or rendering concepts that form the project&#39;s educational core. Learners interested in audio can integrate existing libraries like OpenAL or FMOD after mastering the foundational systems.</p>\n<p><strong>Advanced Physics Features</strong> beyond basic rigid body simulation are excluded to prevent the physics system from overshadowing other components. The engine will not implement joints and constraints, soft-body dynamics, fluid simulation, or advanced collision shapes beyond AABB and circles. These features require sophisticated mathematical techniques and specialized data structures that would expand the physics milestone beyond reasonable scope.</p>\n<p><strong>Networking and Multiplayer Support</strong> represents an entire additional layer of complexity involving client-server architecture, state synchronization, prediction, and rollback systems. While fascinating from an engineering perspective, networking would require extending the ECS with replication systems, implementing deterministic physics, and handling connection management — topics that deserve their own dedicated project.</p>\n<p><strong>Scripting Language Integration</strong> such as embedding Lua, Python, or JavaScript interpreters would add significant complexity around memory management, error handling, and API design. The engine focuses on demonstrating core systems in native code rather than building the abstraction layers needed for safe scripting environments.</p>\n<p><strong>Platform-Specific Optimizations</strong> for mobile devices, consoles, or web deployment are excluded in favor of desktop cross-platform compatibility. Each platform introduces unique constraints around memory management, graphics APIs, and input handling that would fragment the codebase and obscure the core architectural lessons.</p>\n<p><strong>Visual Editing Tools</strong> like scene editors, visual scripting systems, or asset import pipelines represent separate applications built on top of the engine rather than core engine functionality. These tools require GUI frameworks, file format parsers, and undo/redo systems that would expand the project scope dramatically.</p>\n<blockquote>\n<p><strong>Key Insight: Scope Boundaries Enable Deep Learning</strong></p>\n<p>By aggressively limiting scope, we create space for deep exploration of the included features. A renderer that supports only basic textures and transforms can still demonstrate advanced batching techniques, resource management patterns, and performance optimization strategies. The goal is mastery of fundamental patterns rather than breadth of features.</p>\n</blockquote>\n<p><strong>Development Tools and Debugging Support</strong> beyond basic logging are excluded to keep the implementation focused. Production engines typically include visual debuggers, performance profilers, memory leak detection, and hot-reload systems for rapid iteration. While valuable, these tools represent significant development overhead that would distract from the core engine architecture lessons.</p>\n<p>The scope exclusions should be viewed as opportunities for future extension rather than permanent limitations. The modular architecture developed through the core milestones should support adding many of these features as subsequent learning projects. A student who masters the ECS pattern can later explore how networking replication components fit into the system. Someone who understands the rendering pipeline can investigate how shadow mapping techniques integrate with the existing shader infrastructure.</p>\n<p>This focused scope ensures that learners spend their time understanding the fundamental patterns that underlie all game engines — component-based architecture, resource lifetime management, performance-oriented data layout, and real-time system coordination — rather than getting lost in the implementation details of advanced features that obscure these core concepts.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation approach balances educational clarity with realistic engineering practices, providing complete working infrastructure while leaving the core learning challenges for hands-on development. This section bridges the gap between the design requirements and actual code, giving learners concrete starting points and clear success criteria.</p>\n<p><strong>Technology Recommendations and Trade-offs</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommendation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Window Management</td>\n<td>SDL2 (C-style API, wide compatibility)</td>\n<td>GLFW (modern C++ API, lightweight)</td>\n<td>GLFW for cleaner integration</td>\n</tr>\n<tr>\n<td>Graphics API</td>\n<td>OpenGL 3.3 (easier debugging, better tooling)</td>\n<td>Vulkan (explicit control, modern design)</td>\n<td>OpenGL 3.3 for educational clarity</td>\n</tr>\n<tr>\n<td>Math Library</td>\n<td>GLM (header-only, OpenGL-compatible)</td>\n<td>Custom implementation</td>\n<td>GLM to focus on engine architecture</td>\n</tr>\n<tr>\n<td>Image Loading</td>\n<td>stb_image (single-header, simple)</td>\n<td>DevIL/SOIL (more formats)</td>\n<td>stb_image for minimal dependencies</td>\n</tr>\n<tr>\n<td>Build System</td>\n<td>CMake (cross-platform, widely supported)</td>\n<td>Premake/Bazel (simpler syntax)</td>\n<td>CMake for industry relevance</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Catch2 (header-only, readable syntax)</td>\n<td>Google Test (more features)</td>\n<td>Catch2 for ease of integration</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Project Structure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">GameEngine</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── CMakeLists.txt</span><span style=\"color:#6A737D\">              // Build configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── external</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                   // Third-party dependencies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── glfw</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                  // Window management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── glm</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                   // Math library</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── stb</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                   // Image loading</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── src</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                       // Engine source code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── Core</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                  // Foundation classes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Application.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">  // Main application framework</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Window.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">       // Platform window abstraction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── Timer.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">        // Frame timing utilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── Rendering</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">             // Graphics pipeline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Renderer.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">     // Main rendering interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Shader.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">       // Shader compilation and management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Texture.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">      // Texture loading and binding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── Batch.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">        // Sprite batching system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ECS</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                   // Entity-Component-System</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── ECSWorld.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">     // Main ECS coordinator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Entity.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">       // Entity ID management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Component.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">    // Component storage templates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── System.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">       // System execution framework</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── Physics</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">               // Collision and dynamics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Rigidbody.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">    // Physics body representation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── Collision.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">    // Collision detection algorithms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── Spatial.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">      // Spatial partitioning grid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── Resources</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">             // Asset management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── ResourceManager.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">  // Handle-based resource cache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── Scene.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">        // Scene serialization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       └── Assets.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cpp</span><span style=\"color:#6A737D\">       // Asset type definitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── examples</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                  // Demo applications</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── basic_rendering</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">       // Milestone 1 example</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ecs_demo</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">             // Milestone 2 example</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── physics_test</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">         // Milestone 3 example</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── complete_game</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">        // Milestone 4 example</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── tests</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                    // Unit and integration tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── core_tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── rendering_tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── ecs_tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    └── physics_tests</span><span style=\"color:#F97583\">/</span></span></code></pre></div>\n\n<p><strong>Foundation Infrastructure (Complete Implementations)</strong></p>\n<p>The following components provide essential infrastructure that supports the main learning objectives without requiring deep implementation effort:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Timer.h - Frame timing and delta calculation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Timer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::time_point m_startTime;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::time_point m_lastFrame;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_deltaTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Timer</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">           // Call once per frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetDeltaTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_deltaTime; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetElapsedTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FrameTimer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> TARGET_FPS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> TARGET_FRAME_TIME </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> /</span><span style=\"color:#E1E4E8\"> TARGET_FPS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_frameAccumulator;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timer m_timer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FrameTimer</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">m_frameAccumulator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> ShouldUpdate</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">     // Returns true when physics should step</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetAlpha</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Interpolation factor for rendering</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> MarkFrameEnd</span><span style=\"color:#E1E4E8\">() { m_timer.</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Window.h - Platform abstraction for window management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;GLFW/glfw3.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> WindowConfig</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> width </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 800</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> height </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 600</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string title </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Game Engine\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> vsync </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> fullscreen </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Window</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GLFWwindow</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> m_window;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WindowConfig m_config;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Window</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> WindowConfig</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~Window</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> ShouldClose</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SwapBuffers</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> PollEvents</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Input queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsKeyPressed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> keyCode</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsMouseButtonPressed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> button</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">pair</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">GetMousePosition</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Window properties</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> GetWidth</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_config.width; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> GetHeight</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_config.height; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetAspectRatio</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Core Learning Skeletons (Headers + TODOs)</strong></p>\n<p>The main educational components provide detailed skeleton implementations that guide learners through the algorithm steps identified in the design sections:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ECSWorld.h - Main Entity-Component-System coordinator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#E1E4E8\"> Entity NULL_ENTITY </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> MAX_ENTITIES </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ECSWorld</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_availableEntities;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_nextEntityID;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component storage - one array per component type</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::type_index, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentArrayBase</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_componentArrays;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity signatures - which components each entity has</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity, ComponentSignature</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_entitySignatures;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ECSWorld</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity management</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> CreateEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> DestroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> AddComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">ComponentTypes</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">GetEntitiesWithComponents</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System execution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> SystemType</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RegisterSystem</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> UpdateSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement Entity CreateEntity()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Check if available entities queue has recycled IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. If queue empty, generate new ID from m_nextEntityID counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3. Verify new ID doesn't exceed MAX_ENTITIES limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4. Initialize empty component signature for the entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5. Return the entity ID</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement void DestroyEntity(Entity entity)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Verify entity exists in m_entitySignatures map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. Iterate through all component types in entity's signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3. Remove entity from each component array it belongs to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4. Clear entity's signature from the signatures map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5. Add entity ID to m_availableEntities queue for recycling</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Collision.h - Physics collision detection pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;glm/glm.hpp></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glm</span><span style=\"color:#E1E4E8\">::vec2 min, max;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Intersects</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glm</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vec2</span><span style=\"color:#B392F0\"> GetCenter</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (min </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> max) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glm</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vec2</span><span style=\"color:#B392F0\"> GetSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> max </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> min; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glm</span><span style=\"color:#E1E4E8\">::vec2 center;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> radius;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Intersects</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Intersects</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> box</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> CollisionPair</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity entityA, entityB;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glm</span><span style=\"color:#E1E4E8\">::vec2 normal;</span><span style=\"color:#6A737D\">      // Collision normal pointing from A to B</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> penetration;</span><span style=\"color:#6A737D\">     // How far objects are overlapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CollisionDetector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> SpatialGrid</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> cellSize;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> cells;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } m_grid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CollisionDetector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> gridCellSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Broad phase - spatial partitioning</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> UpdateSpatialGrid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entities</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">pair</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">>> </span><span style=\"color:#B392F0\">GetPotentialCollisions</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Narrow phase - geometric intersection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">CollisionPair</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">DetectCollisions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">pair</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">>></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> pairs</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                                               ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> GetGridKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> x</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> y</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">GetCellsForAABB</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> bounds</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement UpdateSpatialGrid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Clear all existing grid cells</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. For each entity, get its Transform and Collider components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3. Calculate AABB bounds from transform position and collider size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4. Determine which grid cells the AABB overlaps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5. Add entity ID to each overlapping cell's entity list</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement GetPotentialCollisions  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Create empty pairs list to return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. For each non-empty grid cell</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3. For each pair of entities within the same cell</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4. Ensure we don't duplicate pairs (entityA &#x3C; entityB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5. Add unique pairs to the potential collisions list</span></span></code></pre></div>\n\n<p><strong>Milestone Verification Checkpoints</strong></p>\n<p>Each milestone includes specific verification steps that confirm successful implementation:</p>\n<p><strong>Milestone 1 Checkpoint - Rendering Foundation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and run basic rendering example</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> build</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cmake</span><span style=\"color:#9ECBFF\"> ..</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./examples/basic_rendering</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Window opens at 800x600 resolution with title \"Basic Rendering\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Clear color cycles between red, green, blue every 2 seconds  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Single textured sprite renders at screen center</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Sprite rotates smoothly at 45 degrees per second</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Frame rate stays above 60 FPS (check console output)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Common issues and fixes:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Black screen: Check OpenGL context creation, verify shader compilation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Missing texture: Verify image file path, check stb_image linking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Poor performance: Ensure VSync is working, check for redundant state changes</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint - ECS Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">./examples/ecs_demo</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - 1000 entities created with Transform + Sprite components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Movement system updates all entity positions each frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Rendering system draws all entities without frame drops</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Console shows \"ECS Update: 1000 entities in &#x3C;2ms\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Memory usage stays under 50MB (check Task Manager/Activity Monitor)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Performance verification:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Run with 10,000 entities - should maintain >30 FPS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Component iteration should scale linearly with entity count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Memory layout should show cache-friendly access patterns in profiler</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<p>For C++ implementation, several platform and compiler considerations ensure smooth development:</p>\n<ul>\n<li>Use <code>std::chrono::high_resolution_clock</code> for precise frame timing measurements</li>\n<li>Leverage <code>std::type_index</code> for component type identification in template systems  </li>\n<li>Apply <code>std::unique_ptr</code> for automatic memory management of component arrays</li>\n<li>Utilize <code>constexpr</code> for compile-time constants like <code>MAX_ENTITIES</code> and <code>TARGET_FPS</code></li>\n<li>Employ range-based for loops when iterating over entity collections for readability</li>\n</ul>\n<p>OpenGL-specific recommendations include using <code>glGetError()</code> after each OpenGL call during development to catch state errors early. Shader compilation should check <code>GL_COMPILE_STATUS</code> and log the info log on failures. Texture uploads require matching internal format, format, and type parameters to avoid corruption.</p>\n<p>Physics simulation benefits from separating collision detection into distinct broad-phase and narrow-phase algorithms. The broad phase should use integer grid coordinates for efficient spatial hashing. Floating-point collision response calculations should use consistent epsilon values for numerical stability.</p>\n<p><strong>Common Implementation Pitfalls and Solutions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Problem</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ECS Iterator Invalidation</td>\n<td>Crashes during component iteration</td>\n<td>Adding/removing components while iterating</td>\n<td>Defer modifications until after iteration completes</td>\n</tr>\n<tr>\n<td>OpenGL State Leaks</td>\n<td>Textures render incorrectly</td>\n<td>Not restoring previous state after rendering</td>\n<td>Track and restore GL state or use state objects</td>\n</tr>\n<tr>\n<td>Physics Tunneling</td>\n<td>Fast objects pass through walls</td>\n<td>Large timestep or thin collision geometry</td>\n<td>Use swept collision detection or smaller timesteps</td>\n</tr>\n<tr>\n<td>Resource Handle Dangling</td>\n<td>Crashes when accessing resources</td>\n<td>Resource freed while handles still exist</td>\n<td>Implement reference counting or weak pointers</td>\n</tr>\n<tr>\n<td>Frame Rate Inconsistency</td>\n<td>Stuttering during gameplay</td>\n<td>Variable timestep affecting game logic</td>\n<td>Use fixed timestep for physics, variable for rendering</td>\n</tr>\n</tbody></table>\n<p>The implementation guidance provides enough structure to prevent common beginner mistakes while preserving the core learning challenges that make game engine development educational and rewarding.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — architecture decisions and module organization affect every stage of development</p>\n</blockquote>\n<p>Creating a game engine is like designing a <strong>theater production company</strong> that must coordinate multiple specialized departments to deliver a live performance every 16.67 milliseconds. Just as a theater has lighting technicians, stage managers, prop masters, and choreographers who must work in perfect synchronization, a game engine has rendering systems, entity managers, physics simulators, and resource loaders that must coordinate seamlessly within our frame time budget. The key architectural challenge is designing these systems to be loosely coupled yet efficiently coordinated, allowing each to focus on its specialized responsibilities while contributing to the unified goal of delivering smooth, interactive gameplay.</p>\n<p>The architecture we&#39;ll build follows <strong>data-oriented design</strong> principles, organizing code around how data flows through systems rather than traditional object-oriented hierarchies. This approach maximizes cache efficiency and enables the performance required for real-time simulation. Our engine will process thousands of entities per frame while maintaining deterministic behavior across different hardware configurations.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"Engine System Architecture\"></p>\n<h3 id=\"engine-subsystem-overview\">Engine Subsystem Overview</h3>\n<p>Our game engine architecture consists of five major subsystems, each with clearly defined responsibilities and interfaces. Think of these as <strong>specialized departments in a production facility</strong> — each department has specific expertise, tools, and outputs, but they must coordinate their work to deliver the final product.</p>\n<p>The <strong>Application</strong> subsystem serves as the executive coordinator, managing the overall lifecycle and orchestrating communication between other systems. The <strong>Window and Rendering</strong> subsystem acts as the visual presentation layer, transforming game data into pixels on screen. The <strong>ECS World</strong> manages all game entities and their data using data-oriented design. The <strong>Physics</strong> subsystem simulates realistic motion and collision responses. Finally, the <strong>Resource Manager</strong> handles loading, caching, and lifetime management of assets like textures, sounds, and scene data.</p>\n<table>\n<thead>\n<tr>\n<th>Subsystem</th>\n<th>Primary Responsibility</th>\n<th>Key Data Structures</th>\n<th>External Dependencies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Application</code></td>\n<td>Lifecycle management, system coordination</td>\n<td><code>WindowConfig</code>, <code>FrameTimer</code></td>\n<td>OS windowing API (SDL2/GLFW)</td>\n</tr>\n<tr>\n<td><code>Window</code> &amp; <code>Renderer</code></td>\n<td>Graphics output, input processing</td>\n<td><code>Renderer</code>, shader programs, vertex buffers</td>\n<td>OpenGL/Vulkan, graphics drivers</td>\n</tr>\n<tr>\n<td><code>ECSWorld</code></td>\n<td>Entity-component storage, system execution</td>\n<td><code>Entity</code> IDs, component arrays, system registry</td>\n<td>None (pure data management)</td>\n</tr>\n<tr>\n<td><code>Physics</code></td>\n<td>Collision detection, rigid body dynamics</td>\n<td><code>AABB</code>, <code>Circle</code>, <code>CollisionPair</code></td>\n<td>Mathematical libraries for transforms</td>\n</tr>\n<tr>\n<td><code>Resource Manager</code></td>\n<td>Asset loading, caching, handle management</td>\n<td>Resource handles, reference counters</td>\n<td>File I/O, image/audio decoders</td>\n</tr>\n</tbody></table>\n<p>Each subsystem exposes its functionality through well-defined interfaces that hide implementation details. This enables us to swap implementations (for example, changing from OpenGL to Vulkan rendering) without affecting other systems. The interfaces use handle-based access patterns rather than direct pointers, providing memory safety and enabling efficient resource management.</p>\n<blockquote>\n<p><strong>Design Principle: Interface Segregation</strong>\nEach subsystem interface contains only the methods that other systems actually need. For example, the physics system doesn&#39;t expose its internal spatial partitioning structure — it only provides collision detection results through the <code>CollisionPair</code> interface. This reduces coupling and makes the codebase easier to understand and maintain.</p>\n</blockquote>\n<p><strong>Application Subsystem Interface:</strong></p>\n<p>The <code>Application</code> class serves as the main engine coordinator, managing initialization, shutdown, and frame processing coordination.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Initialize</code></td>\n<td><code>WindowConfig</code> config</td>\n<td><code>bool</code> success</td>\n<td>Creates window, initializes graphics context and all subsystems</td>\n</tr>\n<tr>\n<td><code>Run</code></td>\n<td>none</td>\n<td><code>int</code> exit_code</td>\n<td>Enters main game loop, processing frames until exit requested</td>\n</tr>\n<tr>\n<td><code>Shutdown</code></td>\n<td>none</td>\n<td><code>void</code></td>\n<td>Cleanly destroys all subsystems and releases resources</td>\n</tr>\n<tr>\n<td><code>ShouldClose</code></td>\n<td>none</td>\n<td><code>bool</code></td>\n<td>Checks if application should terminate (window closed, quit requested)</td>\n</tr>\n<tr>\n<td><code>GetDeltaTime</code></td>\n<td>none</td>\n<td><code>float</code> seconds</td>\n<td>Returns frame time for current frame (time since last frame)</td>\n</tr>\n</tbody></table>\n<p><strong>Window and Renderer Subsystem Interface:</strong></p>\n<p>The windowing and rendering subsystems work together to manage platform-specific window creation and graphics pipeline execution.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateWindow</code></td>\n<td><code>WindowConfig</code> config</td>\n<td><code>Window*</code></td>\n<td>Creates platform window with specified resolution and title</td>\n</tr>\n<tr>\n<td><code>PollEvents</code></td>\n<td>none</td>\n<td><code>void</code></td>\n<td>Processes OS input events and updates input state</td>\n</tr>\n<tr>\n<td><code>SwapBuffers</code></td>\n<td>none</td>\n<td><code>void</code></td>\n<td>Presents rendered frame to screen and swaps front/back buffers</td>\n</tr>\n<tr>\n<td><code>ClearScreen</code></td>\n<td><code>Color</code> clear_color</td>\n<td><code>void</code></td>\n<td>Clears frame buffer to solid color before rendering</td>\n</tr>\n<tr>\n<td><code>RenderSprites</code></td>\n<td><code>SpriteRenderData[]</code> sprites</td>\n<td><code>void</code></td>\n<td>Batch renders textured quads with transforms and materials</td>\n</tr>\n<tr>\n<td><code>RenderMeshes</code></td>\n<td><code>MeshRenderData[]</code> meshes</td>\n<td><code>void</code></td>\n<td>Renders 3D geometry with vertex/index buffers and shaders</td>\n</tr>\n</tbody></table>\n<p><strong>ECS World Subsystem Interface:</strong></p>\n<p>The <code>ECSWorld</code> provides data-oriented entity management with efficient component storage and system iteration.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateEntity</code></td>\n<td>none</td>\n<td><code>Entity</code></td>\n<td>Allocates unique entity ID with generation counter for recycling</td>\n</tr>\n<tr>\n<td><code>DestroyEntity</code></td>\n<td><code>Entity</code> id</td>\n<td><code>void</code></td>\n<td>Removes entity and all associated components, recycles ID</td>\n</tr>\n<tr>\n<td><code>AddComponent&lt;T&gt;</code></td>\n<td><code>Entity</code> id, <code>T</code> data</td>\n<td><code>T&amp;</code> reference</td>\n<td>Attaches component data to entity, returns reference for modification</td>\n</tr>\n<tr>\n<td><code>RemoveComponent&lt;T&gt;</code></td>\n<td><code>Entity</code> id</td>\n<td><code>bool</code> success</td>\n<td>Removes specific component type from entity if present</td>\n</tr>\n<tr>\n<td><code>GetComponent&lt;T&gt;</code></td>\n<td><code>Entity</code> id</td>\n<td><code>T*</code> pointer</td>\n<td>Returns component pointer or nullptr if entity lacks component</td>\n</tr>\n<tr>\n<td><code>RegisterSystem&lt;T&gt;</code></td>\n<td>system constructor args</td>\n<td><code>void</code></td>\n<td>Adds system to execution pipeline with specified component requirements</td>\n</tr>\n<tr>\n<td><code>UpdateSystems</code></td>\n<td><code>float</code> delta_time</td>\n<td><code>void</code></td>\n<td>Executes all registered systems in dependency order</td>\n</tr>\n</tbody></table>\n<p><strong>Physics Subsystem Interface:</strong></p>\n<p>The physics system manages rigid body simulation and collision detection using spatial partitioning for performance.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>StepSimulation</code></td>\n<td><code>float</code> delta_time</td>\n<td><code>void</code></td>\n<td>Advances physics simulation by fixed timestep with accumulator</td>\n</tr>\n<tr>\n<td><code>AddRigidbody</code></td>\n<td><code>Entity</code> id, <code>RigidbodyComponent</code> body</td>\n<td><code>void</code></td>\n<td>Registers entity for physics simulation with mass and velocity</td>\n</tr>\n<tr>\n<td><code>AddCollider</code></td>\n<td><code>Entity</code> id, <code>AABB</code> or <code>Circle</code> shape</td>\n<td><code>void</code></td>\n<td>Adds collision shape to entity for intersection testing</td>\n</tr>\n<tr>\n<td><code>GetCollisions</code></td>\n<td>none</td>\n<td><code>CollisionPair[]</code></td>\n<td>Returns all collision pairs detected in current frame</td>\n</tr>\n<tr>\n<td><code>SetGravity</code></td>\n<td><code>Vector2</code> gravity</td>\n<td><code>void</code></td>\n<td>Sets global gravity vector applied to all rigidbodies</td>\n</tr>\n<tr>\n<td><code>Raycast</code></td>\n<td><code>Vector2</code> origin, <code>Vector2</code> direction, <code>float</code> distance</td>\n<td><code>Entity</code> hit</td>\n<td>Tests ray intersection against all colliders, returns first hit</td>\n</tr>\n</tbody></table>\n<p><strong>Resource Manager Subsystem Interface:</strong></p>\n<p>The resource system provides handle-based asset access with automatic loading, caching, and reference counting.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LoadTexture</code></td>\n<td><code>string</code> filepath</td>\n<td><code>TextureHandle</code></td>\n<td>Loads image file, uploads to GPU, returns handle for rendering</td>\n</tr>\n<tr>\n<td><code>LoadMesh</code></td>\n<td><code>string</code> filepath</td>\n<td><code>MeshHandle</code></td>\n<td>Loads 3D model data, uploads vertex/index buffers to GPU</td>\n</tr>\n<tr>\n<td><code>LoadAudio</code></td>\n<td><code>string</code> filepath</td>\n<td><code>AudioHandle</code></td>\n<td>Loads audio file into memory for playback by audio system</td>\n</tr>\n<tr>\n<td><code>LoadScene</code></td>\n<td><code>string</code> filepath</td>\n<td><code>SceneHandle</code></td>\n<td>Deserializes scene file containing entity and component data</td>\n</tr>\n<tr>\n<td><code>GetTexture</code></td>\n<td><code>TextureHandle</code> handle</td>\n<td><code>Texture*</code></td>\n<td>Returns pointer to loaded texture resource or nullptr if invalid</td>\n</tr>\n<tr>\n<td><code>ReleaseResource</code></td>\n<td><code>ResourceHandle</code> handle</td>\n<td><code>void</code></td>\n<td>Decrements reference count, frees resource when count reaches zero</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Design Decision: Handle-Based Resource Access</strong>\nWe use opaque handles instead of direct pointers for resource access. This provides memory safety (handles can be validated), enables efficient reference counting, and allows resources to be relocated in memory without breaking client code. The trade-off is an extra indirection on every resource access, but this cost is minimal compared to the benefits.</p>\n</blockquote>\n<h3 id=\"frame-processing-pipeline\">Frame Processing Pipeline</h3>\n<p>The frame processing pipeline orchestrates all subsystems to deliver smooth, consistent gameplay at our target frame rate. Think of this as a <strong>factory assembly line</strong> where each station performs specific operations on the data flowing through, and the entire line must complete its work within our 16.67 millisecond frame time budget.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fframe-processing-flow.svg\" alt=\"Frame Processing Pipeline\"></p>\n<p>The pipeline follows a strict order to ensure deterministic behavior: input processing captures player actions, ECS systems update game logic, physics simulation resolves collisions and movement, rendering draws the updated scene, and finally frame timing ensures we maintain consistent frame rates. Each phase has access to the results of previous phases but cannot modify data that earlier phases depend on.</p>\n<blockquote>\n<p><strong>Design Principle: Frame Determinism</strong>\nThe order of operations within each frame is critical for deterministic behavior. Physics must run after game logic updates (so movement commands take effect) but before rendering (so visual output reflects physics results). This ordering ensures the same sequence of inputs produces identical results across different runs.</p>\n</blockquote>\n<p><strong>Detailed Frame Processing Steps:</strong></p>\n<ol>\n<li><p><strong>Frame Timer Update</strong>: The <code>FrameTimer</code> calculates elapsed time since the last frame and updates the delta time value that will be passed to all update systems. This measurement must occur first to ensure accurate timing for physics and animation systems.</p>\n</li>\n<li><p><strong>Input Event Processing</strong>: The <code>Window</code> system calls <code>PollEvents()</code> to process all OS-generated input events (keyboard, mouse, window events) that accumulated since the last frame. Input state is updated in internal buffers that game systems can query.</p>\n</li>\n<li><p><strong>ECS System Execution</strong>: The <code>ECSWorld</code> calls <code>UpdateSystems(delta_time)</code> to execute all registered game logic systems in dependency order. Systems process entities with specific component signatures, updating game state, animations, AI behavior, and other non-physics logic.</p>\n</li>\n<li><p><strong>Physics Simulation Step</strong>: The physics system calls <code>StepSimulation(delta_time)</code> using fixed timestep integration. This updates entity positions based on velocities, performs collision detection using spatial partitioning, and resolves collisions with impulse-based response.</p>\n</li>\n<li><p><strong>Rendering Pipeline Execution</strong>: The renderer clears the screen, gathers all entities with rendering components (sprites, meshes, transforms), sorts them by depth and material, batches draw calls to minimize state changes, and submits rendering commands to the GPU.</p>\n</li>\n<li><p><strong>Frame Presentation</strong>: The renderer calls <code>SwapBuffers()</code> to present the completed frame to the screen and swap front/back buffers. This synchronizes with the display&#39;s refresh rate when vsync is enabled.</p>\n</li>\n<li><p><strong>Frame Time Regulation</strong>: The <code>FrameTimer</code> enforces frame rate limiting by sleeping if the frame completed faster than our target frame time, ensuring consistent frame pacing even when the workload varies.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Processing Phase</th>\n<th>Input Dependencies</th>\n<th>Output Results</th>\n<th>Max Time Budget</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Timer Update</td>\n<td>Previous frame timestamp</td>\n<td>Current <code>delta_time</code></td>\n<td>0.1ms</td>\n</tr>\n<tr>\n<td>Input Processing</td>\n<td>OS event queue</td>\n<td>Input state buffers</td>\n<td>0.5ms</td>\n</tr>\n<tr>\n<td>ECS System Updates</td>\n<td>Game state, input, <code>delta_time</code></td>\n<td>Updated component data</td>\n<td>8.0ms</td>\n</tr>\n<tr>\n<td>Physics Simulation</td>\n<td>Rigidbody/collider components</td>\n<td>New positions, collision events</td>\n<td>4.0ms</td>\n</tr>\n<tr>\n<td>Rendering Pipeline</td>\n<td>Transform/sprite/mesh components</td>\n<td>GPU command submission</td>\n<td>3.0ms</td>\n</tr>\n<tr>\n<td>Frame Presentation</td>\n<td>Completed GPU commands</td>\n<td>Screen pixel updates</td>\n<td>1.0ms</td>\n</tr>\n<tr>\n<td><strong>Total Frame Budget</strong></td>\n<td></td>\n<td></td>\n<td><strong>16.67ms (60 FPS)</strong></td>\n</tr>\n</tbody></table>\n<p>The time budgets shown above are recommendations based on typical game engine performance characteristics. The largest allocation goes to ECS system updates because this includes all game-specific logic that varies widely between different games. Physics and rendering have more predictable performance characteristics that can be optimized at the engine level.</p>\n<blockquote>\n<p><strong>Performance Critical Path</strong>\nThe ECS system update phase typically consumes the most frame time because it includes all game-specific logic. This is why data-oriented design and cache-friendly component iteration are essential — inefficient ECS access patterns can easily cause frame rate drops when processing thousands of entities.</p>\n</blockquote>\n<p><strong>Inter-System Communication Patterns:</strong></p>\n<p>Systems communicate through three primary mechanisms, each suited to different types of data sharing:</p>\n<p><strong>Shared Component Data</strong>: Systems access the same component arrays through the <code>ECSWorld</code> interface. For example, both the movement system and rendering system read <code>Transform</code> components, but only the movement system modifies them. This provides efficient data sharing without explicit message passing.</p>\n<p><strong>Event Queues</strong>: Systems post events to shared queues for loosely-coupled communication. Collision events from physics are posted to a queue that gameplay systems can consume to trigger sound effects, particle systems, or damage calculations.</p>\n<p><strong>Resource Handles</strong>: Systems request assets through the resource manager and receive handles that remain valid across frames. The rendering system requests texture handles during entity creation, then uses those handles every frame without re-requesting the resource.</p>\n<h3 id=\"recommended-module-organization\">Recommended Module Organization</h3>\n<p>Organizing engine code requires balancing several concerns: logical grouping of related functionality, minimizing compilation dependencies, supporting unit testing, and providing clear interfaces between systems. Our module organization follows <strong>domain-driven design</strong> principles, where each major subsystem lives in its own module with minimal cross-dependencies.</p>\n<p>Think of the module structure as <strong>departments in a company</strong> — each department has its own internal organization, tools, and processes, but they communicate through well-defined interfaces rather than reaching into each other&#39;s internal systems. This enables teams to work on different subsystems independently and makes the codebase easier to understand and maintain.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GameEngine/\n├── Application/\n│   ├── Application.h                 ← Main engine coordinator interface\n│   ├── Application.cpp               ← Lifecycle management, frame loop\n│   ├── Timer.h                       ← Frame timing utilities\n│   ├── Timer.cpp                     ← Delta time calculation, FPS limiting\n│   └── Config.h                      ← Engine configuration constants\n├── Window/\n│   ├── Window.h                      ← Platform-independent window interface\n│   ├── WindowSDL.cpp                 ← SDL2 implementation\n│   ├── WindowGLFW.cpp                ← GLFW implementation (alternative)\n│   └── Input.h                       ← Input state management\n├── Rendering/\n│   ├── Renderer.h                    ← Main rendering interface\n│   ├── Renderer.cpp                  ← Batch rendering implementation\n│   ├── Shader.h                      ← Shader compilation and management\n│   ├── Shader.cpp                    ← OpenGL/Vulkan shader implementation\n│   ├── Texture.h                     ← Texture resource interface\n│   ├── Texture.cpp                   ← GPU texture upload and management\n│   ├── Mesh.h                        ← 3D mesh data structures\n│   ├── Mesh.cpp                      ← Vertex/index buffer management\n│   └── RenderComponents.h            ← Transform, Sprite, MeshRenderer components\n├── ECS/\n│   ├── ECSWorld.h                    ← Main ECS coordinator interface\n│   ├── ECSWorld.cpp                  ← Entity creation, system registration\n│   ├── Entity.h                      ← Entity ID structure and generation\n│   ├── ComponentStorage.h            ← Dense array storage for components\n│   ├── ComponentStorage.cpp          ← Archetype-based component organization\n│   ├── System.h                      ← Base system interface and query API\n│   └── SystemRegistry.cpp            ← System execution pipeline\n├── Physics/\n│   ├── PhysicsWorld.h                ← Physics simulation coordinator\n│   ├── PhysicsWorld.cpp              ← Fixed timestep integration, collision response\n│   ├── Collision.h                   ← AABB, Circle collision shapes\n│   ├── CollisionDetection.cpp        ← Broad/narrow phase collision detection\n│   ├── SpatialPartitioning.h         ← Grid/quadtree for optimization\n│   ├── SpatialPartitioning.cpp       ← Spatial data structure implementation\n│   └── PhysicsComponents.h           ← Rigidbody, Collider components\n├── Resources/\n│   ├── ResourceManager.h             ← Resource loading and caching interface\n│   ├── ResourceManager.cpp           ← Handle-based access, reference counting\n│   ├── AssetLoaders.h                ← File format loading interfaces\n│   ├── TextureLoader.cpp             ← PNG/JPG image loading\n│   ├── MeshLoader.cpp                ← OBJ/glTF 3D model loading\n│   ├── AudioLoader.cpp               ← WAV/OGG audio file loading\n│   └── SceneSerializer.h             ← Scene save/load functionality\n├── Scenes/\n│   ├── Scene.h                       ← Scene data structure and interface\n│   ├── Scene.cpp                     ← Entity hierarchy management\n│   ├── SceneManager.h                ← Scene transition coordination\n│   └── SceneManager.cpp              ← Loading/unloading, resource cleanup\n├── Core/\n│   ├── Types.h                       ← Engine-wide type definitions\n│   ├── Math.h                        ← Vector2/3, Matrix, utility functions\n│   ├── Memory.h                      ← Custom allocators (optional)\n│   └── Logging.h                     ← Debug logging and error reporting\n└── Examples/\n    ├── BasicSprites/\n    │   └── main.cpp                  ← Simple 2D sprite rendering example\n    ├── PhysicsDemo/\n    │   └── main.cpp                  ← Physics simulation demonstration\n    └── SceneLoading/\n        └── main.cpp                  ← Scene serialization example</code></pre></div>\n\n<p><strong>Module Dependency Rules:</strong></p>\n<p>The dependency graph between modules follows strict layering to prevent circular dependencies and maintain clear separation of concerns.</p>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Can Depend On</th>\n<th>Cannot Depend On</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Application</code></td>\n<td>All other modules</td>\n<td>None</td>\n<td>Top-level coordinator needs access to all subsystems</td>\n</tr>\n<tr>\n<td><code>Window</code></td>\n<td><code>Core</code> only</td>\n<td><code>ECS</code>, <code>Physics</code>, <code>Resources</code></td>\n<td>Platform abstraction should be independent</td>\n</tr>\n<tr>\n<td><code>Rendering</code></td>\n<td><code>Core</code>, <code>Resources</code>, <code>ECS</code> (components only)</td>\n<td><code>Physics</code>, <code>Scenes</code></td>\n<td>Renderer consumes data but doesn&#39;t modify game logic</td>\n</tr>\n<tr>\n<td><code>ECS</code></td>\n<td><code>Core</code> only</td>\n<td>All other modules</td>\n<td>Data management layer must be independent</td>\n</tr>\n<tr>\n<td><code>Physics</code></td>\n<td><code>Core</code>, <code>ECS</code> (components only)</td>\n<td><code>Rendering</code>, <code>Resources</code>, <code>Scenes</code></td>\n<td>Physics only needs entity data, not presentation</td>\n</tr>\n<tr>\n<td><code>Resources</code></td>\n<td><code>Core</code> only</td>\n<td><code>ECS</code>, <code>Physics</code>, <code>Rendering</code></td>\n<td>Asset loading is foundational service</td>\n</tr>\n<tr>\n<td><code>Scenes</code></td>\n<td>All modules except <code>Application</code></td>\n<td><code>Application</code></td>\n<td>Scenes coordinate subsystems but don&#39;t control application</td>\n</tr>\n<tr>\n<td><code>Core</code></td>\n<td>Standard library only</td>\n<td>All engine modules</td>\n<td>Foundation types used by everything</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Layered Dependencies</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to prevent circular dependencies while allowing necessary communication between subsystems</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Allow bidirectional dependencies with careful interface design</li>\n<li>Strict layering with dependency injection for cross-cutting concerns  </li>\n<li>Event-based communication with no direct dependencies</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Strict layering with component sharing through ECS</li>\n<li><strong>Rationale</strong>: Layered dependencies make the codebase easier to understand and test. The ECS serves as a shared data layer that systems can read from without creating direct dependencies between systems.</li>\n<li><strong>Consequences</strong>: Some communication requires event queues rather than direct calls, but this improves loose coupling and testability.</li>\n</ul>\n</blockquote>\n<p><strong>Header File Organization Strategy:</strong></p>\n<p>Each module exposes its public interface through a primary header file that includes only the declarations needed by other modules. Implementation details, internal data structures, and private helper functions are kept in separate headers or implementation files.</p>\n<table>\n<thead>\n<tr>\n<th>File Type</th>\n<th>Naming Convention</th>\n<th>Contents</th>\n<th>Include Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Public Interface</td>\n<td><code>ModuleName.h</code></td>\n<td>Class declarations, public methods, public constants</td>\n<td>Included by other modules</td>\n</tr>\n<tr>\n<td>Component Definitions</td>\n<td><code>ModuleNameComponents.h</code></td>\n<td>Component data structures only</td>\n<td>Included by ECS and other systems</td>\n</tr>\n<tr>\n<td>Internal Implementation</td>\n<td><code>ModuleNameInternal.h</code></td>\n<td>Private classes, helper functions, constants</td>\n<td>Included only within same module</td>\n</tr>\n<tr>\n<td>Implementation Files</td>\n<td><code>ModuleName.cpp</code></td>\n<td>Method implementations, static functions</td>\n<td>Never included directly</td>\n</tr>\n</tbody></table>\n<p>This organization supports incremental compilation — changes to implementation files don&#39;t require recompiling dependent modules. Only changes to public interface headers trigger widespread recompilation.</p>\n<p><strong>Build System Integration:</strong></p>\n<p>The module structure maps directly to build system targets, enabling parallel compilation and selective linking for different engine configurations.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># CMakeLists.txt structure\nadd_library(GameEngine_Core STATIC Core/*.cpp)\nadd_library(GameEngine_ECS STATIC ECS/*.cpp)\nadd_library(GameEngine_Physics STATIC Physics/*.cpp)\nadd_library(GameEngine_Rendering STATIC Rendering/*.cpp)\nadd_library(GameEngine_Resources STATIC Resources/*.cpp)\nadd_library(GameEngine_Window STATIC Window/*.cpp)\n\n# Link dependencies based on module hierarchy\ntarget_link_libraries(GameEngine_ECS GameEngine_Core)\ntarget_link_libraries(GameEngine_Physics GameEngine_Core GameEngine_ECS)\ntarget_link_libraries(GameEngine_Rendering GameEngine_Core GameEngine_ECS GameEngine_Resources)\n\n# Main engine library combines all modules\nadd_library(GameEngine STATIC Application/*.cpp)\ntarget_link_libraries(GameEngine \n    GameEngine_Core GameEngine_ECS GameEngine_Physics \n    GameEngine_Rendering GameEngine_Resources GameEngine_Window)</code></pre></div>\n\n<p>This build structure enables several advanced scenarios: building physics-only simulations without rendering dependencies, creating headless servers without window management, and developing engine subsystems independently with focused unit tests.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Window Management</td>\n<td>SDL2 (cross-platform, simple API)</td>\n<td>GLFW (lightweight, more OpenGL-focused)</td>\n</tr>\n<tr>\n<td>Graphics API</td>\n<td>OpenGL 3.3+ (widely supported, extensive tutorials)</td>\n<td>Vulkan (modern, explicit control, better performance)</td>\n</tr>\n<tr>\n<td>Mathematics</td>\n<td>Custom Vector2/Vector3 structs</td>\n<td>GLM library (comprehensive, optimized)</td>\n</tr>\n<tr>\n<td>Image Loading</td>\n<td>stb_image single-header library</td>\n<td>SOIL2 or DevIL (more formats, advanced features)</td>\n</tr>\n<tr>\n<td>Audio System</td>\n<td>SDL2_mixer (simple, integrated with SDL)</td>\n<td>OpenAL (3D audio, more control)</td>\n</tr>\n<tr>\n<td>Build System</td>\n<td>CMake (cross-platform, widely adopted)</td>\n<td>Premake (simpler syntax, Lua-based)</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Simple assert macros for basic testing</td>\n<td>Catch2 (comprehensive, modern C++ features)</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Project Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GameEngine/\n├── CMakeLists.txt                    ← Main build configuration\n├── README.md                         ← Project setup instructions\n├── .gitignore                        ← Ignore build artifacts, IDE files\n├── assets/                           ← Example textures, models, scenes\n│   ├── textures/\n│   ├── models/  \n│   └── scenes/\n├── external/                         ← Third-party dependencies\n│   ├── SDL2/                         ← SDL2 headers and libraries\n│   ├── stb/                          ← stb_image.h and related headers\n│   └── glm/                          ← GLM mathematics library\n├── src/                              ← Engine source code (see module structure above)\n│   ├── Core/\n│   ├── Application/\n│   ├── Window/\n│   ├── Rendering/\n│   ├── ECS/\n│   ├── Physics/\n│   ├── Resources/\n│   └── Scenes/\n├── examples/                         ← Example applications using the engine\n│   ├── BasicSprites/\n│   ├── PhysicsDemo/\n│   └── SceneLoading/\n├── tests/                            ← Unit tests for each module\n│   ├── Core/\n│   ├── ECS/\n│   ├── Physics/\n│   └── Resources/\n└── build/                            ← Generated build files (git-ignored)\n    ├── Debug/\n    └── Release/</code></pre></div>\n\n<p><strong>Core Infrastructure Starter Code:</strong></p>\n<p><strong>File: <code>src/Core/Types.h</code></strong> (Complete infrastructure - copy and use)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Engine-wide type definitions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#E1E4E8\"> Entity NULL_ENTITY </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> MAX_ENTITIES </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Frame timing constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> TARGET_FPS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> TARGET_FRAME_TIME </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> /</span><span style=\"color:#E1E4E8\"> TARGET_FPS;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Handle types for resource management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> TextureHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> MeshHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> AudioHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> SceneHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declarations for major subsystems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Application</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Window</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Renderer</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ECSWorld</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PhysicsWorld</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ResourceManager</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SceneManager</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configuration structures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> WindowConfig</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> width </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1280</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> height </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 720</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> title </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Game Engine\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> fullscreen </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> vsync </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common result types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> InitResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Success</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WindowCreationFailed</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GraphicsContextFailed</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AssetLoadingFailed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>File: <code>src/Core/Math.h</code></strong> (Complete infrastructure - copy and use)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cmath></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> x</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> y</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">x</span><span style=\"color:#E1E4E8\">(x), </span><span style=\"color:#B392F0\">y</span><span style=\"color:#E1E4E8\">(y) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">+</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.x, y </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.y}; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">-</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {x </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.x, y </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.y}; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">*</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> scalar</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {x </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> scalar, y </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> scalar}; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> Length</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sqrt</span><span style=\"color:#E1E4E8\">(x </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> y); }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#B392F0\"> Normalized</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Length</span><span style=\"color:#E1E4E8\">(); </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> len </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#E1E4E8\"> Vector2{x</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">len, y</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">len} </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> Vector2{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Vector3</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">; </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> z </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector3</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector3</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> x</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> y</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> z</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">x</span><span style=\"color:#E1E4E8\">(x), </span><span style=\"color:#B392F0\">y</span><span style=\"color:#E1E4E8\">(y), </span><span style=\"color:#B392F0\">z</span><span style=\"color:#E1E4E8\">(z) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector3</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">+</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector3</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.x, y </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.y, z </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.z}; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector3</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">-</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector3</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {x </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.x, y </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.y, z </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.z}; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector3</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">*</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> scalar</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {x </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> scalar, y </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> scalar, z </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> scalar}; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> Length</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sqrt</span><span style=\"color:#E1E4E8\">(x </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> z </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> z); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector2 min;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector2 max;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AABB</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AABB</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Vector2</span><span style=\"color:#FFAB70\"> min</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Vector2</span><span style=\"color:#FFAB70\"> max</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(min), </span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">(max) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Intersects</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> min.x </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> other.max.x </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> max.x </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> other.min.x </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               min.y </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> other.max.y </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> max.y </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> other.min.y;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#B392F0\"> Center</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {(min.x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> max.x) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, (min.y </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> max.y) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">}; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#B392F0\"> Size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {max.x </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> min.x, max.y </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> min.y}; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector2 center;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> radius </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Circle</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Circle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Vector2</span><span style=\"color:#FFAB70\"> center</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> radius</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">center</span><span style=\"color:#E1E4E8\">(center), </span><span style=\"color:#B392F0\">radius</span><span style=\"color:#E1E4E8\">(radius) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Intersects</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Vector2 diff </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> center </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.center;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> distance_squared </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> diff.x </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> diff.x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> diff.y </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> diff.y;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> combined_radius </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> radius </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.radius;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> distance_squared </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> combined_radius </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> combined_radius;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Application Framework Skeleton</strong> (Core logic for learner to implement):</p>\n<p><strong>File: <code>src/Application/Application.h</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../Core/Types.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"Timer.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Application</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Window</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_window;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Renderer</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_renderer;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ECSWorld</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_ecs_world;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">PhysicsWorld</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_physics_world;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ResourceManager</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_resource_manager;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">SceneManager</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_scene_manager;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FrameTimer m_frame_timer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> m_should_close </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize all engine subsystems and create window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns InitResult indicating success or specific failure type</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    InitResult</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> WindowConfig</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main game loop - processes frames until ShouldClose() returns true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns exit code (0 for success, non-zero for error)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> Run</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clean shutdown of all subsystems and resource cleanup  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if application should terminate (window closed, quit requested)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> ShouldClose</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_should_close; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get time elapsed since last frame for time-based calculations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetDeltaTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_frame_timer.</span><span style=\"color:#B392F0\">GetDeltaTime</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process single frame - called by Run() in main loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ProcessFrame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize Window subsystem with SDL2/GLFW</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create OpenGL/Vulkan graphics context through Window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize Renderer with graphics context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create ECSWorld for entity management  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize PhysicsWorld with default gravity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create ResourceManager for asset loading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize SceneManager for level management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check each initialization for failure and return appropriate InitResult</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update FrameTimer to calculate new delta_time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Call Window::PollEvents() to process input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Call ECSWorld::UpdateSystems(delta_time) for game logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Call PhysicsWorld::StepSimulation(delta_time) for physics  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Call Renderer::RenderFrame() to draw everything</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Call Window::SwapBuffers() to present frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Enforce frame rate limiting with FrameTimer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Each step depends on previous steps completing successfully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<ul>\n<li><strong>Memory Management</strong>: Use <code>std::unique_ptr</code> for subsystem ownership in the <code>Application</code> class. This provides automatic cleanup and clear ownership semantics.</li>\n<li><strong>Error Handling</strong>: Return enum values like <code>InitResult</code> rather than throwing exceptions, since game engines need predictable performance.</li>\n<li><strong>Frame Timing</strong>: Use <code>std::chrono::high_resolution_clock</code> for precise timing measurements in the <code>FrameTimer</code> class.</li>\n<li><strong>Platform Abstraction</strong>: Use preprocessor macros to select between SDL2 and GLFW implementations at compile time.</li>\n<li><strong>OpenGL Context</strong>: Call <code>glewInit()</code> after creating the OpenGL context but before using any OpenGL functions.</li>\n<li><strong>Resource Loading</strong>: Use <code>stb_image.h</code> for texture loading - it&#39;s a single header that handles PNG, JPG, and other common formats.</li>\n</ul>\n<p><strong>Milestone Checkpoints:</strong></p>\n<p>After implementing the high-level architecture:</p>\n<p><strong>Checkpoint 1 - Application Initialization:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> GameEngine_Application</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./examples/BasicSprites/BasicSprites</span></span></code></pre></div>\n<p>Expected: Window opens with specified resolution and title, clears to solid color, responds to close button.\nIf it fails: Check window creation error messages, verify SDL2 is properly linked, ensure OpenGL context initialization.</p>\n<p><strong>Checkpoint 2 - Subsystem Communication:</strong>\nCreate a simple example that creates entities, adds components, and runs one update system.\nExpected: No crashes, entity IDs are generated correctly, components can be added and retrieved.\nIf it fails: Check ECS initialization order, verify component storage allocation, ensure system registration works.</p>\n<p><strong>Checkpoint 3 - Frame Loop Stability:</strong>\nRun the application for 30+ seconds and monitor frame rate consistency.\nExpected: Stable frame rate near target FPS, consistent delta time values, no memory leaks.\nIf it fails: Profile frame time breakdown, check for memory allocations in hot paths, verify frame timing logic.</p>\n<h2 id=\"engine-data-model\">Engine Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — core data structures are established in Milestone 1 and extended throughout the project</p>\n</blockquote>\n<p>The data model of a game engine is like the <strong>blueprint of a city&#39;s infrastructure</strong> — it defines the fundamental types, relationships, and organization patterns that every other system depends upon. Just as a city planner must carefully design how residential, commercial, and industrial zones connect through roads, utilities, and services, a game engine architect must define how entities, components, resources, and systems relate to each other in memory. The data model determines not just what information is stored, but how efficiently it can be accessed, modified, and processed during the intense computational demands of real-time game simulation.</p>\n<p>Unlike traditional business applications where data access patterns are relatively predictable, game engines must process thousands of entities every frame within a strict time budget. This creates unique constraints: data must be organized for maximum cache efficiency, memory allocations must be minimized during gameplay, and relationships between game objects must be traversable in microseconds rather than milliseconds. The data model becomes the foundation that either enables or prevents the engine from meeting its performance targets.</p>\n<p>The core challenge lies in balancing three competing forces: <strong>flexibility</strong> (supporting diverse game object types), <strong>performance</strong> (enabling cache-friendly iteration), and <strong>maintainability</strong> (keeping systems decoupled and testable). Traditional object-oriented approaches prioritize flexibility through inheritance hierarchies, but these create cache-unfriendly memory layouts and tight coupling between systems. Modern game engines increasingly adopt data-oriented design principles that organize data by access patterns rather than conceptual relationships.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fecs-data-model.svg\" alt=\"ECS Data Model and Relationships\"></p>\n<h3 id=\"entity-and-component-types\">Entity and Component Types</h3>\n<p>Think of the entity-component system as a <strong>specialized database for game objects</strong>. Traditional relational databases organize data into tables with fixed schemas, but game entities are more dynamic — one entity might need position and rendering components while another needs position, physics, and audio components. The ECS data model solves this by treating entities as unique identifiers (like primary keys) and components as typed data records that can be attached to any entity. Systems then act like database queries, efficiently iterating over all entities that possess specific combinations of component types.</p>\n<p>The entity identifier design is crucial for both performance and correctness. A naive approach might use simple incrementing integers, but this creates problems when entities are destroyed and their IDs are recycled — dangling references to destroyed entities might accidentally refer to newly created entities. Our design uses a <strong>generation-based approach</strong> that embeds a version counter directly into the entity ID, ensuring that stale references become detectably invalid.</p>\n<p><strong>Entity ID Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Bits</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Index</td>\n<td><code>uint32_t</code></td>\n<td>22 bits</td>\n<td>Array index where entity data is stored</td>\n</tr>\n<tr>\n<td>Generation</td>\n<td><code>uint32_t</code></td>\n<td>10 bits</td>\n<td>Version counter incremented when ID is recycled</td>\n</tr>\n</tbody></table>\n<p>The entity index points to a slot in the entity metadata array, while the generation counter tracks how many times that slot has been reused. When an entity is destroyed, its generation counter is incremented, making any existing <code>Entity</code> handles to that slot immediately invalid. This approach supports up to 4,194,304 concurrent entities (2^22) with 1,024 generations per slot (2^10), which is sufficient for most game scenarios while fitting comfortably in a 32-bit integer.</p>\n<blockquote>\n<p><strong>Decision: Generation-Based Entity IDs</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to detect when entity references become invalid after entity destruction and ID recycling</li>\n<li><strong>Options Considered</strong>: Simple incrementing IDs, UUID-based IDs, generation-embedded IDs</li>\n<li><strong>Decision</strong>: Embed 10-bit generation counter in 32-bit entity ID alongside 22-bit index</li>\n<li><strong>Rationale</strong>: Provides automatic stale reference detection with minimal memory overhead and cache-friendly 32-bit size</li>\n<li><strong>Consequences</strong>: Enables safe entity references across frame boundaries, limits to ~4M concurrent entities, requires bit manipulation for ID packing/unpacking</li>\n</ul>\n</blockquote>\n<p>Component storage represents the heart of the ECS performance model. Instead of storing components as fields within entity objects (array-of-structs), we organize them into homogeneous arrays where each component type has its own dense storage (struct-of-arrays). This enables systems to iterate over thousands of components with optimal cache utilization, as each memory access brings multiple components of the same type into the cache line.</p>\n<p><strong>Core Component Types:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Fields</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Transform</code></td>\n<td><code>position: Vector3</code>, <code>rotation: Vector3</code>, <code>scale: Vector3</code></td>\n<td>Spatial positioning in world coordinates</td>\n</tr>\n<tr>\n<td><code>Sprite</code></td>\n<td><code>texture: TextureHandle</code>, <code>size: Vector2</code>, <code>color: Vector4</code></td>\n<td>2D rendering with texture and tinting</td>\n</tr>\n<tr>\n<td><code>RigidBody</code></td>\n<td><code>velocity: Vector3</code>, <code>acceleration: Vector3</code>, <code>mass: float</code></td>\n<td>Physics motion and dynamics</td>\n</tr>\n<tr>\n<td><code>Collider</code></td>\n<td><code>shape: ColliderShape</code>, <code>bounds: AABB</code>, <code>is_trigger: bool</code></td>\n<td>Collision detection geometry</td>\n</tr>\n<tr>\n<td><code>Audio</code></td>\n<td><code>clip: AudioHandle</code>, <code>volume: float</code>, <code>is_playing: bool</code></td>\n<td>Sound playback control</td>\n</tr>\n</tbody></table>\n<p>The component storage system uses <strong>dense arrays with indirection</strong> to maintain cache-friendly iteration while supporting dynamic component addition and removal. Each component type maintains its own storage manager that tracks which entities possess that component and provides efficient iteration over all instances.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fcomponent-storage.svg\" alt=\"ECS Component Storage Organization\"></p>\n<p><strong>Component Storage Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Layer</th>\n<th>Data Structure</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Arrays</td>\n<td><code>std::vector&lt;ComponentType&gt;</code></td>\n<td>Dense storage of component instances</td>\n</tr>\n<tr>\n<td>Entity-to-Index Map</td>\n<td><code>std::unordered_map&lt;Entity, size_t&gt;</code></td>\n<td>Maps entity ID to component array index</td>\n</tr>\n<tr>\n<td>Index-to-Entity Map</td>\n<td><code>std::vector&lt;Entity&gt;</code></td>\n<td>Maps component array index back to entity ID</td>\n</tr>\n<tr>\n<td>Free List</td>\n<td><code>std::vector&lt;size_t&gt;</code></td>\n<td>Tracks available slots from removed components</td>\n</tr>\n</tbody></table>\n<p>When a component is added to an entity, it&#39;s appended to the component array and the maps are updated to establish the bidirectional relationship. When a component is removed, the last element in the array is moved to fill the gap (maintaining density), and the removed slot is added to the free list for future reuse. This approach ensures that systems always iterate over a contiguous memory region regardless of component removal patterns.</p>\n<blockquote>\n<p>The critical insight for ECS performance is that <strong>data locality trumps algorithmic complexity</strong> in real-time systems. A simple linear search over a dense array of 10,000 components will outperform a complex data structure with perfect theoretical complexity if that structure causes cache misses.</p>\n</blockquote>\n<p><strong>System Query Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Query&lt;T&gt;()</code></td>\n<td>Component type</td>\n<td><code>ComponentIterator&lt;T&gt;</code></td>\n<td>Iterate over entities with single component</td>\n</tr>\n<tr>\n<td><code>Query&lt;T1, T2&gt;()</code></td>\n<td>Multiple types</td>\n<td><code>MultiComponentIterator&lt;T1, T2&gt;</code></td>\n<td>Iterate over entities with all specified components</td>\n</tr>\n<tr>\n<td><code>QueryEntity&lt;T&gt;(entity)</code></td>\n<td>Entity ID, type</td>\n<td><code>T*</code></td>\n<td>Get component for specific entity or nullptr</td>\n</tr>\n<tr>\n<td><code>QueryOptional&lt;T&gt;()</code></td>\n<td>Component type</td>\n<td><code>OptionalIterator&lt;T&gt;</code></td>\n<td>Iterate including entities without component</td>\n</tr>\n</tbody></table>\n<p>The query system provides type-safe iteration over entities that possess specific component combinations. The implementation uses template metaprogramming to generate efficient iteration code at compile time, eliminating the runtime overhead of dynamic type checking or virtual function calls.</p>\n<h3 id=\"resource-and-asset-types\">Resource and Asset Types</h3>\n<p>Resource management in a game engine is like a <strong>library checkout system</strong> — assets are expensive to load and store, so they must be shared efficiently between multiple users while tracking who is using what and when resources can be safely freed. Unlike traditional applications where file loading is typically synchronous and memory usage is less constrained, game engines must load large assets without blocking frame processing and carefully manage GPU memory limits.</p>\n<p>The resource system uses <strong>handle-based access</strong> rather than direct pointers to provide memory safety and enable advanced features like hot reloading and reference counting. A handle contains enough information to locate the resource while remaining valid even if the resource is moved in memory or temporarily unloaded.</p>\n<p><strong>Resource Handle Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td><code>uint32_t</code></td>\n<td>Unique identifier for this resource</td>\n</tr>\n<tr>\n<td>Type</td>\n<td><code>ResourceType</code></td>\n<td>Enum indicating resource type (texture, mesh, audio, etc.)</td>\n</tr>\n<tr>\n<td>Version</td>\n<td><code>uint16_t</code></td>\n<td>Version counter for detecting stale handles</td>\n</tr>\n<tr>\n<td>Generation</td>\n<td><code>uint16_t</code></td>\n<td>Recycling counter similar to entity IDs</td>\n</tr>\n</tbody></table>\n<p>The handle design enables the resource manager to detect when client code attempts to access resources that have been unloaded, moved, or are still loading asynchronously. Unlike raw pointers, handles remain safe to store and pass between systems without creating dangling references.</p>\n<blockquote>\n<p><strong>Decision: Handle-Based Resource Access</strong></p>\n<ul>\n<li><strong>Context</strong>: Need safe resource references that survive memory reorganization and support async loading</li>\n<li><strong>Options Considered</strong>: Direct pointers, smart pointers, handle-based indirection</li>\n<li><strong>Decision</strong>: Use 64-bit handles with embedded type and version information</li>\n<li><strong>Rationale</strong>: Provides memory safety, enables hot reloading, supports reference counting, prevents use-after-free bugs</li>\n<li><strong>Consequences</strong>: Requires indirection lookup for resource access, enables advanced resource management features, complicates debugging</li>\n</ul>\n</blockquote>\n<p><strong>Core Asset Types:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Asset Type</th>\n<th>Data Structure</th>\n<th>GPU Resources</th>\n<th>Loading Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Texture</code></td>\n<td><code>TextureData</code> with width, height, format, pixels</td>\n<td>OpenGL texture object</td>\n<td>Asynchronous with fallback</td>\n</tr>\n<tr>\n<td><code>Mesh</code></td>\n<td><code>MeshData</code> with vertices, indices, materials</td>\n<td>Vertex/index buffer objects</td>\n<td>Streaming for large meshes</td>\n</tr>\n<tr>\n<td><code>Audio</code></td>\n<td><code>AudioClip</code> with sample rate, channels, samples</td>\n<td>Audio buffer (OpenAL/FMOD)</td>\n<td>Background loading</td>\n</tr>\n<tr>\n<td><code>Scene</code></td>\n<td><code>SceneData</code> with entity definitions</td>\n<td>None (CPU data only)</td>\n<td>Synchronous on demand</td>\n</tr>\n</tbody></table>\n<p>Each asset type has different loading characteristics and memory requirements. Textures are typically loaded from compressed formats (PNG, JPG) and uploaded to GPU memory as uncompressed pixel arrays. Meshes contain geometric data that must be uploaded to vertex buffer objects for efficient GPU rendering. Audio clips are decompressed and stored in audio system buffers, while scene data remains as CPU-accessible structures for entity instantiation.</p>\n<p><strong>Texture Asset Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>width</code></td>\n<td><code>uint32_t</code></td>\n<td>Texture width in pixels</td>\n</tr>\n<tr>\n<td><code>height</code></td>\n<td><code>uint32_t</code></td>\n<td>Texture height in pixels</td>\n</tr>\n<tr>\n<td><code>format</code></td>\n<td><code>PixelFormat</code></td>\n<td>Color format (RGBA8, RGB8, etc.)</td>\n</tr>\n<tr>\n<td><code>mip_levels</code></td>\n<td><code>uint8_t</code></td>\n<td>Number of mipmap levels for filtering</td>\n</tr>\n<tr>\n<td><code>gl_texture_id</code></td>\n<td><code>GLuint</code></td>\n<td>OpenGL texture object identifier</td>\n</tr>\n<tr>\n<td><code>data</code></td>\n<td><code>std::vector&lt;uint8_t&gt;</code></td>\n<td>Raw pixel data (CPU copy)</td>\n</tr>\n</tbody></table>\n<p><strong>Mesh Asset Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>vertices</code></td>\n<td><code>std::vector&lt;Vertex&gt;</code></td>\n<td>Vertex position, normal, texture coordinates</td>\n</tr>\n<tr>\n<td><code>indices</code></td>\n<td><code>std::vector&lt;uint32_t&gt;</code></td>\n<td>Triangle connectivity information</td>\n</tr>\n<tr>\n<td><code>material</code></td>\n<td><code>MaterialHandle</code></td>\n<td>Reference to associated material properties</td>\n</tr>\n<tr>\n<td><code>bounding_box</code></td>\n<td><code>AABB</code></td>\n<td>Axis-aligned bounds for culling</td>\n</tr>\n<tr>\n<td><code>vao</code></td>\n<td><code>GLuint</code></td>\n<td>OpenGL vertex array object</td>\n</tr>\n<tr>\n<td><code>vbo</code></td>\n<td><code>GLuint</code></td>\n<td>OpenGL vertex buffer object</td>\n</tr>\n<tr>\n<td><code>ebo</code></td>\n<td><code>GLuint</code></td>\n<td>OpenGL element buffer object</td>\n</tr>\n</tbody></table>\n<p>The resource loading pipeline supports both synchronous and asynchronous loading strategies depending on asset type and usage context. Critical resources like default textures and fallback assets are loaded synchronously during engine initialization. Optional assets like high-resolution textures or large meshes are loaded asynchronously in background threads to avoid blocking frame processing.</p>\n<p><strong>Resource Loading State Machine:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Unloaded</code></td>\n<td><code>RequestLoad</code></td>\n<td><code>Loading</code></td>\n<td>Start async load task</td>\n</tr>\n<tr>\n<td><code>Loading</code></td>\n<td><code>LoadComplete</code></td>\n<td><code>Loaded</code></td>\n<td>Update handle mapping, notify waiters</td>\n</tr>\n<tr>\n<td><code>Loading</code></td>\n<td><code>LoadFailed</code></td>\n<td><code>Error</code></td>\n<td>Log error, use fallback resource</td>\n</tr>\n<tr>\n<td><code>Loaded</code></td>\n<td><code>RequestUnload</code></td>\n<td><code>Unloaded</code></td>\n<td>Free GPU resources, clear CPU data</td>\n</tr>\n<tr>\n<td><code>Error</code></td>\n<td><code>RequestReload</code></td>\n<td><code>Loading</code></td>\n<td>Retry loading with exponential backoff</td>\n</tr>\n</tbody></table>\n<p><strong>Resource Cache Management:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Data Structure</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Handle Registry</td>\n<td><code>std::unordered_map&lt;uint64_t, ResourceEntry&gt;</code></td>\n<td>Maps handles to resource metadata</td>\n</tr>\n<tr>\n<td>Type Registries</td>\n<td><code>std::unordered_map&lt;std::string, TextureHandle&gt;</code></td>\n<td>Maps file paths to handles by type</td>\n</tr>\n<tr>\n<td>Reference Counters</td>\n<td><code>std::atomic&lt;uint32_t&gt;</code> per resource</td>\n<td>Tracks active references for cleanup</td>\n</tr>\n<tr>\n<td>Loading Queue</td>\n<td><code>std::queue&lt;LoadRequest&gt;</code></td>\n<td>Pending asynchronous load operations</td>\n</tr>\n</tbody></table>\n<p>The cache ensures that multiple requests for the same asset return the same handle, preventing duplicate loading and memory waste. Reference counting automatically unloads resources when they are no longer needed, while the loading queue manages asynchronous operations without blocking the main thread.</p>\n<h3 id=\"memory-layout-considerations\">Memory Layout Considerations</h3>\n<p>Memory organization in game engines is like designing a <strong>factory assembly line</strong> — the layout of materials and workstations determines how efficiently workers can complete their tasks. In CPU terms, the &quot;workers&quot; are processing cores, &quot;materials&quot; are data in memory, and &quot;workstations&quot; are cache levels. Poor memory layout forces the CPU to constantly wait for data to arrive from slow main memory, while optimal layout keeps frequently accessed data in fast cache memory where it can be processed immediately.</p>\n<p>The fundamental choice in memory layout is between <strong>Array-of-Structs (AoS)</strong> and <strong>Struct-of-Arrays (SoA)</strong> organization. Traditional object-oriented programming favors AoS where each entity is a complete object containing all its data. However, game engines benefit from SoA where each component type is stored in a separate homogeneous array.</p>\n<p><strong>Array-of-Structs vs Struct-of-Arrays Comparison:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Array-of-Structs</th>\n<th>Struct-of-Arrays</th>\n<th>Chosen for Engine</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache Utilization</td>\n<td>Poor (loads unused fields)</td>\n<td>Excellent (only relevant data)</td>\n<td>SoA</td>\n</tr>\n<tr>\n<td>System Iteration</td>\n<td>50-80% cache misses</td>\n<td>95%+ cache hits</td>\n<td>SoA</td>\n</tr>\n<tr>\n<td>Entity Operations</td>\n<td>Fast (all data together)</td>\n<td>Slower (multiple array accesses)</td>\n<td>SoA</td>\n</tr>\n<tr>\n<td>Memory Overhead</td>\n<td>Higher (padding/alignment)</td>\n<td>Lower (no per-entity overhead)</td>\n<td>SoA</td>\n</tr>\n<tr>\n<td>Code Complexity</td>\n<td>Simple (object.field)</td>\n<td>Moderate (component_arrays[type][index])</td>\n<td>SoA</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Struct-of-Arrays Component Storage</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to efficiently iterate over thousands of entities per frame with strict time budgets</li>\n<li><strong>Options Considered</strong>: Array-of-Structs (traditional OOP), Struct-of-Arrays (data-oriented), hybrid approaches</li>\n<li><strong>Decision</strong>: Use pure Struct-of-Arrays with dense component storage</li>\n<li><strong>Rationale</strong>: Systems typically process one component type at a time; SoA provides 3-5x better cache performance for system iteration</li>\n<li><strong>Consequences</strong>: Enables high-performance system updates, complicates entity-centric operations, requires indirection for component access</li>\n</ul>\n</blockquote>\n<p><strong>Cache-Friendly Data Organization Principles:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Principle</th>\n<th>Description</th>\n<th>Engine Application</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Spatial Locality</td>\n<td>Related data stored contiguously</td>\n<td>Components of same type in arrays</td>\n</tr>\n<tr>\n<td>Temporal Locality</td>\n<td>Recently accessed data stays cached</td>\n<td>Hot components updated every frame</td>\n</tr>\n<tr>\n<td>Prefetch-Friendly</td>\n<td>Linear access patterns load next cache lines</td>\n<td>System iteration over dense arrays</td>\n</tr>\n<tr>\n<td>Alignment</td>\n<td>Data aligned to cache line boundaries</td>\n<td>Component arrays aligned to 64-byte boundaries</td>\n</tr>\n<tr>\n<td>False Sharing Avoidance</td>\n<td>Avoid concurrent writes to same cache line</td>\n<td>Separate read/write component arrays</td>\n</tr>\n</tbody></table>\n<p>The engine organizes component data to maximize spatial locality during system processing. When a physics system iterates over <code>Transform</code> and <code>RigidBody</code> components, it accesses a contiguous array of position data followed by a contiguous array of velocity data. This pattern ensures that each memory access brings relevant data into the cache, minimizing expensive main memory fetches.</p>\n<p><strong>Memory Pool Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Pool Type</th>\n<th>Allocation Strategy</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Pools</td>\n<td>Fixed-size chunks, power-of-2 growth</td>\n<td>Component arrays that resize during gameplay</td>\n</tr>\n<tr>\n<td>Temporary Pools</td>\n<td>Linear allocation, frame-based reset</td>\n<td>Short-lived allocations during frame processing</td>\n</tr>\n<tr>\n<td>Resource Pools</td>\n<td>Large block allocation</td>\n<td>Texture and mesh data with unpredictable sizes</td>\n</tr>\n<tr>\n<td>String Pools</td>\n<td>Interned string storage</td>\n<td>Asset paths and debug names</td>\n</tr>\n</tbody></table>\n<p>Memory pools reduce allocation overhead and fragmentation by pre-allocating large blocks and suballocating from them using fast, specialized algorithms. Component pools use exponential growth to minimize reallocations, while temporary pools are completely reset each frame to eliminate fragmentation.</p>\n<p><strong>Component Data Layout in Memory:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Cache Line 0:  [Transform 0] [Transform 1] [Transform 2] [Transform 3] ...\nCache Line 1:  [Transform 4] [Transform 5] [Transform 6] [Transform 7] ...\n...\nCache Line N:  [RigidBody 0] [RigidBody 1] [RigidBody 2] [RigidBody 3] ...</code></pre></div>\n\n<p>This organization ensures that when a system processes <code>Transform</code> components, each cache line load brings multiple consecutive transforms into fast memory. The CPU&#39;s hardware prefetcher recognizes the linear access pattern and automatically loads upcoming cache lines, further reducing memory latency.</p>\n<p><strong>Entity Archetype Optimization:</strong></p>\n<p>Beyond basic component storage, advanced ECS implementations use <strong>archetype</strong> organization where entities with identical component signatures are grouped together. This enables even more efficient system iteration by processing homogeneous groups of entities without checking component presence.</p>\n<table>\n<thead>\n<tr>\n<th>Archetype Example</th>\n<th>Components</th>\n<th>System Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Static Sprites</td>\n<td><code>Transform</code>, <code>Sprite</code></td>\n<td>Rendering system processes without physics checks</td>\n</tr>\n<tr>\n<td>Dynamic Objects</td>\n<td><code>Transform</code>, <code>Sprite</code>, <code>RigidBody</code></td>\n<td>Physics system updates position and rendering follows</td>\n</tr>\n<tr>\n<td>Trigger Zones</td>\n<td><code>Transform</code>, <code>Collider</code> (trigger)</td>\n<td>Collision system handles without physics response</td>\n</tr>\n<tr>\n<td>Audio Sources</td>\n<td><code>Transform</code>, <code>Audio</code></td>\n<td>Audio system updates 3D positioning efficiently</td>\n</tr>\n</tbody></table>\n<p>Archetype organization allows systems to iterate over exactly the entities they care about without wasting cycles on component presence checks or irrelevant data. The trade-off is increased complexity when entities change their component composition, as they must be moved between archetypes.</p>\n<blockquote>\n<p>The key insight for memory layout optimization is that <strong>predictable access patterns enable hardware acceleration</strong>. Modern CPUs have sophisticated prefetching mechanisms that can hide memory latency, but only if the software accesses memory in patterns the hardware can recognize and predict.</p>\n</blockquote>\n<p><strong>Common Pitfalls in Memory Organization:</strong></p>\n<p>⚠️ <strong>Pitfall: Mixed Data Types in Component Arrays</strong>\nStoring different component types in the same array destroys cache locality. Each system iteration loads irrelevant data, causing cache pollution and reduced performance. Always maintain separate homogeneous arrays for each component type.</p>\n<p>⚠️ <strong>Pitfall: Frequent Component Reallocation</strong>\nGrowing component arrays one element at a time causes excessive memory allocations and potential data copying. Use exponential growth strategies (double capacity when full) to amortize reallocation costs over many insertions.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Data Alignment</strong>\nMisaligned data structures force the CPU to perform multiple memory accesses for single values. Ensure component structures are aligned to their natural boundaries (8-byte alignment for doubles, 16-byte alignment for SIMD vectors).</p>\n<p>⚠️ <strong>Pitfall: Pointer Chasing in Hot Paths</strong>\nFollowing pointers during system iteration creates unpredictable memory access patterns that defeat CPU prefetching. Store data values directly in component arrays rather than pointers to data elsewhere.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The data model implementation requires careful attention to memory management, type safety, and performance characteristics. Modern C++ provides excellent tools for implementing cache-friendly data structures while maintaining memory safety through RAII and smart pointers.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Storage</td>\n<td><code>std::vector</code> with manual indexing</td>\n<td>Custom memory pools with SIMD alignment</td>\n</tr>\n<tr>\n<td>Entity IDs</td>\n<td>Packed <code>uint32_t</code> with bit manipulation</td>\n<td>Templated handle system with type safety</td>\n</tr>\n<tr>\n<td>Resource Loading</td>\n<td>Synchronous <code>std::ifstream</code></td>\n<td>Asynchronous thread pool with futures</td>\n</tr>\n<tr>\n<td>Memory Allocation</td>\n<td>Standard allocators</td>\n<td>Custom allocators with pool management</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">engine</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── core</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── Entity.h</span><span style=\"color:#6A737D\">              // Entity ID definition and utilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── Component.h</span><span style=\"color:#6A737D\">           // Base component types and macros</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── Handle.h</span><span style=\"color:#6A737D\">              // Resource handle template system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ComponentArray.h</span><span style=\"color:#6A737D\">      // Template for type-safe component storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ComponentManager.h</span><span style=\"color:#6A737D\">    // Manages all component arrays</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── SystemManager.h</span><span style=\"color:#6A737D\">       // System registration and execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── resources</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ResourceTypes.h</span><span style=\"color:#6A737D\">       // Texture, Mesh, Audio data structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ResourceManager.h</span><span style=\"color:#6A737D\">     // Handle-based resource loading</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── AssetLoader.h</span><span style=\"color:#6A737D\">         // File format specific loading</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── memory</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── MemoryPool.h</span><span style=\"color:#6A737D\">          // Custom allocator implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    └── Alignment.h</span><span style=\"color:#6A737D\">           // SIMD alignment utilities</span></span></code></pre></div>\n\n<p><strong>Core Entity System Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Entity.h - Complete entity ID system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;limits></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> INDEX_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 22</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> GENERATION_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> INDEX_MASK </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> INDEX_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> GENERATION_MASK </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> GENERATION_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#E1E4E8\"> Entity NULL_ENTITY{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> MAX_ENTITIES </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> INDEX_BITS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">m_id</span><span style=\"color:#E1E4E8\">(id) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> generation</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">m_id</span><span style=\"color:#E1E4E8\">((generation </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> INDEX_BITS) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> index) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetIndex</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> INDEX_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetGeneration</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (m_id </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> INDEX_BITS) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> GENERATION_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.m_id; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.m_id; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Hash function for std::unordered_map usage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">hash</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">()</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::hash</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\">{}(entity.</span><span style=\"color:#B392F0\">GetID</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Component Array Template (Infrastructure Code):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ComponentArray.h - Complete generic component storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"Entity.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cassert></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentArray</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_components;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity, </span><span style=\"color:#F97583\">size_t></span><span style=\"color:#E1E4E8\"> m_entityToIndex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_indexToEntity;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> m_freeIndices;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add component to entity with perfect forwarding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> AddComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(m_entityToIndex.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(entity) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> m_entityToIndex.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               \"Entity already has this component\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> index;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">m_freeIndices.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_freeIndices.</span><span style=\"color:#B392F0\">back</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_freeIndices.</span><span style=\"color:#B392F0\">pop_back</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_components[index] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_indexToEntity[index] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_components.</span><span style=\"color:#B392F0\">emplace_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_indexToEntity.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_entityToIndex[entity] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> index;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> m_components[index];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_entityToIndex.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> m_entityToIndex.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#9ECBFF\"> \"Entity doesn't have this component\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> removedIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> it->second;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> lastIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (removedIndex </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> lastIndex) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Move last element to fill gap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_components[removedIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(m_components[lastIndex]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Entity lastEntity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_indexToEntity[lastIndex];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_indexToEntity[removedIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lastEntity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_entityToIndex[lastEntity] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> removedIndex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_components.</span><span style=\"color:#B392F0\">pop_back</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_indexToEntity.</span><span style=\"color:#B392F0\">pop_back</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_entityToIndex.</span><span style=\"color:#B392F0\">erase</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_entityToIndex.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> m_entityToIndex.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">?</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">m_components[it->second] </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iterator support for system processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">iterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">iterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">const_iterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">const_iterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> Size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> HasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> m_entityToIndex.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(entity) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> m_entityToIndex.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get entity for component at index (for system processing)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> GetEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> m_indexToEntity.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> m_indexToEntity[index];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Resource Handle System (Core Logic Skeleton):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Handle.h - Resource handle template for type safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ResourceType</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Texture</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Mesh</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Audio</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Scene</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> m_handle;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> TYPE_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> VERSION_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> ID_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Handle</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">m_handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> id</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> version</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ResourceType</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Pack type, version, and id into 64-bit handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Validate that id fits in ID_BITS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Store packed value in m_handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use bit shifting and OR operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Extract ID from lower 32 bits of m_handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return extracted ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#B392F0\"> GetVersion</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Extract version from bits 32-47 of m_handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Apply appropriate bit mask</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return extracted version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ResourceType</span><span style=\"color:#B392F0\"> GetType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Extract type from upper 16 bits of m_handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Cast to ResourceType enum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return typed value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> ResourceType</span><span style=\"color:#E1E4E8\">::Texture;</span><span style=\"color:#6A737D\"> // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_handle </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_handle </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.m_handle; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_handle </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.m_handle; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Type aliases for specific handle types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> TextureHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> TextureTag</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> MeshHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> MeshTag</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> AudioHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> AudioTag</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> SceneHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> SceneTag</span><span style=\"color:#E1E4E8\">>;</span></span></code></pre></div>\n\n<p><strong>Core Component Definitions:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Component.h - Standard game components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../math/Vector2.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../math/Vector3.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../resources/ResourceTypes.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Transform</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector3 position{</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector3 rotation{</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span><span style=\"color:#6A737D\">  // Euler angles in radians</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector3 scale{</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Add GetMatrix() method that builds 4x4 transform matrix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add SetPosition(), SetRotation(), SetScale() convenience methods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add Translate(), Rotate(), Scale() relative modification methods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use your math library's matrix construction functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Sprite</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TextureHandle texture;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector2 size{</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector4 color{</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span><span style=\"color:#6A737D\">  // RGBA tint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> layer{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span><span style=\"color:#6A737D\">  // Z-order for sprite sorting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Add constructor that takes texture handle and optional size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add SetColor() method with RGB and RGBA overloads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add GetTexCoords() method for sprite sheet support</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> RigidBody</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector3 velocity{</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector3 acceleration{</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> mass{</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> drag{</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span><span style=\"color:#6A737D\">  // Air resistance coefficient</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> kinematic{</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">};</span><span style=\"color:#6A737D\">  // If true, not affected by forces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Add ApplyForce(Vector3 force) method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add ApplyImpulse(Vector3 impulse) method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add SetVelocity() and AddVelocity() methods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add GetKineticEnergy() calculation method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Language-Specific Optimization Hints:</strong></p>\n<ul>\n<li>Use <code>std::vector::reserve()</code> for component arrays when you know the approximate entity count</li>\n<li>Enable compiler optimizations (<code>-O2</code> or <code>-O3</code>) and consider profile-guided optimization for release builds</li>\n<li>Use <code>alignas(64)</code> on component structures that are processed in tight loops to ensure cache line alignment</li>\n<li>Consider <code>std::vector&lt;bool&gt;</code> specialization for component presence bitmasks, but be aware of its iterator invalidation behavior</li>\n<li>Use <code>constexpr</code> for entity ID bit manipulation functions to ensure compile-time evaluation</li>\n<li>Profile memory allocations with tools like Valgrind Massif or Visual Studio diagnostic tools</li>\n</ul>\n<p><strong>Milestone Checkpoint - Entity Component System:</strong></p>\n<p>After implementing the basic ECS data structures, verify correct behavior:</p>\n<ol>\n<li><strong>Entity ID Management Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run entity ID tests</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   cd</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">./tests/entity_tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: All entity IDs unique, generation increments on recycling</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Component Storage Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Run component array tests  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   cd</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">./tests/component_tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: Components stored densely, iteration performance > 1M entities/ms</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Manual Verification:</strong><ul>\n<li>Create 1000 entities with Transform components</li>\n<li>Destroy every other entity</li>\n<li>Create 500 new entities - they should reuse destroyed entity IDs with incremented generations</li>\n<li>Iterate over all Transform components - should process exactly 1000 components efficiently</li>\n</ul>\n</li>\n</ol>\n<p><strong>Signs of Implementation Problems:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Crash when accessing components</td>\n<td>Entity generation mismatch or invalid index</td>\n<td>Validate entity ID before array access</td>\n</tr>\n<tr>\n<td>Poor system performance</td>\n<td>Array-of-structs instead of struct-of-arrays</td>\n<td>Reorganize component storage</td>\n</tr>\n<tr>\n<td>Memory leaks during entity destruction</td>\n<td>Components not removed from all arrays</td>\n<td>Ensure DestroyEntity clears all components</td>\n</tr>\n<tr>\n<td>Incorrect entity counts after recycling</td>\n<td>Generation counter not incremented</td>\n<td>Increment generation on ID recycling</td>\n</tr>\n</tbody></table>\n<h2 id=\"rendering-system-design\">Rendering System Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Window &amp; Rendering Foundation) — complete graphics pipeline implementation from window creation through batch rendering</p>\n</blockquote>\n<p>The rendering system transforms the abstract game world into pixels on the player&#39;s screen. This process involves coordinating window management, graphics contexts, shader compilation, and efficient batch rendering to achieve consistent 60 FPS performance. The rendering system serves as the bridge between the game&#39;s logical representation and the player&#39;s visual experience, making it one of the most critical and complex subsystems in any game engine.</p>\n<h3 id=\"mental-model-art-production-assembly-line\">Mental Model: Art Production Assembly Line</h3>\n<p>Understanding rendering as a factory pipeline that transforms 3D data into 2D pixels provides an intuitive framework for grasping the complexity and organization of graphics systems.</p>\n<p>Imagine a high-speed art production assembly line in a factory that creates thousands of paintings per second. The raw materials enter the factory as <strong>3D scene data</strong> — entity positions, mesh geometry, texture images, and lighting parameters. These materials flow through multiple specialized stations, each performing a specific transformation operation.</p>\n<p>The <strong>vertex processing station</strong> takes 3D coordinates and transforms them into screen positions, similar to how an artist sketches the basic outline and perspective of objects. Workers at this station apply mathematical transformations (translation, rotation, scaling) and project 3D points onto a 2D canvas, determining where each vertex should appear on the final image.</p>\n<p>Next, the <strong>rasterization station</strong> fills in the areas between vertices, converting geometric shapes into individual pixels. This is analogous to artists filling in the outlined shapes with base colors, determining which pixels belong to which objects and calculating coverage percentages for smooth edges.</p>\n<p>The <strong>fragment processing station</strong> applies the final artistic touches — texturing, lighting calculations, and special effects. Workers at this station sample texture images, blend colors, apply shadows, and execute complex shading algorithms to produce the final pixel colors that viewers will see.</p>\n<p>Finally, the <strong>framebuffer composition station</strong> assembles all the processed pixels into complete frames, handling transparency, depth testing, and multi-sample anti-aliasing. This station ensures that objects appear in the correct depth order and that overlapping elements blend appropriately.</p>\n<p>The critical insight is that this assembly line operates under extreme time pressure — it must produce complete frames every 16.67 milliseconds to maintain 60 FPS. Any bottleneck or inefficiency in the pipeline causes the entire production line to miss deadlines, resulting in frame drops and stuttering. This time constraint drives every architectural decision in the rendering system, from batch processing strategies to memory layout optimizations.</p>\n<p>Just as a real factory optimizes material flow to minimize waste and maximize throughput, the rendering system organizes data and operations to minimize GPU state changes, reduce memory transfers, and maximize parallel processing efficiency. Understanding this assembly line metaphor helps explain why seemingly simple operations like drawing a sprite require careful coordination between multiple subsystems and why performance optimization is central to rendering system design.</p>\n<h3 id=\"window-and-graphics-context\">Window and Graphics Context</h3>\n<p>The window and graphics context layer provides platform abstraction for creating display surfaces and initializing GPU access. This foundation enables the engine to present rendered content to users while remaining portable across different operating systems and graphics APIs.</p>\n<p>Window management encompasses creating the display window, handling resize events, processing input messages, and managing the application lifecycle. The graphics context provides the bridge between the CPU-based engine code and the GPU hardware, establishing communication channels and resource sharing mechanisms that enable efficient rendering operations.</p>\n<p>The <code>Window</code> class encapsulates platform-specific window creation and event handling through a unified interface. On Windows, this involves Win32 API calls to create window classes and message loops. On Linux, it uses X11 or Wayland protocols for window management. macOS requires Cocoa framework integration for proper window handling. The abstraction layer hides these platform differences behind consistent method signatures.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Key Operations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Window Manager</td>\n<td>Platform window creation and lifecycle</td>\n<td>Create window, handle resize, process OS events</td>\n</tr>\n<tr>\n<td>Input Handler</td>\n<td>Mouse, keyboard, and gamepad input processing</td>\n<td>Poll events, translate input codes, queue input events</td>\n</tr>\n<tr>\n<td>Graphics Context</td>\n<td>OpenGL/Vulkan context initialization</td>\n<td>Create rendering context, manage GPU state</td>\n</tr>\n<tr>\n<td>Swap Chain</td>\n<td>Double buffering and frame presentation</td>\n<td>Swap front/back buffers, handle v-sync</td>\n</tr>\n</tbody></table>\n<p>The graphics context initialization process varies significantly between OpenGL and Vulkan. OpenGL context creation requires selecting pixel formats, creating rendering contexts, and loading extension function pointers. The engine must handle context sharing for multi-threaded rendering and context loss scenarios on mobile platforms or when graphics drivers are updated.</p>\n<p>Vulkan context initialization involves a more explicit process: creating instances, enumerating physical devices, selecting queue families, creating logical devices, and establishing command pools. While more complex, this explicit approach provides better control over GPU resource allocation and enables more predictable performance characteristics.</p>\n<blockquote>\n<p><strong>Decision: Graphics API Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: The engine needs low-level graphics access for 2D/3D rendering with consistent performance across platforms</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>OpenGL 4.3+ for simplicity and widespread compatibility</li>\n<li>Vulkan for explicit control and modern GPU features</li>\n<li>DirectX 12 for Windows-specific optimization</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: OpenGL 4.3+ as the primary API with Vulkan as an advanced option</li>\n<li><strong>Rationale</strong>: OpenGL provides sufficient features for educational purposes with much simpler initialization and debugging. Vulkan can be added later for advanced learners seeking cutting-edge performance</li>\n<li><strong>Consequences</strong>: Simpler implementation and debugging, but potentially less optimal performance on modern hardware</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Graphics API</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OpenGL 4.3+</td>\n<td>Simple state machine, excellent debugging tools, universal compatibility</td>\n<td>Implicit state management, driver variance, limited multi-threading</td>\n<td>Yes (Primary)</td>\n</tr>\n<tr>\n<td>Vulkan</td>\n<td>Explicit control, minimal driver overhead, excellent multi-threading</td>\n<td>Complex initialization, verbose API, steeper learning curve</td>\n<td>Yes (Advanced)</td>\n</tr>\n<tr>\n<td>DirectX 12</td>\n<td>Windows optimization, modern features, good tooling</td>\n<td>Platform-locked, complex like Vulkan, limited portability</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>The window configuration system uses the <code>WindowConfig</code> structure to specify window properties during creation. This approach centralizes configuration and enables easy customization for different deployment scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>string</td>\n<td>Window title bar text</td>\n</tr>\n<tr>\n<td>width</td>\n<td>int</td>\n<td>Initial window width in pixels</td>\n</tr>\n<tr>\n<td>height</td>\n<td>int</td>\n<td>Initial window height in pixels</td>\n</tr>\n<tr>\n<td>fullscreen</td>\n<td>bool</td>\n<td>Whether to create fullscreen window</td>\n</tr>\n<tr>\n<td>resizable</td>\n<td>bool</td>\n<td>Whether window can be resized by user</td>\n</tr>\n<tr>\n<td>vsync</td>\n<td>bool</td>\n<td>Whether to enable vertical synchronization</td>\n</tr>\n<tr>\n<td>samples</td>\n<td>int</td>\n<td>Multisample anti-aliasing sample count (0, 2, 4, 8)</td>\n</tr>\n</tbody></table>\n<p>The initialization sequence follows a specific order to ensure proper resource creation and dependency resolution:</p>\n<ol>\n<li>The window manager creates the OS-specific window using the provided <code>WindowConfig</code> parameters</li>\n<li>The system queries available pixel formats and selects the best match for the requested configuration</li>\n<li>The graphics context is created and bound to the window, establishing the rendering pipeline connection</li>\n<li>Extension function pointers are loaded and verified to ensure required OpenGL features are available</li>\n<li>Initial OpenGL state is configured, including viewport dimensions, depth testing, and blending modes</li>\n<li>The swap chain is configured for double buffering with the requested v-sync settings</li>\n<li>Debug output is enabled in development builds to capture graphics API errors and warnings</li>\n</ol>\n<p>Error handling during initialization must gracefully degrade when requested features are unavailable. If multisample anti-aliasing cannot be enabled at the requested sample count, the system should retry with lower sample counts before falling back to no multisampling. Similarly, if v-sync cannot be enabled, rendering should continue without synchronization rather than failing completely.</p>\n<blockquote>\n<p>The critical insight for window management is that the graphics context represents expensive GPU state. Creating and destroying contexts frequently causes performance problems, so the engine should maintain long-lived contexts and handle temporary issues like window minimization or graphics driver updates through context preservation rather than recreation.</p>\n</blockquote>\n<p>Input event processing integrates tightly with the window system since OS events arrive through the window message queue. The engine transforms platform-specific input events into normalized engine events, enabling game logic to remain platform-independent. Mouse coordinates are transformed from OS screen space to engine viewport space, and keyboard events are mapped from platform scan codes to engine key identifiers.</p>\n<p>The frame presentation system coordinates between the rendering pipeline and the display hardware. After the GPU completes rendering operations for a frame, the <code>SwapBuffers</code> method presents the completed frame to the user and begins rendering the next frame. This double buffering approach prevents visual artifacts by ensuring users never see partially rendered frames.</p>\n<h3 id=\"shader-compilation-and-management\">Shader Compilation and Management</h3>\n<p>Shader compilation and management transforms high-level shading language code into GPU-executable programs while providing efficient caching and error recovery mechanisms. The shader system serves as the foundation for all visual effects in the engine, from basic sprite rendering to complex 3D material systems.</p>\n<p>Modern graphics rendering relies entirely on programmable shaders to define how vertices are transformed and how pixels are colored. The shader system must load shader source code from files, compile it into GPU bytecode, link vertex and fragment stages into complete programs, and manage the lifetime of these expensive GPU resources.</p>\n<p>The shader compilation pipeline processes GLSL (OpenGL Shading Language) source code through multiple stages. First, shader source files are loaded from disk and preprocessed to handle include directives and conditional compilation. Then, individual shader stages (vertex, fragment, geometry) are compiled independently. Finally, compiled stages are linked together into complete shader programs that can be executed on the GPU.</p>\n<table>\n<thead>\n<tr>\n<th>Shader Stage</th>\n<th>Input</th>\n<th>Output</th>\n<th>Primary Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Vertex</td>\n<td>Vertex attributes (position, UV, normal)</td>\n<td>Transformed vertices in clip space</td>\n<td>Transform 3D positions to screen coordinates</td>\n</tr>\n<tr>\n<td>Fragment</td>\n<td>Interpolated vertex outputs</td>\n<td>Final pixel color (RGBA)</td>\n<td>Calculate pixel colors from textures and lighting</td>\n</tr>\n<tr>\n<td>Geometry</td>\n<td>Primitive vertices</td>\n<td>Modified or additional primitives</td>\n<td>Generate or modify geometry (optional stage)</td>\n</tr>\n</tbody></table>\n<p>The <code>ShaderProgram</code> class encapsulates the complete shader pipeline from source loading through GPU resource management. Each shader program maintains references to its component stages and provides a unified interface for setting uniform variables and binding texture resources.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m_programID</td>\n<td>uint32_t</td>\n<td>OpenGL program object identifier</td>\n</tr>\n<tr>\n<td>m_vertexShaderID</td>\n<td>uint32_t</td>\n<td>Compiled vertex shader object</td>\n</tr>\n<tr>\n<td>m_fragmentShaderID</td>\n<td>uint32_t</td>\n<td>Compiled fragment shader object</td>\n</tr>\n<tr>\n<td>m_uniformLocations</td>\n<td>unordered_map&lt;string, int&gt;</td>\n<td>Cached uniform variable locations</td>\n</tr>\n<tr>\n<td>m_attributeLocations</td>\n<td>unordered_map&lt;string, int&gt;</td>\n<td>Cached vertex attribute locations</td>\n</tr>\n<tr>\n<td>m_isLinked</td>\n<td>bool</td>\n<td>Whether program linking succeeded</td>\n</tr>\n</tbody></table>\n<p>Shader compilation error handling requires careful attention since shader compilation can fail for many reasons — syntax errors, incompatible GLSL versions, missing extensions, or hardware limitations. The shader system must capture compilation logs, provide meaningful error messages to developers, and gracefully handle runtime failures.</p>\n<p>The compilation process follows a specific sequence designed to catch errors early and provide detailed diagnostic information:</p>\n<ol>\n<li>Shader source code is loaded from disk files, with include directive preprocessing and macro expansion</li>\n<li>GLSL version headers are validated against the current OpenGL context capabilities </li>\n<li>Individual shader stages are compiled, with error logs captured and parsed for meaningful messages</li>\n<li>Compiled shaders are linked into a complete program, with additional validation for interface matching</li>\n<li>Uniform and attribute locations are queried and cached to avoid expensive runtime lookups</li>\n<li>The complete program is validated against current OpenGL state to ensure compatibility</li>\n<li>Successful programs are stored in the shader cache with dependency tracking for hot-reloading</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Shader Hot-Reloading Support</strong></p>\n<ul>\n<li><strong>Context</strong>: Artists and developers need rapid iteration on visual effects without engine restarts</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>No hot-reloading for simplicity</li>\n<li>File system watching with automatic recompilation</li>\n<li>Manual reload triggers through debug interface</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: File system watching with automatic recompilation in debug builds</li>\n<li><strong>Rationale</strong>: Hot-reloading dramatically improves developer productivity for visual tweaking, and file watching provides the best user experience</li>\n<li><strong>Consequences</strong>: Additional complexity for file monitoring, but much faster iteration cycles for shader development</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No Hot-Reloading</td>\n<td>Simple implementation, no file dependencies</td>\n<td>Slow iteration, requires engine restarts</td>\n<td>No</td>\n</tr>\n<tr>\n<td>File System Watching</td>\n<td>Automatic updates, fast iteration</td>\n<td>Complex file monitoring, potential race conditions</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Manual Reload</td>\n<td>Simple triggers, controlled timing</td>\n<td>Requires developer action, easy to forget</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>The uniform variable system provides type-safe interfaces for setting shader parameters from CPU code. Uniforms represent data that remains constant across multiple vertices or fragments within a single draw call — transformation matrices, material properties, lighting parameters, and texture bindings.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SetUniform</td>\n<td>name string, value Matrix4</td>\n<td>void</td>\n<td>Sets 4x4 matrix uniform variable</td>\n</tr>\n<tr>\n<td>SetUniform</td>\n<td>name string, value Vector3</td>\n<td>void</td>\n<td>Sets 3D vector uniform variable</td>\n</tr>\n<tr>\n<td>SetUniform</td>\n<td>name string, value float</td>\n<td>void</td>\n<td>Sets scalar float uniform variable</td>\n</tr>\n<tr>\n<td>SetUniform</td>\n<td>name string, value int</td>\n<td>void</td>\n<td>Sets integer uniform variable</td>\n</tr>\n<tr>\n<td>SetTexture</td>\n<td>name string, slot int, handle TextureHandle</td>\n<td>void</td>\n<td>Binds texture to specified texture unit</td>\n</tr>\n</tbody></table>\n<p>Shader caching optimizes compilation performance by storing compiled bytecode and avoiding redundant compilation operations. The cache system tracks shader source file modification times and dependency relationships to invalidate cached programs when source files change.</p>\n<p>The shader cache implementation uses content-based hashing to generate stable cache keys that survive file system changes. When loading a shader program, the system computes hashes of all source files and their dependencies, then checks if a cached compiled version exists with matching hashes. If found, the cached program is loaded directly; otherwise, compilation proceeds normally and the result is cached for future use.</p>\n<blockquote>\n<p>The key insight for shader management is that compilation is expensive but loading compiled shaders is fast. Modern GPUs can compile complex shaders in milliseconds, but this still represents thousands of CPU cycles. Aggressive caching with proper invalidation provides the best balance between compilation speed and correctness.</p>\n</blockquote>\n<p>Error recovery mechanisms handle shader compilation failures gracefully to prevent engine crashes and provide meaningful feedback to developers. When shader compilation fails, the system should:</p>\n<ol>\n<li>Log detailed error information including line numbers and specific syntax issues</li>\n<li>Fall back to a simple &quot;error shader&quot; that renders objects in a bright error color</li>\n<li>Continue monitoring the source file for changes to retry compilation automatically</li>\n<li>Preserve the previous working version of the shader if available</li>\n<li>Display error overlays in debug builds to make compilation issues immediately visible</li>\n</ol>\n<p>The shader preprocessing system enables code reuse and conditional compilation through include directives and macro definitions. Common vertex transformation functions, lighting calculations, and utility functions can be shared across multiple shader programs through include files.</p>\n<p>Preprocessing handles:</p>\n<ul>\n<li><code>#include &quot;filename.glsl&quot;</code> directives for code inclusion with circular dependency detection</li>\n<li><code>#define MACRO_NAME value</code> definitions for conditional compilation and constants</li>\n<li><code>#ifdef</code> / <code>#ifndef</code> / <code>#endif</code> blocks for platform-specific code paths</li>\n<li>Automatic injection of engine-specific defines (OPENGL_VERSION, PLATFORM_WINDOWS, etc.)</li>\n</ul>\n<h3 id=\"batch-rendering-architecture\">Batch Rendering Architecture</h3>\n<p>Batch rendering architecture optimizes GPU utilization by minimizing draw calls and state changes while maximizing data throughput for sprite and mesh rendering operations. This system transforms individual render requests into efficient GPU command streams that can process thousands of objects per frame within the 16.67ms frame budget.</p>\n<p>The fundamental challenge in rendering performance is that individual draw calls carry significant CPU and GPU overhead. Each draw call requires state validation, driver command translation, and GPU pipeline setup. With thousands of sprites or meshes to render per frame, naive approaches that issue one draw call per object quickly become CPU-bound and fail to utilize the GPU&#39;s parallel processing capabilities effectively.</p>\n<p>Batch rendering solves this problem by collecting geometrically similar objects into shared vertex buffers, then issuing single draw calls that render hundreds or thousands of objects simultaneously. This approach reduces draw call counts from thousands to dozens while enabling the GPU to process vertex data in large parallel batches.</p>\n<p>The batching system organizes rendering operations by <strong>material compatibility</strong> and <strong>depth ordering</strong>. Objects that share the same shader program, texture bindings, and blend state can be batched together. However, proper depth ordering requires breaking batches when objects at different depths would be rendered incorrectly if combined.</p>\n<table>\n<thead>\n<tr>\n<th>Batch Type</th>\n<th>Geometry</th>\n<th>Material Requirements</th>\n<th>Typical Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sprite Batch</td>\n<td>Textured quads</td>\n<td>Same texture, same blend mode</td>\n<td>UI elements, 2D game objects, particle effects</td>\n</tr>\n<tr>\n<td>Mesh Batch</td>\n<td>Arbitrary geometry</td>\n<td>Same shader, compatible uniforms</td>\n<td>3D models with shared materials</td>\n</tr>\n<tr>\n<td>Text Batch</td>\n<td>Glyph quads</td>\n<td>Same font texture, same color</td>\n<td>UI text, debug overlays, HUD elements</td>\n</tr>\n<tr>\n<td>Line Batch</td>\n<td>Line segments</td>\n<td>Same line width, same color</td>\n<td>Debug visualization, wireframes</td>\n</tr>\n</tbody></table>\n<p>The sprite batching system represents the most common use case for 2D games and UI rendering. Sprites are rendered as textured quads (two triangles forming a rectangle) with transformation matrices applied in the vertex shader. The batch system collects sprite data into large vertex buffers, sorts by depth and material, then renders entire batches with single draw calls.</p>\n<p>Sprite vertex data includes position, texture coordinates, color tint, and transformation information. To maximize GPU efficiency, this data is organized using <strong>struct-of-arrays</strong> layout rather than <strong>array-of-structs</strong>, enabling efficient SIMD processing and reducing memory bandwidth requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Attribute</th>\n<th>Type</th>\n<th>Components</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Position</td>\n<td>Vector2</td>\n<td>x, y</td>\n<td>Local quad vertex position (-0.5 to 0.5)</td>\n</tr>\n<tr>\n<td>TexCoords</td>\n<td>Vector2</td>\n<td>u, v</td>\n<td>Texture coordinate for this vertex</td>\n</tr>\n<tr>\n<td>Color</td>\n<td>Vector4</td>\n<td>r, g, b, a</td>\n<td>Color tint and transparency</td>\n</tr>\n<tr>\n<td>Transform</td>\n<td>Matrix4</td>\n<td>16 floats</td>\n<td>World transformation matrix</td>\n</tr>\n<tr>\n<td>TextureID</td>\n<td>int</td>\n<td>1 int</td>\n<td>Texture array index for batched textures</td>\n</tr>\n</tbody></table>\n<p>The batching algorithm processes sprites in multiple phases to ensure correct rendering order while maximizing batch sizes:</p>\n<ol>\n<li><strong>Collection Phase</strong>: Gather all sprite render requests for the current frame, including transformation, texture, and material data</li>\n<li><strong>Sorting Phase</strong>: Sort sprites by depth (back-to-front for transparency, front-to-back for opaque objects) and then by material compatibility</li>\n<li><strong>Batching Phase</strong>: Group consecutive sprites with compatible materials into batches, breaking when material changes or batch size limits are reached</li>\n<li><strong>Upload Phase</strong>: Transfer vertex data for all batches to GPU vertex buffers using efficient memory mapping or buffer streaming</li>\n<li><strong>Rendering Phase</strong>: Issue draw calls for each batch with appropriate material state binding and uniform variable updates</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Batch Size Limitations</strong></p>\n<ul>\n<li><strong>Context</strong>: GPU hardware has limits on vertex buffer sizes and draw call complexity</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Fixed batch sizes (1000 sprites per batch)</li>\n<li>Dynamic sizing based on available GPU memory</li>\n<li>Adaptive sizing based on frame performance</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Fixed batch size of 1000 sprites with dynamic rebatching for large scenes</li>\n<li><strong>Rationale</strong>: Fixed sizes provide predictable performance and memory usage, while 1000 sprites fits well within GPU vertex processing capabilities</li>\n<li><strong>Consequences</strong>: Simple implementation and consistent performance, but may be suboptimal for very large or very small sprite counts</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fixed Batch Sizes</td>\n<td>Predictable memory usage, simple implementation</td>\n<td>May be inefficient for varying scene complexity</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Dynamic Sizing</td>\n<td>Adapts to scene complexity and available memory</td>\n<td>Complex memory management, unpredictable performance</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Adaptive Sizing</td>\n<td>Optimizes for current performance conditions</td>\n<td>Requires performance monitoring, potential instability</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>The mesh batching system extends batching concepts to arbitrary 3D geometry while handling the additional complexity of varied vertex layouts and material properties. Unlike sprites, which share identical geometry, meshes have unique vertex counts, attribute layouts, and transformation requirements.</p>\n<p>Mesh batching uses <strong>instanced rendering</strong> to draw multiple copies of the same mesh with different transformation matrices. This approach works well for scenarios like rendering forests (many tree meshes), crowds (character meshes), or debris (rock meshes). Each instance provides a unique transformation matrix while sharing the base mesh geometry.</p>\n<p>The batch rendering pipeline integrates with the Entity Component System to efficiently process renderable entities. Systems query for entities with both <code>Transform</code> and <code>Sprite</code> or <code>MeshRenderer</code> components, then submit render requests to the appropriate batching system.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sprite</td>\n<td>texture</td>\n<td>TextureHandle</td>\n<td>Texture resource for sprite rendering</td>\n</tr>\n<tr>\n<td></td>\n<td>size</td>\n<td>Vector2</td>\n<td>Sprite dimensions in world units</td>\n</tr>\n<tr>\n<td></td>\n<td>color</td>\n<td>Vector4</td>\n<td>Color tint and alpha transparency</td>\n</tr>\n<tr>\n<td></td>\n<td>layer</td>\n<td>int</td>\n<td>Depth sorting layer for batch ordering</td>\n</tr>\n<tr>\n<td>MeshRenderer</td>\n<td>mesh</td>\n<td>MeshHandle</td>\n<td>Mesh geometry resource</td>\n</tr>\n<tr>\n<td></td>\n<td>material</td>\n<td>MaterialHandle</td>\n<td>Shader and texture binding information</td>\n</tr>\n<tr>\n<td></td>\n<td>castShadows</td>\n<td>bool</td>\n<td>Whether this mesh participates in shadow mapping</td>\n</tr>\n</tbody></table>\n<p>The rendering system processes batches in strict depth order to ensure correct transparency and depth testing behavior. Opaque objects are rendered front-to-back to maximize early depth rejection and reduce fragment processing load. Transparent objects are rendered back-to-front to ensure proper alpha blending.</p>\n<p>Texture atlasing optimizes batch coherence by combining multiple small textures into larger texture arrays or atlas images. This technique enables sprites with different source textures to be batched together by using texture coordinates and array indices to select the appropriate sub-image.</p>\n<p>The atlas system automatically packs sprite textures into larger atlas textures during asset loading, updating texture coordinates to reference the packed locations. At runtime, the batching system can group sprites from the same atlas regardless of their original texture sources, significantly improving batch sizes and reducing texture binding overhead.</p>\n<blockquote>\n<p>The crucial insight for batch rendering is that modern GPUs excel at processing large amounts of similar data in parallel, but struggle with frequent state changes and small draw calls. The batching system transforms the rendering workload from &quot;thousands of tiny tasks&quot; to &quot;dozens of large tasks,&quot; matching the GPU&#39;s architectural strengths.</p>\n</blockquote>\n<p>Buffer management for batch rendering uses dynamic vertex buffers that are updated each frame with current batch data. The system employs multiple buffer strategies depending on the rendering load:</p>\n<ul>\n<li><strong>Stream buffers</strong> for data that changes completely each frame (sprite positions, colors)</li>\n<li><strong>Dynamic buffers</strong> for data that changes frequently but has some coherence (mesh instance transforms)</li>\n<li><strong>Static buffers</strong> for data that rarely changes (mesh vertex data, font glyph geometry)</li>\n</ul>\n<p>Memory mapping techniques provide efficient CPU-to-GPU data transfer by avoiding unnecessary memory copies. The rendering system maps vertex buffer memory directly, writes batch data in place, then unmaps before rendering. This approach minimizes memory bandwidth usage and reduces CPU overhead for large batch uploads.</p>\n<h3 id=\"rendering-architecture-decisions\">Rendering Architecture Decisions</h3>\n<p>The rendering system&#39;s architecture emerges from a series of critical design decisions that balance performance, complexity, maintainability, and educational value. These decisions establish the foundational patterns that influence every aspect of the graphics pipeline, from low-level buffer management to high-level scene rendering strategies.</p>\n<p>Each architectural decision represents a trade-off between competing priorities. Performance optimizations often increase implementation complexity. Cross-platform compatibility may sacrifice platform-specific optimizations. Educational clarity sometimes conflicts with industry best practices that assume extensive background knowledge.</p>\n<blockquote>\n<p><strong>Decision: Immediate vs Retained Mode Rendering</strong></p>\n<ul>\n<li><strong>Context</strong>: The engine needs to balance rendering flexibility with performance optimization and implementation complexity</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Immediate mode with direct draw calls from game logic</li>\n<li>Retained mode with scene graphs and cached render commands</li>\n<li>Hybrid approach with batched immediate commands</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Hybrid approach using immediate submission with automatic batching</li>\n<li><strong>Rationale</strong>: Immediate mode provides simple, intuitive APIs for game developers, while automatic batching ensures good performance without requiring manual optimization</li>\n<li><strong>Consequences</strong>: Easier to use than pure retained mode, better performance than naive immediate mode, but requires sophisticated batching logic</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Rendering Mode</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate Mode</td>\n<td>Simple API, direct control, easy debugging</td>\n<td>Poor performance, no optimization opportunity</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Retained Mode</td>\n<td>Excellent performance, automatic optimization</td>\n<td>Complex API, harder to debug, less flexible</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Hybrid Batched</td>\n<td>Good performance, simple API, automatic optimization</td>\n<td>Complex implementation, batching overhead</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<p>The immediate vs retained mode decision fundamentally shapes how game developers interact with the rendering system. Immediate mode APIs allow developers to issue draw commands directly from game logic, providing intuitive control flow and easy debugging. However, naive immediate mode implementations suffer from poor performance due to excessive draw calls and missed optimization opportunities.</p>\n<p>Retained mode systems build scene graphs or command lists that can be optimized, culled, and batched before rendering. While this enables excellent performance, it requires developers to think in terms of scene management rather than direct rendering, increasing cognitive overhead and debugging complexity.</p>\n<p>The hybrid approach chosen for this engine provides immediate-style APIs that internally build optimized command streams. Game developers can issue draw commands directly, but the rendering system automatically batches, sorts, and optimizes these commands before GPU submission. This design provides the performance benefits of retained mode with the usability advantages of immediate mode.</p>\n<blockquote>\n<p><strong>Decision: OpenGL vs Vulkan Primary API</strong></p>\n<ul>\n<li><strong>Context</strong>: Modern graphics development can target either OpenGL for simplicity or Vulkan for maximum performance and control</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>OpenGL 4.3+ as the primary API with good compatibility and debugging</li>\n<li>Vulkan as the primary API for cutting-edge performance</li>\n<li>Multi-API abstraction supporting both OpenGL and Vulkan equally</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: OpenGL 4.3+ as primary with optional Vulkan backend for advanced users</li>\n<li><strong>Rationale</strong>: OpenGL provides sufficient performance for educational purposes with much simpler debugging and implementation, while Vulkan can be added as an advanced learning path</li>\n<li><strong>Consequences</strong>: Faster initial development and easier debugging, but may not demonstrate modern GPU programming best practices</li>\n</ul>\n</blockquote>\n<p>The graphics API selection influences every aspect of the rendering system architecture. OpenGL&#39;s implicit state machine model requires careful state tracking to avoid expensive redundant operations, while Vulkan&#39;s explicit model demands detailed resource management but provides predictable performance characteristics.</p>\n<p>OpenGL benefits include widespread compatibility, excellent debugging tools (RenderDoc, gDEBugger), extensive documentation, and gentler learning curves. The implicit state management, while sometimes criticized, actually simplifies many common rendering scenarios and reduces boilerplate code for educational implementations.</p>\n<p>Vulkan benefits include explicit resource control, minimal driver overhead, excellent multi-threading support, and modern GPU feature access. However, Vulkan requires substantially more code for basic operations, has steep learning curves, and provides fewer debugging tools for newcomers.</p>\n<blockquote>\n<p><strong>Decision: Batching Strategy Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: Batch rendering can be organized by material, depth, object type, or hybrid approaches</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Material-first batching that prioritizes reducing state changes</li>\n<li>Depth-first batching that prioritizes correct transparency rendering</li>\n<li>Hybrid batching with separate passes for opaque and transparent objects</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Hybrid batching with opaque front-to-back and transparent back-to-front passes</li>\n<li><strong>Rationale</strong>: Depth ordering is critical for visual correctness, while material batching within depth passes provides good performance optimization</li>\n<li><strong>Consequences</strong>: Correct transparency and depth behavior, good batching efficiency, but requires two-pass rendering and more complex sorting</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Batching Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Material-First</td>\n<td>Maximum batching efficiency, minimal state changes</td>\n<td>Incorrect transparency, depth fighting issues</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Depth-First</td>\n<td>Correct transparency, optimal depth testing</td>\n<td>Poor batching, many material state changes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Hybrid Two-Pass</td>\n<td>Correct rendering, good batching within passes</td>\n<td>More complex implementation, dual sorting</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<p>The batching strategy decision affects both rendering correctness and performance characteristics. Pure material-first batching maximizes GPU efficiency by minimizing texture bindings and shader changes, but breaks transparency rendering when objects at different depths are rendered out of order.</p>\n<p>Pure depth-first batching ensures correct transparency and depth testing by rendering objects in strict depth order, but sacrifices batching efficiency when nearby objects use different materials. This approach often results in excessive draw calls and poor GPU utilization.</p>\n<p>The hybrid two-pass approach separates opaque and transparent objects into different rendering passes. Opaque objects are rendered front-to-back within material batches to maximize early depth rejection, while transparent objects are rendered back-to-front within material batches to ensure proper alpha blending. This strategy provides correct visual results while maintaining reasonable batching efficiency.</p>\n<blockquote>\n<p><strong>Decision: Vertex Buffer Management Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Batch rendering requires efficient CPU-to-GPU data transfer for dynamic vertex data</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Single large vertex buffer with sub-allocation</li>\n<li>Multiple fixed-size buffers with round-robin usage</li>\n<li>Dynamic buffer allocation based on frame requirements</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Multiple fixed-size buffers with round-robin allocation</li>\n<li><strong>Rationale</strong>: Fixed-size buffers provide predictable memory usage and avoid allocation/deallocation overhead, while multiple buffers prevent GPU stalls</li>\n<li><strong>Consequences</strong>: Predictable memory usage and good performance, but may waste memory when batch sizes vary significantly</li>\n</ul>\n</blockquote>\n<p>The vertex buffer management strategy influences both rendering performance and memory usage patterns. GPU vertex buffers represent expensive resources that must be carefully managed to avoid allocation overhead and synchronization stalls.</p>\n<p>Single large vertex buffers enable efficient memory usage by packing all batch data into contiguous memory regions. However, this approach requires complex sub-allocation logic and can cause GPU stalls when previous draw calls are still processing buffer regions needed for new batches.</p>\n<p>Dynamic buffer allocation provides perfect memory efficiency by allocating exactly the required buffer sizes each frame. However, frequent allocation and deallocation operations cause CPU overhead and memory fragmentation that can degrade performance over time.</p>\n<p>The chosen round-robin buffer strategy pre-allocates multiple fixed-size vertex buffers and cycles between them each frame. This approach ensures that while one buffer is being processed by the GPU, the CPU can safely update other buffers without synchronization stalls. The fixed sizes provide predictable memory usage while multiple buffers enable efficient parallel processing.</p>\n<blockquote>\n<p>The key architectural insight for rendering systems is that GPU performance depends heavily on data flow patterns rather than just algorithmic complexity. Decisions that optimize for consistent data throughput and minimal state changes often matter more than clever algorithms that assume zero-cost state transitions.</p>\n</blockquote>\n<p>Error handling and graceful degradation strategies ensure that rendering failures don&#39;t crash the engine or leave users with blank screens. The rendering system implements multiple fallback levels:</p>\n<ol>\n<li><strong>Shader Compilation Errors</strong>: Fall back to simple unlit shaders that render objects in solid colors</li>\n<li><strong>Texture Loading Failures</strong>: Use checkerboard error textures that clearly indicate missing assets</li>\n<li><strong>Buffer Allocation Failures</strong>: Reduce batch sizes or fall back to immediate mode rendering</li>\n<li><strong>Context Loss</strong>: Recreate all GPU resources and reload shaders/textures from cached data</li>\n<li><strong>Driver Crashes</strong>: Implement context recovery with exponential backoff for repeated failures</li>\n</ol>\n<p>Performance monitoring integration tracks key rendering metrics to identify performance bottlenecks and validate optimization effectiveness. The system measures:</p>\n<ul>\n<li>Frame rendering times and frame rate consistency</li>\n<li>Draw call counts and batch effectiveness ratios</li>\n<li>GPU memory usage and vertex buffer utilization</li>\n<li>Shader compilation times and cache hit rates</li>\n<li>Texture binding changes and material state transitions</li>\n</ul>\n<p>These metrics enable data-driven performance optimization and help developers understand the impact of different rendering approaches on their specific game content and target hardware configurations.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete technology recommendations and starter code to bridge the gap between the rendering system design and actual implementation. The focus is on practical techniques that enable rapid development while maintaining the architectural principles described above.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Window Management</td>\n<td>SDL2 for cross-platform window/input handling</td>\n<td>GLFW with custom input abstraction layer</td>\n</tr>\n<tr>\n<td>Graphics Context</td>\n<td>OpenGL 4.3 with GLAD function loader</td>\n<td>Vulkan with custom command buffer abstraction</td>\n</tr>\n<tr>\n<td>Shader Compilation</td>\n<td>Direct OpenGL calls with error logging</td>\n<td>SPIR-V compilation with cross-API compatibility</td>\n</tr>\n<tr>\n<td>Texture Loading</td>\n<td>stb_image for PNG/JPG support</td>\n<td>Custom loader with DDS and HDR support</td>\n</tr>\n<tr>\n<td>Mathematics</td>\n<td>GLM library for vectors and matrices</td>\n<td>Custom SIMD-optimized math library</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>engine/\n├── src/\n│   ├── rendering/\n│   │   ├── window.hpp/.cpp          ← Platform window abstraction\n│   │   ├── renderer.hpp/.cpp        ← Main rendering interface\n│   │   ├── shader.hpp/.cpp          ← Shader compilation and management\n│   │   ├── batch_renderer.hpp/.cpp  ← Sprite and mesh batching system\n│   │   ├── texture.hpp/.cpp         ← Texture loading and management\n│   │   └── vertex_buffer.hpp/.cpp   ← Buffer management utilities\n│   ├── platform/\n│   │   ├── window_sdl2.cpp          ← SDL2 window implementation\n│   │   └── opengl_context.cpp       ← OpenGL context setup\n│   └── math/\n│       ├── vector.hpp               ← Vector2, Vector3 definitions\n│       └── matrix.hpp               ← Matrix4 transformation utilities\n├── assets/\n│   └── shaders/\n│       ├── sprite.vert              ← Basic sprite vertex shader\n│       ├── sprite.frag              ← Basic sprite fragment shader\n│       └── error.frag               ← Fallback error shader\n└── external/\n    ├── SDL2/                        ← SDL2 library\n    ├── glad/                        ← OpenGL function loader\n    └── stb/                         ← Image loading library</code></pre></div>\n\n<p><strong>Window and Graphics Context Infrastructure:</strong></p>\n<p>This complete window management implementation handles platform-specific details while providing a clean interface for the rendering system:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// window.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"math/vector.hpp\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> WindowConfig</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string title </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Game Engine\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> width </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 800</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> height </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 600</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> fullscreen </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> resizable </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> vsync </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> samples </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // MSAA samples (0, 2, 4, 8)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Window</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> ResizeCallback</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> width</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> height</span><span style=\"color:#E1E4E8\">)>;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Window</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~Window</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> WindowConfig</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> ShouldClose</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SwapBuffers</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> PollEvents</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#B392F0\"> GetSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> Vector2{m_width, m_height}; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetResizeCallback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ResizeCallback</span><span style=\"color:#FFAB70\"> callback</span><span style=\"color:#E1E4E8\">) { m_resizeCallback </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> callback; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Input state queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsKeyPressed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> keycode</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsMouseButtonPressed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> button</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#B392F0\"> GetMousePosition</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> SDL_Window</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> m_window </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> m_glContext </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // SDL_GLContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> m_width </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> m_height </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResizeCallback m_resizeCallback;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    friend</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> HandleWindowResize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> width</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> height</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// window.cpp - Complete SDL2 implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"window.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;SDL2/SDL.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;glad/glad.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> Window</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> g_currentWindow </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> Window</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Initialize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> WindowConfig</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">SDL_Init</span><span style=\"color:#E1E4E8\">(SDL_INIT_VIDEO) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"SDL_Init Error: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> SDL_GetError</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set OpenGL attributes before window creation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SDL_GL_SetAttribute</span><span style=\"color:#E1E4E8\">(SDL_GL_CONTEXT_MAJOR_VERSION, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SDL_GL_SetAttribute</span><span style=\"color:#E1E4E8\">(SDL_GL_CONTEXT_MINOR_VERSION, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SDL_GL_SetAttribute</span><span style=\"color:#E1E4E8\">(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SDL_GL_SetAttribute</span><span style=\"color:#E1E4E8\">(SDL_GL_DOUBLEBUFFER, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SDL_GL_SetAttribute</span><span style=\"color:#E1E4E8\">(SDL_GL_DEPTH_SIZE, </span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (config.samples </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        SDL_GL_SetAttribute</span><span style=\"color:#E1E4E8\">(SDL_GL_MULTISAMPLEBUFFERS, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        SDL_GL_SetAttribute</span><span style=\"color:#E1E4E8\">(SDL_GL_MULTISAMPLESAMPLES, config.samples);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Uint32 flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SDL_WINDOW_OPENGL </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SDL_WINDOW_SHOWN;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (config.fullscreen) flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> SDL_WINDOW_FULLSCREEN;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (config.resizable) flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> SDL_WINDOW_RESIZABLE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m_window </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> SDL_CreateWindow</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.title.</span><span style=\"color:#B392F0\">c_str</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.width, config.height, flags</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">m_window) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"SDL_CreateWindow Error: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> SDL_GetError</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m_glContext </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> SDL_GL_CreateContext</span><span style=\"color:#E1E4E8\">(m_window);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">m_glContext) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"SDL_GL_CreateContext Error: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> SDL_GetError</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load OpenGL functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">gladLoadGLLoader</span><span style=\"color:#E1E4E8\">((GLADloadproc)SDL_GL_GetProcAddress)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Failed to initialize OpenGL context\"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set vsync</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SDL_GL_SetSwapInterval</span><span style=\"color:#E1E4E8\">(config.vsync </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure initial OpenGL state</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glEnable</span><span style=\"color:#E1E4E8\">(GL_BLEND);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glBlendFunc</span><span style=\"color:#E1E4E8\">(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glEnable</span><span style=\"color:#E1E4E8\">(GL_DEPTH_TEST);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    glDepthFunc</span><span style=\"color:#E1E4E8\">(GL_LESS);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (config.samples </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        glEnable</span><span style=\"color:#E1E4E8\">(GL_MULTISAMPLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m_width </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config.width;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m_height </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config.height;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    g_currentWindow </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"OpenGL \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> glGetString</span><span style=\"color:#E1E4E8\">(GL_VERSION) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"GPU: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> glGetString</span><span style=\"color:#E1E4E8\">(GL_RENDERER) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> Window</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">PollEvents</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SDL_Event event;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">SDL_PollEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">event)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (event.type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> SDL_QUIT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Set close flag - implementation detail</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> SDL_WINDOWEVENT:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (event.window.event </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SDL_WINDOWEVENT_RESIZED) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    m_width </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event.window.data1;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    m_height </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event.window.data2;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    glViewport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, m_width, m_height);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> (m_resizeCallback) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        m_resizeCallback</span><span style=\"color:#E1E4E8\">(m_width, m_height);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Shader System Core Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// shader.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"math/vector.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"math/matrix.hpp\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ShaderProgram</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ShaderProgram</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~ShaderProgram</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> LoadFromFiles</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> vertexPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> fragmentPath</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> LoadFromSource</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> vertexSource</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> fragmentSource</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Use</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_programID </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> m_isLinked; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Uniform setters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetUniform</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetUniform</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetUniform</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector3</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetUniform</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector4</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetUniform</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Matrix4</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetUniform</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetProgramID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_programID; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_programID </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_vertexShaderID </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_fragmentShaderID </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> m_isLinked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mutable</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, </span><span style=\"color:#F97583\">int></span><span style=\"color:#E1E4E8\"> m_uniformLocations;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> CompileShader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> shaderType</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> LinkProgram</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> GetUniformLocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> CheckCompileErrors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> shader</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Basic sprite vertex shader (assets/shaders/sprite.vert)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> SPRITE_VERTEX_SHADER </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> R\"(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">#version 430 core</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">layout (location = 0) in vec2 a_Position;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">layout (location = 1) in vec2 a_TexCoord;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">layout (location = 2) in vec4 a_Color;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">uniform mat4 u_ViewProjection;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">uniform mat4 u_Transform;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">out vec2 v_TexCoord;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">out vec4 v_Color;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">void main() {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    v_TexCoord = a_TexCoord;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    v_Color = a_Color;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 0.0, 1.0);</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Basic sprite fragment shader (assets/shaders/sprite.frag)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> SPRITE_FRAGMENT_SHADER </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> R\"(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">#version 430 core</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">in vec2 v_TexCoord;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">in vec4 v_Color;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">uniform sampler2D u_Texture;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">out vec4 FragColor;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">void main() {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    FragColor = texture(u_Texture, v_TexCoord) * v_Color;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p><strong>Batch Renderer Core Logic Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// batch_renderer.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"rendering/shader.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"math/vector.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"math/matrix.hpp\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> SpriteVertex</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector2 position;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector2 texCoord;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector4 color;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> SpriteRenderData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Matrix4 transform;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector4 color;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> textureID;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> depth;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BatchRenderer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> MAX_SPRITES_PER_BATCH </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> VERTICES_PER_SPRITE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> INDICES_PER_SPRITE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BatchRenderer</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~BatchRenderer</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> BeginBatch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Matrix4</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> viewProjection</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SubmitSprite</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> SpriteRenderData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> sprite</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> EndBatch</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> BatchData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">SpriteVertex</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> vertices;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> indices;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> textureID;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> spriteCount;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_VAO </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_VBO </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_EBO </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ShaderProgram m_spriteShader;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Matrix4 m_viewProjection;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">BatchData</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_batches;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">SpriteRenderData</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_spriteQueue;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> FlushBatches</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> CreateBatch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">SpriteRenderData</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> sprites</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> textureID</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RenderBatch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> BatchData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> batch</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement sprite sorting by depth and texture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SortSprites</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement batch creation from sorted sprite queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> BuildBatches</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement vertex data generation for sprite quads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> GenerateQuadVertices</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> SpriteRenderData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> sprite</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">SpriteVertex</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> vertices</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Core batch processing implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> BatchRenderer</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">EndBatch</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (m_spriteQueue.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Sort sprites by depth (back-to-front for transparency)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use std::sort with custom comparator on m_spriteQueue</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SortSprites</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Group consecutive sprites with same texture into batches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Iterate through sorted queue, break batches when texture changes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BuildBatches</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Upload vertex data and render each batch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use glBufferSubData to upload vertices, then glDrawElements</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FlushBatches</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Clear sprite queue and batch data for next frame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m_spriteQueue.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m_batches.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint for Rendering System:</strong></p>\n<p>After implementing the rendering system, verify the following functionality:</p>\n<ol>\n<li><strong>Window Creation Test</strong>: Run the engine and verify a window appears with the correct title and resolution</li>\n<li><strong>Clear Color Test</strong>: Verify the window clears to a solid color each frame (usually dark blue or black)</li>\n<li><strong>Shader Compilation Test</strong>: Check console output for successful shader compilation messages</li>\n<li><strong>Basic Sprite Test</strong>: Render a single white square at screen center using the sprite batch renderer</li>\n<li><strong>Texture Loading Test</strong>: Load and display a simple PNG texture on a sprite quad</li>\n<li><strong>Batch Performance Test</strong>: Render 100+ sprites and verify frame rate stays above 60 FPS</li>\n</ol>\n<p>Expected console output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>SDL2 initialized successfully\nOpenGL 4.3.0 (or higher)\nGPU: [Your graphics card name]\nSprite vertex shader compiled successfully\nSprite fragment shader compiled successfully\nShader program linked successfully\nBatch renderer initialized: VAO=1, VBO=2, EBO=3</code></pre></div>\n\n<p><strong>Debugging Tips for Rendering Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Black screen</td>\n<td>Shader compilation failure</td>\n<td>Check console for compilation errors</td>\n<td>Fix shader syntax, verify GLSL version</td>\n</tr>\n<tr>\n<td>White/pink textures</td>\n<td>Texture loading failure</td>\n<td>Verify file paths and formats</td>\n<td>Check stb_image error messages, use absolute paths</td>\n</tr>\n<tr>\n<td>Sprites not visible</td>\n<td>Incorrect transformation matrices</td>\n<td>Log matrix values, check coordinate systems</td>\n<td>Verify view-projection matrix, world transforms</td>\n</tr>\n<tr>\n<td>Poor performance</td>\n<td>Too many draw calls</td>\n<td>Count draw calls in GPU debugger</td>\n<td>Increase batch sizes, reduce material changes</td>\n</tr>\n<tr>\n<td>Flickering sprites</td>\n<td>Depth fighting or sorting issues</td>\n<td>Disable depth testing temporarily</td>\n<td>Fix sprite depth values, improve sorting</td>\n</tr>\n</tbody></table>\n<h2 id=\"entity-component-system\">Entity Component System</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Entity Component System) — complete ECS architecture with entity management, component storage, and system execution pipeline</p>\n</blockquote>\n<p>The Entity Component System represents the <strong>organizational backbone</strong> of our game engine, determining how game objects are structured, how their data is stored in memory, and how game logic processes that data each frame. Unlike traditional object-oriented approaches where game objects inherit from base classes and encapsulate both data and behavior, ECS separates these concerns into three distinct architectural elements: entities as identifiers, components as pure data, and systems as pure logic.</p>\n<p>This architectural separation enables <strong>data-oriented design principles</strong> that optimize for modern CPU performance characteristics, particularly cache efficiency and vectorization opportunities. The challenge lies in designing an ECS that provides both the flexibility needed for diverse game object types and the performance required to process thousands of entities at 60 frames per second within our 16.67ms frame time budget.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fecs-data-model.svg\" alt=\"ECS Data Model and Relationships\"></p>\n<h3 id=\"mental-model-database-with-specialized-workers\">Mental Model: Database with Specialized Workers</h3>\n<p>Think of the ECS as a <strong>specialized database system</strong> where entities are row identifiers, components are tables with typed columns, and systems are background workers that process specific combinations of tables. Just as a database query like &quot;SELECT position, velocity FROM entities WHERE has_physics_body&quot; efficiently retrieves only the relevant data, ECS systems query for entities possessing specific component combinations and iterate through densely packed arrays of that data.</p>\n<p>In this mental model, <strong>entities</strong> function like primary keys in a relational database — unique identifiers that link related data across multiple tables. An entity with ID 1203 might have a row in the <code>Transform</code> component table, a row in the <code>Sprite</code> component table, and a row in the <code>RigidBody</code> component table. The entity itself contains no data; it merely serves as the foreign key that relates these component records.</p>\n<p><strong>Components</strong> correspond to database tables with strongly typed schemas. The <code>Transform</code> component table contains columns for <code>position</code>, <code>rotation</code>, and <code>scale</code>, with one row per entity that possesses transform data. Unlike traditional database tables, component tables use dense array storage where removing an entity causes the last element to fill the gap, maintaining cache-friendly contiguous memory layout.</p>\n<p><strong>Systems</strong> act as specialized database workers that execute specific queries and transformations. A <code>MovementSystem</code> queries for entities with both <code>Transform</code> and <code>RigidBody</code> components, iterates through the dense arrays of position and velocity data, and updates positions based on physics calculations. The database analogy breaks down slightly here because systems modify data in-place rather than producing result sets, but the core concept of query-based processing remains.</p>\n<p>This mental model helps explain why ECS excels at performance: database systems optimize for bulk operations on structured data, and ECS applies the same principles to game object processing. Instead of scattered object instances calling virtual methods, we have dense arrays being processed by tight loops — exactly what modern CPUs handle most efficiently.</p>\n<h3 id=\"entity-id-management\">Entity ID Management</h3>\n<p>Entity identity in our ECS follows a <strong>generation-based approach</strong> that combines array indexing with staleness detection. Unlike simple incrementing counters that eventually overflow, or pointer-based systems that suffer from memory fragmentation, generation-based entity IDs provide both efficient storage access and robust error detection when game logic attempts to use outdated entity references.</p>\n<p>The <code>Entity</code> structure packs two pieces of information into a single 32-bit identifier: a 22-bit array index and a 10-bit generation counter. This design supports up to 4,194,304 concurrent entities while providing 1,024 generations per array slot, which proves sufficient for detecting stale references in typical game scenarios where entities are created and destroyed frequently.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_id</code></td>\n<td><code>uint32_t</code></td>\n<td>Packed entity identifier containing index (bits 0-21) and generation (bits 22-31)</td>\n</tr>\n</tbody></table>\n<p>The entity ID encoding uses bitwise operations to pack and extract the index and generation components efficiently. The index occupies the lower 22 bits, providing direct array access for component lookups, while the generation occupies the upper 10 bits, incrementing each time an entity slot is recycled.</p>\n<p>Entity creation follows a <strong>recycling strategy</strong> that maintains a free list of available indices while incrementing generation counters to invalidate stale references. When <code>CreateEntity()</code> is called, the system first checks the free list for recycled indices. If available, it pops the index, increments the generation counter for that slot, and returns the new packed ID. If no recycled indices exist, it allocates a new index at the end of the entity array.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateEntity</code></td>\n<td>None</td>\n<td><code>Entity</code></td>\n<td>Creates new entity with unique recycled ID from free list or new allocation</td>\n</tr>\n<tr>\n<td><code>DestroyEntity</code></td>\n<td><code>Entity</code></td>\n<td><code>void</code></td>\n<td>Removes entity, increments generation, adds index to free list</td>\n</tr>\n<tr>\n<td><code>GetIndex</code></td>\n<td>None</td>\n<td><code>uint32_t</code></td>\n<td>Extracts 22-bit array index from packed entity ID</td>\n</tr>\n<tr>\n<td><code>GetGeneration</code></td>\n<td>None</td>\n<td><code>uint32_t</code></td>\n<td>Extracts 10-bit generation counter from packed entity ID</td>\n</tr>\n<tr>\n<td><code>GetID</code></td>\n<td>None</td>\n<td><code>uint32_t</code></td>\n<td>Returns complete packed entity identifier</td>\n</tr>\n<tr>\n<td><code>IsValid</code></td>\n<td>None</td>\n<td><code>bool</code></td>\n<td>Checks if entity ID is non-zero (NULL_ENTITY check)</td>\n</tr>\n</tbody></table>\n<p>Entity destruction involves a two-phase process that ensures both memory cleanup and reference invalidation. First, the <code>ECSWorld</code> removes all components associated with the entity, triggering cleanup in each component storage system. Second, the entity manager increments the generation counter for the entity&#39;s index slot and adds the index to the free list for future recycling.</p>\n<p>The generation counter mechanism provides <strong>automatic staleness detection</strong> when game logic holds outdated entity references. Consider a scenario where entity 1203 (index 1203, generation 5) is destroyed and its index is recycled for a new entity 1203 (index 1203, generation 6). If old game logic attempts to access the original entity using the outdated ID, component lookups will fail because the stored generation (6) no longer matches the requested generation (5).</p>\n<p>Here&#39;s a step-by-step walkthrough of the entity lifecycle:</p>\n<ol>\n<li><strong>Creation Request</strong>: Game logic calls <code>CreateEntity()</code> to spawn a new game object</li>\n<li><strong>Index Allocation</strong>: Entity manager checks free list; if empty, allocates new index at end of array</li>\n<li><strong>Generation Assignment</strong>: If recycling, increment generation counter for that index; if new, start at generation 1</li>\n<li><strong>ID Encoding</strong>: Pack index (22 bits) and generation (10 bits) into 32-bit entity ID using bitwise operations</li>\n<li><strong>Registration</strong>: Store generation counter in entity metadata array for future validation</li>\n<li><strong>Component Attachment</strong>: Game logic calls <code>AddComponent&lt;T&gt;()</code> to attach data to the new entity</li>\n<li><strong>Active Usage</strong>: Systems process entity through component queries during frame updates</li>\n<li><strong>Destruction Request</strong>: Game logic calls <code>DestroyEntity()</code> when object should be removed</li>\n<li><strong>Component Cleanup</strong>: ECS world removes all components, triggering destructor calls and memory deallocation</li>\n<li><strong>Generation Increment</strong>: Increment generation counter to invalidate existing references to this index</li>\n<li><strong>Index Recycling</strong>: Add index to free list for future entity creation requests</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight</strong>: Generation-based entity IDs solve the &quot;dangling pointer&quot; problem common in game engines where one system destroys an entity while another system still holds a reference. Instead of crashes or undefined behavior, stale references simply fail component lookups gracefully, making debugging significantly easier.</p>\n</blockquote>\n<p><strong>Architecture Decision: Generation-Based Entity IDs</strong></p>\n<blockquote>\n<p><strong>Decision: Generation-Based Entity IDs</strong></p>\n<ul>\n<li><strong>Context</strong>: Game engines frequently create and destroy entities, leading to potential stale references when one system destroys an entity that another system still references. Traditional approaches like raw pointers cause crashes, while UUID-based systems waste memory and reduce cache efficiency.</li>\n<li><strong>Options Considered</strong>: Raw pointers with manual lifecycle management, UUID-based globally unique identifiers, simple incrementing counters, generation-based recycling IDs</li>\n<li><strong>Decision</strong>: 32-bit generation-based entity IDs with 22-bit index and 10-bit generation counter</li>\n<li><strong>Rationale</strong>: Provides both efficient array-based component access (via index) and automatic stale reference detection (via generation counter) while fitting in a single 32-bit word for cache efficiency</li>\n<li><strong>Consequences</strong>: Limits maximum concurrent entities to 4M and maximum generations per slot to 1024, but enables robust error detection and maintains high performance component access patterns</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Raw Pointers</td>\n<td>Fastest access, minimal memory</td>\n<td>Crashes on stale references, manual lifecycle</td>\n<td>No</td>\n</tr>\n<tr>\n<td>UUID Identifiers</td>\n<td>Globally unique, no stale refs</td>\n<td>128-bit overhead, slow component lookup</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Incrementing Counter</td>\n<td>Simple implementation, unique IDs</td>\n<td>Integer overflow, no stale detection</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Generation-Based</td>\n<td>Fast access + stale detection, 32-bit size</td>\n<td>Limited entities/generations per slot</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"component-storage-strategy\">Component Storage Strategy</h3>\n<p>Component storage represents the <strong>performance-critical foundation</strong> of our ECS architecture, directly determining cache efficiency, memory usage patterns, and iteration speed for systems processing thousands of entities per frame. Our storage strategy prioritizes data-oriented design principles, organizing components in dense arrays that maximize CPU cache utilization while providing efficient insertion, removal, and query operations.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fcomponent-storage.svg\" alt=\"ECS Component Storage Organization\"></p>\n<p>The core storage mechanism uses <strong>sparse-dense pairs</strong> where a sparse array provides O(1) entity-to-component lookup while dense arrays enable cache-friendly iteration. This hybrid approach solves the fundamental tension between random access performance (needed for component queries) and sequential access performance (needed for system iteration).</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ComponentArray&lt;T&gt;</code></td>\n<td>Template class</td>\n<td>Dense storage container for specific component type</td>\n</tr>\n<tr>\n<td><code>m_components</code></td>\n<td><code>vector&lt;T&gt;</code></td>\n<td>Dense array containing actual component data in contiguous memory</td>\n</tr>\n<tr>\n<td><code>m_entityToIndex</code></td>\n<td><code>unordered_map&lt;Entity, size_t&gt;</code></td>\n<td>Sparse mapping from entity ID to dense array index</td>\n</tr>\n<tr>\n<td><code>m_indexToEntity</code></td>\n<td><code>vector&lt;Entity&gt;</code></td>\n<td>Parallel array mapping dense indices back to entity IDs</td>\n</tr>\n<tr>\n<td><code>m_freeIndices</code></td>\n<td><code>vector&lt;size_t&gt;</code></td>\n<td>Stack of available indices for recycling after component removal</td>\n</tr>\n</tbody></table>\n<p>The <strong>dense array strategy</strong> ensures that component data remains tightly packed in memory regardless of entity creation and destruction patterns. When system iteration processes components, it accesses sequential memory locations that are likely to be cached together, maximizing cache hit rates and minimizing memory bandwidth requirements.</p>\n<p>Component addition follows a <strong>append-or-recycle pattern</strong> that maintains density while enabling efficient insertion:</p>\n<ol>\n<li><strong>Entity Validation</strong>: Verify entity ID is valid and does not already possess this component type</li>\n<li><strong>Index Selection</strong>: Pop free index from recycling stack, or append to end if stack empty</li>\n<li><strong>Component Construction</strong>: Construct component object in-place at selected dense array location using provided arguments</li>\n<li><strong>Mapping Update</strong>: Insert entity-to-index mapping in sparse lookup table</li>\n<li><strong>Reverse Mapping</strong>: Store entity ID in parallel index-to-entity array for iteration support</li>\n<li><strong>Archetype Update</strong>: Notify archetype system that entity&#39;s component signature has changed</li>\n</ol>\n<p>Component removal requires <strong>swap-and-pop deletion</strong> to maintain array density without shifting elements:</p>\n<ol>\n<li><strong>Lookup Validation</strong>: Confirm entity possesses component via sparse lookup table</li>\n<li><strong>Index Retrieval</strong>: Extract dense array index for the component to be removed</li>\n<li><strong>Component Destruction</strong>: Call component destructor to clean up any owned resources</li>\n<li><strong>Swap Operation</strong>: Move last component in dense array to fill the gap left by removed component</li>\n<li><strong>Mapping Updates</strong>: Update both sparse and reverse mappings to reflect the swap operation</li>\n<li><strong>Index Recycling</strong>: Push freed index onto recycling stack for future component additions</li>\n<li><strong>Archetype Update</strong>: Notify archetype system of component signature change</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>AddComponent&lt;T&gt;</code></td>\n<td><code>Entity entity, Args... args</code></td>\n<td><code>T&amp;</code></td>\n<td>Constructs component in dense array with forwarded arguments</td>\n</tr>\n<tr>\n<td><code>RemoveComponent&lt;T&gt;</code></td>\n<td><code>Entity entity</code></td>\n<td><code>void</code></td>\n<td>Removes component using swap-and-pop deletion</td>\n</tr>\n<tr>\n<td><code>GetComponent&lt;T&gt;</code></td>\n<td><code>Entity entity</code></td>\n<td><code>T*</code></td>\n<td>Returns component pointer or nullptr via sparse lookup</td>\n</tr>\n<tr>\n<td><code>HasComponent&lt;T&gt;</code></td>\n<td><code>Entity entity</code></td>\n<td><code>bool</code></td>\n<td>Checks component existence via sparse lookup table</td>\n</tr>\n<tr>\n<td><code>GetEntity</code></td>\n<td><code>size_t index</code></td>\n<td><code>Entity</code></td>\n<td>Maps dense array index back to entity ID</td>\n</tr>\n</tbody></table>\n<p>The storage system supports <strong>efficient iteration patterns</strong> required by system processing. Systems typically iterate over dense component arrays using simple for loops, accessing both the component data and the associated entity ID through the parallel index-to-entity mapping. This iteration pattern achieves optimal cache performance because it accesses memory sequentially regardless of entity creation order.</p>\n<p>Here&#39;s a detailed walkthrough of component access patterns during system execution:</p>\n<ol>\n<li><strong>Query Initiation</strong>: System requests entities possessing specific component combination (e.g., Transform + RigidBody)</li>\n<li><strong>Archetype Selection</strong>: ECS identifies archetypes matching the component signature</li>\n<li><strong>Dense Array Access</strong>: System retrieves dense component arrays for iteration</li>\n<li><strong>Sequential Iteration</strong>: System loops through component arrays using simple index-based iteration</li>\n<li><strong>Entity Identification</strong>: System accesses parallel index-to-entity array to identify current entity</li>\n<li><strong>Component Processing</strong>: System applies logic to current component data, potentially modifying values</li>\n<li><strong>Cross-Component Access</strong>: System uses entity ID to access additional components via sparse lookup</li>\n<li><strong>Cache Optimization</strong>: CPU cache lines contain multiple components due to sequential access pattern</li>\n</ol>\n<p><strong>Archetype organization</strong> groups entities sharing identical component signatures to further optimize iteration performance. An archetype represents a specific combination of component types, such as &quot;Transform + Sprite + RigidBody&quot;. Entities within an archetype can be processed together without checking component existence, and their component data is stored in aligned arrays that maximize vectorization opportunities.</p>\n<table>\n<thead>\n<tr>\n<th>Archetype Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>componentSignature</code></td>\n<td><code>bitset&lt;MAX_COMPONENTS&gt;</code></td>\n<td>Bitmask indicating which component types this archetype contains</td>\n</tr>\n<tr>\n<td><code>entities</code></td>\n<td><code>vector&lt;Entity&gt;</code></td>\n<td>Entities belonging to this archetype for batch processing</td>\n</tr>\n<tr>\n<td><code>componentArrays</code></td>\n<td><code>array&lt;void*, MAX_COMPONENTS&gt;</code></td>\n<td>Pointers to dense component arrays for each component type</td>\n</tr>\n</tbody></table>\n<p>Archetype transitions occur when entities gain or lose components, requiring movement between archetype storage areas. This operation involves copying component data from source to destination archetypes and updating entity-to-archetype mappings. While archetype transitions have higher overhead than simple component modifications, they enable extremely efficient system iteration for entities that remain stable.</p>\n<blockquote>\n<p><strong>Performance Insight</strong>: The cache-friendly nature of dense component arrays can improve system iteration performance by 5-10x compared to traditional object-oriented approaches where game object data is scattered across heap allocations. Modern CPUs can process sequential arrays much more efficiently than pointer-chasing through object hierarchies.</p>\n</blockquote>\n<p><strong>Architecture Decision: Dense Array Component Storage</strong></p>\n<blockquote>\n<p><strong>Decision: Dense Array Component Storage with Archetype Organization</strong></p>\n<ul>\n<li><strong>Context</strong>: ECS systems must iterate over thousands of components per frame within a 16.67ms budget. Traditional object-oriented storage scatters component data across memory, causing cache misses and poor iteration performance.</li>\n<li><strong>Options Considered</strong>: Array-of-structs with component inheritance, hash map storage by entity ID, sparse component arrays with holes, dense arrays with sparse lookup</li>\n<li><strong>Decision</strong>: Dense arrays for component data with sparse lookup tables and archetype grouping</li>\n<li><strong>Rationale</strong>: Dense arrays maximize cache efficiency during system iteration, sparse lookup provides O(1) component access, and archetypes eliminate component existence checks during processing</li>\n<li><strong>Consequences</strong>: Requires complex bookkeeping for component addition/removal and archetype transitions, but enables high-performance iteration and vectorization opportunities</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Storage Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Cache Performance</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Object Hierarchy</td>\n<td>Familiar OOP model</td>\n<td>Scattered memory, virtual calls</td>\n<td>Poor (pointer chasing)</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Hash Map Storage</td>\n<td>Simple implementation</td>\n<td>Poor iteration locality</td>\n<td>Poor (random access)</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Sparse Arrays</td>\n<td>Direct entity indexing</td>\n<td>Memory waste, false sharing</td>\n<td>Fair (holes break locality)</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Dense Arrays</td>\n<td>Optimal cache usage</td>\n<td>Complex bookkeeping</td>\n<td>Excellent (sequential)</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"system-update-pipeline\">System Update Pipeline</h3>\n<p>The system update pipeline orchestrates the <strong>execution order and data dependencies</strong> between different game logic systems, ensuring that each frame processes entity updates in a deterministic sequence that respects inter-system dependencies while maximizing opportunities for parallel execution where safe.</p>\n<p>Our pipeline design follows a <strong>query-driven execution model</strong> where systems declare their component requirements upfront, and the ECS schedules system execution based on data access patterns and explicit dependency relationships. This approach enables both automatic parallelization of independent systems and deterministic ordering for systems with read-after-write dependencies.</p>\n<p>System registration involves <strong>compile-time dependency analysis</strong> where each system specifies its component access patterns (read-only, write-only, read-write) and explicit dependencies on other systems. The ECS uses this information to construct a dependency graph that determines execution order and identifies opportunities for parallel execution within each frame.</p>\n<table>\n<thead>\n<tr>\n<th>System Property</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>componentSignature</code></td>\n<td><code>bitset&lt;MAX_COMPONENTS&gt;</code></td>\n<td>Bitmask indicating required component types for system queries</td>\n</tr>\n<tr>\n<td><code>readComponents</code></td>\n<td><code>set&lt;ComponentType&gt;</code></td>\n<td>Component types this system reads but does not modify</td>\n</tr>\n<tr>\n<td><code>writeComponents</code></td>\n<td><code>set&lt;ComponentType&gt;</code></td>\n<td>Component types this system modifies during execution</td>\n</tr>\n<tr>\n<td><code>dependencies</code></td>\n<td><code>vector&lt;SystemType&gt;</code></td>\n<td>Other systems that must execute before this system</td>\n</tr>\n<tr>\n<td><code>updateFrequency</code></td>\n<td><code>float</code></td>\n<td>Target update rate in Hz (for systems that don&#39;t need 60fps)</td>\n</tr>\n</tbody></table>\n<p>The <strong>execution scheduling algorithm</strong> processes systems in topologically sorted order based on their dependency graph, grouping independent systems into parallel execution batches where data dependencies permit concurrent execution:</p>\n<ol>\n<li><strong>Dependency Graph Construction</strong>: Build directed graph where edges represent &quot;must execute before&quot; relationships</li>\n<li><strong>Topological Sort</strong>: Order systems to respect all dependency constraints while minimizing total execution phases</li>\n<li><strong>Parallel Batch Identification</strong>: Group systems with no data conflicts into concurrent execution batches</li>\n<li><strong>Resource Conflict Detection</strong>: Identify systems that write to shared component types and serialize their execution</li>\n<li><strong>Update Frequency Grouping</strong>: Schedule systems with different update rates (e.g., AI at 30Hz, rendering at 60Hz)</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RegisterSystem&lt;T&gt;</code></td>\n<td><code>Args... args</code></td>\n<td><code>void</code></td>\n<td>Adds system to execution pipeline with dependency analysis</td>\n</tr>\n<tr>\n<td><code>UpdateSystems</code></td>\n<td><code>float deltaTime</code></td>\n<td><code>void</code></td>\n<td>Executes all registered systems in dependency-aware order</td>\n</tr>\n<tr>\n<td><code>SetSystemDependency&lt;A, B&gt;</code></td>\n<td>None</td>\n<td><code>void</code></td>\n<td>Declares that system A must execute before system B</td>\n</tr>\n<tr>\n<td><code>GetSystemUpdateTime&lt;T&gt;</code></td>\n<td>None</td>\n<td><code>float</code></td>\n<td>Returns average execution time for performance monitoring</td>\n</tr>\n</tbody></table>\n<p>Query execution within each system follows a <strong>batch processing model</strong> that maximizes cache efficiency and enables vectorization opportunities. When a system executes, it queries for all entities possessing its required component combination, then processes them in large batches rather than individually.</p>\n<p>Here&#39;s the detailed system execution sequence for a typical frame update:</p>\n<ol>\n<li><strong>Frame Initialization</strong>: Calculate delta time and prepare system execution context</li>\n<li><strong>Dependency Resolution</strong>: Sort systems based on dependency graph and component access patterns</li>\n<li><strong>Parallel Batch Identification</strong>: Group independent systems for concurrent execution where safe</li>\n<li><strong>System Query Phase</strong>: Each system queries ECS for entities matching its component signature</li>\n<li><strong>Entity Set Retrieval</strong>: Return dense component arrays and entity lists for efficient iteration</li>\n<li><strong>Batch Processing</strong>: System iterates through component arrays using cache-friendly sequential access</li>\n<li><strong>Component Updates</strong>: System modifies component data in-place, maintaining memory layout</li>\n<li><strong>Cross-System Communication</strong>: Systems publish events or set shared state for subsequent systems</li>\n<li><strong>Dependency Synchronization</strong>: Wait for parallel systems to complete before dependent systems begin</li>\n<li><strong>Resource Cleanup</strong>: Handle any component destruction or archetype transitions requested during updates</li>\n</ol>\n<p><strong>Parallel execution safety</strong> relies on <strong>read-write access analysis</strong> to determine which systems can run concurrently without data races. Systems that only read shared component types can execute in parallel, while systems that write to shared types must be serialized to prevent undefined behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Access Pattern</th>\n<th>Parallel Safety</th>\n<th>Example Systems</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read-Only Different Components</td>\n<td>Safe</td>\n<td>Input processing + Audio playback</td>\n</tr>\n<tr>\n<td>Read-Only Same Components</td>\n<td>Safe</td>\n<td>Multiple rendering passes</td>\n</tr>\n<tr>\n<td>Write Different Components</td>\n<td>Safe</td>\n<td>Physics simulation + Animation</td>\n</tr>\n<tr>\n<td>Write Same Components</td>\n<td>Unsafe</td>\n<td>Transform updates + Physics updates</td>\n</tr>\n<tr>\n<td>Read-Write Dependency</td>\n<td>Unsafe</td>\n<td>Movement calculation → Collision detection</td>\n</tr>\n</tbody></table>\n<p>The system pipeline supports <strong>variable update frequencies</strong> for systems that don&#39;t require full 60fps processing. AI systems might update at 30Hz, networking at 20Hz, and physics at 120Hz, while rendering maintains the target frame rate. Each system maintains an accumulator that determines when it should execute based on elapsed time since its last update.</p>\n<p>Query optimization occurs through <strong>archetype-aware iteration</strong> where systems receive pre-filtered entity lists organized by archetype. Instead of checking component existence for each entity, systems iterate through archetype buckets where all entities are guaranteed to possess the required components, eliminating conditional branches in hot loops.</p>\n<blockquote>\n<p><strong>Performance Insight</strong>: Grouping systems by data access patterns and enabling parallel execution can improve frame processing performance by 2-4x on multi-core systems, particularly for CPU-intensive operations like AI, animation, and physics that don&#39;t require strict sequential ordering.</p>\n</blockquote>\n<p><strong>Architecture Decision: Query-Driven System Pipeline</strong></p>\n<blockquote>\n<p><strong>Decision: Query-Driven System Pipeline with Dependency-Aware Scheduling</strong></p>\n<ul>\n<li><strong>Context</strong>: Game systems often have complex interdependencies (e.g., physics must run before rendering, input must run before movement) while also having opportunities for parallelization (e.g., audio and rendering are independent)</li>\n<li><strong>Options Considered</strong>: Fixed sequential execution order, priority-based scheduling, full parallel execution with locks, dependency graph with batch parallelization</li>\n<li><strong>Decision</strong>: Dependency graph construction with topological sorting and parallel batch identification</li>\n<li><strong>Rationale</strong>: Enables deterministic execution order for dependent systems while maximizing parallel execution opportunities and maintaining cache-friendly iteration patterns</li>\n<li><strong>Consequences</strong>: Requires upfront dependency declaration and more complex scheduling logic, but provides both performance and correctness for complex system interactions</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Pipeline Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Parallelism</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fixed Sequential</td>\n<td>Simple, predictable</td>\n<td>No parallelism, inflexible</td>\n<td>None</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Priority Scheduling</td>\n<td>Flexible ordering</td>\n<td>Non-deterministic, race conditions</td>\n<td>Limited</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Full Parallel + Locks</td>\n<td>Maximum concurrency</td>\n<td>Complex synchronization, deadlocks</td>\n<td>Maximum</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Dependency Graph</td>\n<td>Deterministic + parallel</td>\n<td>Complex scheduling logic</td>\n<td>Optimal</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"ecs-architecture-decisions\">ECS Architecture Decisions</h3>\n<p>The design of our ECS architecture required several <strong>fundamental architectural choices</strong> that significantly impact performance, usability, and maintainability. Each decision represents a trade-off between competing concerns, and understanding these trade-offs is crucial for both implementing the system correctly and extending it in the future.</p>\n<p><strong>Storage Layout: Struct-of-Arrays vs Array-of-Structs</strong></p>\n<blockquote>\n<p><strong>Decision: Struct-of-Arrays Component Storage</strong></p>\n<ul>\n<li><strong>Context</strong>: Component data can be organized either as arrays of complete component objects (AoS) or as separate arrays for each component field (SoA). This choice affects cache performance, vectorization opportunities, and implementation complexity.</li>\n<li><strong>Options Considered</strong>: Array-of-Structs for object cohesion, Struct-of-Arrays for cache optimization, hybrid approach with component splitting, adaptive layout based on access patterns</li>\n<li><strong>Decision</strong>: Struct-of-Arrays organization with separate dense arrays for each component type</li>\n<li><strong>Rationale</strong>: SoA maximizes cache line utilization when systems access only subset of component fields, enables SIMD vectorization for batch operations, and aligns with data-oriented design principles for modern CPU architectures</li>\n<li><strong>Consequences</strong>: Requires more complex iteration patterns for systems accessing multiple component types, but provides significant performance advantages for systems processing large entity counts</li>\n</ul>\n</blockquote>\n<p>The struct-of-arrays approach stores component data in separate arrays organized by field type rather than as complete objects. For example, instead of an array of <code>Transform</code> objects containing position, rotation, and scale fields, we maintain separate arrays for positions, rotations, and scales. This organization optimizes for systems that process only specific fields, avoiding cache pollution from unused data.</p>\n<table>\n<thead>\n<tr>\n<th>Storage Approach</th>\n<th>Memory Layout</th>\n<th>Cache Efficiency</th>\n<th>Vectorization</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Array-of-Structs</td>\n<td><code>[pos,rot,scale][pos,rot,scale]...</code></td>\n<td>Poor (unused fields)</td>\n<td>Limited</td>\n<td>Simple</td>\n</tr>\n<tr>\n<td>Struct-of-Arrays</td>\n<td><code>[pos,pos,pos...][rot,rot,rot...]</code></td>\n<td>Excellent (packed fields)</td>\n<td>Optimal</td>\n<td>Complex</td>\n</tr>\n<tr>\n<td>Hybrid Approach</td>\n<td>Mixed based on usage patterns</td>\n<td>Variable</td>\n<td>Good</td>\n<td>Very Complex</td>\n</tr>\n</tbody></table>\n<p><strong>Archetype vs Signature-Based Organization</strong></p>\n<blockquote>\n<p><strong>Decision: Archetype-Based Entity Organization</strong></p>\n<ul>\n<li><strong>Context</strong>: Entities can be organized either by checking component signatures during iteration (signature-based) or by grouping entities with identical component sets into archetypes. This affects iteration performance and memory usage patterns.</li>\n<li><strong>Options Considered</strong>: Signature-based with runtime component checks, archetype grouping with pre-sorted entities, sparse tables with component bitmasks, hybrid approach with common archetypes</li>\n<li><strong>Decision</strong>: Full archetype organization where entities are grouped by identical component signatures</li>\n<li><strong>Rationale</strong>: Archetype organization eliminates conditional branches during system iteration, enables optimal vectorization by guaranteeing component presence, and provides better cache locality for common entity patterns</li>\n<li><strong>Consequences</strong>: Requires entity migration between archetypes when components are added/removed, increasing complexity for dynamic component modification</li>\n</ul>\n</blockquote>\n<p>Archetype organization groups entities with identical component signatures into specialized storage areas. Each archetype maintains aligned arrays for its specific component combination, enabling systems to iterate through guaranteed-compatible entities without runtime component existence checks.</p>\n<table>\n<thead>\n<tr>\n<th>Organization Method</th>\n<th>Iteration Speed</th>\n<th>Component Changes</th>\n<th>Memory Layout</th>\n<th>Branch Prediction</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Signature-Based</td>\n<td>Slow (checks per entity)</td>\n<td>Fast (in-place)</td>\n<td>Flexible</td>\n<td>Poor (unpredictable)</td>\n</tr>\n<tr>\n<td>Archetype-Based</td>\n<td>Fast (guaranteed components)</td>\n<td>Slow (migration)</td>\n<td>Optimal</td>\n<td>Excellent (no branches)</td>\n</tr>\n<tr>\n<td>Sparse Tables</td>\n<td>Medium (bitmap checks)</td>\n<td>Medium</td>\n<td>Good</td>\n<td>Fair</td>\n</tr>\n</tbody></table>\n<p><strong>Component Access: Handle-Based vs Direct Pointers</strong></p>\n<blockquote>\n<p><strong>Decision: Direct Pointer Component Access with Generation Validation</strong></p>\n<ul>\n<li><strong>Context</strong>: Component access can use either direct pointers to component data or handle-based indirection for safety. This affects access performance and memory safety in the presence of component reallocation.</li>\n<li><strong>Options Considered</strong>: Raw pointers with manual validation, handle-based access with indirection, smart pointers with reference counting, generation-validated direct pointers</li>\n<li><strong>Decision</strong>: Direct pointers with entity generation validation for safety</li>\n<li><strong>Rationale</strong>: Direct pointer access provides optimal performance for tight system loops while generation validation catches most stale reference bugs without the overhead of full handle indirection</li>\n<li><strong>Consequences</strong>: Requires careful management of pointer invalidation during component array reallocation and archetype migrations</li>\n</ul>\n</blockquote>\n<p>The component access strategy balances performance with safety by using direct pointers for component data access while relying on entity generation counters to detect stale references. This approach avoids the indirection overhead of handle-based systems while providing reasonable protection against common reference errors.</p>\n<table>\n<thead>\n<tr>\n<th>Access Method</th>\n<th>Performance</th>\n<th>Safety</th>\n<th>Implementation</th>\n<th>Reallocation Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Raw Pointers</td>\n<td>Fastest</td>\n<td>None</td>\n<td>Simple</td>\n<td>Manual invalidation</td>\n</tr>\n<tr>\n<td>Handle Indirection</td>\n<td>Slower</td>\n<td>High</td>\n<td>Complex</td>\n<td>Automatic</td>\n</tr>\n<tr>\n<td>Smart Pointers</td>\n<td>Slowest</td>\n<td>High</td>\n<td>Medium</td>\n<td>Reference counting</td>\n</tr>\n<tr>\n<td>Generation Validated</td>\n<td>Fast</td>\n<td>Good</td>\n<td>Medium</td>\n<td>Explicit validation</td>\n</tr>\n</tbody></table>\n<p><strong>Query Performance: Cached vs Dynamic Component Queries</strong></p>\n<blockquote>\n<p><strong>Decision: Cached Component Queries with Invalidation Tracking</strong></p>\n<ul>\n<li><strong>Context</strong>: System component queries can be evaluated dynamically each frame or cached between frames with invalidation. This affects query performance and memory usage for systems with stable entity sets.</li>\n<li><strong>Options Considered</strong>: Dynamic queries each frame, cached queries with manual invalidation, cached queries with automatic tracking, hybrid caching for stable vs dynamic systems</li>\n<li><strong>Decision</strong>: Cached component queries with automatic invalidation tracking based on archetype changes</li>\n<li><strong>Rationale</strong>: Most systems process stable entity sets that change infrequently, making cached queries significantly faster than repeated dynamic evaluation, while automatic invalidation ensures correctness</li>\n<li><strong>Consequences</strong>: Requires change tracking infrastructure and increases memory usage for query results, but provides substantial performance improvements for systems with large entity sets</li>\n</ul>\n</blockquote>\n<p>Cached queries store the results of component lookups between frames, avoiding repeated traversal of archetype structures for systems that process stable entity populations. The caching system tracks archetype modifications and automatically invalidates affected query results.</p>\n<table>\n<thead>\n<tr>\n<th>Query Strategy</th>\n<th>Frame Performance</th>\n<th>Memory Usage</th>\n<th>Complexity</th>\n<th>Dynamic Entities</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dynamic Each Frame</td>\n<td>Consistent slow</td>\n<td>Minimal</td>\n<td>Simple</td>\n<td>Handles perfectly</td>\n</tr>\n<tr>\n<td>Manual Cache</td>\n<td>Fast when valid</td>\n<td>High</td>\n<td>Complex</td>\n<td>Error-prone</td>\n</tr>\n<tr>\n<td>Automatic Cache</td>\n<td>Fast most frames</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Handles correctly</td>\n</tr>\n<tr>\n<td>Hybrid Caching</td>\n<td>Optimal</td>\n<td>Variable</td>\n<td>High</td>\n<td>Best of both</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Understanding common implementation mistakes helps avoid subtle bugs that can be difficult to diagnose in a complex ECS system. These pitfalls often stem from the conceptual differences between ECS and traditional object-oriented patterns.</p>\n<p>⚠️ <strong>Pitfall: Component Iterator Invalidation During Iteration</strong></p>\n<p>A frequent mistake occurs when systems add or remove components while iterating through component arrays, causing iterator invalidation and unpredictable behavior. This happens because component addition may trigger array reallocation, invalidating existing pointers, while component removal uses swap-and-pop deletion that changes array indices.</p>\n<p>The problem manifests when a system processes entities and decides to add or remove components based on current state. For example, a collision system detecting overlap might try to add a <code>Collision</code> component to entities during iteration, or a health system might remove entities that reach zero health.</p>\n<p><strong>How to fix</strong>: Collect modification requests during iteration and apply them after iteration completes. Use separate arrays to track entities requiring component changes, then process these requests in a second pass once iteration finishes.</p>\n<p>⚠️ <strong>Pitfall: Cross-System Data Dependencies Without Ordering</strong></p>\n<p>Systems that read data written by other systems can produce inconsistent results if execution order isn&#39;t properly managed. This commonly occurs with transform hierarchies where child transforms depend on parent updates, or physics systems where collision detection depends on movement calculations.</p>\n<p>The bug appears as frame-to-frame inconsistency where results depend on arbitrary system execution order. Child objects might lag one frame behind parent movement, or collision detection might use stale position data from the previous frame.</p>\n<p><strong>How to fix</strong>: Explicitly declare system dependencies during registration and ensure the execution pipeline respects these constraints. Use dependency injection or event systems for loose coupling between systems that don&#39;t require strict ordering.</p>\n<p>⚠️ <strong>Pitfall: Memory Fragmentation from Frequent Archetype Changes</strong></p>\n<p>Dynamic component addition and removal can cause excessive memory allocations and fragmentation if entities frequently change archetypes. This particularly affects games with state-based entities (e.g., units that gain/lose abilities) or temporary effect systems.</p>\n<p>Performance degrades over time as memory becomes fragmented and archetype arrays require frequent reallocation. The frame time budget gets consumed by memory management rather than game logic.</p>\n<p><strong>How to fix</strong>: Design component hierarchies to minimize archetype transitions. Use component data fields to represent state changes rather than adding/removing entire components. Consider pooling strategies for temporary components or effects.</p>\n<p>⚠️ <strong>Pitfall: Component Access After Entity Destruction</strong></p>\n<p>Systems holding entity references from previous frames may attempt component access after entity destruction, leading to stale pointer dereference or incorrect component data retrieval from recycled entity slots.</p>\n<p>This typically occurs when one system destroys an entity while another system maintains a cached reference list. The destroying system recycles the entity ID, but cached references remain valid-looking until they&#39;re used.</p>\n<p><strong>How to fix</strong>: Use generation-based entity validation before component access. Implement automatic reference invalidation when entities are destroyed, or design systems to re-query entity lists each frame rather than caching references across frames.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The ECS implementation requires careful attention to memory layout, data structures, and algorithm efficiency to achieve the performance targets necessary for real-time game processing. The following code provides the foundation for a cache-friendly, high-performance entity component system.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Storage</td>\n<td><code>std::vector</code> with free list</td>\n<td>Custom memory pools with generation arrays</td>\n</tr>\n<tr>\n<td>Component Arrays</td>\n<td><code>std::vector&lt;T&gt;</code> per component type</td>\n<td>Template metaprogramming with type erasure</td>\n</tr>\n<tr>\n<td>Archetype Management</td>\n<td>Manual type registration</td>\n<td>Compile-time signature generation</td>\n</tr>\n<tr>\n<td>System Scheduling</td>\n<td>Linear execution order</td>\n<td>Task-based parallelism with work stealing</td>\n</tr>\n<tr>\n<td>Memory Allocation</td>\n<td>Standard allocators</td>\n<td>Custom block allocators for component data</td>\n</tr>\n</tbody></table>\n<p><strong>File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>src/ecs/\n  entity.h                   ← Entity ID structure and utilities\n  entity.cpp\n  component_array.h          ← Template component storage\n  component_array.inl        ← Template implementation\n  ecs_world.h               ← Main ECS coordinator\n  ecs_world.cpp\n  system_base.h             ← System interface and registration\n  system_base.cpp\n  archetype.h               ← Archetype management\n  archetype.cpp\ntests/ecs/\n  entity_tests.cpp          ← Entity lifecycle and validation\n  component_storage_tests.cpp ← Component CRUD operations\n  system_pipeline_tests.cpp  ← System execution and dependencies</code></pre></div>\n\n<p><strong>Entity Infrastructure Code</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// entity.h - Complete entity ID management system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Entity ID bit layout: [Generation:10][Index:22]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> INDEX_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 22</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> GENERATION_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> INDEX_MASK </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> INDEX_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> GENERATION_MASK </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> GENERATION_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> MAX_ENTITIES </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> INDEX_BITS;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">m_id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> id</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">m_id</span><span style=\"color:#E1E4E8\">(id) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetIndex</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> INDEX_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetGeneration</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (m_id </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> INDEX_BITS) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> GENERATION_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.m_id; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.m_id; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> Entity NULL_ENTITY{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Entity manager handles ID allocation and recycling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> m_generations;</span><span style=\"color:#6A737D\">  // Generation per index slot</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> m_freeIndices;</span><span style=\"color:#6A737D\">   // Recycled indices</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_nextIndex;</span><span style=\"color:#6A737D\">                 // Next new index to allocate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityManager</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">m_nextIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {}</span><span style=\"color:#6A737D\">  // Start at 1, reserve 0 for NULL_ENTITY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> CreateEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> DestroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Hash function for Entity to use in unordered containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> hash</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">()</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> hash</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">>()(entity.</span><span style=\"color:#B392F0\">GetID</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Component Storage Infrastructure Code</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// component_array.h - Dense component storage template</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cassert></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentArray</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_components;</span><span style=\"color:#6A737D\">                    // Dense component data</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity, </span><span style=\"color:#F97583\">size_t></span><span style=\"color:#E1E4E8\"> m_entityToIndex;</span><span style=\"color:#6A737D\">  // Sparse entity lookup</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_indexToEntity;</span><span style=\"color:#6A737D\">           // Dense index to entity mapping</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> m_freeIndices;</span><span style=\"color:#6A737D\">             // Recycled indices for reuse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add component with perfect forwarding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> AddComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove component using swap-and-pop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get component pointer (nullptr if not found)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check component existence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> HasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get entity for dense array index</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> GetEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iteration support</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> Size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> m_freeIndices.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> Data</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> Data</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_components.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear all components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Type-erased interface for component storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IComponentArray</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~IComponentArray</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> RemoveEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Clear</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Type-erased wrapper for ComponentArray&#x3C;T></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentArrayWrapper</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> IComponentArray</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentArray</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_array;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentArray</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> GetArray</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_array; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (m_array.</span><span style=\"color:#B392F0\">HasComponent</span><span style=\"color:#E1E4E8\">(entity)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_array.</span><span style=\"color:#B392F0\">RemoveComponent</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Clear</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_array.</span><span style=\"color:#B392F0\">Clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Core ECS Logic Skeleton</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ecs_world.h - Main ECS coordinator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component_array.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"system_base.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ECSWorld</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityManager m_entityManager;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::type_index, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">IComponentArray</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_componentArrays;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">SystemBase</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_systems;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentArray</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetComponentArray</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity management</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> CreateEntity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Call entity manager to create new entity ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return the created entity for component attachment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> DestroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate entity exists and is valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Remove entity from all component arrays</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Call entity manager to recycle entity ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Notify systems that entity was destroyed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> AddComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get or create component array for type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Verify entity doesn't already have this component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Add component with perfect forwarding of arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Update entity's archetype signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return reference to new component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get component array for type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Verify entity has this component type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Remove component from storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Update entity's archetype signature</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get component array for type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return component pointer or nullptr</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use GetComponentArray&#x3C;T>() helper method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> HasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Find component array for type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if entity exists in that array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return boolean result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RegisterSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create system instance with forwarded arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Add to systems vector for execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Allow system to register component dependencies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> UpdateSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Iterate through all registered systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Call Update method on each system with delta time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Handle any system-requested entity/component changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Apply deferred operations after all systems complete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// System base class for type erasure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemBase</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~SystemBase</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> OnEntityDestroyed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper template for implementing systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> Derived</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> SystemBase</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        static_cast&#x3C;</span><span style=\"color:#E1E4E8\">Derived</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">)-></span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(world, deltaTime);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Example System Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example: MovementSystem that updates transform positions based on velocity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MovementSystem</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">MovementSystem</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Query for entities with both Transform and RigidBody components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Iterate through component arrays in parallel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Apply velocity to position: position += velocity * deltaTime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Apply acceleration to velocity: velocity += acceleration * deltaTime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Handle any collision or boundary constraints</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Implementation hint:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Use dense array iteration for performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Access components through entity indices</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Modify transform positions in-place</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint</strong></p>\n<p>After implementing the ECS foundation:</p>\n<ol>\n<li><strong>Entity Creation Test</strong>: Create 1000 entities, verify unique IDs and proper recycling</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Expected: All entity IDs unique, generations increment on recycling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   auto</span><span style=\"color:#E1E4E8\"> entities </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       entities.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(world.</span><span style=\"color:#B392F0\">CreateEntity</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   // Verify no duplicate IDs</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Component Storage Test</strong>: Add/remove components and verify dense array maintenance</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Expected: Components stored contiguously, swap-and-pop on removal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   auto</span><span style=\"color:#E1E4E8\"> entity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.</span><span style=\"color:#B392F0\">CreateEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   auto&#x26;</span><span style=\"color:#E1E4E8\"> transform </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.AddComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Transform</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity, Vector3{</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   assert</span><span style=\"color:#E1E4E8\">(world.HasComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Transform</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   world.RemoveComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Transform</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">world.HasComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Transform</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity));</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>System Execution Test</strong>: Register systems and verify correct update order</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Expected: Systems execute in registration order, receive deltaTime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   world.RegisterSystem</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">MovementSystem</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   world.RegisterSystem</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">RenderSystem</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   world.</span><span style=\"color:#B392F0\">UpdateSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0.016</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 60fps frame time</span></span></code></pre></div>\n\n<p><strong>Performance Debugging</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Slow system iteration</td>\n<td>Non-contiguous component data</td>\n<td>Profile cache misses</td>\n<td>Use dense arrays, avoid pointer chasing</td>\n</tr>\n<tr>\n<td>Memory leaks</td>\n<td>Components not destroyed</td>\n<td>Check entity destruction</td>\n<td>Ensure all component arrays cleaned up</td>\n</tr>\n<tr>\n<td>Stale entity access</td>\n<td>Generation mismatch</td>\n<td>Add entity validation</td>\n<td>Check generations before component access</td>\n</tr>\n<tr>\n<td>Frame time spikes</td>\n<td>Archetype migrations</td>\n<td>Profile allocation calls</td>\n<td>Minimize dynamic component changes</td>\n</tr>\n</tbody></table>\n<h2 id=\"physics-and-collision-system\">Physics and Collision System</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Physics &amp; Collision) — 2D rigid body physics with collision detection, spatial partitioning, and deterministic simulation</p>\n</blockquote>\n<p>The physics system in a game engine is like the <strong>laws of nature</strong> that govern how objects move, collide, and respond to forces in your virtual world. Just as real physics determines whether a billiard ball bounces off the table&#39;s edge or sinks into a pocket, your game&#39;s physics system calculates trajectories, detects collisions, and applies realistic responses that make virtual objects behave convincingly.</p>\n<h3 id=\"mental-model-billiard-table-simulation\">Mental Model: Billiard Table Simulation</h3>\n<p>Understanding physics simulation becomes intuitive when you think of it as an automated billiard table that plays out thousands of scenarios per second. In this mental model:</p>\n<p><strong>The Table Surface</strong> represents your game world&#39;s coordinate space. Objects move across this surface according to velocity and acceleration, just like billiard balls rolling with initial momentum and gradually slowing due to friction.</p>\n<p><strong>The Cue Stick</strong> represents forces applied to objects. When you apply a force to a <code>RigidBody</code>, you&#39;re essentially giving it a &quot;cue stick hit&quot; that changes its velocity. The magnitude and direction of the force determine how dramatically the object&#39;s motion changes.</p>\n<p><strong>Predicting the Ball&#39;s Path</strong> is what physics integration does every frame. The system calculates where each object will be in the next instant based on its current velocity, just like an experienced player visualizing where the cue ball will travel.</p>\n<p><strong>The Moment of Contact</strong> represents collision detection. The system must predict exactly when and where two objects will touch, similar to calculating the precise moment two billiard balls will collide based on their trajectories.</p>\n<p><strong>The Bounce and Spin</strong> after impact represents collision response. When two objects collide, the physics system calculates how they should react — do they bounce apart, stick together, or transfer momentum? This is like calculating how billiard balls should behave after they strike each other.</p>\n<p><strong>Keeping Perfect Time</strong> is why deterministic simulation matters. In a real billiard game, the laws of physics are consistent — the same shot will always produce the same result. Your physics system must maintain this consistency by using fixed time steps, ensuring that replaying the same sequence of inputs always produces identical outcomes.</p>\n<p>This billiard table metaphor helps explain why physics systems need spatial partitioning (you only check collisions between balls that could possibly hit each other), why fixed timesteps matter (consistent &quot;frame rate&quot; for physics calculations), and why collision response is complex (different materials and impact angles produce different bounce behaviors).</p>\n<h3 id=\"collision-detection-pipeline\">Collision Detection Pipeline</h3>\n<p>The collision detection pipeline operates like a <strong>two-stage security system</strong> at an airport. The first stage (broad phase) quickly identifies potential threats using simple, fast checks. The second stage (narrow phase) performs detailed examination only on flagged items. This approach prevents the system from wasting computational resources on impossible collisions while ensuring accuracy for objects that might actually intersect.</p>\n<h4 id=\"broad-phase-spatial-partitioning\">Broad Phase Spatial Partitioning</h4>\n<p>The broad phase uses <strong>spatial partitioning</strong> to dramatically reduce the number of collision checks from O(n²) to approximately O(n log n) or better. Without spatial partitioning, a world with 1000 objects would require 499,500 collision checks per frame. With proper partitioning, this typically reduces to a few thousand checks.</p>\n<p>The system divides the game world into a grid or hierarchical structure where each cell contains references to objects whose bounding boxes overlap that region. When an object moves, the system updates which cells contain that object. During collision detection, each object only tests against other objects in the same cells.</p>\n<table>\n<thead>\n<tr>\n<th>Spatial Structure</th>\n<th>Cell Update Cost</th>\n<th>Query Cost</th>\n<th>Memory Usage</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Uniform Grid</td>\n<td>O(1)</td>\n<td>O(1) average</td>\n<td>High (sparse areas waste space)</td>\n<td>Evenly distributed objects</td>\n</tr>\n<tr>\n<td>Quadtree</td>\n<td>O(log n)</td>\n<td>O(log n)</td>\n<td>Low (adaptive subdivision)</td>\n<td>Clustered objects</td>\n</tr>\n<tr>\n<td>Hash Grid</td>\n<td>O(1)</td>\n<td>O(1) average</td>\n<td>Medium (hash collisions possible)</td>\n<td>Mixed distributions</td>\n</tr>\n</tbody></table>\n<p>The broad phase maintains a list of <code>CollisionPair</code> candidates that represents potentially colliding entities. This list gets regenerated each frame based on the current spatial partitioning state.</p>\n<p><strong>Broad Phase Algorithm:</strong></p>\n<ol>\n<li>Clear the previous frame&#39;s collision pair list to start fresh</li>\n<li>For each active entity with a collision component, update its spatial grid position based on its current bounding box</li>\n<li>For each grid cell that contains multiple entities, generate collision pairs between all entities in that cell</li>\n<li>For entities whose bounding boxes span multiple cells, check against entities in all overlapping cells to avoid missing collisions</li>\n<li>Apply additional broad phase filtering (such as collision layer masks) to eliminate pairs that should never collide</li>\n<li>Sort the resulting collision pairs by entity ID for consistent processing order and potential cache benefits</li>\n<li>Pass the filtered collision pair list to the narrow phase for precise geometric testing</li>\n</ol>\n<h4 id=\"narrow-phase-geometric-testing\">Narrow Phase Geometric Testing</h4>\n<p>The narrow phase performs precise geometric intersection tests on collision pairs that survived the broad phase. This stage determines not just whether objects are colliding, but also calculates the exact contact points, penetration depth, and collision normals needed for response.</p>\n<p>For 2D games, the narrow phase typically handles several collision shape combinations:</p>\n<table>\n<thead>\n<tr>\n<th>Shape A</th>\n<th>Shape B</th>\n<th>Test Method</th>\n<th>Complexity</th>\n<th>Contact Info</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>AABB</code></td>\n<td><code>AABB</code></td>\n<td>Interval overlap test</td>\n<td>O(1)</td>\n<td>Contact normal, penetration depth</td>\n</tr>\n<tr>\n<td><code>Circle</code></td>\n<td><code>Circle</code></td>\n<td>Distance comparison</td>\n<td>O(1)</td>\n<td>Contact point, penetration depth</td>\n</tr>\n<tr>\n<td><code>AABB</code></td>\n<td><code>Circle</code></td>\n<td>Closest point on box</td>\n<td>O(1)</td>\n<td>Contact point, normal</td>\n</tr>\n<tr>\n<td><code>Circle</code></td>\n<td><code>AABB</code></td>\n<td>Distance to closest box edge</td>\n<td>O(1)</td>\n<td>Contact point, normal</td>\n</tr>\n</tbody></table>\n<p>The narrow phase populates detailed <code>CollisionPair</code> structures that contain all information needed for collision response:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>entityA</td>\n<td><code>Entity</code></td>\n<td>First colliding entity ID</td>\n</tr>\n<tr>\n<td>entityB</td>\n<td><code>Entity</code></td>\n<td>Second colliding entity ID</td>\n</tr>\n<tr>\n<td>contactPoint</td>\n<td><code>Vector2</code></td>\n<td>World position where collision occurred</td>\n</tr>\n<tr>\n<td>normal</td>\n<td><code>Vector2</code></td>\n<td>Unit vector pointing from A toward B at contact</td>\n</tr>\n<tr>\n<td>penetration</td>\n<td><code>float</code></td>\n<td>How far the objects have overlapped</td>\n</tr>\n<tr>\n<td>relativeVelocity</td>\n<td><code>Vector2</code></td>\n<td>Velocity of A relative to B at contact point</td>\n</tr>\n<tr>\n<td>restitution</td>\n<td><code>float</code></td>\n<td>Combined bounciness factor (0=stick, 1=perfect bounce)</td>\n</tr>\n<tr>\n<td>friction</td>\n<td><code>float</code></td>\n<td>Combined friction coefficient for tangential forces</td>\n</tr>\n</tbody></table>\n<p><strong>Narrow Phase Algorithm:</strong></p>\n<ol>\n<li>Iterate through each collision pair from the broad phase in consistent order</li>\n<li>Retrieve the collision shape components for both entities (AABB, Circle, etc.)</li>\n<li>Apply the appropriate geometric intersection test based on the shape combination</li>\n<li>If no intersection exists, skip this pair and continue to the next</li>\n<li>Calculate the contact point as the closest point between the two shapes</li>\n<li>Compute the collision normal as the unit vector pointing from the first shape toward the second</li>\n<li>Determine penetration depth as the minimum distance needed to separate the objects</li>\n<li>Store all collision information in a <code>CollisionPair</code> structure for the response phase</li>\n<li>Add the completed collision pair to the active collisions list for this frame</li>\n</ol>\n<h4 id=\"collision-detection-data-structures\">Collision Detection Data Structures</h4>\n<p>The collision detection system uses several key data structures to efficiently organize and process collision information:</p>\n<p><strong>AABB Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>min</td>\n<td><code>Vector2</code></td>\n<td>Bottom-left corner of bounding box</td>\n</tr>\n<tr>\n<td>max</td>\n<td><code>Vector2</code></td>\n<td>Top-right corner of bounding box</td>\n</tr>\n<tr>\n<td>center</td>\n<td><code>Vector2</code></td>\n<td>Computed center point (min + max) / 2</td>\n</tr>\n<tr>\n<td>extents</td>\n<td><code>Vector2</code></td>\n<td>Half-width and half-height (max - min) / 2</td>\n</tr>\n</tbody></table>\n<p><strong>Circle Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>center</td>\n<td><code>Vector2</code></td>\n<td>World position of circle center</td>\n</tr>\n<tr>\n<td>radius</td>\n<td><code>float</code></td>\n<td>Collision radius in world units</td>\n</tr>\n</tbody></table>\n<p><strong>CollisionPair Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>entityA</td>\n<td><code>Entity</code></td>\n<td>First entity in collision</td>\n</tr>\n<tr>\n<td>entityB</td>\n<td><code>Entity</code></td>\n<td>Second entity in collision</td>\n</tr>\n<tr>\n<td>contactPoint</td>\n<td><code>Vector2</code></td>\n<td>World position of contact</td>\n</tr>\n<tr>\n<td>normal</td>\n<td><code>Vector2</code></td>\n<td>Collision normal (A toward B)</td>\n</tr>\n<tr>\n<td>penetration</td>\n<td><code>float</code></td>\n<td>Overlap distance</td>\n</tr>\n<tr>\n<td>restitution</td>\n<td><code>float</code></td>\n<td>Bounce factor (0-1)</td>\n</tr>\n<tr>\n<td>friction</td>\n<td><code>float</code></td>\n<td>Surface friction coefficient</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fcollision-detection.svg\" alt=\"Collision Detection Pipeline\"></p>\n<h3 id=\"physics-integration-and-timestep\">Physics Integration and Timestep</h3>\n<p>Physics integration is like the <strong>metronome</strong> that keeps your virtual world&#39;s temporal rhythm consistent and predictable. Just as a metronome ensures musicians play at the same tempo regardless of their individual interpretations, fixed timestep integration ensures your physics simulation produces identical results regardless of frame rate variations or performance fluctuations.</p>\n<h4 id=\"fixed-timestep-architecture\">Fixed Timestep Architecture</h4>\n<p>The physics system uses a <strong>fixed timestep accumulator</strong> pattern that decouples physics simulation from rendering frame rate. This approach accumulates real elapsed time until enough has passed to warrant one or more physics steps, then processes physics in consistent time increments.</p>\n<p>The accumulator pattern works by maintaining a time debt that represents how much simulation time needs to be processed. Each frame, real elapsed time gets added to this debt. The system then &quot;pays off&quot; the debt by running fixed-timestep physics updates until the remaining debt is less than one timestep.</p>\n<p><strong>Fixed Timestep Algorithm:</strong></p>\n<ol>\n<li>Measure the actual elapsed time since the last frame using high-precision timing</li>\n<li>Add the elapsed time to the physics time accumulator (capped to prevent spiral of death)</li>\n<li>While the accumulator contains at least one full physics timestep worth of time:\na. Execute one complete physics update using the fixed timestep duration\nb. Subtract one timestep&#39;s worth of time from the accumulator\nc. Increment the physics step counter for debugging and profiling</li>\n<li>Calculate an interpolation factor (accumulator / timestep) for smooth rendering between physics steps</li>\n<li>Store the interpolation factor for use during rendering to smooth object positions</li>\n</ol>\n<p>This approach ensures that physics always runs at exactly the same rate (typically 60Hz or 120Hz), regardless of whether rendering runs at 30fps, 60fps, 144fps, or varies unpredictably.</p>\n<p><strong>Physics Timestep Constants:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Constant</th>\n<th>Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PHYSICS_TIMESTEP</code></td>\n<td>1.0f/60.0f (16.67ms)</td>\n<td>Fixed time increment for physics</td>\n</tr>\n<tr>\n<td><code>MAX_TIMESTEP</code></td>\n<td>1.0f/20.0f (50ms)</td>\n<td>Maximum accumulated time per frame</td>\n</tr>\n<tr>\n<td><code>ACCUMULATOR_THRESHOLD</code></td>\n<td><code>PHYSICS_TIMESTEP</code></td>\n<td>Minimum time needed for physics step</td>\n</tr>\n</tbody></table>\n<h4 id=\"velocity-and-position-integration\">Velocity and Position Integration</h4>\n<p>The physics system uses <strong>semi-implicit Euler integration</strong> (also called symplectic Euler) which provides better stability than explicit Euler integration while remaining computationally simple. This integration method updates velocity first, then uses the new velocity to update position, creating a slight coupling that improves energy conservation.</p>\n<p><strong>Semi-Implicit Euler Integration Algorithm:</strong></p>\n<ol>\n<li>Calculate the total acceleration for this timestep by summing all forces acting on the object and dividing by mass</li>\n<li>Apply drag/damping to the current velocity: <code>velocity *= (1.0f - drag * timestep)</code></li>\n<li>Update velocity using acceleration: <code>velocity += acceleration * timestep</code></li>\n<li>Update position using the newly calculated velocity: <code>position += velocity * timestep</code></li>\n<li>Clear accumulated forces for the next timestep to prevent double-application</li>\n<li>Update the object&#39;s transform component with the new position for rendering</li>\n</ol>\n<p>This integration approach maintains better energy conservation than explicit Euler (which tends to add energy to the system) and avoids the computational complexity of higher-order methods like Runge-Kutta.</p>\n<p><strong>RigidBody Physics Integration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Operation</th>\n<th>Formula</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Apply drag</td>\n<td><code>velocity *= (1 - drag * dt)</code></td>\n<td>Energy dissipation</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Update velocity</td>\n<td><code>velocity += acceleration * dt</code></td>\n<td>Force integration</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Update position</td>\n<td><code>position += velocity * dt</code></td>\n<td>Motion integration</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Clear forces</td>\n<td><code>acceleration = Vector2::Zero()</code></td>\n<td>Reset for next frame</td>\n</tr>\n</tbody></table>\n<h4 id=\"deterministic-simulation-requirements\">Deterministic Simulation Requirements</h4>\n<p>Deterministic physics simulation means that identical inputs always produce identical outputs, which is crucial for networked games, replay systems, and debugging. Achieving determinism requires careful attention to floating-point precision, operation ordering, and algorithmic consistency.</p>\n<p>The physics system maintains determinism through several key practices:</p>\n<p><strong>Consistent Operation Ordering:</strong> All physics operations process entities in the same order every frame, typically sorted by entity ID. This prevents different execution orders from causing floating-point precision differences to accumulate differently.</p>\n<p><strong>Fixed-Point Arithmetic Considerations:</strong> While the implementation uses floating-point arithmetic for simplicity, production engines often use fixed-point math to guarantee bitwise-identical results across different processors and compiler optimizations.</p>\n<p><strong>Collision Processing Order:</strong> Collision pairs are sorted by entity ID before processing to ensure that simultaneous collisions always resolve in the same sequence.</p>\n<p><strong>Force Application Consistency:</strong> Forces are accumulated in a consistent order and applied all at once during integration, rather than being applied immediately when generated.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The accumulator pattern elegantly solves the &quot;spiral of death&quot; problem where slow frames could cause physics to take even longer, creating a feedback loop. By capping the maximum timestep, the system gracefully degrades performance rather than becoming completely unresponsive.</p>\n</blockquote>\n<h3 id=\"collision-response-and-resolution\">Collision Response and Resolution</h3>\n<p>Collision response transforms the geometric information from collision detection into realistic physical reactions. This is like a <strong>judicial system</strong> that not only identifies when rules are broken (collision detection finds overlapping objects) but also determines the appropriate consequences and enforces them (collision response separates objects and applies forces).</p>\n<h4 id=\"impulse-based-response-calculation\">Impulse-Based Response Calculation</h4>\n<p>When two objects collide, the collision response system calculates <strong>impulse forces</strong> that instantaneously change the velocities of both objects to simulate the brief, intense forces that occur during real collisions. This approach models the fact that most game collisions happen faster than the physics timestep can resolve.</p>\n<p>The impulse calculation considers several physical properties: the masses of both objects, their relative velocity at the contact point, the collision normal direction, and material properties like restitution (bounciness) and friction.</p>\n<p><strong>Impulse Magnitude Calculation Algorithm:</strong></p>\n<ol>\n<li>Calculate the relative velocity of the two objects at the contact point: <code>relativeVelocity = velocityA - velocityB</code></li>\n<li>Project the relative velocity onto the collision normal to find the separating velocity: <code>separatingVelocity = dot(relativeVelocity, normal)</code></li>\n<li>If the separating velocity is positive, the objects are already moving apart, so skip collision response</li>\n<li>Calculate the desired final separating velocity after collision: <code>finalSeparatingVelocity = -restitution * separatingVelocity</code></li>\n<li>Compute the impulse magnitude needed to achieve this velocity change: <code>impulseMagnitude = (finalSeparatingVelocity - separatingVelocity) / (1/massA + 1/massB)</code></li>\n<li>Convert the impulse magnitude to a vector: <code>impulseVector = impulseMagnitude * normal</code></li>\n<li>Apply the impulse to object A (positive) and object B (negative) to conserve momentum</li>\n</ol>\n<p><strong>Collision Response Data:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Source</th>\n<th>Usage</th>\n<th>Range</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Restitution</td>\n<td>Material properties</td>\n<td>Controls bounciness</td>\n<td>0.0 (sticky) to 1.0 (perfect bounce)</td>\n</tr>\n<tr>\n<td>Friction</td>\n<td>Material properties</td>\n<td>Resists tangential motion</td>\n<td>0.0 (frictionless) to 1.0+ (high grip)</td>\n</tr>\n<tr>\n<td>Mass</td>\n<td><code>RigidBody</code> component</td>\n<td>Affects impulse distribution</td>\n<td>&gt; 0.0 (infinite mass = kinematic)</td>\n</tr>\n<tr>\n<td>Relative velocity</td>\n<td>Current object motion</td>\n<td>Determines collision intensity</td>\n<td>Calculated per collision</td>\n</tr>\n</tbody></table>\n<h4 id=\"position-correction-and-penetration-resolution\">Position Correction and Penetration Resolution</h4>\n<p>When collision detection finds overlapping objects, the collision response system must <strong>separate</strong> them to prevent visual artifacts and physics instability. This separation process, called position correction, moves objects apart by the minimum distance needed to eliminate overlap.</p>\n<p>Position correction uses a technique called <strong>linear projection</strong> that moves both objects along the collision normal by distances proportional to their masses. Lighter objects move farther than heavier objects, and immovable (kinematic) objects don&#39;t move at all.</p>\n<p><strong>Position Correction Algorithm:</strong></p>\n<ol>\n<li>Calculate the total mass ratio: <code>totalInverseMass = 1/massA + 1/massB</code></li>\n<li>If total inverse mass is zero (both objects are kinematic), skip position correction</li>\n<li>Determine the correction percentage to apply this frame (typically 80% to avoid overcorrection)</li>\n<li>Calculate the total correction distance: <code>correctionDistance = penetrationDepth * correctionPercentage</code></li>\n<li>Compute individual correction distances: <code>correctionA = correctionDistance * (1/massA) / totalInverseMass</code></li>\n<li>Apply position corrections: <code>positionA += correctionA * normal</code> and <code>positionB -= (correctionDistance - correctionA) * normal</code></li>\n<li>Update the transform components with the corrected positions for immediate visual feedback</li>\n</ol>\n<p>The position correction system uses a percentage-based approach (typically 80-90%) rather than full correction to avoid introducing energy into the system and causing jittery behavior when objects are in resting contact.</p>\n<h4 id=\"friction-and-tangential-forces\">Friction and Tangential Forces</h4>\n<p>Friction modeling adds realism by resisting motion perpendicular to the collision normal. The friction system calculates tangential impulses that oppose relative sliding motion between colliding objects.</p>\n<p><strong>Friction Calculation Algorithm:</strong></p>\n<ol>\n<li>Calculate the tangent vector perpendicular to the collision normal: <code>tangent = relativeVelocity - dot(relativeVelocity, normal) * normal</code>, then normalize</li>\n<li>Compute the relative velocity along the tangent: <code>tangentialVelocity = dot(relativeVelocity, tangent)</code></li>\n<li>Calculate the friction impulse magnitude: <code>frictionImpulse = -tangentialVelocity / (1/massA + 1/massB)</code></li>\n<li>Apply Coulomb friction limiting: <code>maxFriction = frictionCoefficient * abs(normalImpulse)</code></li>\n<li>Clamp the friction impulse: <code>frictionImpulse = clamp(frictionImpulse, -maxFriction, maxFriction)</code></li>\n<li>Convert to vector and apply: <code>frictionVector = frictionImpulse * tangent</code></li>\n<li>Apply friction impulses to both objects in opposite directions</li>\n</ol>\n<p><strong>Collision Response Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Key Operations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Impulse Calculator</td>\n<td>Velocity changes</td>\n<td>Normal impulse, restitution</td>\n</tr>\n<tr>\n<td>Position Corrector</td>\n<td>Separation</td>\n<td>Linear projection, penetration resolution</td>\n</tr>\n<tr>\n<td>Friction Resolver</td>\n<td>Tangential forces</td>\n<td>Coulomb friction, sliding resistance</td>\n</tr>\n<tr>\n<td>Material Manager</td>\n<td>Physical properties</td>\n<td>Restitution, friction coefficients</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight</strong>: Collision response must carefully balance realism with stability. Too much correction creates jittery behavior, while too little allows objects to sink into each other. The 80% correction percentage represents a sweet spot that works well for most game scenarios.</p>\n</blockquote>\n<h3 id=\"physics-architecture-decisions\">Physics Architecture Decisions</h3>\n<p>The physics system&#39;s architecture involves several critical design decisions that significantly impact performance, accuracy, and implementation complexity. Each decision represents a trade-off between different system qualities, and understanding these trade-offs is essential for making appropriate choices for your specific game requirements.</p>\n<blockquote>\n<p><strong>Decision: Fixed vs Variable Timestep</strong></p>\n<ul>\n<li><strong>Context</strong>: Physics simulation requires consistent timing to produce predictable, stable results. Different timestep approaches offer different guarantees about consistency and performance.</li>\n<li><strong>Options Considered</strong>: Variable timestep (use actual frame time), Semi-fixed timestep (clamp frame time), Fixed timestep with accumulator</li>\n<li><strong>Decision</strong>: Fixed timestep with accumulator pattern</li>\n<li><strong>Rationale</strong>: Fixed timestep provides deterministic simulation essential for networked games, replays, and debugging. The accumulator pattern decouples physics from rendering performance while preventing the &quot;spiral of death&quot; where slow physics makes subsequent frames even slower.</li>\n<li><strong>Consequences</strong>: Requires interpolation between physics states for smooth rendering, adds complexity to the main loop, but guarantees consistent behavior across different hardware and performance conditions.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Timestep Approach</th>\n<th>Determinism</th>\n<th>Performance</th>\n<th>Implementation Complexity</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Variable timestep</td>\n<td>No</td>\n<td>Excellent</td>\n<td>Low</td>\n<td>Simple single-player games</td>\n</tr>\n<tr>\n<td>Clamped variable</td>\n<td>Limited</td>\n<td>Good</td>\n<td>Low</td>\n<td>Most single-player games</td>\n</tr>\n<tr>\n<td>Fixed with accumulator</td>\n<td>Yes</td>\n<td>Good</td>\n<td>Medium</td>\n<td>Networked/competitive games</td>\n</tr>\n<tr>\n<td>Multiple timesteps</td>\n<td>Yes</td>\n<td>Complex</td>\n<td>High</td>\n<td>Advanced simulation games</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Spatial Partitioning Algorithm</strong></p>\n<ul>\n<li><strong>Context</strong>: Collision detection requires checking interactions between objects, which scales as O(n²) without optimization. Spatial partitioning reduces this cost by grouping nearby objects.</li>\n<li><strong>Options Considered</strong>: Uniform grid, Adaptive quadtree, Spatial hashing</li>\n<li><strong>Decision</strong>: Uniform grid with configurable cell size</li>\n<li><strong>Rationale</strong>: Uniform grids provide O(1) insertion/removal and work well for games with relatively even object distribution. The simplicity aids debugging and the performance is predictable.</li>\n<li><strong>Consequences</strong>: Less efficient for games with highly clustered objects, wastes memory in sparse areas, but provides excellent performance for typical 2D games with moderate object density.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Spatial Structure</th>\n<th>Insert/Remove</th>\n<th>Query</th>\n<th>Memory</th>\n<th>Object Distribution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Uniform Grid</td>\n<td>O(1)</td>\n<td>O(1) avg</td>\n<td>High</td>\n<td>Even distribution</td>\n</tr>\n<tr>\n<td>Quadtree</td>\n<td>O(log n)</td>\n<td>O(log n)</td>\n<td>Low</td>\n<td>Clustered objects</td>\n</tr>\n<tr>\n<td>Hash Grid</td>\n<td>O(1)</td>\n<td>O(1) avg</td>\n<td>Medium</td>\n<td>Mixed distribution</td>\n</tr>\n<tr>\n<td>No partitioning</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td>Low</td>\n<td>Very few objects (&lt;50)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Collision Response Method</strong></p>\n<ul>\n<li><strong>Context</strong>: When objects collide, the system must calculate realistic physical responses while maintaining simulation stability and performance.</li>\n<li><strong>Options Considered</strong>: Penalty forces (spring-based), Impulse-based response, Constraint-based solving</li>\n<li><strong>Decision</strong>: Impulse-based response with position correction</li>\n<li><strong>Rationale</strong>: Impulse methods provide good realism with simple implementation. Position correction prevents overlap accumulation without the complexity of constraint solvers.</li>\n<li><strong>Consequences</strong>: Handles most collision scenarios well, may struggle with complex multi-contact situations, but offers excellent performance-to-quality ratio for 2D games.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Response Method</th>\n<th>Realism</th>\n<th>Stability</th>\n<th>Performance</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Penalty forces</td>\n<td>Medium</td>\n<td>Poor</td>\n<td>Excellent</td>\n<td>Simple</td>\n</tr>\n<tr>\n<td>Impulse-based</td>\n<td>Good</td>\n<td>Good</td>\n<td>Good</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Constraint solving</td>\n<td>Excellent</td>\n<td>Excellent</td>\n<td>Poor</td>\n<td>Complex</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Integration Method</strong></p>\n<ul>\n<li><strong>Context</strong>: Physics integration determines how forces and velocities update object positions over time. Different methods offer trade-offs between accuracy, stability, and computational cost.</li>\n<li><strong>Options Considered</strong>: Explicit Euler, Semi-implicit Euler, Verlet integration, Runge-Kutta 4th order</li>\n<li><strong>Decision</strong>: Semi-implicit Euler integration</li>\n<li><strong>Rationale</strong>: Semi-implicit Euler provides better energy conservation than explicit Euler while remaining computationally simple. It handles typical game physics scenarios well without the complexity of higher-order methods.</li>\n<li><strong>Consequences</strong>: Good stability for most game scenarios, occasional energy drift in extreme cases, but excellent performance and simplicity make it ideal for real-time games.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Integration Method</th>\n<th>Stability</th>\n<th>Accuracy</th>\n<th>Performance</th>\n<th>Energy Conservation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Explicit Euler</td>\n<td>Poor</td>\n<td>Low</td>\n<td>Excellent</td>\n<td>Poor (adds energy)</td>\n</tr>\n<tr>\n<td>Semi-implicit Euler</td>\n<td>Good</td>\n<td>Medium</td>\n<td>Excellent</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Verlet</td>\n<td>Excellent</td>\n<td>High</td>\n<td>Good</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td>RK4</td>\n<td>Excellent</td>\n<td>Very High</td>\n<td>Poor</td>\n<td>Excellent</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Broad Phase Algorithm Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: The broad phase must quickly identify potentially colliding object pairs from the full set of objects in the world, minimizing expensive narrow phase tests.</li>\n<li><strong>Options Considered</strong>: Grid-based partitioning, Quadtree hierarchical subdivision, Sort-and-sweep along axes</li>\n<li><strong>Decision</strong>: Grid-based spatial partitioning with dynamic cell sizing</li>\n<li><strong>Rationale</strong>: Grid-based approaches offer constant-time insertion and lookup with predictable memory usage. Dynamic cell sizing adapts to object density for optimal performance.</li>\n<li><strong>Consequences</strong>: Excellent performance for evenly distributed objects, simple debugging and visualization, but less optimal for highly clustered scenarios compared to hierarchical approaches.</li>\n</ul>\n</blockquote>\n<p><strong>Physics System Configuration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Default Value</th>\n<th>Range</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Physics timestep</td>\n<td>16.67ms (60Hz)</td>\n<td>8-33ms</td>\n<td>Simulation accuracy vs performance</td>\n</tr>\n<tr>\n<td>Max accumulated time</td>\n<td>100ms</td>\n<td>50-200ms</td>\n<td>Spiral of death prevention</td>\n</tr>\n<tr>\n<td>Grid cell size</td>\n<td>64 units</td>\n<td>32-256 units</td>\n<td>Collision detection performance</td>\n</tr>\n<tr>\n<td>Position correction</td>\n<td>80%</td>\n<td>50-100%</td>\n<td>Stability vs convergence speed</td>\n</tr>\n<tr>\n<td>Velocity threshold</td>\n<td>0.01 units/s</td>\n<td>0.001-0.1</td>\n<td>Sleep/wake optimization</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-pitfalls\">Common Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Variable Timestep Physics</strong>\nPhysics that uses variable frame time (delta time from rendering) becomes non-deterministic and unstable. Fast-moving objects may tunnel through thin barriers during slow frames, while collision detection becomes inconsistent across different frame rates. The solution is implementing fixed timestep physics with an accumulator pattern that processes physics in consistent increments regardless of rendering performance.</p>\n<p>⚠️ <strong>Pitfall: Missing Collision Velocity Checks</strong>\nApplying collision response to objects that are already separating can cause them to &quot;stick&quot; together unnaturally. Always check that the relative velocity indicates the objects are approaching (<code>dot(relativeVelocity, normal) &lt; 0</code>) before applying impulse forces. Objects moving apart should not have their separation velocity reduced.</p>\n<p>⚠️ <strong>Pitfall: Excessive Position Correction</strong>\nCorrecting 100% of penetration depth every frame causes objects to jitter when they come to rest against each other. Use partial correction (80-90%) to allow small overlaps that get resolved gradually, providing stable resting contact between objects.</p>\n<p>⚠️ <strong>Pitfall: Broad Phase Cell Size Mismatch</strong>\nUsing grid cells that are too small relative to object sizes forces objects to span multiple cells, increasing collision checks. Conversely, cells that are too large fail to eliminate distant objects from consideration. Optimal cell size is typically 1-2 times the average object size.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Mass in Collision Response</strong>\nTreating all objects as having equal mass during collision response violates physical realism and creates strange behavior where small objects can dramatically affect large ones. Always consider inverse mass ratios when distributing impulse forces and position corrections between colliding objects.</p>\n<p>⚠️ <strong>Pitfall: Tunneling Through Thin Objects</strong>\nFast-moving objects can pass completely through thin barriers between physics frames. Implement continuous collision detection for high-speed objects or use swept collision volumes that consider the object&#39;s path between frames rather than just its current position.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math Library</td>\n<td>Custom <code>Vector2</code>/<code>Vector3</code> structs</td>\n<td>GLM (OpenGL Mathematics) library</td>\n</tr>\n<tr>\n<td>Spatial Partitioning</td>\n<td>Fixed uniform grid</td>\n<td>Dynamic quadtree or spatial hash</td>\n</tr>\n<tr>\n<td>Physics Integration</td>\n<td>Semi-implicit Euler</td>\n<td>Verlet integration with constraints</td>\n</tr>\n<tr>\n<td>Collision Shapes</td>\n<td>AABB and Circle only</td>\n<td>Convex polygons and compound shapes</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Standard containers</td>\n<td>Custom memory pools for hot objects</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">engine</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  physics</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    physics_world.h           ← Main physics system coordinator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    physics_world.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    collision_detection.h     ← Broad </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> narrow phase collision detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    collision_detection.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    collision_response.h      ← Impulse calculation </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> position correction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    collision_response.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spatial_grid.h           ← Uniform grid spatial partitioning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spatial_grid.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    integrator.h             ← Physics </span><span style=\"color:#B392F0\">integration</span><span style=\"color:#E1E4E8\"> (Euler, Verlet, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    integrator.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    physics_components.h     ← RigidBody, Collider, </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> related components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    physics_math.h          ← Vector math </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> physics utility functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    physics_math.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  components</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transform.h             ← Position, rotation, scale component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rigid_body.h           ← Physics properties: mass, velocity, forces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    collider.h             ← Collision shapes: AABB, Circle, etc.</span></span></code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Physics Math Utilities (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// physics/physics_math.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../engine_data_model.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cmath></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;algorithm></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> Physics</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Vector operations optimized for physics calculations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">inline</span><span style=\"color:#F97583\"> float</span><span style=\"color:#B392F0\"> Dot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> a.x </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b.x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> a.y </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b.y;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">inline</span><span style=\"color:#F97583\"> float</span><span style=\"color:#B392F0\"> LengthSquared</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> v</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> v.x </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> v.x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> v.y </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> v.y;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">inline</span><span style=\"color:#F97583\"> float</span><span style=\"color:#B392F0\"> Length</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> v</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sqrt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LengthSquared</span><span style=\"color:#E1E4E8\">(v));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">inline</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#B392F0\"> Normalize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> v</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Length</span><span style=\"color:#E1E4E8\">(v);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (len </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e-</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> Vector2{</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> Vector2{v.x </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> len, v.y </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> len};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">inline</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#B392F0\"> Project</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> v</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> normal</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> normal </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> Dot</span><span style=\"color:#E1E4E8\">(v, normal);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">inline</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#B392F0\"> Reject</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> v</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> normal</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">-</span><span style=\"color:#B392F0\"> Project</span><span style=\"color:#E1E4E8\">(v, normal);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AABB operations for collision detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> AABBTest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> Intersects</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (a.min.x </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> b.max.x </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> a.max.x </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> b.min.x) </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               (a.min.y </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> b.max.y </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> a.max.y </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> b.min.y);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#B392F0\"> ClosestPointOnAABB</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> box</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> point</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Vector2{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">clamp</span><span style=\"color:#E1E4E8\">(point.x, box.min.x, box.max.x),</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">clamp</span><span style=\"color:#E1E4E8\">(point.y, box.min.y, box.max.y)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> float</span><span style=\"color:#B392F0\"> PenetrationDepth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> xPenetration </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(a.max.x </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> b.min.x, b.max.x </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> a.min.x);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> yPenetration </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(a.max.y </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> b.min.y, b.max.y </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> a.min.y);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(xPenetration, yPenetration);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Circle collision operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> CircleTest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> Intersects</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> distanceSquared </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> LengthSquared</span><span style=\"color:#E1E4E8\">(a.center </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> b.center);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> radiusSum </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a.radius </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> b.radius;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> distanceSquared </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> radiusSum </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> radiusSum;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> float</span><span style=\"color:#B392F0\"> PenetrationDepth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> distance </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Length</span><span style=\"color:#E1E4E8\">(a.center </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> b.center);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (a.radius </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> b.radius) </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> distance;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // namespace Physics</span></span></code></pre></div>\n\n<p><strong>Spatial Grid Implementation (Complete):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// physics/spatial_grid.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../ecs/ecs_world.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../engine_data_model.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SpatialGrid</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> GridCell</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_cellSize;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;uint64_t</span><span style=\"color:#E1E4E8\">, GridCell</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_grid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#B392F0\"> GetCellKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> x</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> y</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">static_cast&#x3C;uint64_t></span><span style=\"color:#E1E4E8\">(x) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> static_cast&#x3C;uint64_t></span><span style=\"color:#E1E4E8\">(y);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Vector2</span><span style=\"color:#B392F0\"> WorldToGrid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Vector2</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> worldPos</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Vector2{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">floor</span><span style=\"color:#E1E4E8\">(worldPos.x </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> m_cellSize),</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">floor</span><span style=\"color:#E1E4E8\">(worldPos.y </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> m_cellSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> SpatialGrid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> cellSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 64.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">m_cellSize</span><span style=\"color:#E1E4E8\">(cellSize) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Clear</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> [key, cell] : m_grid) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cell.entities.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> bounds</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Vector2 minCell </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WorldToGrid</span><span style=\"color:#E1E4E8\">(bounds.min);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Vector2 maxCell </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WorldToGrid</span><span style=\"color:#E1E4E8\">(bounds.max);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> static_cast&#x3C;int></span><span style=\"color:#E1E4E8\">(minCell.x); x </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#F97583\"> static_cast&#x3C;int></span><span style=\"color:#E1E4E8\">(maxCell.x); </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">x) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> static_cast&#x3C;int></span><span style=\"color:#E1E4E8\">(minCell.y); y </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#F97583\"> static_cast&#x3C;int></span><span style=\"color:#E1E4E8\">(maxCell.y); </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">y) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint64_t</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GetCellKey</span><span style=\"color:#E1E4E8\">(x, y);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                m_grid[key].entities.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">CollisionPair</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">GetPotentialCollisions</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">CollisionPair</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> pairs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> [key, cell] : m_grid) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> entities </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cell.entities;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> entities.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> entities.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">j) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    pairs.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">({entities[i], entities[j]});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> pairs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Physics World Main Coordinator:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// physics/physics_world.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../ecs/ecs_world.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"spatial_grid.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"collision_detection.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"collision_response.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PhysicsWorld</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ECSWorld</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> m_ecsWorld;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpatialGrid m_spatialGrid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CollisionDetection m_collisionDetection;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CollisionResponse m_collisionResponse;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_accumulator;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_timestep;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> m_maxStepsPerFrame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">CollisionPair</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_activeCollisions;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PhysicsWorld</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> ecsWorld</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> timestep</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f/</span><span style=\"color:#79B8FF\">60.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main physics update called from game loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Add deltaTime to accumulator (clamp to prevent spiral of death)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: While accumulator >= timestep, perform fixed physics steps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: For each step: integrate forces, detect collisions, resolve responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Update transform components with new positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Calculate interpolation factor for smooth rendering</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Clamp deltaTime to 50ms max to prevent spiral of death</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> StepSimulation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> dt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Apply forces and integrate velocities/positions for all RigidBody components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Update spatial grid with new entity positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Run broad phase collision detection to get potential pairs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Run narrow phase to test actual intersections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Apply collision responses and position corrections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Process systems in order - integration first, then collision detection, then response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> IntegrateMotion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> dt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Query ECS for all entities with Transform and RigidBody components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: For each entity, apply semi-implicit Euler integration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Update velocity: velocity += acceleration * dt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Apply drag: velocity *= (1 - drag * dt)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update position: position += velocity * dt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Update Transform component with new position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use ComponentQuery to iterate efficiently over entities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Collision Detection System:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// physics/collision_detection.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../ecs/ecs_world.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../engine_data_model.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"spatial_grid.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CollisionDetection</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ECSWorld</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> m_ecsWorld;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpatialGrid</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> m_spatialGrid;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CollisionDetection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> ecs</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">SpatialGrid</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> grid</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">m_ecsWorld</span><span style=\"color:#E1E4E8\">(ecs), </span><span style=\"color:#B392F0\">m_spatialGrid</span><span style=\"color:#E1E4E8\">(grid) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">CollisionPair</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">DetectCollisions</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Clear and rebuild spatial grid with current entity positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get potential collision pairs from broad phase (spatial grid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: For each potential pair, perform narrow phase geometric test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: If collision detected, calculate contact info (point, normal, penetration)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Create CollisionPair with complete contact information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Return list of actual collisions for response processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Sort collision pairs by entity ID for deterministic processing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> TestAABBvsAABB</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">CollisionPair</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> result</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if bounding boxes overlap using interval test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If overlapping, calculate penetration depth in X and Y</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Choose axis with minimum penetration as collision normal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Calculate contact point as center of overlap region</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Set collision normal pointing from first object toward second</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Fill CollisionPair structure with contact information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Penetration depth = min(maxA - minB, maxB - minA) for each axis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> TestCirclevsCircle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Circle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">CollisionPair</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> result</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate distance between circle centers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if distance &#x3C;= sum of radii (collision condition)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Calculate penetration depth = radiusSum - distance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Calculate collision normal = normalize(centerB - centerA)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Calculate contact point on line between centers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Fill CollisionPair with calculated contact information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Handle edge case where circles have identical centers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Collision Response System:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// physics/collision_response.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../ecs/ecs_world.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../engine_data_model.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CollisionResponse</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ECSWorld</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> m_ecsWorld;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_positionCorrectionPercent;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CollisionResponse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> ecs</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> correctionPercent</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.8</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">m_ecsWorld</span><span style=\"color:#E1E4E8\">(ecs), </span><span style=\"color:#B392F0\">m_positionCorrectionPercent</span><span style=\"color:#E1E4E8\">(correctionPercent) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ResolveCollisions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">CollisionPair</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> collisions</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: For each collision pair, retrieve RigidBody components for both entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Calculate relative velocity at contact point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Check if objects are separating (skip if already moving apart)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Calculate impulse magnitude using restitution and mass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Apply impulse to both objects (equal and opposite)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Apply position correction to separate overlapping objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Process all velocity changes first, then all position corrections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ApplyImpulse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entityA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entityB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> CollisionPair</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> collision</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get RigidBody components for both entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Calculate relative velocity: velA - velB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Project relative velocity onto collision normal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: If separating velocity > 0, objects already separating - return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Calculate impulse: (-(1 + restitution) * separatingVel) / (1/massA + 1/massB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Apply impulse to velocities: velA += impulse/massA, velB -= impulse/massB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Handle infinite mass (kinematic) objects by using massInv = 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> CorrectPositions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entityA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entityB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> CollisionPair</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> collision</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate total inverse mass = 1/massA + 1/massB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If total inverse mass == 0, both objects kinematic - return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Calculate correction magnitude = penetration * correctionPercent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Distribute correction based on mass ratios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Move objects apart along collision normal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Update Transform components with corrected positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Lighter objects move more than heavier objects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>C++ Physics Implementation Tips:</strong></p>\n<ul>\n<li>Use <code>std::vector::reserve()</code> for collision pair containers to avoid repeated allocations during detection</li>\n<li>Implement custom <code>Vector2</code> operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) for clean physics math code</li>\n<li>Use <code>constexpr</code> for physics constants like <code>PHYSICS_TIMESTEP</code> to enable compile-time optimization</li>\n<li>Consider <code>std::unordered_set</code> for tracking active collision pairs between frames</li>\n<li>Use <code>alignas(16)</code> for <code>Vector2</code> structures to enable SIMD optimization in math operations</li>\n</ul>\n<p><strong>Memory Management for Physics:</strong></p>\n<ul>\n<li>Pre-allocate collision pair vectors based on expected maximum object count</li>\n<li>Use object pools for frequently created/destroyed physics components</li>\n<li>Consider structure-of-arrays layout for hot physics data (separate position, velocity arrays)</li>\n<li>Profile memory usage during collision detection - spatial partitioning can fragment memory</li>\n</ul>\n<p><strong>Performance Optimization:</strong></p>\n<ul>\n<li>Implement sleeping for stationary objects to skip physics processing</li>\n<li>Use squared distance comparisons to avoid expensive <code>sqrt()</code> calls</li>\n<li>Batch similar collision shape tests together for better instruction cache usage</li>\n<li>Consider fixed-point arithmetic for networked games requiring bitwise determinism</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the physics system, verify the following behavior:</p>\n<p><strong>Test Command:</strong> Create a simple test scene with falling objects and static platforms.</p>\n<p><strong>Expected Results:</strong></p>\n<ol>\n<li><strong>Gravity Integration</strong>: Objects with <code>RigidBody</code> components fall at consistent acceleration regardless of frame rate</li>\n<li><strong>Collision Detection</strong>: Moving objects stop when they hit static platforms, with collision pairs logged to console</li>\n<li><strong>Collision Response</strong>: Objects bounce realistically based on restitution values, with conservation of momentum</li>\n<li><strong>Spatial Partitioning</strong>: Performance remains stable with 100+ objects (measure frame times)</li>\n<li><strong>Determinism</strong>: Same input sequence produces identical simulation results across multiple runs</li>\n</ol>\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Drop 10 identical objects from the same height - they should hit the ground simultaneously</li>\n<li>Adjust restitution from 0.0 to 1.0 - observe bouncing behavior from sticky to perfectly elastic</li>\n<li>Test collision between objects of different masses - lighter objects should be affected more</li>\n<li>Enable collision pair debug drawing - verify broad phase eliminates distant objects</li>\n<li>Measure physics step timing - should remain constant regardless of rendering frame rate</li>\n</ol>\n<p><strong>Performance Benchmarks:</strong></p>\n<ul>\n<li>100 objects: &lt; 2ms per physics step</li>\n<li>500 objects: &lt; 8ms per physics step</li>\n<li>Spatial grid: &lt; 1ms rebuild time per frame</li>\n<li>Memory usage: &lt; 1MB for collision data structures</li>\n</ul>\n<h2 id=\"resource-and-scene-management\">Resource and Scene Management</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (Resource &amp; Scene Management) — asset loading, caching, and scene serialization system with reference counting and lifecycle management</p>\n</blockquote>\n<p>Resource and scene management forms the <strong>operational backbone</strong> of a game engine, controlling how assets flow from disk storage into active memory and GPU resources. This system determines whether your engine can efficiently load and unload game content, transition between levels without memory leaks, and provide consistent access to shared resources across multiple game objects. The complexity lies not just in loading files, but in managing resource lifecycles, handling loading failures gracefully, and maintaining performance during scene transitions.</p>\n<h3 id=\"mental-model-library-check-out-system\">Mental Model: Library Check-out System</h3>\n<p>Understanding resource management as a <strong>library check-out system</strong> provides intuitive insight into the core responsibilities and challenges. In a physical library, patrons check out books using a catalog system that tracks which books are available, who has borrowed them, and when they must be returned. The librarian maintains an inventory system that prevents duplicate acquisitions, handles damaged or missing books, and ensures popular resources remain accessible.</p>\n<p>Similarly, a game engine&#39;s resource manager acts as a <strong>digital librarian</strong> that maintains a catalog of available assets (textures, meshes, audio clips, scene files), tracks which game systems are currently using each resource through <strong>reference counting</strong>, and automatically returns memory to the system when no entities need a particular asset anymore. The resource handles act like library cards—they provide indirect access to the actual resource while allowing the system to track usage and validate that the requested resource still exists.</p>\n<p>When a rendering system requests a texture for a sprite, it doesn&#39;t receive a direct memory pointer. Instead, it gets a <code>TextureHandle</code> that represents a <strong>validated loan</strong> of that resource. The resource manager maintains the actual texture data in GPU memory and can revoke access, reload damaged resources, or substitute fallback assets transparently. This indirection enables sophisticated lifecycle management that would be impossible with direct pointer access.</p>\n<p>The scene management system extends this metaphor to <strong>entire collections</strong> of related resources. Loading a new game level is like checking out a complete course syllabus—dozens of related books, videos, and materials that must be acquired together, used in coordination, and returned as a group when the course ends.</p>\n<h3 id=\"asset-loading-pipeline\">Asset Loading Pipeline</h3>\n<p>The asset loading pipeline transforms files stored on disk into GPU-ready resources that can be efficiently accessed during frame rendering. This process involves multiple stages of validation, format conversion, and memory allocation that must handle both successful loads and various failure modes gracefully.</p>\n<h4 id=\"file-format-support-strategy\">File Format Support Strategy</h4>\n<p>The engine supports a <strong>curated set of standard formats</strong> chosen for broad compatibility and efficient loading characteristics. Rather than attempting to support every possible file format, the pipeline focuses on formats that provide good compression, fast loading times, and reliable cross-platform behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Asset Type</th>\n<th>Primary Format</th>\n<th>Fallback Format</th>\n<th>Loading Library</th>\n<th>GPU Format</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Textures</td>\n<td>PNG</td>\n<td>JPEG</td>\n<td>stb_image</td>\n<td>RGBA8</td>\n<td>Lossless with transparency, widely supported</td>\n</tr>\n<tr>\n<td>3D Meshes</td>\n<td>OBJ</td>\n<td>Custom Binary</td>\n<td>tinyobjloader</td>\n<td>Vertex Buffers</td>\n<td>Text format for debugging, binary for performance</td>\n</tr>\n<tr>\n<td>Audio</td>\n<td>WAV</td>\n<td>OGG Vorbis</td>\n<td>Custom + stb_vorbis</td>\n<td>PCM Samples</td>\n<td>Uncompressed for low latency, compressed for music</td>\n</tr>\n<tr>\n<td>Scenes</td>\n<td>JSON</td>\n<td>Binary</td>\n<td>nlohmann::json</td>\n<td>Entity-Component Data</td>\n<td>Human readable for development, compact for shipping</td>\n</tr>\n<tr>\n<td>Shaders</td>\n<td>GLSL</td>\n<td>SPIR-V</td>\n<td>Custom</td>\n<td>Compiled Programs</td>\n<td>Source for development, bytecode for deployment</td>\n</tr>\n</tbody></table>\n<p>The loading pipeline implements a <strong>format detection system</strong> that examines file headers and extensions to determine the appropriate loader. This allows the engine to handle assets regardless of whether they have correct file extensions, and provides fallback options when primary loaders fail.</p>\n<h4 id=\"resource-loading-state-machine\">Resource Loading State Machine</h4>\n<p>Each resource progresses through a well-defined set of states during its lifecycle, from initial load request through active use and eventual cleanup. The state machine ensures consistent behavior and prevents common errors like using resources before they&#39;re ready or accessing freed memory.</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Trigger Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unloaded</td>\n<td>Load Request</td>\n<td>Loading</td>\n<td>Allocate handle, start async load, increment ref count</td>\n</tr>\n<tr>\n<td>Loading</td>\n<td>Load Complete</td>\n<td>Loaded</td>\n<td>Store resource data, mark handle valid, notify waiters</td>\n</tr>\n<tr>\n<td>Loading</td>\n<td>Load Failed</td>\n<td>Error</td>\n<td>Store error message, mark handle invalid, notify waiters</td>\n</tr>\n<tr>\n<td>Loaded</td>\n<td>Additional Request</td>\n<td>Loaded</td>\n<td>Increment reference count, return existing handle</td>\n</tr>\n<tr>\n<td>Loaded</td>\n<td>Release Request</td>\n<td>Loaded</td>\n<td>Decrement reference count, check for zero refs</td>\n</tr>\n<tr>\n<td>Loaded</td>\n<td>Ref Count Zero</td>\n<td>Unloaded</td>\n<td>Free GPU memory, deallocate handle, mark invalid</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>Retry Request</td>\n<td>Loading</td>\n<td>Reset error state, restart async load process</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>Release Request</td>\n<td>Unloaded</td>\n<td>Clean up error state, deallocate handle</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fresource-lifecycle.svg\" alt=\"Resource Loading and Caching\"></p>\n<p>The state machine implementation uses <strong>atomic operations</strong> for state transitions to ensure thread safety during asynchronous loading. Multiple game systems can request the same resource simultaneously without creating race conditions or duplicate loading operations.</p>\n<h4 id=\"asynchronous-loading-architecture\">Asynchronous Loading Architecture</h4>\n<p>Modern games require <strong>non-blocking asset loading</strong> to maintain smooth frame rates during level transitions and streaming scenarios. The engine implements a <strong>worker thread pool</strong> dedicated to asset loading operations, allowing the main game thread to continue processing input and rendering while resources load in the background.</p>\n<p>The asynchronous loading system consists of several coordinated components:</p>\n<ol>\n<li><strong>Load Request Queue</strong>: Thread-safe queue where game systems submit asset loading requests with priority levels and completion callbacks</li>\n<li><strong>Worker Thread Pool</strong>: Fixed number of background threads that process loading requests in priority order</li>\n<li><strong>Completion Notification System</strong>: Mechanism for notifying requesting systems when loads complete or fail</li>\n<li><strong>Memory Staging Area</strong>: Temporary storage for loaded asset data before transfer to final GPU or main memory locations</li>\n<li><strong>Progress Tracking</strong>: System for monitoring loading progress and providing feedback to loading screens</li>\n</ol>\n<p>The loading process follows this detailed sequence:</p>\n<ol>\n<li>Game system calls <code>ResourceManager::LoadAsync&lt;TextureHandle&gt;(&quot;texture.png&quot;, callback)</code></li>\n<li>Resource manager checks cache for existing handle with same path</li>\n<li>If found, increments reference count and invokes callback immediately with existing handle</li>\n<li>If not found, allocates new handle in Loading state and queues load request</li>\n<li>Worker thread dequeues request and opens file using appropriate format loader</li>\n<li>Raw file data is decoded into engine-native format (RGBA8 for textures, vertex arrays for meshes)</li>\n<li>Decoded data is transferred to GPU memory using OpenGL texture creation calls</li>\n<li>Handle state transitions to Loaded, GPU resource ID is stored in handle</li>\n<li>Completion callback is invoked on main thread with valid handle</li>\n<li>Requesting system can now use handle for rendering operations</li>\n</ol>\n<h4 id=\"gpu-resource-upload-pipeline\">GPU Resource Upload Pipeline</h4>\n<p>Loading asset data from disk represents only half of the resource loading challenge. The loaded data must be efficiently transferred to GPU memory and organized for optimal rendering performance. This <strong>upload pipeline</strong> handles the conversion from CPU-accessible asset data to GPU resources like textures, vertex buffers, and shader programs.</p>\n<p>The GPU upload process varies significantly by resource type:</p>\n<p><strong>Texture Upload Process:</strong></p>\n<ol>\n<li>Decode image file into RGBA8 pixel array using <code>stb_image</code></li>\n<li>Generate OpenGL texture object with <code>glGenTextures</code></li>\n<li>Bind texture and configure filtering, wrapping, and mipmap parameters</li>\n<li>Upload pixel data to GPU with <code>glTexImage2D</code></li>\n<li>Generate mipmaps for distance-based level-of-detail if requested</li>\n<li>Store texture ID and dimensions in <code>TextureHandle</code> for future access</li>\n</ol>\n<p><strong>Mesh Upload Process:</strong></p>\n<ol>\n<li>Parse OBJ file into arrays of vertex positions, normals, and texture coordinates</li>\n<li>Interleave vertex attributes into single array matching shader input layout</li>\n<li>Generate vertex buffer object (VBO) and vertex array object (VAO) with OpenGL</li>\n<li>Upload vertex data to GPU memory with <code>glBufferData</code></li>\n<li>Configure vertex attribute pointers for position, normal, and texcoord data</li>\n<li>Store VAO ID and vertex count in <code>MeshHandle</code> for rendering</li>\n</ol>\n<p>The upload pipeline implements <strong>batching optimizations</strong> to minimize GPU state changes. Multiple resources of the same type are uploaded together, texture atlases combine multiple small textures into larger GPU allocations, and vertex buffers are packed to reduce draw call overhead.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: GPU memory allocation is expensive and permanent until explicitly freed. The upload pipeline front-loads all allocation costs during loading to ensure rendering performance remains consistent during gameplay.</p>\n</blockquote>\n<h3 id=\"resource-cache-and-handles\">Resource Cache and Handles</h3>\n<p>The resource cache provides <strong>unified access</strong> to all loaded assets through a handle-based system that abstracts memory management and provides thread-safe access patterns. Rather than exposing raw pointers to GPU resources, the engine issues handles that can be validated, reference-counted, and revoked when necessary.</p>\n<h4 id=\"handle-based-resource-access\">Handle-Based Resource Access</h4>\n<p>Resource handles solve several critical problems with direct pointer access: they prevent dangling pointer crashes when resources are unloaded, enable automatic memory management through reference counting, and provide type safety by encoding resource types directly in the handle value.</p>\n<p>Each resource handle contains three essential pieces of information encoded in a 64-bit unsigned integer:</p>\n<table>\n<thead>\n<tr>\n<th>Bit Range</th>\n<th>Component</th>\n<th>Purpose</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0-31</td>\n<td>Resource ID</td>\n<td>Unique identifier within resource type</td>\n<td>1247</td>\n</tr>\n<tr>\n<td>32-47</td>\n<td>Version</td>\n<td>Prevents access to freed and reallocated handles</td>\n<td>23</td>\n</tr>\n<tr>\n<td>48-63</td>\n<td>Type</td>\n<td>Distinguishes texture, mesh, audio, scene handles</td>\n<td>TYPE_TEXTURE</td>\n</tr>\n</tbody></table>\n<p>The handle encoding enables <strong>constant-time validation</strong> and <strong>type-safe access</strong> without requiring string lookups or hash table operations. The resource manager can immediately determine whether a handle is valid by checking if the version matches the stored version for that resource ID.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Handle Structure (64-bit):\n[TYPE:16][VERSION:16][ID:32]</code></pre></div>\n\n<p>The version component provides <strong>ABA problem protection</strong>—it prevents accessing a resource handle that points to a memory location that has been freed and reallocated for a different resource. Each time a resource ID is recycled, its version increments, making old handles detectably invalid.</p>\n<h4 id=\"reference-counting-and-automatic-cleanup\">Reference Counting and Automatic Cleanup</h4>\n<p>The resource cache implements <strong>automatic reference counting</strong> to track which game systems are actively using each resource. When a system requests a resource handle, the reference count increments. When the system releases the handle (either explicitly or through destructor calls), the count decrements. Resources with zero references become candidates for automatic cleanup.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Reference Count Change</th>\n<th>Cache Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LoadResource()</code></td>\n<td>+1</td>\n<td>If resource exists, return existing handle; otherwise start loading</td>\n</tr>\n<tr>\n<td><code>Handle Copy Constructor</code></td>\n<td>+1</td>\n<td>Multiple handles can reference same resource</td>\n</tr>\n<tr>\n<td><code>Handle Destructor</code></td>\n<td>-1</td>\n<td>Automatically called when handles go out of scope</td>\n</tr>\n<tr>\n<td><code>Release()</code> explicit call</td>\n<td>-1</td>\n<td>Manual release for precise control</td>\n</tr>\n<tr>\n<td>Count reaches zero</td>\n<td>N/A</td>\n<td>Resource marked for cleanup, GPU memory freed</td>\n</tr>\n<tr>\n<td><code>LoadResource()</code> after cleanup</td>\n<td>+1</td>\n<td>Resource reloaded from disk if needed again</td>\n</tr>\n</tbody></table>\n<p>The reference counting system uses <strong>atomic operations</strong> to ensure thread safety when multiple systems access the same resource simultaneously. The cache can handle scenarios like one system requesting a resource while another system is releasing its reference to the same resource.</p>\n<h4 id=\"cache-implementation-architecture\">Cache Implementation Architecture</h4>\n<p>The resource cache organizes resources by type using <strong>separate storage pools</strong> for textures, meshes, audio clips, and scene data. This organization enables type-specific optimizations and prevents resource ID conflicts between different asset types.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Cache Organization:\nResourceCache\n├── TexturePool: vector&lt;TextureResource&gt;\n├── MeshPool: vector&lt;MeshResource&gt; \n├── AudioPool: vector&lt;AudioResource&gt;\n└── ScenePool: vector&lt;SceneResource&gt;\n\nEach Pool Entry:\n- ResourceData: GPU IDs, dimensions, format info\n- ReferenceCount: atomic&lt;uint32_t&gt;\n- Version: uint16_t for handle validation\n- State: enum {Loading, Loaded, Error}\n- LoadPath: string for reloading</code></pre></div>\n\n<p>The cache implements <strong>generational garbage collection</strong> for resource cleanup. Rather than immediately freeing resources when reference counts reach zero, the cache marks them as <strong>candidates for collection</strong> and performs cleanup during dedicated maintenance phases. This approach prevents performance hitches during gameplay and allows recently-used resources to remain cached for potential reuse.</p>\n<h4 id=\"thread-safety-and-concurrent-access\">Thread Safety and Concurrent Access</h4>\n<p>Modern game engines require <strong>concurrent access</strong> to the resource cache from multiple threads: the main thread during rendering, background threads during loading, and potentially audio threads accessing sound resources. The cache implementation provides thread safety without compromising performance for the common case of accessing already-loaded resources.</p>\n<p>The thread safety strategy combines <strong>lock-free reads</strong> for loaded resources with <strong>fine-grained locking</strong> for modification operations:</p>\n<ol>\n<li><strong>Handle Validation</strong>: Uses atomic loads to read handle versions and resource states without locking</li>\n<li><strong>Reference Counting</strong>: Uses atomic increment/decrement operations for thread-safe counting</li>\n<li><strong>Resource Loading</strong>: Uses per-resource mutexes to prevent duplicate loading of the same asset</li>\n<li><strong>Cache Cleanup</strong>: Uses write locks during garbage collection phases to ensure consistency</li>\n</ol>\n<p>This design ensures that the common operations—validating handles and accessing loaded resource data—never block, while expensive operations like loading and cleanup use appropriate synchronization.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The resource cache optimizes for the 95% case where resources are already loaded and simply need to be accessed. Handle validation and resource data retrieval use lock-free atomic operations, while the rare cases of loading new resources or cleaning up unused resources accept the overhead of mutex synchronization.</p>\n</blockquote>\n<h3 id=\"scene-serialization-and-transitions\">Scene Serialization and Transitions</h3>\n<p>Scene management orchestrates the <strong>coordinated loading and unloading</strong> of entire game levels, including all entities, components, and referenced resources. Unlike individual resource loading, scene transitions must handle complex dependency graphs, maintain referential integrity, and provide atomic success-or-rollback behavior to prevent partially-loaded game states.</p>\n<h4 id=\"scene-data-format-and-structure\">Scene Data Format and Structure</h4>\n<p>Game scenes represent <strong>complete snapshots</strong> of the entity-component world state at a specific point in time, along with metadata about required resources and system configurations. The engine supports both human-readable JSON format for development and compact binary format for production deployment.</p>\n<p>The scene file structure captures all information needed to reconstruct the game world:</p>\n<table>\n<thead>\n<tr>\n<th>Section</th>\n<th>Content</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Scene Metadata</td>\n<td>Version, creation date, dependencies</td>\n<td><code>{&quot;version&quot;: 1, &quot;engine_version&quot;: &quot;0.1.0&quot;}</code></td>\n</tr>\n<tr>\n<td>Resource Manifest</td>\n<td>List of all required assets with checksums</td>\n<td><code>{&quot;textures&quot;: [&quot;player.png&quot;, &quot;background.jpg&quot;]}</code></td>\n</tr>\n<tr>\n<td>Entity Definitions</td>\n<td>Complete entity-component data</td>\n<td><code>{&quot;entity_1&quot;: {&quot;Transform&quot;: {...}, &quot;Sprite&quot;: {...}}}</code></td>\n</tr>\n<tr>\n<td>System Configuration</td>\n<td>Scene-specific system parameters</td>\n<td><code>{&quot;physics&quot;: {&quot;gravity&quot;: -9.8, &quot;timestep&quot;: 0.016}}</code></td>\n</tr>\n<tr>\n<td>Scene Graph</td>\n<td>Hierarchical entity relationships</td>\n<td><code>{&quot;root&quot;: {&quot;children&quot;: [&quot;entity_1&quot;, &quot;entity_2&quot;]}}</code></td>\n</tr>\n</tbody></table>\n<p>The serialization format uses <strong>stable entity IDs</strong> that remain consistent across save/load cycles, enabling save game compatibility and networking scenarios where entity references must be synchronized between different game instances.</p>\n<h4 id=\"entity-component-serialization\">Entity-Component Serialization</h4>\n<p>Converting the runtime entity-component state into serialized form requires handling <strong>component polymorphism</strong> and <strong>resource references</strong> while maintaining the data-oriented memory layout benefits of the ECS architecture. The serialization system must serialize each component type using its specific format while preserving entity relationships and component interdependencies.</p>\n<table>\n<thead>\n<tr>\n<th>Component Type</th>\n<th>Serialization Format</th>\n<th>Special Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Transform</code></td>\n<td>Direct value copy</td>\n<td>None—simple POD structure</td>\n</tr>\n<tr>\n<td><code>Sprite</code></td>\n<td>Texture handle conversion</td>\n<td>Convert handle to asset path string</td>\n</tr>\n<tr>\n<td><code>RigidBody</code></td>\n<td>Physics state with references</td>\n<td>Handle collision shape references</td>\n</tr>\n<tr>\n<td><code>AudioSource</code></td>\n<td>Audio settings + clip reference</td>\n<td>Convert audio handle to asset path</td>\n</tr>\n<tr>\n<td>Custom Components</td>\n<td>Reflection-based or manual</td>\n<td>User-provided serialization functions</td>\n</tr>\n</tbody></table>\n<p>The serialization process follows this detailed procedure:</p>\n<ol>\n<li><strong>Entity Enumeration</strong>: Iterate through all valid entities in the ECS world, collecting their component signatures</li>\n<li><strong>Resource Path Resolution</strong>: Convert all resource handles back to their original file paths for inclusion in the resource manifest</li>\n<li><strong>Component Serialization</strong>: For each entity, serialize all attached components using type-specific serialization functions</li>\n<li><strong>Reference Validation</strong>: Ensure all entity references (parent/child relationships, collision target references) point to entities that exist in the scene</li>\n<li><strong>Manifest Generation</strong>: Create the complete list of external resources required by the serialized entities</li>\n<li><strong>File Writing</strong>: Write the complete scene data to disk using either JSON or binary format with integrity checksums</li>\n</ol>\n<p>The reverse process during scene loading validates the resource manifest, loads all required assets, creates entities with the correct IDs, and attaches components with properly-resolved resource references.</p>\n<h4 id=\"scene-transition-pipeline\">Scene Transition Pipeline</h4>\n<p>Scene transitions represent one of the most complex operations in game engine architecture, requiring <strong>atomic state management</strong> to prevent partially-loaded game worlds and <strong>resource lifecycle coordination</strong> to avoid memory leaks and dangling references.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fscene-management.svg\" alt=\"Scene Transition Flow\"></p>\n<p>The scene transition pipeline implements a <strong>two-phase commit protocol</strong> that ensures either complete success or complete rollback:</p>\n<p><strong>Phase 1: Preparation and Validation</strong></p>\n<ol>\n<li>Parse new scene file and validate format version compatibility</li>\n<li>Check resource manifest against available storage and memory limits</li>\n<li>Begin preloading all required resources in background threads</li>\n<li>Validate that all entity references and component dependencies can be satisfied</li>\n<li>Prepare temporary entity storage for the new scene data</li>\n</ol>\n<p><strong>Phase 2: Atomic Transition</strong>\n6. Pause all game systems to prevent updates during transition\n7. Store current scene state if save-on-transition is requested\n8. Destroy all entities in current scene and decrement resource reference counts\n9. Create new entities from serialized data with resolved resource handles\n10. Resume game systems with new scene data active</p>\n<p>The pipeline provides <strong>rollback capability</strong> if any step fails: if resource loading fails in Phase 1, the current scene remains unchanged; if entity creation fails in Phase 2, the system can restore the previous scene state and report the specific error.</p>\n<h4 id=\"memory-management-during-transitions\">Memory Management During Transitions</h4>\n<p>Scene transitions create significant <strong>memory pressure</strong> as the system simultaneously holds resources for the outgoing scene (until cleanup completes) and incoming scene (during loading). The transition pipeline implements several strategies to minimize peak memory usage and prevent out-of-memory conditions:</p>\n<p><strong>Resource Sharing</strong>: Resources used by both the current and incoming scene (common UI textures, sound effects, character assets) maintain their reference counts and avoid unnecessary unload/reload cycles.</p>\n<p><strong>Streaming Prioritization</strong>: Critical resources for the new scene (player character, ground textures) receive loading priority over less essential assets (background music, ambient sound effects).</p>\n<p><strong>Cleanup Scheduling</strong>: Resources from the previous scene are freed in dependency order—first entities release component references, then components release resource handles, finally resources with zero references free their GPU memory.</p>\n<p><strong>Memory Pool Recycling</strong>: Entity and component storage pools retain their allocated memory between scenes, avoiding repeated heap allocation overhead for similarly-sized game levels.</p>\n<p>The transition pipeline monitors available memory throughout the process and can implement <strong>aggressive cleanup</strong> (immediately freeing unused resources) or <strong>conservative caching</strong> (retaining recently-used resources) based on current memory pressure.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Scene transitions are the most memory-intensive operation in game engines. The two-phase commit protocol ensures atomic success/failure behavior, but the engine must carefully balance memory usage, loading performance, and user experience during the transition period.</p>\n</blockquote>\n<h3 id=\"resource-architecture-decisions\">Resource Architecture Decisions</h3>\n<p>The resource management system requires several fundamental architecture decisions that affect performance, memory usage, and implementation complexity throughout the engine. Each decision involves significant trade-offs that impact how game developers interact with the engine and what scenarios the engine can handle effectively.</p>\n<blockquote>\n<p><strong>Decision: Handle-Based vs Direct Pointer Access</strong></p>\n<ul>\n<li><strong>Context</strong>: Game systems need access to loaded resources like textures and meshes, but direct pointers create lifetime management problems</li>\n<li><strong>Options Considered</strong>: Direct GPU resource pointers, weak pointer systems, handle-based access with validation</li>\n<li><strong>Decision</strong>: Handle-based access with embedded versioning and reference counting</li>\n<li><strong>Rationale</strong>: Handles prevent dangling pointer crashes, enable automatic memory management, and provide type safety with minimal runtime overhead</li>\n<li><strong>Consequences</strong>: Enables safe resource lifecycle management but requires handle validation on each access and complicates direct resource manipulation</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Memory Overhead</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Direct Pointers</td>\n<td>Zero overhead, simple access</td>\n<td>Dangling pointer crashes, manual lifetime management</td>\n<td>None</td>\n<td>Fastest access</td>\n</tr>\n<tr>\n<td>Weak Pointers</td>\n<td>Automatic cleanup detection</td>\n<td>Complex implementation, reference counting overhead</td>\n<td>High (shared_ptr control blocks)</td>\n<td>Moderate (atomic operations)</td>\n</tr>\n<tr>\n<td><strong>Handle-Based</strong></td>\n<td>Safe lifetime management, type safety, validation</td>\n<td>Handle validation cost, indirection overhead</td>\n<td>Low (64-bit handles)</td>\n<td>Low (single table lookup)</td>\n</tr>\n</tbody></table>\n<p>The handle-based approach provides the best balance of safety, performance, and implementation simplicity for an educational engine that must handle resource loading errors gracefully.</p>\n<blockquote>\n<p><strong>Decision: Synchronous vs Asynchronous Resource Loading</strong></p>\n<ul>\n<li><strong>Context</strong>: Asset loading from disk can cause frame rate hitches, but asynchronous loading complicates resource availability checking</li>\n<li><strong>Options Considered</strong>: Synchronous blocking loads, fully asynchronous with callbacks, hybrid approach with optional synchronous fallback</li>\n<li><strong>Decision</strong>: Asynchronous loading with completion callbacks and synchronous fallback for critical resources</li>\n<li><strong>Rationale</strong>: Maintains smooth frame rates during normal gameplay while allowing immediate loading for essential resources like fallback textures</li>\n<li><strong>Consequences</strong>: Enables smooth gameplay experience but requires callback-based programming patterns and careful loading state management</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Implementation Complexity</th>\n<th>User Experience</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Synchronous Only</td>\n<td>Simple implementation, immediate availability</td>\n<td>Frame rate hitches, poor UX</td>\n<td>Low</td>\n<td>Poor (loading pauses)</td>\n</tr>\n<tr>\n<td><strong>Async + Sync Fallback</strong></td>\n<td>Smooth performance, flexibility</td>\n<td>Complex state management</td>\n<td>Medium</td>\n<td>Good (responsive with fallbacks)</td>\n</tr>\n<tr>\n<td>Async Only</td>\n<td>Best performance, consistent patterns</td>\n<td>Complex availability checking</td>\n<td>High</td>\n<td>Excellent (never blocks)</td>\n</tr>\n</tbody></table>\n<p>The hybrid approach provides flexibility for different use cases while maintaining reasonable implementation complexity for educational purposes.</p>\n<blockquote>\n<p><strong>Decision: JSON vs Binary Scene Serialization</strong></p>\n<ul>\n<li><strong>Context</strong>: Scene files need to store entity-component data, with requirements for both human readability during development and compact size for distribution</li>\n<li><strong>Options Considered</strong>: JSON only, binary only, hybrid format with JSON for development and binary for shipping</li>\n<li><strong>Decision</strong>: Hybrid approach with JSON as primary format and binary as optimization option</li>\n<li><strong>Rationale</strong>: JSON enables easy debugging, version control, and manual editing during development, while binary provides space efficiency for final game distribution</li>\n<li><strong>Consequences</strong>: Supports both development and production needs but requires maintaining two serialization code paths</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>File Size</th>\n<th>Debug Ability</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Only</td>\n<td>Human readable, standard tooling</td>\n<td>Large files, slower parsing</td>\n<td>Large</td>\n<td>Excellent</td>\n<td>For development</td>\n</tr>\n<tr>\n<td>Binary Only</td>\n<td>Compact, fast parsing</td>\n<td>Opaque files, hard to debug</td>\n<td>Small</td>\n<td>Poor</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Hybrid Format</strong></td>\n<td>Best of both worlds</td>\n<td>Dual implementation complexity</td>\n<td>Flexible</td>\n<td>Good</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<p>The hybrid approach acknowledges that development and production have different priorities and provides appropriate tools for each scenario.</p>\n<blockquote>\n<p><strong>Decision: Reference Counting vs Garbage Collection</strong></p>\n<ul>\n<li><strong>Context</strong>: Resources must be automatically freed when no longer in use, but different cleanup strategies have different performance characteristics</li>\n<li><strong>Options Considered</strong>: Manual cleanup only, reference counting with immediate cleanup, mark-and-sweep garbage collection</li>\n<li><strong>Decision</strong>: Reference counting with deferred cleanup during maintenance phases</li>\n<li><strong>Rationale</strong>: Provides predictable resource cleanup without garbage collection pauses, while deferred cleanup prevents performance hitches from expensive GPU resource deallocation</li>\n<li><strong>Consequences</strong>: Enables deterministic resource management with controlled cleanup timing but requires careful handling of circular references</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Cleanup Timing</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Manual Only</td>\n<td>Full control, no overhead</td>\n<td>Error-prone, memory leaks</td>\n<td>Immediate</td>\n<td>None</td>\n</tr>\n<tr>\n<td><strong>Reference Counting</strong></td>\n<td>Automatic, deterministic</td>\n<td>Cannot handle cycles, cleanup overhead</td>\n<td>Predictable</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Garbage Collection</td>\n<td>Handles cycles, simple usage</td>\n<td>Pause times, complex implementation</td>\n<td>Unpredictable</td>\n<td>Variable</td>\n</tr>\n</tbody></table>\n<p>Reference counting provides the right balance of automation and predictability for a real-time game engine that cannot tolerate garbage collection pauses.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Resource management presents several recurring challenges that can cause memory leaks, performance problems, or hard-to-debug crashes. Understanding these pitfalls helps developers implement robust resource systems from the beginning.</p>\n<p>⚠️ <strong>Pitfall: Resource Handle Validation Skipping</strong></p>\n<p>Many developers skip handle validation checks in performance-critical code paths, assuming that handles will always remain valid throughout frame processing. However, resources can become invalid due to loading failures, memory pressure, or scene transitions that occur asynchronously.</p>\n<p><strong>Why this breaks</strong>: Accessing an invalid handle can return stale resource data, cause OpenGL errors when using deallocated texture IDs, or crash the application when dereferencing null pointers in the resource storage arrays.</p>\n<p><strong>How to avoid</strong>: Always call <code>IsValid()</code> on resource handles before accessing resource data, especially after scene transitions or during error recovery scenarios. The validation cost is minimal compared to debugging crashes caused by invalid resource access.</p>\n<p>⚠️ <strong>Pitfall: Circular Resource Dependencies</strong></p>\n<p>Scene files can inadvertently create circular references where Scene A references resources that depend on Scene B, which in turn references resources from Scene A. Reference counting systems cannot automatically clean up circular dependencies, leading to memory leaks.</p>\n<p><strong>Why this breaks</strong>: Resources involved in circular references never reach zero reference count, preventing automatic cleanup. Over multiple scene transitions, memory usage grows continuously until the application runs out of memory.</p>\n<p><strong>How to avoid</strong>: Design resource dependencies as a directed acyclic graph (DAG). Use dependency analysis tools during scene authoring to detect potential cycles, and implement explicit cleanup phases during scene transitions that break circular references.</p>\n<p>⚠️ <strong>Pitfall: GPU Resource Upload Without Context Validation</strong></p>\n<p>Loading resources asynchronously requires transferring data to GPU memory using OpenGL calls, but these calls are only valid when the correct graphics context is active. Background loading threads often lack proper graphics context setup.</p>\n<p><strong>Why this breaks</strong>: OpenGL calls from threads without active contexts either fail silently, cause graphics driver crashes, or corrupt GPU memory by writing to invalid locations.</p>\n<p><strong>How to avoid</strong>: Implement a <strong>two-stage loading process</strong>: background threads handle file I/O and decode asset data into CPU memory, then the main thread with active graphics context handles GPU resource upload during designated upload phases.</p>\n<p>⚠️ <strong>Pitfall: Scene Transition Atomicity Violations</strong></p>\n<p>Failing to implement atomic scene transitions can leave the game in partially-loaded states where some entities exist from the old scene while others belong to the new scene. This creates inconsistent game world state.</p>\n<p><strong>Why this breaks</strong>: Systems processing entities during partial transitions may encounter missing components, invalid references between entities from different scenes, or resource handles that point to unloaded assets.</p>\n<p><strong>How to avoid</strong>: Use the two-phase commit protocol for scene transitions: complete all loading and validation before making any changes to the active scene state. If any step fails, rollback to the previous consistent state rather than leaving the system in an intermediate configuration.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The resource management system represents the most complex subsystem in the game engine, requiring careful coordination between file I/O, memory management, GPU resource handling, and multi-threaded programming. This implementation provides complete working code for the infrastructure components while leaving the core resource management logic for learners to implement.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File I/O</td>\n<td>Standard C++ fstream</td>\n<td>Memory-mapped files with OS APIs</td>\n<td>fstream is portable but slower; mmap is faster but platform-specific</td>\n</tr>\n<tr>\n<td>JSON Parsing</td>\n<td>nlohmann::json library</td>\n<td>Custom parser with faster allocation</td>\n<td>nlohmann is full-featured but allocates heavily; custom parser needs more code</td>\n</tr>\n<tr>\n<td>Image Loading</td>\n<td>stb_image single-header library</td>\n<td>FreeImage or SOIL libraries</td>\n<td>stb_image is lightweight; other libraries support more formats</td>\n</tr>\n<tr>\n<td>Threading</td>\n<td>std::thread with std::mutex</td>\n<td>Lock-free queues and atomics</td>\n<td>Standard threading is easier to debug; lock-free is faster but complex</td>\n</tr>\n<tr>\n<td>GPU Upload</td>\n<td>OpenGL immediate calls</td>\n<td>Command buffers with batch upload</td>\n<td>Immediate calls are simple; batching reduces driver overhead</td>\n</tr>\n</tbody></table>\n<p>For an educational implementation, the simple options provide the best learning experience while avoiding unnecessary complexity in non-core areas.</p>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Resource Management Module Organization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">src</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── resource</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ResourceManager.h           ← Main resource cache </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> handle management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ResourceManager.cpp         ← Core </span><span style=\"color:#B392F0\">logic</span><span style=\"color:#E1E4E8\"> (learner implements)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ResourceHandle.h            ← Handle </span><span style=\"color:#B392F0\">implementation</span><span style=\"color:#E1E4E8\"> (provided)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ResourceHandle.cpp          ← Handle validation </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> encoding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── AssetLoaders.h              ← File format loading interfaces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── AssetLoaders.cpp            ← Texture, mesh, audio </span><span style=\"color:#B392F0\">loaders</span><span style=\"color:#E1E4E8\"> (provided)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ResourceTypes.h             ← Resource data structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── AsyncLoader.h               ← Background loading </span><span style=\"color:#B392F0\">system</span><span style=\"color:#E1E4E8\"> (provided)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── scene</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── Scene.h                     ← Scene data structure </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── Scene.cpp                   ← Scene </span><span style=\"color:#B392F0\">logic</span><span style=\"color:#E1E4E8\"> (learner implements)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── SceneSerializer.h           ← JSON</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">binary serialization interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── SceneSerializer.cpp         ← Serialization </span><span style=\"color:#B392F0\">logic</span><span style=\"color:#E1E4E8\"> (learner implements)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── SceneManager.h              ← Scene transition management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── common</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── Handle.h                    ← Generic handle </span><span style=\"color:#F97583\">template</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    └── ThreadSafeQueue.h           ← Queue </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> async loading</span></span></code></pre></div>\n\n<p>This organization separates the core learning challenges (resource management, scene serialization) from the supporting infrastructure that learners can use directly.</p>\n<h4 id=\"infrastructure-starter-code-complete\">Infrastructure Starter Code (Complete)</h4>\n<p><strong>Handle.h - Generic Handle Template</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> NULL_HANDLE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> TYPE_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> VERSION_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> ID_BITS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> TYPE_SHIFT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 48</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> VERSION_SHIFT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> ID_MASK </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFFFFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> VERSION_MASK </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> TYPE_MASK </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> m_handle;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Handle</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">m_handle</span><span style=\"color:#E1E4E8\">(NULL_HANDLE) {}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">m_handle</span><span style=\"color:#E1E4E8\">(handle) {}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> version</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> id</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">m_handle</span><span style=\"color:#E1E4E8\">(((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)type </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> TYPE_SHIFT) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)version </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> VERSION_SHIFT) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)id) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_handle </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> NULL_HANDLE; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_handle </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> ID_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#B392F0\"> GetVersion</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (m_handle </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> VERSION_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> VERSION_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#B392F0\"> GetType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (m_handle </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> TYPE_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TYPE_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#B392F0\"> GetHandle</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_handle; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_handle </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.m_handle; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_handle </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.m_handle; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Specific handle types with compile-time type safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ResourceType</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TEXTURE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MESH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AUDIO</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SCENE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TextureHandle</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TextureHandle</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TextureHandle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> version</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> id</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">static_cast&#x3C;uint16_t></span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ResourceType</span><span style=\"color:#E1E4E8\">::TEXTURE), version, id) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MeshHandle</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">MeshHandle</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MeshHandle</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MeshHandle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> version</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> id</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">static_cast&#x3C;uint16_t></span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ResourceType</span><span style=\"color:#E1E4E8\">::MESH), version, id) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AudioHandle</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">AudioHandle</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AudioHandle</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AudioHandle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> version</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> id</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">static_cast&#x3C;uint16_t></span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ResourceType</span><span style=\"color:#E1E4E8\">::AUDIO), version, id) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SceneHandle</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">SceneHandle</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SceneHandle</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SceneHandle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> version</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> id</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">static_cast&#x3C;uint16_t></span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ResourceType</span><span style=\"color:#E1E4E8\">::SCENE), version, id) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>AssetLoaders.h - File Format Loading</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> TextureData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint8_t></span><span style=\"color:#E1E4E8\"> pixels;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> width;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> height;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> channels;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> MeshData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;float></span><span style=\"color:#E1E4E8\"> vertices;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> indices;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> vertexCount;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> indexCount;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> AudioData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;float></span><span style=\"color:#E1E4E8\"> samples;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sampleRate;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> channels;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> duration;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete image loading implementation using stb_image</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ImageLoader</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> LoadPNG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">TextureData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> output</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> LoadJPEG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">TextureData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> output</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> LoadImage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">TextureData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> output</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // Auto-detect format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete mesh loading implementation using tinyobjloader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MeshLoader</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> LoadOBJ</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">MeshData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> output</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete audio loading implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AudioLoader</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> LoadWAV</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">AudioData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> output</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> LoadOGG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">AudioData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> output</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>ThreadSafeQueue.h - Async Loading Infrastructure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;mutex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;condition_variable></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ThreadSafeQueue</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_queue;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mutable</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::mutex m_mutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::condition_variable m_condition;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> item</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_queue.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">(item);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_condition.</span><span style=\"color:#B392F0\">notify_one</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> TryPop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> item</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (m_queue.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        item </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_queue.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_queue.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> WaitAndPop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> item</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_condition.</span><span style=\"color:#B392F0\">wait</span><span style=\"color:#E1E4E8\">(lock, [</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">] { </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">m_queue.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">(); });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        item </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_queue.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_queue.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Empty</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> m_queue.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> Size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> m_queue.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-learner-implementation\">Core Logic Skeleton (Learner Implementation)</h4>\n<p><strong>ResourceManager.h - Core Resource Management Interface</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"ResourceHandle.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"AssetLoaders.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"ThreadSafeQueue.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;atomic></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;thread></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> TextureResource</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> textureID;</span><span style=\"color:#6A737D\">  // OpenGL texture object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> width, height;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> version;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> referenceCount;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string filepath;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> MeshResource</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> VAO, VBO, EBO;</span><span style=\"color:#6A737D\">  // OpenGL vertex array and buffer objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> vertexCount, indexCount;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> version;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> referenceCount;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string filepath;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> LoadingState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Unloaded</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Loading</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Loaded</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> LoadRequest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string filepath;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceType type;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> success)</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> callback;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> priority;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ResourceManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource storage pools</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">TextureResource</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_textures;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">MeshResource</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_meshes;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">AudioResource</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_audioClips;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle management</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, TextureHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_textureHandles;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, MeshHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_meshHandles;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, AudioHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_audioHandles;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Async loading infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ThreadSafeQueue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">LoadRequest</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_loadQueue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::thread</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_workerThreads;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;bool></span><span style=\"color:#E1E4E8\"> m_shouldStop;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Thread safety</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_textureMutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_meshMutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_audioMutex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ResourceManager</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~ResourceManager</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Core resource loading interface</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TextureHandle</span><span style=\"color:#B392F0\"> LoadTexture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MeshHandle</span><span style=\"color:#B392F0\"> LoadMesh</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AudioHandle</span><span style=\"color:#B392F0\"> LoadAudio</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Async loading with callbacks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> LoadTextureAsync</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> LoadMeshAsync</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">MeshHandle</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> LoadAudioAsync</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">AudioHandle</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource access and validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TextureResource</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetTexture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MeshResource</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetMesh</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">MeshHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AudioResource</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetAudio</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">AudioHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">MeshHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">AudioHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Reference counting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">MeshHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">AudioHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">MeshHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">AudioHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cleanup and maintenance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RunGarbageCollection</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ProcessAsyncUploads</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialization and shutdown</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement these core methods</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TextureHandle</span><span style=\"color:#B392F0\"> CreateTextureHandle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MeshHandle</span><span style=\"color:#B392F0\"> CreateMeshHandle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AudioHandle</span><span style=\"color:#B392F0\"> CreateAudioHandle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> WorkerThreadFunction</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ProcessLoadRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> LoadRequest</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> LoadTextureFromFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">TextureResource</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> resource</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> LoadMeshFromFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">MeshResource</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> resource</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> LoadAudioFromFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">AudioResource</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> resource</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> UploadTextureToGPU</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> TextureData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">TextureResource</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> resource</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> UploadMeshToGPU</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> MeshData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">MeshResource</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> resource</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Core Resource Manager Implementation (Learner Implements)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ResourceManager.cpp - Core methods for learner to implement</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#B392F0\"> ResourceManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">LoadTexture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if texture is already loaded in m_textureHandles map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If found, increment reference count and return existing handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If not found, create new TextureResource entry in m_textures vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Load texture data from file using ImageLoader::LoadImage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Upload texture data to GPU using UploadTextureToGPU</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create TextureHandle with version and ID, store in m_textureHandles map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Set reference count to 1 and return handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use std::lock_guard&#x3C;std::mutex> for thread safety</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> ResourceManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">IsValid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract ID and version from handle using GetID() and GetVersion()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if ID is within bounds of m_textures vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare handle version with stored version in TextureResource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return true only if both bounds check and version check pass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Invalid handles have ID 0 or version mismatch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> ResourceManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">RemoveReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate handle using IsValid() - return early if invalid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Get TextureResource using handle ID as index into m_textures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Atomically decrement reference count using fetch_sub(1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If reference count reaches 0, mark resource for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Consider immediate cleanup vs deferred garbage collection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use atomic operations to avoid race conditions with other threads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> ResourceManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">WorkerThreadFunction</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Loop while m_shouldStop is false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait for load request from m_loadQueue using WaitAndPop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Process request based on ResourceType (TEXTURE, MESH, AUDIO)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Load file data using appropriate loader (ImageLoader, MeshLoader, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Signal main thread that GPU upload is ready</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Invoke completion callback with success/failure result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Worker threads only do file I/O, GPU upload happens on main thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> ResourceManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">ProcessAsyncUploads</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check queue of completed file loads waiting for GPU upload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each completed load, upload data to GPU (OpenGL calls)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update resource state from Loading to Loaded or Error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Store GPU resource IDs (texture ID, VAO, etc.) in resource struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Invoke any completion callbacks waiting for this resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: This method runs on main thread with active OpenGL context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Scene.h - Scene Data Structure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../ecs/ECSWorld.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"ResourceHandle.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;nlohmann/json.hpp></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> SceneMetadata</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string name;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string version;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string engineVersion;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> requiredResources;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Scene</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SceneMetadata m_metadata;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_entities;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, TextureHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_textureReferences;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, MeshHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_meshReferences;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, AudioHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_audioReferences;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Scene</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~Scene</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> GetEntities</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_entities; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource references</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddResourceReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddResourceReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">MeshHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddResourceReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">AudioHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Serialization interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> SaveToFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> LoadFromFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ResourceManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> resources</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // JSON conversion</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    nlohmann</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">json</span><span style=\"color:#B392F0\"> ToJSON</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> FromJSON</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> nlohmann</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">json</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> json</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ResourceManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> resources</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Metadata access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> SceneMetadata</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> GetMetadata</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_metadata; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetMetadata</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> SceneMetadata</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> metadata</span><span style=\"color:#E1E4E8\">) { m_metadata </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> metadata; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Scene Implementation (Learner Implements)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Scene.cpp - Serialization methods for learner to implement</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> Scene</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">SaveToFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create JSON object using ToJSON method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Open output file stream for writing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Write JSON data to file with proper formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Ensure file is properly closed and handle write errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return true on success, false on any error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use std::ofstream and check file.good() for error handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nlohmann</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">json</span><span style=\"color:#B392F0\"> Scene</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">ToJSON</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    nlohmann</span><span style=\"color:#E1E4E8\">::json sceneJson;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Serialize scene metadata (name, version, engine version)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Build resource manifest by collecting all resource references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Iterate through m_entities and serialize each entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each entity, get all components and serialize them</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Convert resource handles back to asset path strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle component polymorphism using type registration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use world.GetComponent&#x3C;T>() to retrieve components by type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> Scene</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">FromJSON</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> nlohmann</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">json</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> json</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ResourceManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> resources</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse and validate scene metadata from JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Preload all resources listed in the resource manifest</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create entities with the correct IDs from serialized data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each entity, deserialize and attach all components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Resolve resource path strings back to valid handles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate that all entity references are satisfied</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return false if any step fails, true on complete success</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check that all required resources loaded successfully before creating entities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>C++ Resource Management:</strong></p>\n<ul>\n<li>Use <code>std::unique_ptr</code> for automatic cleanup of resource data structures</li>\n<li>Implement RAII (Resource Acquisition Is Initialization) pattern for GPU resources</li>\n<li>Use <code>std::atomic&lt;uint32_t&gt;</code> for thread-safe reference counting without mutex overhead</li>\n<li>Call <code>glGenTextures</code>, <code>glBindTexture</code>, <code>glTexImage2D</code> for texture uploads</li>\n<li>Call <code>glGenBuffers</code>, <code>glBindBuffer</code>, <code>glBufferData</code> for mesh uploads</li>\n<li>Use <code>std::lock_guard&lt;std::mutex&gt;</code> for automatic lock management</li>\n</ul>\n<p><strong>OpenGL Integration:</strong></p>\n<ul>\n<li>Check <code>glGetError()</code> after each OpenGL call during development</li>\n<li>Use <code>GL_RGBA8</code> internal format for texture uploads</li>\n<li>Generate mipmaps with <code>glGenerateMipmap(GL_TEXTURE_2D)</code> for distance-based filtering</li>\n<li>Store OpenGL object IDs (texture, VBO, VAO) in resource structures</li>\n<li>Call <code>glDeleteTextures</code>, <code>glDeleteBuffers</code> during resource cleanup</li>\n</ul>\n<p><strong>JSON Serialization with nlohmann::json:</strong></p>\n<ul>\n<li>Use <code>json[&quot;key&quot;] = value</code> syntax for simple value assignment  </li>\n<li>Use <code>json.contains(&quot;key&quot;)</code> to check for optional fields before access</li>\n<li>Handle missing or malformed JSON gracefully with try/catch blocks</li>\n<li>Use <code>json.dump(4)</code> for pretty-printed output with 4-space indentation</li>\n<li>Convert handles to strings with <code>std::to_string(handle.GetID())</code></li>\n</ul>\n<p><strong>Threading and Async Loading:</strong></p>\n<ul>\n<li>Create worker threads in ResourceManager constructor, join in destructor</li>\n<li>Use <code>std::this_thread::sleep_for()</code> to avoid busy-waiting in worker threads</li>\n<li>Signal main thread using <code>std::condition_variable</code> when uploads are ready</li>\n<li>Only make OpenGL calls from the main thread with active graphics context</li>\n<li>Use <code>std::atomic&lt;bool&gt;</code> for thread-safe shutdown signaling</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing ResourceManager core methods:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic resource loading</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./engine_test</span><span style=\"color:#79B8FF\"> --test_resource_loading</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Expected</span><span style=\"color:#9ECBFF\"> output:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Texture</span><span style=\"color:#9ECBFF\"> loading:</span><span style=\"color:#9ECBFF\"> player.png</span><span style=\"color:#E1E4E8\"> (512x512, </span><span style=\"color:#9ECBFF\">handle=</span><span style=\"color:#79B8FF\">0x100001</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Handle</span><span style=\"color:#9ECBFF\"> validation:</span><span style=\"color:#9ECBFF\"> valid</span><span style=\"color:#9ECBFF\"> handle</span><span style=\"color:#9ECBFF\"> returns</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Handle</span><span style=\"color:#9ECBFF\"> validation:</span><span style=\"color:#9ECBFF\"> invalid</span><span style=\"color:#9ECBFF\"> handle</span><span style=\"color:#9ECBFF\"> returns</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Reference</span><span style=\"color:#9ECBFF\"> counting:</span><span style=\"color:#9ECBFF\"> increment/decrement</span><span style=\"color:#9ECBFF\"> works</span><span style=\"color:#9ECBFF\"> correctly</span></span></code></pre></div>\n\n<p><strong>After implementing async loading system:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test background loading without frame hitches</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./engine_test</span><span style=\"color:#79B8FF\"> --test_async_loading</span><span style=\"color:#79B8FF\"> --monitor_framerate</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Expected</span><span style=\"color:#9ECBFF\"> output:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Started</span><span style=\"color:#9ECBFF\"> loading</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#9ECBFF\"> textures</span><span style=\"color:#9ECBFF\"> asynchronously</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Frame</span><span style=\"color:#9ECBFF\"> rate</span><span style=\"color:#9ECBFF\"> maintained</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\">55fps</span><span style=\"color:#9ECBFF\"> during</span><span style=\"color:#9ECBFF\"> loading</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> All</span><span style=\"color:#9ECBFF\"> textures</span><span style=\"color:#9ECBFF\"> loaded</span><span style=\"color:#9ECBFF\"> successfully</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> No</span><span style=\"color:#9ECBFF\"> memory</span><span style=\"color:#9ECBFF\"> leaks</span><span style=\"color:#9ECBFF\"> detected</span></span></code></pre></div>\n\n<p><strong>After implementing scene serialization:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test scene save/load roundtrip</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./engine_test</span><span style=\"color:#79B8FF\"> --test_scene_serialization</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Expected</span><span style=\"color:#9ECBFF\"> output:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Created</span><span style=\"color:#9ECBFF\"> scene</span><span style=\"color:#9ECBFF\"> with</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#9ECBFF\"> entities,</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#9ECBFF\"> components</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Saved</span><span style=\"color:#9ECBFF\"> scene</span><span style=\"color:#9ECBFF\"> to</span><span style=\"color:#9ECBFF\"> test_scene.json</span><span style=\"color:#E1E4E8\"> (45.2 </span><span style=\"color:#9ECBFF\">KB</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> Loaded</span><span style=\"color:#9ECBFF\"> scene</span><span style=\"color:#9ECBFF\"> successfully,</span><span style=\"color:#9ECBFF\"> entity</span><span style=\"color:#9ECBFF\"> count</span><span style=\"color:#9ECBFF\"> matches</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> All</span><span style=\"color:#9ECBFF\"> component</span><span style=\"color:#9ECBFF\"> data</span><span style=\"color:#9ECBFF\"> matches</span><span style=\"color:#9ECBFF\"> original</span><span style=\"color:#9ECBFF\"> values</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">✓</span><span style=\"color:#9ECBFF\"> All</span><span style=\"color:#9ECBFF\"> resource</span><span style=\"color:#9ECBFF\"> handles</span><span style=\"color:#9ECBFF\"> resolved</span><span style=\"color:#9ECBFF\"> correctly</span></span></code></pre></div>\n\n<p><strong>Signs of problems and debugging:</strong></p>\n<ul>\n<li><strong>Black textures</strong>: Check that image loading succeeded and data uploaded to correct OpenGL texture ID</li>\n<li><strong>Crashes during cleanup</strong>: Verify reference counting prevents access to freed resources  </li>\n<li><strong>Memory leaks</strong>: Check that RemoveReference decrements correctly and cleanup occurs</li>\n<li><strong>Loading hangs</strong>: Ensure worker threads process requests and main thread handles uploads</li>\n<li><strong>Scene corruption</strong>: Validate JSON structure and handle loading failures gracefully</li>\n</ul>\n<p>The resource and scene management system represents the foundation for all content in your game engine. Take time to implement each component thoroughly—the complexity invested here pays dividends in reliability and performance throughout the rest of the engine development process.</p>\n<h2 id=\"system-interactions-and-data-flow\">System Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — understanding system interactions is critical throughout development as subsystems are built incrementally and must coordinate effectively</p>\n</blockquote>\n<p>Understanding how engine subsystems communicate is like orchestrating a <strong>symphony orchestra</strong>. Each section (rendering, physics, ECS, resource management) plays its own part with specialized instruments and timing, but they must coordinate through a conductor (the main game loop) to create harmonious gameplay. Without proper coordination, you get cacophony—frame drops, visual glitches, physics explosions, and resource leaks. The conductor ensures each section plays at the right tempo, responds to cues from other sections, and maintains perfect timing even when individual musicians (systems) encounter difficulties.</p>\n<p>The complexity arises because game engines operate under strict real-time constraints. Unlike web applications where a slow database query might add a few hundred milliseconds to response time, a game engine has exactly 16.67 milliseconds to process input, update game state, simulate physics, and render a frame. Miss this deadline, and players immediately notice stuttering, input lag, or visual artifacts. This temporal pressure shapes every aspect of how systems interact and communicate.</p>\n<h3 id=\"frame-processing-lifecycle\">Frame Processing Lifecycle</h3>\n<p>The <strong>frame processing lifecycle</strong> is the heartbeat of the game engine—a carefully choreographed sequence that repeats 60 times per second. Think of it as a <strong>factory assembly line</strong> where each station (subsystem) has specific responsibilities, operates on a fixed schedule, and passes work to the next station. The assembly line must maintain constant throughput regardless of variations in workload, and any station that falls behind affects the entire production schedule.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fframe-processing-flow.svg\" alt=\"Frame Processing Pipeline\"></p>\n<p>The frame lifecycle consists of five distinct phases, each with specific timing constraints and data dependencies. Understanding the order and timing of these phases is crucial because violating dependencies or exceeding time budgets leads to visible performance problems.</p>\n<h4 id=\"phase-1-input-processing-and-event-handling\">Phase 1: Input Processing and Event Handling</h4>\n<p>The frame begins with <strong>input processing</strong>, where the engine polls the operating system for user input events, window events, and system notifications. This phase acts like a <strong>mail sorting facility</strong>—collecting all incoming messages, categorizing them by type, and routing them to appropriate handlers. The Window system takes primary responsibility for this phase, interfacing directly with SDL2 or GLFW to retrieve events from the OS event queue.</p>\n<p>Input processing must complete within the first 1-2 milliseconds of the frame to ensure responsive controls. The Window system performs several critical operations:</p>\n<ol>\n<li><strong>Event Polling</strong>: The <code>PollEvents()</code> method retrieves all queued events from the OS, including keyboard presses, mouse movements, window resize notifications, and system messages</li>\n<li><strong>Event Classification</strong>: Each event gets categorized by type and priority—immediate events like window close requests get processed immediately, while gameplay input gets queued for the ECS systems</li>\n<li><strong>Input State Updates</strong>: Current keyboard and mouse state gets updated in global input managers, providing systems with immediate access to &quot;is key pressed&quot; queries</li>\n<li><strong>Event Distribution</strong>: Events get distributed to registered listeners through callback mechanisms or event queues, allowing systems to respond to relevant input</li>\n</ol>\n<p>The Window system maintains several critical data structures during input processing:</p>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_eventQueue</code></td>\n<td><code>vector&lt;InputEvent&gt;</code></td>\n<td>Stores processed input events for ECS systems</td>\n</tr>\n<tr>\n<td><code>m_keyboardState</code></td>\n<td><code>array&lt;bool, 256&gt;</code></td>\n<td>Current state of all keyboard keys</td>\n</tr>\n<tr>\n<td><code>m_mouseState</code></td>\n<td><code>MouseState</code></td>\n<td>Current mouse position and button states</td>\n</tr>\n<tr>\n<td><code>m_resizeCallback</code></td>\n<td><code>ResizeCallback</code></td>\n<td>Callback for window resize events</td>\n</tr>\n<tr>\n<td><code>m_closeRequested</code></td>\n<td><code>bool</code></td>\n<td>Flag indicating application should terminate</td>\n</tr>\n</tbody></table>\n<p>Input processing includes several error handling considerations. Network disconnections for multiplayer games, gamepad disconnections, or window focus changes all require graceful handling without disrupting the frame pipeline.</p>\n<h4 id=\"phase-2-ecs-world-update-and-system-execution\">Phase 2: ECS World Update and System Execution</h4>\n<p>Following input processing, the <strong>ECS world update</strong> phase processes all game logic through the registered system pipeline. This phase resembles a <strong>data processing factory</strong> where specialized machines (systems) operate on conveyor belts of component data, transforming entity state according to game rules. The ECSWorld coordinates this phase, ensuring systems execute in dependency order and receive accurate delta time information.</p>\n<p>The system execution phase typically consumes 8-10 milliseconds of the 16.67-millisecond frame budget, making it the most time-critical phase. The ECSWorld orchestrates system execution through several mechanisms:</p>\n<ol>\n<li><strong>System Dependency Resolution</strong>: Systems execute in predetermined order based on data dependencies—input systems run before movement systems, movement systems run before animation systems</li>\n<li><strong>Component Query Processing</strong>: Each system queries for entities matching its component signature, receiving dense arrays of component data for cache-efficient iteration</li>\n<li><strong>Delta Time Propagation</strong>: All systems receive the current frame&#39;s delta time, ensuring frame-rate-independent behavior</li>\n<li><strong>Cross-System Communication</strong>: Systems communicate through component modifications, event queues, or shared state managers</li>\n</ol>\n<p>The ECSWorld maintains execution metadata throughout the update phase:</p>\n<table>\n<thead>\n<tr>\n<th>Execution Data</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_systemRegistry</code></td>\n<td><code>vector&lt;unique_ptr&lt;System&gt;&gt;</code></td>\n<td>All registered systems in execution order</td>\n</tr>\n<tr>\n<td><code>m_frameTime</code></td>\n<td><code>float</code></td>\n<td>Delta time for current frame</td>\n</tr>\n<tr>\n<td><code>m_componentQueries</code></td>\n<td><code>QueryCache</code></td>\n<td>Cached entity lists for common component signatures</td>\n</tr>\n<tr>\n<td><code>m_systemTimings</code></td>\n<td><code>map&lt;SystemID, float&gt;</code></td>\n<td>Performance profiling data for each system</td>\n</tr>\n<tr>\n<td><code>m_eventBus</code></td>\n<td><code>EventBus</code></td>\n<td>Inter-system communication channel</td>\n</tr>\n</tbody></table>\n<p>System execution involves careful memory management and performance monitoring. Each system&#39;s execution time gets tracked to identify performance bottlenecks, and memory allocations are minimized through object pooling and component reuse strategies.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: The ECS update phase determines frame rate stability more than any other phase. A single poorly optimized system that takes 20 milliseconds will cause visible stuttering regardless of how efficiently other systems perform.</p>\n</blockquote>\n<h4 id=\"phase-3-physics-simulation-with-fixed-timestep\">Phase 3: Physics Simulation with Fixed Timestep</h4>\n<p>The <strong>physics simulation phase</strong> advances the physical world using a fixed timestep accumulator pattern, decoupling physics determinism from rendering frame rate. Think of this as a <strong>precision clockwork mechanism</strong>—it ticks at exactly 60Hz regardless of whether the overall frame runs at 30fps, 60fps, or 120fps. This phase typically runs after ECS updates but before rendering, ensuring visual output reflects the most recent physics state.</p>\n<p>Physics simulation uses a fundamentally different timing model than other engine systems. While rendering and ECS updates use variable delta time (the actual time elapsed since last frame), physics uses a fixed timestep to ensure deterministic, reproducible simulation. The physics system maintains a time accumulator that tracks how much &quot;physics time&quot; needs processing:</p>\n<ol>\n<li><strong>Accumulator Management</strong>: The current frame&#39;s delta time gets added to a time accumulator, representing physics simulation debt</li>\n<li><strong>Fixed Timestep Processing</strong>: While the accumulator contains at least <code>PHYSICS_TIMESTEP</code> seconds (typically 1/60th second), the physics world advances by exactly that amount</li>\n<li><strong>Multiple Physics Steps</strong>: High frame rates may process multiple physics steps per frame, while low frame rates process fractional steps</li>\n<li><strong>Interpolation</strong>: Rendering systems interpolate between physics positions to smooth visual motion at arbitrary frame rates</li>\n</ol>\n<p>The physics system maintains several timing-critical data structures:</p>\n<table>\n<thead>\n<tr>\n<th>Physics Timing Data</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_accumulator</code></td>\n<td><code>float</code></td>\n<td>Time debt requiring physics processing</td>\n</tr>\n<tr>\n<td><code>m_fixedTimestep</code></td>\n<td><code>float</code></td>\n<td>Constant time increment (typically 1/60 second)</td>\n</tr>\n<tr>\n<td><code>m_maxAccumulator</code></td>\n<td><code>float</code></td>\n<td>Maximum accumulated time to prevent spiral of death</td>\n</tr>\n<tr>\n<td><code>m_interpolationFactor</code></td>\n<td><code>float</code></td>\n<td>Blending factor for smooth rendering</td>\n</tr>\n<tr>\n<td><code>m_stepCount</code></td>\n<td><code>int</code></td>\n<td>Number of physics steps processed this frame</td>\n</tr>\n</tbody></table>\n<p>The physics simulation phase includes collision detection and response, which involves complex spatial queries and geometric computations. The collision system maintains spatial partitioning structures (grids or quadtrees) that require incremental updates as entities move through space.</p>\n<p><strong>Decision: Fixed vs Variable Timestep Physics</strong></p>\n<ul>\n<li><strong>Context</strong>: Physics simulation can use either variable delta time (matching frame rate) or fixed timestep (constant time increment)</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Variable timestep: Simple implementation, matches rendering frame rate</li>\n<li>Fixed timestep with accumulator: More complex, deterministic behavior</li>\n<li>Hybrid approach: Fixed physics with variable rendering interpolation</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Fixed timestep with accumulator pattern</li>\n<li><strong>Rationale</strong>: Deterministic physics behavior is essential for gameplay consistency, network synchronization, and replay systems. Variable timestep physics produces different results on different hardware, making debugging and testing nearly impossible</li>\n<li><strong>Consequences</strong>: Added complexity in time management, but ensures consistent behavior across all hardware and frame rates</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Timestep Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Variable</td>\n<td>Simple implementation, lower input lag</td>\n<td>Non-deterministic, hardware-dependent behavior</td>\n</tr>\n<tr>\n<td>Fixed</td>\n<td>Deterministic, consistent across hardware</td>\n<td>More complex timing, potential frame rate coupling</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Best visual quality with deterministic physics</td>\n<td>Most complex implementation</td>\n</tr>\n</tbody></table>\n<h4 id=\"phase-4-rendering-pipeline-execution\">Phase 4: Rendering Pipeline Execution</h4>\n<p>The <strong>rendering phase</strong> transforms the current world state into visual output, operating like a <strong>3D photography studio</strong> with multiple stages of scene preparation, lighting setup, and final image composition. The Renderer coordinates this phase, collecting visual data from ECS components, organizing it for efficient GPU processing, and issuing draw commands that produce the final frame. This phase typically consumes 4-6 milliseconds on modern hardware but can vary dramatically based on scene complexity.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Frendering-pipeline.svg\" alt=\"Graphics Rendering Pipeline\"></p>\n<p>Rendering operates on snapshot data from the completed ECS and physics updates, ensuring visual consistency throughout the frame. The rendering pipeline processes visual data through several stages:</p>\n<ol>\n<li><strong>Scene Culling</strong>: The Renderer queries the ECSWorld for all entities with visual components (<code>Transform</code>, <code>Sprite</code>, <code>Mesh</code>), filtering out objects outside the camera frustum</li>\n<li><strong>Depth Sorting</strong>: Visual elements get sorted by depth/layer to ensure correct drawing order and optimal GPU state management</li>\n<li><strong>Batch Preparation</strong>: Similar rendering operations get grouped together to minimize GPU state changes and draw calls</li>\n<li><strong>GPU Command Generation</strong>: The BatchRenderer generates vertex buffers, sets shader uniforms, and issues draw calls to the graphics API</li>\n<li><strong>Frame Presentation</strong>: The completed frame gets presented through the Window system&#39;s swap chain</li>\n</ol>\n<p>The rendering phase maintains several performance-critical data structures:</p>\n<table>\n<thead>\n<tr>\n<th>Rendering Data</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_renderQueue</code></td>\n<td><code>vector&lt;RenderCommand&gt;</code></td>\n<td>GPU commands sorted by state changes</td>\n</tr>\n<tr>\n<td><code>m_activeBatch</code></td>\n<td><code>BatchData</code></td>\n<td>Current geometry batch being assembled</td>\n</tr>\n<tr>\n<td><code>m_viewMatrix</code></td>\n<td><code>Matrix4</code></td>\n<td>Camera transformation for world-to-screen projection</td>\n</tr>\n<tr>\n<td><code>m_visibleEntities</code></td>\n<td><code>vector&lt;Entity&gt;</code></td>\n<td>Entities within camera frustum</td>\n</tr>\n<tr>\n<td><code>m_frameStats</code></td>\n<td><code>RenderStats</code></td>\n<td>Performance metrics for current frame</td>\n</tr>\n</tbody></table>\n<p>The rendering system interfaces heavily with the Resource Manager during this phase, requesting textures, shaders, and mesh data through handle-based access. These resource requests must complete immediately since rendering operates under strict timing constraints.</p>\n<h4 id=\"phase-5-frame-finalization-and-timing-control\">Phase 5: Frame Finalization and Timing Control</h4>\n<p>The final phase handles <strong>frame finalization</strong>—presenting the completed frame to screen, updating timing statistics, and preparing for the next frame cycle. This phase operates like a <strong>quality control checkpoint</strong> in the assembly line, ensuring the finished product meets timing requirements before releasing it to consumers (players). The Application class coordinates this phase, working with the Window system and FrameTimer to maintain consistent frame pacing.</p>\n<p>Frame finalization involves several critical operations:</p>\n<ol>\n<li><strong>Buffer Swapping</strong>: The Window system&#39;s <code>SwapBuffers()</code> method presents the completed frame and switches to the next render target</li>\n<li><strong>V-Sync Coordination</strong>: If vertical synchronization is enabled, the system waits for display refresh to prevent screen tearing</li>\n<li><strong>Timing Updates</strong>: The FrameTimer calculates the actual frame duration and updates delta time for the next frame</li>\n<li><strong>Performance Monitoring</strong>: Frame timing statistics get updated for performance analysis and debugging</li>\n<li><strong>Memory Cleanup</strong>: Temporary allocations from the current frame get released, and garbage collection runs if needed</li>\n</ol>\n<p>The frame finalization phase maintains timing and performance data:</p>\n<table>\n<thead>\n<tr>\n<th>Finalization Data</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_frameCounter</code></td>\n<td><code>uint64_t</code></td>\n<td>Total frames rendered since startup</td>\n</tr>\n<tr>\n<td><code>m_averageFrameTime</code></td>\n<td><code>float</code></td>\n<td>Rolling average of recent frame durations</td>\n</tr>\n<tr>\n<td><code>m_frameTiming</code></td>\n<td><code>RingBuffer&lt;float&gt;</code></td>\n<td>Recent frame times for analysis</td>\n</tr>\n<tr>\n<td><code>m_performanceStats</code></td>\n<td><code>FrameStats</code></td>\n<td>Detailed timing breakdown by phase</td>\n</tr>\n<tr>\n<td><code>m_vsyncEnabled</code></td>\n<td><code>bool</code></td>\n<td>Whether vertical synchronization is active</td>\n</tr>\n</tbody></table>\n<h4 id=\"frame-lifecycle-error-handling\">Frame Lifecycle Error Handling</h4>\n<p>Each phase of the frame lifecycle includes specific error handling mechanisms to ensure graceful degradation rather than catastrophic failure. The frame processing pipeline implements several resilience strategies:</p>\n<p><strong>Input Processing Errors</strong>: Device disconnections or invalid input events get logged but don&#39;t interrupt frame processing. Missing input devices get detected and handled through fallback input methods.</p>\n<p><strong>ECS Update Errors</strong>: System execution exceptions get caught and logged, allowing other systems to continue processing. Malformed component data gets validated and corrected where possible.</p>\n<p><strong>Physics Simulation Errors</strong>: Numerical instability or collision detection failures trigger fallback behaviors like entity separation or velocity clamping. The physics system includes debugging modes that visualize problematic interactions.</p>\n<p><strong>Rendering Errors</strong>: Shader compilation failures, texture loading errors, or GPU driver issues trigger fallback rendering paths using basic shaders and default textures. The rendering system maintains error state that prevents cascading failures.</p>\n<p><strong>Timing Errors</strong>: Frame rate drops or system suspension get handled through the accumulator pattern, preventing physics simulation from becoming unstable during temporary performance problems.</p>\n<h3 id=\"inter-system-communication\">Inter-System Communication</h3>\n<p>Systems within a game engine must coordinate and exchange information while maintaining loose coupling and performance efficiency. This coordination resembles a <strong>corporate communication network</strong> where different departments (systems) need to share information and coordinate actions without creating bottlenecks or dependencies that slow down operations. The key challenge is enabling rich communication while preserving the performance benefits of data-oriented design and avoiding the coupling problems that plague traditional object-oriented architectures.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"Engine System Architecture\"></p>\n<p>Game engine systems communicate through several complementary mechanisms, each optimized for different types of interactions and timing requirements. The communication architecture balances immediate responsiveness for critical interactions with deferred processing for non-urgent coordination.</p>\n<h4 id=\"component-based-state-sharing\">Component-Based State Sharing</h4>\n<p>The primary communication mechanism between systems occurs through <strong>shared component state</strong> within the ECS architecture. This approach treats components as a <strong>shared database</strong> where systems read and write specific data fields to coordinate behavior. Components act as communication contracts—when one system modifies a component, other systems that query for that component type automatically see the updated state during their execution.</p>\n<p>Component-based communication provides several advantages for game engine architectures. It maintains data locality by keeping related information together in component arrays, enables efficient batch processing of similar operations, and provides automatic state synchronization without explicit message passing overhead. Systems remain loosely coupled because they depend only on component interfaces, not on specific system implementations.</p>\n<p>Common component-based communication patterns include:</p>\n<p><strong>Transform Propagation</strong>: The physics system updates <code>RigidBody</code> velocity and the <code>Transform</code> position, while the rendering system reads <code>Transform</code> data to position visual elements. This creates automatic coordination between physics simulation and visual representation without direct system dependencies.</p>\n<p><strong>Animation State Sharing</strong>: Animation systems modify <code>Transform</code> and <code>Sprite</code> components to represent current animation frames, while physics systems read these values to maintain collision shape alignment with visual appearance.</p>\n<p><strong>Health and Damage Communication</strong>: Combat systems modify <code>Health</code> components to represent damage effects, while UI systems read <code>Health</code> components to update health bars, and AI systems use health values for decision making.</p>\n<p>The ECS architecture provides efficient component access through query systems:</p>\n<table>\n<thead>\n<tr>\n<th>Communication Pattern</th>\n<th>Read Components</th>\n<th>Write Components</th>\n<th>Systems Involved</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Physics-Rendering Sync</td>\n<td><code>Transform</code>, <code>RigidBody</code></td>\n<td><code>Transform</code></td>\n<td>Physics, Rendering</td>\n</tr>\n<tr>\n<td>Animation Updates</td>\n<td><code>Transform</code>, <code>AnimationState</code></td>\n<td><code>Transform</code>, <code>Sprite</code></td>\n<td>Animation, Rendering</td>\n</tr>\n<tr>\n<td>Combat Resolution</td>\n<td><code>Health</code>, <code>Damage</code></td>\n<td><code>Health</code>, <code>CombatState</code></td>\n<td>Combat, AI, UI</td>\n</tr>\n<tr>\n<td>Input Processing</td>\n<td><code>InputComponent</code></td>\n<td><code>Movement</code>, <code>Transform</code></td>\n<td>Input, Movement</td>\n</tr>\n</tbody></table>\n<p>Component-based communication includes timing considerations because system execution order determines which systems see updated component state during each frame. The ECSWorld ensures systems execute in dependency order to maintain consistent data flow.</p>\n<h4 id=\"event-queue-architecture\">Event Queue Architecture</h4>\n<p>For <strong>asynchronous communication</strong> and <strong>decoupled notifications</strong>, the engine implements an event queue system that enables systems to broadcast information without knowing which systems need to receive it. This approach functions like a <strong>company-wide bulletin board</strong> where departments can post announcements that other departments check and respond to as needed. Event queues handle communications that don&#39;t require immediate response and help break circular dependencies between systems.</p>\n<p>The event system provides temporal decoupling—events posted during one frame get processed during subsequent frames, preventing immediate recursion and allowing systems to maintain clear execution phases. This temporal separation is crucial for maintaining deterministic behavior and avoiding cascade effects where one system&#39;s operation triggers another system, which triggers another, creating unpredictable execution patterns.</p>\n<p>Event-based communication serves several specific use cases:</p>\n<p><strong>Entity Lifecycle Events</strong>: When entities are created or destroyed, the ECS system posts lifecycle events that allow other systems to perform cleanup or initialization without direct coupling to entity management code.</p>\n<p><strong>Collision Notifications</strong>: The physics system posts collision events when entities collide, allowing audio systems to play sound effects, particle systems to create visual effects, and gameplay systems to apply damage without the physics system knowing about these higher-level concepts.</p>\n<p><strong>Resource Loading Completion</strong>: The resource management system posts events when assets complete loading, allowing systems that depend on specific resources to respond appropriately.</p>\n<p><strong>User Interface Events</strong>: UI systems post events for button clicks, menu selections, and dialog responses, allowing gameplay systems to respond to player choices without UI systems depending on specific game logic.</p>\n<p>The event queue implementation maintains several key data structures:</p>\n<table>\n<thead>\n<tr>\n<th>Event System Data</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_eventQueue</code></td>\n<td><code>ThreadSafeQueue&lt;Event&gt;</code></td>\n<td>Queue of pending events for processing</td>\n</tr>\n<tr>\n<td><code>m_eventHandlers</code></td>\n<td><code>map&lt;EventType, vector&lt;Handler&gt;&gt;</code></td>\n<td>Registered handlers for each event type</td>\n</tr>\n<tr>\n<td><code>m_eventPool</code></td>\n<td><code>ObjectPool&lt;Event&gt;</code></td>\n<td>Memory pool for event allocation</td>\n</tr>\n<tr>\n<td><code>m_deferredEvents</code></td>\n<td><code>vector&lt;Event&gt;</code></td>\n<td>Events scheduled for future frames</td>\n</tr>\n</tbody></table>\n<p>Event processing occurs during specific phases of the frame lifecycle to ensure predictable timing and avoid mid-frame state changes that could cause inconsistent behavior.</p>\n<p><strong>Decision: Event Queue vs Direct System References</strong></p>\n<ul>\n<li><strong>Context</strong>: Systems need to communicate and coordinate without creating tight coupling or performance bottlenecks</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Direct system references: Systems hold pointers to other systems they need to communicate with</li>\n<li>Global event queue: Centralized event broadcasting with registration-based handling</li>\n<li>Component-only communication: All coordination through shared component state</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Hybrid approach using component-based communication for frequent updates and event queues for infrequent notifications</li>\n<li><strong>Rationale</strong>: Component-based communication provides optimal performance for high-frequency interactions like physics-rendering coordination, while event queues handle infrequent notifications without coupling systems</li>\n<li><strong>Consequences</strong>: Adds complexity through dual communication channels, but provides both performance and flexibility benefits</li>\n</ul>\n<h4 id=\"callback-and-observer-patterns\">Callback and Observer Patterns</h4>\n<p>For <strong>immediate response communication</strong> where systems need to react instantly to specific conditions, the engine implements callback and observer patterns. These mechanisms function like <strong>emergency notification systems</strong> that bypass normal communication channels when critical events require immediate attention. Callback-based communication typically handles resource loading completion, error conditions, and user input processing where delayed response would cause poor user experience.</p>\n<p>Callback patterns provide synchronous communication for situations where event queue delays would be problematic. Resource loading systems use callbacks to notify requesters immediately when assets become available, allowing rendering systems to update textures or models within the same frame. Input systems use callbacks to provide immediate response to critical input like pause requests or window close commands.</p>\n<p>The engine implements several callback mechanisms:</p>\n<p><strong>Resource Loading Callbacks</strong>: When systems request assets through the Resource Manager, they provide callback functions that execute immediately when loading completes, allowing seamless integration of new resources.</p>\n<p><strong>Window Event Callbacks</strong>: The Window system provides callbacks for resize events, focus changes, and close requests that require immediate response to maintain proper application behavior.</p>\n<p><strong>Physics Collision Callbacks</strong>: High-priority collision events like damage triggers or pickup detection use callbacks to ensure immediate response within the same physics timestep.</p>\n<p><strong>Error Condition Callbacks</strong>: Critical errors like graphics context loss or file system failures trigger callbacks that allow systems to initiate recovery procedures immediately.</p>\n<p>Callback registration and management requires careful lifetime management:</p>\n<table>\n<thead>\n<tr>\n<th>Callback Management</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_resourceCallbacks</code></td>\n<td><code>map&lt;Handle, function&lt;void(Resource*)&gt;&gt;</code></td>\n<td>Callbacks waiting for resource loading</td>\n</tr>\n<tr>\n<td><code>m_collisionCallbacks</code></td>\n<td><code>vector&lt;function&lt;void(CollisionPair)&gt;&gt;</code></td>\n<td>Physics collision response functions</td>\n</tr>\n<tr>\n<td><code>m_windowCallbacks</code></td>\n<td><code>WindowCallbackRegistry</code></td>\n<td>Window event response functions</td>\n</tr>\n<tr>\n<td><code>m_errorCallbacks</code></td>\n<td><code>vector&lt;function&lt;void(ErrorCode)&gt;&gt;</code></td>\n<td>Error recovery callback functions</td>\n</tr>\n</tbody></table>\n<h4 id=\"system-dependency-management\">System Dependency Management</h4>\n<p>Managing <strong>execution dependencies</strong> between systems ensures consistent data flow and prevents race conditions where systems access component data in inconsistent states. This coordination resembles <strong>project task scheduling</strong> where certain tasks must complete before others can begin, and the project manager (ECSWorld) ensures proper sequencing to avoid conflicts and maintain quality output.</p>\n<p>The ECSWorld maintains a <strong>system dependency graph</strong> that determines execution order based on component access patterns. Systems that write to components must execute before systems that read from those same components during the same frame. The dependency resolver analyzes component signatures to automatically determine safe execution orders.</p>\n<p>System dependency resolution involves several analysis phases:</p>\n<ol>\n<li><strong>Component Access Analysis</strong>: Each system declares which component types it reads and writes during registration</li>\n<li><strong>Dependency Graph Construction</strong>: The ECSWorld builds a directed graph where edges represent data dependencies between systems</li>\n<li><strong>Cycle Detection</strong>: The dependency analyzer checks for circular dependencies that would prevent consistent execution order</li>\n<li><strong>Topological Sorting</strong>: Systems get sorted into execution order that respects all data dependencies</li>\n<li><strong>Parallel Execution Groups</strong>: Systems with no dependencies between them get grouped for potential parallel execution</li>\n</ol>\n<p>The dependency management system maintains execution metadata:</p>\n<table>\n<thead>\n<tr>\n<th>Dependency Data</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_systemGraph</code></td>\n<td><code>DependencyGraph</code></td>\n<td>System execution dependencies</td>\n</tr>\n<tr>\n<td><code>m_executionOrder</code></td>\n<td><code>vector&lt;SystemID&gt;</code></td>\n<td>Resolved system execution sequence</td>\n</tr>\n<tr>\n<td><code>m_parallelGroups</code></td>\n<td><code>vector&lt;vector&lt;SystemID&gt;&gt;</code></td>\n<td>Systems that can run concurrently</td>\n</tr>\n<tr>\n<td><code>m_accessPatterns</code></td>\n<td><code>map&lt;SystemID, ComponentAccess&gt;</code></td>\n<td>Read/write patterns for each system</td>\n</tr>\n</tbody></table>\n<p>System dependency management includes error detection for common problems like circular dependencies or conflicting access patterns that could cause data races.</p>\n<p>⚠️ <strong>Pitfall: Ignoring System Execution Order</strong>\nMany learners implement systems without considering execution dependencies, leading to inconsistent behavior where the same input produces different outputs depending on system registration order. For example, if a movement system runs after the rendering system, entity positions update after visual output, causing a one-frame delay in visual movement. The fix is explicitly analyzing component access patterns and ensuring systems execute in dependency order.</p>\n<h3 id=\"resource-loading-dependencies\">Resource Loading Dependencies</h3>\n<p>The resource loading and management system creates complex dependencies between engine subsystems because graphics, audio, and gameplay systems all depend on loaded assets to function correctly. This dependency web resembles a <strong>supply chain network</strong> where manufacturing plants (systems) depend on raw materials (assets) delivered by suppliers (resource managers), and production cannot begin until all required materials arrive at the correct locations and times.</p>\n<p>Resource dependencies create unique challenges for game engines because asset loading involves file system I/O, network requests, and GPU memory allocation—all operations that can fail, take unpredictable amounts of time, or complete at arbitrary points during frame processing. The engine must coordinate resource requests from multiple systems while maintaining frame rate stability and providing graceful fallback behavior when resources are unavailable.</p>\n<p><img src=\"/api/project/build-game-engine/architecture-doc/asset?path=diagrams%2Fresource-lifecycle.svg\" alt=\"Resource Loading and Caching\"></p>\n<p>The resource loading architecture addresses several complex dependency scenarios that arise during game engine operation.</p>\n<h4 id=\"synchronous-vs-asynchronous-loading-patterns\">Synchronous vs Asynchronous Loading Patterns</h4>\n<p>Resource loading systems must balance <strong>immediate availability</strong> requirements against <strong>frame rate stability</strong> concerns. Some resources like default shaders and error textures must be available immediately when systems start, while other resources like level-specific textures and models can load asynchronously without disrupting gameplay. Understanding this distinction is like differentiating between <strong>emergency supplies</strong> that must always be available and <strong>specialty materials</strong> that can be ordered when needed.</p>\n<p><strong>Synchronous loading</strong> blocks system execution until resources become available, providing immediate access but potentially causing frame rate drops during loading operations. The engine uses synchronous loading for critical resources that systems cannot function without:</p>\n<p><strong>Bootstrap Resources</strong>: Default shaders, error textures, and system fonts must load synchronously during engine initialization because multiple systems depend on their immediate availability.</p>\n<p><strong>Scene Transition Resources</strong>: When transitioning between game levels, critical assets for the new scene must load synchronously to prevent visual glitches or missing content.</p>\n<p><strong>Error Recovery Resources</strong>: Fallback assets used when primary resources fail to load must be available immediately to maintain visual consistency.</p>\n<p>Synchronous loading operations use immediate resource access patterns:</p>\n<table>\n<thead>\n<tr>\n<th>Loading Operation</th>\n<th>Resource Type</th>\n<th>Typical Duration</th>\n<th>Systems Blocked</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Default shader compilation</td>\n<td><code>ShaderProgram</code></td>\n<td>50-100ms</td>\n<td>All rendering systems</td>\n</tr>\n<tr>\n<td>Error texture loading</td>\n<td><code>TextureResource</code></td>\n<td>5-10ms</td>\n<td>Rendering, UI systems</td>\n</tr>\n<tr>\n<td>System font loading</td>\n<td><code>FontResource</code></td>\n<td>10-20ms</td>\n<td>UI, text rendering systems</td>\n</tr>\n<tr>\n<td>Configuration file parsing</td>\n<td><code>ConfigData</code></td>\n<td>1-5ms</td>\n<td>All systems using config</td>\n</tr>\n</tbody></table>\n<p><strong>Asynchronous loading</strong> performs resource operations on background threads, allowing main thread systems to continue processing while assets load. The engine uses asynchronous loading for non-critical resources that systems can function without temporarily:</p>\n<p><strong>Level Assets</strong>: Textures, models, and audio specific to game levels can load in the background while players interact with currently loaded content.</p>\n<p><strong>Streaming Content</strong>: Large assets like high-resolution textures or detailed models can stream asynchronously based on player proximity or predicted need.</p>\n<p><strong>Prefetch Operations</strong>: Assets likely to be needed in the near future can begin loading before systems explicitly request them, reducing perceived loading times.</p>\n<p>Asynchronous loading requires coordination mechanisms to handle completion notifications and resource availability checking:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Async Loading Workflow:\n1. System requests resource through ResourceManager::LoadTextureAsync()\n2. ResourceManager queues LoadRequest in background thread queue\n3. Worker thread processes file I/O and GPU upload\n4. Completion callback notifies requesting system\n5. System begins using newly available resource</code></pre></div>\n\n<p>The Resource Manager maintains separate data structures for tracking synchronous and asynchronous operations:</p>\n<table>\n<thead>\n<tr>\n<th>Loading State</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>m_syncRequests</code></td>\n<td><code>vector&lt;LoadRequest&gt;</code></td>\n<td>Immediate loading operations</td>\n</tr>\n<tr>\n<td><code>m_asyncQueue</code></td>\n<td><code>ThreadSafeQueue&lt;LoadRequest&gt;</code></td>\n<td>Background loading queue</td>\n</tr>\n<tr>\n<td><code>m_completionCallbacks</code></td>\n<td><code>map&lt;Handle, Callback&gt;</code></td>\n<td>Async completion notifications</td>\n</tr>\n<tr>\n<td><code>m_loadingStates</code></td>\n<td><code>map&lt;Handle, LoadState&gt;</code></td>\n<td>Resource availability tracking</td>\n</tr>\n</tbody></table>\n<h4 id=\"handle-based-resource-access\">Handle-Based Resource Access</h4>\n<p>The engine implements <strong>handle-based resource access</strong> to decouple systems from resource storage details and provide safe access to assets that might not be loaded yet. Handles function like <strong>claim tickets</strong> at a coat check—they provide proof of ownership and enable retrieval, but don&#39;t guarantee the item is immediately available. This indirection enables sophisticated resource management features like hot reloading, memory management, and error recovery.</p>\n<p>Handle-based access provides several critical benefits for resource management. Systems can request resources and receive handles immediately, even if the actual loading occurs asynchronously. Handles remain valid across resource reloading operations, allowing systems to continue using updated assets without code changes. Handle validation prevents crashes when resources fail to load or become corrupted.</p>\n<p>The Handle<T> system implements type-safe resource access:</p>\n<table>\n<thead>\n<tr>\n<th>Handle Component</th>\n<th>Bits</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Resource ID</td>\n<td>32</td>\n<td>Unique identifier for resource instance</td>\n</tr>\n<tr>\n<td>Resource Version</td>\n<td>16</td>\n<td>Version counter for hot reloading detection</td>\n</tr>\n<tr>\n<td>Resource Type</td>\n<td>16</td>\n<td>Type information for validation</td>\n</tr>\n</tbody></table>\n<p>Handle validation occurs during resource access to ensure systems receive valid resources or appropriate fallback assets:</p>\n<ol>\n<li><strong>Handle Validity Check</strong>: The <code>IsValid()</code> method verifies the handle contains a non-zero resource ID and matches the expected resource type</li>\n<li><strong>Version Verification</strong>: The handle version gets compared against the current resource version to detect stale references</li>\n<li><strong>Loading State Check</strong>: The resource manager verifies the resource has completed loading and is available for use</li>\n<li><strong>Fallback Resolution</strong>: If the primary resource is unavailable, the system provides appropriate fallback resources</li>\n</ol>\n<p>Systems interact with the resource manager through handle-based APIs that abstract loading complexity:</p>\n<p>| Resource Access Method | Parameters | Returns | Behavior |\n|---|---|---|\n| <code>LoadTexture(filepath)</code> | <code>string filepath</code> | <code>TextureHandle</code> | Immediate loading, blocks until complete |\n| <code>LoadTextureAsync(filepath, callback)</code> | <code>string filepath, Callback</code> | <code>TextureHandle</code> | Background loading with notification |\n| <code>GetTexture(handle)</code> | <code>TextureHandle</code> | <code>TextureResource*</code> | Retrieves loaded resource or nullptr |\n| <code>IsResourceLoaded(handle)</code> | <code>Handle&lt;T&gt;</code> | <code>bool</code> | Checks loading completion status |</p>\n<h4 id=\"cross-system-resource-sharing\">Cross-System Resource Sharing</h4>\n<p>Multiple engine systems often require access to the same resources, creating <strong>shared dependency relationships</strong> that the resource manager must coordinate efficiently. This sharing resembles a <strong>public library system</strong> where multiple patrons can access the same books, but the library must track usage, prevent conflicts, and ensure resources remain available as long as anyone needs them.</p>\n<p>Resource sharing enables memory efficiency by preventing duplicate loading of identical assets. When multiple systems request the same texture file, the resource manager loads it once and provides handles to all requesters. Reference counting automatically manages resource lifetime—when the last system releases its handle, the resource manager can safely unload the asset to free memory.</p>\n<p>The resource manager implements several sharing mechanisms:</p>\n<p><strong>Reference Counting</strong>: Each resource maintains an atomic reference count that tracks how many systems currently hold handles to it. The <code>AddReference()</code> and <code>RemoveReference()</code> methods provide thread-safe reference management.</p>\n<p><strong>Shared Handle Distribution</strong>: Multiple requests for the same resource filepath return handles pointing to the same resource instance, preventing duplicate loading operations.</p>\n<p><strong>Automatic Cleanup</strong>: Resources with zero reference counts become eligible for garbage collection, automatically freeing memory without requiring explicit cleanup from systems.</p>\n<p><strong>Hot Reloading Support</strong>: When resources get updated on disk, the resource manager can reload them and update all existing handles simultaneously, allowing systems to automatically use updated content.</p>\n<p>Common resource sharing patterns in game engines include:</p>\n<table>\n<thead>\n<tr>\n<th>Sharing Pattern</th>\n<th>Resource Types</th>\n<th>Systems Involved</th>\n<th>Coordination Mechanism</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Shared Textures</td>\n<td>UI elements, sprites</td>\n<td>Rendering, UI, particle systems</td>\n<td>Reference counted handles</td>\n</tr>\n<tr>\n<td>Common Shaders</td>\n<td>Material rendering</td>\n<td>All graphics systems</td>\n<td>Shared shader program instances</td>\n</tr>\n<tr>\n<td>Audio Clips</td>\n<td>Sound effects</td>\n<td>Audio, physics, gameplay systems</td>\n<td>Instance-based playback with shared data</td>\n</tr>\n<tr>\n<td>Model Assets</td>\n<td>Character meshes</td>\n<td>Rendering, physics, animation systems</td>\n<td>Shared geometry with per-instance transforms</td>\n</tr>\n</tbody></table>\n<p>Resource sharing includes error handling for situations where shared resources become corrupted or unavailable. The resource manager provides fallback mechanisms that ensure systems continue functioning even when shared resources encounter problems.</p>\n<p><strong>Decision: Reference Counting vs Garbage Collection</strong></p>\n<ul>\n<li><strong>Context</strong>: Resource lifetime management needs to balance automatic cleanup with performance predictability</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Manual resource management: Systems explicitly load and unload resources</li>\n<li>Reference counting: Automatic cleanup when reference count reaches zero</li>\n<li>Garbage collection: Periodic cleanup of unused resources</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Reference counting with periodic garbage collection</li>\n<li><strong>Rationale</strong>: Reference counting provides immediate cleanup of unused resources while garbage collection handles edge cases like circular references. This combination provides both memory efficiency and predictable performance</li>\n<li><strong>Consequences</strong>: Slightly increased complexity in handle management, but prevents both memory leaks and unexpected cleanup delays</li>\n</ul>\n<h4 id=\"resource-loading-error-recovery\">Resource Loading Error Recovery</h4>\n<p>Resource loading operations can fail for numerous reasons including missing files, corrupted data, insufficient memory, or graphics driver problems. The engine must provide <strong>graceful degradation</strong> and <strong>recovery mechanisms</strong> that allow systems to continue functioning when resources are unavailable. This resilience resembles <strong>supply chain redundancy</strong> where critical operations maintain backup suppliers and alternative materials when primary sources encounter problems.</p>\n<p>Error recovery in resource loading involves several strategies that prevent cascading failures when individual assets cannot be loaded. The resource manager implements fallback hierarchies, retry mechanisms, and error reporting that enable systems to adapt to resource loading failures without crashing or producing broken visual output.</p>\n<p><strong>Fallback Resource Hierarchies</strong> provide alternative assets when primary resources fail to load. Each resource type includes default fallback instances that guarantee systems always receive valid resources:</p>\n<p><strong>Texture Fallbacks</strong>: Missing textures get replaced with generated error textures (typically bright magenta checkerboards) that clearly indicate loading failures while maintaining rendering functionality.</p>\n<p><strong>Shader Fallbacks</strong>: Failed shader compilation triggers fallback to basic unlit shaders that provide minimal but functional rendering capability.</p>\n<p><strong>Mesh Fallbacks</strong>: Missing 3D models get replaced with simple geometric primitives like cubes or spheres that preserve collision boundaries and visual presence.</p>\n<p><strong>Audio Fallbacks</strong>: Failed audio loading results in silent playback that maintains audio system functionality without generating errors.</p>\n<p>The resource manager maintains fallback resources for each major resource type:</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Primary Loading</th>\n<th>Fallback Resource</th>\n<th>Error Indication</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>TextureResource</code></td>\n<td>File-based PNG/JPG</td>\n<td>Generated error texture</td>\n<td>Magenta checkerboard pattern</td>\n</tr>\n<tr>\n<td><code>ShaderProgram</code></td>\n<td>File-based GLSL</td>\n<td>Basic unlit shader</td>\n<td>Solid color rendering</td>\n</tr>\n<tr>\n<td><code>MeshResource</code></td>\n<td>File-based OBJ/FBX</td>\n<td>Generated cube mesh</td>\n<td>Bright wireframe outline</td>\n</tr>\n<tr>\n<td><code>AudioResource</code></td>\n<td>File-based WAV/MP3</td>\n<td>Silent audio buffer</td>\n<td>No audio output</td>\n</tr>\n</tbody></table>\n<p><strong>Retry Mechanisms</strong> handle transient failures like temporary file system issues or network interruptions. The resource manager implements exponential backoff retry logic that attempts to reload failed resources without overwhelming the system with repeated failure attempts.</p>\n<p><strong>Error Reporting and Logging</strong> provide detailed information about resource loading failures to aid debugging and content pipeline issues. The resource manager logs failure reasons, file paths, and system state to help developers identify and resolve asset problems.</p>\n<p>Resource loading error recovery includes several implementation considerations:</p>\n<ol>\n<li><strong>Error Classification</strong>: Different error types (file not found vs corrupted data vs insufficient memory) receive different recovery strategies</li>\n<li><strong>System Notification</strong>: Systems receive notifications when resources fail to load so they can adapt behavior appropriately</li>\n<li><strong>Graceful Degradation</strong>: Visual and audio quality degrades gradually rather than failing completely when resources are unavailable</li>\n<li><strong>Recovery Monitoring</strong>: The resource manager tracks error rates and patterns to identify systemic problems with the content pipeline</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Cascading Resource Failures</strong>\nWhen primary resources fail to load, systems often request additional fallback resources, which can also fail and trigger more resource requests, creating cascading failures that consume all available loading bandwidth. The fix is implementing circuit breaker patterns that limit retry attempts and provide guaranteed-available fallback resources that never require additional loading operations.</p>\n<p>The resource loading dependency system creates the foundation for robust asset management that supports both development workflows and production deployment scenarios. Understanding these dependency patterns helps developers build systems that gracefully handle the complex resource loading scenarios encountered in real game development environments.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Building effective system interactions requires careful attention to timing, data flow, and error handling. The following implementation provides concrete structures and patterns for coordinating engine subsystems efficiently.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Event Queue</td>\n<td><code>std::queue</code> with mutex</td>\n<td>Lock-free circular buffer (SPSC)</td>\n</tr>\n<tr>\n<td>Message Passing</td>\n<td>Function pointers</td>\n<td><code>std::function</code> with type erasure</td>\n</tr>\n<tr>\n<td>Resource Handles</td>\n<td>64-bit integers with validation</td>\n<td>Typed handles with version counters</td>\n</tr>\n<tr>\n<td>Timing Control</td>\n<td><code>std::chrono::steady_clock</code></td>\n<td>Platform-specific high-resolution timers</td>\n</tr>\n<tr>\n<td>Threading</td>\n<td><code>std::thread</code> with <code>std::mutex</code></td>\n<td>Thread pool with work stealing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">engine</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  core</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Application.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">          // Main application framework</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FrameTimer.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">          // Frame timing and control</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventSystem.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">         // Inter-system communication</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  systems</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemManager.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">       // System registration and execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemBase.h</span><span style=\"color:#6A737D\">              // Base class for all systems</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InputSystem.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">        // Input processing and distribution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  resources</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceManager.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">     // Asset loading and caching</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Handle.h</span><span style=\"color:#6A737D\">                  // Resource handle implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceTypes.h</span><span style=\"color:#6A737D\">           // Resource type definitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  communication</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventQueue.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">         // Thread-safe event queuing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CallbackRegistry.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">   // Callback management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MessageBus.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp</span><span style=\"color:#6A737D\">         // System message passing</span></span></code></pre></div>\n\n<h4 id=\"frame-processing-infrastructure\">Frame Processing Infrastructure</h4>\n<p>Complete frame timing and control system that manages the main game loop and coordinates system execution:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// FrameTimer.h - Complete frame timing implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FrameTimer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> TARGET_FPS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> TARGET_FRAME_TIME </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> /</span><span style=\"color:#E1E4E8\"> TARGET_FPS;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> MAX_ACCUMULATED_TIME </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Prevent spiral of death</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::time_point m_lastFrameTime;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::time_point m_currentFrameTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_deltaTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_frameTimeAccumulator;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;float></span><span style=\"color:#E1E4E8\"> m_frameTimeHistory;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> m_historyIndex;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> m_frameCounter;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FrameTimer</span><span style=\"color:#E1E4E8\">() </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">m_deltaTime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        , </span><span style=\"color:#B392F0\">m_frameTimeAccumulator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        , </span><span style=\"color:#B392F0\">m_frameTimeHistory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">60</span><span style=\"color:#E1E4E8\">, TARGET_FRAME_TIME)</span><span style=\"color:#6A737D\">  // Track last 60 frames</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        , </span><span style=\"color:#B392F0\">m_historyIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        , </span><span style=\"color:#B392F0\">m_frameCounter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_lastFrameTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_currentFrameTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_lastFrameTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_currentFrameTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">duration</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">>(m_currentFrameTime </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> m_lastFrameTime);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_deltaTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> elapsed.</span><span style=\"color:#B392F0\">count</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Clamp delta time to prevent huge jumps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_deltaTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(m_deltaTime, MAX_ACCUMULATED_TIME);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Update frame time history for averaging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_frameTimeHistory[m_historyIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_deltaTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_historyIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (m_historyIndex </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> m_frameTimeHistory.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_lastFrameTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_currentFrameTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_frameCounter</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetDeltaTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_deltaTime; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> GetAverageFrameTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\"> time : m_frameTimeHistory) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> time;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> sum </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> m_frameTimeHistory.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#B392F0\"> GetFrameCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> m_frameCounter; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EventSystem.h - Complete event communication system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;mutex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> EventType</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntityCreated</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntityDestroyed</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CollisionDetected</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ResourceLoaded</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ResourceFailed</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WindowResized</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WindowClosed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventType type;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> timestamp;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> dataSize;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Event</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EventType</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> d</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">type</span><span style=\"color:#E1E4E8\">(t), </span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(d), </span><span style=\"color:#B392F0\">dataSize</span><span style=\"color:#E1E4E8\">(size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">time_since_epoch</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">count</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EventSystem</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Event</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_eventQueue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EventType, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> Event</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">>>></span><span style=\"color:#E1E4E8\"> m_handlers;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_queueMutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_handlersMutex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> EventData</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> PostEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EventType</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> EventData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_queueMutex);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allocate event data on heap for thread safety</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EventData</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> eventData </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> EventData</span><span style=\"color:#E1E4E8\">(data);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_eventQueue.</span><span style=\"color:#B392F0\">emplace</span><span style=\"color:#E1E4E8\">(type, eventData, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(EventData));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> PostEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EventType</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_queueMutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_eventQueue.</span><span style=\"color:#B392F0\">emplace</span><span style=\"color:#E1E4E8\">(type);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Subscribe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EventType</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_handlersMutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_handlers[type].</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(handler));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ProcessEvents</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Event</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> eventsToProcess;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Move events to local queue for processing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_queueMutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            eventsToProcess.</span><span style=\"color:#B392F0\">swap</span><span style=\"color:#E1E4E8\">(m_eventQueue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Process events without holding locks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">eventsToProcess.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            const</span><span style=\"color:#E1E4E8\"> Event</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> eventsToProcess.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_handlersMutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_handlers.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(event.type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> m_handlers.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> handler : it->second) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        handler</span><span style=\"color:#E1E4E8\">(event);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Clean up event data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (event.data) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                delete[]</span><span style=\"color:#F97583\"> static_cast&#x3C;char*></span><span style=\"color:#E1E4E8\">(event.data);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            eventsToProcess.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"system-coordination-framework\">System Coordination Framework</h4>\n<p>Core system execution pipeline with dependency management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SystemManager.h - System execution coordination</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"SystemBase.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">SystemBase</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_systems;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::type_index, </span><span style=\"color:#F97583\">size_t></span><span style=\"color:#E1E4E8\"> m_systemIndices;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;size_t>></span><span style=\"color:#E1E4E8\"> m_executionGroups;</span><span style=\"color:#6A737D\">  // Systems grouped by dependencies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> m_systemsInitialized;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SystemManager</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">m_systemsInitialized</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> SystemType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RegisterSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> system </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">make_unique</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">SystemType</span><span style=\"color:#E1E4E8\">>(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::type_index </span><span style=\"color:#B392F0\">typeIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(SystemType));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_systemIndices[typeIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_systems.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_systems.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(system));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_systemsInitialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Need to rebuild execution order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> SystemType</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SystemType</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetSystem</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::type_index </span><span style=\"color:#B392F0\">typeIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(SystemType));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_systemIndices.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(typeIndex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> m_systemIndices.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> static_cast&#x3C;</span><span style=\"color:#E1E4E8\">SystemType</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(m_systems[it->second].</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> system : m_systems) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            system-></span><span style=\"color:#B392F0\">Initialize</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        BuildExecutionOrder</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_systemsInitialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> UpdateSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">m_systemsInitialized) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Execute systems in dependency order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> group : m_executionGroups) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> systemIndex : group) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                m_systems[systemIndex]-></span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(deltaTime);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> BuildExecutionOrder</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Analyze component read/write dependencies for each system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Build dependency graph based on component access patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Perform topological sort to determine execution order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Group systems with no dependencies for potential parallel execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Store execution groups in m_executionGroups</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Simple implementation: execute in registration order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_executionGroups.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> m_systems.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_executionGroups.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">({i});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SystemBase.h - Base interface for all systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemBase</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~SystemBase</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Dependency analysis for execution ordering</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">GetReadComponents</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">GetWriteComponents</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"resource-loading-coordination\">Resource Loading Coordination</h4>\n<p>Complete resource management system with async loading and handle validation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ResourceManager.h - Complete resource loading infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"Handle.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;thread></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;atomic></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;mutex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;condition_variable></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ResourceType</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Texture</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Mesh</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Audio</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Shader</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> LoadState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Unloaded</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Loading</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Loaded</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    Failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> LoadRequest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string filepath;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceType type;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">(Handle</span><span style=\"color:#F97583\">&#x3C;void></span><span style=\"color:#E1E4E8\">, LoadState)</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> callback;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> priority;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">&#x3C;</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> LoadRequest</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> priority </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> other.priority;</span><span style=\"color:#6A737D\">  // Higher priority first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ResourceEntry</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    T resource;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">LoadState</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> state;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> referenceCount;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> version;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string filepath;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ResourceEntry</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">state</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LoadState</span><span style=\"color:#E1E4E8\">::Unloaded), </span><span style=\"color:#B392F0\">referenceCount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">version</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ResourceManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource storage by type</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ResourceEntry</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">TextureResource</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_textures;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ResourceEntry</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">MeshResource</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_meshes;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ResourceEntry</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">AudioResource</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_audioClips;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle mapping</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, TextureHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_textureHandles;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, MeshHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_meshHandles;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, AudioHandle</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_audioHandles;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Async loading infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::priority_queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">LoadRequest</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_loadQueue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::thread</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_workerThreads;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_queueMutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::condition_variable m_queueCondition;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;bool></span><span style=\"color:#E1E4E8\"> m_shouldStop;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Thread-safe resource access</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_texturesMutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_meshesMutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex m_audioMutex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ResourceManager</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">m_shouldStop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Start worker threads for async loading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> numThreads </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">thread</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">hardware_concurrency</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> numThreads; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m_workerThreads.</span><span style=\"color:#B392F0\">emplace_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">ResourceManager</span><span style=\"color:#E1E4E8\">::WorkerThread, </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~ResourceManager</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Shutdown</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TextureHandle</span><span style=\"color:#B392F0\"> LoadTexture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if texture already loaded, return existing handle if found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create new texture entry and handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Load texture data from file synchronously</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Upload texture data to GPU</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update texture entry state to Loaded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Return valid handle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TextureHandle{};</span><span style=\"color:#6A737D\">  // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> LoadTextureAsync</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> filepath</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                         std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">LoadState</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if texture already exists, call callback immediately if loaded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create texture entry and handle for async loading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Queue load request with callback</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Wake worker thread to process request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TextureResource</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetTexture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate handle (check ID, version, type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if resource is in Loaded state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return resource pointer or nullptr if invalid/not loaded</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Increment reference count atomically</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RemoveReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TextureHandle</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Decrement reference count atomically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Queue for cleanup if reference count reaches zero</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> WorkerThread</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">m_shouldStop) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LoadRequest request;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Wait for work</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(m_queueMutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                m_queueCondition.</span><span style=\"color:#B392F0\">wait</span><span style=\"color:#E1E4E8\">(lock, [</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">] { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">m_loadQueue.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> m_shouldStop; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (m_shouldStop) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                request </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_loadQueue.</span><span style=\"color:#B392F0\">top</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                m_loadQueue.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Process load request</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ProcessLoadRequest</span><span style=\"color:#E1E4E8\">(request);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ProcessLoadRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> LoadRequest</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Load resource data from file based on request.type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Upload to GPU if necessary (textures, meshes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Update resource entry state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Call completion callback with result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_shouldStop </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_queueCondition.</span><span style=\"color:#B392F0\">notify_all</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> thread : m_workerThreads) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (thread.</span><span style=\"color:#B392F0\">joinable</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                thread.</span><span style=\"color:#B392F0\">join</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Rendering Foundation):</strong></p>\n<ul>\n<li>Run: Create window, verify frame loop runs at stable 60fps</li>\n<li>Test: <code>FrameTimer</code> reports consistent delta times around 16.67ms</li>\n<li>Verify: Window processes close events and terminates gracefully</li>\n</ul>\n<p><strong>After Milestone 2 (ECS Implementation):</strong></p>\n<ul>\n<li>Run: Create entities, add components, register systems</li>\n<li>Test: System execution order respects component dependencies</li>\n<li>Verify: <code>EventSystem</code> delivers events between systems correctly</li>\n</ul>\n<p><strong>After Milestone 3 (Physics Integration):</strong></p>\n<ul>\n<li>Run: Physics simulation with multiple bodies and collisions</li>\n<li>Test: Fixed timestep maintains deterministic behavior</li>\n<li>Verify: Collision events trigger appropriate system responses</li>\n</ul>\n<p><strong>After Milestone 4 (Resource Management):</strong></p>\n<ul>\n<li>Run: Load textures and meshes both synchronously and asynchronously</li>\n<li>Test: Resource handles remain valid across hot reloading</li>\n<li>Verify: Reference counting prevents premature resource cleanup</li>\n</ul>\n<h4 id=\"debugging-system-interactions\">Debugging System Interactions</h4>\n<p>| Symptom | Likely Cause | Diagnosis | Fix |\n|---|---|---|\n| Inconsistent entity behavior | System execution order wrong | Log system execution sequence | Implement proper dependency analysis |\n| Frame rate drops during loading | Synchronous loading on main thread | Profile frame phases | Move asset loading to background threads |\n| Visual glitches after scene change | Resource cleanup during transition | Check resource reference counts | Implement two-phase scene transitions |\n| Events not delivered | Event processing timing wrong | Check event queue processing order | Process events at start of frame cycle |\n| Handle validation failures | Stale handles after hot reload | Log handle version mismatches | Update handle versions during resource reload |</p>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — robust error handling is essential throughout development as each subsystem introduces failure modes that must be handled gracefully</p>\n</blockquote>\n<p>Game engines operate in an unforgiving real-time environment where failures can cascade rapidly across interconnected systems. Think of error handling in a game engine like <strong>emergency protocols in an air traffic control tower</strong> — when one system fails, you need immediate detection, graceful degradation, and rapid recovery to prevent the entire operation from collapsing. Unlike typical applications that can afford to crash and restart, game engines must maintain the illusion of a continuous, responsive world even when components fail.</p>\n<p>The challenge of game engine error handling stems from three fundamental constraints. First, the <strong>frame time budget</strong> of 16.67 milliseconds leaves no room for expensive recovery operations during normal frame processing. Second, the <strong>interdependency between systems</strong> means that a graphics driver crash can affect physics simulation, or a resource loading failure can break rendering. Third, the <strong>real-time nature</strong> of games means users expect immediate feedback when something goes wrong, not cryptic error messages or frozen screens.</p>\n<p>Modern game engines must handle failures across multiple domains simultaneously. Graphics hardware can lose context, run out of memory, or encounter driver bugs. Physics simulations can encounter numerical instability, object tunneling, or collision jitter. Resource loading can fail due to corrupted files, network timeouts, or insufficient memory. Each failure mode requires a different recovery strategy that maintains engine stability while preserving game state integrity.</p>\n<p>The mental model for effective game engine error handling is a <strong>layered defense system</strong> with multiple fallback positions. The outer layer attempts to prevent errors through validation and defensive programming. The middle layer detects errors early and attempts local recovery. The inner layer provides graceful degradation and user notification when recovery isn&#39;t possible. Each layer has clearly defined responsibilities and failure escalation paths.</p>\n<h3 id=\"graphics-and-shader-error-recovery\">Graphics and Shader Error Recovery</h3>\n<p>Graphics errors represent some of the most critical failures in game engines because rendering failures are immediately visible to users and can cascade through the entire frame pipeline. The graphics system operates in a hostile environment where driver bugs, hardware limitations, and resource exhaustion are constant threats that must be anticipated and handled gracefully.</p>\n<h4 id=\"opengl-context-loss-recovery\">OpenGL Context Loss Recovery</h4>\n<p>OpenGL context loss occurs when the graphics driver resets due to GPU hangs, driver crashes, or system power management events. When context loss happens, all GPU resources become invalid and must be recreated from scratch. The engine must detect this condition quickly and rebuild the entire graphics state without crashing or corrupting the frame pipeline.</p>\n<table>\n<thead>\n<tr>\n<th>Context Loss Scenario</th>\n<th>Trigger Condition</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GPU Driver Crash</td>\n<td>Invalid GPU commands</td>\n<td><code>glGetError()</code> returns <code>GL_CONTEXT_LOST</code></td>\n<td>Full context recreation</td>\n</tr>\n<tr>\n<td>Power Management</td>\n<td>System enters sleep mode</td>\n<td>Render commands fail silently</td>\n<td>Resource validation and reload</td>\n</tr>\n<tr>\n<td>Hardware Failure</td>\n<td>GPU memory corruption</td>\n<td>Frame buffer corruption</td>\n<td>Fallback to software rendering</td>\n</tr>\n<tr>\n<td>Driver Update</td>\n<td>Graphics driver replacement</td>\n<td>Context creation failure</td>\n<td>Context recreation with validation</td>\n</tr>\n<tr>\n<td>Resource Exhaustion</td>\n<td>Out of video memory</td>\n<td>Texture/buffer allocation fails</td>\n<td>Resource cleanup and retry</td>\n</tr>\n</tbody></table>\n<p>The context loss recovery process follows a structured sequence that rebuilds graphics state incrementally. First, the <code>Window</code> detects context loss by monitoring OpenGL error states and render command success. When context loss is detected, the system enters recovery mode and stops all rendering operations to prevent further corruption. Next, the <code>Renderer</code> invalidates all cached OpenGL state including vertex array objects, buffer objects, and texture handles. The system then recreates the OpenGL context through the windowing system and reinitializes all graphics resources from their CPU-side copies.</p>\n<p><strong>Context Loss Detection Implementation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Detection Point</th>\n<th>Check Method</th>\n<th>Error Condition</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame Start</td>\n<td><code>glGetError()</code> after swap</td>\n<td><code>GL_CONTEXT_LOST</code></td>\n<td>Enter recovery mode</td>\n</tr>\n<tr>\n<td>Texture Upload</td>\n<td>Check <code>glTexImage2D</code> result</td>\n<td>Function returns false</td>\n<td>Mark texture invalid</td>\n</tr>\n<tr>\n<td>Shader Compilation</td>\n<td>Check compilation status</td>\n<td>Compilation fails</td>\n<td>Use fallback shader</td>\n</tr>\n<tr>\n<td>Buffer Binding</td>\n<td>Verify buffer object validity</td>\n<td>Buffer ID invalid</td>\n<td>Recreate buffer</td>\n</tr>\n<tr>\n<td>Draw Call Execution</td>\n<td>Monitor <code>glDrawElements</code></td>\n<td>Silent failure</td>\n<td>Validate all state</td>\n</tr>\n</tbody></table>\n<p>The <code>ShaderProgram</code> class maintains CPU-side copies of all shader source code and compilation parameters to enable rapid recreation after context loss. When the graphics context is restored, shaders are recompiled in dependency order, starting with the most critical rendering programs and falling back to simpler shaders if compilation fails. The system validates each shader compilation step and provides detailed error reporting to help diagnose driver-specific issues.</p>\n<blockquote>\n<p><strong>Recovery Strategy</strong>: The key insight for context loss recovery is maintaining <strong>parallel state tracking</strong> — every GPU resource must have a CPU-side representation that can be used to recreate the resource exactly. This doubles memory usage but enables robust recovery from any graphics failure.</p>\n</blockquote>\n<h4 id=\"shader-compilation-error-handling\">Shader Compilation Error Handling</h4>\n<p>Shader compilation failures can occur due to syntax errors in shader source code, driver bugs that reject valid GLSL, or hardware limitations that prevent certain shader features from working. The shader system must detect these failures early and provide meaningful fallbacks that maintain visual continuity while reporting diagnostic information.</p>\n<p>The <code>ShaderProgram</code> compilation process implements a multi-stage validation pipeline that catches errors at each compilation phase. First, the system validates shader source code syntax using regex patterns to catch common mistakes before attempting GPU compilation. Next, individual shaders are compiled with detailed error reporting that captures line numbers and error descriptions. The system then attempts program linking and validates all uniform and attribute bindings. Finally, a runtime validation pass ensures the shader can execute successfully with typical input data.</p>\n<table>\n<thead>\n<tr>\n<th>Shader Error Type</th>\n<th>Detection Phase</th>\n<th>Error Symptoms</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Syntax Error</td>\n<td>Source compilation</td>\n<td>Compilation log contains errors</td>\n<td>Use fallback shader</td>\n</tr>\n<tr>\n<td>Link Error</td>\n<td>Program linking</td>\n<td>Link status reports failure</td>\n<td>Try alternative shader variants</td>\n</tr>\n<tr>\n<td>Uniform Error</td>\n<td>Runtime validation</td>\n<td>Uniform location is -1</td>\n<td>Skip uniform updates</td>\n</tr>\n<tr>\n<td>Attribute Error</td>\n<td>Vertex setup</td>\n<td>Attribute location invalid</td>\n<td>Use default vertex format</td>\n</tr>\n<tr>\n<td>Hardware Limitation</td>\n<td>Feature detection</td>\n<td>Extension not supported</td>\n<td>Disable advanced features</td>\n</tr>\n</tbody></table>\n<p>The shader fallback system maintains a hierarchy of increasingly simple shaders that can substitute for complex programs when compilation fails. A sophisticated PBR shader might fall back to basic Phong lighting, then to unlit textured rendering, and finally to solid color rendering if all other options fail. This ensures that objects remain visible even when advanced rendering features are unavailable.</p>\n<p><strong>Shader Error Recovery Flowchart:</strong></p>\n<ol>\n<li><strong>Attempt Primary Shader Compilation</strong>: Load vertex and fragment shader source files and compile them individually</li>\n<li><strong>Validate Compilation Results</strong>: Check compilation status and parse error logs for specific failure information  </li>\n<li><strong>Try Progressive Fallbacks</strong>: If compilation fails, attempt simpler shader variants in order of decreasing complexity</li>\n<li><strong>Cache Working Configurations</strong>: Remember which shaders work on the current hardware to avoid repeated failures</li>\n<li><strong>Report Diagnostic Information</strong>: Log shader errors with full context including GPU vendor, driver version, and source code</li>\n<li><strong>Update Rendering Pipeline</strong>: Ensure fallback shaders provide compatible uniforms and vertex attributes</li>\n<li><strong>Validate Runtime Performance</strong>: Confirm fallback shaders maintain acceptable frame rate performance</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Fallback Shader Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Shader compilation can fail due to driver bugs, hardware limitations, or syntax errors, but rendering must continue</li>\n<li><strong>Options Considered</strong>: (1) Crash on shader failure, (2) Skip rendering for failed objects, (3) Progressive fallback system</li>\n<li><strong>Decision</strong>: Implement progressive fallback with multiple shader complexity levels</li>\n<li><strong>Rationale</strong>: Maintains visual continuity while providing graceful degradation path for unsupported hardware</li>\n<li><strong>Consequences</strong>: Requires maintaining multiple shader variants but ensures rendering never completely fails</li>\n</ul>\n</blockquote>\n<h4 id=\"texture-loading-error-recovery\">Texture Loading Error Recovery</h4>\n<p>Texture loading failures can stem from corrupted image files, unsupported formats, insufficient GPU memory, or file system errors. The texture system must handle these failures gracefully while providing visual feedback that helps identify missing assets without breaking the rendering pipeline.</p>\n<p>The <code>TextureResource</code> loading pipeline implements comprehensive validation at each stage of the texture creation process. File validation occurs first, checking for file existence, read permissions, and basic format headers before attempting full image decoding. Image decoding validation ensures pixel data integrity and handles format conversion errors gracefully. GPU upload validation confirms texture creation success and handles out-of-memory conditions by reducing texture quality or using compression.</p>\n<table>\n<thead>\n<tr>\n<th>Texture Error Source</th>\n<th>Failure Symptoms</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing File</td>\n<td>File not found error</td>\n<td><code>fopen()</code> returns null</td>\n<td>Use default &quot;missing&quot; texture</td>\n</tr>\n<tr>\n<td>Corrupted Data</td>\n<td>Image decode failure</td>\n<td>PNG/JPEG library error</td>\n<td>Try alternative formats</td>\n</tr>\n<tr>\n<td>Format Unsupported</td>\n<td>Decode returns invalid data</td>\n<td>Invalid pixel format</td>\n<td>Convert to supported format</td>\n</tr>\n<tr>\n<td>GPU Memory Full</td>\n<td>Texture creation fails</td>\n<td><code>glTexImage2D</code> error</td>\n<td>Reduce texture resolution</td>\n</tr>\n<tr>\n<td>Size Limitations</td>\n<td>Texture too large</td>\n<td>Exceeds <code>GL_MAX_TEXTURE_SIZE</code></td>\n<td>Resize to maximum supported</td>\n</tr>\n</tbody></table>\n<p>The fallback texture system provides a clear visual indication when textures fail to load while maintaining rendering pipeline compatibility. A default &quot;missing texture&quot; pattern uses a distinctive purple/pink checkerboard that&#39;s immediately recognizable to developers while remaining visually acceptable to end users. For production builds, the system can substitute placeholder textures that match expected content categories (terrain, character, UI, etc.).</p>\n<p><strong>Texture Memory Management Strategy:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Memory Pressure Level</th>\n<th>Detection Criteria</th>\n<th>Response Action</th>\n<th>Fallback Quality</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal Operation</td>\n<td>All textures load successfully</td>\n<td>No action required</td>\n<td>Full resolution</td>\n</tr>\n<tr>\n<td>Mild Pressure</td>\n<td>Occasional allocation failures</td>\n<td>Compress new textures</td>\n<td>50% resolution</td>\n</tr>\n<tr>\n<td>High Pressure</td>\n<td>Frequent allocation failures</td>\n<td>Compress existing textures</td>\n<td>25% resolution</td>\n</tr>\n<tr>\n<td>Critical Pressure</td>\n<td>Most allocations fail</td>\n<td>Unload unused textures</td>\n<td>Essential only</td>\n</tr>\n<tr>\n<td>Out of Memory</td>\n<td>All allocations fail</td>\n<td>Emergency garbage collection</td>\n<td>Minimum viable set</td>\n</tr>\n</tbody></table>\n<h3 id=\"physics-simulation-edge-cases\">Physics Simulation Edge Cases</h3>\n<p>Physics simulations are inherently unstable numerical systems that can exhibit chaotic behavior when edge cases aren&#39;t handled properly. Small numerical errors can compound rapidly, leading to objects flying apart, falling through floors, or jittering uncontrollably. The physics system must implement robust error detection and correction mechanisms that maintain simulation stability while preserving realistic behavior.</p>\n<h4 id=\"tunneling-prevention\">Tunneling Prevention</h4>\n<p><strong>Tunneling</strong> occurs when fast-moving objects pass completely through thin barriers between physics timesteps without collision detection registering contact. This happens because discrete collision detection only checks object positions at specific time intervals, missing intermediate collisions that occur between frames. High-speed projectiles are particularly susceptible to tunneling through walls, floors, or other collision geometry.</p>\n<p>The tunneling prevention system combines multiple strategies to ensure collision detection captures all contacts regardless of object velocity. <strong>Continuous collision detection</strong> traces the path of fast-moving objects between timesteps, checking for intersections along the entire movement trajectory rather than just at endpoints. <strong>Swept volume testing</strong> expands collision shapes to cover the entire movement path, ensuring collision detection captures any intermediate contacts.</p>\n<table>\n<thead>\n<tr>\n<th>Tunneling Scenario</th>\n<th>Object Velocity</th>\n<th>Collision Shape</th>\n<th>Prevention Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bullet vs Thin Wall</td>\n<td>&gt;1000 units/sec</td>\n<td>Small sphere</td>\n<td>Continuous raycast</td>\n</tr>\n<tr>\n<td>Fast Character vs Floor</td>\n<td>&gt;500 units/sec</td>\n<td>Capsule</td>\n<td>Swept shape test</td>\n</tr>\n<tr>\n<td>Projectile vs Moving Target</td>\n<td>Relative &gt;800 units/sec</td>\n<td>AABB</td>\n<td>Temporal coherence</td>\n</tr>\n<tr>\n<td>Small Object vs Mesh</td>\n<td>&gt;300 units/sec</td>\n<td>Point</td>\n<td>Expanded bounding volume</td>\n</tr>\n<tr>\n<td>Rotating Object</td>\n<td>&gt;720 degrees/sec</td>\n<td>Complex shape</td>\n<td>Conservative advancement</td>\n</tr>\n</tbody></table>\n<p>The <strong>Conservative Advancement Algorithm</strong> provides the most robust solution to tunneling by advancing simulation time in small increments until the first collision is detected. This algorithm calculates the time of impact for each potential collision pair and advances the simulation to the earliest collision time, resolves that collision, then continues with remaining simulation time. This ensures no collisions are missed regardless of object velocity or simulation timestep size.</p>\n<p><strong>Tunneling Detection Process:</strong></p>\n<ol>\n<li><strong>Calculate Movement Bounds</strong>: For each moving object, compute the swept AABB that encompasses start and end positions</li>\n<li><strong>Identify Potential Tunneling</strong>: Check if movement distance exceeds collision shape dimensions or barrier thickness</li>\n<li><strong>Perform Continuous Query</strong>: Raycast or sweep test along movement path to detect intermediate collisions</li>\n<li><strong>Calculate Impact Time</strong>: Determine exact time when collision first occurs along movement trajectory</li>\n<li><strong>Advance to Collision</strong>: Move simulation forward to collision time and process impact normally</li>\n<li><strong>Continue with Remaining Time</strong>: Apply remaining timestep after collision resolution</li>\n<li><strong>Validate Final State</strong>: Ensure no objects remain in penetrating state after tunneling prevention</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Tunneling Prevention Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Fast-moving objects can pass through barriers between timesteps, breaking physics consistency</li>\n<li><strong>Options Considered</strong>: (1) Smaller timesteps, (2) Velocity clamping, (3) Continuous collision detection</li>\n<li><strong>Decision</strong>: Implement selective continuous collision detection for high-velocity objects</li>\n<li><strong>Rationale</strong>: Maintains simulation stability without performance penalty for slow-moving objects</li>\n<li><strong>Consequences</strong>: Adds complexity but prevents the most common physics simulation failures</li>\n</ul>\n</blockquote>\n<h4 id=\"collision-jitter-reduction\">Collision Jitter Reduction</h4>\n<p><strong>Collision jitter</strong> manifests as rapid oscillation when objects are in resting contact, caused by numerical precision errors that cause objects to alternate between penetrating and separating states each frame. This creates visually distracting vibration and can destabilize stacks of objects or cause perpetual motion in systems that should be at rest.</p>\n<p>The jitter reduction system addresses numerical instability through several complementary techniques. <strong>Penetration tolerance</strong> allows small overlaps to persist without correction, reducing sensitivity to floating-point errors. <strong>Velocity damping</strong> gradually reduces oscillation energy in objects that are nearly at rest. <strong>Position correction limiting</strong> prevents overcorrection that can cause objects to separate too far and fall back together.</p>\n<table>\n<thead>\n<tr>\n<th>Jitter Source</th>\n<th>Manifestation</th>\n<th>Root Cause</th>\n<th>Correction Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Floating Point Error</td>\n<td>Micro-oscillation</td>\n<td>Limited numerical precision</td>\n<td>Penetration tolerance</td>\n</tr>\n<tr>\n<td>Overcorrection</td>\n<td>Bouncing separation</td>\n<td>Excessive position correction</td>\n<td>Correction damping</td>\n</tr>\n<tr>\n<td>Velocity Accumulation</td>\n<td>Growing oscillation</td>\n<td>Energy not being removed</td>\n<td>Velocity damping</td>\n</tr>\n<tr>\n<td>Timestep Quantization</td>\n<td>Frame-rate dependent jitter</td>\n<td>Discrete simulation steps</td>\n<td>Temporal smoothing</td>\n</tr>\n<tr>\n<td>Constraint Conflicts</td>\n<td>Chaotic movement</td>\n<td>Contradictory constraints</td>\n<td>Constraint prioritization</td>\n</tr>\n</tbody></table>\n<p>The <strong>Baumgarte Stabilization</strong> technique provides robust jitter reduction by combining position correction with velocity adjustment. When objects are penetrating, the system calculates both the position correction needed to separate them and a velocity bias that prevents them from moving back together immediately. The velocity bias gradually decreases over multiple frames, allowing objects to settle into stable contact without oscillation.</p>\n<p><strong>Jitter Reduction Parameters:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Typical Value</th>\n<th>Purpose</th>\n<th>Effect of Tuning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PENETRATION_TOLERANCE</code></td>\n<td>0.01f units</td>\n<td>Minimum overlap to ignore</td>\n<td>Higher = more stable, less precise</td>\n</tr>\n<tr>\n<td><code>POSITION_CORRECTION_PERCENT</code></td>\n<td>0.8f</td>\n<td>Fraction of overlap to correct</td>\n<td>Lower = less aggressive correction</td>\n</tr>\n<tr>\n<td><code>VELOCITY_DAMPING_FACTOR</code></td>\n<td>0.98f per second</td>\n<td>Rate of energy removal</td>\n<td>Higher = more damping</td>\n</tr>\n<tr>\n<td><code>REST_VELOCITY_THRESHOLD</code></td>\n<td>0.5f units/sec</td>\n<td>Speed below which damping applies</td>\n<td>Higher = more objects affected</td>\n</tr>\n<tr>\n<td><code>CORRECTION_ITERATIONS</code></td>\n<td>4</td>\n<td>Solver iteration count</td>\n<td>More = stabler but slower</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Performance vs Stability Trade-off</strong>: Jitter reduction requires careful parameter tuning because aggressive stabilization can make physics feel &quot;mushy&quot; or unresponsive, while insufficient stabilization causes visible artifacts. The sweet spot varies by game genre and visual style.</p>\n</blockquote>\n<h4 id=\"numerical-stability-maintenance\">Numerical Stability Maintenance</h4>\n<p>Physics simulations accumulate numerical errors over time that can cause catastrophic instability if not managed proactively. Small floating-point precision errors compound through integration steps, constraint solving, and collision response calculations, eventually leading to explosive behavior where objects gain infinite energy or assume invalid positions.</p>\n<p>The numerical stability system monitors simulation health through multiple invariants and corrective mechanisms. <strong>Energy conservation tracking</strong> ensures the total system energy remains bounded and decreases over time due to damping. <strong>Position bounds validation</strong> detects objects that have moved to extreme coordinates indicating numerical overflow. <strong>Velocity clamping</strong> prevents objects from exceeding physically reasonable speeds that could cause integration errors.</p>\n<table>\n<thead>\n<tr>\n<th>Stability Metric</th>\n<th>Normal Range</th>\n<th>Warning Threshold</th>\n<th>Critical Threshold</th>\n<th>Corrective Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Total System Energy</td>\n<td>Game dependent</td>\n<td>2x initial</td>\n<td>10x initial</td>\n<td>Apply global damping</td>\n</tr>\n<tr>\n<td>Maximum Object Velocity</td>\n<td>&lt;100 units/sec</td>\n<td>&gt;500 units/sec</td>\n<td>&gt;1000 units/sec</td>\n<td>Clamp velocity</td>\n</tr>\n<tr>\n<td>Integration Error</td>\n<td>&lt;0.01 units</td>\n<td>&gt;0.1 units</td>\n<td>&gt;1.0 units</td>\n<td>Reduce timestep</td>\n</tr>\n<tr>\n<td>Constraint Error</td>\n<td>&lt;0.001 units</td>\n<td>&gt;0.01 units</td>\n<td>&gt;0.1 units</td>\n<td>Reset constraints</td>\n</tr>\n<tr>\n<td>Floating Point Validity</td>\n<td>All finite values</td>\n<td>NaN detected</td>\n<td>Infinity detected</td>\n<td>Reset object state</td>\n</tr>\n</tbody></table>\n<p>The <strong>Simulation Health Monitor</strong> runs continuously during physics updates, checking for early warning signs of numerical instability. When warning thresholds are exceeded, the system applies gentle corrective measures like increased damping or constraint relaxation. When critical thresholds are reached, the system performs emergency stabilization including object state reset or temporary constraint disabling.</p>\n<p><strong>Numerical Error Detection Algorithm:</strong></p>\n<ol>\n<li><strong>Pre-Integration Validation</strong>: Check all object states for NaN/infinity values before physics step</li>\n<li><strong>Energy Delta Calculation</strong>: Measure total system energy change and compare to expected damping</li>\n<li><strong>Velocity Magnitude Monitoring</strong>: Track maximum object velocities and identify outliers</li>\n<li><strong>Position Bounds Checking</strong>: Ensure all objects remain within reasonable world coordinates</li>\n<li><strong>Integration Error Estimation</strong>: Calculate position prediction error for validation</li>\n<li><strong>Constraint Violation Measurement</strong>: Check how well constraints are being satisfied</li>\n<li><strong>Corrective Action Application</strong>: Apply appropriate stabilization measures based on error severity</li>\n<li><strong>Post-Integration Validation</strong>: Verify simulation state remains stable after corrections</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Ignoring Accumulated Numerical Error</strong>\nMany physics implementations ignore small numerical errors assuming they won&#39;t compound significantly. However, floating-point errors in iterative constraint solvers can grow exponentially, causing stable simulations to suddenly explode after running for extended periods. Always implement error bounds checking and periodic state normalization to prevent long-term instability.</p>\n<h3 id=\"resource-loading-failure-handling\">Resource Loading Failure Handling</h3>\n<p>Resource loading operates in an uncertain environment where files can be corrupted, network connections can fail, and memory can be exhausted at any time. The resource management system must handle these failures gracefully while maintaining game functionality and providing clear feedback about asset problems.</p>\n<h4 id=\"fallback-resource-strategy\">Fallback Resource Strategy</h4>\n<p>When resource loading fails, the system must provide immediate substitutes that maintain game functionality while clearly indicating missing content. The fallback strategy implements a hierarchy of increasingly generic replacements that ensure rendering and audio systems never encounter null resources that could cause crashes.</p>\n<p>The <strong>Fallback Resource Hierarchy</strong> provides multiple levels of replacement content based on resource type and criticality. Essential gameplay resources receive high-quality fallbacks that preserve game mechanics, while cosmetic resources use simple placeholders that maintain visual consistency. The system maintains pre-loaded fallback resources in memory that are immediately available when primary loading fails.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Primary Fallback</th>\n<th>Secondary Fallback</th>\n<th>Emergency Fallback</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Character Texture</td>\n<td>Default character skin</td>\n<td>Solid color texture</td>\n<td>Magenta error texture</td>\n</tr>\n<tr>\n<td>Environment Mesh</td>\n<td>Low-detail substitute</td>\n<td>Bounding box mesh</td>\n<td>Single triangle</td>\n</tr>\n<tr>\n<td>Audio Clip</td>\n<td>Silence placeholder</td>\n<td>Beep sound</td>\n<td>No audio output</td>\n</tr>\n<tr>\n<td>Animation Data</td>\n<td>T-pose default</td>\n<td>Identity transforms</td>\n<td>Static pose</td>\n</tr>\n<tr>\n<td>Font Resource</td>\n<td>System default font</td>\n<td>Basic bitmap font</td>\n<td>ASCII-only fallback</td>\n</tr>\n</tbody></table>\n<p>The fallback selection process considers both the semantic meaning of missing resources and their impact on gameplay. A missing weapon texture might fall back to a generic weapon appearance, preserving the object&#39;s gameplay function while indicating the visual problem. A missing level mesh might use a simple geometric placeholder that maintains collision properties while clearly showing the missing content.</p>\n<p><strong>Fallback Resource Implementation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Fallback Strategy</th>\n<th>Resource Coverage</th>\n<th>Memory Cost</th>\n<th>Quality Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Type-Specific Defaults</td>\n<td>High semantic accuracy</td>\n<td>Medium</td>\n<td>Maintains game feel</td>\n</tr>\n<tr>\n<td>Generic Placeholders</td>\n<td>Universal compatibility</td>\n<td>Low</td>\n<td>Clear error indication</td>\n</tr>\n<tr>\n<td>Procedural Generation</td>\n<td>Infinite variety</td>\n<td>Very Low</td>\n<td>Acceptable quality</td>\n</tr>\n<tr>\n<td>Community Fallbacks</td>\n<td>High visual quality</td>\n<td>High</td>\n<td>Professional appearance</td>\n</tr>\n<tr>\n<td>Asset Bundling</td>\n<td>Guaranteed availability</td>\n<td>Very High</td>\n<td>Perfect fidelity</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Fallback Resource Quality Level</strong></p>\n<ul>\n<li><strong>Context</strong>: Resource loading failures require immediate substitutes but fallback quality affects user experience</li>\n<li><strong>Options Considered</strong>: (1) Minimal placeholders, (2) High-quality defaults, (3) Procedural generation</li>\n<li><strong>Decision</strong>: Type-specific defaults with clear error indication</li>\n<li><strong>Rationale</strong>: Balances development effort with user experience while making missing assets obvious during development</li>\n<li><strong>Consequences</strong>: Requires creating and maintaining fallback assets but prevents confusing user experiences</li>\n</ul>\n</blockquote>\n<h4 id=\"asynchronous-loading-error-propagation\">Asynchronous Loading Error Propagation</h4>\n<p>Asynchronous resource loading introduces complexity in error handling because failures occur on background threads and must be communicated back to game systems safely. The async loading system must ensure errors are reported promptly while maintaining thread safety and avoiding race conditions.</p>\n<p>The <strong>Error Propagation Pipeline</strong> channels loading failures through a thread-safe communication system that delivers error information to the appropriate game systems. Background loading threads detect failures immediately and package error details into thread-safe messages that are queued for main thread processing. The main thread processes these error messages during the resource update phase and takes appropriate corrective action.</p>\n<table>\n<thead>\n<tr>\n<th>Error Source</th>\n<th>Detection Thread</th>\n<th>Propagation Method</th>\n<th>Main Thread Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Not Found</td>\n<td>Worker Thread</td>\n<td>Error message queue</td>\n<td>Load fallback resource</td>\n</tr>\n<tr>\n<td>Decode Failure</td>\n<td>Worker Thread</td>\n<td>Error message with details</td>\n<td>Try alternative decoder</td>\n</tr>\n<tr>\n<td>Memory Exhaustion</td>\n<td>Worker Thread</td>\n<td>Priority error message</td>\n<td>Free unused resources</td>\n</tr>\n<tr>\n<td>Network Timeout</td>\n<td>Network Thread</td>\n<td>Timeout notification</td>\n<td>Retry with backoff</td>\n</tr>\n<tr>\n<td>Validation Failure</td>\n<td>Worker Thread</td>\n<td>Validation error report</td>\n<td>Reject resource</td>\n</tr>\n</tbody></table>\n<p>The <code>ThreadSafeQueue&lt;LoadRequest&gt;</code> system handles error communication by embedding error information directly in the loading request structure. When a loading operation fails, the worker thread updates the request status and error details, then pushes the failed request back to the main thread for error handling. This approach ensures all error information is preserved and properly synchronized.</p>\n<p><strong>Async Error Communication Flow:</strong></p>\n<ol>\n<li><strong>Background Loading</strong>: Worker thread attempts resource loading operation</li>\n<li><strong>Error Detection</strong>: Loading operation fails with specific error code and message</li>\n<li><strong>Error Packaging</strong>: Thread packages error details into LoadRequest structure</li>\n<li><strong>Thread-Safe Queuing</strong>: Error information is queued for main thread processing</li>\n<li><strong>Main Thread Processing</strong>: Game loop processes error queue during resource update phase</li>\n<li><strong>Error Classification</strong>: System determines error severity and appropriate response</li>\n<li><strong>Fallback Activation</strong>: Appropriate fallback resource is loaded and assigned</li>\n<li><strong>User Notification</strong>: Error is logged and optionally reported to user interface</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Race Conditions in Error Handling</strong>\nAsync error handling can create race conditions where the main thread might try to use a resource that&#39;s failed loading but hasn&#39;t been marked as failed yet. Always use atomic operations or proper synchronization when updating resource status, and never assume a resource is valid just because it&#39;s not marked as failed.</p>\n<h4 id=\"user-notification-and-diagnostics\">User Notification and Diagnostics</h4>\n<p>When resource loading fails, users and developers need clear information about what went wrong and how to fix it. The notification system provides layered feedback that ranges from detailed diagnostic information for developers to simple status updates for end users.</p>\n<p>The <strong>Diagnostic Information System</strong> captures comprehensive details about loading failures including file paths, error codes, system state, and recovery actions taken. For developers, this information appears in detailed log files with timestamps and stack traces. For end users, the system provides simplified notifications that explain the impact without technical details.</p>\n<table>\n<thead>\n<tr>\n<th>User Type</th>\n<th>Notification Level</th>\n<th>Information Provided</th>\n<th>Presentation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Developer</td>\n<td>Full Diagnostic</td>\n<td>Complete error details, stack trace, system state</td>\n<td>Console log, debug overlay</td>\n</tr>\n<tr>\n<td>QA Tester</td>\n<td>Intermediate</td>\n<td>Resource name, error type, impact on functionality</td>\n<td>In-game notification</td>\n</tr>\n<tr>\n<td>End User</td>\n<td>Simplified</td>\n<td>General problem description, suggested actions</td>\n<td>Status message</td>\n</tr>\n<tr>\n<td>Support Staff</td>\n<td>Technical Summary</td>\n<td>Error categorization, frequency, system specs</td>\n<td>Automated reports</td>\n</tr>\n<tr>\n<td>Analytics</td>\n<td>Statistical</td>\n<td>Error rates, patterns, hardware correlation</td>\n<td>Telemetry dashboard</td>\n</tr>\n</tbody></table>\n<p>The notification system implements <strong>Error Categorization</strong> that groups similar failures to avoid spamming users with redundant messages. If multiple textures fail to load due to memory exhaustion, the system reports a single &quot;insufficient video memory&quot; error rather than individual texture failures. This aggregation provides clearer diagnosis while reducing notification noise.</p>\n<p><strong>Error Reporting Data Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Purpose</th>\n<th>Audience</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>errorCode</code></td>\n<td><code>uint32_t</code></td>\n<td>Specific failure classification</td>\n<td>Developers</td>\n</tr>\n<tr>\n<td><code>errorMessage</code></td>\n<td><code>string</code></td>\n<td>Human-readable description</td>\n<td>All users</td>\n</tr>\n<tr>\n<td><code>resourcePath</code></td>\n<td><code>string</code></td>\n<td>Failed resource identifier</td>\n<td>Developers/QA</td>\n</tr>\n<tr>\n<td><code>systemState</code></td>\n<td><code>string</code></td>\n<td>Memory/GPU status snapshot</td>\n<td>Support staff</td>\n</tr>\n<tr>\n<td><code>recoverActions</code></td>\n<td><code>vector&lt;string&gt;</code></td>\n<td>Steps taken to handle failure</td>\n<td>QA/Support</td>\n</tr>\n<tr>\n<td><code>userImpact</code></td>\n<td><code>enum</code></td>\n<td>Severity of user experience impact</td>\n<td>End users</td>\n</tr>\n<tr>\n<td><code>frequency</code></td>\n<td><code>uint32_t</code></td>\n<td>How often this error occurs</td>\n<td>Analytics</td>\n</tr>\n<tr>\n<td><code>timestamp</code></td>\n<td><code>uint64_t</code></td>\n<td>When error occurred</td>\n<td>All audiences</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>User Experience Consideration</strong>: Error notifications must strike a balance between providing useful information and avoiding alarm. End users don&#39;t need to know about fallback texture loading, but they should be informed if core gameplay features are affected by resource failures.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling implementation requires careful coordination between multiple engine subsystems to ensure failures are detected early, reported clearly, and handled gracefully without compromising performance or stability.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Logging</td>\n<td><code>printf</code> to console + file output</td>\n<td>Structured logging with <code>spdlog</code> library</td>\n</tr>\n<tr>\n<td>Thread Communication</td>\n<td><code>std::mutex</code> + <code>std::queue</code></td>\n<td>Lock-free <code>boost::lockfree::queue</code></td>\n</tr>\n<tr>\n<td>Graphics Debugging</td>\n<td>Manual <code>glGetError()</code> checks</td>\n<td><code>GL_KHR_debug</code> callback system</td>\n</tr>\n<tr>\n<td>Physics Validation</td>\n<td>Manual bounds checking</td>\n<td>Continuous simulation monitoring</td>\n</tr>\n<tr>\n<td>Resource Validation</td>\n<td>File existence + basic checks</td>\n<td>Comprehensive asset validation pipeline</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The error handling code is distributed across multiple engine subsystems but centralized reporting provides consistent behavior:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">engine</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── core</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── error_manager.h</span><span style=\"color:#6A737D\">          // Central error reporting and categorization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── error_manager.cpp        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── diagnostic_logger.h</span><span style=\"color:#6A737D\">      // Detailed diagnostic information capture</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── graphics</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── gl_error_handler.h</span><span style=\"color:#6A737D\">       // OpenGL-specific error detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── shader_validator.h</span><span style=\"color:#6A737D\">       // Shader compilation error handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── texture_fallbacks.h</span><span style=\"color:#6A737D\">      // Graphics fallback resource system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── physics</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── simulation_monitor.h</span><span style=\"color:#6A737D\">     // Physics stability monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── collision_validator.h</span><span style=\"color:#6A737D\">    // Collision detection validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── resources</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── loading_error_handler.h</span><span style=\"color:#6A737D\">  // Resource loading failure management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── fallback_manager.h</span><span style=\"color:#6A737D\">       // Fallback resource coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── utils</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── thread_safe_queue.h</span><span style=\"color:#6A737D\">      // Async error communication</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    └── performance_monitor.h</span><span style=\"color:#6A737D\">    // System performance tracking</span></span></code></pre></div>\n\n<h4 id=\"graphics-error-detection-infrastructure\">Graphics Error Detection Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Complete OpenGL error checking wrapper that can be enabled/disabled for performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GLErrorChecker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\"> s_enableChecking;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">GLenum, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_errorStrings;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> EnableChecking</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> enable</span><span style=\"color:#E1E4E8\">) { s_enableChecking </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enable; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> CheckErrors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> operation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">s_enableChecking) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Call glGetError() and store result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If no error (GL_NO_ERROR), return true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Look up error string in s_errorStrings map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Log error with operation, file, and line information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Check for context lost condition and trigger recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Return false to indicate error occurred</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use GL_CONTEXT_LOST_KHR for context loss detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> InitializeErrorStrings</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Pre-populate error code to string mapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s_errorStrings[GL_INVALID_ENUM] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Invalid enum parameter\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s_errorStrings[GL_INVALID_VALUE] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Invalid value parameter\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s_errorStrings[GL_INVALID_OPERATION] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Invalid operation for current state\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s_errorStrings[GL_OUT_OF_MEMORY] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Insufficient GPU memory\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s_errorStrings[GL_CONTEXT_LOST_KHR] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Graphics context lost\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Macro for automatic error checking with file/line information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> GL_CHECK</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operation; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        GLErrorChecker</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">CheckErrors</span><span style=\"color:#E1E4E8\">(#operation, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shader compilation with comprehensive error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ShaderCompiler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> CompileShader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> shaderID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> source</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                             GLenum</span><span style=\"color:#FFAB70\"> shaderType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> errorLog</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Set shader source using glShaderSource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Compile shader using glCompileShader  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Check compilation status with glGetShaderiv(GL_COMPILE_STATUS)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: If compilation failed, retrieve error log with glGetShaderInfoLog</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Parse error log to extract line numbers and error descriptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Format user-friendly error message with context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Return compilation success status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Reserve adequate buffer size for error log (e.g., 1024 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> LinkProgram</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> programID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> errorLog</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Link program using glLinkProgram</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check link status with glGetProgramiv(GL_LINK_STATUS)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If linking failed, retrieve error log with glGetProgramInfoLog</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Validate program using glValidateProgram for additional checks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return linking success status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"physics-stability-monitoring-system\">Physics Stability Monitoring System</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Comprehensive physics simulation health monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PhysicsMonitor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> SimulationMetrics</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> totalEnergy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> maxVelocity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> maxPosition;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> nanDetectedCount;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> tunnellingEvents;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> jitterObjects;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SimulationMetrics m_currentMetrics;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SimulationMetrics m_baselineMetrics;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;float></span><span style=\"color:#E1E4E8\"> m_energyHistory;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> m_stabilityThreshold;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> ValidateSimulationState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">RigidBody</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> bodies</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate total kinetic and potential energy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Find maximum object velocity and position magnitude</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Check for NaN/infinity values in all object states</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Compare current metrics against baseline and thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update energy history for trend analysis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Detect objects with excessive jitter (rapid velocity changes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Count potential tunnelling candidates (high velocity vs size ratio)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 8: Return false if any critical thresholds exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use std::isfinite() to check for invalid floating point values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ApplyStabilizationMeasures</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">RigidBody</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> bodies</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Apply velocity clamping to objects exceeding speed limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Reset positions for objects outside world bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Apply additional damping to jittery objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Disable physics for objects with invalid state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Log all corrective actions taken</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Tunnelling prevention for high-speed objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TunnellingPreventer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> CheckForTunnelling</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> RigidBody</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> body</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Transform</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> oldTransform</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                  const</span><span style=\"color:#B392F0\"> Transform</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> newTransform</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate movement distance this frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get collision shape dimensions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Check if movement distance > shape size (potential tunnelling)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: If potential tunnelling, perform continuous collision detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Raycast from old position to new position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: If collision detected, calculate exact impact time and position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Return true if tunnelling would occur without intervention</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> Vector3</span><span style=\"color:#B392F0\"> CalculateSafePosition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> RigidBody</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> body</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                       const</span><span style=\"color:#B392F0\"> CollisionPair</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> collision</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                       float</span><span style=\"color:#FFAB70\"> impactTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate position at exact impact time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Apply collision normal offset to prevent penetration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Validate safe position doesn't cause new overlaps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return corrected position that prevents tunnelling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"resource-loading-error-recovery-system\">Resource Loading Error Recovery System</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Thread-safe error communication between async loaders and main thread</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ThreadSafeErrorQueue</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mutable</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::mutex m_mutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_queue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::condition_variable m_condition;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> m_shutdown;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> item</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Lock mutex for thread-safe access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Add item to queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Notify waiting threads that item is available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Handle shutdown condition gracefully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> TryPop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> item</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Try to lock mutex (don't block)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If queue empty, return false immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Copy front item and remove from queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return true indicating successful pop</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> WaitAndPop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> item</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">milliseconds</span><span style=\"color:#FFAB70\"> timeout</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Lock mutex and wait for item or timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check for shutdown condition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If item available, copy and remove from queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return success status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Comprehensive resource loading error information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ResourceLoadError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string resourcePath;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceType resourceType;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> errorCode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string errorMessage;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string systemState;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> recoveryActions;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::time_point</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::steady_clock</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> timestamp;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> retryCount;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Error severity classification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Severity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        INFO</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">       // Fallback used successfully</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        WARNING</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">    // Non-critical resource failed</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        ERROR</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">      // Important resource failed</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        CRITICAL</span><span style=\"color:#6A737D\">    // Essential resource failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } severity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Fallback resource manager with type-specific defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FallbackResourceManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ResourceType, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Handle</span><span style=\"color:#F97583\">&#x3C;void>>></span><span style=\"color:#E1E4E8\"> m_fallbackHierarchy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> InitializeFallbacks</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Load default fallback textures (error, missing, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create fallback audio clips (silence, beep)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Generate fallback meshes (cube, sphere, plane)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Set up fallback fonts and UI resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Organize fallbacks into quality hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Load fallbacks during engine initialization to guarantee availability</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">GetFallbackResource</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ResourceType</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> qualityLevel</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Look up fallback hierarchy for resource type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Select appropriate quality level (prefer highest available)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Validate fallback resource is loaded and valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Log fallback usage for diagnostic purposes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return handle to fallback resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Always have at least one fallback per type to prevent null handles</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Graphics Error Recovery Validation:</strong></p>\n<ul>\n<li>Run engine with deliberately corrupted shader files — verify fallback shaders load</li>\n<li>Simulate GPU memory exhaustion — confirm texture quality reduction works</li>\n<li>Trigger context loss (minimize/restore window) — validate full recovery</li>\n<li>Expected: Rendering continues with fallbacks, detailed error logs generated</li>\n</ul>\n<p><strong>Physics Stability Verification:</strong></p>\n<ul>\n<li>Create high-speed projectiles — verify tunnelling prevention activates</li>\n<li>Spawn jittery contact scenarios — confirm stabilization reduces oscillation  </li>\n<li>Inject NaN values into physics state — validate error detection and correction</li>\n<li>Expected: Simulation remains stable, diagnostic logs show corrective actions</li>\n</ul>\n<p><strong>Resource Loading Resilience Testing:</strong></p>\n<ul>\n<li>Delete required texture files — verify fallback textures appear</li>\n<li>Corrupt audio files — confirm silent fallbacks prevent crashes</li>\n<li>Fill disk space during loading — validate graceful degradation</li>\n<li>Expected: Game continues running, missing content clearly indicated</li>\n</ul>\n<p>The comprehensive error handling system ensures your game engine remains stable and provides meaningful feedback when failures occur, creating a robust foundation for game development.</p>\n<h2 id=\"testing-strategy-and-milestones\">Testing Strategy and Milestones</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — comprehensive testing strategy that validates each subsystem independently and as an integrated whole</p>\n</blockquote>\n<p>Testing a game engine is like <strong>quality assuring a movie production pipeline</strong>. Just as a film studio needs to verify that cameras capture footage properly, editors can process it, sound engineers can mix it, and projectors can display the final result, a game engine requires validation at every stage: individual systems must work in isolation, data must flow correctly between systems, and the complete pipeline must deliver smooth interactive experiences under performance constraints.</p>\n<p>The fundamental challenge in game engine testing lies in the <strong>real-time constraint</strong>. Unlike traditional software where correctness is the primary concern, game engines must maintain consistent performance while handling thousands of entities, processing physics simulations, and rendering frames within a strict 16.67 millisecond budget. This creates unique testing requirements that blend functional verification with performance validation and stability analysis.</p>\n<p>Game engines also exhibit <strong>emergent behavior</strong> where the interaction between simple systems creates complex outcomes. A sprite might render incorrectly not because the rendering system is broken, but because the ECS query returns stale transforms, the physics system failed to update positions, or resource loading introduced memory corruption. This interconnectedness demands both isolated unit testing and comprehensive integration testing that exercises realistic game scenarios.</p>\n<h3 id=\"milestone-verification-checkpoints\">Milestone Verification Checkpoints</h3>\n<p>Each milestone represents a foundational capability that all subsequent development depends upon. Think of these checkpoints as <strong>structural inspections during construction</strong> — before adding the next floor, you must verify that the current foundation can support the additional load. Failing to properly validate each milestone leads to cascading failures that become exponentially harder to debug as complexity increases.</p>\n<p>The verification approach follows a three-tier strategy: <strong>functional validation</strong> ensures the system works correctly, <strong>performance validation</strong> ensures it meets real-time constraints, and <strong>integration validation</strong> ensures it cooperates properly with other subsystems.</p>\n<h4 id=\"milestone-1-window-amp-rendering-foundation-verification\">Milestone 1: Window &amp; Rendering Foundation Verification</h4>\n<p><strong>Mental Model: Theater Stage Setup</strong></p>\n<p>Before actors can perform, the stage crew must verify that lighting works, curtains open and close properly, and sound equipment functions. Similarly, the rendering foundation must be thoroughly validated before any game content can be displayed.</p>\n<p>The rendering system verification follows a systematic progression from basic functionality through performance stress testing:</p>\n<table>\n<thead>\n<tr>\n<th>Verification Phase</th>\n<th>Test Objective</th>\n<th>Success Criteria</th>\n<th>Common Failure Modes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Window Creation</td>\n<td>OS integration works</td>\n<td>Window appears with correct dimensions, title, and responds to close events</td>\n<td>Window fails to appear, wrong size, or crashes on creation</td>\n</tr>\n<tr>\n<td>Graphics Context</td>\n<td>GPU communication established</td>\n<td>OpenGL context initializes, can clear screen to different colors</td>\n<td>Context creation fails, extensions missing, or driver compatibility issues</td>\n</tr>\n<tr>\n<td>Basic Drawing</td>\n<td>Primitive rendering works</td>\n<td>Single textured quad renders at correct position and size</td>\n<td>Black screen, texture not loading, incorrect positioning</td>\n</tr>\n<tr>\n<td>Shader System</td>\n<td>Programmable pipeline functions</td>\n<td>Custom shaders compile, link, and render with different colors/effects</td>\n<td>Shader compilation errors, linking failures, uniform variables not working</td>\n</tr>\n<tr>\n<td>Batch Rendering</td>\n<td>Performance optimization active</td>\n<td>Multiple sprites render efficiently with minimal draw calls</td>\n<td>Poor performance, visual artifacts, incorrect sprite ordering</td>\n</tr>\n</tbody></table>\n<p><strong>Functional Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Window Lifecycle Test</strong>: Create window, resize it, minimize/restore, and close cleanly. The <code>Window</code> class should handle all events without memory leaks or crashes.</p>\n</li>\n<li><p><strong>Graphics Context Robustness</strong>: Initialize OpenGL context, verify required extensions exist, and handle context loss scenarios gracefully.</p>\n</li>\n<li><p><strong>Texture Loading Pipeline</strong>: Load various image formats (PNG, JPG), handle invalid files, and verify GPU upload completes successfully.</p>\n</li>\n<li><p><strong>Shader Compilation Verification</strong>: Load valid vertex/fragment shader pairs, test compilation error handling with malformed shaders, and verify uniform variable access.</p>\n</li>\n<li><p><strong>Basic Sprite Rendering</strong>: Draw single sprite with correct position, rotation, scale, and color. Verify texture coordinates map properly and alpha blending works.</p>\n</li>\n</ol>\n<p><strong>Performance Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Frame Rate Consistency</strong>: Render 100 sprites and measure frame times. Should maintain 60 FPS consistently without significant variance.</p>\n</li>\n<li><p><strong>Batch Efficiency</strong>: Compare rendering 1000 individual sprites versus batched rendering. Batching should reduce draw calls from 1000 to 1-10.</p>\n</li>\n<li><p><strong>Memory Usage Stability</strong>: Run rendering loop for extended periods and verify no memory leaks in texture or shader resources.</p>\n</li>\n</ol>\n<p><strong>Integration Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Event Processing</strong>: Verify window events (resize, input) are processed correctly during active rendering.</p>\n</li>\n<li><p><strong>Resource Cleanup</strong>: Ensure proper cleanup when window closes or graphics context is lost.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Critical Checkpoint</strong>: After Milestone 1, you should be able to run a simple program that opens a window, loads a texture, and displays a rotating sprite at 60 FPS without memory leaks or crashes.</p>\n</blockquote>\n<h4 id=\"milestone-2-entity-component-system-verification\">Milestone 2: Entity Component System Verification</h4>\n<p><strong>Mental Model: Database Query Performance Testing</strong></p>\n<p>The ECS is like a specialized database optimized for real-time queries. Just as database administrators run performance tests to ensure query response times meet SLA requirements, ECS verification must validate both correctness and performance under realistic entity loads.</p>\n<p>ECS testing focuses heavily on <strong>data integrity</strong> and <strong>performance characteristics</strong> because subtle bugs in entity management or component storage can corrupt game state in ways that manifest much later:</p>\n<table>\n<thead>\n<tr>\n<th>Verification Phase</th>\n<th>Test Objective</th>\n<th>Success Criteria</th>\n<th>Performance Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Management</td>\n<td>ID recycling works correctly</td>\n<td>Create/destroy entities without ID collisions or leaks</td>\n<td>Handle 10,000+ entities</td>\n</tr>\n<tr>\n<td>Component Storage</td>\n<td>Data remains consistent</td>\n<td>Add/remove components maintains entity-component relationships</td>\n<td>O(1) access times</td>\n</tr>\n<tr>\n<td>System Execution</td>\n<td>Iteration is cache-friendly</td>\n<td>Systems process entities efficiently without skipping or duplicating</td>\n<td>Process 5,000+ entities per system</td>\n</tr>\n<tr>\n<td>Query Performance</td>\n<td>Component filtering is fast</td>\n<td>Multi-component queries return correct entity sets</td>\n<td>Sub-millisecond query times</td>\n</tr>\n</tbody></table>\n<p><strong>Functional Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Entity ID Recycling</strong>: Create entities until ID space fills, destroy some, create new ones. Verify IDs are recycled correctly and no collisions occur.</p>\n</li>\n<li><p><strong>Component Lifetime Management</strong>: Add components to entities, remove them, verify memory is cleaned up and entity relationships remain consistent.</p>\n</li>\n<li><p><strong>System Execution Order</strong>: Register systems with dependencies, verify execution order respects dependency graph.</p>\n</li>\n<li><p><strong>Multi-Component Queries</strong>: Create entities with various component combinations, run queries for specific signatures, verify correct entities are returned.</p>\n</li>\n<li><p><strong>Entity Destruction Cascade</strong>: Destroy entities with multiple components, verify all component references are cleaned up properly.</p>\n</li>\n</ol>\n<p><strong>Performance Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Component Iteration Performance</strong>: Time system iteration over 10,000 entities with various component densities. Should complete in under 1ms per system.</p>\n</li>\n<li><p><strong>Memory Layout Efficiency</strong>: Measure cache miss rates during component iteration using performance counters or profiling tools.</p>\n</li>\n<li><p><strong>Query Scalability</strong>: Benchmark query performance as entity count increases from 1,000 to 100,000 entities.</p>\n</li>\n</ol>\n<p><strong>Integration Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Rendering Integration</strong>: Create entities with <code>Transform</code> and <code>Sprite</code> components, verify rendering system processes them correctly.</p>\n</li>\n<li><p><strong>Component Modification During Iteration</strong>: Test adding/removing components while systems are executing, ensure no crashes or data corruption.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Critical Checkpoint</strong>: After Milestone 2, you should be able to create 10,000 entities with mixed components, run multiple systems that process them in under 1ms each, and destroy entities without memory leaks.</p>\n</blockquote>\n<h4 id=\"milestone-3-physics-amp-collision-verification\">Milestone 3: Physics &amp; Collision Verification</h4>\n<p><strong>Mental Model: Scientific Experiment Validation</strong></p>\n<p>Physics simulation is like conducting repeatable scientific experiments. The same initial conditions must always produce identical results, energy should be conserved (within numerical precision), and the simulation should remain stable over extended periods.</p>\n<p>Physics testing requires special attention to <strong>numerical stability</strong> and <strong>determinism</strong>. Small floating-point errors can accumulate over time, leading to objects slowly gaining energy, falling through floors, or exhibiting other non-physical behaviors:</p>\n<table>\n<thead>\n<tr>\n<th>Verification Phase</th>\n<th>Test Objective</th>\n<th>Success Criteria</th>\n<th>Stability Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Collision Detection</td>\n<td>Geometric accuracy</td>\n<td>AABB and circle intersections detected correctly</td>\n<td>No false positives/negatives</td>\n</tr>\n<tr>\n<td>Physics Integration</td>\n<td>Energy conservation</td>\n<td>Objects don&#39;t gain energy spontaneously</td>\n<td>Energy drift &lt; 1% over 1000 frames</td>\n</tr>\n<tr>\n<td>Collision Response</td>\n<td>Realistic behavior</td>\n<td>Objects bounce and separate naturally</td>\n<td>No penetration or jitter</td>\n</tr>\n<tr>\n<td>Spatial Partitioning</td>\n<td>Performance scaling</td>\n<td>Collision detection remains fast with many objects</td>\n<td>O(n log n) or better</td>\n</tr>\n<tr>\n<td>Timestep Stability</td>\n<td>Deterministic results</td>\n<td>Same inputs always produce same outputs</td>\n<td>Bit-identical across runs</td>\n</tr>\n</tbody></table>\n<p><strong>Functional Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Basic Collision Detection</strong>: Test AABB vs AABB and circle vs circle intersection with known geometric cases, verify accuracy.</p>\n</li>\n<li><p><strong>Physics Integration</strong>: Drop objects under gravity, measure velocities and positions, verify they match analytical solutions.</p>\n</li>\n<li><p><strong>Collision Response</strong>: Collide objects with different masses and velocities, verify momentum and energy are conserved approximately.</p>\n</li>\n<li><p><strong>Spatial Partitioning Correctness</strong>: Distribute objects across space, verify spatial queries return correct neighbor sets.</p>\n</li>\n<li><p><strong>Edge Case Handling</strong>: Test objects at cell boundaries, very small objects, and high-velocity collisions.</p>\n</li>\n</ol>\n<p><strong>Performance Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Collision Scaling</strong>: Measure collision detection time as object count increases. Should scale better than O(n²).</p>\n</li>\n<li><p><strong>Physics Timestep Consistency</strong>: Run physics simulation and measure frame processing times. Should complete reliably within timestep budget.</p>\n</li>\n<li><p><strong>Memory Access Pattern</strong>: Profile cache performance during collision detection, optimize for spatial locality.</p>\n</li>\n</ol>\n<p><strong>Stability Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Energy Conservation</strong>: Run simulation with bouncing balls for 10,000 timesteps, verify total energy remains approximately constant.</p>\n</li>\n<li><p><strong>Determinism Verification</strong>: Run identical scenarios multiple times, verify positions and velocities match exactly.</p>\n</li>\n<li><p><strong>Numerical Stability</strong>: Test extreme cases (very light/heavy objects, high velocities, many contacts) and verify simulation remains stable.</p>\n</li>\n</ol>\n<p><strong>Integration Validation Tests:</strong></p>\n<ol>\n<li><p><strong>ECS Integration</strong>: Verify physics system correctly updates <code>Transform</code> components, rendering system displays updated positions.</p>\n</li>\n<li><p><strong>Multi-System Coordination</strong>: Test physics running alongside other systems without interference or race conditions.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Critical Checkpoint</strong>: After Milestone 3, you should be able to simulate 500+ rigid bodies with realistic physics behavior, stable energy levels over extended periods, and deterministic results across multiple runs.</p>\n</blockquote>\n<h4 id=\"milestone-4-resource-amp-scene-management-verification\">Milestone 4: Resource &amp; Scene Management Verification</h4>\n<p><strong>Mental Model: Library Management System</strong></p>\n<p>Resource management is like running a library where books (assets) must be checked out, tracked, returned, and replaced when damaged. The system must handle concurrent requests, prevent loss of materials, and maintain accurate records even when patrons behave unexpectedly.</p>\n<p>Resource system testing emphasizes <strong>lifecycle management</strong> and <strong>concurrency safety</strong> because resource leaks and loading race conditions are common sources of instability:</p>\n<table>\n<thead>\n<tr>\n<th>Verification Phase</th>\n<th>Test Objective</th>\n<th>Success Criteria</th>\n<th>Reliability Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Asset Loading</td>\n<td>File formats supported</td>\n<td>Load textures, meshes, audio from various formats</td>\n<td>Handle corrupt/missing files</td>\n</tr>\n<tr>\n<td>Reference Counting</td>\n<td>No resource leaks</td>\n<td>Resources freed when no longer referenced</td>\n<td>Zero leaks over extended use</td>\n</tr>\n<tr>\n<td>Async Loading</td>\n<td>Thread safety</td>\n<td>Background loading without blocking main thread</td>\n<td>No race conditions</td>\n</tr>\n<tr>\n<td>Scene Serialization</td>\n<td>Data persistence</td>\n<td>Save/load scenes with full fidelity</td>\n<td>Bit-identical round trips</td>\n</tr>\n<tr>\n<td>Transition Handling</td>\n<td>State consistency</td>\n<td>Scene changes maintain resource consistency</td>\n<td>No crashes during transitions</td>\n</tr>\n</tbody></table>\n<p><strong>Functional Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Multi-Format Loading</strong>: Load assets in different formats, verify content loads correctly and GPU resources are created properly.</p>\n</li>\n<li><p><strong>Reference Counting Accuracy</strong>: Load resources, create multiple handles, release handles, verify cleanup occurs when reference count reaches zero.</p>\n</li>\n<li><p><strong>Async Loading Pipeline</strong>: Request multiple assets asynchronously, verify they load in background and complete callbacks execute correctly.</p>\n</li>\n<li><p><strong>Scene Serialization Round-Trip</strong>: Create complex scene with entities and components, save to file, load into new scene, verify identical state.</p>\n</li>\n<li><p><strong>Resource Handle Validation</strong>: Test access to invalid handles, ensure graceful failure without crashes.</p>\n</li>\n</ol>\n<p><strong>Performance Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Loading Throughput</strong>: Measure asset loading speed for various file sizes, optimize for typical game content volumes.</p>\n</li>\n<li><p><strong>Memory Efficiency</strong>: Monitor memory usage during loading, verify resources are shared appropriately and freed promptly.</p>\n</li>\n<li><p><strong>Cache Hit Rates</strong>: Test resource cache effectiveness, measure how often duplicate requests are satisfied from cache.</p>\n</li>\n</ol>\n<p><strong>Concurrency Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Thread Safety</strong>: Load resources from multiple threads simultaneously, verify no data corruption or crashes occur.</p>\n</li>\n<li><p><strong>Main Thread Integration</strong>: Verify async loading completions are processed safely on main thread without blocking.</p>\n</li>\n</ol>\n<p><strong>Integration Validation Tests:</strong></p>\n<ol>\n<li><p><strong>Cross-System Resource Usage</strong>: Load textures used by rendering system, verify proper coordination between resource manager and renderer.</p>\n</li>\n<li><p><strong>Scene Transition Stability</strong>: Test transitions between different scenes, verify resources load/unload correctly and no references remain dangling.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Critical Checkpoint</strong>: After Milestone 4, you should be able to load complex scenes with hundreds of assets, transition between scenes without memory leaks, and handle loading errors gracefully.</p>\n</blockquote>\n<h3 id=\"component-unit-testing\">Component Unit Testing</h3>\n<p>Unit testing individual engine subsystems is like <strong>testing car components on a test bench</strong> before assembling the complete vehicle. Each component must demonstrate correct behavior in isolation before being integrated into the larger system. Game engine unit testing requires special techniques because many components interact closely with hardware, operate under performance constraints, or manage complex internal state.</p>\n<p>The key insight for game engine unit testing is that <strong>behavioral correctness</strong> is often more important than exact implementation details. A physics system that conserves energy and prevents tunneling is correct regardless of the specific integration method used. This leads to testing strategies that verify observable outcomes rather than internal implementation steps.</p>\n<h4 id=\"ecs-query-system-testing\">ECS Query System Testing</h4>\n<p><strong>Mental Model: Database Query Validation</strong></p>\n<p>Testing ECS queries is like validating database queries — you create known data sets, run queries, and verify the result sets contain exactly the expected records. However, ECS queries must also meet performance requirements since they execute every frame.</p>\n<p>The ECS query system requires comprehensive testing because subtle bugs can cause systems to process incorrect entity sets, leading to game logic errors that are difficult to trace back to the ECS layer:</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Objective</th>\n<th>Validation Approach</th>\n<th>Performance Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single Component Queries</td>\n<td>Correct entity filtering</td>\n<td>Create entities with/without components, verify query results</td>\n<td>Sub-millisecond execution</td>\n</tr>\n<tr>\n<td>Multi-Component Queries</td>\n<td>Intersection logic</td>\n<td>Test AND, OR, NOT combinations of component requirements</td>\n<td>O(n) scaling with entity count</td>\n</tr>\n<tr>\n<td>Component Modification</td>\n<td>Iteration stability</td>\n<td>Add/remove components during iteration, verify no corruption</td>\n<td>No iterator invalidation</td>\n</tr>\n<tr>\n<td>Query Caching</td>\n<td>Performance optimization</td>\n<td>Repeated queries should use cached results when possible</td>\n<td>10x speedup for cached queries</td>\n</tr>\n<tr>\n<td>Memory Layout</td>\n<td>Cache efficiency</td>\n<td>Verify component iteration accesses memory sequentially</td>\n<td>Minimal cache misses</td>\n</tr>\n</tbody></table>\n<p><strong>Core Test Scenarios:</strong></p>\n<ol>\n<li><p><strong>Entity Set Validation Tests</strong>: Create a known population of entities with specific component combinations. Run queries for various component signatures and verify the returned entity sets exactly match expected results.</p>\n</li>\n<li><p><strong>Component Addition/Removal Tests</strong>: Start with entities lacking required components, add components, run queries, verify entities appear in results. Remove components and verify entities disappear from subsequent queries.</p>\n</li>\n<li><p><strong>Performance Scaling Tests</strong>: Create entity populations ranging from 100 to 100,000 entities, measure query execution time, verify it scales linearly or better.</p>\n</li>\n<li><p><strong>Concurrent Modification Tests</strong>: Run queries while other threads add/remove entities and components, verify results remain consistent and no crashes occur.</p>\n</li>\n<li><p><strong>Memory Access Pattern Tests</strong>: Use profiling tools to verify component iteration accesses memory in cache-friendly patterns with minimal random access.</p>\n</li>\n</ol>\n<p><strong>Test Implementation Strategy:</strong></p>\n<p>The testing approach uses <strong>controlled entity populations</strong> where the test setup creates entities with known component combinations, making it easy to predict correct query results:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Test Setup: \n- 100 entities with Transform component only\n- 50 entities with Transform + Sprite components  \n- 25 entities with Transform + Sprite + RigidBody components\n- 25 entities with Sprite component only\n\nQuery Test Cases:\n- Query&lt;Transform&gt;() should return 175 entities (100+50+25)\n- Query&lt;Transform, Sprite&gt;() should return 75 entities (50+25)  \n- Query&lt;Transform, Sprite, RigidBody&gt;() should return 25 entities\n- Query&lt;Sprite&gt;() should return 100 entities (50+25+25)</code></pre></div>\n\n<h4 id=\"collision-detection-testing\">Collision Detection Testing</h4>\n<p><strong>Mental Model: Geometric Proof Verification</strong></p>\n<p>Collision detection testing is like verifying geometric proofs — you create scenarios with known mathematical answers and verify the algorithm produces correct results. The challenge is covering edge cases that might not occur during typical gameplay but could cause crashes or incorrect physics behavior.</p>\n<p>Collision detection requires both <strong>correctness testing</strong> and <strong>performance validation</strong> because errors can cause objects to fall through floors or tunnel through barriers, while poor performance can cause frame rate drops:</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Objective</th>\n<th>Validation Method</th>\n<th>Accuracy Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic Intersection</td>\n<td>Geometric accuracy</td>\n<td>Test known overlapping/non-overlapping cases</td>\n<td>Zero false positives/negatives</td>\n</tr>\n<tr>\n<td>Edge Cases</td>\n<td>Boundary handling</td>\n<td>Objects at exact boundaries, zero-size objects</td>\n<td>Consistent behavior</td>\n</tr>\n<tr>\n<td>Performance</td>\n<td>Scaling behavior</td>\n<td>Time detection with increasing object counts</td>\n<td>O(n log n) or better</td>\n</tr>\n<tr>\n<td>Spatial Partitioning</td>\n<td>Optimization correctness</td>\n<td>Verify spatial queries return same results as brute force</td>\n<td>Identical result sets</td>\n</tr>\n<tr>\n<td>Numerical Precision</td>\n<td>Floating-point stability</td>\n<td>Test with very small/large coordinates</td>\n<td>Stable results</td>\n</tr>\n</tbody></table>\n<p><strong>Core Test Scenarios:</strong></p>\n<ol>\n<li><p><strong>Known Geometry Tests</strong>: Create AABB and circle pairs with manually calculated intersection results, verify collision detection matches analytical solutions.</p>\n</li>\n<li><p><strong>Boundary Case Tests</strong>: Test objects that exactly touch at edges, objects with zero dimensions, and objects at floating-point precision limits.</p>\n</li>\n<li><p><strong>Spatial Partitioning Validation</strong>: Compare spatial partitioning results against brute-force collision detection, verify identical collision pairs are detected.</p>\n</li>\n<li><p><strong>Performance Regression Tests</strong>: Benchmark collision detection time with fixed object distributions, alert when performance degrades significantly.</p>\n</li>\n<li><p><strong>Numerical Stability Tests</strong>: Run collision detection with very large or very small coordinates, verify results remain consistent and don&#39;t produce NaN values.</p>\n</li>\n</ol>\n<h4 id=\"resource-loading-testing\">Resource Loading Testing</h4>\n<p><strong>Mental Model: File System Stress Testing</strong></p>\n<p>Resource loading testing is like stress testing a file system — you need to verify it handles various file formats, sizes, corruption scenarios, and concurrent access patterns without losing data or crashing.</p>\n<p>Resource loading testing must cover <strong>file format variations</strong>, <strong>error conditions</strong>, and <strong>concurrency scenarios</strong> because games load assets from diverse sources and must handle missing files, network interruptions, or corrupted data gracefully:</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Objective</th>\n<th>Test Scenarios</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Format Support</td>\n<td>Multi-format loading</td>\n<td>PNG, JPG, OBJ, WAV files with various parameters</td>\n<td>Graceful degradation</td>\n</tr>\n<tr>\n<td>Error Conditions</td>\n<td>Resilient loading</td>\n<td>Missing files, corrupted data, insufficient memory</td>\n<td>Clear error messages</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>Thread safety</td>\n<td>Multiple threads loading different/same resources</td>\n<td>No race conditions</td>\n</tr>\n<tr>\n<td>Cache Behavior</td>\n<td>Efficiency</td>\n<td>Duplicate load requests should return cached results</td>\n<td>Reference sharing</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Resource cleanup</td>\n<td>Resources freed when no longer referenced</td>\n<td>Zero leaks</td>\n</tr>\n</tbody></table>\n<p><strong>Core Test Scenarios:</strong></p>\n<ol>\n<li><p><strong>Multi-Format Validation</strong>: Load assets in different formats with various compression settings, color depths, and resolutions. Verify loaded data matches expected content.</p>\n</li>\n<li><p><strong>Error Condition Testing</strong>: Test loading from non-existent files, corrupted files, and files with incorrect headers. Verify appropriate error codes are returned and no crashes occur.</p>\n</li>\n<li><p><strong>Concurrent Loading Tests</strong>: Start multiple loading operations from different threads targeting the same and different files. Verify thread safety and proper resource sharing.</p>\n</li>\n<li><p><strong>Reference Counting Validation</strong>: Create multiple handles to the same resource, release handles in various orders, verify cleanup occurs exactly when the last reference is released.</p>\n</li>\n<li><p><strong>Memory Pressure Testing</strong>: Load large numbers of resources until memory is exhausted, verify graceful handling and cleanup of partially loaded resources.</p>\n</li>\n</ol>\n<h3 id=\"system-integration-testing\">System Integration Testing</h3>\n<p>Integration testing for game engines is like <strong>rehearsing a complete orchestra performance</strong> — while individual musicians might play their parts perfectly, the complete performance requires precise timing, coordination, and handling of unexpected situations like missed cues or equipment failures.</p>\n<p>Game engine integration testing focuses on <strong>frame processing pipelines</strong>, <strong>cross-system data flow</strong>, and <strong>performance under realistic loads</strong>. The goal is to verify that all subsystems work together to deliver consistent interactive experiences without crashes, memory leaks, or performance degradation.</p>\n<h4 id=\"frame-processing-pipeline-testing\">Frame Processing Pipeline Testing</h4>\n<p><strong>Mental Model: Manufacturing Assembly Line Validation</strong></p>\n<p>The frame processing pipeline is like a manufacturing assembly line where each station (system) performs operations on products (entities) flowing through the line. Integration testing validates that the assembly line maintains throughput, quality, and timing under various load conditions.</p>\n<p>Frame processing integration testing must verify <strong>system execution order</strong>, <strong>data consistency across frames</strong>, and <strong>performance stability</strong> because errors in frame processing can cause visual glitches, input lag, or game logic inconsistencies:</p>\n<table>\n<thead>\n<tr>\n<th>Integration Aspect</th>\n<th>Test Objective</th>\n<th>Validation Criteria</th>\n<th>Performance Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System Execution Order</td>\n<td>Dependencies respected</td>\n<td>Systems run in correct sequence without race conditions</td>\n<td>Deterministic execution</td>\n</tr>\n<tr>\n<td>Data Flow Consistency</td>\n<td>Information propagates</td>\n<td>Changes in one system visible to dependent systems</td>\n<td>One-frame propagation delay</td>\n</tr>\n<tr>\n<td>Frame Time Budget</td>\n<td>Performance stability</td>\n<td>Complete frame processing within 16.67ms target</td>\n<td>95% of frames meet deadline</td>\n</tr>\n<tr>\n<td>Memory Stability</td>\n<td>Resource management</td>\n<td>No memory growth or leaks during extended operation</td>\n<td>Stable memory usage</td>\n</tr>\n<tr>\n<td>Error Propagation</td>\n<td>Failure isolation</td>\n<td>Errors in one system don&#39;t crash other systems</td>\n<td>Graceful degradation</td>\n</tr>\n</tbody></table>\n<p><strong>Frame Processing Test Scenarios:</strong></p>\n<ol>\n<li><p><strong>Complete Game Loop Integration</strong>: Run realistic game scenarios with moving entities, collisions, rendering, and user input. Verify all systems coordinate properly and maintain target frame rate.</p>\n</li>\n<li><p><strong>System Dependency Validation</strong>: Create scenarios where systems have clear dependencies (physics updates positions, rendering uses updated positions), verify execution order ensures consistency.</p>\n</li>\n<li><p><strong>Performance Stress Testing</strong>: Gradually increase entity counts, collision complexity, and rendering load until frame rate drops, identify bottlenecks and scaling limits.</p>\n</li>\n<li><p><strong>Error Injection Testing</strong>: Introduce controlled failures in individual systems (resource loading errors, physics instabilities, rendering failures), verify other systems continue operating.</p>\n</li>\n<li><p><strong>Extended Operation Testing</strong>: Run game engine continuously for hours or days, monitor memory usage, frame rate consistency, and resource cleanup.</p>\n</li>\n</ol>\n<p><strong>Cross-System Data Flow Validation:</strong></p>\n<p>The frame processing pipeline requires careful validation of how data flows between systems because <strong>temporal coupling</strong> can create subtle bugs where systems read stale data or miss important updates:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Frame N Processing Order:\n1. Input System: Updates input component states\n2. Game Logic Systems: Process gameplay rules using input\n3. Physics System: Updates positions/velocities  \n4. Collision System: Resolves collisions, modifies positions\n5. Animation System: Updates sprite frames based on time\n6. Rendering System: Draws entities using final positions\n\nValidation Points:\n- Physics system sees input changes from Frame N\n- Rendering system sees position changes from Frame N physics\n- No system uses data that's more than 1 frame old</code></pre></div>\n\n<h4 id=\"scene-transition-integration-testing\">Scene Transition Integration Testing</h4>\n<p><strong>Mental Model: Theater Set Changes</strong></p>\n<p>Scene transitions are like complex set changes during a theater performance — the old set must be struck, new sets must be assembled, lighting must be reconfigured, and actors must be repositioned, all while maintaining the illusion of continuity for the audience.</p>\n<p>Scene transition testing validates <strong>resource lifecycle management</strong>, <strong>state consistency</strong>, and <strong>transition timing</strong> because errors during scene changes can cause crashes, memory leaks, or inconsistent game state:</p>\n<table>\n<thead>\n<tr>\n<th>Transition Aspect</th>\n<th>Test Objective</th>\n<th>Success Criteria</th>\n<th>Reliability Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Resource Cleanup</td>\n<td>No memory leaks</td>\n<td>All old scene resources freed completely</td>\n<td>Zero leaked resources</td>\n</tr>\n<tr>\n<td>Asset Loading</td>\n<td>New content ready</td>\n<td>All required assets loaded before scene activation</td>\n<td>100% loading success</td>\n</tr>\n<tr>\n<td>State Consistency</td>\n<td>No data corruption</td>\n<td>Entity-component relationships remain valid</td>\n<td>Zero state corruption</td>\n</tr>\n<tr>\n<td>Transition Timing</td>\n<td>Smooth experience</td>\n<td>Scene changes complete within acceptable time</td>\n<td>&lt; 2 second transitions</td>\n</tr>\n<tr>\n<td>Error Recovery</td>\n<td>Failure resilience</td>\n<td>Failed transitions don&#39;t corrupt current scene</td>\n<td>Graceful fallback</td>\n</tr>\n</tbody></table>\n<p><strong>Scene Transition Test Scenarios:</strong></p>\n<ol>\n<li><p><strong>Resource Lifecycle Validation</strong>: Create scenes with shared and unique resources, perform transitions, verify shared resources remain loaded and unique resources are freed appropriately.</p>\n</li>\n<li><p><strong>State Transfer Testing</strong>: Test scenarios where some game state must persist across scene transitions (player inventory, global settings), verify data survives the transition correctly.</p>\n</li>\n<li><p><strong>Loading Failure Recovery</strong>: Simulate asset loading failures during scene transitions, verify the system can recover gracefully without corrupting the current scene.</p>\n</li>\n<li><p><strong>Rapid Transition Testing</strong>: Perform multiple scene transitions in quick succession, verify the system handles overlapping load/unload operations correctly.</p>\n</li>\n<li><p><strong>Memory Pressure Testing</strong>: Perform scene transitions while memory is nearly exhausted, verify graceful handling and cleanup prioritization.</p>\n</li>\n</ol>\n<h4 id=\"performance-integration-testing\">Performance Integration Testing</h4>\n<p><strong>Mental Model: Orchestra Tempo Maintenance</strong></p>\n<p>Performance integration testing is like validating that an orchestra maintains consistent tempo throughout a complex musical piece, even during challenging passages with many instruments playing intricate parts simultaneously.</p>\n<p>Performance testing must validate <strong>frame rate consistency</strong>, <strong>scalability limits</strong>, and <strong>resource usage patterns</strong> under realistic game loads because performance problems often emerge only when multiple systems are operating simultaneously:</p>\n<table>\n<thead>\n<tr>\n<th>Performance Aspect</th>\n<th>Test Objective</th>\n<th>Measurement Method</th>\n<th>Target Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame Rate Stability</td>\n<td>Consistent timing</td>\n<td>Frame time histograms over extended periods</td>\n<td>95% frames within 16.67ms</td>\n</tr>\n<tr>\n<td>CPU Usage Distribution</td>\n<td>Work balance</td>\n<td>Profiling system execution times</td>\n<td>No single system dominates</td>\n</tr>\n<tr>\n<td>Memory Usage Patterns</td>\n<td>Resource efficiency</td>\n<td>Memory allocation/deallocation tracking</td>\n<td>Minimal garbage collection</td>\n</tr>\n<tr>\n<td>GPU Resource Usage</td>\n<td>Graphics efficiency</td>\n<td>Draw call counts, texture memory usage</td>\n<td>Optimal batching achieved</td>\n</tr>\n<tr>\n<td>Scalability Limits</td>\n<td>Performance boundaries</td>\n<td>Entity counts where performance degrades</td>\n<td>Graceful degradation</td>\n</tr>\n</tbody></table>\n<p><strong>Performance Integration Test Scenarios:</strong></p>\n<ol>\n<li><p><strong>Realistic Game Simulation</strong>: Create scenarios that mimic actual gameplay with typical entity counts, interaction patterns, and content complexity. Measure performance over extended periods.</p>\n</li>\n<li><p><strong>Scalability Boundary Testing</strong>: Gradually increase system load (entities, collisions, rendering complexity) until performance targets are no longer met. Identify specific bottlenecks and scaling limits.</p>\n</li>\n<li><p><strong>Resource Contention Testing</strong>: Create scenarios where multiple systems compete for shared resources (memory, CPU cache, GPU bandwidth), measure impact on individual system performance.</p>\n</li>\n<li><p><strong>Background Loading Impact</strong>: Run performance tests while background asset loading is active, verify main thread performance remains stable.</p>\n</li>\n<li><p><strong>Memory Fragmentation Analysis</strong>: Run extended performance tests while monitoring memory allocation patterns, identify potential fragmentation issues that could cause performance degradation over time.</p>\n</li>\n</ol>\n<p><strong>Benchmark Suite Development:</strong></p>\n<p>A comprehensive benchmark suite provides <strong>repeatable performance validation</strong> across different hardware configurations and development stages:</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark Category</th>\n<th>Measurement Target</th>\n<th>Validation Criteria</th>\n<th>Hardware Coverage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Processing</td>\n<td>ECS system performance</td>\n<td>Entities processed per millisecond</td>\n<td>Low-end to high-end CPUs</td>\n</tr>\n<tr>\n<td>Rendering Throughput</td>\n<td>Graphics performance</td>\n<td>Sprites/polygons rendered per frame</td>\n<td>Integrated to discrete GPUs</td>\n</tr>\n<tr>\n<td>Physics Simulation</td>\n<td>Collision performance</td>\n<td>Rigid bodies simulated per frame</td>\n<td>Various CPU architectures</td>\n</tr>\n<tr>\n<td>Asset Loading</td>\n<td>I/O performance</td>\n<td>MB loaded per second</td>\n<td>HDD, SSD, network storage</td>\n</tr>\n<tr>\n<td>Memory Efficiency</td>\n<td>Resource usage</td>\n<td>Peak and average memory consumption</td>\n<td>Limited to abundant RAM</td>\n</tr>\n</tbody></table>\n<p>The benchmark suite should run automatically during development to detect performance regressions and provide consistent metrics for optimization efforts.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This testing strategy transforms from design concept into practical validation code that builds confidence in each engine subsystem. The implementation focuses on creating a comprehensive test suite that can run automatically and provide clear feedback about system correctness and performance.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td>Simple assertion macros with manual test registration</td>\n<td>Google Test with parameterized tests and fixtures</td>\n<td>Start simple, upgrade for complex test scenarios</td>\n</tr>\n<tr>\n<td>Performance Measurement</td>\n<td>Basic timing with std::chrono</td>\n<td>Profiling integration with Tracy or Optick</td>\n<td>Manual timing sufficient initially, profiler needed for optimization</td>\n</tr>\n<tr>\n<td>Memory Testing</td>\n<td>Manual leak detection with reference counting</td>\n<td>Valgrind or Address Sanitizer integration</td>\n<td>Platform-specific tools for comprehensive validation</td>\n</tr>\n<tr>\n<td>Graphics Testing</td>\n<td>Manual visual verification</td>\n<td>Automated screenshot comparison</td>\n<td>Visual verification adequate for educational project</td>\n</tr>\n<tr>\n<td>Benchmark Automation</td>\n<td>Manual execution and timing</td>\n<td>Continuous integration with performance tracking</td>\n<td>Manual acceptable for learning, CI valuable for production</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── engine</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── core</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">              ← Core engine systems</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── rendering</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">         ← Graphics pipeline </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ecs</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">              ← Entity Component System</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── physics</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">          ← Physics </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> collision</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── resources</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">        ← Asset </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> scene management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── unit</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">             ← Individual system tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── test_ecs.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── test_physics.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── test_rendering.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── test_resources.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── integration</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">      ← Cross</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">system tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── test_frame_processing.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── test_scene_transitions.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── test_performance.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── assets</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">          ← Test asset files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── textures</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── meshes</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── scenes</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── framework</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">       ← Testing utilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── test_framework.h</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── performance_timer.h</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       └── mock_systems.h</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── benchmarks</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">          ← Performance validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── ecs_benchmark.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── physics_benchmark.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    └── rendering_benchmark.cpp</span></span></code></pre></div>\n\n<h4 id=\"testing-framework-infrastructure\">Testing Framework Infrastructure</h4>\n<p>Complete testing infrastructure that provides assertion macros, test registration, and performance measurement capabilities:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/framework/test_framework.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> TestFramework</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> TestResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string testName;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> passed;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string errorMessage;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> executionTimeMs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestRunner</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> TestRunner</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> Instance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        static</span><span style=\"color:#E1E4E8\"> TestRunner instance;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> instance;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RegisterTest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">()> </span><span style=\"color:#FFAB70\">testFunc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">TestResult</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">RunAllTests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RunTestsByPattern</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> pattern</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::pair</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">>>></span><span style=\"color:#E1E4E8\"> m_tests;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Simple assertion macros</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASSERT_TRUE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(condition)) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">runtime_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Assertion failed: \"</span><span style=\"color:#E1E4E8\"> #condition </span><span style=\"color:#9ECBFF\">\" at \"</span><span style=\"color:#B392F0\"> __FILE__</span><span style=\"color:#9ECBFF\"> \":\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">to_string</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASSERT_FALSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ASSERT_TRUE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(condition))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASSERT_EQ</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((expected) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> (actual)) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">runtime_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Expected \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">to_string</span><span style=\"color:#E1E4E8\">(expected) </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" but got \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">to_string</span><span style=\"color:#E1E4E8\">(actual)); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASSERT_NEAR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tolerance</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">((expected) </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (actual)) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (tolerance)) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">runtime_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Values not within tolerance\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test registration macro</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TEST</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">testName</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#E1E4E8\"> Test_##testName(); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> TestRegistrar_</span><span style=\"color:#E1E4E8\">##testName { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TestRegistrar_##testName() { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            TestFramework</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">TestRunner</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Instance</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">RegisterTest</span><span style=\"color:#E1E4E8\">(#testName, Test_##testName); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> TestRegistrar_##testName registrar_##testName; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#E1E4E8\"> Test_##testName()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Performance testing utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceTimer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Start</span><span style=\"color:#E1E4E8\">() { m_startTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Stop</span><span style=\"color:#E1E4E8\">() { m_endTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#B392F0\"> GetMilliseconds</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_endTime </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> m_startTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">duration_cast</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">duration</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">milli</span><span style=\"color:#E1E4E8\">>>(duration).</span><span style=\"color:#B392F0\">count</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::time_point m_startTime, m_endTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // namespace TestFramework</span></span></code></pre></div>\n\n<h4 id=\"ecs-unit-testing-implementation\">ECS Unit Testing Implementation</h4>\n<p>Complete test suite for ECS functionality with entity management, component storage, and system execution validation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/unit/test_ecs.cpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"test_framework.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"engine/ecs/ecs_world.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"engine/ecs/components.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_set></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#F97583\"> namespace</span><span style=\"color:#B392F0\"> TestFramework</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(EntityCreationAndDestruction) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create ECSWorld instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create multiple entities and verify they have unique IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Destroy some entities and create new ones</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify ID recycling works correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Ensure destroyed entity IDs are not reused immediately (generation counter)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(ComponentAdditionAndRemoval) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create entities and add various components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify GetComponent returns correct component data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove components and verify they're no longer accessible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test adding components to destroyed entities (should fail gracefully)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify component memory is cleaned up properly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(SystemExecutionAndQueries) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create test system that processes Transform components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create entities with and without Transform components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Run system and verify only entities with Transform are processed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test multi-component queries (Transform + Sprite)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify system execution order respects dependencies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(ComponentStoragePerformance) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PerformanceTimer timer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> ENTITY_COUNT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create large number of entities with Transform components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Time component iteration performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify iteration completes within performance budget (&#x3C; 1ms)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test component addition/removal performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Measure memory usage and verify cache-friendly access patterns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(ConcurrentEntityManagement) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Test adding/removing entities from multiple threads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify no race conditions in ID generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test component modification during system iteration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Ensure data consistency under concurrent access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify no crashes or data corruption occur</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"physics-system-testing-implementation\">Physics System Testing Implementation</h4>\n<p>Comprehensive physics testing that validates collision detection accuracy, energy conservation, and numerical stability:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/unit/test_physics.cpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"test_framework.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"engine/physics/collision_system.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"engine/physics/physics_integrator.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"engine/math/vector2.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#F97583\"> namespace</span><span style=\"color:#B392F0\"> TestFramework</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(AABBCollisionDetection) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create AABB pairs with known intersection results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Test overlapping cases (partial and complete overlap)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test non-overlapping cases (separated by various distances)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test edge cases (exactly touching, zero-size boxes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify no false positives or false negatives</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(PhysicsEnergyConservation) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create physics simulation with bouncing balls</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate initial total kinetic energy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Run simulation for many timesteps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify energy remains approximately constant (&#x3C; 1% drift)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test with different object masses and velocities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(CollisionResponseAccuracy) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set up collision between objects with known masses and velocities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate expected post-collision velocities using physics equations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Run collision response system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify actual velocities match expected within tolerance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test various collision scenarios (head-on, glancing, stationary targets)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(SpatialPartitioningPerformance) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PerformanceTimer timer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> OBJECT_COUNT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create large number of collision objects in grid pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Time collision detection with and without spatial partitioning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify spatial partitioning provides significant speedup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify spatial partitioning returns identical results to brute force</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test performance scaling as object count increases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(PhysicsNumericalStability) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Run long physics simulation (10000+ timesteps)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Monitor for NaN or infinite values in positions/velocities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test with very small and very large coordinate values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify objects don't spontaneously gain energy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test collision jitter prevention mechanisms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"integration-testing-implementation\">Integration Testing Implementation</h4>\n<p>End-to-end testing that validates complete frame processing pipelines and system coordination:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/integration/test_frame_processing.cpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"test_framework.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"engine/core/application.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"engine/core/timer.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#F97583\"> namespace</span><span style=\"color:#B392F0\"> TestFramework</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(CompleteFrameProcessing) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Application app;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WindowConfig config{</span><span style=\"color:#9ECBFF\">\"Test Window\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">800</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">600</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize application with test configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create test scene with entities having Transform, Sprite, RigidBody components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Run multiple frame processing cycles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify all systems execute in correct order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify frame time remains within budget (16.67ms target)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for memory leaks after extended operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(SystemCoordinationValidation) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create entities that require coordination between multiple systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Physics system modifies positions, rendering system uses updated positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify data flows correctly between systems within same frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test input processing affects game logic systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Ensure no system reads stale data from previous frames</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(SceneTransitionIntegration) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create two different scenes with unique resource requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Load first scene and verify all resources loaded correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Transition to second scene</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify first scene resources cleaned up properly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify second scene resources loaded and functional</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Test rapid scene transitions and error recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST</span><span style=\"color:#E1E4E8\">(PerformanceStressTest) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PerformanceTimer timer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> STRESS_ENTITY_COUNT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create large number of entities with full component sets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Run frame processing under heavy load</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Measure frame processing time distribution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Identify performance bottlenecks and scaling limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify graceful degradation when limits exceeded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-verification-scripts\">Milestone Verification Scripts</h4>\n<p>Automated validation scripts that provide clear pass/fail results for each milestone:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/milestone_verification.cpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"test_framework.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"engine/core/application.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> MilestoneVerification</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> VerifyMilestone1</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"=== Milestone 1: Window &#x26; Rendering Foundation ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Test window creation with various configurations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify OpenGL context initialization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test basic sprite rendering functionality</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify shader compilation and linking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test batch rendering performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return true if all tests pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> VerifyMilestone2</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"=== Milestone 2: Entity Component System ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Test entity creation and ID recycling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify component storage and retrieval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test system execution and queries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify performance meets targets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test concurrent access safety</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> VerifyMilestone3</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"=== Milestone 3: Physics &#x26; Collision ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Test collision detection accuracy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify physics integration stability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test collision response realism</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify spatial partitioning performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test deterministic behavior</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> VerifyMilestone4</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"=== Milestone 4: Resource &#x26; Scene Management ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Test asset loading for various formats</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify reference counting accuracy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test scene serialization round-trips</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify async loading thread safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test error handling and recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // namespace MilestoneVerification</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> allMilestonesPassed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allMilestonesPassed </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#B392F0\"> MilestoneVerification</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">VerifyMilestone1</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allMilestonesPassed </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#B392F0\"> MilestoneVerification</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">VerifyMilestone2</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allMilestonesPassed </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#B392F0\"> MilestoneVerification</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">VerifyMilestone3</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allMilestonesPassed </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#B392F0\"> MilestoneVerification</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">VerifyMilestone4</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (allMilestonesPassed) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">✅ All milestones verified successfully!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">❌ Some milestones failed verification.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-testing-hints\">Language-Specific Testing Hints</h4>\n<p><strong>C++ Testing Best Practices:</strong></p>\n<ul>\n<li>Use RAII for test fixture setup/teardown to ensure resource cleanup</li>\n<li>Leverage <code>std::chrono::high_resolution_clock</code> for accurate performance measurement  </li>\n<li>Use <code>std::unique_ptr</code> and smart pointers to detect memory leaks automatically</li>\n<li>Enable compiler warnings (<code>-Wall -Wextra</code>) to catch potential issues early</li>\n<li>Use address sanitizer (<code>-fsanitize=address</code>) during development for memory error detection</li>\n</ul>\n<p><strong>Performance Measurement Guidelines:</strong></p>\n<ul>\n<li>Run performance tests multiple times and report average/median/95th percentile</li>\n<li>Warm up caches before timing critical sections</li>\n<li>Use CPU performance counters when available for detailed analysis</li>\n<li>Disable optimization during correctness testing, enable for performance testing</li>\n<li>Measure both CPU time and wall clock time to detect threading issues</li>\n</ul>\n<p><strong>Graphics Testing Considerations:</strong></p>\n<ul>\n<li>Initialize graphics context before running rendering tests</li>\n<li>Use offscreen framebuffers for automated graphics testing</li>\n<li>Verify OpenGL error state after each graphics operation</li>\n<li>Test with different GPU vendors and driver versions when possible</li>\n<li>Use simple geometric shapes for deterministic visual verification</li>\n</ul>\n<h4 id=\"debugging-integration-test-failures\">Debugging Integration Test Failures</h4>\n<table>\n<thead>\n<tr>\n<th>Failure Symptom</th>\n<th>Likely Root Cause</th>\n<th>Diagnostic Approach</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame rate drops during testing</td>\n<td>Performance bottleneck in system coordination</td>\n<td>Profile individual system execution times</td>\n<td>Optimize slowest system or reduce test load</td>\n</tr>\n<tr>\n<td>Memory usage grows during tests</td>\n<td>Resource leaks in asset loading or ECS</td>\n<td>Track allocation/deallocation patterns</td>\n<td>Add reference counting validation</td>\n</tr>\n<tr>\n<td>Crashes during scene transitions</td>\n<td>Race condition or invalid resource handles</td>\n<td>Use thread sanitizer and handle validation</td>\n<td>Add synchronization and handle checking</td>\n</tr>\n<tr>\n<td>Physics simulation becomes unstable</td>\n<td>Numerical precision issues or timestep problems</td>\n<td>Monitor energy conservation and NaN detection</td>\n<td>Adjust integration method or timestep</td>\n</tr>\n<tr>\n<td>Rendering artifacts in integration tests</td>\n<td>State leakage between graphics operations</td>\n<td>Check OpenGL error state and context validity</td>\n<td>Add state cleanup between render operations</td>\n</tr>\n</tbody></table>\n<p>This comprehensive testing strategy ensures each engine subsystem works correctly in isolation and coordinates properly with other systems to deliver smooth interactive experiences. The combination of unit testing, integration testing, and milestone verification provides confidence that the game engine meets both functional and performance requirements.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — debugging techniques are essential throughout development as each subsystem introduces unique failure modes and diagnostic challenges</p>\n</blockquote>\n<p>Building a game engine is like performing <strong>surgery on a moving patient</strong> — the system must continue running at 60 frames per second while you diagnose and fix problems. Unlike traditional software where you can pause execution and examine state, game engines operate under real-time constraints where debugging itself can disrupt the very timing issues you&#39;re trying to solve.</p>\n<p>The debugging process for game engines requires a fundamentally different mindset than typical application development. You&#39;re debugging not just logic errors, but performance issues, timing-dependent race conditions, GPU state corruption, and numerical stability problems in physics simulations. Each subsystem introduces its own category of failures: graphics drivers can crash, physics simulations can explode, resources can fail to load, and the ECS can become corrupted. The challenge is developing systematic approaches to isolate problems across multiple interacting systems.</p>\n<p>This guide provides structured approaches to the most common categories of issues learners encounter when building game engines. Rather than generic debugging advice, we focus on engine-specific problems with concrete diagnostic steps and solutions.</p>\n<h3 id=\"graphics-and-rendering-issues\">Graphics and Rendering Issues</h3>\n<p>The rendering subsystem presents the most visually obvious failures — when graphics break, you immediately see black screens, corrupted textures, or missing geometry. However, graphics problems are also among the most difficult to debug because they involve complex interactions between CPU code, GPU drivers, and graphics hardware.</p>\n<h4 id=\"mental-model-film-production-pipeline\">Mental Model: Film Production Pipeline</h4>\n<p>Think of graphics debugging like troubleshooting a <strong>film production pipeline</strong> where problems can occur at multiple stages: script writing (shader code), equipment setup (OpenGL state), filming (draw calls), and post-production (framebuffer operations). Just as a film director must isolate whether problems are in the script, camera, lighting, or editing room, graphics debugging requires systematically checking each stage of the rendering pipeline.</p>\n<h4 id=\"black-screen-issues\">Black Screen Issues</h4>\n<p>The dreaded black screen is often a new developer&#39;s first encounter with graphics debugging. Black screens typically indicate complete rendering pipeline failure rather than partial corruption.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Window opens but shows black</td>\n<td>OpenGL context not created</td>\n<td>Check <code>Window::Initialize()</code> return value</td>\n<td>Verify graphics drivers, try different OpenGL version</td>\n</tr>\n<tr>\n<td>Context exists but black screen</td>\n<td>Viewport not set correctly</td>\n<td>Call <code>glGetIntegerv(GL_VIEWPORT)</code></td>\n<td>Set viewport to window dimensions in resize callback</td>\n</tr>\n<tr>\n<td>Viewport correct but no rendering</td>\n<td>Shader compilation failure</td>\n<td>Check <code>ShaderProgram::m_isLinked</code> flag</td>\n<td>Add shader error logging, check GLSL syntax</td>\n</tr>\n<tr>\n<td>Shaders link but geometry missing</td>\n<td>Vertex attributes not bound</td>\n<td>Call <code>glGetAttribLocation()</code> for each attribute</td>\n<td>Verify vertex format matches shader inputs</td>\n</tr>\n<tr>\n<td>Attributes bound but still black</td>\n<td>Matrices not set or incorrect</td>\n<td>Print view-projection matrix values</td>\n<td>Check matrix multiplication order and coordinate system</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Assuming Silent Failures</strong>\nOpenGL operates on a state machine principle where errors are queued rather than throwing exceptions immediately. A common mistake is not checking for OpenGL errors after each significant operation. The engine should use <code>GLErrorChecker::CheckErrors()</code> after every OpenGL call during development, even though this impacts performance.</p>\n<h4 id=\"texture-loading-and-display-problems\">Texture Loading and Display Problems</h4>\n<p>Texture problems manifest as pink/magenta rectangles (indicating missing textures), corrupted imagery, or textures that appear but with wrong colors or orientations.</p>\n<table>\n<thead>\n<tr>\n<th>Problem Type</th>\n<th>Visual Symptom</th>\n<th>Root Cause</th>\n<th>Diagnostic Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing textures</td>\n<td>Pink/magenta rectangles</td>\n<td>Texture ID is 0 or invalid</td>\n<td>Check <code>TextureHandle::IsValid()</code> before binding</td>\n</tr>\n<tr>\n<td>Corrupted colors</td>\n<td>Wrong colors, banding</td>\n<td>Incorrect pixel format during upload</td>\n<td>Verify <code>GL_RGB</code> vs <code>GL_RGBA</code> matches image data</td>\n</tr>\n<tr>\n<td>Flipped textures</td>\n<td>Upside-down or mirrored</td>\n<td>Y-coordinate origin mismatch</td>\n<td>Adjust texture coordinates or flip during loading</td>\n</tr>\n<tr>\n<td>Blurry textures</td>\n<td>Loss of detail, soft appearance</td>\n<td>Incorrect filtering parameters</td>\n<td>Set <code>GL_NEAREST</code> for pixel art, check mipmap generation</td>\n</tr>\n<tr>\n<td>Black textures</td>\n<td>Loaded but appear black</td>\n<td>Premultiplied alpha or wrong format</td>\n<td>Check alpha channel, try <code>GL_RGBA8</code> format explicitly</td>\n</tr>\n</tbody></table>\n<p>The texture loading pipeline involves multiple stages where failures can occur:</p>\n<ol>\n<li><strong>File Loading</strong>: The image decoder reads the file from disk and extracts pixel data</li>\n<li><strong>Format Conversion</strong>: Pixel data is converted to OpenGL-compatible format (RGB/RGBA)</li>\n<li><strong>GPU Upload</strong>: Converted data is transferred to graphics memory via <code>glTexImage2D</code></li>\n<li><strong>Binding and Sampling</strong>: Texture is bound to a texture unit and sampled in shaders</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight</strong>: Texture debugging requires validating each stage independently. Create a simple test texture (like a 2x2 checkerboard pattern) programmatically to isolate whether problems are in file loading or GPU operations.</p>\n</blockquote>\n<h4 id=\"shader-compilation-and-linking-errors\">Shader Compilation and Linking Errors</h4>\n<p>Shader errors are particularly challenging because GLSL error messages vary significantly between graphics drivers and often provide cryptic line numbers or syntax descriptions.</p>\n<p><strong>Shader Error Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Common Messages</th>\n<th>Typical Causes</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Compilation</td>\n<td>&quot;syntax error&quot;, &quot;undeclared identifier&quot;</td>\n<td>GLSL syntax errors, typos</td>\n<td>Parse error logs, check GLSL version compatibility</td>\n</tr>\n<tr>\n<td>Linking</td>\n<td>&quot;undefined reference&quot;, &quot;type mismatch&quot;</td>\n<td>Vertex/fragment interface mismatch</td>\n<td>Verify <code>out</code> variables match <code>in</code> variables exactly</td>\n</tr>\n<tr>\n<td>Uniform</td>\n<td>&quot;uniform location not found&quot;</td>\n<td>Wrong uniform names or unused uniforms</td>\n<td>Check spelling, verify uniform isn&#39;t optimized out</td>\n</tr>\n<tr>\n<td>Attribute</td>\n<td>&quot;attribute location invalid&quot;</td>\n<td>Vertex format doesn&#39;t match shader</td>\n<td>Print attribute locations, compare with vertex layout</td>\n</tr>\n</tbody></table>\n<p>The shader system should implement comprehensive error reporting:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> ShaderCompiler</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">CompileShader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> shaderID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">GLenum</span><span style=\"color:#FFAB70\"> shaderType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> errorLog</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Compile shader and check GL_COMPILE_STATUS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If compilation failed, retrieve info log with glGetShaderInfoLog</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Parse error log to extract line numbers and error descriptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Append original source with line numbers for context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return false with detailed error message in errorLog parameter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Silent Uniform Failures</strong>\nOpenGL silently ignores <code>glUniform</code> calls for uniforms that don&#39;t exist or were optimized out during linking. The shader system should validate uniform locations during development and warn about unused uniforms that might indicate typos.</p>\n<h4 id=\"opengl-state-management-issues\">OpenGL State Management Issues</h4>\n<p>OpenGL&#39;s state machine nature creates debugging challenges when previous rendering operations leave the graphics context in unexpected states.</p>\n<p><strong>Common State Corruption Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>State Category</th>\n<th>Symptoms</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Texture binding</td>\n<td>Wrong textures on wrong objects</td>\n<td>Check <code>GL_TEXTURE_BINDING_2D</code></td>\n<td>Bind texture 0 after rendering</td>\n</tr>\n<tr>\n<td>Shader program</td>\n<td>Wrong shader effects</td>\n<td>Query <code>GL_CURRENT_PROGRAM</code></td>\n<td>Use RAII shader binding guards</td>\n</tr>\n<tr>\n<td>Vertex arrays</td>\n<td>Wrong geometry rendered</td>\n<td>Check <code>GL_VERTEX_ARRAY_BINDING</code></td>\n<td>Unbind VAO after batch completion</td>\n</tr>\n<tr>\n<td>Blend state</td>\n<td>Transparency artifacts</td>\n<td>Query blend function parameters</td>\n<td>Reset blend state between frames</td>\n</tr>\n<tr>\n<td>Depth testing</td>\n<td>Z-fighting or missing occlusion</td>\n<td>Check <code>GL_DEPTH_TEST</code> enable state</td>\n<td>Clear depth buffer each frame</td>\n</tr>\n</tbody></table>\n<p>The <code>GLErrorChecker</code> utility should provide detailed state introspection during debugging sessions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GLErrorChecker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">GLenum, string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_errorStrings;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\"> s_enableChecking;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> CheckErrors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> operation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> DumpCurrentState</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // Prints all relevant GL state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> EnableChecking</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> enable</span><span style=\"color:#E1E4E8\">) { s_enableChecking </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enable; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> GL_CHECK</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">call</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> { call; </span><span style=\"color:#B392F0\">GLErrorChecker</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">CheckErrors</span><span style=\"color:#E1E4E8\">(#call, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">); } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> GL_CHECK</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">call</span><span style=\"color:#E1E4E8\">) call</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<h3 id=\"performance-and-memory-issues\">Performance and Memory Issues</h3>\n<p>Performance problems in game engines are insidious because they often develop gradually as content is added, making them difficult to notice until frame rates drop below acceptable thresholds. Unlike functional bugs that cause immediate failures, performance issues require systematic measurement and profiling.</p>\n<h4 id=\"mental-model-traffic-management-system\">Mental Model: Traffic Management System</h4>\n<p>Think of performance debugging like managing <strong>traffic flow in a city</strong> — bottlenecks can occur at intersections (system boundaries), traffic lights (synchronization points), or road capacity limits (memory bandwidth). Just as traffic engineers use sensors and cameras to identify problem areas, performance debugging requires continuous monitoring of frame times, memory allocation patterns, and system resource usage.</p>\n<h4 id=\"frame-rate-drops-and-timing-issues\">Frame Rate Drops and Timing Issues</h4>\n<p>Frame rate instability manifests as stuttering, irregular motion, or complete freezes. These problems often stem from systems exceeding their frame time budget or creating timing dependencies between subsystems.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Issue</th>\n<th>Observable Symptoms</th>\n<th>Measurement Approach</th>\n<th>Typical Solutions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Inconsistent frame times</td>\n<td>Stuttering movement, frame drops</td>\n<td>Track delta time variance over 1000 frames</td>\n<td>Implement fixed timestep with accumulator</td>\n</tr>\n<tr>\n<td>CPU-bound rendering</td>\n<td>High CPU usage, low GPU utilization</td>\n<td>Profile rendering thread with sampling profiler</td>\n<td>Reduce draw calls through batching</td>\n</tr>\n<tr>\n<td>GPU-bound rendering</td>\n<td>Low CPU usage, high GPU load</td>\n<td>Use GPU profiler to identify bottlenecks</td>\n<td>Optimize shaders, reduce overdraw</td>\n</tr>\n<tr>\n<td>Memory allocation spikes</td>\n<td>Frame drops during loading</td>\n<td>Track allocation patterns with heap profiler</td>\n<td>Pre-allocate pools, avoid per-frame allocation</td>\n</tr>\n<tr>\n<td>System blocking operations</td>\n<td>Periodic freezes</td>\n<td>Monitor system call duration</td>\n<td>Move file I/O to background threads</td>\n</tr>\n</tbody></table>\n<p><strong>Frame Time Budget Analysis:</strong></p>\n<p>The engine operates under strict timing constraints where each frame must complete within approximately 16.67 milliseconds for 60 FPS target frame rate. Understanding how this budget is distributed across subsystems helps identify optimization priorities:</p>\n<table>\n<thead>\n<tr>\n<th>Subsystem</th>\n<th>Typical Budget</th>\n<th>Measurement Method</th>\n<th>Optimization Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Input Processing</td>\n<td>0.5ms</td>\n<td>Time <code>PollEvents()</code> duration</td>\n<td>Batch input events, avoid per-event allocation</td>\n</tr>\n<tr>\n<td>ECS System Updates</td>\n<td>4-6ms</td>\n<td>Profile each system individually</td>\n<td>Cache-friendly iteration, reduce component copying</td>\n</tr>\n<tr>\n<td>Physics Simulation</td>\n<td>2-4ms</td>\n<td>Time <code>StepSimulation()</code> calls</td>\n<td>Spatial partitioning efficiency, collision pair reduction</td>\n</tr>\n<tr>\n<td>Rendering Pipeline</td>\n<td>8-10ms</td>\n<td>GPU profiler timestamps</td>\n<td>Draw call batching, shader optimization</td>\n</tr>\n<tr>\n<td>Resource Loading</td>\n<td>0ms (background)</td>\n<td>Monitor async queue depth</td>\n<td>Prevent blocking main thread</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Ignoring Variance</strong>\nAverage frame time can be misleading — a system that averages 14ms but occasionally spikes to 30ms will cause noticeable stuttering. Performance monitoring should track both average and 99th percentile frame times to identify systems causing occasional but severe performance drops.</p>\n<h4 id=\"memory-leaks-and-resource-management\">Memory Leaks and Resource Management</h4>\n<p>Game engines are particularly susceptible to memory leaks because they manage large amounts of temporary data (vertex buffers, textures, audio clips) that must be explicitly freed. Unlike application software, games cannot rely on garbage collection or process termination to clean up resources.</p>\n<p><strong>Memory Leak Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Leak Type</th>\n<th>Growth Pattern</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Resource handles</td>\n<td>Steady growth during gameplay</td>\n<td>Monitor <code>ResourceManager</code> handle counts</td>\n<td>Implement reference counting with automatic cleanup</td>\n</tr>\n<tr>\n<td>Texture memory</td>\n<td>Spikes during level loading</td>\n<td>Track GPU memory usage</td>\n<td>Unload unused textures during scene transitions</td>\n</tr>\n<tr>\n<td>Physics objects</td>\n<td>Growth correlates with entity creation</td>\n<td>Count rigid bodies vs. entities</td>\n<td>Ensure <code>DestroyEntity()</code> removes physics components</td>\n</tr>\n<tr>\n<td>ECS components</td>\n<td>Slow growth over time</td>\n<td>Monitor component array sizes</td>\n<td>Verify component removal recycles storage slots</td>\n</tr>\n<tr>\n<td>Temporary allocations</td>\n<td>Sawtooth pattern each frame</td>\n<td>Heap profiler allocation tracking</td>\n<td>Use memory pools for frequent small allocations</td>\n</tr>\n</tbody></table>\n<p>The engine should implement comprehensive memory tracking to detect leaks early in development:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MemoryTracker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> AllocationInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string file;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        steady_clock</span><span style=\"color:#E1E4E8\">::time_point timestamp;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> unordered_map</span><span style=\"color:#F97583\">&#x3C;void*</span><span style=\"color:#E1E4E8\">, AllocationInfo</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_allocations;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> atomic</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> s_totalAllocated;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> RecordAllocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> RecordDeallocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> DumpLeaks</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // Print all unfreed allocations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#B392F0\"> GetTotalAllocated</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> s_totalAllocated.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"inefficient-ecs-iteration-patterns\">Inefficient ECS Iteration Patterns</h4>\n<p>The Entity Component System&#39;s performance benefits depend on cache-friendly iteration patterns. Poor ECS usage can actually be slower than traditional object-oriented approaches due to cache misses and unnecessary data movement.</p>\n<p><strong>ECS Performance Anti-Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Anti-Pattern</th>\n<th>Performance Impact</th>\n<th>Diagnostic Signs</th>\n<th>Corrective Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random entity access</td>\n<td>Cache misses, poor branch prediction</td>\n<td>High L3 cache miss rate</td>\n<td>Use archetype-based iteration instead</td>\n</tr>\n<tr>\n<td>Excessive component copying</td>\n<td>Memory bandwidth waste</td>\n<td>High memory usage during system updates</td>\n<td>Pass components by reference</td>\n</tr>\n<tr>\n<td>Mixed data types in hot loops</td>\n<td>Cache line pollution</td>\n<td>Poor instruction per cycle metrics</td>\n<td>Separate hot/cold component data</td>\n</tr>\n<tr>\n<td>Sparse component arrays</td>\n<td>Memory fragmentation</td>\n<td>Low memory utilization efficiency</td>\n<td>Implement dense packing with index mapping</td>\n</tr>\n<tr>\n<td>Cross-system data dependencies</td>\n<td>Pipeline stalls</td>\n<td>Systems waiting for data</td>\n<td>Restructure component ownership</td>\n</tr>\n</tbody></table>\n<p>The ECS implementation should provide profiling hooks to identify performance bottlenecks:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemProfiler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    steady_clock</span><span style=\"color:#E1E4E8\">::time_point m_startTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> m_entitiesProcessed;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    string m_systemName;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SystemProfiler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">m_systemName</span><span style=\"color:#E1E4E8\">(name), </span><span style=\"color:#B392F0\">m_startTime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">()) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~SystemProfiler</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> m_startTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> microseconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> duration_cast</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">microseconds</span><span style=\"color:#E1E4E8\">>(duration).</span><span style=\"color:#B392F0\">count</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Log system execution time and entity count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Calculate entities processed per microsecond</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Track worst-case execution times over multiple frames</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Detect systems exceeding frame time budget</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PROFILE_SYSTEM</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) SystemProfiler </span><span style=\"color:#B392F0\">profiler</span><span style=\"color:#E1E4E8\">(name)</span></span></code></pre></div>\n\n<h3 id=\"physics-simulation-problems\">Physics Simulation Problems</h3>\n<p>Physics simulation debugging requires understanding both the mathematical foundations of rigid body dynamics and the numerical methods used to approximate continuous physics in discrete timesteps. Physics bugs often manifest as seemingly impossible behavior — objects falling through solid floors, explosive energy accumulation, or deterministic simulations producing different results on identical inputs.</p>\n<h4 id=\"mental-model-forensic-investigation\">Mental Model: Forensic Investigation</h4>\n<p>Physics debugging is like <strong>forensic investigation</strong> — you must reconstruct what happened during collision events using evidence from before and after the collision. Since physics operates on predictions (where will this object be next frame?), debugging requires validating both the prediction logic and the correction mechanisms when predictions prove wrong.</p>\n<h4 id=\"objects-falling-through-floors-tunneling\">Objects Falling Through Floors (Tunneling)</h4>\n<p>Tunneling occurs when fast-moving objects pass completely through thin barriers between physics timesteps. This is one of the most common and frustrating physics bugs because it appears to violate basic physical laws.</p>\n<p><strong>Tunneling Root Causes:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Cause</th>\n<th>Physics Explanation</th>\n<th>Detection Method</th>\n<th>Solution Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Excessive velocity</td>\n<td>Object moves farther than barrier thickness per timestep</td>\n<td>Compare velocity * timestep to collider size</td>\n<td>Clamp maximum velocity or reduce timestep</td>\n</tr>\n<tr>\n<td>Large timestep</td>\n<td>Too much time passes between collision checks</td>\n<td>Monitor physics timestep accumulation</td>\n<td>Use fixed timestep with smaller intervals</td>\n</tr>\n<tr>\n<td>Thin collision geometry</td>\n<td>Barriers too thin relative to object speed</td>\n<td>Measure barrier thickness vs. object bounds</td>\n<td>Increase barrier thickness or use swept collision</td>\n</tr>\n<tr>\n<td>Missed collision detection</td>\n<td>Spatial partitioning fails to find collision pairs</td>\n<td>Verify broad phase detects all potential pairs</td>\n<td>Expand spatial partition cells or use continuous detection</td>\n</tr>\n<tr>\n<td>Numerical precision loss</td>\n<td>Floating-point errors in position calculations</td>\n<td>Check for NaN or infinite position values</td>\n<td>Use double precision for critical calculations</td>\n</tr>\n</tbody></table>\n<p>The <code>TunnellingPreventer</code> utility helps detect potential tunneling before it occurs:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TunnellingPreventer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> CheckForTunnelling</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> RigidBody</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> body</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Transform</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> oldTransform</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   const</span><span style=\"color:#B392F0\"> Transform</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> newTransform</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate movement distance between old and new positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get the smallest dimension of the object's collision bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If movement distance > bounds dimension, potential tunneling detected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Log warning with object ID, velocity, and suggested max safe velocity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return true if tunneling risk detected, false otherwise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> float</span><span style=\"color:#B392F0\"> CalculateMaxSafeVelocity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> AABB</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> bounds</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> timestep</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Find the smallest dimension of the bounding box</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Calculate maximum safe distance per timestep (e.g., 0.5 * min dimension)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return safe distance divided by timestep to get max velocity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"jittery-collisions-and-resting-contact\">Jittery Collisions and Resting Contact</h4>\n<p>Collision jitter occurs when objects in resting contact (like a box sitting on the ground) rapidly oscillate between slightly penetrating and slightly separated states. This creates visually distracting vibration and can accumulate energy over time.</p>\n<p><strong>Jitter Analysis Framework:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Jitter Type</th>\n<th>Visual Appearance</th>\n<th>Physical Cause</th>\n<th>Stabilization Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Penetration jitter</td>\n<td>Rapid up-down oscillation</td>\n<td>Position correction overshoots</td>\n<td>Reduce <code>POSITION_CORRECTION_PERCENT</code></td>\n</tr>\n<tr>\n<td>Velocity jitter</td>\n<td>Object appears to vibrate</td>\n<td>Impulse response too aggressive</td>\n<td>Apply velocity damping in resting contact</td>\n</tr>\n<tr>\n<td>Stacking jitter</td>\n<td>Tower of objects vibrates</td>\n<td>Accumulated correction errors</td>\n<td>Process collisions in stability order</td>\n</tr>\n<tr>\n<td>Rotational jitter</td>\n<td>Objects spin rapidly</td>\n<td>Torque from off-center collisions</td>\n<td>Separate linear and angular damping</td>\n</tr>\n<tr>\n<td>Temporal jitter</td>\n<td>Inconsistent behavior over time</td>\n<td>Variable timestep effects</td>\n<td>Enforce fixed timestep accumulator</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: Jitter reduction involves balancing responsiveness against stability. Too much damping makes collisions feel sluggish, while too little creates visible oscillation. The physics system should provide tunable parameters for different object types (e.g., heavy objects need less damping than light objects).</p>\n</blockquote>\n<h4 id=\"non-deterministic-physics-behavior\">Non-Deterministic Physics Behavior</h4>\n<p>Deterministic physics simulation means identical initial conditions always produce identical results, which is critical for networked games and debugging reproducibility. Non-determinism usually stems from floating-point precision variations or execution order dependencies.</p>\n<p><strong>Determinism Validation System:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PhysicsMonitor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> SimulationMetrics</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> totalEnergy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> maxVelocity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> maxPosition;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> nanDetectedCount;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SimulationMetrics m_currentMetrics;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SimulationMetrics m_baselineMetrics;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vector</span><span style=\"color:#F97583\">&#x3C;float></span><span style=\"color:#E1E4E8\"> m_energyHistory;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RecordSimulationState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">RigidBody</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> bodies</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate total kinetic and potential energy of all bodies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Find maximum velocity and position magnitudes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Count any NaN or infinite values in physics data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Store metrics for comparison with baseline or previous frames</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Detect energy conservation violations or explosive growth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> ValidateSimulationState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">RigidBody</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> bodies</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check all positions and velocities for NaN or infinity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Verify energy conservation within acceptable tolerance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Detect objects with impossible velocities (faster than light)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Validate that all collision normals are unit vectors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return false if any validation checks fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Determinism Threat Analysis:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Threat Source</th>\n<th>Manifestation</th>\n<th>Detection Strategy</th>\n<th>Mitigation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Floating-point variance</td>\n<td>Slightly different collision outcomes</td>\n<td>Compare simulation checksums</td>\n<td>Use consistent rounding modes</td>\n</tr>\n<tr>\n<td>Execution order</td>\n<td>Different results based on iteration order</td>\n<td>Run same simulation multiple times</td>\n<td>Sort entities by ID before processing</td>\n</tr>\n<tr>\n<td>Temporal precision</td>\n<td>Accumulating timestep errors</td>\n<td>Track simulation drift over time</td>\n<td>Use rational timestep representation</td>\n</tr>\n<tr>\n<td>Parallel processing</td>\n<td>Race conditions in collision resolution</td>\n<td>Single-thread determinism test</td>\n<td>Eliminate shared state or use deterministic ordering</td>\n</tr>\n<tr>\n<td>Memory layout</td>\n<td>Different results on different platforms</td>\n<td>Cross-platform validation tests</td>\n<td>Use fixed-size types and explicit padding</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-tools-and-techniques\">Debugging Tools and Techniques</h3>\n<p>Effective game engine debugging requires specialized tools and techniques adapted to real-time constraints and multi-system complexity. Traditional debuggers often disrupt timing-sensitive code, so game engines need non-invasive monitoring and logging systems.</p>\n<h4 id=\"mental-model-air-traffic-control-system\">Mental Model: Air Traffic Control System</h4>\n<p>Think of debugging tools like <strong>air traffic control systems</strong> — they provide continuous monitoring of multiple moving objects (entities), track their trajectories (transforms), identify conflicts (collisions), and maintain communication logs (event traces) without disrupting the ongoing operation of the system.</p>\n<h4 id=\"graphics-debugging-and-profiling-tools\">Graphics Debugging and Profiling Tools</h4>\n<p>Graphics debugging requires tools that can capture and analyze GPU state without significantly impacting performance during capture.</p>\n<p><strong>Recommended Graphics Debugging Tools:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Tool Category</th>\n<th>Recommended Tools</th>\n<th>Use Cases</th>\n<th>Integration Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OpenGL Debuggers</td>\n<td>RenderDoc, Nsight Graphics</td>\n<td>Capture frame state, analyze draw calls</td>\n<td>Hook into <code>SwapBuffers()</code> for automated capture</td>\n</tr>\n<tr>\n<td>GPU Profilers</td>\n<td>AMD Radeon GPU Profiler, Intel GPA</td>\n<td>Measure GPU timing, identify bottlenecks</td>\n<td>Insert timestamp queries around rendering phases</td>\n</tr>\n<tr>\n<td>Shader Debuggers</td>\n<td>GLSL-Debugger, Visual Studio Graphics</td>\n<td>Step through shader execution</td>\n<td>Add debug variants of critical shaders</td>\n</tr>\n<tr>\n<td>Memory Trackers</td>\n<td>GPU PerfStudio, custom allocation hooks</td>\n<td>Track GPU memory usage</td>\n<td>Override texture/buffer allocation functions</td>\n</tr>\n<tr>\n<td>State Validators</td>\n<td>Custom OpenGL state checker</td>\n<td>Detect state leaks between frames</td>\n<td>Query and validate state at frame boundaries</td>\n</tr>\n</tbody></table>\n<p>The engine should provide built-in graphics debugging infrastructure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphicsDebugger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\"> s_captureNextFrame;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">DrawCallInfo</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_drawCallHistory;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> DrawCallInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        steady_clock</span><span style=\"color:#E1E4E8\">::time_point timestamp;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string shaderName;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> vertexCount;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> textureCount;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Matrix4 modelViewProjection;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> BeginFrame</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (s_captureNextFrame) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s_drawCallHistory.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Insert GPU timestamp query for frame start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Capture current OpenGL state snapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> RecordDrawCall</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> shaderName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vertices</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Matrix4</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> mvp</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Record timestamp and call parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Capture bound textures and their dimensions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Store current vertex array configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Calculate estimated GPU cost for this draw call</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> EndFrame</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (s_captureNextFrame) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Insert GPU timestamp query for frame end</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Generate frame analysis report</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Export data in RenderDoc-compatible format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Reset capture flag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s_captureNextFrame </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"performance-profiling-and-bottleneck-analysis\">Performance Profiling and Bottleneck Analysis</h4>\n<p>Game engine profiling must operate with minimal overhead while providing detailed timing information across multiple subsystems running concurrently.</p>\n<p><strong>Multi-Level Profiling Strategy:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Profiling Level</th>\n<th>Granularity</th>\n<th>Overhead</th>\n<th>Information Provided</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame-level</td>\n<td>Per-frame timing</td>\n<td>&lt;0.1ms</td>\n<td>Overall frame budget distribution</td>\n</tr>\n<tr>\n<td>System-level</td>\n<td>Per-system execution</td>\n<td>&lt;0.5ms</td>\n<td>ECS system performance comparison</td>\n</tr>\n<tr>\n<td>Function-level</td>\n<td>Individual function calls</td>\n<td>1-2ms</td>\n<td>Hotspot identification within systems</td>\n</tr>\n<tr>\n<td>Micro-level</td>\n<td>Critical inner loops</td>\n<td>5-10ms</td>\n<td>Cache performance and instruction analysis</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceProfiler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> ProfileNode</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string name;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        steady_clock</span><span style=\"color:#E1E4E8\">::time_point startTime;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        steady_clock</span><span style=\"color:#E1E4E8\">::time_point endTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ProfileNode</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> children;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> callCount;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> thread_local</span><span style=\"color:#E1E4E8\"> stack</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ProfileNode</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\"> s_nodeStack;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> ProfileNode s_rootNode;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> ScopedTimer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ProfileNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> m_node;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ScopedTimer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Create new ProfileNode with current timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Add to parent node's children (or root if stack empty)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Push onto node stack for nested timing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ~ScopedTimer</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Record end timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Increment call count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Pop from node stack</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Calculate exclusive time (total minus children)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> GenerateReport</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Walk profile tree and calculate percentages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Identify functions exceeding frame time budget</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Sort by exclusive time to find real bottlenecks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Export to external profiler format (Chrome tracing)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PROFILE_SCOPE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PerformanceProfiler</span><span style=\"color:#E1E4E8\">::ScopedTimer </span><span style=\"color:#B392F0\">timer</span><span style=\"color:#E1E4E8\">(name)</span></span></code></pre></div>\n\n<h4 id=\"logging-and-event-tracing-systems\">Logging and Event Tracing Systems</h4>\n<p>Game engines generate massive amounts of diagnostic information that must be filtered, formatted, and stored efficiently without impacting frame rate performance.</p>\n<p><strong>Hierarchical Logging Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Log Level</th>\n<th>Use Cases</th>\n<th>Performance Impact</th>\n<th>Storage Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TRACE</td>\n<td>Detailed execution flow</td>\n<td>High (debug only)</td>\n<td>Memory buffer, periodic flush</td>\n</tr>\n<tr>\n<td>DEBUG</td>\n<td>System state changes</td>\n<td>Medium</td>\n<td>Async file writing</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>Major events, milestones</td>\n<td>Low</td>\n<td>Immediate console output</td>\n</tr>\n<tr>\n<td>WARNING</td>\n<td>Recoverable errors</td>\n<td>Minimal</td>\n<td>Immediate file and console</td>\n</tr>\n<tr>\n<td>ERROR</td>\n<td>System failures</td>\n<td>Minimal</td>\n<td>Immediate all outputs</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EngineLogger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    enum</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">TRACE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">DEBUG</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">INFO</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">WARNING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> LogEntry</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        steady_clock</span><span style=\"color:#E1E4E8\">::time_point timestamp;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LogLevel level;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string category;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string message;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string file;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> ThreadSafeQueue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">LogEntry</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_logQueue;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> thread s_writerThread;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> atomic</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">LogLevel</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_filterLevel;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LogLevel</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> category</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> message</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (level </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> s_filterLevel.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create LogEntry with current timestamp and parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Push to thread-safe queue for background processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If ERROR level, also output immediately to stderr</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Trigger flush if queue becomes too full</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> WriterThreadMain</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Wait for log entries in queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Batch multiple entries for efficient I/O</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Format entries with timestamp, level, category</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Write to appropriate outputs (console, file, network)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_TRACE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">category</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::TRACE, category, </span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_DEBUG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">category</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::DEBUG, category, </span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_INFO</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">category</span><span style=\"color:#E1E4E8\">, ...)  </span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::INFO, category, </span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_WARN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">category</span><span style=\"color:#E1E4E8\">, ...)  </span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::WARNING, category, </span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">category</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EngineLogger</span><span style=\"color:#E1E4E8\">::ERROR, category, </span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"memory-analysis-and-leak-detection\">Memory Analysis and Leak Detection</h4>\n<p>Memory debugging in game engines requires tracking both CPU heap allocations and GPU resource allocations across multiple subsystems with different lifecycle patterns.</p>\n<p><strong>Comprehensive Memory Tracking System:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Memory Category</th>\n<th>Tracking Method</th>\n<th>Leak Indicators</th>\n<th>Analysis Tools</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CPU Heap</td>\n<td>Override global new/delete</td>\n<td>Growing heap size over time</td>\n<td>Allocation call stacks</td>\n</tr>\n<tr>\n<td>GPU Textures</td>\n<td>Hook <code>glGenTextures</code>/<code>glDeleteTextures</code></td>\n<td>Texture count increases</td>\n<td>Texture usage patterns</td>\n</tr>\n<tr>\n<td>GPU Buffers</td>\n<td>Monitor VBO/VAO creation/destruction</td>\n<td>Buffer memory growth</td>\n<td>Buffer size distribution</td>\n</tr>\n<tr>\n<td>ECS Components</td>\n<td>Track component array growth</td>\n<td>Array size vs. entity count</td>\n<td>Component lifecycle analysis</td>\n</tr>\n<tr>\n<td>Resource Handles</td>\n<td>Monitor handle creation/reference counts</td>\n<td>Handles with zero references</td>\n<td>Resource dependency graphs</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MemoryAnalyzer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> AllocationSite</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string function;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string file;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> totalAllocated;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> allocationCount;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vector</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> allocationSizes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> unordered_map</span><span style=\"color:#F97583\">&#x3C;void*</span><span style=\"color:#E1E4E8\">, AllocationSite</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_activeAllocations;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">string, AllocationSite</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_allocationSites;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> mutex s_allocationMutex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#B392F0\"> TrackedMalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> function</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ptr) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(s_allocationMutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Record allocation site information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Add to active allocations map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Update allocation site statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Check for memory usage thresholds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> TrackedFree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ptr) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(s_allocationMutex);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Remove from active allocations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Update allocation site statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Check for double-free attempts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> GenerateLeakReport</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Analyze active allocations by allocation site</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Identify allocations that are growing over time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Generate call stack information for leak sources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Export leak data for external memory analyzers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG_MEMORY</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACKED_NEW</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">__FUNCTION__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACKED_DELETE</span><span style=\"color:#E1E4E8\"> TrackedFree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACKED_NEW</span><span style=\"color:#F97583\"> new</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACKED_DELETE</span><span style=\"color:#F97583\"> delete</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The debugging infrastructure should be built incrementally alongside the core engine systems, with each milestone adding appropriate debugging capabilities for the subsystems being developed.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Debugging Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Graphics Debugging</td>\n<td><code>glGetError()</code> after each call + manual state checking</td>\n<td>RenderDoc integration with automatic frame capture</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td>Manual timestamp logging with <code>std::chrono</code></td>\n<td>Integrated profiler with Chrome tracing export</td>\n</tr>\n<tr>\n<td>Memory Tracking</td>\n<td>Override global <code>new</code>/<code>delete</code> with allocation logging</td>\n<td>Valgrind/AddressSanitizer integration</td>\n</tr>\n<tr>\n<td>Logging System</td>\n<td>Simple <code>printf</code> with log levels</td>\n<td>Structured logging with async file writing</td>\n</tr>\n<tr>\n<td>Physics Debugging</td>\n<td>Manual energy conservation checking</td>\n<td>Integrated physics visualizer with collision display</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-module-structure\">Recommended Module Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  src</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">engine</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      GraphicsDebugger.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp     ← Graphics state validation </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> capture</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      PerformanceProfiler.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp  ← Hierarchical timing profiler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      MemoryTracker.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp        ← Allocation tracking </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> leak detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      EngineLogger.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp         ← Async logging system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      PhysicsMonitor.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp       ← Physics simulation validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      DebugRenderer.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp        ← On</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">screen debug visualization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tools</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      ProfileViewer</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">              ← External profiler data viewer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      MemoryAnalyzer</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">             ← Memory usage analysis tools</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debugging</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      debug_integration_test.cpp  ← End</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">to</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">end debugging workflow tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      profiler_test.cpp           ← Performance profiler accuracy tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      memory_tracker_test.cpp     ← Memory tracking correctness tests</span></span></code></pre></div>\n\n<h4 id=\"core-debugging-infrastructure\">Core Debugging Infrastructure</h4>\n<p><strong>Graphics Error Checking System:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GLErrorChecker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\"> s_enableChecking;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">GLenum, string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s_errorStrings;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> CheckErrors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> operation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">s_enableChecking) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Call glGetError() in loop until GL_NO_ERROR</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: For each error, look up human-readable string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Log error with operation name, file, and line number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Include current OpenGL state context in error message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return false if any errors were found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Populate s_errorStrings map with all OpenGL error codes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if OpenGL debug context is available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Register debug callback if supported</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Set initial checking enable state based on build configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Performance Timer Utility:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceTimer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    steady_clock</span><span style=\"color:#E1E4E8\">::time_point m_startTime;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    steady_clock</span><span style=\"color:#E1E4E8\">::time_point m_endTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> m_running;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Start</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Record current high-resolution timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Set running flag to true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Clear any previous end time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_startTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_running </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Stop</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Record end timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Set running flag to false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Validate that Start() was called first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_endTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_running </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#B392F0\"> GetMilliseconds</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate duration between start and end times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Convert to milliseconds with fractional precision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return 0.0 if timer hasn't been stopped</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_endTime </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> m_startTime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> duration_cast</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">duration</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">milli</span><span style=\"color:#E1E4E8\">>>(duration).</span><span style=\"color:#B392F0\">count</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"language-specific-debugging-hints\">Language-Specific Debugging Hints</h4>\n<p><strong>C++ Debugging Best Practices:</strong></p>\n<ul>\n<li>Use <code>std::chrono::steady_clock</code> for performance timing (immune to system clock changes)</li>\n<li>Leverage RAII with scoped timing classes to ensure measurements are always completed</li>\n<li>Use <code>thread_local</code> storage for profiler data to avoid synchronization overhead</li>\n<li>Implement custom memory allocators for debugging builds with allocation tracking</li>\n<li>Use <code>__FUNCTION__</code>, <code>__FILE__</code>, and <code>__LINE__</code> macros for automatic source location tracking</li>\n</ul>\n<p><strong>OpenGL Debugging Techniques:</strong></p>\n<ul>\n<li>Always check for OpenGL errors after context creation and major state changes</li>\n<li>Use <code>glObjectLabel()</code> to assign names to OpenGL objects for clearer debug output</li>\n<li>Implement fallback shaders that render solid colors when primary shaders fail to compile</li>\n<li>Save framebuffer contents to disk files when rendering appears incorrect</li>\n<li>Use <code>glFinish()</code> during debugging to force GPU/CPU synchronization for accurate timing</li>\n</ul>\n<h4 id=\"milestone-debugging-checkpoints\">Milestone Debugging Checkpoints</h4>\n<p><strong>Milestone 1 - Rendering Foundation:</strong></p>\n<ul>\n<li><strong>Verify</strong>: Window creates successfully and displays solid color background</li>\n<li><strong>Test</strong>: Modify clear color and confirm visual changes</li>\n<li><strong>Debug</strong>: If black screen appears, check OpenGL context creation and viewport settings</li>\n<li><strong>Tools</strong>: Use graphics debugger to capture first successful frame</li>\n</ul>\n<p><strong>Milestone 2 - Entity Component System:</strong></p>\n<ul>\n<li><strong>Verify</strong>: Entity creation/destruction cycles properly with no memory growth</li>\n<li><strong>Test</strong>: Create 10,000 entities, destroy half, verify memory usage returns to baseline</li>\n<li><strong>Debug</strong>: If component queries return wrong entities, validate archetype organization</li>\n<li><strong>Tools</strong>: Profile ECS system iteration performance with 1000+ entities</li>\n</ul>\n<p><strong>Milestone 3 - Physics and Collision:</strong></p>\n<ul>\n<li><strong>Verify</strong>: Objects fall under gravity and stop when hitting ground (no tunneling)</li>\n<li><strong>Test</strong>: Stack boxes and verify stable resting contact without jitter</li>\n<li><strong>Debug</strong>: If objects explode or oscillate, check impulse calculation and timestep</li>\n<li><strong>Tools</strong>: Visualize collision shapes and contact points on screen</li>\n</ul>\n<p><strong>Milestone 4 - Resource Management:</strong></p>\n<ul>\n<li><strong>Verify</strong>: Texture loading works for PNG/JPG files with correct colors and orientation</li>\n<li><strong>Test</strong>: Load scene, transition to different scene, verify old resources are freed</li>\n<li><strong>Debug</strong>: If textures appear corrupted, check pixel format and OpenGL texture parameters</li>\n<li><strong>Tools</strong>: Monitor resource reference counts and detect handle leaks</li>\n</ul>\n<h4 id=\"common-debugging-scenarios\">Common Debugging Scenarios</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Diagnostic Steps</th>\n<th>Expected Findings</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Everything compiles but window is black&quot;</td>\n<td>1. Check OpenGL context creation 2. Verify viewport size 3. Test shader compilation</td>\n<td>Context creation succeeds, viewport matches window, shaders fail to compile</td>\n<td>Add shader error logging and fix GLSL syntax errors</td>\n</tr>\n<tr>\n<td>&quot;Frame rate drops over time&quot;</td>\n<td>1. Profile frame time distribution 2. Monitor memory allocation 3. Track resource handle counts</td>\n<td>Memory usage grows steadily, handle counts increase</td>\n<td>Implement proper resource cleanup and reference counting</td>\n</tr>\n<tr>\n<td>&quot;Physics objects behave randomly&quot;</td>\n<td>1. Check for NaN values in positions 2. Verify timestep consistency 3. Monitor energy conservation</td>\n<td>NaN detected after certain collisions</td>\n<td>Add numerical stability checks and clamp extreme values</td>\n</tr>\n<tr>\n<td>&quot;Textures look wrong/corrupted&quot;</td>\n<td>1. Validate image loading format 2. Check OpenGL texture parameters 3. Verify texture coordinate setup</td>\n<td>Image format doesn&#39;t match OpenGL expectations</td>\n<td>Convert pixel data to match OpenGL format requirements</td>\n</tr>\n</tbody></table>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — future extensions build upon the foundation established across all development phases and demonstrate how architectural decisions enable advanced features</p>\n</blockquote>\n<p>A well-architected game engine is like a <strong>city&#39;s infrastructure</strong> — while the initial construction provides essential services like power, water, and roads, the real test of good urban planning comes when the city needs to grow. Can you add new neighborhoods without tearing up existing streets? Can the power grid scale to support skyscrapers? Can the transportation system adapt to autonomous vehicles? Similarly, the architectural decisions made throughout our four-milestone engine development create the foundation that either enables or constrains future capabilities.</p>\n<p>The modular design philosophy we&#39;ve established — with clear separation between rendering, ECS, physics, and resource management — acts as expansion joints in our engine&#39;s architecture. Each subsystem communicates through well-defined interfaces, making it possible to enhance individual components without cascading changes throughout the codebase. The handle-based resource system provides indirection that allows for advanced resource streaming. The data-oriented ECS design enables parallelization. The fixed-timestep physics architecture supports networked multiplayer. These aren&#39;t accidents — they&#39;re the natural result of thinking beyond immediate requirements.</p>\n<p>This section explores three categories of advanced features that our engine architecture naturally supports: enhanced rendering capabilities that transform visual fidelity, expanded engine systems that broaden functionality beyond core game mechanics, and performance optimizations that scale to handle demanding modern game requirements. Each extension leverages the architectural foundation we&#39;ve built while introducing new design challenges and opportunities.</p>\n<h3 id=\"advanced-rendering-features\">Advanced Rendering Features</h3>\n<blockquote>\n<p><strong>Mental Model: Photography Studio Evolution</strong>\nThink of our current rendering system as a basic portrait studio with essential lighting and a backdrop. Advanced rendering features are like upgrading to a professional film studio with multiple lighting rigs, green screens, post-processing equipment, and real-time color correction. Each new capability builds on the existing infrastructure while adding layers of sophistication.</p>\n</blockquote>\n<p>The rendering foundation established in Milestone 1 provides the infrastructure for sophisticated visual enhancements. Our shader compilation system, batch rendering architecture, and GPU resource management create the scaffolding needed for advanced lighting models, shadow rendering, and post-processing effects. These extensions transform our engine from a functional rendering pipeline into a visually compelling graphics system.</p>\n<h4 id=\"dynamic-lighting-and-shadow-systems\">Dynamic Lighting and Shadow Systems</h4>\n<p>Our current rendering pipeline processes sprites and meshes with simple texture sampling and vertex colors. Advanced lighting extends this foundation by introducing multiple light sources, surface materials, and shadow casting. The architectural hooks already exist in our <code>ShaderProgram</code> system — we simply need to expand the uniform variable system to support light parameters and shadow maps.</p>\n<table>\n<thead>\n<tr>\n<th>Lighting Component</th>\n<th>Purpose</th>\n<th>Integration Point</th>\n<th>Data Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Directional Light</td>\n<td>Sun-like illumination</td>\n<td>ECS component on entities</td>\n<td>Direction vector, color, intensity</td>\n</tr>\n<tr>\n<td>Point Light</td>\n<td>Localized illumination</td>\n<td>ECS component with Transform</td>\n<td>Position, color, intensity, attenuation</td>\n</tr>\n<tr>\n<td>Spot Light</td>\n<td>Focused illumination</td>\n<td>ECS component with Transform</td>\n<td>Position, direction, cone angles, color</td>\n</tr>\n<tr>\n<td>Shadow Map</td>\n<td>Depth-based shadow rendering</td>\n<td>Framebuffer render target</td>\n<td>Resolution, light space matrix</td>\n</tr>\n<tr>\n<td>Material Properties</td>\n<td>Surface light response</td>\n<td>Component with mesh data</td>\n<td>Albedo, normal, metallic, roughness</td>\n</tr>\n</tbody></table>\n<p>The lighting calculation pipeline integrates naturally with our existing ECS architecture. A <code>LightingSystem</code> would query entities with light components during the rendering phase, uploading light parameters as uniform arrays to the fragment shader. Our <code>BatchRenderer</code> requires minimal modification — the same geometry batching applies, but with expanded shader programs that perform light calculations per-pixel.</p>\n<p>Shadow mapping introduces the concept of multi-pass rendering, where the scene is rendered multiple times from different perspectives. Our <code>Renderer</code> interface can be extended with a <code>RenderToFramebuffer</code> method that captures depth information from the light&#39;s perspective. The resulting shadow map texture becomes an additional uniform input to the main rendering pass, where shadow coordinates are calculated and compared for shadow determination.</p>\n<blockquote>\n<p><strong>Critical Insight: Shader Hot-Swapping</strong>\nAdvanced rendering features require rapid iteration on shader code. Our <code>ShaderProgram</code> architecture supports this by detecting file changes and recompiling shaders at runtime, allowing artists and programmers to see lighting changes immediately without engine restarts.</p>\n</blockquote>\n<h4 id=\"post-processing-pipeline\">Post-Processing Pipeline</h4>\n<p>Post-processing effects transform the final rendered image through screen-space operations like bloom, tone mapping, and depth-of-field blur. These effects require a <strong>full-screen quad rendering</strong> approach where the scene is first rendered to an off-screen framebuffer, then processed through multiple shader passes before final presentation.</p>\n<table>\n<thead>\n<tr>\n<th>Post-Process Effect</th>\n<th>Visual Impact</th>\n<th>Shader Requirements</th>\n<th>Performance Cost</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bloom</td>\n<td>Bright objects glow</td>\n<td>Gaussian blur passes</td>\n<td>Medium (multiple passes)</td>\n</tr>\n<tr>\n<td>Tone Mapping</td>\n<td>HDR to display range</td>\n<td>Single pass with LUT</td>\n<td>Low (single pass)</td>\n</tr>\n<tr>\n<td>Depth of Field</td>\n<td>Camera focus simulation</td>\n<td>Blur with depth testing</td>\n<td>High (complex blur)</td>\n</tr>\n<tr>\n<td>Screen Space Ambient Occlusion</td>\n<td>Contact shadows</td>\n<td>Depth buffer sampling</td>\n<td>High (many samples)</td>\n</tr>\n<tr>\n<td>Temporal Anti-Aliasing</td>\n<td>Edge smoothing</td>\n<td>Previous frame history</td>\n<td>Medium (memory bandwidth)</td>\n</tr>\n</tbody></table>\n<p>The post-processing pipeline requires extending our <code>Renderer</code> with framebuffer management capabilities. A <code>PostProcessManager</code> component would maintain a chain of render targets and associated shaders, applying effects in sequence. Our existing <code>BatchRenderer</code> handles the full-screen quad rendering — it&#39;s simply a sprite that covers the entire screen with the previous render pass as its texture.</p>\n<p>Each post-processing effect becomes a self-contained shader program with its associated framebuffer configuration. The pipeline supports <strong>effect chaining</strong> where the output of one effect becomes the input to the next. Memory management requires careful attention — multiple full-screen render targets can consume significant GPU memory, requiring adaptive resolution scaling based on available video memory.</p>\n<blockquote>\n<p><strong>Architecture Decision: Render Graph vs Linear Pipeline</strong></p>\n<ul>\n<li><strong>Context</strong>: Post-processing effects have dependencies and optimal execution orders that vary by scene content</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Linear pipeline (fixed effect order)</li>\n<li>Render graph (dynamic dependency resolution)</li>\n<li>Hybrid approach (linear with optional branches)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Linear pipeline with optional branches</li>\n<li><strong>Rationale</strong>: Provides 80% of the flexibility with 20% of the complexity. Most post-processing workflows follow predictable patterns, but occasional branching (skip expensive effects on low-end hardware) provides necessary adaptability</li>\n<li><strong>Consequences</strong>: Enables immediate implementation while preserving upgrade path to full render graph when complexity demands justify the investment</li>\n</ul>\n</blockquote>\n<h4 id=\"modern-rendering-techniques\">Modern Rendering Techniques</h4>\n<p>Advanced rendering techniques like physically-based rendering (PBR) and compute shader integration represent significant extensions to our graphics pipeline. These features require substantial shader program expansion and new GPU resource management patterns, but our existing architecture provides the foundation for implementation.</p>\n<p>PBR rendering replaces ad-hoc lighting calculations with physically accurate material models. The mathematical complexity increases significantly, but the integration points remain the same — expanded uniform variables for material properties, enhanced fragment shaders for lighting calculations, and additional textures for surface detail maps.</p>\n<table>\n<thead>\n<tr>\n<th>PBR Component</th>\n<th>Physical Meaning</th>\n<th>Texture Input</th>\n<th>Shader Calculation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Albedo</td>\n<td>Surface color without lighting</td>\n<td>RGB texture</td>\n<td>Diffuse color basis</td>\n</tr>\n<tr>\n<td>Normal Map</td>\n<td>Surface micro-geometry</td>\n<td>RGB encoded vectors</td>\n<td>Tangent space transformation</td>\n</tr>\n<tr>\n<td>Metallic</td>\n<td>Conductor vs dielectric</td>\n<td>Grayscale texture</td>\n<td>Specular reflection behavior</td>\n</tr>\n<tr>\n<td>Roughness</td>\n<td>Surface micro-facet distribution</td>\n<td>Grayscale texture</td>\n<td>Light scattering calculation</td>\n</tr>\n<tr>\n<td>Ambient Occlusion</td>\n<td>Ambient light blocking</td>\n<td>Grayscale texture</td>\n<td>Ambient light attenuation</td>\n</tr>\n</tbody></table>\n<p>Compute shaders introduce GPU-based computation for non-rendering tasks like particle simulation, procedural animation, and advanced lighting calculations. Our <code>ShaderProgram</code> system requires extension to support compute shader compilation and dispatch. The key architectural challenge is <strong>CPU-GPU synchronization</strong> — ensuring compute results are available when needed by the rendering pipeline.</p>\n<p>The integration approach leverages our existing handle-based resource system. Compute buffers become a new resource type managed by the <code>ResourceManager</code>, with <code>ComputeBufferHandle</code> providing safe access similar to texture and mesh handles. Systems that depend on compute results can query buffer availability before proceeding with dependent calculations.</p>\n<h3 id=\"engine-system-extensions\">Engine System Extensions</h3>\n<p>Beyond enhanced visuals, a mature game engine provides systems for audio, networking, scripting, and development tools. Our architectural foundation — particularly the ECS design and event-driven communication patterns — creates natural integration points for these advanced capabilities.</p>\n<h4 id=\"audio-system-integration\">Audio System Integration</h4>\n<p>Game audio encompasses environmental soundscapes, dynamic music, and interactive sound effects that respond to game state changes. An audio system integrates with our engine through ECS components that represent sound sources and listeners, with spatial audio calculations updating based on entity transforms.</p>\n<table>\n<thead>\n<tr>\n<th>Audio Component Type</th>\n<th>ECS Integration</th>\n<th>Behavior</th>\n<th>Resource Dependencies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Audio Source</td>\n<td>Component with Transform</td>\n<td>3D positioned sound</td>\n<td>AudioHandle references</td>\n</tr>\n<tr>\n<td>Audio Listener</td>\n<td>Component with Transform</td>\n<td>Player ear position</td>\n<td>None (singleton)</td>\n</tr>\n<tr>\n<td>Audio Mixer</td>\n<td>System processor</td>\n<td>Volume and effect management</td>\n<td>Audio configuration</td>\n</tr>\n<tr>\n<td>Music Manager</td>\n<td>System processor</td>\n<td>Dynamic music transitions</td>\n<td>Music track AudioHandles</td>\n</tr>\n<tr>\n<td>Sound Pool</td>\n<td>Resource optimization</td>\n<td>Reusable audio instances</td>\n<td>Pooled AudioHandle groups</td>\n</tr>\n</tbody></table>\n<p>The audio pipeline follows our established resource loading patterns. Audio files become <code>AudioResource</code> objects managed by the <code>ResourceManager</code>, with <code>AudioHandle</code> references providing safe access. The <code>AudioSystem</code> queries entities with audio components during each frame, calculating 3D spatial audio parameters based on source and listener transforms.</p>\n<p>Audio streaming introduces <strong>background loading</strong> requirements similar to texture streaming. Large audio files can&#39;t be fully loaded into memory simultaneously, requiring a streaming buffer system that loads audio data on-demand. Our existing asynchronous resource loading infrastructure supports this through prioritized loading queues and completion callbacks.</p>\n<blockquote>\n<p><strong>Critical Design Challenge: Audio Threading</strong>\nAudio processing requires consistent timing to avoid glitches, while game logic runs on variable frame times. The solution is an independent audio thread that maintains its own fixed-rate update loop, communicating with the main thread through lock-free queues for parameter updates and trigger events.</p>\n</blockquote>\n<h4 id=\"networking-and-multiplayer-support\">Networking and Multiplayer Support</h4>\n<p>Networked multiplayer transforms a single-player game engine into a distributed system where game state must remain synchronized across multiple clients. Our deterministic physics simulation and serializable ECS architecture provide the foundation for reliable multiplayer implementation.</p>\n<p>The networking extension introduces <strong>client-server</strong> and <strong>peer-to-peer</strong> communication patterns. Client-server architecture designates one instance as authoritative, with clients sending input and receiving state updates. Peer-to-peer architecture distributes authority, requiring more complex conflict resolution but eliminating single points of failure.</p>\n<table>\n<thead>\n<tr>\n<th>Networking Pattern</th>\n<th>Authority Model</th>\n<th>Synchronization Approach</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Client-Server</td>\n<td>Server authoritative</td>\n<td>Input prediction + rollback</td>\n<td>Client reconnection</td>\n</tr>\n<tr>\n<td>Peer-to-Peer</td>\n<td>Distributed consensus</td>\n<td>Shared simulation state</td>\n<td>Majority voting</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Dynamic authority</td>\n<td>Region-based authority</td>\n<td>Authority migration</td>\n</tr>\n</tbody></table>\n<p>Our ECS architecture supports networking through <strong>component replication</strong>. Network-relevant components are marked with replication flags, and a <code>NetworkSystem</code> serializes component changes for transmission. The receiving system applies updates to local entity state, with conflict resolution handling simultaneous modifications.</p>\n<p>The serialization system extends our existing scene serialization infrastructure. Network messages use the same <code>ToJSON</code>/<code>FromJSON</code> patterns established for scene persistence, ensuring consistency between save/load and network synchronization. Delta compression reduces bandwidth by transmitting only changed component values rather than complete entity state.</p>\n<blockquote>\n<p><strong>Architecture Decision: Lockstep vs Client-Server</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiplayer games require synchronized game state across multiple machines with varying network latency</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Lockstep simulation (all clients run identical simulation)</li>\n<li>Client-server (authoritative server, predictive clients)</li>\n<li>Hybrid (deterministic simulation with periodic reconciliation)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Client-server with input prediction</li>\n<li><strong>Rationale</strong>: Provides best balance of responsiveness and security. Lockstep requires perfect synchronization and is vulnerable to cheating. Pure server authority has poor responsiveness. Client-server with prediction provides immediate feedback while maintaining server authority</li>\n<li><strong>Consequences</strong>: Requires rollback and replay systems for mispredictions, but enables responsive multiplayer with cheat protection</li>\n</ul>\n</blockquote>\n<h4 id=\"scripting-system-integration\">Scripting System Integration</h4>\n<p>Scripting languages like Lua or Python enable rapid gameplay iteration without engine recompilation. A scripting system integrates with our ECS architecture by allowing scripts to define custom components and systems, extending game behavior through interpreted code rather than compiled C++.</p>\n<p>The scripting integration creates a <strong>dual-language</strong> architecture where performance-critical systems remain in C++ while gameplay logic moves to scripts. This separation requires careful API design to expose engine functionality to scripts without compromising performance or stability.</p>\n<table>\n<thead>\n<tr>\n<th>Scripting Integration Point</th>\n<th>C++ Responsibility</th>\n<th>Script Responsibility</th>\n<th>Communication Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Definition</td>\n<td>Storage and iteration</td>\n<td>Data structure and behavior</td>\n<td>Registration callbacks</td>\n</tr>\n<tr>\n<td>System Logic</td>\n<td>ECS query and execution</td>\n<td>Gameplay rules and reactions</td>\n<td>Function call binding</td>\n</tr>\n<tr>\n<td>Event Handling</td>\n<td>Event queue management</td>\n<td>Event response logic</td>\n<td>Callback registration</td>\n</tr>\n<tr>\n<td>Resource Access</td>\n<td>Handle validation and lifecycle</td>\n<td>Content specification and usage</td>\n<td>Proxy object wrapping</td>\n</tr>\n</tbody></table>\n<p>The implementation approach embeds a scripting interpreter within the engine process, with bidirectional binding between C++ engine code and script functions. Scripts define custom components as data tables, while C++ provides the underlying storage and iteration infrastructure. Custom systems written in scripts receive callbacks during the system update phase, with access to entity queries and component modification through bound API functions.</p>\n<p>Script sandboxing becomes important for security and stability. Scripts should not directly access memory or file systems, instead operating through controlled engine APIs. Resource access follows our handle-based pattern, with script proxies providing safe access to textures, audio, and other assets.</p>\n<h4 id=\"development-tools-and-editor-integration\">Development Tools and Editor Integration</h4>\n<p>Professional game development requires editor tools for level design, asset management, and debugging. Our engine architecture supports editor integration through <strong>reflection</strong> systems that expose internal data structures and <strong>immediate mode GUI</strong> systems that provide runtime debugging interfaces.</p>\n<table>\n<thead>\n<tr>\n<th>Editor Component</th>\n<th>Purpose</th>\n<th>Integration Approach</th>\n<th>Implementation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Scene Editor</td>\n<td>Visual level design</td>\n<td>ECS entity manipulation</td>\n<td>Transform gizmos, selection</td>\n</tr>\n<tr>\n<td>Asset Browser</td>\n<td>Resource management</td>\n<td>ResourceManager integration</td>\n<td>Thumbnail generation, metadata</td>\n</tr>\n<tr>\n<td>Performance Profiler</td>\n<td>Runtime analysis</td>\n<td>System timing collection</td>\n<td>Frame time graphs, memory usage</td>\n</tr>\n<tr>\n<td>Component Inspector</td>\n<td>Entity debugging</td>\n<td>Reflection-based UI</td>\n<td>Property editing, type introspection</td>\n</tr>\n<tr>\n<td>Console Window</td>\n<td>Command execution</td>\n<td>Script system integration</td>\n<td>Command parsing, output display</td>\n</tr>\n</tbody></table>\n<p>The editor architecture follows a <strong>plugin</strong> pattern where each tool is a self-contained module that interfaces with the engine through well-defined APIs. This separation allows editor features to be developed independently while maintaining engine stability. The editor runs alongside the game, sharing the same ECS world but with additional systems for tool functionality.</p>\n<p>Reflection support requires extending our component system with <strong>metadata</strong> that describes component fields, types, and constraints. This metadata enables automatic GUI generation for component editing without manual interface programming for each component type. The reflection system integrates with our serialization infrastructure, ensuring that editor modifications can be saved and loaded consistently.</p>\n<h3 id=\"performance-and-scalability\">Performance and Scalability</h3>\n<p>Modern games demand performance that scales from mobile devices to high-end gaming PCs. Our engine architecture provides multiple optimization pathways through multi-threading, job systems, and GPU compute integration. These performance extensions build upon our data-oriented design foundation while introducing parallel processing complexity.</p>\n<h4 id=\"multi-threading-and-job-systems\">Multi-Threading and Job Systems</h4>\n<p>Game engines are naturally parallel — rendering, physics, and audio can execute simultaneously while the main thread coordinates overall execution. A <strong>job system</strong> architecture decomposes frame processing into independent work units that execute across multiple CPU cores.</p>\n<p>Our ECS design supports parallelization through <strong>component archetype</strong> organization. Systems that operate on disjoint component sets can execute simultaneously, while systems with overlapping component access require synchronization. The challenge is <strong>dependency management</strong> — ensuring systems execute in the correct order while maximizing parallel execution opportunities.</p>\n<table>\n<thead>\n<tr>\n<th>Threading Model</th>\n<th>Coordination Approach</th>\n<th>Scalability Characteristics</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Thread Pool</td>\n<td>Work stealing queues</td>\n<td>Scales with available cores</td>\n<td>Medium (queue management)</td>\n</tr>\n<tr>\n<td>Task Graph</td>\n<td>Dependency resolution</td>\n<td>Optimal parallel scheduling</td>\n<td>High (graph construction)</td>\n</tr>\n<tr>\n<td>Pipeline</td>\n<td>Stage-based processing</td>\n<td>Predictable parallel patterns</td>\n<td>Low (fixed pipeline stages)</td>\n</tr>\n</tbody></table>\n<p>The job system implementation extends our existing <code>System</code> execution infrastructure. Instead of sequential system updates, systems generate <strong>job descriptions</strong> that specify their component requirements and processing functions. A job scheduler analyzes dependencies and assigns work to available threads, ensuring that systems with conflicting component access don&#39;t execute simultaneously.</p>\n<p>Memory access patterns become critical for multi-threaded performance. Our component storage system&#39;s dense arrays provide <strong>cache-friendly</strong> iteration patterns that work well with parallel processing. Thread-local memory pools reduce allocation contention, while lock-free data structures enable safe concurrent access to shared resources.</p>\n<blockquote>\n<p><strong>Critical Performance Insight: False Sharing</strong>\nMulti-threaded component processing can suffer from false sharing when adjacent components are processed by different threads. The solution is <strong>component padding</strong> or <strong>interleaved processing</strong> patterns that ensure each thread works on cache-line-aligned memory regions.</p>\n</blockquote>\n<h4 id=\"gpu-compute-integration\">GPU Compute Integration</h4>\n<p>Modern GPUs provide massive parallel processing capability beyond graphics rendering. <strong>Compute shaders</strong> enable GPU-accelerated physics simulation, procedural content generation, and AI processing. Our engine architecture supports compute integration through extended shader management and CPU-GPU synchronization patterns.</p>\n<p>Compute shader integration follows our established resource management patterns. Compute buffers become a new resource type with associated handles and lifecycle management. The key challenge is <strong>synchronization</strong> — ensuring compute results are available when needed by dependent systems while avoiding CPU-GPU pipeline stalls.</p>\n<table>\n<thead>\n<tr>\n<th>Compute Application</th>\n<th>Parallel Advantage</th>\n<th>Integration Requirements</th>\n<th>Synchronization Needs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Particle Physics</td>\n<td>Thousands of independent particles</td>\n<td>Particle component storage</td>\n<td>Position buffer readback</td>\n</tr>\n<tr>\n<td>Procedural Animation</td>\n<td>Vertex-level skeletal animation</td>\n<td>Mesh vertex buffer access</td>\n<td>Animation frame synchronization</td>\n</tr>\n<tr>\n<td>Pathfinding</td>\n<td>Parallel graph traversal</td>\n<td>Spatial grid representation</td>\n<td>Path result availability</td>\n</tr>\n<tr>\n<td>Procedural Generation</td>\n<td>Noise evaluation and terrain synthesis</td>\n<td>Heightmap texture generation</td>\n<td>Terrain mesh creation</td>\n</tr>\n</tbody></table>\n<p>The implementation approach extends our <code>ShaderProgram</code> system with compute shader compilation and dispatch capabilities. Compute operations become part of the frame processing pipeline, with careful scheduling to avoid resource conflicts between compute and graphics operations. Buffer mapping and unmapping require explicit management to ensure data consistency across CPU and GPU operations.</p>\n<p>Asynchronous compute enables <strong>parallel GPU processing</strong> where compute operations execute concurrently with graphics rendering. This requires sophisticated resource management to ensure compute operations don&#39;t interfere with ongoing rendering, typically through double-buffered resource patterns.</p>\n<h4 id=\"memory-management-optimization\">Memory Management Optimization</h4>\n<p>Advanced performance requires sophisticated memory management that goes beyond basic allocation and deallocation. <strong>Memory pools</strong>, <strong>object recycling</strong>, and <strong>cache-aware data layout</strong> optimize allocation patterns and improve cache performance for performance-critical game loops.</p>\n<p>Our ECS architecture already provides foundation-level memory management through dense component arrays and handle-based resource access. Performance optimization builds upon this foundation with specialized allocators and memory access pattern analysis.</p>\n<table>\n<thead>\n<tr>\n<th>Memory Optimization</th>\n<th>Performance Impact</th>\n<th>Implementation Requirements</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory Pools</td>\n<td>Eliminates allocation overhead</td>\n<td>Pre-allocated block management</td>\n<td>Memory over-allocation</td>\n</tr>\n<tr>\n<td>Object Recycling</td>\n<td>Reduces garbage collection</td>\n<td>Object lifecycle tracking</td>\n<td>Initialization overhead</td>\n</tr>\n<tr>\n<td>Custom Allocators</td>\n<td>Cache-friendly allocation</td>\n<td>Platform-specific optimization</td>\n<td>Implementation complexity</td>\n</tr>\n<tr>\n<td>Memory Mapping</td>\n<td>Large file handling</td>\n<td>Virtual memory management</td>\n<td>Address space consumption</td>\n</tr>\n</tbody></table>\n<p>Memory pool implementation extends our component storage with <strong>pre-allocated</strong> blocks for frequently created and destroyed objects. Particle systems, temporary collision pairs, and network messages benefit from pooled allocation patterns that eliminate allocation overhead during performance-critical frame processing.</p>\n<p>Cache optimization requires <strong>data layout</strong> analysis of our component storage patterns. Struct-of-arrays organization provides good cache performance for system iteration, but cross-system component access may benefit from <strong>hybrid</strong> layouts that group related components for spatial locality.</p>\n<p>Memory profiling integration provides runtime analysis of allocation patterns and memory usage trends. This profiling data informs optimization decisions and helps identify memory leaks or excessive allocation in performance-critical code paths.</p>\n<blockquote>\n<p><strong>Architecture Decision: Custom Allocators vs Standard Library</strong></p>\n<ul>\n<li><strong>Context</strong>: Game engines require predictable memory allocation performance with minimal fragmentation and low latency</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Standard library allocators (malloc/free, new/delete)</li>\n<li>Custom game-specific allocators (pools, stacks, rings)</li>\n<li>Hybrid approach (custom for hot paths, standard for cold paths)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with custom allocators for performance-critical systems</li>\n<li><strong>Rationale</strong>: Standard allocators provide good general performance but can&#39;t optimize for specific game engine access patterns. Custom allocators for components, rendering, and physics provide predictable performance. Standard allocators for initialization and tool code reduce implementation burden</li>\n<li><strong>Consequences</strong>: Requires allocator interface abstraction and careful memory ownership tracking, but enables optimal performance for frame-critical systems</li>\n</ul>\n</blockquote>\n<h3 id=\"common-extension-pitfalls\">Common Extension Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Feature Creep Without Architecture Evolution</strong>\nMany engine extensions fail because they&#39;re bolted onto existing systems without considering architectural implications. Adding networking to a single-player engine, for example, requires fundamental changes to state management and update ordering. The solution is to evaluate how each extension affects core architectural assumptions and modify foundational systems as needed rather than creating workarounds.</p>\n<p>⚠️ <strong>Pitfall: Performance Optimization Too Early</strong>\nAdvanced performance features like multi-threading and GPU compute introduce significant complexity that can destabilize a working engine. Implement these optimizations only after establishing baseline functionality and identifying actual performance bottlenecks through profiling. Premature optimization often creates bugs that are difficult to diagnose and fix.</p>\n<p>⚠️ <strong>Pitfall: Breaking Interface Compatibility</strong>\nEngine extensions should enhance existing systems without breaking established APIs. Adding lighting support, for example, should extend the rendering pipeline rather than replacing it entirely. Design extensions as <strong>additive</strong> features that can be enabled or disabled without affecting core engine functionality.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Resource Constraints</strong>\nAdvanced features often assume abundant memory and processing power. Real games run on constrained hardware with limited memory and battery life. Design extensions with <strong>scalability</strong> from the beginning, providing quality settings and graceful degradation when resources are limited.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The future extensions described above build upon the four-milestone foundation, demonstrating how architectural decisions made during core development enable advanced capabilities. This section provides concrete starting points for implementing selected extensions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Foundational Technology</th>\n<th>Advanced Integration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Advanced Rendering</td>\n<td>OpenGL 3.3 + GLSL shaders</td>\n<td>Vulkan with compute shaders</td>\n</tr>\n<tr>\n<td>Audio System</td>\n<td>OpenAL or SDL2 Audio</td>\n<td>FMOD or Steam Audio</td>\n</tr>\n<tr>\n<td>Networking</td>\n<td>UDP sockets + serialization</td>\n<td>ENet or custom reliable UDP</td>\n</tr>\n<tr>\n<td>Scripting Integration</td>\n<td>Lua with C++ binding</td>\n<td>Python with pybind11</td>\n</tr>\n<tr>\n<td>Multi-threading</td>\n<td>std::thread with work queues</td>\n<td>Intel TBB or custom job system</td>\n</tr>\n<tr>\n<td>Development Tools</td>\n<td>Dear ImGui for immediate mode UI</td>\n<td>Custom editor with Qt or web UI</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-extension-implementation-order\">Recommended Extension Implementation Order</h4>\n<p>Extensions should be implemented in dependency order, building upon previously established capabilities:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>engine-extensions/\n  rendering/\n    lighting/\n      directional_light.h          ← Basic lighting components\n      point_light.h                ← Extends ECS with light entities\n      shadow_mapper.h              ← Framebuffer-based shadow rendering\n    post_processing/\n      post_process_manager.h       ← Pipeline for chained effects\n      bloom_effect.h               ← Gaussian blur-based bloom\n      tone_mapper.h                ← HDR to LDR conversion\n  systems/\n    audio/\n      audio_system.h               ← 3D positioned audio processing\n      audio_streaming.h            ← Background audio loading\n    networking/\n      network_system.h             ← Component replication\n      client_server.h              ← Authority and prediction\n    scripting/\n      lua_integration.h            ← Embedded Lua interpreter\n      script_component.h           ← Script-defined components\n  performance/\n    threading/\n      job_system.h                 ← Multi-threaded system execution\n      thread_pool.h                ← Work stealing implementation\n    compute/\n      compute_shader.h             ← GPU compute integration\n      buffer_manager.h             ← CPU-GPU synchronization</code></pre></div>\n\n<h4 id=\"advanced-rendering-infrastructure\">Advanced Rendering Infrastructure</h4>\n<p>The lighting and post-processing extensions require framebuffer management and multi-pass rendering capabilities:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Framebuffer management for advanced rendering</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FramebufferManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> FramebufferConfig</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> width;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> height;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        GLenum colorFormat;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> hasDepth;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> hasStencil;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">string, </span><span style=\"color:#F97583\">uint32_t></span><span style=\"color:#E1E4E8\"> m_framebuffers;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">string, </span><span style=\"color:#F97583\">uint32_t></span><span style=\"color:#E1E4E8\"> m_colorTextures;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">string, </span><span style=\"color:#F97583\">uint32_t></span><span style=\"color:#E1E4E8\"> m_depthTextures;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create framebuffer with specified configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> CreateFramebuffer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> FramebufferConfig</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Bind framebuffer for rendering (use 0 for default framebuffer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> BindFramebuffer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get color texture handle for use in subsequent passes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetColorTexture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get depth texture for shadow mapping or depth effects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetDepthTexture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Resize framebuffer when window dimensions change</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ResizeFramebuffer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> width</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> height</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Multi-pass rendering coordinator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RenderPassManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> RenderPass</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        string framebuffer;</span><span style=\"color:#6A737D\">    // Target framebuffer name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ShaderProgram shader;</span><span style=\"color:#6A737D\">  // Shader for this pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> setupCallback;</span><span style=\"color:#6A737D\">  // Pass-specific setup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">RenderPass</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_passes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FramebufferManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> m_framebufferManager;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add render pass to execution pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddPass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> framebuffer</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 const</span><span style=\"color:#B392F0\"> ShaderProgram</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> shader</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">()> </span><span style=\"color:#FFAB70\">setup</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Execute all passes in sequence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ExecutePasses</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clear all registered passes (for dynamic pipeline changes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ClearPasses</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"ecs-integrated-audio-system\">ECS-Integrated Audio System</h4>\n<p>The audio system demonstrates how new engine systems integrate with our established ECS architecture:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Audio components that integrate with existing ECS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> AudioSource</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AudioHandle audioClip;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> volume </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> pitch </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> looping </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> is3D </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> maxDistance </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> isPlaying </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> AudioListener</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> masterVolume </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Vector3 velocity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span><span style=\"color:#6A737D\">  // For doppler effects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Audio system that processes spatial audio each frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AudioSystem</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> m_audioContext;</span><span style=\"color:#6A737D\">  // OpenAL context or similar</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity m_listenerEntity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity, </span><span style=\"color:#F97583\">uint32_t></span><span style=\"color:#E1E4E8\"> m_activeSources;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize audio context and set up 3D audio parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update all audio sources based on 3D positions relative to listener</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Find listener entity and get its transform</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Query all entities with AudioSource and Transform components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: For each audio source, calculate 3D position relative to listener</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Update OpenAL source position, velocity, and attenuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Start or stop sources based on isPlaying flag changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Trigger one-shot audio playback at specific world position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> PlaySoundAtPosition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">AudioHandle</span><span style=\"color:#FFAB70\"> audio</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Vector3</span><span style=\"color:#FFAB70\"> position</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> volume</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clean up audio context and release resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"job-system-foundation\">Job System Foundation</h4>\n<p>Multi-threading support requires careful integration with the existing ECS system execution pipeline:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Job description for work that can execute in parallel</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Job</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> workFunction;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> requiredComponents;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> modifiedComponents;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    string debugName;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Thread-safe job queue with work stealing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JobSystem</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">thread</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_workers;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ThreadSafeQueue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Job</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_jobQueues;</span><span style=\"color:#6A737D\">  // One queue per worker thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atomic</span><span style=\"color:#F97583\">&#x3C;bool></span><span style=\"color:#E1E4E8\"> m_shouldStop{</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_numThreads;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Worker thread main loop that steals work from other queues when idle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> WorkerThreadMain</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> threadIndex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Start worker threads (typically numCores - 1 to leave main thread free)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> Initialize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> numThreads</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> thread</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">hardware_concurrency</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add job to least loaded worker queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SubmitJob</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Job</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> job</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Wait for all currently queued jobs to complete</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> WaitForCompletion</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Execute systems in parallel where component dependencies allow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ExecuteSystemsParallel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">System</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> systems</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ECSWorld</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Analyze component dependencies between systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Group systems into parallel batches based on component conflicts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Execute each batch in parallel, synchronizing between batches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Handle systems that require exclusive access to components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Shutdown worker threads gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> Shutdown</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"extension-integration-checkpoints\">Extension Integration Checkpoints</h4>\n<p>Each extension category has specific verification steps to ensure proper integration:</p>\n<p><strong>Lighting System Verification:</strong></p>\n<ol>\n<li>Compile and run engine with a scene containing multiple point lights</li>\n<li>Verify lights affect sprite and mesh rendering with realistic falloff</li>\n<li>Test shadow map generation by observing shadow casting from directional light</li>\n<li>Confirm performance remains acceptable with 10+ dynamic lights</li>\n</ol>\n<p><strong>Audio System Verification:</strong></p>\n<ol>\n<li>Play positioned audio that changes volume based on camera distance</li>\n<li>Test audio streaming by loading large audio files without frame drops</li>\n<li>Verify multiple simultaneous audio sources mix properly</li>\n<li>Confirm audio continues playing during physics simulation and rendering</li>\n</ol>\n<p><strong>Multi-threading Verification:</strong></p>\n<ol>\n<li>Profile frame time with and without parallel system execution enabled</li>\n<li>Test thread safety by running intensive workloads without crashes</li>\n<li>Verify deterministic behavior by comparing single-threaded and multi-threaded results</li>\n<li>Monitor CPU usage to confirm work is distributed across available cores</li>\n</ol>\n<p>The extension architecture demonstrates how thoughtful foundational design enables sophisticated future capabilities while maintaining the modular, testable structure established during core engine development.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) — terminology reference needed throughout development to ensure consistent understanding of game engine concepts and implementation details</p>\n</blockquote>\n<p>Understanding game engine development requires mastery of specialized terminology from multiple domains: computer graphics, physics simulation, software architecture, and real-time systems. This glossary serves as both a learning aid for newcomers and a reference for consistent terminology throughout the project. Each term includes not only its definition but also its context within game engine architecture and relationships to other concepts.</p>\n<h3 id=\"mental-model-technical-dictionary-with-context\">Mental Model: Technical Dictionary with Context</h3>\n<p>Think of this glossary as a <strong>specialized technical dictionary for a foreign language</strong>. Game engine development has evolved its own vocabulary that combines terms from graphics programming, physics simulation, software architecture, and performance optimization. Just as a foreign language dictionary provides not only translations but also usage examples and cultural context, this glossary explains not just what each term means, but how it fits into the broader ecosystem of game engine architecture and why understanding it matters for implementation success.</p>\n<h3 id=\"core-architecture-terminology\">Core Architecture Terminology</h3>\n<p>The foundation of game engine terminology centers around the major architectural patterns and design principles that govern how game engines organize code, data, and system interactions.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n<th>Related Concepts</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Entity Component System (ECS)</strong></td>\n<td>Architectural pattern separating data (components) from behavior (systems) with entities as unique identifiers</td>\n<td>Primary architecture for game object management in modern engines</td>\n<td>Entity, Component, System, Archetype</td>\n</tr>\n<tr>\n<td><strong>Data-Oriented Design</strong></td>\n<td>Programming approach that organizes data by access patterns rather than conceptual relationships</td>\n<td>Optimization philosophy underlying ECS and cache-friendly data structures</td>\n<td>Cache-friendly, Struct-of-arrays, Hot/cold data</td>\n</tr>\n<tr>\n<td><strong>Frame Time Budget</strong></td>\n<td>Maximum time available per frame to maintain target framerate (16.67ms for 60fps)</td>\n<td>Performance constraint that drives all system design decisions</td>\n<td>Fixed timestep, Frame processing pipeline</td>\n</tr>\n<tr>\n<td><strong>Handle-Based Access</strong></td>\n<td>Indirect resource access through validated handles instead of raw pointers</td>\n<td>Memory safety and resource lifecycle management strategy</td>\n<td>Resource handles, Generation counter, Handle validation</td>\n</tr>\n<tr>\n<td><strong>Archetype</strong></td>\n<td>Group of entities sharing identical component signatures</td>\n<td>ECS optimization technique for efficient component iteration</td>\n<td>Component signature, Dense storage, System queries</td>\n</tr>\n<tr>\n<td><strong>Component Signature</strong></td>\n<td>Bitset indicating which component types an entity possesses</td>\n<td>Fast matching mechanism for system queries and archetype assignment</td>\n<td>Bitset operations, Entity queries, System execution</td>\n</tr>\n</tbody></table>\n<p><strong>Real-time System Constraints</strong> define the performance and behavioral requirements that distinguish game engines from general-purpose applications. Unlike traditional software that can take variable time to complete operations, game engines must maintain consistent frame rates and deterministic behavior under strict time constraints.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n<th>Implementation Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Deterministic Simulation</strong></td>\n<td>Identical inputs always produce identical outputs regardless of timing</td>\n<td>Critical for physics simulation and networked gameplay</td>\n<td>Fixed timestep, Floating-point precision, Accumulator pattern</td>\n</tr>\n<tr>\n<td><strong>Frame Processing Pipeline</strong></td>\n<td>Sequence of input, update, physics, and rendering phases repeated each frame</td>\n<td>Organizing principle for all engine subsystems</td>\n<td>System ordering, Data dependencies, Parallel execution</td>\n</tr>\n<tr>\n<td><strong>Cache-Friendly</strong></td>\n<td>Memory layout optimized for CPU cache performance</td>\n<td>Performance optimization for component iteration and bulk operations</td>\n<td>Struct-of-arrays, Dense storage, Prefetching</td>\n</tr>\n<tr>\n<td><strong>Fixed Timestep</strong></td>\n<td>Constant time increment for deterministic physics simulation</td>\n<td>Decouples simulation accuracy from rendering framerate</td>\n<td>Accumulator pattern, Spiral of death, Interpolation</td>\n</tr>\n<tr>\n<td><strong>Accumulator Pattern</strong></td>\n<td>Time debt system that decouples physics from rendering frame rate</td>\n<td>Ensures deterministic physics while allowing variable rendering framerate</td>\n<td>Fixed timestep, Frame time budget, Interpolation</td>\n</tr>\n</tbody></table>\n<h3 id=\"entity-component-system-terminology\">Entity Component System Terminology</h3>\n<p>The ECS architecture introduces specialized terminology for entity management, component storage, and system execution that differs significantly from traditional object-oriented approaches.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Storage Implications</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Dense Storage</strong></td>\n<td>Contiguous array storage without gaps for maximum cache efficiency</td>\n<td>Components stored in packed arrays with index mapping</td>\n<td>O(1) iteration, excellent cache locality</td>\n</tr>\n<tr>\n<td><strong>Sparse Storage</strong></td>\n<td>Hash table or similar structure allowing gaps but direct entity ID indexing</td>\n<td>Components accessed directly by entity ID</td>\n<td>O(1) random access, poor iteration performance</td>\n</tr>\n<tr>\n<td><strong>Struct-of-Arrays (SoA)</strong></td>\n<td>Organizing data with separate arrays for each field type</td>\n<td>Each component type has separate arrays for each field</td>\n<td>Optimal for SIMD operations, complex access patterns</td>\n</tr>\n<tr>\n<td><strong>Array-of-Structs (AoS)</strong></td>\n<td>Organizing data with objects containing all fields together</td>\n<td>Components stored as complete structures in arrays</td>\n<td>Simple access patterns, suboptimal cache usage</td>\n</tr>\n<tr>\n<td><strong>Generation Counter</strong></td>\n<td>Version number to detect stale handle references after entity recycling</td>\n<td>Entity IDs include generation bits incremented on reuse</td>\n<td>Prevents use-after-free errors, validates handle lifetime</td>\n</tr>\n<tr>\n<td><strong>Component Archetype</strong></td>\n<td>Entities grouped by identical component signatures for efficient iteration</td>\n<td>Systems process entire archetypes rather than individual entities</td>\n<td>Minimizes component storage fragmentation</td>\n</tr>\n</tbody></table>\n<p><strong>Entity Lifecycle Management</strong> encompasses the creation, modification, and destruction of entities within the ECS framework. Understanding these patterns is crucial for preventing memory leaks and maintaining system performance.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Purpose</th>\n<th>Implementation Strategy</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Entity Recycling</strong></td>\n<td>Reuse destroyed entity IDs to prevent ID exhaustion</td>\n<td>Maintain free list of available entity slots</td>\n<td>Prevents unbounded ID growth</td>\n</tr>\n<tr>\n<td><strong>Component Addition</strong></td>\n<td>Attach new component data to existing entity</td>\n<td>May require archetype migration and storage reallocation</td>\n<td>O(1) amortized with occasional O(n) migration</td>\n</tr>\n<tr>\n<td><strong>Component Removal</strong></td>\n<td>Detach component data while preserving entity</td>\n<td>Triggers archetype change and component cleanup</td>\n<td>O(1) removal with potential archetype fragmentation</td>\n</tr>\n<tr>\n<td><strong>Archetype Migration</strong></td>\n<td>Move entity between component signature groups</td>\n<td>Copy entity&#39;s components to new archetype storage</td>\n<td>O(k) where k is number of components</td>\n</tr>\n<tr>\n<td><strong>Entity Destruction</strong></td>\n<td>Remove entity and all associated components</td>\n<td>Mark ID for recycling and cleanup all component storage</td>\n<td>O(k) component cleanup operations</td>\n</tr>\n</tbody></table>\n<h3 id=\"graphics-and-rendering-terminology\">Graphics and Rendering Terminology</h3>\n<p>Graphics programming introduces extensive terminology for GPU interaction, shader management, and rendering pipeline optimization. These concepts are fundamental to understanding how game engines transform 3D world data into 2D screen pixels.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>GPU Interaction</th>\n<th>Performance Implications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Vertex Buffer</strong></td>\n<td>GPU memory storing vertex attribute data (position, texture coordinates, colors)</td>\n<td>Uploaded once, referenced multiple times in draw calls</td>\n<td>Minimizes CPU-GPU data transfer overhead</td>\n</tr>\n<tr>\n<td><strong>Shader Program</strong></td>\n<td>Linked vertex and fragment shaders that define rendering appearance</td>\n<td>Compiled on GPU, switched between draw operations</td>\n<td>State changes expensive, batch similar materials</td>\n</tr>\n<tr>\n<td><strong>Draw Call</strong></td>\n<td>GPU command to render geometry using current shader and vertex data</td>\n<td>Synchronization point between CPU and GPU</td>\n<td>Minimize count through batching</td>\n</tr>\n<tr>\n<td><strong>State Change</strong></td>\n<td>GPU pipeline reconfiguration between draw operations</td>\n<td>Flushes GPU pipeline and reconfigures rendering state</td>\n<td>Expensive operation, group similar rendering work</td>\n</tr>\n<tr>\n<td><strong>Batch Rendering</strong></td>\n<td>Grouping similar draw operations to minimize GPU state changes</td>\n<td>Collect sprites/meshes with same material before submission</td>\n<td>Reduces draw calls from thousands to dozens</td>\n</tr>\n<tr>\n<td><strong>Uniform Variable</strong></td>\n<td>Shader parameter constant across entire draw call</td>\n<td>Set once per draw call, accessible to all vertices/pixels</td>\n<td>Efficient way to pass transformation matrices</td>\n</tr>\n</tbody></table>\n<p><strong>Rendering Pipeline Stages</strong> represent the sequence of operations that transform 3D geometry into final pixel colors. Each stage has specific responsibilities and performance characteristics that influence overall rendering efficiency.</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input</th>\n<th>Processing</th>\n<th>Output</th>\n<th>Optimization Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Vertex Shader</strong></td>\n<td>Vertex attributes</td>\n<td>Transform vertices to clip space</td>\n<td>Transformed vertices</td>\n<td>Minimize matrix operations</td>\n</tr>\n<tr>\n<td><strong>Primitive Assembly</strong></td>\n<td>Transformed vertices</td>\n<td>Group vertices into triangles</td>\n<td>Primitive shapes</td>\n<td>Handled automatically by GPU</td>\n</tr>\n<tr>\n<td><strong>Rasterization</strong></td>\n<td>Triangles in clip space</td>\n<td>Generate pixel fragments</td>\n<td>Fragment candidates</td>\n<td>Reduce overdraw through culling</td>\n</tr>\n<tr>\n<td><strong>Fragment Shader</strong></td>\n<td>Fragment data</td>\n<td>Calculate final pixel color</td>\n<td>Colored fragments</td>\n<td>Optimize texture sampling</td>\n</tr>\n<tr>\n<td><strong>Depth Testing</strong></td>\n<td>Fragment depth values</td>\n<td>Discard occluded fragments</td>\n<td>Visible fragments</td>\n<td>Enable early-Z rejection</td>\n</tr>\n<tr>\n<td><strong>Blending</strong></td>\n<td>Final fragment colors</td>\n<td>Combine with framebuffer</td>\n<td>Final pixel colors</td>\n<td>Minimize alpha blending</td>\n</tr>\n</tbody></table>\n<p><strong>Texture and Resource Management</strong> within the rendering system involves loading, caching, and efficiently accessing graphics assets during frame rendering.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Storage Location</th>\n<th>Access Pattern</th>\n<th>Management Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Texture Resources</strong></td>\n<td>GPU VRAM</td>\n<td>Random access by fragment shader</td>\n<td>Handle-based with reference counting</td>\n</tr>\n<tr>\n<td><strong>Mesh Resources</strong></td>\n<td>GPU vertex/index buffers</td>\n<td>Sequential access during draw calls</td>\n<td>Batch similar geometry together</td>\n</tr>\n<tr>\n<td><strong>Shader Resources</strong></td>\n<td>GPU program memory</td>\n<td>State changes between material types</td>\n<td>Cache compiled programs, minimize switches</td>\n</tr>\n<tr>\n<td><strong>Framebuffer Resources</strong></td>\n<td>GPU render targets</td>\n<td>Write during rendering, read for effects</td>\n<td>Double-buffering for temporal effects</td>\n</tr>\n</tbody></table>\n<h3 id=\"physics-and-collision-terminology\">Physics and Collision Terminology</h3>\n<p>Physics simulation introduces terminology from mechanical engineering and computational geometry, adapted for real-time constraints and numerical stability requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Simulation Role</th>\n<th>Numerical Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Rigid Body</strong></td>\n<td>Object with fixed shape that moves and rotates as unit</td>\n<td>Primary physics entity with mass, velocity, acceleration</td>\n<td>Assumes infinite stiffness for computational efficiency</td>\n</tr>\n<tr>\n<td><strong>Semi-Implicit Euler</strong></td>\n<td>Integration method updating velocity first, then position</td>\n<td>More stable than explicit Euler for stiff systems</td>\n<td>Reduces energy accumulation in oscillating systems</td>\n</tr>\n<tr>\n<td><strong>Impulse Response</strong></td>\n<td>Instantaneous velocity changes simulating collision forces</td>\n<td>Handles collision resolution without force accumulation</td>\n<td>Avoids integration instabilities from large forces</td>\n</tr>\n<tr>\n<td><strong>Position Correction</strong></td>\n<td>Separating overlapping objects to prevent visual artifacts</td>\n<td>Maintains non-penetration constraint after collision</td>\n<td>Balances realism with numerical stability</td>\n</tr>\n<tr>\n<td><strong>Penetration Depth</strong></td>\n<td>Distance two collision shapes have overlapped</td>\n<td>Determines correction magnitude and impulse strength</td>\n<td>Must handle floating-point precision limitations</td>\n</tr>\n<tr>\n<td><strong>Contact Manifold</strong></td>\n<td>Set of contact points between colliding objects</td>\n<td>Provides detailed collision geometry for response</td>\n<td>More contacts improve stability but increase cost</td>\n</tr>\n</tbody></table>\n<p><strong>Collision Detection Pipeline</strong> consists of multiple phases designed to efficiently identify and process object interactions in large game worlds.</p>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Purpose</th>\n<th>Algorithm</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Broad Phase</strong></td>\n<td>Identify potentially colliding object pairs</td>\n<td>Spatial partitioning (grid, quadtree, sweep-and-prune)</td>\n<td>Reduces O(n²) to O(n log n) complexity</td>\n</tr>\n<tr>\n<td><strong>Narrow Phase</strong></td>\n<td>Precise geometric intersection testing</td>\n<td>Shape-specific algorithms (AABB, circle, polygon)</td>\n<td>O(1) per pair but expensive geometric operations</td>\n</tr>\n<tr>\n<td><strong>Collision Response</strong></td>\n<td>Apply forces and position corrections</td>\n<td>Impulse-based response with constraint solving</td>\n<td>Must maintain energy conservation and stability</td>\n</tr>\n<tr>\n<td><strong>Contact Resolution</strong></td>\n<td>Handle resting contact and friction</td>\n<td>Iterative constraint solver or direct analytical solution</td>\n<td>Balances realism with computational cost</td>\n</tr>\n</tbody></table>\n<p><strong>Spatial Partitioning Techniques</strong> organize game world objects to accelerate collision detection and other spatial queries.</p>\n<table>\n<thead>\n<tr>\n<th>Technique</th>\n<th>Structure</th>\n<th>Best Use Cases</th>\n<th>Performance Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Uniform Grid</strong></td>\n<td>Regular grid cells</td>\n<td>Evenly distributed, similar-sized objects</td>\n<td>Simple implementation, poor for clustered objects</td>\n</tr>\n<tr>\n<td><strong>Quadtree/Octree</strong></td>\n<td>Hierarchical space subdivision</td>\n<td>Uneven object distribution, large world spaces</td>\n<td>Adaptive resolution, more complex traversal</td>\n</tr>\n<tr>\n<td><strong>Sweep and Prune</strong></td>\n<td>Sorted interval lists</td>\n<td>Many moving objects, coherent motion</td>\n<td>Excellent temporal coherence, poor for teleporting</td>\n</tr>\n<tr>\n<td><strong>Hash Grid</strong></td>\n<td>Hash table with spatial keys</td>\n<td>Large worlds with sparse occupation</td>\n<td>Constant-time insertion, potential hash collisions</td>\n</tr>\n</tbody></table>\n<h3 id=\"resource-and-asset-management-terminology\">Resource and Asset Management Terminology</h3>\n<p>Resource management encompasses the loading, caching, and lifecycle management of game assets including textures, audio files, meshes, and scene data.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Lifecycle Stage</th>\n<th>Memory Management</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Resource Handle</strong></td>\n<td>Indirect reference to loaded asset with validation</td>\n<td>Provides stable reference across resource reloading</td>\n<td>Prevents dangling pointers and use-after-free</td>\n</tr>\n<tr>\n<td><strong>Reference Counting</strong></td>\n<td>Automatic cleanup based on usage tracking</td>\n<td>Determines when resources can be safely unloaded</td>\n<td>Shared ownership model with circular reference prevention</td>\n</tr>\n<tr>\n<td><strong>Asynchronous Loading</strong></td>\n<td>Background file loading without blocking main thread</td>\n<td>Improves responsiveness during asset streaming</td>\n<td>Requires thread-safe completion notification</td>\n</tr>\n<tr>\n<td><strong>Resource Manifest</strong></td>\n<td>List of all assets required by scene or level</td>\n<td>Enables predictive loading and dependency resolution</td>\n<td>Prevents missing asset errors at runtime</td>\n</tr>\n<tr>\n<td><strong>Hot Reloading</strong></td>\n<td>Replace assets while application is running</td>\n<td>Development feature for rapid iteration</td>\n<td>Requires handle indirection and asset versioning</td>\n</tr>\n<tr>\n<td><strong>Asset Streaming</strong></td>\n<td>Load/unload resources based on player proximity</td>\n<td>Manages memory usage in large game worlds</td>\n<td>Complex prediction and prioritization algorithms</td>\n</tr>\n</tbody></table>\n<p><strong>Asset Loading Pipeline</strong> transforms raw file data into GPU-ready resources through multiple processing stages.</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input Format</th>\n<th>Processing</th>\n<th>Output Format</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>File Loading</strong></td>\n<td>Raw bytes from disk</td>\n<td>I/O operations, compression</td>\n<td>Memory buffer</td>\n<td>File not found, corruption detection</td>\n</tr>\n<tr>\n<td><strong>Format Parsing</strong></td>\n<td>Raw file data</td>\n<td>PNG/JPG/OBJ decoding</td>\n<td>Structured data</td>\n<td>Invalid format, version mismatch</td>\n</tr>\n<tr>\n<td><strong>GPU Upload</strong></td>\n<td>CPU asset data</td>\n<td>Texture/buffer creation</td>\n<td>GPU resources</td>\n<td>Out of memory, driver failures</td>\n</tr>\n<tr>\n<td><strong>Handle Creation</strong></td>\n<td>GPU resource IDs</td>\n<td>Indirection table entry</td>\n<td>Validated handle</td>\n<td>Resource limit exhaustion</td>\n</tr>\n</tbody></table>\n<p><strong>Resource Caching Strategies</strong> balance memory usage with access performance by maintaining frequently-used assets in fast storage.</p>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Cache Policy</th>\n<th>Eviction Algorithm</th>\n<th>Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>LRU (Least Recently Used)</strong></td>\n<td>Replace oldest accessed items</td>\n<td>Track access timestamps</td>\n<td>General-purpose caching</td>\n</tr>\n<tr>\n<td><strong>Reference Counting</strong></td>\n<td>Keep while in use, discard when unused</td>\n<td>Automatic based on handle lifetime</td>\n<td>Predictable memory management</td>\n</tr>\n<tr>\n<td><strong>Priority-Based</strong></td>\n<td>Assign importance scores to resources</td>\n<td>Evict lowest priority items first</td>\n<td>Performance-critical assets</td>\n</tr>\n<tr>\n<td><strong>Spatial Locality</strong></td>\n<td>Cache based on world position</td>\n<td>Predict based on player movement</td>\n<td>Open world streaming</td>\n</tr>\n</tbody></table>\n<h3 id=\"memory-management-and-performance-terminology\">Memory Management and Performance Terminology</h3>\n<p>Game engines require sophisticated memory management strategies to maintain consistent performance under real-time constraints.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Performance Impact</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory Pool</strong></td>\n<td>Pre-allocated memory blocks for frequent allocations</td>\n<td>Eliminates allocation overhead and fragmentation</td>\n<td>Fixed-size blocks for specific object types</td>\n</tr>\n<tr>\n<td><strong>Object Pooling</strong></td>\n<td>Reuse objects instead of allocation/deallocation</td>\n<td>Reduces garbage collection pressure</td>\n<td>Maintain free lists of reusable objects</td>\n</tr>\n<tr>\n<td><strong>Cache Line</strong></td>\n<td>Unit of data transfer between main memory and CPU cache (typically 64 bytes)</td>\n<td>Determines memory access efficiency</td>\n<td>Align frequently accessed data to cache boundaries</td>\n</tr>\n<tr>\n<td><strong>False Sharing</strong></td>\n<td>Cache line conflicts in multi-threaded access</td>\n<td>Degrades performance in parallel systems</td>\n<td>Separate frequently modified data by cache line size</td>\n</tr>\n<tr>\n<td><strong>Memory Alignment</strong></td>\n<td>Positioning data at specific byte boundaries</td>\n<td>Enables SIMD instructions and reduces access cost</td>\n<td>Use compiler attributes or manual padding</td>\n</tr>\n<tr>\n<td><strong>Garbage Collection</strong></td>\n<td>Automatic cleanup of unused resources</td>\n<td>Can cause frame rate stutters if not managed</td>\n<td>Use reference counting or manual lifetime management</td>\n</tr>\n</tbody></table>\n<p><strong>Performance Profiling Terminology</strong> helps identify and resolve performance bottlenecks in game engine systems.</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Measurement</th>\n<th>Interpretation</th>\n<th>Optimization Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Frame Time</strong></td>\n<td>Milliseconds per frame</td>\n<td>Must stay under 16.67ms for 60fps</td>\n<td>Identify bottleneck systems</td>\n</tr>\n<tr>\n<td><strong>Draw Calls</strong></td>\n<td>GPU rendering commands per frame</td>\n<td>Each call has overhead, minimize count</td>\n<td>Batch rendering optimization</td>\n</tr>\n<tr>\n<td><strong>Cache Misses</strong></td>\n<td>CPU cache access failures</td>\n<td>Indicates poor data locality</td>\n<td>Memory layout optimization</td>\n</tr>\n<tr>\n<td><strong>Context Switches</strong></td>\n<td>Thread scheduling changes</td>\n<td>High count indicates contention</td>\n<td>Reduce thread synchronization</td>\n</tr>\n<tr>\n<td><strong>Memory Bandwidth</strong></td>\n<td>Bytes transferred per second</td>\n<td>Bottleneck for large data sets</td>\n<td>Data structure optimization</td>\n</tr>\n<tr>\n<td><strong>Instruction Cache Misses</strong></td>\n<td>CPU instruction fetch failures</td>\n<td>Indicates code size or branching issues</td>\n<td>Code organization and size</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-and-development-terminology\">Debugging and Development Terminology</h3>\n<p>Game engine development requires specialized debugging techniques due to real-time constraints and complex system interactions.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Use Case</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Graphics Debugger</strong></td>\n<td>Tool for capturing and analyzing GPU rendering commands</td>\n<td>Debug rendering issues, optimize draw calls</td>\n<td>RenderDoc, Nsight Graphics, Intel GPA</td>\n</tr>\n<tr>\n<td><strong>Memory Leak Detection</strong></td>\n<td>Tracking allocations without corresponding deallocations</td>\n<td>Prevent gradual memory exhaustion</td>\n<td>Custom allocators with tracking</td>\n</tr>\n<tr>\n<td><strong>Assertion Macros</strong></td>\n<td>Debug-only checks that crash on invalid conditions</td>\n<td>Catch programming errors during development</td>\n<td>Compile out in release builds</td>\n</tr>\n<tr>\n<td><strong>Performance Profiler</strong></td>\n<td>Tool measuring execution time and resource usage</td>\n<td>Identify performance bottlenecks</td>\n<td>Intel VTune, AMD CodeXL, custom timers</td>\n</tr>\n<tr>\n<td><strong>Hot Code Paths</strong></td>\n<td>Frequently executed code sections</td>\n<td>Focus optimization efforts on high-impact areas</td>\n<td>Profile-guided optimization</td>\n</tr>\n<tr>\n<td><strong>Instrumentation</strong></td>\n<td>Adding measurement code to track system behavior</td>\n<td>Gather performance data and usage patterns</td>\n<td>Minimal overhead monitoring</td>\n</tr>\n</tbody></table>\n<p><strong>Common Debugging Scenarios</strong> in game engine development often involve system interactions that are difficult to isolate and reproduce.</p>\n<table>\n<thead>\n<tr>\n<th>Problem Type</th>\n<th>Symptoms</th>\n<th>Investigation Approach</th>\n<th>Common Causes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Rendering Issues</strong></td>\n<td>Black screen, incorrect graphics</td>\n<td>Graphics debugger, shader validation</td>\n<td>Context loss, state leaks, uniform errors</td>\n</tr>\n<tr>\n<td><strong>Physics Instability</strong></td>\n<td>Objects jittering or flying apart</td>\n<td>Energy monitoring, collision visualization</td>\n<td>Timestep issues, penetration resolution</td>\n</tr>\n<tr>\n<td><strong>Memory Corruption</strong></td>\n<td>Random crashes, data anomalies</td>\n<td>Memory debuggers, bounds checking</td>\n<td>Buffer overflows, use-after-free</td>\n</tr>\n<tr>\n<td><strong>Performance Regression</strong></td>\n<td>Frame rate drops, stuttering</td>\n<td>Profiling comparison, system timing</td>\n<td>Algorithm complexity, cache misses</td>\n</tr>\n<tr>\n<td><strong>Race Conditions</strong></td>\n<td>Intermittent failures, data corruption</td>\n<td>Thread synchronization analysis</td>\n<td>Shared data access, missing locks</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-architecture-patterns\">Advanced Architecture Patterns</h3>\n<p>Advanced game engine development introduces sophisticated architectural patterns that address scalability, maintainability, and performance challenges in large systems.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Purpose</th>\n<th>Implementation Complexity</th>\n<th>Benefits</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Job System</strong></td>\n<td>Parallel work distribution across CPU cores</td>\n<td>High - requires work stealing queues</td>\n<td>Maximizes CPU utilization</td>\n</tr>\n<tr>\n<td><strong>Entity Queries</strong></td>\n<td>Efficient selection of entities matching component criteria</td>\n<td>Medium - requires archetype optimization</td>\n<td>Fast system iteration</td>\n</tr>\n<tr>\n<td><strong>Event Systems</strong></td>\n<td>Decoupled communication between engine subsystems</td>\n<td>Medium - callback management</td>\n<td>Loose coupling, extensibility</td>\n</tr>\n<tr>\n<td><strong>Command Buffers</strong></td>\n<td>Deferred execution of rendering or logic operations</td>\n<td>Medium - requires serialization</td>\n<td>Thread safety, batching</td>\n</tr>\n<tr>\n<td><strong>Dependency Injection</strong></td>\n<td>Providing system dependencies through interfaces</td>\n<td>Low to Medium</td>\n<td>Testability, modularity</td>\n</tr>\n<tr>\n<td><strong>State Machines</strong></td>\n<td>Formal state management for complex game logic</td>\n<td>Medium - state transition validation</td>\n<td>Predictable behavior</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrent Programming Patterns</strong> address the challenges of multi-threaded game engine development while maintaining performance and correctness.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Thread Safety</th>\n<th>Performance Impact</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Lock-Free Queues</strong></td>\n<td>Atomic operations without mutex locking</td>\n<td>High performance, but complex</td>\n<td>High implementation complexity</td>\n</tr>\n<tr>\n<td><strong>Reader-Writer Locks</strong></td>\n<td>Multiple readers, exclusive writers</td>\n<td>Good for read-heavy workloads</td>\n<td>Medium complexity, potential deadlocks</td>\n</tr>\n<tr>\n<td><strong>Thread-Local Storage</strong></td>\n<td>Per-thread data to avoid synchronization</td>\n<td>Excellent performance</td>\n<td>Low complexity, memory overhead</td>\n</tr>\n<tr>\n<td><strong>Work Stealing</strong></td>\n<td>Distribute work dynamically between threads</td>\n<td>Excellent load balancing</td>\n<td>High implementation complexity</td>\n</tr>\n<tr>\n<td><strong>Message Passing</strong></td>\n<td>Thread communication through queues</td>\n<td>Eliminates shared state issues</td>\n<td>Medium complexity, copying overhead</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Game engine terminology spans multiple specialized domains, and understanding these concepts requires both theoretical knowledge and practical experience with real implementations. The following guidance helps translate terminology into working code.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Terminology Management</td>\n<td>Static header file with constants</td>\n<td>Dynamic string table with validation</td>\n</tr>\n<tr>\n<td>Documentation</td>\n<td>Inline comments with examples</td>\n<td>Generated documentation system</td>\n</tr>\n<tr>\n<td>API Consistency</td>\n<td>Naming convention guidelines</td>\n<td>Automated style checking</td>\n</tr>\n<tr>\n<td>Type Safety</td>\n<td>Strong typing with distinct types</td>\n<td>Template-based type system</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-organization\">Recommended File Organization</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// engine/include/terminology.h - Central terminology definitions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity Component System terminology</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> EntityID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> ComponentTypeID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint16_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> ArchetypeID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource management terminology  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> TextureHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">TextureResource</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> MeshHandle</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">MeshResource</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Physics simulation terminology</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> RigidBody</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> CollisionPair</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Rendering pipeline terminology</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> SpriteRenderData</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> BatchRenderer</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// engine/include/constants.h - Named constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Constants</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> TARGET_FPS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> MAX_ENTITIES </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4194304</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> PHYSICS_TIMESTEP </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> MAX_SPRITES_PER_BATCH </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// engine/include/enums.h - Engine enumerations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ResourceType</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        Texture</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        Mesh</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        Audio</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        Scene</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ComponentStorageType</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        Dense</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        Sparse</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        Hybrid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-type-definitions\">Core Type Definitions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Entity identification with generation counter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> m_id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetIndex</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> INDEX_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetGeneration</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (m_id </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> INDEX_BITS) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> GENERATION_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> m_id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.m_id; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resource handle with type safety and validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> ResourceType</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> m_handle;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Handle</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">m_handle</span><span style=\"color:#E1E4E8\">(NULL_HANDLE) {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> Handle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> handle</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">m_handle</span><span style=\"color:#E1E4E8\">(handle) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#B392F0\"> GetID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> static_cast&#x3C;uint32_t></span><span style=\"color:#E1E4E8\">(m_handle </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> ID_MASK); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#B392F0\"> GetVersion</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> static_cast&#x3C;uint16_t></span><span style=\"color:#E1E4E8\">((m_handle </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> VERSION_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> VERSION_MASK); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#B392F0\"> GetType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> static_cast&#x3C;uint16_t></span><span style=\"color:#E1E4E8\">((m_handle </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> TYPE_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TYPE_MASK); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> IsValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> m_handle </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> NULL_HANDLE; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Component storage interface for different strategies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> ComponentType</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~ComponentStorage</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ComponentType</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> AddComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> ComponentType</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> component</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> RemoveComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ComponentType</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> GetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> HasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> ForEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ComponentType</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"terminology-validation-system\">Terminology Validation System</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Development-time terminology validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TerminologyValidator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_set</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_validTerms;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> m_termDefinitions;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TerminologyValidator</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Load terminology from configuration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        RegisterTerm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"entity\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Unique identifier for game object\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        RegisterTerm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"component\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Data container attached to entity\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        RegisterTerm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"system\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Logic processor for component data\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ... register all engine terms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> RegisterTerm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> term</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> definition</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_validTerms.</span><span style=\"color:#B392F0\">insert</span><span style=\"color:#E1E4E8\">(term);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_termDefinitions[term] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> definition;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> ValidateCodebase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> sourceDirectory</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Scan source files for terminology usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Report inconsistencies and unknown terms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Generate terminology usage report</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#B392F0\"> GetDefinition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> term</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m_termDefinitions.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(term);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> m_termDefinitions.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> it->second </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"Unknown term\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"documentation-generation\">Documentation Generation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Automatic documentation generation from terminology</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DocumentationGenerator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::pair</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> m_glossaryEntries;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> AddGlossaryEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> term</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> definition</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        m_glossaryEntries.</span><span style=\"color:#B392F0\">emplace_back</span><span style=\"color:#E1E4E8\">(term, definition);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> GenerateMarkdownGlossary</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> outputPath</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::ofstream </span><span style=\"color:#B392F0\">file</span><span style=\"color:#E1E4E8\">(outputPath);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"# Engine Terminology</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Sort entries alphabetically</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#E1E4E8\">(m_glossaryEntries.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), m_glossaryEntries.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> [term, definition] : m_glossaryEntries) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            file </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"## \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> term </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            file </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> definition </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> GenerateCodeDocumentation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> outputPath</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Generate API documentation with terminology links</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Cross-reference terminology usage in code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Validate that all public APIs use consistent terminology</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"development-workflow-integration\">Development Workflow Integration</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Integration with development tools for terminology consistency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TerminologyIntegration</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate pull requests for terminology consistency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> ValidatePullRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> diffContent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Parse code changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check new terminology against approved glossary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Report terminology violations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generate IDE autocomplete for engine terminology  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> GenerateIDEConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> outputPath</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Export terminology as IDE snippets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Generate code completion databases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Create terminology-aware refactoring rules</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate API naming consistency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">ValidateAPINaming</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> violations;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check that public APIs follow terminology conventions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Verify consistent naming patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Report deviations from established patterns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> violations;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone 1 Terminology Validation:</strong></p>\n<ul>\n<li>Verify consistent use of rendering terminology in graphics code</li>\n<li>Validate that all shader variables use established naming conventions</li>\n<li>Confirm that window and context management uses standard terms</li>\n</ul>\n<p><strong>Milestone 2 Terminology Validation:</strong></p>\n<ul>\n<li>Check ECS terminology consistency across entity, component, and system code</li>\n<li>Validate that component storage terminology matches implementation</li>\n<li>Verify system execution terminology aligns with architectural decisions</li>\n</ul>\n<p><strong>Milestone 3 Terminology Validation:</strong>  </p>\n<ul>\n<li>Confirm physics terminology matches simulation approach</li>\n<li>Validate collision detection terminology in broad/narrow phase code</li>\n<li>Check that spatial partitioning uses consistent terminology</li>\n</ul>\n<p><strong>Milestone 4 Terminology Validation:</strong></p>\n<ul>\n<li>Verify resource management terminology in loading and caching systems</li>\n<li>Validate scene serialization terminology matches data structures</li>\n<li>Check that asset pipeline terminology aligns with implementation</li>\n</ul>\n<h4 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Inconsistent Terminology Usage</strong>\nMany developers introduce their own terms or use established terms incorrectly, creating confusion and maintenance difficulties. For example, using &quot;GameObject&quot; instead of &quot;Entity&quot; or &quot;Mesh&quot; instead of &quot;RigidBody&quot; for physics objects breaks the established terminology patterns and makes code harder to understand.</p>\n<p><strong>Solution:</strong> Establish terminology early in development and enforce it through code reviews and automated validation. Create a central header file with type aliases that enforce consistent naming throughout the codebase.</p>\n<p>⚠️ <strong>Pitfall: Terminology Drift Over Time</strong>\nAs projects evolve, terminology can gradually drift from original definitions, leading to confusion between team members and inconsistent API design. This often happens when new features are added without considering existing terminology patterns.</p>\n<p><strong>Solution:</strong> Regular terminology audits during development milestones, automated checking for consistency, and maintaining a living glossary document that evolves with the project while preserving established patterns.</p>\n","toc":[{"level":1,"text":"Game Engine: Design Document","id":"game-engine-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: Digital Theater Production","id":"mental-model-digital-theater-production"},{"level":3,"text":"Core Technical Challenges","id":"core-technical-challenges"},{"level":4,"text":"Frame-Rate Constraints and Real-Time Deadlines","id":"frame-rate-constraints-and-real-time-deadlines"},{"level":4,"text":"Memory Management and Cache Efficiency","id":"memory-management-and-cache-efficiency"},{"level":4,"text":"System Interdependencies and Update Ordering","id":"system-interdependencies-and-update-ordering"},{"level":4,"text":"Resource Loading and Streaming","id":"resource-loading-and-streaming"},{"level":3,"text":"Existing Engine Architectures","id":"existing-engine-architectures"},{"level":4,"text":"Monolithic Architecture","id":"monolithic-architecture"},{"level":4,"text":"Component-Based Architecture","id":"component-based-architecture"},{"level":4,"text":"Entity-Component-System (ECS) Architecture","id":"entity-component-system-ecs-architecture"},{"level":4,"text":"Architecture Selection Criteria","id":"architecture-selection-criteria"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Learning Skeleton Code","id":"core-learning-skeleton-code"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Requirements","id":"functional-requirements"},{"level":3,"text":"Performance and Quality Requirements","id":"performance-and-quality-requirements"},{"level":3,"text":"Scope Exclusions","id":"scope-exclusions"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Engine Subsystem Overview","id":"engine-subsystem-overview"},{"level":3,"text":"Frame Processing Pipeline","id":"frame-processing-pipeline"},{"level":3,"text":"Recommended Module Organization","id":"recommended-module-organization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Engine Data Model","id":"engine-data-model"},{"level":3,"text":"Entity and Component Types","id":"entity-and-component-types"},{"level":3,"text":"Resource and Asset Types","id":"resource-and-asset-types"},{"level":3,"text":"Memory Layout Considerations","id":"memory-layout-considerations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Rendering System Design","id":"rendering-system-design"},{"level":3,"text":"Mental Model: Art Production Assembly Line","id":"mental-model-art-production-assembly-line"},{"level":3,"text":"Window and Graphics Context","id":"window-and-graphics-context"},{"level":3,"text":"Shader Compilation and Management","id":"shader-compilation-and-management"},{"level":3,"text":"Batch Rendering Architecture","id":"batch-rendering-architecture"},{"level":3,"text":"Rendering Architecture Decisions","id":"rendering-architecture-decisions"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Entity Component System","id":"entity-component-system"},{"level":3,"text":"Mental Model: Database with Specialized Workers","id":"mental-model-database-with-specialized-workers"},{"level":3,"text":"Entity ID Management","id":"entity-id-management"},{"level":3,"text":"Component Storage Strategy","id":"component-storage-strategy"},{"level":3,"text":"System Update Pipeline","id":"system-update-pipeline"},{"level":3,"text":"ECS Architecture Decisions","id":"ecs-architecture-decisions"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Physics and Collision System","id":"physics-and-collision-system"},{"level":3,"text":"Mental Model: Billiard Table Simulation","id":"mental-model-billiard-table-simulation"},{"level":3,"text":"Collision Detection Pipeline","id":"collision-detection-pipeline"},{"level":4,"text":"Broad Phase Spatial Partitioning","id":"broad-phase-spatial-partitioning"},{"level":4,"text":"Narrow Phase Geometric Testing","id":"narrow-phase-geometric-testing"},{"level":4,"text":"Collision Detection Data Structures","id":"collision-detection-data-structures"},{"level":3,"text":"Physics Integration and Timestep","id":"physics-integration-and-timestep"},{"level":4,"text":"Fixed Timestep Architecture","id":"fixed-timestep-architecture"},{"level":4,"text":"Velocity and Position Integration","id":"velocity-and-position-integration"},{"level":4,"text":"Deterministic Simulation Requirements","id":"deterministic-simulation-requirements"},{"level":3,"text":"Collision Response and Resolution","id":"collision-response-and-resolution"},{"level":4,"text":"Impulse-Based Response Calculation","id":"impulse-based-response-calculation"},{"level":4,"text":"Position Correction and Penetration Resolution","id":"position-correction-and-penetration-resolution"},{"level":4,"text":"Friction and Tangential Forces","id":"friction-and-tangential-forces"},{"level":3,"text":"Physics Architecture Decisions","id":"physics-architecture-decisions"},{"level":4,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Resource and Scene Management","id":"resource-and-scene-management"},{"level":3,"text":"Mental Model: Library Check-out System","id":"mental-model-library-check-out-system"},{"level":3,"text":"Asset Loading Pipeline","id":"asset-loading-pipeline"},{"level":4,"text":"File Format Support Strategy","id":"file-format-support-strategy"},{"level":4,"text":"Resource Loading State Machine","id":"resource-loading-state-machine"},{"level":4,"text":"Asynchronous Loading Architecture","id":"asynchronous-loading-architecture"},{"level":4,"text":"GPU Resource Upload Pipeline","id":"gpu-resource-upload-pipeline"},{"level":3,"text":"Resource Cache and Handles","id":"resource-cache-and-handles"},{"level":4,"text":"Handle-Based Resource Access","id":"handle-based-resource-access"},{"level":4,"text":"Reference Counting and Automatic Cleanup","id":"reference-counting-and-automatic-cleanup"},{"level":4,"text":"Cache Implementation Architecture","id":"cache-implementation-architecture"},{"level":4,"text":"Thread Safety and Concurrent Access","id":"thread-safety-and-concurrent-access"},{"level":3,"text":"Scene Serialization and Transitions","id":"scene-serialization-and-transitions"},{"level":4,"text":"Scene Data Format and Structure","id":"scene-data-format-and-structure"},{"level":4,"text":"Entity-Component Serialization","id":"entity-component-serialization"},{"level":4,"text":"Scene Transition Pipeline","id":"scene-transition-pipeline"},{"level":4,"text":"Memory Management During Transitions","id":"memory-management-during-transitions"},{"level":3,"text":"Resource Architecture Decisions","id":"resource-architecture-decisions"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code (Complete)","id":"infrastructure-starter-code-complete"},{"level":4,"text":"Core Logic Skeleton (Learner Implementation)","id":"core-logic-skeleton-learner-implementation"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"System Interactions and Data Flow","id":"system-interactions-and-data-flow"},{"level":3,"text":"Frame Processing Lifecycle","id":"frame-processing-lifecycle"},{"level":4,"text":"Phase 1: Input Processing and Event Handling","id":"phase-1-input-processing-and-event-handling"},{"level":4,"text":"Phase 2: ECS World Update and System Execution","id":"phase-2-ecs-world-update-and-system-execution"},{"level":4,"text":"Phase 3: Physics Simulation with Fixed Timestep","id":"phase-3-physics-simulation-with-fixed-timestep"},{"level":4,"text":"Phase 4: Rendering Pipeline Execution","id":"phase-4-rendering-pipeline-execution"},{"level":4,"text":"Phase 5: Frame Finalization and Timing Control","id":"phase-5-frame-finalization-and-timing-control"},{"level":4,"text":"Frame Lifecycle Error Handling","id":"frame-lifecycle-error-handling"},{"level":3,"text":"Inter-System Communication","id":"inter-system-communication"},{"level":4,"text":"Component-Based State Sharing","id":"component-based-state-sharing"},{"level":4,"text":"Event Queue Architecture","id":"event-queue-architecture"},{"level":4,"text":"Callback and Observer Patterns","id":"callback-and-observer-patterns"},{"level":4,"text":"System Dependency Management","id":"system-dependency-management"},{"level":3,"text":"Resource Loading Dependencies","id":"resource-loading-dependencies"},{"level":4,"text":"Synchronous vs Asynchronous Loading Patterns","id":"synchronous-vs-asynchronous-loading-patterns"},{"level":4,"text":"Handle-Based Resource Access","id":"handle-based-resource-access"},{"level":4,"text":"Cross-System Resource Sharing","id":"cross-system-resource-sharing"},{"level":4,"text":"Resource Loading Error Recovery","id":"resource-loading-error-recovery"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Frame Processing Infrastructure","id":"frame-processing-infrastructure"},{"level":4,"text":"System Coordination Framework","id":"system-coordination-framework"},{"level":4,"text":"Resource Loading Coordination","id":"resource-loading-coordination"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging System Interactions","id":"debugging-system-interactions"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Graphics and Shader Error Recovery","id":"graphics-and-shader-error-recovery"},{"level":4,"text":"OpenGL Context Loss Recovery","id":"opengl-context-loss-recovery"},{"level":4,"text":"Shader Compilation Error Handling","id":"shader-compilation-error-handling"},{"level":4,"text":"Texture Loading Error Recovery","id":"texture-loading-error-recovery"},{"level":3,"text":"Physics Simulation Edge Cases","id":"physics-simulation-edge-cases"},{"level":4,"text":"Tunneling Prevention","id":"tunneling-prevention"},{"level":4,"text":"Collision Jitter Reduction","id":"collision-jitter-reduction"},{"level":4,"text":"Numerical Stability Maintenance","id":"numerical-stability-maintenance"},{"level":3,"text":"Resource Loading Failure Handling","id":"resource-loading-failure-handling"},{"level":4,"text":"Fallback Resource Strategy","id":"fallback-resource-strategy"},{"level":4,"text":"Asynchronous Loading Error Propagation","id":"asynchronous-loading-error-propagation"},{"level":4,"text":"User Notification and Diagnostics","id":"user-notification-and-diagnostics"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Graphics Error Detection Infrastructure","id":"graphics-error-detection-infrastructure"},{"level":4,"text":"Physics Stability Monitoring System","id":"physics-stability-monitoring-system"},{"level":4,"text":"Resource Loading Error Recovery System","id":"resource-loading-error-recovery-system"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Testing Strategy and Milestones","id":"testing-strategy-and-milestones"},{"level":3,"text":"Milestone Verification Checkpoints","id":"milestone-verification-checkpoints"},{"level":4,"text":"Milestone 1: Window &amp; Rendering Foundation Verification","id":"milestone-1-window-amp-rendering-foundation-verification"},{"level":4,"text":"Milestone 2: Entity Component System Verification","id":"milestone-2-entity-component-system-verification"},{"level":4,"text":"Milestone 3: Physics &amp; Collision Verification","id":"milestone-3-physics-amp-collision-verification"},{"level":4,"text":"Milestone 4: Resource &amp; Scene Management Verification","id":"milestone-4-resource-amp-scene-management-verification"},{"level":3,"text":"Component Unit Testing","id":"component-unit-testing"},{"level":4,"text":"ECS Query System Testing","id":"ecs-query-system-testing"},{"level":4,"text":"Collision Detection Testing","id":"collision-detection-testing"},{"level":4,"text":"Resource Loading Testing","id":"resource-loading-testing"},{"level":3,"text":"System Integration Testing","id":"system-integration-testing"},{"level":4,"text":"Frame Processing Pipeline Testing","id":"frame-processing-pipeline-testing"},{"level":4,"text":"Scene Transition Integration Testing","id":"scene-transition-integration-testing"},{"level":4,"text":"Performance Integration Testing","id":"performance-integration-testing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Testing Framework Infrastructure","id":"testing-framework-infrastructure"},{"level":4,"text":"ECS Unit Testing Implementation","id":"ecs-unit-testing-implementation"},{"level":4,"text":"Physics System Testing Implementation","id":"physics-system-testing-implementation"},{"level":4,"text":"Integration Testing Implementation","id":"integration-testing-implementation"},{"level":4,"text":"Milestone Verification Scripts","id":"milestone-verification-scripts"},{"level":4,"text":"Language-Specific Testing Hints","id":"language-specific-testing-hints"},{"level":4,"text":"Debugging Integration Test Failures","id":"debugging-integration-test-failures"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Graphics and Rendering Issues","id":"graphics-and-rendering-issues"},{"level":4,"text":"Mental Model: Film Production Pipeline","id":"mental-model-film-production-pipeline"},{"level":4,"text":"Black Screen Issues","id":"black-screen-issues"},{"level":4,"text":"Texture Loading and Display Problems","id":"texture-loading-and-display-problems"},{"level":4,"text":"Shader Compilation and Linking Errors","id":"shader-compilation-and-linking-errors"},{"level":4,"text":"OpenGL State Management Issues","id":"opengl-state-management-issues"},{"level":3,"text":"Performance and Memory Issues","id":"performance-and-memory-issues"},{"level":4,"text":"Mental Model: Traffic Management System","id":"mental-model-traffic-management-system"},{"level":4,"text":"Frame Rate Drops and Timing Issues","id":"frame-rate-drops-and-timing-issues"},{"level":4,"text":"Memory Leaks and Resource Management","id":"memory-leaks-and-resource-management"},{"level":4,"text":"Inefficient ECS Iteration Patterns","id":"inefficient-ecs-iteration-patterns"},{"level":3,"text":"Physics Simulation Problems","id":"physics-simulation-problems"},{"level":4,"text":"Mental Model: Forensic Investigation","id":"mental-model-forensic-investigation"},{"level":4,"text":"Objects Falling Through Floors (Tunneling)","id":"objects-falling-through-floors-tunneling"},{"level":4,"text":"Jittery Collisions and Resting Contact","id":"jittery-collisions-and-resting-contact"},{"level":4,"text":"Non-Deterministic Physics Behavior","id":"non-deterministic-physics-behavior"},{"level":3,"text":"Debugging Tools and Techniques","id":"debugging-tools-and-techniques"},{"level":4,"text":"Mental Model: Air Traffic Control System","id":"mental-model-air-traffic-control-system"},{"level":4,"text":"Graphics Debugging and Profiling Tools","id":"graphics-debugging-and-profiling-tools"},{"level":4,"text":"Performance Profiling and Bottleneck Analysis","id":"performance-profiling-and-bottleneck-analysis"},{"level":4,"text":"Logging and Event Tracing Systems","id":"logging-and-event-tracing-systems"},{"level":4,"text":"Memory Analysis and Leak Detection","id":"memory-analysis-and-leak-detection"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Module Structure","id":"recommended-module-structure"},{"level":4,"text":"Core Debugging Infrastructure","id":"core-debugging-infrastructure"},{"level":4,"text":"Language-Specific Debugging Hints","id":"language-specific-debugging-hints"},{"level":4,"text":"Milestone Debugging Checkpoints","id":"milestone-debugging-checkpoints"},{"level":4,"text":"Common Debugging Scenarios","id":"common-debugging-scenarios"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Advanced Rendering Features","id":"advanced-rendering-features"},{"level":4,"text":"Dynamic Lighting and Shadow Systems","id":"dynamic-lighting-and-shadow-systems"},{"level":4,"text":"Post-Processing Pipeline","id":"post-processing-pipeline"},{"level":4,"text":"Modern Rendering Techniques","id":"modern-rendering-techniques"},{"level":3,"text":"Engine System Extensions","id":"engine-system-extensions"},{"level":4,"text":"Audio System Integration","id":"audio-system-integration"},{"level":4,"text":"Networking and Multiplayer Support","id":"networking-and-multiplayer-support"},{"level":4,"text":"Scripting System Integration","id":"scripting-system-integration"},{"level":4,"text":"Development Tools and Editor Integration","id":"development-tools-and-editor-integration"},{"level":3,"text":"Performance and Scalability","id":"performance-and-scalability"},{"level":4,"text":"Multi-Threading and Job Systems","id":"multi-threading-and-job-systems"},{"level":4,"text":"GPU Compute Integration","id":"gpu-compute-integration"},{"level":4,"text":"Memory Management Optimization","id":"memory-management-optimization"},{"level":3,"text":"Common Extension Pitfalls","id":"common-extension-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Extension Implementation Order","id":"recommended-extension-implementation-order"},{"level":4,"text":"Advanced Rendering Infrastructure","id":"advanced-rendering-infrastructure"},{"level":4,"text":"ECS-Integrated Audio System","id":"ecs-integrated-audio-system"},{"level":4,"text":"Job System Foundation","id":"job-system-foundation"},{"level":4,"text":"Extension Integration Checkpoints","id":"extension-integration-checkpoints"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: Technical Dictionary with Context","id":"mental-model-technical-dictionary-with-context"},{"level":3,"text":"Core Architecture Terminology","id":"core-architecture-terminology"},{"level":3,"text":"Entity Component System Terminology","id":"entity-component-system-terminology"},{"level":3,"text":"Graphics and Rendering Terminology","id":"graphics-and-rendering-terminology"},{"level":3,"text":"Physics and Collision Terminology","id":"physics-and-collision-terminology"},{"level":3,"text":"Resource and Asset Management Terminology","id":"resource-and-asset-management-terminology"},{"level":3,"text":"Memory Management and Performance Terminology","id":"memory-management-and-performance-terminology"},{"level":3,"text":"Debugging and Development Terminology","id":"debugging-and-development-terminology"},{"level":3,"text":"Advanced Architecture Patterns","id":"advanced-architecture-patterns"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Organization","id":"recommended-file-organization"},{"level":4,"text":"Core Type Definitions","id":"core-type-definitions"},{"level":4,"text":"Terminology Validation System","id":"terminology-validation-system"},{"level":4,"text":"Documentation Generation","id":"documentation-generation"},{"level":4,"text":"Development Workflow Integration","id":"development-workflow-integration"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"}],"title":"Game Engine: Design Document","markdown":"# Game Engine: Design Document\n\n\n## Overview\n\nA modular 2D/3D game engine that manages entity-component systems, graphics rendering, physics simulation, and resource loading through a performance-oriented architecture. The key architectural challenge is designing loosely-coupled systems that can efficiently process thousands of entities per frame while maintaining deterministic behavior.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** All milestones (1-4) — foundational understanding needed throughout the project\n\nGame engines represent one of the most architecturally challenging domains in software engineering. Unlike typical business applications that process user requests, return responses, and wait for the next interaction, game engines must continuously simulate an entire virtual world at 60+ frames per second while managing complex interdependent systems. They sit at the intersection of real-time systems, high-performance computing, and interactive media, creating a unique set of constraints that demand careful architectural consideration.\n\nThe complexity stems not just from individual technical challenges like graphics programming or physics simulation, but from the intricate coordination required between multiple subsystems operating under strict timing constraints. A single frame must process user input, update thousands of game entities, simulate physics interactions, manage resource loading, and render the final image to screen — all within approximately 16.67 milliseconds to maintain 60 FPS. Any architectural decision that introduces inefficiency, unpredictable latency, or tight coupling between systems can cascade into performance problems or maintenance nightmares.\n\nThis section establishes the foundational understanding of why game engines are complex systems, explores the key technical challenges that drive architectural decisions, and examines how different architectural approaches address these challenges with varying trade-offs.\n\n### Mental Model: Digital Theater Production\n\nThink of a game engine as the behind-the-scenes infrastructure for a live theater production that never ends. Just as a theater has a stage manager coordinating lighting technicians, sound engineers, prop masters, and actors to create a seamless performance, a game engine coordinates rendering systems, physics simulation, entity management, and resource loading to create an interactive virtual world.\n\n**The Stage Manager (Main Game Loop)** maintains the show's rhythm, calling cues at precise intervals to ensure everything happens in the right sequence. In theater, this might be \"Lights dim, actor enters stage left, sound effect plays, backdrop changes.\" In a game engine, it's \"Process input, update entities, simulate physics, render frame\" — repeated 60 times per second with clockwork precision.\n\n**The Props Department (Resource Management System)** maintains an inventory of costumes, furniture, and set pieces, ensuring the right props are available when needed and returned to storage when scenes change. Similarly, the game engine's resource system loads textures, models, and audio files on demand, caches them in memory for quick access, and unloads them when transitioning between game levels.\n\n**The Lighting Crew (Rendering System)** manages spotlights, color filters, and projection systems to create the visual atmosphere. They work with standardized equipment (lighting rigs, control boards) and must coordinate with the set design to avoid shadows falling in wrong places. The game engine's renderer manages shaders, textures, and draw calls, working within the constraints of graphics APIs (OpenGL, Vulkan) and coordinating with the entity system to know what objects need to be drawn and where.\n\n**The Sound Engineers (Audio System)** manage microphones, speakers, and mixing boards to create the auditory experience, ensuring dialogue is clear, music sets the mood, and sound effects enhance the action. They must synchronize audio cues with visual events and manage multiple audio channels simultaneously without overwhelming the audience.\n\n**The Choreographer (Physics and Entity Systems)** coordinates the movement and interactions of all actors on stage, ensuring collisions look realistic, movements follow natural laws, and multiple actors can share the stage without accidentally interfering with each other's performances.\n\nThe critical insight from this analogy is that **coordination complexity grows exponentially with the number of systems involved**. A two-person scene requires minimal coordination, but a full-cast musical number with lighting changes, set transitions, and orchestra synchronization demands precise timing and well-defined interfaces between all departments. Similarly, adding new game engine systems creates coordination challenges that must be addressed architecturally.\n\nJust as a theater production needs clear roles, standardized communication protocols (\"Standby cue 47\", \"Go cue 47\"), and contingency plans for when things go wrong, a game engine needs well-defined system boundaries, standardized data interfaces, and robust error handling to maintain smooth operation under the pressure of real-time constraints.\n\n### Core Technical Challenges\n\nGame engines face a unique combination of technical challenges that distinguish them from other software domains. These challenges drive every major architectural decision and create constraints that must be considered when designing each subsystem.\n\n#### Frame-Rate Constraints and Real-Time Deadlines\n\nThe most fundamental challenge is the **frame-time budget**: everything the engine needs to accomplish in a single frame must complete within 16.67 milliseconds (for 60 FPS) or 33.33 milliseconds (for 30 FPS). This creates a hard real-time constraint where missing deadlines results in immediately visible stuttering, frame drops, or input lag that directly impacts the player's experience.\n\nUnlike web servers that can queue requests during traffic spikes or database systems that can delay non-critical operations, game engines cannot defer work to future frames without creating noticeable artifacts. Every frame must process input events, update entity logic, simulate physics, manage resource loading, and render the final image within the time budget.\n\nThis constraint forces architectural decisions around **predictable performance** rather than average-case optimization. A system that usually runs in 2ms but occasionally spikes to 50ms is worse than a system that consistently runs in 8ms, because the spikes cause frame drops. This drives design choices toward:\n\n- **Cache-friendly memory layouts** that ensure predictable memory access patterns\n- **Batch processing** that amortizes setup costs across many operations\n- **Fixed-capacity data structures** that avoid dynamic allocation during frame processing\n- **System execution ordering** that minimizes data dependencies and cache misses\n\n| Performance Requirement | Target Value | Consequences of Missing Target |\n|-------------------------|--------------|------------------------------|\n| Frame Time | 16.67ms (60 FPS) | Visible stuttering, input lag |\n| Input Latency | <20ms total | Unresponsive controls |\n| Memory Allocation | <1MB per frame | Garbage collection pauses |\n| Cache Misses | <5% in hot paths | Unpredictable frame times |\n| Draw Calls | <1000 per frame | GPU bottlenecks |\n\n#### Memory Management and Cache Efficiency\n\nGame engines typically manage thousands of active entities (players, enemies, bullets, particles, UI elements) that must be processed every frame. Traditional object-oriented approaches that scatter related data across the heap create cache miss patterns that make it impossible to process large numbers of entities within frame-time budgets.\n\nConsider a naive approach where each game entity is a separate object with position, velocity, sprite, and health components stored as individual allocations. To update all entities, the system must traverse a linked list or array of pointers, following each pointer to load the entity data from potentially random memory locations. On modern processors, a cache miss costs 200-400 CPU cycles, meaning that processing 1000 entities with poor cache locality could consume the entire frame budget just on memory access.\n\nThis drives game engines toward **data-oriented design** principles that organize data by access patterns rather than conceptual relationships:\n\n- **Struct-of-Arrays (SoA)** organization that stores all position components together, all velocity components together, etc.\n- **Component storage systems** that enable efficient iteration over entities with specific component combinations  \n- **Memory pools and custom allocators** that provide predictable allocation patterns and eliminate fragmentation\n- **Prefetching strategies** that load related data before it's needed\n\nThe Entity-Component-System (ECS) architectural pattern emerged specifically to address these memory access patterns by organizing game data for efficient system processing rather than conceptual object modeling.\n\n| Memory Challenge | Traditional Approach | Game Engine Approach |\n|------------------|---------------------|---------------------|\n| Entity Storage | Objects with embedded components | Components in separate dense arrays |\n| Memory Allocation | Dynamic allocation as needed | Pre-allocated pools with fixed capacity |\n| Data Access | Object.getComponent().getValue() | Direct array indexing |\n| Cache Utilization | Random access pattern | Sequential iteration over component arrays |\n\n#### System Interdependencies and Update Ordering\n\nGame engine systems exhibit complex interdependencies that create coordination challenges. The rendering system needs transform and sprite components updated by the entity system. The physics system needs to read transform components and write back updated positions. The audio system needs to know entity positions for 3D sound spatialization. The resource system needs to load assets requested by rendering and audio systems.\n\nThese dependencies create **update ordering constraints** that must be carefully managed:\n\n1. **Input processing** must complete before entity systems can respond to player actions\n2. **Entity logic updates** must complete before physics simulation to ensure consistent state\n3. **Physics simulation** must complete before rendering to display updated positions\n4. **Resource loading** must coordinate with rendering to avoid displaying partially-loaded assets\n\nThe challenge is that naive sequential execution of systems can create unnecessary latency and underutilize available CPU cores. Modern processors have multiple cores that could theoretically process independent systems in parallel, but the interdependencies create synchronization points that limit parallelization opportunities.\n\nFurthermore, some systems have **circular dependencies** that require careful handling:\n\n- Physics simulation updates entity positions, but entity logic may immediately override those positions based on game rules\n- Rendering needs to know current entity positions, but UI rendering may modify entity states (e.g., health bars affecting game logic)\n- Resource loading triggered by entity spawning may complete during physics simulation, requiring thread-safe coordination\n\n> **Critical Design Insight:** The order of system execution in a game engine is not just a performance optimization — it determines the correctness of the simulation. A physics system that reads stale position data or a rendering system that displays inconsistent entity states can create bugs that are extremely difficult to reproduce and debug.\n\n| System Dependency | Read Data | Write Data | Timing Constraint |\n|-------------------|-----------|------------|-------------------|\n| Input → Entity Logic | Input events | Entity state | Must complete before entity updates |\n| Entity Logic → Physics | Transform, collision bounds | Velocity, forces | Must provide consistent state |\n| Physics → Transform | Velocity, forces | Position, rotation | Must complete before rendering |\n| Transform → Rendering | Position, scale, rotation | Screen coordinates | Must complete before frame present |\n| Entity Logic → Audio | Position, game events | Audio playback requests | Can overlap with other systems |\n\n#### Resource Loading and Streaming\n\nModern games require hundreds of megabytes or gigabytes of assets (textures, models, audio files) that cannot all fit in memory simultaneously. The resource management system must coordinate loading, caching, and unloading of assets while ensuring that systems always have access to the resources they need for rendering or audio playback.\n\nThis creates several architectural challenges:\n\n**Asynchronous Loading Complexity:** Loading assets from disk or network takes much longer than a single frame (often 10-100ms per asset), so resource loading must happen asynchronously while the game continues running. This requires thread-safe coordination between the main game thread and background loading threads, with careful handling of race conditions where a system requests a resource that's currently being loaded.\n\n**Memory Budget Management:** The engine must balance keeping frequently-used assets in memory for fast access against the limited available memory, requiring sophisticated caching policies that consider both access frequency and asset size. Loading new assets when memory is full requires unloading existing assets, but only if they're not currently needed by any active systems.\n\n**Asset Dependency Chains:** Many assets have dependencies on other assets (models reference textures, scenes reference models, etc.), creating loading order constraints that must be resolved without creating deadlocks or loading unnecessary assets.\n\n**Format Conversion and Optimization:** Raw asset files are often stored in formats optimized for creation tools rather than runtime efficiency, requiring conversion to GPU-friendly formats (compressed textures, optimized vertex buffers) that may be expensive to compute.\n\n### Existing Engine Architectures\n\nThe architectural patterns used in game engines have evolved significantly over the past decades, driven by changing hardware capabilities, game complexity requirements, and lessons learned from shipped projects. Understanding the trade-offs between different architectural approaches provides context for the design decisions made in modern game engines.\n\n#### Monolithic Architecture\n\nEarly game engines often used **monolithic architectures** where all functionality was tightly integrated into a single large system with minimal separation between rendering, gameplay logic, physics, and resource management. This approach prioritized simplicity and direct optimization over modularity and maintainability.\n\nIn a monolithic engine, the main game loop directly calls rendering functions, physics update code, and entity management logic without abstraction layers. Entity data might be stored in global arrays, with systems accessing this data directly by index or pointer. Resource loading happens synchronously when assets are needed, blocking the main thread until loading completes.\n\n**Monolithic Architecture Trade-offs:**\n\n| Advantages | Disadvantages |\n|------------|---------------|\n| Simple to understand — all code in one place | Difficult to modify without breaking other systems |\n| No abstraction overhead — direct function calls | Hard to test individual systems in isolation |\n| Easy to optimize cross-system interactions | Code reuse requires copying and modifying |\n| Minimal coordination complexity | Adding new features affects entire codebase |\n| Predictable performance characteristics | Multiple developers cannot work independently |\n\n> **Decision: Why Monolithic Architectures Were Initially Popular**  \n> - **Context**: Early games were developed by small teams (1-5 people) with limited time and hardware constraints that demanded maximum performance  \n> - **Options Considered**: Monolithic vs early modular approaches  \n> - **Decision**: Monolithic architecture for most early engines  \n> - **Rationale**: Small team size eliminated coordination problems, performance requirements exceeded abstraction costs, and game complexity was low enough for single developers to understand entire systems  \n> - **Consequences**: Fast initial development but poor scalability as games became more complex and teams grew larger\n\nMonolithic architectures remain viable for specific contexts: small indie games, game jam projects, or highly specialized engines where the entire system is optimized for one specific type of gameplay. However, they become increasingly problematic as game complexity grows and development teams expand beyond 2-3 programmers.\n\n#### Component-Based Architecture  \n\n**Component-based architectures** emerged as games became more complex and development teams grew larger. This approach models game entities as containers that hold multiple component objects, each responsible for a specific aspect of entity behavior (rendering, physics, gameplay logic, audio).\n\nIn this architecture, an entity like a \"Player\" might contain a `TransformComponent` for position and rotation, a `SpriteComponent` for visual representation, a `PhysicsComponent` for collision detection, and a `HealthComponent` for gameplay state. Systems operate by iterating through entities and processing the components they care about.\n\nThe key insight driving component-based design is **separation of concerns**: rendering logic doesn't need to understand physics simulation, physics systems don't need to know about audio playback, and gameplay logic can focus on game rules without managing graphics resources.\n\n**Component-Based Architecture Implementation Patterns:**\n\n| Pattern | Description | Trade-offs |\n|---------|-------------|------------|\n| Component Inheritance | Base `Component` class with virtual methods | Easy to understand, but virtual call overhead |\n| Component Interfaces | Components implement specific interfaces | More flexible, but requires careful interface design |\n| Message Passing | Components communicate through events/messages | Loose coupling, but harder to debug data flow |\n| Direct Component Access | Systems directly access component data | Best performance, but creates coupling |\n\nHowever, component-based architectures introduced new challenges around **component communication** and **data access patterns**. When the physics system updates an entity's position, how does the rendering system learn about the change? When gameplay logic needs to spawn a particle effect, how does it communicate with the rendering system? Various solutions emerged:\n\n- **Component message systems** where components send events to each other\n- **Entity event broadcasts** where changes to one component trigger notifications to others  \n- **System-to-system communication** where systems coordinate directly rather than through entities\n- **Shared component access** where systems can directly read/write other systems' components\n\n> **Decision: Component-Based vs Monolithic Trade-offs**  \n> - **Context**: Growing game complexity and team sizes made monolithic architectures unmaintainable  \n> - **Options Considered**: Monolithic, component-based with inheritance, component-based with interfaces  \n> - **Decision**: Component-based with interface-driven design  \n> - **Rationale**: Enabled multiple programmers to work on different systems simultaneously, improved testability by isolating system logic, provided better code reuse across different entity types  \n> - **Consequences**: Improved maintainability and team scalability, but introduced performance overhead from virtual calls and complex component communication patterns\n\nThe component-based approach dominated game engine design through the 2000s and early 2010s, forming the foundation for engines like Unity's early architecture and many custom game engines developed during this period.\n\n#### Entity-Component-System (ECS) Architecture\n\n**Entity-Component-System (ECS) architectures** represent the latest evolution in game engine design, driven by the need to process thousands of entities efficiently while maintaining architectural flexibility. ECS separates the three concerns that were conflated in earlier approaches:\n\n- **Entities** are just unique identifiers (typically integers) with no behavior or data  \n- **Components** are pure data structures with no logic or methods\n- **Systems** contain all logic and operate on entities that have specific component combinations\n\nThis separation enables **data-oriented design** principles that optimize for CPU cache efficiency and parallel processing. Instead of storing an entity as an object containing components, ECS stores all components of the same type together in dense arrays. Systems iterate over these component arrays, processing all entities with compatible component sets in cache-friendly sequential order.\n\n**ECS Architecture Principles:**\n\n| Principle | Traditional OOP | ECS Approach |\n|-----------|----------------|--------------|\n| Data Organization | Objects contain related data | Components of same type stored together |\n| Behavior Location | Methods on objects | Systems operate on component data |\n| Entity Representation | Object instance with identity | Integer ID with component associations |\n| System Processing | Object.update() on each entity | Process component arrays in batches |\n| Memory Layout | Random heap allocation | Dense arrays with predictable access patterns |\n\nThe ECS approach excels when games need to process large numbers of similar entities efficiently. A system updating positions of 10,000 moving entities can iterate through a dense array of `PositionComponent` structs, performing the same operation on each one with optimal cache utilization and potential for SIMD vectorization.\n\n**ECS Implementation Variations:**\n\nDifferent ECS implementations make different trade-offs around component storage, query performance, and system execution:\n\n| Implementation Style | Component Storage | Query Performance | Memory Overhead |\n|---------------------|------------------|------------------|-----------------|\n| Archetype-based | Group entities by component signature | Very fast iteration | Higher memory usage |\n| Sparse Set | Hash tables mapping entity→component | Fast random access | Lower memory usage |  \n| Bitset-based | Component presence tracked in bitfields | Medium performance | Lowest overhead |\n| Hybrid | Combines multiple approaches | Balanced performance | Medium overhead |\n\n> **Decision: ECS vs Component-Based Architecture**  \n> - **Context**: Modern games require processing thousands of entities per frame with complex interactions, while maintaining code maintainability for large development teams  \n> - **Options Considered**: Enhanced component-based, ECS with archetype storage, ECS with sparse sets  \n> - **Decision**: ECS with archetype-based storage for this educational engine  \n> - **Rationale**: Archetype storage provides optimal iteration performance for the common case of processing many entities with the same component combination, while still supporting complex queries and dynamic component addition/removal  \n> - **Consequences**: Excellent performance for batch processing, clear separation of data and logic, but requires learning curve for developers familiar with OOP approaches and adds complexity around component relationships\n\nHowever, ECS architectures introduce their own challenges:\n\n**System Dependency Management:** Systems still need to execute in correct order, but the dependencies are now implicit in the component data they read and write. A physics system that writes to `PositionComponent` must execute before a rendering system that reads from `PositionComponent`.\n\n**Component Relationships:** Pure ECS prohibits components from referencing each other directly, but games often need relationships like \"this weapon belongs to this player\" or \"this UI element displays this entity's health.\" Various solutions exist, from entity reference components to separate relationship management systems.\n\n**Query Complexity:** As systems need to operate on more complex combinations of components, the query system becomes a critical performance bottleneck. Finding all entities with components A, B, and C but not component D requires efficient data structures and algorithms.\n\n**Dynamic Component Changes:** Adding or removing components from entities during system execution can invalidate iterators or change archetype assignments, requiring careful handling to avoid crashes or inconsistent state.\n\n#### Architecture Selection Criteria\n\nThe choice between these architectural approaches depends on several factors that vary by project context:\n\n| Factor | Monolithic | Component-Based | ECS |\n|--------|------------|----------------|-----|\n| Team Size | 1-3 developers | 3-10 developers | 5+ developers |\n| Entity Count | <100 active entities | 100-1000 entities | 1000+ entities |\n| Performance Requirements | Platform-specific optimization | Balanced performance/maintainability | Maximum performance |\n| Development Timeline | Short (weeks/months) | Medium (months/year) | Long (year+) |\n| Code Reuse Needs | Minimal | Moderate | High |\n| System Complexity | Simple, well-understood | Medium complexity | Complex, evolving |\n\nFor this educational project, we've chosen an **ECS architecture with archetype-based storage** because:\n\n1. **Learning Value:** ECS represents current best practices in game engine design and exposes learners to data-oriented programming principles\n2. **Performance Characteristics:** The archetype approach provides excellent iteration performance while remaining conceptually understandable  \n3. **Scalability:** The architecture can handle both simple games with dozens of entities and complex simulations with thousands\n4. **Industry Relevance:** Major engines (Unity DOTS, Unreal Engine 5, custom AAA engines) are moving toward ECS-based approaches\n\n> **Key Architectural Insight:** The evolution from monolithic to component-based to ECS architectures reflects the gaming industry's growing understanding that **data access patterns are the primary performance bottleneck in game engines**. Each architectural evolution has optimized data layout and access patterns at the cost of increased conceptual complexity.\n\nThe remainder of this design document will detail how each engine subsystem implements ECS principles while addressing the core technical challenges identified in this section.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Window Management | SDL2 (simple API, good tutorials) | GLFW (lightweight, more control) |\n| Graphics API | OpenGL 3.3+ (mature, well-documented) | Vulkan (modern, explicit control) |\n| Math Library | GLM (C++ header-only) | Custom implementation (learning value) |\n| Build System | CMake (cross-platform, widely used) | Premake5 (Lua-based, cleaner syntax) |\n| Testing Framework | Catch2 (header-only, minimal setup) | Google Test (more features) |\n| Profiling | Built-in timers (simple debugging) | Tracy Profiler (advanced analysis) |\n\n#### Recommended File Structure\n\nStarting with proper organization prevents the \"everything in main.cpp\" problem that plagues many learning projects:\n\n```\ngame-engine/\n├── src/\n│   ├── core/                     ← Core engine systems\n│   │   ├── Application.h/cpp     ← Main application loop\n│   │   ├── Window.h/cpp          ← Platform window abstraction\n│   │   └── Timer.h/cpp           ← Frame timing utilities\n│   ├── ecs/                      ← Entity-Component-System\n│   │   ├── Entity.h              ← Entity ID management\n│   │   ├── Component.h           ← Component base types\n│   │   ├── System.h              ← System base class\n│   │   └── World.h/cpp           ← ECS coordinator\n│   ├── rendering/                ← Graphics pipeline\n│   │   ├── Renderer.h/cpp        ← Main rendering interface\n│   │   ├── Shader.h/cpp          ← Shader compilation\n│   │   ├── Texture.h/cpp         ← Texture loading\n│   │   └── Sprite.h/cpp          ← 2D sprite rendering\n│   ├── physics/                  ← Physics simulation\n│   │   ├── RigidBody.h/cpp       ← Physics bodies\n│   │   ├── Collider.h/cpp        ← Collision detection\n│   │   └── PhysicsWorld.h/cpp    ← Physics simulation\n│   └── resources/                ← Asset management\n│       ├── ResourceManager.h/cpp ← Resource loading/caching\n│       ├── Asset.h               ← Asset base types\n│       └── Handle.h              ← Resource handle system\n├── assets/                       ← Game assets\n│   ├── textures/\n│   ├── shaders/\n│   └── scenes/\n├── tests/                        ← Unit tests\n│   ├── ecs_tests.cpp\n│   ├── physics_tests.cpp\n│   └── rendering_tests.cpp\n└── examples/                     ← Sample games\n    ├── simple_2d/\n    └── physics_demo/\n```\n\n#### Infrastructure Starter Code\n\n**Basic Application Framework** (complete implementation to handle platform details):\n\n```cpp\n// src/core/Application.h\n#pragma once\n#include <memory>\n#include <string>\n\nclass Window;\nclass Renderer;\nclass ECSWorld;\n\nclass Application {\npublic:\n    Application(const std::string& title, int width, int height);\n    virtual ~Application();\n    \n    void Run();\n    \nprotected:\n    virtual void Initialize() {}\n    virtual void Update(float deltaTime) {}\n    virtual void Render() {}\n    virtual void Shutdown() {}\n    \nprivate:\n    std::unique_ptr<Window> m_window;\n    std::unique_ptr<Renderer> m_renderer;\n    std::unique_ptr<ECSWorld> m_world;\n    bool m_running;\n    \n    void InternalInitialize();\n    void ProcessEvents();\n    void InternalShutdown();\n};\n\n// Usage: inherit from Application and override virtual methods\nclass MyGame : public Application {\npublic:\n    MyGame() : Application(\"My Game\", 1280, 720) {}\n    \nprotected:\n    void Initialize() override {\n        // TODO: Create entities, load assets, setup systems\n    }\n    \n    void Update(float deltaTime) override {\n        // TODO: Update game logic, run ECS systems\n    }\n};\n```\n\n**Frame Timing Utilities** (complete implementation):\n\n```cpp\n// src/core/Timer.h\n#pragma once\n#include <chrono>\n\nclass Timer {\npublic:\n    Timer();\n    \n    void Reset();\n    float GetElapsedSeconds() const;\n    float GetElapsedMilliseconds() const;\n    \nprivate:\n    std::chrono::high_resolution_clock::time_point m_startTime;\n};\n\nclass FrameTimer {\npublic:\n    FrameTimer(float targetFPS = 60.0f);\n    \n    void BeginFrame();\n    void EndFrame();\n    \n    float GetDeltaTime() const { return m_deltaTime; }\n    float GetFPS() const { return m_fps; }\n    bool ShouldLimitFrameRate() const;\n    \nprivate:\n    float m_targetFPS;\n    float m_targetFrameTime;\n    float m_deltaTime;\n    float m_fps;\n    Timer m_frameTimer;\n    std::chrono::high_resolution_clock::time_point m_lastFrame;\n};\n```\n\n#### Core Learning Skeleton Code\n\n**ECS World Interface** (learner implements the core ECS logic):\n\n```cpp\n// src/ecs/World.h\n#pragma once\n#include \"Entity.h\"\n#include \"Component.h\"\n#include \"System.h\"\n#include <vector>\n#include <memory>\n#include <typeindex>\n#include <unordered_map>\n\nclass ECSWorld {\npublic:\n    ECSWorld();\n    ~ECSWorld();\n    \n    // Entity management - LEARNER IMPLEMENTS\n    Entity CreateEntity();\n    void DestroyEntity(Entity entity);\n    bool IsEntityValid(Entity entity) const;\n    \n    // Component management - LEARNER IMPLEMENTS  \n    template<typename T, typename... Args>\n    T& AddComponent(Entity entity, Args&&... args) {\n        // TODO 1: Check if entity is valid\n        // TODO 2: Check if component type already exists on entity\n        // TODO 3: Create component in appropriate storage array\n        // TODO 4: Update entity's component signature\n        // TODO 5: Update archetype if using archetype-based storage\n        // TODO 6: Return reference to created component\n    }\n    \n    template<typename T>\n    void RemoveComponent(Entity entity) {\n        // TODO 1: Check if entity has this component type\n        // TODO 2: Remove component from storage array\n        // TODO 3: Update entity's component signature  \n        // TODO 4: Update archetype assignment\n        // TODO 5: Handle component array compaction if needed\n    }\n    \n    template<typename T>\n    T* GetComponent(Entity entity) {\n        // TODO 1: Check if entity has this component type\n        // TODO 2: Find component in storage array\n        // TODO 3: Return pointer to component data\n        // HINT: Return nullptr if component doesn't exist\n    }\n    \n    // System management - LEARNER IMPLEMENTS\n    template<typename T, typename... Args>\n    void RegisterSystem(Args&&... args) {\n        // TODO 1: Create system instance\n        // TODO 2: Store system in execution order\n        // TODO 3: Set up system's component signature\n        // TODO 4: Initialize system with world reference\n    }\n    \n    void UpdateSystems(float deltaTime);\n    \nprivate:\n    // TODO: Define data structures for entity storage\n    // TODO: Define component storage arrays\n    // TODO: Define system execution list\n    // TODO: Define entity-to-archetype mapping\n    // HINT: Consider using std::vector for component arrays\n    // HINT: Consider using std::unordered_map for entity lookups\n};\n```\n\n#### Language-Specific Implementation Hints\n\n**C++ Memory Management:**\n- Use `std::vector` for component storage arrays — they provide cache-friendly dense storage\n- Use `std::unique_ptr` for systems to ensure automatic cleanup  \n- Consider `std::unordered_map<Entity, ComponentMask>` for tracking which components each entity has\n- Use placement new for custom component construction: `new(&storage[index]) ComponentType(args...)`\n\n**Template Metaprogramming:**\n- Use `std::type_index` to get unique identifiers for component types\n- Consider `typeid(T).hash_code()` for component type hashing\n- Use SFINAE or `std::enable_if` to constrain template functions to component types\n\n**Performance Optimization:**\n- Reserve capacity in vectors during initialization: `components.reserve(1000)`\n- Use `emplace_back` instead of `push_back` for in-place construction\n- Consider using `std::array` for fixed-size component signatures\n- Profile with `-O2` optimization to see actual performance characteristics\n\n#### Milestone Checkpoints\n\n**After completing basic ECS framework:**\n\nRun this test to verify entity creation and component management:\n\n```cpp\n// Test entity lifecycle\nECSWorld world;\nEntity entity = world.CreateEntity();\nassert(world.IsEntityValid(entity));\n\n// Test component addition\nauto& transform = world.AddComponent<Transform>(entity, Vector3{0, 0, 0});\nassert(world.GetComponent<Transform>(entity) != nullptr);\n\n// Test component removal  \nworld.RemoveComponent<Transform>(entity);\nassert(world.GetComponent<Transform>(entity) == nullptr);\n\n// Test entity destruction\nworld.DestroyEntity(entity);\nassert(!world.IsEntityValid(entity));\n```\n\n**Expected behavior:**\n- Entity IDs should be unique across creation/destruction cycles\n- Components should be accessible immediately after addition\n- Memory should be released when entities/components are destroyed\n- No crashes or memory leaks during normal operation\n\n**Signs something is wrong:**\n- Segmentation faults during component access → Check bounds and null pointers\n- Memory continuously growing → Missing destructors or cleanup logic\n- Assertion failures → Entity/component state management issues\n- Slow performance → May be using inefficient data structures\n\n**Debugging approach:**\n1. Add logging to entity create/destroy to track ID reuse\n2. Add assertions to component add/remove to verify state consistency  \n3. Use AddressSanitizer (`-fsanitize=address`) to catch memory errors\n4. Profile with simple timer around ECS operations to identify bottlenecks\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** All milestones (1-4) — defines the scope and success criteria for the entire project\n\nBuilding a game engine presents a paradox: the more features you add, the more complex the architecture becomes, yet each new feature seems essential for creating compelling games. This section establishes clear boundaries around what our educational game engine will accomplish, ensuring we build a solid foundation without drowning in scope creep. Think of this as drafting the blueprint for a house — we need to decide whether we're building a cozy cabin or a mansion before we start laying the foundation.\n\nThe challenge in scoping a game engine lies in balancing educational value with practical constraints. A production game engine like Unreal or Unity represents millions of lines of code and decades of engineering effort. Our goal is to distill the core architectural patterns and engineering challenges into a manageable project that teaches the fundamental concepts without overwhelming complexity. We want learners to experience the \"aha moments\" of understanding ECS design, graphics pipeline optimization, and physics simulation without getting lost in the weeds of advanced rendering techniques or platform-specific optimizations.\n\nOur approach follows the principle of \"depth over breadth\" — rather than building a shallow implementation of dozens of features, we'll create a robust, well-architected implementation of the core systems that every game engine needs. This means our renderer might not support advanced lighting models, but it will demonstrate proper resource management, batch rendering, and shader compilation. Our physics system might not handle complex constraints, but it will showcase spatial partitioning, collision detection, and deterministic simulation.\n\n### Functional Requirements\n\nThe core functional requirements define the minimum viable feature set that transforms our codebase from a graphics demo into a legitimate game engine. These requirements are directly tied to the four project milestones and represent the essential capabilities that any 2D or simple 3D game would need.\n\n**Window and Platform Management** forms the foundation layer that connects our engine to the operating system. The engine must create application windows with configurable dimensions, handle window resize events gracefully, and process input from keyboard and mouse devices. This includes managing the application lifecycle — starting up cleanly, running a stable game loop, and shutting down without resource leaks. The platform layer should abstract away operating system differences, allowing the same engine code to run on Windows, macOS, and Linux without modification.\n\n**Graphics Rendering Pipeline** provides the visual output capabilities that bring game worlds to life. The renderer must initialize a modern graphics context (OpenGL 3.3+ or Vulkan), compile and link shader programs from source files, and render textured sprites and 3D meshes to the screen. The system needs to support basic transformations — translation, rotation, and scaling — applied to individual objects. Texture loading should handle common image formats (PNG, JPEG) and upload pixel data to GPU memory efficiently. The rendering architecture should use batch rendering to minimize draw calls, combining multiple objects with the same shader and texture into single GPU commands.\n\n| Rendering Feature | Requirement | Success Criteria |\n|------------------|-------------|-------------------|\n| Window Creation | Configurable resolution and title | Window appears with requested dimensions, processes close events |\n| Graphics Context | OpenGL 3.3+ or Vulkan initialization | Context creation succeeds, basic state management works |\n| Shader System | Vertex and fragment shader compilation | Shaders load from files, compilation errors are reported clearly |\n| Texture Loading | PNG/JPEG image file support | Images load from disk, upload to GPU, render correctly |\n| Sprite Rendering | 2D textured rectangles | Sprites draw at specified positions with rotation and scaling |\n| Mesh Rendering | Basic 3D geometry | Simple meshes (cubes, spheres) render with textures and transforms |\n| Batch Rendering | Multiple objects per draw call | Performance scales well with hundreds of sprites on screen |\n\n**Entity Component System Architecture** enables flexible game object composition and efficient data processing. The ECS must support creating and destroying entities with unique identifiers, adding and removing components dynamically, and executing systems that process entities with specific component combinations. Entity creation should return recyclable IDs to prevent integer overflow in long-running games. Component storage needs to support arbitrary data types while maintaining cache-friendly memory layout. System execution should iterate over entities matching query patterns (e.g., \"all entities with Transform and Sprite components\") without scanning irrelevant data.\n\n**Physics and Collision Detection** brings realistic movement and interaction to game objects. The physics system must implement rigid body dynamics with configurable mass, velocity, and acceleration properties. Collision detection needs to identify overlapping objects using both axis-aligned bounding boxes (AABB) and circle colliders. The broad phase should use spatial partitioning to avoid O(n²) collision checks when many objects are present. Collision response must apply realistic impulse forces and position corrections to separate overlapping bodies. The physics timestep should be fixed and deterministic, ensuring consistent behavior regardless of frame rate variations.\n\n| Physics Feature | Requirement | Success Criteria |\n|----------------|-------------|-------------------|\n| Rigid Bodies | Mass, velocity, acceleration simulation | Objects fall under gravity, respond to forces naturally |\n| AABB Collision | Rectangle-rectangle overlap detection | Fast broad-phase culling of non-overlapping pairs |\n| Circle Collision | Circle-circle intersection tests | Accurate narrow-phase detection with contact points |\n| Spatial Partitioning | Grid or quadtree optimization | Collision performance scales sub-quadratically |\n| Collision Response | Impulse-based separation | Objects bounce and separate realistically after contact |\n| Fixed Timestep | Deterministic simulation step | Physics behaves identically across different frame rates |\n\n**Resource and Scene Management** provides the infrastructure for loading game assets and organizing content. The resource system must load textures, audio files, and data files from disk, returning typed handles that remain valid throughout the asset's lifetime. Resource caching should prevent duplicate loading of the same file and automatically free unused assets when no references remain. Scene management needs to serialize the current game state to files and restore complete scenes from saved data. Scene transitions should cleanly unload previous content and load new assets without memory leaks or dangling references.\n\n> **Design Principle: Modularity and Extensibility**\n> \n> Each functional requirement is designed to be independently testable and replaceable. The rendering system doesn't directly reference physics components, and the ECS doesn't hard-code specific component types. This separation enables iterative development — learners can build and test the renderer before implementing physics, or experiment with different ECS storage strategies without breaking other systems.\n\n### Performance and Quality Requirements\n\nPerformance requirements establish the quantitative benchmarks that distinguish a usable game engine from an academic exercise. These targets reflect the constraints that real games face — maintaining smooth frame rates, managing limited memory, and providing responsive user interaction. The requirements are aggressive enough to force good architectural decisions but achievable with careful implementation.\n\n**Frame Rate and Timing Constraints** define the real-time performance expectations that games demand. The engine must maintain a stable 60 FPS (16.67ms frame time budget) when rendering scenes with up to 1,000 dynamic sprites or 10,000 static sprites on modern hardware (GTX 1060 / RX 580 class graphics cards). Frame time consistency matters more than peak performance — frame times should stay within ±2ms of the target to avoid visible stuttering. The game loop must support both fixed timestep physics simulation and variable timestep rendering, allowing physics to run at 60Hz even if rendering occasionally drops frames.\n\nThe engine should demonstrate graceful performance degradation rather than sudden frame rate cliffs. When scenes exceed the target complexity, frame rates should decrease gradually while maintaining playable performance above 30 FPS. This requires careful profiling and optimization of the most expensive code paths — typically ECS iteration, collision detection, and draw call submission.\n\n| Performance Target | Minimum Requirement | Optimal Target | Measurement Method |\n|--------------------|---------------------|----------------|-------------------|\n| Frame Rate | 30 FPS sustained | 60 FPS sustained | Frame time histogram over 30 seconds |\n| Frame Time Variance | ±5ms from average | ±2ms from average | Standard deviation of frame times |\n| Sprite Capacity | 500 dynamic sprites | 1,000 dynamic sprites | Stress test with moving textured quads |\n| Physics Objects | 100 colliding bodies | 500 colliding bodies | Collision detection benchmark |\n| Memory Usage | <100MB for basic scenes | <50MB for basic scenes | Process memory monitoring |\n| Startup Time | <5 seconds cold start | <2 seconds cold start | Time from launch to first rendered frame |\n\n**Memory Management and Resource Efficiency** ensure the engine runs reliably on systems with limited RAM and prevents resource leaks that accumulate during long gameplay sessions. Total memory usage should remain under 100MB for typical game scenes containing dozens of textures, hundreds of entities, and thousands of components. Memory allocation patterns should minimize garbage collection pressure in managed languages and avoid memory fragmentation in native languages.\n\nThe ECS component storage should demonstrate cache-friendly data layout, achieving measurable performance improvements over naive array-of-structs organization. System iteration benchmarks should show linear scaling with entity count, not quadratic or worse complexity. Resource loading and caching should prevent duplicate allocations — loading the same texture file multiple times should return the same GPU resource handle without consuming additional memory.\n\n**Code Quality and Maintainability Standards** establish the architectural discipline that makes the codebase a good learning resource and enables future extensions. The engine should demonstrate clear separation of concerns between subsystems, with well-defined interfaces that could theoretically be swapped out independently. Error handling must be comprehensive and informative — graphics context failures, file loading errors, and physics simulation edge cases should produce clear diagnostic messages rather than silent failures or crashes.\n\n> **Architecture Decision: Performance vs. Simplicity Trade-offs**\n> - **Context**: Educational engines can prioritize either maximum performance or code clarity\n> - **Options Considered**: \n>   1. Maximum optimization with complex memory management and SIMD intrinsics\n>   2. Moderate optimization focusing on algorithmic efficiency and cache-friendly data layout\n>   3. Simple implementation prioritizing code readability over performance\n> - **Decision**: Moderate optimization approach with clear performance measurement\n> - **Rationale**: Learners need to understand why performance matters and experience the impact of architectural decisions, but shouldn't get lost in low-level optimization techniques that obscure the core concepts\n> - **Consequences**: Performance targets are achievable without heroic optimization efforts, and code remains readable for educational purposes while demonstrating real-world performance considerations\n\nUnit test coverage should reach 80% for critical systems like ECS queries, collision detection algorithms, and resource management. Integration tests should verify end-to-end functionality — creating entities with components, running physics simulation, and rendering the results to screen. Performance regression tests should catch algorithmic complexity increases that might not be obvious during development.\n\n### Scope Exclusions\n\nDefining what the engine will NOT implement is crucial for maintaining focus and preventing scope creep that could derail the educational objectives. These exclusions represent features that, while valuable in production engines, would add significant complexity without proportional learning benefit for the core architectural concepts.\n\n**Advanced Rendering Features** are explicitly out of scope to keep the graphics pipeline understandable and maintainable. The engine will not implement dynamic lighting systems, shadow mapping, post-processing effects, or modern physically-based rendering (PBR) techniques. Particle systems, skeletal animation, and level-of-detail (LOD) management add substantial complexity to the renderer without teaching fundamentally new architectural patterns. The focus remains on demonstrating proper resource management, batch rendering optimization, and shader compilation rather than advanced graphics techniques.\n\n| Excluded Feature | Rationale | Alternative |\n|------------------|-----------|-------------|\n| Dynamic Lighting | Requires complex shader management and scene graph traversal | Basic ambient lighting or pre-lit textures |\n| Shadow Mapping | Involves render-to-texture and multiple rendering passes | Simple sprite layering for depth illusion |\n| Post-Processing | Needs framebuffer management and effect chaining | Direct-to-screen rendering only |\n| Particle Systems | Complex lifecycle management and instanced rendering | Static sprite animation |\n| Skeletal Animation | Bone hierarchies and vertex skinning calculations | Sprite-based animation frames |\n| PBR Materials | Advanced BRDF calculations and HDR pipeline | Simple diffuse textures |\n\n**Audio System Implementation** is deferred to keep the project focused on the core engine architecture patterns. While audio is essential for complete games, implementing 3D positional audio, mixing, and format decoding would require substantial additional infrastructure that doesn't reinforce the ECS, physics, or rendering concepts that form the project's educational core. Learners interested in audio can integrate existing libraries like OpenAL or FMOD after mastering the foundational systems.\n\n**Advanced Physics Features** beyond basic rigid body simulation are excluded to prevent the physics system from overshadowing other components. The engine will not implement joints and constraints, soft-body dynamics, fluid simulation, or advanced collision shapes beyond AABB and circles. These features require sophisticated mathematical techniques and specialized data structures that would expand the physics milestone beyond reasonable scope.\n\n**Networking and Multiplayer Support** represents an entire additional layer of complexity involving client-server architecture, state synchronization, prediction, and rollback systems. While fascinating from an engineering perspective, networking would require extending the ECS with replication systems, implementing deterministic physics, and handling connection management — topics that deserve their own dedicated project.\n\n**Scripting Language Integration** such as embedding Lua, Python, or JavaScript interpreters would add significant complexity around memory management, error handling, and API design. The engine focuses on demonstrating core systems in native code rather than building the abstraction layers needed for safe scripting environments.\n\n**Platform-Specific Optimizations** for mobile devices, consoles, or web deployment are excluded in favor of desktop cross-platform compatibility. Each platform introduces unique constraints around memory management, graphics APIs, and input handling that would fragment the codebase and obscure the core architectural lessons.\n\n**Visual Editing Tools** like scene editors, visual scripting systems, or asset import pipelines represent separate applications built on top of the engine rather than core engine functionality. These tools require GUI frameworks, file format parsers, and undo/redo systems that would expand the project scope dramatically.\n\n> **Key Insight: Scope Boundaries Enable Deep Learning**\n> \n> By aggressively limiting scope, we create space for deep exploration of the included features. A renderer that supports only basic textures and transforms can still demonstrate advanced batching techniques, resource management patterns, and performance optimization strategies. The goal is mastery of fundamental patterns rather than breadth of features.\n\n**Development Tools and Debugging Support** beyond basic logging are excluded to keep the implementation focused. Production engines typically include visual debuggers, performance profilers, memory leak detection, and hot-reload systems for rapid iteration. While valuable, these tools represent significant development overhead that would distract from the core engine architecture lessons.\n\nThe scope exclusions should be viewed as opportunities for future extension rather than permanent limitations. The modular architecture developed through the core milestones should support adding many of these features as subsequent learning projects. A student who masters the ECS pattern can later explore how networking replication components fit into the system. Someone who understands the rendering pipeline can investigate how shadow mapping techniques integrate with the existing shader infrastructure.\n\nThis focused scope ensures that learners spend their time understanding the fundamental patterns that underlie all game engines — component-based architecture, resource lifetime management, performance-oriented data layout, and real-time system coordination — rather than getting lost in the implementation details of advanced features that obscure these core concepts.\n\n### Implementation Guidance\n\nThe implementation approach balances educational clarity with realistic engineering practices, providing complete working infrastructure while leaving the core learning challenges for hands-on development. This section bridges the gap between the design requirements and actual code, giving learners concrete starting points and clear success criteria.\n\n**Technology Recommendations and Trade-offs**\n\n| Component | Simple Option | Advanced Option | Recommendation |\n|-----------|---------------|-----------------|----------------|\n| Window Management | SDL2 (C-style API, wide compatibility) | GLFW (modern C++ API, lightweight) | GLFW for cleaner integration |\n| Graphics API | OpenGL 3.3 (easier debugging, better tooling) | Vulkan (explicit control, modern design) | OpenGL 3.3 for educational clarity |\n| Math Library | GLM (header-only, OpenGL-compatible) | Custom implementation | GLM to focus on engine architecture |\n| Image Loading | stb_image (single-header, simple) | DevIL/SOIL (more formats) | stb_image for minimal dependencies |\n| Build System | CMake (cross-platform, widely supported) | Premake/Bazel (simpler syntax) | CMake for industry relevance |\n| Testing Framework | Catch2 (header-only, readable syntax) | Google Test (more features) | Catch2 for ease of integration |\n\n**Recommended Project Structure**\n\n```cpp\nGameEngine/\n├── CMakeLists.txt              // Build configuration\n├── external/                   // Third-party dependencies\n│   ├── glfw/                  // Window management\n│   ├── glm/                   // Math library\n│   └── stb/                   // Image loading\n├── src/                       // Engine source code\n│   ├── Core/                  // Foundation classes\n│   │   ├── Application.h/cpp  // Main application framework\n│   │   ├── Window.h/cpp       // Platform window abstraction\n│   │   └── Timer.h/cpp        // Frame timing utilities\n│   ├── Rendering/             // Graphics pipeline\n│   │   ├── Renderer.h/cpp     // Main rendering interface\n│   │   ├── Shader.h/cpp       // Shader compilation and management\n│   │   ├── Texture.h/cpp      // Texture loading and binding\n│   │   └── Batch.h/cpp        // Sprite batching system\n│   ├── ECS/                   // Entity-Component-System\n│   │   ├── ECSWorld.h/cpp     // Main ECS coordinator\n│   │   ├── Entity.h/cpp       // Entity ID management\n│   │   ├── Component.h/cpp    // Component storage templates\n│   │   └── System.h/cpp       // System execution framework\n│   ├── Physics/               // Collision and dynamics\n│   │   ├── Rigidbody.h/cpp    // Physics body representation\n│   │   ├── Collision.h/cpp    // Collision detection algorithms\n│   │   └── Spatial.h/cpp      // Spatial partitioning grid\n│   └── Resources/             // Asset management\n│       ├── ResourceManager.h/cpp  // Handle-based resource cache\n│       ├── Scene.h/cpp        // Scene serialization\n│       └── Assets.h/cpp       // Asset type definitions\n├── examples/                  // Demo applications\n│   ├── basic_rendering/       // Milestone 1 example\n│   ├── ecs_demo/             // Milestone 2 example\n│   ├── physics_test/         // Milestone 3 example\n│   └── complete_game/        // Milestone 4 example\n└── tests/                    // Unit and integration tests\n    ├── core_tests/\n    ├── rendering_tests/\n    ├── ecs_tests/\n    └── physics_tests/\n```\n\n**Foundation Infrastructure (Complete Implementations)**\n\nThe following components provide essential infrastructure that supports the main learning objectives without requiring deep implementation effort:\n\n```cpp\n// Timer.h - Frame timing and delta calculation\n#pragma once\n#include <chrono>\n\nclass Timer {\nprivate:\n    std::chrono::high_resolution_clock::time_point m_startTime;\n    std::chrono::high_resolution_clock::time_point m_lastFrame;\n    float m_deltaTime;\n    \npublic:\n    Timer();\n    void Update();           // Call once per frame\n    float GetDeltaTime() const { return m_deltaTime; }\n    float GetElapsedTime() const;\n};\n\nclass FrameTimer {\nprivate:\n    static constexpr float TARGET_FPS = 60.0f;\n    static constexpr float TARGET_FRAME_TIME = 1.0f / TARGET_FPS;\n    \n    float m_frameAccumulator;\n    Timer m_timer;\n    \npublic:\n    FrameTimer() : m_frameAccumulator(0.0f) {}\n    \n    bool ShouldUpdate();     // Returns true when physics should step\n    float GetAlpha() const;  // Interpolation factor for rendering\n    void MarkFrameEnd() { m_timer.Update(); }\n};\n```\n\n```cpp\n// Window.h - Platform abstraction for window management\n#pragma once\n#include <GLFW/glfw3.h>\n#include <string>\n#include <functional>\n\nstruct WindowConfig {\n    int width = 800;\n    int height = 600;\n    std::string title = \"Game Engine\";\n    bool vsync = true;\n    bool fullscreen = false;\n};\n\nclass Window {\nprivate:\n    GLFWwindow* m_window;\n    WindowConfig m_config;\n    \npublic:\n    Window(const WindowConfig& config);\n    ~Window();\n    \n    bool ShouldClose() const;\n    void SwapBuffers();\n    void PollEvents();\n    \n    // Input queries\n    bool IsKeyPressed(int keyCode) const;\n    bool IsMouseButtonPressed(int button) const;\n    std::pair<float, float> GetMousePosition() const;\n    \n    // Window properties\n    int GetWidth() const { return m_config.width; }\n    int GetHeight() const { return m_config.height; }\n    float GetAspectRatio() const;\n};\n```\n\n**Core Learning Skeletons (Headers + TODOs)**\n\nThe main educational components provide detailed skeleton implementations that guide learners through the algorithm steps identified in the design sections:\n\n```cpp\n// ECSWorld.h - Main Entity-Component-System coordinator\n#pragma once\n#include <vector>\n#include <unordered_map>\n#include <typeindex>\n#include <memory>\n\nusing Entity = uint32_t;\nstatic constexpr Entity NULL_ENTITY = 0;\nstatic constexpr uint32_t MAX_ENTITIES = 100000;\n\nclass ECSWorld {\nprivate:\n    std::vector<Entity> m_availableEntities;\n    uint32_t m_nextEntityID;\n    \n    // Component storage - one array per component type\n    std::unordered_map<std::type_index, std::unique_ptr<ComponentArrayBase>> m_componentArrays;\n    \n    // Entity signatures - which components each entity has\n    std::unordered_map<Entity, ComponentSignature> m_entitySignatures;\n    \npublic:\n    ECSWorld();\n    \n    // Entity management\n    Entity CreateEntity();\n    void DestroyEntity(Entity entity);\n    \n    // Component management\n    template<typename T, typename... Args>\n    T& AddComponent(Entity entity, Args&&... args);\n    \n    template<typename T>\n    void RemoveComponent(Entity entity);\n    \n    template<typename T>\n    T* GetComponent(Entity entity);\n    \n    // System queries\n    template<typename... ComponentTypes>\n    std::vector<Entity> GetEntitiesWithComponents();\n    \n    // System execution\n    template<typename SystemType>\n    void RegisterSystem();\n    \n    void UpdateSystems(float deltaTime);\n};\n\n// TODO: Implement Entity CreateEntity()\n// 1. Check if available entities queue has recycled IDs\n// 2. If queue empty, generate new ID from m_nextEntityID counter\n// 3. Verify new ID doesn't exceed MAX_ENTITIES limit\n// 4. Initialize empty component signature for the entity\n// 5. Return the entity ID\n\n// TODO: Implement void DestroyEntity(Entity entity)\n// 1. Verify entity exists in m_entitySignatures map\n// 2. Iterate through all component types in entity's signature\n// 3. Remove entity from each component array it belongs to\n// 4. Clear entity's signature from the signatures map\n// 5. Add entity ID to m_availableEntities queue for recycling\n```\n\n```cpp\n// Collision.h - Physics collision detection pipeline\n#pragma once\n#include <vector>\n#include <glm/glm.hpp>\n\nstruct AABB {\n    glm::vec2 min, max;\n    \n    bool Intersects(const AABB& other) const;\n    glm::vec2 GetCenter() const { return (min + max) * 0.5f; }\n    glm::vec2 GetSize() const { return max - min; }\n};\n\nstruct Circle {\n    glm::vec2 center;\n    float radius;\n    \n    bool Intersects(const Circle& other) const;\n    bool Intersects(const AABB& box) const;\n};\n\nstruct CollisionPair {\n    Entity entityA, entityB;\n    glm::vec2 normal;      // Collision normal pointing from A to B\n    float penetration;     // How far objects are overlapping\n};\n\nclass CollisionDetector {\nprivate:\n    struct SpatialGrid {\n        int cellSize;\n        std::unordered_map<int, std::vector<Entity>> cells;\n    } m_grid;\n    \npublic:\n    CollisionDetector(int gridCellSize = 64);\n    \n    // Broad phase - spatial partitioning\n    void UpdateSpatialGrid(const std::vector<Entity>& entities, ECSWorld& world);\n    std::vector<std::pair<Entity, Entity>> GetPotentialCollisions();\n    \n    // Narrow phase - geometric intersection\n    std::vector<CollisionPair> DetectCollisions(const std::vector<std::pair<Entity, Entity>>& pairs, \n                                               ECSWorld& world);\n    \nprivate:\n    int GetGridKey(int x, int y) const;\n    std::vector<int> GetCellsForAABB(const AABB& bounds) const;\n};\n\n// TODO: Implement UpdateSpatialGrid\n// 1. Clear all existing grid cells\n// 2. For each entity, get its Transform and Collider components\n// 3. Calculate AABB bounds from transform position and collider size\n// 4. Determine which grid cells the AABB overlaps\n// 5. Add entity ID to each overlapping cell's entity list\n\n// TODO: Implement GetPotentialCollisions  \n// 1. Create empty pairs list to return\n// 2. For each non-empty grid cell\n// 3. For each pair of entities within the same cell\n// 4. Ensure we don't duplicate pairs (entityA < entityB)\n// 5. Add unique pairs to the potential collisions list\n```\n\n**Milestone Verification Checkpoints**\n\nEach milestone includes specific verification steps that confirm successful implementation:\n\n**Milestone 1 Checkpoint - Rendering Foundation:**\n```bash\n# Build and run basic rendering example\nmkdir build && cd build\ncmake .. && make\n./examples/basic_rendering\n\n# Expected behavior:\n# - Window opens at 800x600 resolution with title \"Basic Rendering\"\n# - Clear color cycles between red, green, blue every 2 seconds  \n# - Single textured sprite renders at screen center\n# - Sprite rotates smoothly at 45 degrees per second\n# - Frame rate stays above 60 FPS (check console output)\n\n# Common issues and fixes:\n# - Black screen: Check OpenGL context creation, verify shader compilation\n# - Missing texture: Verify image file path, check stb_image linking\n# - Poor performance: Ensure VSync is working, check for redundant state changes\n```\n\n**Milestone 2 Checkpoint - ECS Implementation:**\n```bash\n./examples/ecs_demo\n\n# Expected behavior:\n# - 1000 entities created with Transform + Sprite components\n# - Movement system updates all entity positions each frame\n# - Rendering system draws all entities without frame drops\n# - Console shows \"ECS Update: 1000 entities in <2ms\"\n# - Memory usage stays under 50MB (check Task Manager/Activity Monitor)\n\n# Performance verification:\n# - Run with 10,000 entities - should maintain >30 FPS\n# - Component iteration should scale linearly with entity count\n# - Memory layout should show cache-friendly access patterns in profiler\n```\n\n**Language-Specific Implementation Hints:**\n\nFor C++ implementation, several platform and compiler considerations ensure smooth development:\n\n- Use `std::chrono::high_resolution_clock` for precise frame timing measurements\n- Leverage `std::type_index` for component type identification in template systems  \n- Apply `std::unique_ptr` for automatic memory management of component arrays\n- Utilize `constexpr` for compile-time constants like `MAX_ENTITIES` and `TARGET_FPS`\n- Employ range-based for loops when iterating over entity collections for readability\n\nOpenGL-specific recommendations include using `glGetError()` after each OpenGL call during development to catch state errors early. Shader compilation should check `GL_COMPILE_STATUS` and log the info log on failures. Texture uploads require matching internal format, format, and type parameters to avoid corruption.\n\nPhysics simulation benefits from separating collision detection into distinct broad-phase and narrow-phase algorithms. The broad phase should use integer grid coordinates for efficient spatial hashing. Floating-point collision response calculations should use consistent epsilon values for numerical stability.\n\n**Common Implementation Pitfalls and Solutions:**\n\n| Problem | Symptoms | Root Cause | Solution |\n|---------|----------|-------------|-----------|\n| ECS Iterator Invalidation | Crashes during component iteration | Adding/removing components while iterating | Defer modifications until after iteration completes |\n| OpenGL State Leaks | Textures render incorrectly | Not restoring previous state after rendering | Track and restore GL state or use state objects |\n| Physics Tunneling | Fast objects pass through walls | Large timestep or thin collision geometry | Use swept collision detection or smaller timesteps |\n| Resource Handle Dangling | Crashes when accessing resources | Resource freed while handles still exist | Implement reference counting or weak pointers |\n| Frame Rate Inconsistency | Stuttering during gameplay | Variable timestep affecting game logic | Use fixed timestep for physics, variable for rendering |\n\nThe implementation guidance provides enough structure to prevent common beginner mistakes while preserving the core learning challenges that make game engine development educational and rewarding.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** All milestones (1-4) — architecture decisions and module organization affect every stage of development\n\nCreating a game engine is like designing a **theater production company** that must coordinate multiple specialized departments to deliver a live performance every 16.67 milliseconds. Just as a theater has lighting technicians, stage managers, prop masters, and choreographers who must work in perfect synchronization, a game engine has rendering systems, entity managers, physics simulators, and resource loaders that must coordinate seamlessly within our frame time budget. The key architectural challenge is designing these systems to be loosely coupled yet efficiently coordinated, allowing each to focus on its specialized responsibilities while contributing to the unified goal of delivering smooth, interactive gameplay.\n\nThe architecture we'll build follows **data-oriented design** principles, organizing code around how data flows through systems rather than traditional object-oriented hierarchies. This approach maximizes cache efficiency and enables the performance required for real-time simulation. Our engine will process thousands of entities per frame while maintaining deterministic behavior across different hardware configurations.\n\n![Engine System Architecture](./diagrams/system-architecture.svg)\n\n### Engine Subsystem Overview\n\nOur game engine architecture consists of five major subsystems, each with clearly defined responsibilities and interfaces. Think of these as **specialized departments in a production facility** — each department has specific expertise, tools, and outputs, but they must coordinate their work to deliver the final product.\n\nThe **Application** subsystem serves as the executive coordinator, managing the overall lifecycle and orchestrating communication between other systems. The **Window and Rendering** subsystem acts as the visual presentation layer, transforming game data into pixels on screen. The **ECS World** manages all game entities and their data using data-oriented design. The **Physics** subsystem simulates realistic motion and collision responses. Finally, the **Resource Manager** handles loading, caching, and lifetime management of assets like textures, sounds, and scene data.\n\n| Subsystem | Primary Responsibility | Key Data Structures | External Dependencies |\n|-----------|------------------------|-------------------|---------------------|\n| `Application` | Lifecycle management, system coordination | `WindowConfig`, `FrameTimer` | OS windowing API (SDL2/GLFW) |\n| `Window` & `Renderer` | Graphics output, input processing | `Renderer`, shader programs, vertex buffers | OpenGL/Vulkan, graphics drivers |\n| `ECSWorld` | Entity-component storage, system execution | `Entity` IDs, component arrays, system registry | None (pure data management) |\n| `Physics` | Collision detection, rigid body dynamics | `AABB`, `Circle`, `CollisionPair` | Mathematical libraries for transforms |\n| `Resource Manager` | Asset loading, caching, handle management | Resource handles, reference counters | File I/O, image/audio decoders |\n\nEach subsystem exposes its functionality through well-defined interfaces that hide implementation details. This enables us to swap implementations (for example, changing from OpenGL to Vulkan rendering) without affecting other systems. The interfaces use handle-based access patterns rather than direct pointers, providing memory safety and enabling efficient resource management.\n\n> **Design Principle: Interface Segregation**\n> Each subsystem interface contains only the methods that other systems actually need. For example, the physics system doesn't expose its internal spatial partitioning structure — it only provides collision detection results through the `CollisionPair` interface. This reduces coupling and makes the codebase easier to understand and maintain.\n\n**Application Subsystem Interface:**\n\nThe `Application` class serves as the main engine coordinator, managing initialization, shutdown, and frame processing coordination.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `Initialize` | `WindowConfig` config | `bool` success | Creates window, initializes graphics context and all subsystems |\n| `Run` | none | `int` exit_code | Enters main game loop, processing frames until exit requested |\n| `Shutdown` | none | `void` | Cleanly destroys all subsystems and releases resources |\n| `ShouldClose` | none | `bool` | Checks if application should terminate (window closed, quit requested) |\n| `GetDeltaTime` | none | `float` seconds | Returns frame time for current frame (time since last frame) |\n\n**Window and Renderer Subsystem Interface:**\n\nThe windowing and rendering subsystems work together to manage platform-specific window creation and graphics pipeline execution.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `CreateWindow` | `WindowConfig` config | `Window*` | Creates platform window with specified resolution and title |\n| `PollEvents` | none | `void` | Processes OS input events and updates input state |\n| `SwapBuffers` | none | `void` | Presents rendered frame to screen and swaps front/back buffers |\n| `ClearScreen` | `Color` clear_color | `void` | Clears frame buffer to solid color before rendering |\n| `RenderSprites` | `SpriteRenderData[]` sprites | `void` | Batch renders textured quads with transforms and materials |\n| `RenderMeshes` | `MeshRenderData[]` meshes | `void` | Renders 3D geometry with vertex/index buffers and shaders |\n\n**ECS World Subsystem Interface:**\n\nThe `ECSWorld` provides data-oriented entity management with efficient component storage and system iteration.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `CreateEntity` | none | `Entity` | Allocates unique entity ID with generation counter for recycling |\n| `DestroyEntity` | `Entity` id | `void` | Removes entity and all associated components, recycles ID |\n| `AddComponent<T>` | `Entity` id, `T` data | `T&` reference | Attaches component data to entity, returns reference for modification |\n| `RemoveComponent<T>` | `Entity` id | `bool` success | Removes specific component type from entity if present |\n| `GetComponent<T>` | `Entity` id | `T*` pointer | Returns component pointer or nullptr if entity lacks component |\n| `RegisterSystem<T>` | system constructor args | `void` | Adds system to execution pipeline with specified component requirements |\n| `UpdateSystems` | `float` delta_time | `void` | Executes all registered systems in dependency order |\n\n**Physics Subsystem Interface:**\n\nThe physics system manages rigid body simulation and collision detection using spatial partitioning for performance.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `StepSimulation` | `float` delta_time | `void` | Advances physics simulation by fixed timestep with accumulator |\n| `AddRigidbody` | `Entity` id, `RigidbodyComponent` body | `void` | Registers entity for physics simulation with mass and velocity |\n| `AddCollider` | `Entity` id, `AABB` or `Circle` shape | `void` | Adds collision shape to entity for intersection testing |\n| `GetCollisions` | none | `CollisionPair[]` | Returns all collision pairs detected in current frame |\n| `SetGravity` | `Vector2` gravity | `void` | Sets global gravity vector applied to all rigidbodies |\n| `Raycast` | `Vector2` origin, `Vector2` direction, `float` distance | `Entity` hit | Tests ray intersection against all colliders, returns first hit |\n\n**Resource Manager Subsystem Interface:**\n\nThe resource system provides handle-based asset access with automatic loading, caching, and reference counting.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `LoadTexture` | `string` filepath | `TextureHandle` | Loads image file, uploads to GPU, returns handle for rendering |\n| `LoadMesh` | `string` filepath | `MeshHandle` | Loads 3D model data, uploads vertex/index buffers to GPU |\n| `LoadAudio` | `string` filepath | `AudioHandle` | Loads audio file into memory for playback by audio system |\n| `LoadScene` | `string` filepath | `SceneHandle` | Deserializes scene file containing entity and component data |\n| `GetTexture` | `TextureHandle` handle | `Texture*` | Returns pointer to loaded texture resource or nullptr if invalid |\n| `ReleaseResource` | `ResourceHandle` handle | `void` | Decrements reference count, frees resource when count reaches zero |\n\n> **Critical Design Decision: Handle-Based Resource Access**\n> We use opaque handles instead of direct pointers for resource access. This provides memory safety (handles can be validated), enables efficient reference counting, and allows resources to be relocated in memory without breaking client code. The trade-off is an extra indirection on every resource access, but this cost is minimal compared to the benefits.\n\n### Frame Processing Pipeline\n\nThe frame processing pipeline orchestrates all subsystems to deliver smooth, consistent gameplay at our target frame rate. Think of this as a **factory assembly line** where each station performs specific operations on the data flowing through, and the entire line must complete its work within our 16.67 millisecond frame time budget.\n\n![Frame Processing Pipeline](./diagrams/frame-processing-flow.svg)\n\nThe pipeline follows a strict order to ensure deterministic behavior: input processing captures player actions, ECS systems update game logic, physics simulation resolves collisions and movement, rendering draws the updated scene, and finally frame timing ensures we maintain consistent frame rates. Each phase has access to the results of previous phases but cannot modify data that earlier phases depend on.\n\n> **Design Principle: Frame Determinism**\n> The order of operations within each frame is critical for deterministic behavior. Physics must run after game logic updates (so movement commands take effect) but before rendering (so visual output reflects physics results). This ordering ensures the same sequence of inputs produces identical results across different runs.\n\n**Detailed Frame Processing Steps:**\n\n1. **Frame Timer Update**: The `FrameTimer` calculates elapsed time since the last frame and updates the delta time value that will be passed to all update systems. This measurement must occur first to ensure accurate timing for physics and animation systems.\n\n2. **Input Event Processing**: The `Window` system calls `PollEvents()` to process all OS-generated input events (keyboard, mouse, window events) that accumulated since the last frame. Input state is updated in internal buffers that game systems can query.\n\n3. **ECS System Execution**: The `ECSWorld` calls `UpdateSystems(delta_time)` to execute all registered game logic systems in dependency order. Systems process entities with specific component signatures, updating game state, animations, AI behavior, and other non-physics logic.\n\n4. **Physics Simulation Step**: The physics system calls `StepSimulation(delta_time)` using fixed timestep integration. This updates entity positions based on velocities, performs collision detection using spatial partitioning, and resolves collisions with impulse-based response.\n\n5. **Rendering Pipeline Execution**: The renderer clears the screen, gathers all entities with rendering components (sprites, meshes, transforms), sorts them by depth and material, batches draw calls to minimize state changes, and submits rendering commands to the GPU.\n\n6. **Frame Presentation**: The renderer calls `SwapBuffers()` to present the completed frame to the screen and swap front/back buffers. This synchronizes with the display's refresh rate when vsync is enabled.\n\n7. **Frame Time Regulation**: The `FrameTimer` enforces frame rate limiting by sleeping if the frame completed faster than our target frame time, ensuring consistent frame pacing even when the workload varies.\n\n| Processing Phase | Input Dependencies | Output Results | Max Time Budget |\n|------------------|-------------------|----------------|-----------------|\n| Timer Update | Previous frame timestamp | Current `delta_time` | 0.1ms |\n| Input Processing | OS event queue | Input state buffers | 0.5ms |\n| ECS System Updates | Game state, input, `delta_time` | Updated component data | 8.0ms |\n| Physics Simulation | Rigidbody/collider components | New positions, collision events | 4.0ms |\n| Rendering Pipeline | Transform/sprite/mesh components | GPU command submission | 3.0ms |\n| Frame Presentation | Completed GPU commands | Screen pixel updates | 1.0ms |\n| **Total Frame Budget** | | | **16.67ms (60 FPS)** |\n\nThe time budgets shown above are recommendations based on typical game engine performance characteristics. The largest allocation goes to ECS system updates because this includes all game-specific logic that varies widely between different games. Physics and rendering have more predictable performance characteristics that can be optimized at the engine level.\n\n> **Performance Critical Path**\n> The ECS system update phase typically consumes the most frame time because it includes all game-specific logic. This is why data-oriented design and cache-friendly component iteration are essential — inefficient ECS access patterns can easily cause frame rate drops when processing thousands of entities.\n\n**Inter-System Communication Patterns:**\n\nSystems communicate through three primary mechanisms, each suited to different types of data sharing:\n\n**Shared Component Data**: Systems access the same component arrays through the `ECSWorld` interface. For example, both the movement system and rendering system read `Transform` components, but only the movement system modifies them. This provides efficient data sharing without explicit message passing.\n\n**Event Queues**: Systems post events to shared queues for loosely-coupled communication. Collision events from physics are posted to a queue that gameplay systems can consume to trigger sound effects, particle systems, or damage calculations.\n\n**Resource Handles**: Systems request assets through the resource manager and receive handles that remain valid across frames. The rendering system requests texture handles during entity creation, then uses those handles every frame without re-requesting the resource.\n\n### Recommended Module Organization\n\nOrganizing engine code requires balancing several concerns: logical grouping of related functionality, minimizing compilation dependencies, supporting unit testing, and providing clear interfaces between systems. Our module organization follows **domain-driven design** principles, where each major subsystem lives in its own module with minimal cross-dependencies.\n\nThink of the module structure as **departments in a company** — each department has its own internal organization, tools, and processes, but they communicate through well-defined interfaces rather than reaching into each other's internal systems. This enables teams to work on different subsystems independently and makes the codebase easier to understand and maintain.\n\n```\nGameEngine/\n├── Application/\n│   ├── Application.h                 ← Main engine coordinator interface\n│   ├── Application.cpp               ← Lifecycle management, frame loop\n│   ├── Timer.h                       ← Frame timing utilities\n│   ├── Timer.cpp                     ← Delta time calculation, FPS limiting\n│   └── Config.h                      ← Engine configuration constants\n├── Window/\n│   ├── Window.h                      ← Platform-independent window interface\n│   ├── WindowSDL.cpp                 ← SDL2 implementation\n│   ├── WindowGLFW.cpp                ← GLFW implementation (alternative)\n│   └── Input.h                       ← Input state management\n├── Rendering/\n│   ├── Renderer.h                    ← Main rendering interface\n│   ├── Renderer.cpp                  ← Batch rendering implementation\n│   ├── Shader.h                      ← Shader compilation and management\n│   ├── Shader.cpp                    ← OpenGL/Vulkan shader implementation\n│   ├── Texture.h                     ← Texture resource interface\n│   ├── Texture.cpp                   ← GPU texture upload and management\n│   ├── Mesh.h                        ← 3D mesh data structures\n│   ├── Mesh.cpp                      ← Vertex/index buffer management\n│   └── RenderComponents.h            ← Transform, Sprite, MeshRenderer components\n├── ECS/\n│   ├── ECSWorld.h                    ← Main ECS coordinator interface\n│   ├── ECSWorld.cpp                  ← Entity creation, system registration\n│   ├── Entity.h                      ← Entity ID structure and generation\n│   ├── ComponentStorage.h            ← Dense array storage for components\n│   ├── ComponentStorage.cpp          ← Archetype-based component organization\n│   ├── System.h                      ← Base system interface and query API\n│   └── SystemRegistry.cpp            ← System execution pipeline\n├── Physics/\n│   ├── PhysicsWorld.h                ← Physics simulation coordinator\n│   ├── PhysicsWorld.cpp              ← Fixed timestep integration, collision response\n│   ├── Collision.h                   ← AABB, Circle collision shapes\n│   ├── CollisionDetection.cpp        ← Broad/narrow phase collision detection\n│   ├── SpatialPartitioning.h         ← Grid/quadtree for optimization\n│   ├── SpatialPartitioning.cpp       ← Spatial data structure implementation\n│   └── PhysicsComponents.h           ← Rigidbody, Collider components\n├── Resources/\n│   ├── ResourceManager.h             ← Resource loading and caching interface\n│   ├── ResourceManager.cpp           ← Handle-based access, reference counting\n│   ├── AssetLoaders.h                ← File format loading interfaces\n│   ├── TextureLoader.cpp             ← PNG/JPG image loading\n│   ├── MeshLoader.cpp                ← OBJ/glTF 3D model loading\n│   ├── AudioLoader.cpp               ← WAV/OGG audio file loading\n│   └── SceneSerializer.h             ← Scene save/load functionality\n├── Scenes/\n│   ├── Scene.h                       ← Scene data structure and interface\n│   ├── Scene.cpp                     ← Entity hierarchy management\n│   ├── SceneManager.h                ← Scene transition coordination\n│   └── SceneManager.cpp              ← Loading/unloading, resource cleanup\n├── Core/\n│   ├── Types.h                       ← Engine-wide type definitions\n│   ├── Math.h                        ← Vector2/3, Matrix, utility functions\n│   ├── Memory.h                      ← Custom allocators (optional)\n│   └── Logging.h                     ← Debug logging and error reporting\n└── Examples/\n    ├── BasicSprites/\n    │   └── main.cpp                  ← Simple 2D sprite rendering example\n    ├── PhysicsDemo/\n    │   └── main.cpp                  ← Physics simulation demonstration\n    └── SceneLoading/\n        └── main.cpp                  ← Scene serialization example\n```\n\n**Module Dependency Rules:**\n\nThe dependency graph between modules follows strict layering to prevent circular dependencies and maintain clear separation of concerns.\n\n| Module | Can Depend On | Cannot Depend On | Rationale |\n|--------|---------------|------------------|-----------|\n| `Application` | All other modules | None | Top-level coordinator needs access to all subsystems |\n| `Window` | `Core` only | `ECS`, `Physics`, `Resources` | Platform abstraction should be independent |\n| `Rendering` | `Core`, `Resources`, `ECS` (components only) | `Physics`, `Scenes` | Renderer consumes data but doesn't modify game logic |\n| `ECS` | `Core` only | All other modules | Data management layer must be independent |\n| `Physics` | `Core`, `ECS` (components only) | `Rendering`, `Resources`, `Scenes` | Physics only needs entity data, not presentation |\n| `Resources` | `Core` only | `ECS`, `Physics`, `Rendering` | Asset loading is foundational service |\n| `Scenes` | All modules except `Application` | `Application` | Scenes coordinate subsystems but don't control application |\n| `Core` | Standard library only | All engine modules | Foundation types used by everything |\n\n> **Architecture Decision: Layered Dependencies**\n> - **Context**: Need to prevent circular dependencies while allowing necessary communication between subsystems\n> - **Options Considered**: \n>   1. Allow bidirectional dependencies with careful interface design\n>   2. Strict layering with dependency injection for cross-cutting concerns  \n>   3. Event-based communication with no direct dependencies\n> - **Decision**: Strict layering with component sharing through ECS\n> - **Rationale**: Layered dependencies make the codebase easier to understand and test. The ECS serves as a shared data layer that systems can read from without creating direct dependencies between systems.\n> - **Consequences**: Some communication requires event queues rather than direct calls, but this improves loose coupling and testability.\n\n**Header File Organization Strategy:**\n\nEach module exposes its public interface through a primary header file that includes only the declarations needed by other modules. Implementation details, internal data structures, and private helper functions are kept in separate headers or implementation files.\n\n| File Type | Naming Convention | Contents | Include Strategy |\n|-----------|------------------|----------|------------------|\n| Public Interface | `ModuleName.h` | Class declarations, public methods, public constants | Included by other modules |\n| Component Definitions | `ModuleNameComponents.h` | Component data structures only | Included by ECS and other systems |\n| Internal Implementation | `ModuleNameInternal.h` | Private classes, helper functions, constants | Included only within same module |\n| Implementation Files | `ModuleName.cpp` | Method implementations, static functions | Never included directly |\n\nThis organization supports incremental compilation — changes to implementation files don't require recompiling dependent modules. Only changes to public interface headers trigger widespread recompilation.\n\n**Build System Integration:**\n\nThe module structure maps directly to build system targets, enabling parallel compilation and selective linking for different engine configurations.\n\n```\n# CMakeLists.txt structure\nadd_library(GameEngine_Core STATIC Core/*.cpp)\nadd_library(GameEngine_ECS STATIC ECS/*.cpp)\nadd_library(GameEngine_Physics STATIC Physics/*.cpp)\nadd_library(GameEngine_Rendering STATIC Rendering/*.cpp)\nadd_library(GameEngine_Resources STATIC Resources/*.cpp)\nadd_library(GameEngine_Window STATIC Window/*.cpp)\n\n# Link dependencies based on module hierarchy\ntarget_link_libraries(GameEngine_ECS GameEngine_Core)\ntarget_link_libraries(GameEngine_Physics GameEngine_Core GameEngine_ECS)\ntarget_link_libraries(GameEngine_Rendering GameEngine_Core GameEngine_ECS GameEngine_Resources)\n\n# Main engine library combines all modules\nadd_library(GameEngine STATIC Application/*.cpp)\ntarget_link_libraries(GameEngine \n    GameEngine_Core GameEngine_ECS GameEngine_Physics \n    GameEngine_Rendering GameEngine_Resources GameEngine_Window)\n```\n\nThis build structure enables several advanced scenarios: building physics-only simulations without rendering dependencies, creating headless servers without window management, and developing engine subsystems independently with focused unit tests.\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|----------------|\n| Window Management | SDL2 (cross-platform, simple API) | GLFW (lightweight, more OpenGL-focused) |\n| Graphics API | OpenGL 3.3+ (widely supported, extensive tutorials) | Vulkan (modern, explicit control, better performance) |\n| Mathematics | Custom Vector2/Vector3 structs | GLM library (comprehensive, optimized) |\n| Image Loading | stb_image single-header library | SOIL2 or DevIL (more formats, advanced features) |\n| Audio System | SDL2_mixer (simple, integrated with SDL) | OpenAL (3D audio, more control) |\n| Build System | CMake (cross-platform, widely adopted) | Premake (simpler syntax, Lua-based) |\n| Testing Framework | Simple assert macros for basic testing | Catch2 (comprehensive, modern C++ features) |\n\n**Recommended Project Structure:**\n\n```\nGameEngine/\n├── CMakeLists.txt                    ← Main build configuration\n├── README.md                         ← Project setup instructions\n├── .gitignore                        ← Ignore build artifacts, IDE files\n├── assets/                           ← Example textures, models, scenes\n│   ├── textures/\n│   ├── models/  \n│   └── scenes/\n├── external/                         ← Third-party dependencies\n│   ├── SDL2/                         ← SDL2 headers and libraries\n│   ├── stb/                          ← stb_image.h and related headers\n│   └── glm/                          ← GLM mathematics library\n├── src/                              ← Engine source code (see module structure above)\n│   ├── Core/\n│   ├── Application/\n│   ├── Window/\n│   ├── Rendering/\n│   ├── ECS/\n│   ├── Physics/\n│   ├── Resources/\n│   └── Scenes/\n├── examples/                         ← Example applications using the engine\n│   ├── BasicSprites/\n│   ├── PhysicsDemo/\n│   └── SceneLoading/\n├── tests/                            ← Unit tests for each module\n│   ├── Core/\n│   ├── ECS/\n│   ├── Physics/\n│   └── Resources/\n└── build/                            ← Generated build files (git-ignored)\n    ├── Debug/\n    └── Release/\n```\n\n**Core Infrastructure Starter Code:**\n\n**File: `src/Core/Types.h`** (Complete infrastructure - copy and use)\n```cpp\n#pragma once\n#include <cstdint>\n#include <memory>\n\n// Engine-wide type definitions\nusing Entity = uint32_t;\nstatic constexpr Entity NULL_ENTITY = 0;\nstatic constexpr uint32_t MAX_ENTITIES = 100000;\n\n// Frame timing constants\nstatic constexpr float TARGET_FPS = 60.0f;\nstatic constexpr float TARGET_FRAME_TIME = 1.0f / TARGET_FPS;\n\n// Handle types for resource management\nusing TextureHandle = uint32_t;\nusing MeshHandle = uint32_t;\nusing AudioHandle = uint32_t;\nusing SceneHandle = uint32_t;\n\n// Forward declarations for major subsystems\nclass Application;\nclass Window;\nclass Renderer;\nclass ECSWorld;\nclass PhysicsWorld;\nclass ResourceManager;\nclass SceneManager;\n\n// Configuration structures\nstruct WindowConfig {\n    int width = 1280;\n    int height = 720;\n    const char* title = \"Game Engine\";\n    bool fullscreen = false;\n    bool vsync = true;\n};\n\n// Common result types\nenum class InitResult {\n    Success,\n    WindowCreationFailed,\n    GraphicsContextFailed,\n    AssetLoadingFailed\n};\n```\n\n**File: `src/Core/Math.h`** (Complete infrastructure - copy and use)\n```cpp\n#pragma once\n#include <cmath>\n\nstruct Vector2 {\n    float x = 0.0f;\n    float y = 0.0f;\n    \n    Vector2() = default;\n    Vector2(float x, float y) : x(x), y(y) {}\n    \n    Vector2 operator+(const Vector2& other) const { return {x + other.x, y + other.y}; }\n    Vector2 operator-(const Vector2& other) const { return {x - other.x, y - other.y}; }\n    Vector2 operator*(float scalar) const { return {x * scalar, y * scalar}; }\n    \n    float Length() const { return std::sqrt(x * x + y * y); }\n    Vector2 Normalized() const { \n        float len = Length(); \n        return len > 0 ? Vector2{x/len, y/len} : Vector2{0, 0}; \n    }\n};\n\nstruct Vector3 {\n    float x = 0.0f;\n    float y = 0.0f; \n    float z = 0.0f;\n    \n    Vector3() = default;\n    Vector3(float x, float y, float z) : x(x), y(y), z(z) {}\n    \n    Vector3 operator+(const Vector3& other) const { return {x + other.x, y + other.y, z + other.z}; }\n    Vector3 operator-(const Vector3& other) const { return {x - other.x, y - other.y, z - other.z}; }\n    Vector3 operator*(float scalar) const { return {x * scalar, y * scalar, z * scalar}; }\n    \n    float Length() const { return std::sqrt(x * x + y * y + z * z); }\n};\n\nstruct AABB {\n    Vector2 min;\n    Vector2 max;\n    \n    AABB() = default;\n    AABB(Vector2 min, Vector2 max) : min(min), max(max) {}\n    \n    bool Intersects(const AABB& other) const {\n        return min.x <= other.max.x && max.x >= other.min.x &&\n               min.y <= other.max.y && max.y >= other.min.y;\n    }\n    \n    Vector2 Center() const { return {(min.x + max.x) * 0.5f, (min.y + max.y) * 0.5f}; }\n    Vector2 Size() const { return {max.x - min.x, max.y - min.y}; }\n};\n\nstruct Circle {\n    Vector2 center;\n    float radius = 0.0f;\n    \n    Circle() = default;\n    Circle(Vector2 center, float radius) : center(center), radius(radius) {}\n    \n    bool Intersects(const Circle& other) const {\n        Vector2 diff = center - other.center;\n        float distance_squared = diff.x * diff.x + diff.y * diff.y;\n        float combined_radius = radius + other.radius;\n        return distance_squared <= combined_radius * combined_radius;\n    }\n};\n```\n\n**Application Framework Skeleton** (Core logic for learner to implement):\n\n**File: `src/Application/Application.h`**\n```cpp\n#pragma once\n#include \"../Core/Types.h\"\n#include \"Timer.h\"\n#include <memory>\n\nclass Application {\nprivate:\n    std::unique_ptr<Window> m_window;\n    std::unique_ptr<Renderer> m_renderer;\n    std::unique_ptr<ECSWorld> m_ecs_world;\n    std::unique_ptr<PhysicsWorld> m_physics_world;\n    std::unique_ptr<ResourceManager> m_resource_manager;\n    std::unique_ptr<SceneManager> m_scene_manager;\n    \n    FrameTimer m_frame_timer;\n    bool m_should_close = false;\n\npublic:\n    // Initialize all engine subsystems and create window\n    // Returns InitResult indicating success or specific failure type\n    InitResult Initialize(const WindowConfig& config);\n    \n    // Main game loop - processes frames until ShouldClose() returns true\n    // Returns exit code (0 for success, non-zero for error)\n    int Run();\n    \n    // Clean shutdown of all subsystems and resource cleanup  \n    void Shutdown();\n    \n    // Check if application should terminate (window closed, quit requested)\n    bool ShouldClose() const { return m_should_close; }\n    \n    // Get time elapsed since last frame for time-based calculations\n    float GetDeltaTime() const { return m_frame_timer.GetDeltaTime(); }\n\nprivate:\n    // Process single frame - called by Run() in main loop\n    void ProcessFrame();\n    \n    // TODO: Initialize Window subsystem with SDL2/GLFW\n    // TODO: Create OpenGL/Vulkan graphics context through Window\n    // TODO: Initialize Renderer with graphics context\n    // TODO: Create ECSWorld for entity management  \n    // TODO: Initialize PhysicsWorld with default gravity\n    // TODO: Create ResourceManager for asset loading\n    // TODO: Initialize SceneManager for level management\n    // Hint: Check each initialization for failure and return appropriate InitResult\n    \n    // TODO: Update FrameTimer to calculate new delta_time\n    // TODO: Call Window::PollEvents() to process input\n    // TODO: Call ECSWorld::UpdateSystems(delta_time) for game logic\n    // TODO: Call PhysicsWorld::StepSimulation(delta_time) for physics  \n    // TODO: Call Renderer::RenderFrame() to draw everything\n    // TODO: Call Window::SwapBuffers() to present frame\n    // TODO: Enforce frame rate limiting with FrameTimer\n    // Hint: Each step depends on previous steps completing successfully\n};\n```\n\n**Language-Specific Implementation Hints:**\n\n- **Memory Management**: Use `std::unique_ptr` for subsystem ownership in the `Application` class. This provides automatic cleanup and clear ownership semantics.\n- **Error Handling**: Return enum values like `InitResult` rather than throwing exceptions, since game engines need predictable performance.\n- **Frame Timing**: Use `std::chrono::high_resolution_clock` for precise timing measurements in the `FrameTimer` class.\n- **Platform Abstraction**: Use preprocessor macros to select between SDL2 and GLFW implementations at compile time.\n- **OpenGL Context**: Call `glewInit()` after creating the OpenGL context but before using any OpenGL functions.\n- **Resource Loading**: Use `stb_image.h` for texture loading - it's a single header that handles PNG, JPG, and other common formats.\n\n**Milestone Checkpoints:**\n\nAfter implementing the high-level architecture:\n\n**Checkpoint 1 - Application Initialization:**\n```bash\ncd build && make GameEngine_Application\n./examples/BasicSprites/BasicSprites\n```\nExpected: Window opens with specified resolution and title, clears to solid color, responds to close button.\nIf it fails: Check window creation error messages, verify SDL2 is properly linked, ensure OpenGL context initialization.\n\n**Checkpoint 2 - Subsystem Communication:**\nCreate a simple example that creates entities, adds components, and runs one update system.\nExpected: No crashes, entity IDs are generated correctly, components can be added and retrieved.\nIf it fails: Check ECS initialization order, verify component storage allocation, ensure system registration works.\n\n**Checkpoint 3 - Frame Loop Stability:**\nRun the application for 30+ seconds and monitor frame rate consistency.\nExpected: Stable frame rate near target FPS, consistent delta time values, no memory leaks.\nIf it fails: Profile frame time breakdown, check for memory allocations in hot paths, verify frame timing logic.\n\n\n## Engine Data Model\n\n> **Milestone(s):** All milestones (1-4) — core data structures are established in Milestone 1 and extended throughout the project\n\nThe data model of a game engine is like the **blueprint of a city's infrastructure** — it defines the fundamental types, relationships, and organization patterns that every other system depends upon. Just as a city planner must carefully design how residential, commercial, and industrial zones connect through roads, utilities, and services, a game engine architect must define how entities, components, resources, and systems relate to each other in memory. The data model determines not just what information is stored, but how efficiently it can be accessed, modified, and processed during the intense computational demands of real-time game simulation.\n\nUnlike traditional business applications where data access patterns are relatively predictable, game engines must process thousands of entities every frame within a strict time budget. This creates unique constraints: data must be organized for maximum cache efficiency, memory allocations must be minimized during gameplay, and relationships between game objects must be traversable in microseconds rather than milliseconds. The data model becomes the foundation that either enables or prevents the engine from meeting its performance targets.\n\nThe core challenge lies in balancing three competing forces: **flexibility** (supporting diverse game object types), **performance** (enabling cache-friendly iteration), and **maintainability** (keeping systems decoupled and testable). Traditional object-oriented approaches prioritize flexibility through inheritance hierarchies, but these create cache-unfriendly memory layouts and tight coupling between systems. Modern game engines increasingly adopt data-oriented design principles that organize data by access patterns rather than conceptual relationships.\n\n![ECS Data Model and Relationships](./diagrams/ecs-data-model.svg)\n\n### Entity and Component Types\n\nThink of the entity-component system as a **specialized database for game objects**. Traditional relational databases organize data into tables with fixed schemas, but game entities are more dynamic — one entity might need position and rendering components while another needs position, physics, and audio components. The ECS data model solves this by treating entities as unique identifiers (like primary keys) and components as typed data records that can be attached to any entity. Systems then act like database queries, efficiently iterating over all entities that possess specific combinations of component types.\n\nThe entity identifier design is crucial for both performance and correctness. A naive approach might use simple incrementing integers, but this creates problems when entities are destroyed and their IDs are recycled — dangling references to destroyed entities might accidentally refer to newly created entities. Our design uses a **generation-based approach** that embeds a version counter directly into the entity ID, ensuring that stale references become detectably invalid.\n\n**Entity ID Structure:**\n\n| Field | Type | Bits | Description |\n|-------|------|------|-------------|\n| Index | `uint32_t` | 22 bits | Array index where entity data is stored |\n| Generation | `uint32_t` | 10 bits | Version counter incremented when ID is recycled |\n\nThe entity index points to a slot in the entity metadata array, while the generation counter tracks how many times that slot has been reused. When an entity is destroyed, its generation counter is incremented, making any existing `Entity` handles to that slot immediately invalid. This approach supports up to 4,194,304 concurrent entities (2^22) with 1,024 generations per slot (2^10), which is sufficient for most game scenarios while fitting comfortably in a 32-bit integer.\n\n> **Decision: Generation-Based Entity IDs**\n> - **Context**: Need to detect when entity references become invalid after entity destruction and ID recycling\n> - **Options Considered**: Simple incrementing IDs, UUID-based IDs, generation-embedded IDs\n> - **Decision**: Embed 10-bit generation counter in 32-bit entity ID alongside 22-bit index\n> - **Rationale**: Provides automatic stale reference detection with minimal memory overhead and cache-friendly 32-bit size\n> - **Consequences**: Enables safe entity references across frame boundaries, limits to ~4M concurrent entities, requires bit manipulation for ID packing/unpacking\n\nComponent storage represents the heart of the ECS performance model. Instead of storing components as fields within entity objects (array-of-structs), we organize them into homogeneous arrays where each component type has its own dense storage (struct-of-arrays). This enables systems to iterate over thousands of components with optimal cache utilization, as each memory access brings multiple components of the same type into the cache line.\n\n**Core Component Types:**\n\n| Component | Fields | Purpose |\n|-----------|---------|---------|\n| `Transform` | `position: Vector3`, `rotation: Vector3`, `scale: Vector3` | Spatial positioning in world coordinates |\n| `Sprite` | `texture: TextureHandle`, `size: Vector2`, `color: Vector4` | 2D rendering with texture and tinting |\n| `RigidBody` | `velocity: Vector3`, `acceleration: Vector3`, `mass: float` | Physics motion and dynamics |\n| `Collider` | `shape: ColliderShape`, `bounds: AABB`, `is_trigger: bool` | Collision detection geometry |\n| `Audio` | `clip: AudioHandle`, `volume: float`, `is_playing: bool` | Sound playback control |\n\nThe component storage system uses **dense arrays with indirection** to maintain cache-friendly iteration while supporting dynamic component addition and removal. Each component type maintains its own storage manager that tracks which entities possess that component and provides efficient iteration over all instances.\n\n![ECS Component Storage Organization](./diagrams/component-storage.svg)\n\n**Component Storage Architecture:**\n\n| Layer | Data Structure | Purpose |\n|-------|---------------|---------|\n| Component Arrays | `std::vector<ComponentType>` | Dense storage of component instances |\n| Entity-to-Index Map | `std::unordered_map<Entity, size_t>` | Maps entity ID to component array index |\n| Index-to-Entity Map | `std::vector<Entity>` | Maps component array index back to entity ID |\n| Free List | `std::vector<size_t>` | Tracks available slots from removed components |\n\nWhen a component is added to an entity, it's appended to the component array and the maps are updated to establish the bidirectional relationship. When a component is removed, the last element in the array is moved to fill the gap (maintaining density), and the removed slot is added to the free list for future reuse. This approach ensures that systems always iterate over a contiguous memory region regardless of component removal patterns.\n\n> The critical insight for ECS performance is that **data locality trumps algorithmic complexity** in real-time systems. A simple linear search over a dense array of 10,000 components will outperform a complex data structure with perfect theoretical complexity if that structure causes cache misses.\n\n**System Query Interface:**\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `Query<T>()` | Component type | `ComponentIterator<T>` | Iterate over entities with single component |\n| `Query<T1, T2>()` | Multiple types | `MultiComponentIterator<T1, T2>` | Iterate over entities with all specified components |\n| `QueryEntity<T>(entity)` | Entity ID, type | `T*` | Get component for specific entity or nullptr |\n| `QueryOptional<T>()` | Component type | `OptionalIterator<T>` | Iterate including entities without component |\n\nThe query system provides type-safe iteration over entities that possess specific component combinations. The implementation uses template metaprogramming to generate efficient iteration code at compile time, eliminating the runtime overhead of dynamic type checking or virtual function calls.\n\n### Resource and Asset Types\n\nResource management in a game engine is like a **library checkout system** — assets are expensive to load and store, so they must be shared efficiently between multiple users while tracking who is using what and when resources can be safely freed. Unlike traditional applications where file loading is typically synchronous and memory usage is less constrained, game engines must load large assets without blocking frame processing and carefully manage GPU memory limits.\n\nThe resource system uses **handle-based access** rather than direct pointers to provide memory safety and enable advanced features like hot reloading and reference counting. A handle contains enough information to locate the resource while remaining valid even if the resource is moved in memory or temporarily unloaded.\n\n**Resource Handle Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| ID | `uint32_t` | Unique identifier for this resource |\n| Type | `ResourceType` | Enum indicating resource type (texture, mesh, audio, etc.) |\n| Version | `uint16_t` | Version counter for detecting stale handles |\n| Generation | `uint16_t` | Recycling counter similar to entity IDs |\n\nThe handle design enables the resource manager to detect when client code attempts to access resources that have been unloaded, moved, or are still loading asynchronously. Unlike raw pointers, handles remain safe to store and pass between systems without creating dangling references.\n\n> **Decision: Handle-Based Resource Access**\n> - **Context**: Need safe resource references that survive memory reorganization and support async loading\n> - **Options Considered**: Direct pointers, smart pointers, handle-based indirection\n> - **Decision**: Use 64-bit handles with embedded type and version information\n> - **Rationale**: Provides memory safety, enables hot reloading, supports reference counting, prevents use-after-free bugs\n> - **Consequences**: Requires indirection lookup for resource access, enables advanced resource management features, complicates debugging\n\n**Core Asset Types:**\n\n| Asset Type | Data Structure | GPU Resources | Loading Strategy |\n|------------|---------------|---------------|------------------|\n| `Texture` | `TextureData` with width, height, format, pixels | OpenGL texture object | Asynchronous with fallback |\n| `Mesh` | `MeshData` with vertices, indices, materials | Vertex/index buffer objects | Streaming for large meshes |\n| `Audio` | `AudioClip` with sample rate, channels, samples | Audio buffer (OpenAL/FMOD) | Background loading |\n| `Scene` | `SceneData` with entity definitions | None (CPU data only) | Synchronous on demand |\n\nEach asset type has different loading characteristics and memory requirements. Textures are typically loaded from compressed formats (PNG, JPG) and uploaded to GPU memory as uncompressed pixel arrays. Meshes contain geometric data that must be uploaded to vertex buffer objects for efficient GPU rendering. Audio clips are decompressed and stored in audio system buffers, while scene data remains as CPU-accessible structures for entity instantiation.\n\n**Texture Asset Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `width` | `uint32_t` | Texture width in pixels |\n| `height` | `uint32_t` | Texture height in pixels |\n| `format` | `PixelFormat` | Color format (RGBA8, RGB8, etc.) |\n| `mip_levels` | `uint8_t` | Number of mipmap levels for filtering |\n| `gl_texture_id` | `GLuint` | OpenGL texture object identifier |\n| `data` | `std::vector<uint8_t>` | Raw pixel data (CPU copy) |\n\n**Mesh Asset Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `vertices` | `std::vector<Vertex>` | Vertex position, normal, texture coordinates |\n| `indices` | `std::vector<uint32_t>` | Triangle connectivity information |\n| `material` | `MaterialHandle` | Reference to associated material properties |\n| `bounding_box` | `AABB` | Axis-aligned bounds for culling |\n| `vao` | `GLuint` | OpenGL vertex array object |\n| `vbo` | `GLuint` | OpenGL vertex buffer object |\n| `ebo` | `GLuint` | OpenGL element buffer object |\n\nThe resource loading pipeline supports both synchronous and asynchronous loading strategies depending on asset type and usage context. Critical resources like default textures and fallback assets are loaded synchronously during engine initialization. Optional assets like high-resolution textures or large meshes are loaded asynchronously in background threads to avoid blocking frame processing.\n\n**Resource Loading State Machine:**\n\n| Current State | Event | Next State | Actions |\n|---------------|-------|------------|---------|\n| `Unloaded` | `RequestLoad` | `Loading` | Start async load task |\n| `Loading` | `LoadComplete` | `Loaded` | Update handle mapping, notify waiters |\n| `Loading` | `LoadFailed` | `Error` | Log error, use fallback resource |\n| `Loaded` | `RequestUnload` | `Unloaded` | Free GPU resources, clear CPU data |\n| `Error` | `RequestReload` | `Loading` | Retry loading with exponential backoff |\n\n**Resource Cache Management:**\n\n| Component | Data Structure | Purpose |\n|-----------|---------------|---------|\n| Handle Registry | `std::unordered_map<uint64_t, ResourceEntry>` | Maps handles to resource metadata |\n| Type Registries | `std::unordered_map<std::string, TextureHandle>` | Maps file paths to handles by type |\n| Reference Counters | `std::atomic<uint32_t>` per resource | Tracks active references for cleanup |\n| Loading Queue | `std::queue<LoadRequest>` | Pending asynchronous load operations |\n\nThe cache ensures that multiple requests for the same asset return the same handle, preventing duplicate loading and memory waste. Reference counting automatically unloads resources when they are no longer needed, while the loading queue manages asynchronous operations without blocking the main thread.\n\n### Memory Layout Considerations\n\nMemory organization in game engines is like designing a **factory assembly line** — the layout of materials and workstations determines how efficiently workers can complete their tasks. In CPU terms, the \"workers\" are processing cores, \"materials\" are data in memory, and \"workstations\" are cache levels. Poor memory layout forces the CPU to constantly wait for data to arrive from slow main memory, while optimal layout keeps frequently accessed data in fast cache memory where it can be processed immediately.\n\nThe fundamental choice in memory layout is between **Array-of-Structs (AoS)** and **Struct-of-Arrays (SoA)** organization. Traditional object-oriented programming favors AoS where each entity is a complete object containing all its data. However, game engines benefit from SoA where each component type is stored in a separate homogeneous array.\n\n**Array-of-Structs vs Struct-of-Arrays Comparison:**\n\n| Aspect | Array-of-Structs | Struct-of-Arrays | Chosen for Engine |\n|--------|------------------|------------------|-------------------|\n| Cache Utilization | Poor (loads unused fields) | Excellent (only relevant data) | SoA |\n| System Iteration | 50-80% cache misses | 95%+ cache hits | SoA |\n| Entity Operations | Fast (all data together) | Slower (multiple array accesses) | SoA |\n| Memory Overhead | Higher (padding/alignment) | Lower (no per-entity overhead) | SoA |\n| Code Complexity | Simple (object.field) | Moderate (component_arrays[type][index]) | SoA |\n\n> **Decision: Struct-of-Arrays Component Storage**\n> - **Context**: Need to efficiently iterate over thousands of entities per frame with strict time budgets\n> - **Options Considered**: Array-of-Structs (traditional OOP), Struct-of-Arrays (data-oriented), hybrid approaches\n> - **Decision**: Use pure Struct-of-Arrays with dense component storage\n> - **Rationale**: Systems typically process one component type at a time; SoA provides 3-5x better cache performance for system iteration\n> - **Consequences**: Enables high-performance system updates, complicates entity-centric operations, requires indirection for component access\n\n**Cache-Friendly Data Organization Principles:**\n\n| Principle | Description | Engine Application |\n|-----------|-------------|-------------------|\n| Spatial Locality | Related data stored contiguously | Components of same type in arrays |\n| Temporal Locality | Recently accessed data stays cached | Hot components updated every frame |\n| Prefetch-Friendly | Linear access patterns load next cache lines | System iteration over dense arrays |\n| Alignment | Data aligned to cache line boundaries | Component arrays aligned to 64-byte boundaries |\n| False Sharing Avoidance | Avoid concurrent writes to same cache line | Separate read/write component arrays |\n\nThe engine organizes component data to maximize spatial locality during system processing. When a physics system iterates over `Transform` and `RigidBody` components, it accesses a contiguous array of position data followed by a contiguous array of velocity data. This pattern ensures that each memory access brings relevant data into the cache, minimizing expensive main memory fetches.\n\n**Memory Pool Architecture:**\n\n| Pool Type | Allocation Strategy | Use Case |\n|-----------|-------------------|-----------|\n| Component Pools | Fixed-size chunks, power-of-2 growth | Component arrays that resize during gameplay |\n| Temporary Pools | Linear allocation, frame-based reset | Short-lived allocations during frame processing |\n| Resource Pools | Large block allocation | Texture and mesh data with unpredictable sizes |\n| String Pools | Interned string storage | Asset paths and debug names |\n\nMemory pools reduce allocation overhead and fragmentation by pre-allocating large blocks and suballocating from them using fast, specialized algorithms. Component pools use exponential growth to minimize reallocations, while temporary pools are completely reset each frame to eliminate fragmentation.\n\n**Component Data Layout in Memory:**\n\n```\nCache Line 0:  [Transform 0] [Transform 1] [Transform 2] [Transform 3] ...\nCache Line 1:  [Transform 4] [Transform 5] [Transform 6] [Transform 7] ...\n...\nCache Line N:  [RigidBody 0] [RigidBody 1] [RigidBody 2] [RigidBody 3] ...\n```\n\nThis organization ensures that when a system processes `Transform` components, each cache line load brings multiple consecutive transforms into fast memory. The CPU's hardware prefetcher recognizes the linear access pattern and automatically loads upcoming cache lines, further reducing memory latency.\n\n**Entity Archetype Optimization:**\n\nBeyond basic component storage, advanced ECS implementations use **archetype** organization where entities with identical component signatures are grouped together. This enables even more efficient system iteration by processing homogeneous groups of entities without checking component presence.\n\n| Archetype Example | Components | System Benefit |\n|-------------------|------------|----------------|\n| Static Sprites | `Transform`, `Sprite` | Rendering system processes without physics checks |\n| Dynamic Objects | `Transform`, `Sprite`, `RigidBody` | Physics system updates position and rendering follows |\n| Trigger Zones | `Transform`, `Collider` (trigger) | Collision system handles without physics response |\n| Audio Sources | `Transform`, `Audio` | Audio system updates 3D positioning efficiently |\n\nArchetype organization allows systems to iterate over exactly the entities they care about without wasting cycles on component presence checks or irrelevant data. The trade-off is increased complexity when entities change their component composition, as they must be moved between archetypes.\n\n> The key insight for memory layout optimization is that **predictable access patterns enable hardware acceleration**. Modern CPUs have sophisticated prefetching mechanisms that can hide memory latency, but only if the software accesses memory in patterns the hardware can recognize and predict.\n\n**Common Pitfalls in Memory Organization:**\n\n⚠️ **Pitfall: Mixed Data Types in Component Arrays**\nStoring different component types in the same array destroys cache locality. Each system iteration loads irrelevant data, causing cache pollution and reduced performance. Always maintain separate homogeneous arrays for each component type.\n\n⚠️ **Pitfall: Frequent Component Reallocation**\nGrowing component arrays one element at a time causes excessive memory allocations and potential data copying. Use exponential growth strategies (double capacity when full) to amortize reallocation costs over many insertions.\n\n⚠️ **Pitfall: Ignoring Data Alignment**\nMisaligned data structures force the CPU to perform multiple memory accesses for single values. Ensure component structures are aligned to their natural boundaries (8-byte alignment for doubles, 16-byte alignment for SIMD vectors).\n\n⚠️ **Pitfall: Pointer Chasing in Hot Paths**\nFollowing pointers during system iteration creates unpredictable memory access patterns that defeat CPU prefetching. Store data values directly in component arrays rather than pointers to data elsewhere.\n\n### Implementation Guidance\n\nThe data model implementation requires careful attention to memory management, type safety, and performance characteristics. Modern C++ provides excellent tools for implementing cache-friendly data structures while maintaining memory safety through RAII and smart pointers.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Component Storage | `std::vector` with manual indexing | Custom memory pools with SIMD alignment |\n| Entity IDs | Packed `uint32_t` with bit manipulation | Templated handle system with type safety |\n| Resource Loading | Synchronous `std::ifstream` | Asynchronous thread pool with futures |\n| Memory Allocation | Standard allocators | Custom allocators with pool management |\n\n**Recommended File Structure:**\n```cpp\nengine/\n├── core/\n│   ├── Entity.h              // Entity ID definition and utilities\n│   ├── Component.h           // Base component types and macros\n│   └── Handle.h              // Resource handle template system\n├── ecs/\n│   ├── ComponentArray.h      // Template for type-safe component storage\n│   ├── ComponentManager.h    // Manages all component arrays\n│   └── SystemManager.h       // System registration and execution\n├── resources/\n│   ├── ResourceTypes.h       // Texture, Mesh, Audio data structures\n│   ├── ResourceManager.h     // Handle-based resource loading\n│   └── AssetLoader.h         // File format specific loading\n└── memory/\n    ├── MemoryPool.h          // Custom allocator implementations\n    └── Alignment.h           // SIMD alignment utilities\n```\n\n**Core Entity System Implementation:**\n\n```cpp\n// Entity.h - Complete entity ID system\n#pragma once\n#include <cstdint>\n#include <limits>\n\nclass Entity {\nprivate:\n    static constexpr uint32_t INDEX_BITS = 22;\n    static constexpr uint32_t GENERATION_BITS = 10;\n    static constexpr uint32_t INDEX_MASK = (1u << INDEX_BITS) - 1;\n    static constexpr uint32_t GENERATION_MASK = (1u << GENERATION_BITS) - 1;\n    \n    uint32_t m_id;\n    \npublic:\n    static constexpr Entity NULL_ENTITY{0};\n    static constexpr uint32_t MAX_ENTITIES = 1u << INDEX_BITS;\n    \n    explicit Entity(uint32_t id = 0) : m_id(id) {}\n    \n    Entity(uint32_t index, uint32_t generation) \n        : m_id((generation << INDEX_BITS) | index) {}\n    \n    uint32_t GetIndex() const { return m_id & INDEX_MASK; }\n    uint32_t GetGeneration() const { return (m_id >> INDEX_BITS) & GENERATION_MASK; }\n    uint32_t GetID() const { return m_id; }\n    \n    bool IsValid() const { return m_id != 0; }\n    bool operator==(const Entity& other) const { return m_id == other.m_id; }\n    bool operator!=(const Entity& other) const { return m_id != other.m_id; }\n};\n\n// Hash function for std::unordered_map usage\ntemplate<>\nstruct std::hash<Entity> {\n    size_t operator()(const Entity& entity) const {\n        return std::hash<uint32_t>{}(entity.GetID());\n    }\n};\n```\n\n**Component Array Template (Infrastructure Code):**\n\n```cpp\n// ComponentArray.h - Complete generic component storage\n#pragma once\n#include \"Entity.h\"\n#include <vector>\n#include <unordered_map>\n#include <cassert>\n\ntemplate<typename T>\nclass ComponentArray {\nprivate:\n    std::vector<T> m_components;\n    std::unordered_map<Entity, size_t> m_entityToIndex;\n    std::vector<Entity> m_indexToEntity;\n    std::vector<size_t> m_freeIndices;\n    \npublic:\n    // Add component to entity with perfect forwarding\n    template<typename... Args>\n    T& AddComponent(Entity entity, Args&&... args) {\n        assert(m_entityToIndex.find(entity) == m_entityToIndex.end() && \n               \"Entity already has this component\");\n        \n        size_t index;\n        if (!m_freeIndices.empty()) {\n            index = m_freeIndices.back();\n            m_freeIndices.pop_back();\n            m_components[index] = T(std::forward<Args>(args)...);\n            m_indexToEntity[index] = entity;\n        } else {\n            index = m_components.size();\n            m_components.emplace_back(std::forward<Args>(args)...);\n            m_indexToEntity.push_back(entity);\n        }\n        \n        m_entityToIndex[entity] = index;\n        return m_components[index];\n    }\n    \n    void RemoveComponent(Entity entity) {\n        auto it = m_entityToIndex.find(entity);\n        assert(it != m_entityToIndex.end() && \"Entity doesn't have this component\");\n        \n        size_t removedIndex = it->second;\n        size_t lastIndex = m_components.size() - 1;\n        \n        if (removedIndex != lastIndex) {\n            // Move last element to fill gap\n            m_components[removedIndex] = std::move(m_components[lastIndex]);\n            Entity lastEntity = m_indexToEntity[lastIndex];\n            m_indexToEntity[removedIndex] = lastEntity;\n            m_entityToIndex[lastEntity] = removedIndex;\n        }\n        \n        m_components.pop_back();\n        m_indexToEntity.pop_back();\n        m_entityToIndex.erase(entity);\n    }\n    \n    T* GetComponent(Entity entity) {\n        auto it = m_entityToIndex.find(entity);\n        return it != m_entityToIndex.end() ? &m_components[it->second] : nullptr;\n    }\n    \n    // Iterator support for system processing\n    typename std::vector<T>::iterator begin() { return m_components.begin(); }\n    typename std::vector<T>::iterator end() { return m_components.end(); }\n    typename std::vector<T>::const_iterator begin() const { return m_components.begin(); }\n    typename std::vector<T>::const_iterator end() const { return m_components.end(); }\n    \n    size_t Size() const { return m_components.size(); }\n    bool HasComponent(Entity entity) const {\n        return m_entityToIndex.find(entity) != m_entityToIndex.end();\n    }\n    \n    // Get entity for component at index (for system processing)\n    Entity GetEntity(size_t index) const {\n        assert(index < m_indexToEntity.size());\n        return m_indexToEntity[index];\n    }\n};\n```\n\n**Resource Handle System (Core Logic Skeleton):**\n\n```cpp\n// Handle.h - Resource handle template for type safety\n#pragma once\n#include <cstdint>\n\nenum class ResourceType : uint16_t {\n    Texture = 0,\n    Mesh = 1,\n    Audio = 2,\n    Scene = 3\n};\n\ntemplate<typename T>\nclass Handle {\nprivate:\n    uint64_t m_handle;\n    \n    static constexpr uint64_t TYPE_BITS = 16;\n    static constexpr uint64_t VERSION_BITS = 16;\n    static constexpr uint64_t ID_BITS = 32;\n    \npublic:\n    Handle() : m_handle(0) {}\n    Handle(uint32_t id, uint16_t version, ResourceType type) {\n        // TODO 1: Pack type, version, and id into 64-bit handle\n        // TODO 2: Validate that id fits in ID_BITS\n        // TODO 3: Store packed value in m_handle\n        // Hint: Use bit shifting and OR operations\n    }\n    \n    uint32_t GetID() const {\n        // TODO 1: Extract ID from lower 32 bits of m_handle\n        // TODO 2: Return extracted ID\n        return 0; // Replace with actual implementation\n    }\n    \n    uint16_t GetVersion() const {\n        // TODO 1: Extract version from bits 32-47 of m_handle\n        // TODO 2: Apply appropriate bit mask\n        // TODO 3: Return extracted version\n        return 0; // Replace with actual implementation\n    }\n    \n    ResourceType GetType() const {\n        // TODO 1: Extract type from upper 16 bits of m_handle\n        // TODO 2: Cast to ResourceType enum\n        // TODO 3: Return typed value\n        return ResourceType::Texture; // Replace with actual implementation\n    }\n    \n    bool IsValid() const { return m_handle != 0; }\n    bool operator==(const Handle<T>& other) const { return m_handle == other.m_handle; }\n    bool operator!=(const Handle<T>& other) const { return m_handle != other.m_handle; }\n};\n\n// Type aliases for specific handle types\nusing TextureHandle = Handle<struct TextureTag>;\nusing MeshHandle = Handle<struct MeshTag>;\nusing AudioHandle = Handle<struct AudioTag>;\nusing SceneHandle = Handle<struct SceneTag>;\n```\n\n**Core Component Definitions:**\n\n```cpp\n// Component.h - Standard game components\n#pragma once\n#include \"../math/Vector2.h\"\n#include \"../math/Vector3.h\"\n#include \"../resources/ResourceTypes.h\"\n\nstruct Transform {\n    Vector3 position{0.0f, 0.0f, 0.0f};\n    Vector3 rotation{0.0f, 0.0f, 0.0f};  // Euler angles in radians\n    Vector3 scale{1.0f, 1.0f, 1.0f};\n    \n    // TODO 1: Add GetMatrix() method that builds 4x4 transform matrix\n    // TODO 2: Add SetPosition(), SetRotation(), SetScale() convenience methods\n    // TODO 3: Add Translate(), Rotate(), Scale() relative modification methods\n    // Hint: Use your math library's matrix construction functions\n};\n\nstruct Sprite {\n    TextureHandle texture;\n    Vector2 size{1.0f, 1.0f};\n    Vector4 color{1.0f, 1.0f, 1.0f, 1.0f};  // RGBA tint\n    int layer{0};  // Z-order for sprite sorting\n    \n    // TODO 1: Add constructor that takes texture handle and optional size\n    // TODO 2: Add SetColor() method with RGB and RGBA overloads\n    // TODO 3: Add GetTexCoords() method for sprite sheet support\n};\n\nstruct RigidBody {\n    Vector3 velocity{0.0f, 0.0f, 0.0f};\n    Vector3 acceleration{0.0f, 0.0f, 0.0f};\n    float mass{1.0f};\n    float drag{0.0f};  // Air resistance coefficient\n    bool kinematic{false};  // If true, not affected by forces\n    \n    // TODO 1: Add ApplyForce(Vector3 force) method\n    // TODO 2: Add ApplyImpulse(Vector3 impulse) method\n    // TODO 3: Add SetVelocity() and AddVelocity() methods\n    // TODO 4: Add GetKineticEnergy() calculation method\n};\n```\n\n**Language-Specific Optimization Hints:**\n\n- Use `std::vector::reserve()` for component arrays when you know the approximate entity count\n- Enable compiler optimizations (`-O2` or `-O3`) and consider profile-guided optimization for release builds\n- Use `alignas(64)` on component structures that are processed in tight loops to ensure cache line alignment\n- Consider `std::vector<bool>` specialization for component presence bitmasks, but be aware of its iterator invalidation behavior\n- Use `constexpr` for entity ID bit manipulation functions to ensure compile-time evaluation\n- Profile memory allocations with tools like Valgrind Massif or Visual Studio diagnostic tools\n\n**Milestone Checkpoint - Entity Component System:**\n\nAfter implementing the basic ECS data structures, verify correct behavior:\n\n1. **Entity ID Management Test:**\n   ```bash\n   # Run entity ID tests\n   cd build && ./tests/entity_tests\n   # Expected: All entity IDs unique, generation increments on recycling\n   ```\n\n2. **Component Storage Test:**\n   ```bash\n   # Run component array tests  \n   cd build && ./tests/component_tests\n   # Expected: Components stored densely, iteration performance > 1M entities/ms\n   ```\n\n3. **Manual Verification:**\n   - Create 1000 entities with Transform components\n   - Destroy every other entity\n   - Create 500 new entities - they should reuse destroyed entity IDs with incremented generations\n   - Iterate over all Transform components - should process exactly 1000 components efficiently\n\n**Signs of Implementation Problems:**\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| Crash when accessing components | Entity generation mismatch or invalid index | Validate entity ID before array access |\n| Poor system performance | Array-of-structs instead of struct-of-arrays | Reorganize component storage |\n| Memory leaks during entity destruction | Components not removed from all arrays | Ensure DestroyEntity clears all components |\n| Incorrect entity counts after recycling | Generation counter not incremented | Increment generation on ID recycling |\n\n\n## Rendering System Design\n\n> **Milestone(s):** Milestone 1 (Window & Rendering Foundation) — complete graphics pipeline implementation from window creation through batch rendering\n\nThe rendering system transforms the abstract game world into pixels on the player's screen. This process involves coordinating window management, graphics contexts, shader compilation, and efficient batch rendering to achieve consistent 60 FPS performance. The rendering system serves as the bridge between the game's logical representation and the player's visual experience, making it one of the most critical and complex subsystems in any game engine.\n\n### Mental Model: Art Production Assembly Line\n\nUnderstanding rendering as a factory pipeline that transforms 3D data into 2D pixels provides an intuitive framework for grasping the complexity and organization of graphics systems.\n\nImagine a high-speed art production assembly line in a factory that creates thousands of paintings per second. The raw materials enter the factory as **3D scene data** — entity positions, mesh geometry, texture images, and lighting parameters. These materials flow through multiple specialized stations, each performing a specific transformation operation.\n\nThe **vertex processing station** takes 3D coordinates and transforms them into screen positions, similar to how an artist sketches the basic outline and perspective of objects. Workers at this station apply mathematical transformations (translation, rotation, scaling) and project 3D points onto a 2D canvas, determining where each vertex should appear on the final image.\n\nNext, the **rasterization station** fills in the areas between vertices, converting geometric shapes into individual pixels. This is analogous to artists filling in the outlined shapes with base colors, determining which pixels belong to which objects and calculating coverage percentages for smooth edges.\n\nThe **fragment processing station** applies the final artistic touches — texturing, lighting calculations, and special effects. Workers at this station sample texture images, blend colors, apply shadows, and execute complex shading algorithms to produce the final pixel colors that viewers will see.\n\nFinally, the **framebuffer composition station** assembles all the processed pixels into complete frames, handling transparency, depth testing, and multi-sample anti-aliasing. This station ensures that objects appear in the correct depth order and that overlapping elements blend appropriately.\n\nThe critical insight is that this assembly line operates under extreme time pressure — it must produce complete frames every 16.67 milliseconds to maintain 60 FPS. Any bottleneck or inefficiency in the pipeline causes the entire production line to miss deadlines, resulting in frame drops and stuttering. This time constraint drives every architectural decision in the rendering system, from batch processing strategies to memory layout optimizations.\n\nJust as a real factory optimizes material flow to minimize waste and maximize throughput, the rendering system organizes data and operations to minimize GPU state changes, reduce memory transfers, and maximize parallel processing efficiency. Understanding this assembly line metaphor helps explain why seemingly simple operations like drawing a sprite require careful coordination between multiple subsystems and why performance optimization is central to rendering system design.\n\n### Window and Graphics Context\n\nThe window and graphics context layer provides platform abstraction for creating display surfaces and initializing GPU access. This foundation enables the engine to present rendered content to users while remaining portable across different operating systems and graphics APIs.\n\nWindow management encompasses creating the display window, handling resize events, processing input messages, and managing the application lifecycle. The graphics context provides the bridge between the CPU-based engine code and the GPU hardware, establishing communication channels and resource sharing mechanisms that enable efficient rendering operations.\n\nThe `Window` class encapsulates platform-specific window creation and event handling through a unified interface. On Windows, this involves Win32 API calls to create window classes and message loops. On Linux, it uses X11 or Wayland protocols for window management. macOS requires Cocoa framework integration for proper window handling. The abstraction layer hides these platform differences behind consistent method signatures.\n\n| Component | Responsibility | Key Operations |\n|-----------|---------------|----------------|\n| Window Manager | Platform window creation and lifecycle | Create window, handle resize, process OS events |\n| Input Handler | Mouse, keyboard, and gamepad input processing | Poll events, translate input codes, queue input events |\n| Graphics Context | OpenGL/Vulkan context initialization | Create rendering context, manage GPU state |\n| Swap Chain | Double buffering and frame presentation | Swap front/back buffers, handle v-sync |\n\nThe graphics context initialization process varies significantly between OpenGL and Vulkan. OpenGL context creation requires selecting pixel formats, creating rendering contexts, and loading extension function pointers. The engine must handle context sharing for multi-threaded rendering and context loss scenarios on mobile platforms or when graphics drivers are updated.\n\nVulkan context initialization involves a more explicit process: creating instances, enumerating physical devices, selecting queue families, creating logical devices, and establishing command pools. While more complex, this explicit approach provides better control over GPU resource allocation and enables more predictable performance characteristics.\n\n> **Decision: Graphics API Selection**\n> - **Context**: The engine needs low-level graphics access for 2D/3D rendering with consistent performance across platforms\n> - **Options Considered**: \n>   - OpenGL 4.3+ for simplicity and widespread compatibility\n>   - Vulkan for explicit control and modern GPU features\n>   - DirectX 12 for Windows-specific optimization\n> - **Decision**: OpenGL 4.3+ as the primary API with Vulkan as an advanced option\n> - **Rationale**: OpenGL provides sufficient features for educational purposes with much simpler initialization and debugging. Vulkan can be added later for advanced learners seeking cutting-edge performance\n> - **Consequences**: Simpler implementation and debugging, but potentially less optimal performance on modern hardware\n\n| Graphics API | Pros | Cons | Chosen? |\n|--------------|------|------|---------|\n| OpenGL 4.3+ | Simple state machine, excellent debugging tools, universal compatibility | Implicit state management, driver variance, limited multi-threading | Yes (Primary) |\n| Vulkan | Explicit control, minimal driver overhead, excellent multi-threading | Complex initialization, verbose API, steeper learning curve | Yes (Advanced) |\n| DirectX 12 | Windows optimization, modern features, good tooling | Platform-locked, complex like Vulkan, limited portability | No |\n\nThe window configuration system uses the `WindowConfig` structure to specify window properties during creation. This approach centralizes configuration and enables easy customization for different deployment scenarios.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| title | string | Window title bar text |\n| width | int | Initial window width in pixels |\n| height | int | Initial window height in pixels |\n| fullscreen | bool | Whether to create fullscreen window |\n| resizable | bool | Whether window can be resized by user |\n| vsync | bool | Whether to enable vertical synchronization |\n| samples | int | Multisample anti-aliasing sample count (0, 2, 4, 8) |\n\nThe initialization sequence follows a specific order to ensure proper resource creation and dependency resolution:\n\n1. The window manager creates the OS-specific window using the provided `WindowConfig` parameters\n2. The system queries available pixel formats and selects the best match for the requested configuration\n3. The graphics context is created and bound to the window, establishing the rendering pipeline connection\n4. Extension function pointers are loaded and verified to ensure required OpenGL features are available\n5. Initial OpenGL state is configured, including viewport dimensions, depth testing, and blending modes\n6. The swap chain is configured for double buffering with the requested v-sync settings\n7. Debug output is enabled in development builds to capture graphics API errors and warnings\n\nError handling during initialization must gracefully degrade when requested features are unavailable. If multisample anti-aliasing cannot be enabled at the requested sample count, the system should retry with lower sample counts before falling back to no multisampling. Similarly, if v-sync cannot be enabled, rendering should continue without synchronization rather than failing completely.\n\n> The critical insight for window management is that the graphics context represents expensive GPU state. Creating and destroying contexts frequently causes performance problems, so the engine should maintain long-lived contexts and handle temporary issues like window minimization or graphics driver updates through context preservation rather than recreation.\n\nInput event processing integrates tightly with the window system since OS events arrive through the window message queue. The engine transforms platform-specific input events into normalized engine events, enabling game logic to remain platform-independent. Mouse coordinates are transformed from OS screen space to engine viewport space, and keyboard events are mapped from platform scan codes to engine key identifiers.\n\nThe frame presentation system coordinates between the rendering pipeline and the display hardware. After the GPU completes rendering operations for a frame, the `SwapBuffers` method presents the completed frame to the user and begins rendering the next frame. This double buffering approach prevents visual artifacts by ensuring users never see partially rendered frames.\n\n### Shader Compilation and Management\n\nShader compilation and management transforms high-level shading language code into GPU-executable programs while providing efficient caching and error recovery mechanisms. The shader system serves as the foundation for all visual effects in the engine, from basic sprite rendering to complex 3D material systems.\n\nModern graphics rendering relies entirely on programmable shaders to define how vertices are transformed and how pixels are colored. The shader system must load shader source code from files, compile it into GPU bytecode, link vertex and fragment stages into complete programs, and manage the lifetime of these expensive GPU resources.\n\nThe shader compilation pipeline processes GLSL (OpenGL Shading Language) source code through multiple stages. First, shader source files are loaded from disk and preprocessed to handle include directives and conditional compilation. Then, individual shader stages (vertex, fragment, geometry) are compiled independently. Finally, compiled stages are linked together into complete shader programs that can be executed on the GPU.\n\n| Shader Stage | Input | Output | Primary Responsibility |\n|-------------|-------|--------|----------------------|\n| Vertex | Vertex attributes (position, UV, normal) | Transformed vertices in clip space | Transform 3D positions to screen coordinates |\n| Fragment | Interpolated vertex outputs | Final pixel color (RGBA) | Calculate pixel colors from textures and lighting |\n| Geometry | Primitive vertices | Modified or additional primitives | Generate or modify geometry (optional stage) |\n\nThe `ShaderProgram` class encapsulates the complete shader pipeline from source loading through GPU resource management. Each shader program maintains references to its component stages and provides a unified interface for setting uniform variables and binding texture resources.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| m_programID | uint32_t | OpenGL program object identifier |\n| m_vertexShaderID | uint32_t | Compiled vertex shader object |\n| m_fragmentShaderID | uint32_t | Compiled fragment shader object |\n| m_uniformLocations | unordered_map<string, int> | Cached uniform variable locations |\n| m_attributeLocations | unordered_map<string, int> | Cached vertex attribute locations |\n| m_isLinked | bool | Whether program linking succeeded |\n\nShader compilation error handling requires careful attention since shader compilation can fail for many reasons — syntax errors, incompatible GLSL versions, missing extensions, or hardware limitations. The shader system must capture compilation logs, provide meaningful error messages to developers, and gracefully handle runtime failures.\n\nThe compilation process follows a specific sequence designed to catch errors early and provide detailed diagnostic information:\n\n1. Shader source code is loaded from disk files, with include directive preprocessing and macro expansion\n2. GLSL version headers are validated against the current OpenGL context capabilities \n3. Individual shader stages are compiled, with error logs captured and parsed for meaningful messages\n4. Compiled shaders are linked into a complete program, with additional validation for interface matching\n5. Uniform and attribute locations are queried and cached to avoid expensive runtime lookups\n6. The complete program is validated against current OpenGL state to ensure compatibility\n7. Successful programs are stored in the shader cache with dependency tracking for hot-reloading\n\n> **Decision: Shader Hot-Reloading Support**\n> - **Context**: Artists and developers need rapid iteration on visual effects without engine restarts\n> - **Options Considered**:\n>   - No hot-reloading for simplicity\n>   - File system watching with automatic recompilation\n>   - Manual reload triggers through debug interface\n> - **Decision**: File system watching with automatic recompilation in debug builds\n> - **Rationale**: Hot-reloading dramatically improves developer productivity for visual tweaking, and file watching provides the best user experience\n> - **Consequences**: Additional complexity for file monitoring, but much faster iteration cycles for shader development\n\n| Approach | Pros | Cons | Chosen? |\n|----------|------|------|---------|\n| No Hot-Reloading | Simple implementation, no file dependencies | Slow iteration, requires engine restarts | No |\n| File System Watching | Automatic updates, fast iteration | Complex file monitoring, potential race conditions | Yes |\n| Manual Reload | Simple triggers, controlled timing | Requires developer action, easy to forget | No |\n\nThe uniform variable system provides type-safe interfaces for setting shader parameters from CPU code. Uniforms represent data that remains constant across multiple vertices or fragments within a single draw call — transformation matrices, material properties, lighting parameters, and texture bindings.\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| SetUniform | name string, value Matrix4 | void | Sets 4x4 matrix uniform variable |\n| SetUniform | name string, value Vector3 | void | Sets 3D vector uniform variable |\n| SetUniform | name string, value float | void | Sets scalar float uniform variable |\n| SetUniform | name string, value int | void | Sets integer uniform variable |\n| SetTexture | name string, slot int, handle TextureHandle | void | Binds texture to specified texture unit |\n\nShader caching optimizes compilation performance by storing compiled bytecode and avoiding redundant compilation operations. The cache system tracks shader source file modification times and dependency relationships to invalidate cached programs when source files change.\n\nThe shader cache implementation uses content-based hashing to generate stable cache keys that survive file system changes. When loading a shader program, the system computes hashes of all source files and their dependencies, then checks if a cached compiled version exists with matching hashes. If found, the cached program is loaded directly; otherwise, compilation proceeds normally and the result is cached for future use.\n\n> The key insight for shader management is that compilation is expensive but loading compiled shaders is fast. Modern GPUs can compile complex shaders in milliseconds, but this still represents thousands of CPU cycles. Aggressive caching with proper invalidation provides the best balance between compilation speed and correctness.\n\nError recovery mechanisms handle shader compilation failures gracefully to prevent engine crashes and provide meaningful feedback to developers. When shader compilation fails, the system should:\n\n1. Log detailed error information including line numbers and specific syntax issues\n2. Fall back to a simple \"error shader\" that renders objects in a bright error color\n3. Continue monitoring the source file for changes to retry compilation automatically\n4. Preserve the previous working version of the shader if available\n5. Display error overlays in debug builds to make compilation issues immediately visible\n\nThe shader preprocessing system enables code reuse and conditional compilation through include directives and macro definitions. Common vertex transformation functions, lighting calculations, and utility functions can be shared across multiple shader programs through include files.\n\nPreprocessing handles:\n- `#include \"filename.glsl\"` directives for code inclusion with circular dependency detection\n- `#define MACRO_NAME value` definitions for conditional compilation and constants\n- `#ifdef` / `#ifndef` / `#endif` blocks for platform-specific code paths\n- Automatic injection of engine-specific defines (OPENGL_VERSION, PLATFORM_WINDOWS, etc.)\n\n### Batch Rendering Architecture\n\nBatch rendering architecture optimizes GPU utilization by minimizing draw calls and state changes while maximizing data throughput for sprite and mesh rendering operations. This system transforms individual render requests into efficient GPU command streams that can process thousands of objects per frame within the 16.67ms frame budget.\n\nThe fundamental challenge in rendering performance is that individual draw calls carry significant CPU and GPU overhead. Each draw call requires state validation, driver command translation, and GPU pipeline setup. With thousands of sprites or meshes to render per frame, naive approaches that issue one draw call per object quickly become CPU-bound and fail to utilize the GPU's parallel processing capabilities effectively.\n\nBatch rendering solves this problem by collecting geometrically similar objects into shared vertex buffers, then issuing single draw calls that render hundreds or thousands of objects simultaneously. This approach reduces draw call counts from thousands to dozens while enabling the GPU to process vertex data in large parallel batches.\n\nThe batching system organizes rendering operations by **material compatibility** and **depth ordering**. Objects that share the same shader program, texture bindings, and blend state can be batched together. However, proper depth ordering requires breaking batches when objects at different depths would be rendered incorrectly if combined.\n\n| Batch Type | Geometry | Material Requirements | Typical Use Cases |\n|------------|----------|----------------------|-------------------|\n| Sprite Batch | Textured quads | Same texture, same blend mode | UI elements, 2D game objects, particle effects |\n| Mesh Batch | Arbitrary geometry | Same shader, compatible uniforms | 3D models with shared materials |\n| Text Batch | Glyph quads | Same font texture, same color | UI text, debug overlays, HUD elements |\n| Line Batch | Line segments | Same line width, same color | Debug visualization, wireframes |\n\nThe sprite batching system represents the most common use case for 2D games and UI rendering. Sprites are rendered as textured quads (two triangles forming a rectangle) with transformation matrices applied in the vertex shader. The batch system collects sprite data into large vertex buffers, sorts by depth and material, then renders entire batches with single draw calls.\n\nSprite vertex data includes position, texture coordinates, color tint, and transformation information. To maximize GPU efficiency, this data is organized using **struct-of-arrays** layout rather than **array-of-structs**, enabling efficient SIMD processing and reducing memory bandwidth requirements.\n\n| Attribute | Type | Components | Description |\n|-----------|------|------------|-------------|\n| Position | Vector2 | x, y | Local quad vertex position (-0.5 to 0.5) |\n| TexCoords | Vector2 | u, v | Texture coordinate for this vertex |\n| Color | Vector4 | r, g, b, a | Color tint and transparency |\n| Transform | Matrix4 | 16 floats | World transformation matrix |\n| TextureID | int | 1 int | Texture array index for batched textures |\n\nThe batching algorithm processes sprites in multiple phases to ensure correct rendering order while maximizing batch sizes:\n\n1. **Collection Phase**: Gather all sprite render requests for the current frame, including transformation, texture, and material data\n2. **Sorting Phase**: Sort sprites by depth (back-to-front for transparency, front-to-back for opaque objects) and then by material compatibility\n3. **Batching Phase**: Group consecutive sprites with compatible materials into batches, breaking when material changes or batch size limits are reached\n4. **Upload Phase**: Transfer vertex data for all batches to GPU vertex buffers using efficient memory mapping or buffer streaming\n5. **Rendering Phase**: Issue draw calls for each batch with appropriate material state binding and uniform variable updates\n\n> **Decision: Batch Size Limitations**\n> - **Context**: GPU hardware has limits on vertex buffer sizes and draw call complexity\n> - **Options Considered**:\n>   - Fixed batch sizes (1000 sprites per batch)\n>   - Dynamic sizing based on available GPU memory\n>   - Adaptive sizing based on frame performance\n> - **Decision**: Fixed batch size of 1000 sprites with dynamic rebatching for large scenes\n> - **Rationale**: Fixed sizes provide predictable performance and memory usage, while 1000 sprites fits well within GPU vertex processing capabilities\n> - **Consequences**: Simple implementation and consistent performance, but may be suboptimal for very large or very small sprite counts\n\n| Approach | Pros | Cons | Chosen? |\n|----------|------|------|---------|\n| Fixed Batch Sizes | Predictable memory usage, simple implementation | May be inefficient for varying scene complexity | Yes |\n| Dynamic Sizing | Adapts to scene complexity and available memory | Complex memory management, unpredictable performance | No |\n| Adaptive Sizing | Optimizes for current performance conditions | Requires performance monitoring, potential instability | No |\n\nThe mesh batching system extends batching concepts to arbitrary 3D geometry while handling the additional complexity of varied vertex layouts and material properties. Unlike sprites, which share identical geometry, meshes have unique vertex counts, attribute layouts, and transformation requirements.\n\nMesh batching uses **instanced rendering** to draw multiple copies of the same mesh with different transformation matrices. This approach works well for scenarios like rendering forests (many tree meshes), crowds (character meshes), or debris (rock meshes). Each instance provides a unique transformation matrix while sharing the base mesh geometry.\n\nThe batch rendering pipeline integrates with the Entity Component System to efficiently process renderable entities. Systems query for entities with both `Transform` and `Sprite` or `MeshRenderer` components, then submit render requests to the appropriate batching system.\n\n| Component | Field | Type | Description |\n|-----------|-------|------|-------------|\n| Sprite | texture | TextureHandle | Texture resource for sprite rendering |\n| | size | Vector2 | Sprite dimensions in world units |\n| | color | Vector4 | Color tint and alpha transparency |\n| | layer | int | Depth sorting layer for batch ordering |\n| MeshRenderer | mesh | MeshHandle | Mesh geometry resource |\n| | material | MaterialHandle | Shader and texture binding information |\n| | castShadows | bool | Whether this mesh participates in shadow mapping |\n\nThe rendering system processes batches in strict depth order to ensure correct transparency and depth testing behavior. Opaque objects are rendered front-to-back to maximize early depth rejection and reduce fragment processing load. Transparent objects are rendered back-to-front to ensure proper alpha blending.\n\nTexture atlasing optimizes batch coherence by combining multiple small textures into larger texture arrays or atlas images. This technique enables sprites with different source textures to be batched together by using texture coordinates and array indices to select the appropriate sub-image.\n\nThe atlas system automatically packs sprite textures into larger atlas textures during asset loading, updating texture coordinates to reference the packed locations. At runtime, the batching system can group sprites from the same atlas regardless of their original texture sources, significantly improving batch sizes and reducing texture binding overhead.\n\n> The crucial insight for batch rendering is that modern GPUs excel at processing large amounts of similar data in parallel, but struggle with frequent state changes and small draw calls. The batching system transforms the rendering workload from \"thousands of tiny tasks\" to \"dozens of large tasks,\" matching the GPU's architectural strengths.\n\nBuffer management for batch rendering uses dynamic vertex buffers that are updated each frame with current batch data. The system employs multiple buffer strategies depending on the rendering load:\n\n- **Stream buffers** for data that changes completely each frame (sprite positions, colors)\n- **Dynamic buffers** for data that changes frequently but has some coherence (mesh instance transforms)\n- **Static buffers** for data that rarely changes (mesh vertex data, font glyph geometry)\n\nMemory mapping techniques provide efficient CPU-to-GPU data transfer by avoiding unnecessary memory copies. The rendering system maps vertex buffer memory directly, writes batch data in place, then unmaps before rendering. This approach minimizes memory bandwidth usage and reduces CPU overhead for large batch uploads.\n\n### Rendering Architecture Decisions\n\nThe rendering system's architecture emerges from a series of critical design decisions that balance performance, complexity, maintainability, and educational value. These decisions establish the foundational patterns that influence every aspect of the graphics pipeline, from low-level buffer management to high-level scene rendering strategies.\n\nEach architectural decision represents a trade-off between competing priorities. Performance optimizations often increase implementation complexity. Cross-platform compatibility may sacrifice platform-specific optimizations. Educational clarity sometimes conflicts with industry best practices that assume extensive background knowledge.\n\n> **Decision: Immediate vs Retained Mode Rendering**\n> - **Context**: The engine needs to balance rendering flexibility with performance optimization and implementation complexity\n> - **Options Considered**:\n>   - Immediate mode with direct draw calls from game logic\n>   - Retained mode with scene graphs and cached render commands\n>   - Hybrid approach with batched immediate commands\n> - **Decision**: Hybrid approach using immediate submission with automatic batching\n> - **Rationale**: Immediate mode provides simple, intuitive APIs for game developers, while automatic batching ensures good performance without requiring manual optimization\n> - **Consequences**: Easier to use than pure retained mode, better performance than naive immediate mode, but requires sophisticated batching logic\n\n| Rendering Mode | Pros | Cons | Chosen? |\n|----------------|------|------|---------|\n| Immediate Mode | Simple API, direct control, easy debugging | Poor performance, no optimization opportunity | No |\n| Retained Mode | Excellent performance, automatic optimization | Complex API, harder to debug, less flexible | No |\n| Hybrid Batched | Good performance, simple API, automatic optimization | Complex implementation, batching overhead | Yes |\n\nThe immediate vs retained mode decision fundamentally shapes how game developers interact with the rendering system. Immediate mode APIs allow developers to issue draw commands directly from game logic, providing intuitive control flow and easy debugging. However, naive immediate mode implementations suffer from poor performance due to excessive draw calls and missed optimization opportunities.\n\nRetained mode systems build scene graphs or command lists that can be optimized, culled, and batched before rendering. While this enables excellent performance, it requires developers to think in terms of scene management rather than direct rendering, increasing cognitive overhead and debugging complexity.\n\nThe hybrid approach chosen for this engine provides immediate-style APIs that internally build optimized command streams. Game developers can issue draw commands directly, but the rendering system automatically batches, sorts, and optimizes these commands before GPU submission. This design provides the performance benefits of retained mode with the usability advantages of immediate mode.\n\n> **Decision: OpenGL vs Vulkan Primary API**\n> - **Context**: Modern graphics development can target either OpenGL for simplicity or Vulkan for maximum performance and control\n> - **Options Considered**:\n>   - OpenGL 4.3+ as the primary API with good compatibility and debugging\n>   - Vulkan as the primary API for cutting-edge performance\n>   - Multi-API abstraction supporting both OpenGL and Vulkan equally\n> - **Decision**: OpenGL 4.3+ as primary with optional Vulkan backend for advanced users\n> - **Rationale**: OpenGL provides sufficient performance for educational purposes with much simpler debugging and implementation, while Vulkan can be added as an advanced learning path\n> - **Consequences**: Faster initial development and easier debugging, but may not demonstrate modern GPU programming best practices\n\nThe graphics API selection influences every aspect of the rendering system architecture. OpenGL's implicit state machine model requires careful state tracking to avoid expensive redundant operations, while Vulkan's explicit model demands detailed resource management but provides predictable performance characteristics.\n\nOpenGL benefits include widespread compatibility, excellent debugging tools (RenderDoc, gDEBugger), extensive documentation, and gentler learning curves. The implicit state management, while sometimes criticized, actually simplifies many common rendering scenarios and reduces boilerplate code for educational implementations.\n\nVulkan benefits include explicit resource control, minimal driver overhead, excellent multi-threading support, and modern GPU feature access. However, Vulkan requires substantially more code for basic operations, has steep learning curves, and provides fewer debugging tools for newcomers.\n\n> **Decision: Batching Strategy Selection**\n> - **Context**: Batch rendering can be organized by material, depth, object type, or hybrid approaches\n> - **Options Considered**:\n>   - Material-first batching that prioritizes reducing state changes\n>   - Depth-first batching that prioritizes correct transparency rendering\n>   - Hybrid batching with separate passes for opaque and transparent objects\n> - **Decision**: Hybrid batching with opaque front-to-back and transparent back-to-front passes\n> - **Rationale**: Depth ordering is critical for visual correctness, while material batching within depth passes provides good performance optimization\n> - **Consequences**: Correct transparency and depth behavior, good batching efficiency, but requires two-pass rendering and more complex sorting\n\n| Batching Strategy | Pros | Cons | Chosen? |\n|------------------|------|------|---------|\n| Material-First | Maximum batching efficiency, minimal state changes | Incorrect transparency, depth fighting issues | No |\n| Depth-First | Correct transparency, optimal depth testing | Poor batching, many material state changes | No |\n| Hybrid Two-Pass | Correct rendering, good batching within passes | More complex implementation, dual sorting | Yes |\n\nThe batching strategy decision affects both rendering correctness and performance characteristics. Pure material-first batching maximizes GPU efficiency by minimizing texture bindings and shader changes, but breaks transparency rendering when objects at different depths are rendered out of order.\n\nPure depth-first batching ensures correct transparency and depth testing by rendering objects in strict depth order, but sacrifices batching efficiency when nearby objects use different materials. This approach often results in excessive draw calls and poor GPU utilization.\n\nThe hybrid two-pass approach separates opaque and transparent objects into different rendering passes. Opaque objects are rendered front-to-back within material batches to maximize early depth rejection, while transparent objects are rendered back-to-front within material batches to ensure proper alpha blending. This strategy provides correct visual results while maintaining reasonable batching efficiency.\n\n> **Decision: Vertex Buffer Management Strategy**\n> - **Context**: Batch rendering requires efficient CPU-to-GPU data transfer for dynamic vertex data\n> - **Options Considered**:\n>   - Single large vertex buffer with sub-allocation\n>   - Multiple fixed-size buffers with round-robin usage\n>   - Dynamic buffer allocation based on frame requirements\n> - **Decision**: Multiple fixed-size buffers with round-robin allocation\n> - **Rationale**: Fixed-size buffers provide predictable memory usage and avoid allocation/deallocation overhead, while multiple buffers prevent GPU stalls\n> - **Consequences**: Predictable memory usage and good performance, but may waste memory when batch sizes vary significantly\n\nThe vertex buffer management strategy influences both rendering performance and memory usage patterns. GPU vertex buffers represent expensive resources that must be carefully managed to avoid allocation overhead and synchronization stalls.\n\nSingle large vertex buffers enable efficient memory usage by packing all batch data into contiguous memory regions. However, this approach requires complex sub-allocation logic and can cause GPU stalls when previous draw calls are still processing buffer regions needed for new batches.\n\nDynamic buffer allocation provides perfect memory efficiency by allocating exactly the required buffer sizes each frame. However, frequent allocation and deallocation operations cause CPU overhead and memory fragmentation that can degrade performance over time.\n\nThe chosen round-robin buffer strategy pre-allocates multiple fixed-size vertex buffers and cycles between them each frame. This approach ensures that while one buffer is being processed by the GPU, the CPU can safely update other buffers without synchronization stalls. The fixed sizes provide predictable memory usage while multiple buffers enable efficient parallel processing.\n\n> The key architectural insight for rendering systems is that GPU performance depends heavily on data flow patterns rather than just algorithmic complexity. Decisions that optimize for consistent data throughput and minimal state changes often matter more than clever algorithms that assume zero-cost state transitions.\n\nError handling and graceful degradation strategies ensure that rendering failures don't crash the engine or leave users with blank screens. The rendering system implements multiple fallback levels:\n\n1. **Shader Compilation Errors**: Fall back to simple unlit shaders that render objects in solid colors\n2. **Texture Loading Failures**: Use checkerboard error textures that clearly indicate missing assets\n3. **Buffer Allocation Failures**: Reduce batch sizes or fall back to immediate mode rendering\n4. **Context Loss**: Recreate all GPU resources and reload shaders/textures from cached data\n5. **Driver Crashes**: Implement context recovery with exponential backoff for repeated failures\n\nPerformance monitoring integration tracks key rendering metrics to identify performance bottlenecks and validate optimization effectiveness. The system measures:\n\n- Frame rendering times and frame rate consistency\n- Draw call counts and batch effectiveness ratios\n- GPU memory usage and vertex buffer utilization\n- Shader compilation times and cache hit rates\n- Texture binding changes and material state transitions\n\nThese metrics enable data-driven performance optimization and help developers understand the impact of different rendering approaches on their specific game content and target hardware configurations.\n\n### Implementation Guidance\n\nThis section provides concrete technology recommendations and starter code to bridge the gap between the rendering system design and actual implementation. The focus is on practical techniques that enable rapid development while maintaining the architectural principles described above.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Window Management | SDL2 for cross-platform window/input handling | GLFW with custom input abstraction layer |\n| Graphics Context | OpenGL 4.3 with GLAD function loader | Vulkan with custom command buffer abstraction |\n| Shader Compilation | Direct OpenGL calls with error logging | SPIR-V compilation with cross-API compatibility |\n| Texture Loading | stb_image for PNG/JPG support | Custom loader with DDS and HDR support |\n| Mathematics | GLM library for vectors and matrices | Custom SIMD-optimized math library |\n\n**Recommended File Structure:**\n```\nengine/\n├── src/\n│   ├── rendering/\n│   │   ├── window.hpp/.cpp          ← Platform window abstraction\n│   │   ├── renderer.hpp/.cpp        ← Main rendering interface\n│   │   ├── shader.hpp/.cpp          ← Shader compilation and management\n│   │   ├── batch_renderer.hpp/.cpp  ← Sprite and mesh batching system\n│   │   ├── texture.hpp/.cpp         ← Texture loading and management\n│   │   └── vertex_buffer.hpp/.cpp   ← Buffer management utilities\n│   ├── platform/\n│   │   ├── window_sdl2.cpp          ← SDL2 window implementation\n│   │   └── opengl_context.cpp       ← OpenGL context setup\n│   └── math/\n│       ├── vector.hpp               ← Vector2, Vector3 definitions\n│       └── matrix.hpp               ← Matrix4 transformation utilities\n├── assets/\n│   └── shaders/\n│       ├── sprite.vert              ← Basic sprite vertex shader\n│       ├── sprite.frag              ← Basic sprite fragment shader\n│       └── error.frag               ← Fallback error shader\n└── external/\n    ├── SDL2/                        ← SDL2 library\n    ├── glad/                        ← OpenGL function loader\n    └── stb/                         ← Image loading library\n```\n\n**Window and Graphics Context Infrastructure:**\n\nThis complete window management implementation handles platform-specific details while providing a clean interface for the rendering system:\n\n```cpp\n// window.hpp\n#pragma once\n#include <string>\n#include <functional>\n#include \"math/vector.hpp\"\n\nstruct WindowConfig {\n    std::string title = \"Game Engine\";\n    int width = 800;\n    int height = 600;\n    bool fullscreen = false;\n    bool resizable = true;\n    bool vsync = true;\n    int samples = 0; // MSAA samples (0, 2, 4, 8)\n};\n\nclass Window {\npublic:\n    using ResizeCallback = std::function<void(int width, int height)>;\n    \n    Window() = default;\n    ~Window();\n    \n    bool Initialize(const WindowConfig& config);\n    void Shutdown();\n    \n    bool ShouldClose() const;\n    void SwapBuffers();\n    void PollEvents();\n    \n    Vector2 GetSize() const { return Vector2{m_width, m_height}; }\n    void SetResizeCallback(ResizeCallback callback) { m_resizeCallback = callback; }\n    \n    // Input state queries\n    bool IsKeyPressed(int keycode) const;\n    bool IsMouseButtonPressed(int button) const;\n    Vector2 GetMousePosition() const;\n    \nprivate:\n    struct SDL_Window* m_window = nullptr;\n    void* m_glContext = nullptr; // SDL_GLContext\n    int m_width = 0;\n    int m_height = 0;\n    ResizeCallback m_resizeCallback;\n    \n    friend void HandleWindowResize(int width, int height);\n};\n\n// window.cpp - Complete SDL2 implementation\n#include \"window.hpp\"\n#include <SDL2/SDL.h>\n#include <glad/glad.h>\n#include <iostream>\n\nstatic Window* g_currentWindow = nullptr;\n\nbool Window::Initialize(const WindowConfig& config) {\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        std::cerr << \"SDL_Init Error: \" << SDL_GetError() << std::endl;\n        return false;\n    }\n    \n    // Set OpenGL attributes before window creation\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    \n    if (config.samples > 0) {\n        SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);\n        SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, config.samples);\n    }\n    \n    Uint32 flags = SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN;\n    if (config.fullscreen) flags |= SDL_WINDOW_FULLSCREEN;\n    if (config.resizable) flags |= SDL_WINDOW_RESIZABLE;\n    \n    m_window = SDL_CreateWindow(\n        config.title.c_str(),\n        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n        config.width, config.height, flags\n    );\n    \n    if (!m_window) {\n        std::cerr << \"SDL_CreateWindow Error: \" << SDL_GetError() << std::endl;\n        return false;\n    }\n    \n    m_glContext = SDL_GL_CreateContext(m_window);\n    if (!m_glContext) {\n        std::cerr << \"SDL_GL_CreateContext Error: \" << SDL_GetError() << std::endl;\n        return false;\n    }\n    \n    // Load OpenGL functions\n    if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress)) {\n        std::cerr << \"Failed to initialize OpenGL context\" << std::endl;\n        return false;\n    }\n    \n    // Set vsync\n    SDL_GL_SetSwapInterval(config.vsync ? 1 : 0);\n    \n    // Configure initial OpenGL state\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_DEPTH_TEST);\n    glDepthFunc(GL_LESS);\n    \n    if (config.samples > 0) {\n        glEnable(GL_MULTISAMPLE);\n    }\n    \n    m_width = config.width;\n    m_height = config.height;\n    g_currentWindow = this;\n    \n    std::cout << \"OpenGL \" << glGetString(GL_VERSION) << std::endl;\n    std::cout << \"GPU: \" << glGetString(GL_RENDERER) << std::endl;\n    \n    return true;\n}\n\nvoid Window::PollEvents() {\n    SDL_Event event;\n    while (SDL_PollEvent(&event)) {\n        switch (event.type) {\n            case SDL_QUIT:\n                // Set close flag - implementation detail\n                break;\n            case SDL_WINDOWEVENT:\n                if (event.window.event == SDL_WINDOWEVENT_RESIZED) {\n                    m_width = event.window.data1;\n                    m_height = event.window.data2;\n                    glViewport(0, 0, m_width, m_height);\n                    if (m_resizeCallback) {\n                        m_resizeCallback(m_width, m_height);\n                    }\n                }\n                break;\n        }\n    }\n}\n```\n\n**Shader System Core Implementation:**\n\n```cpp\n// shader.hpp\n#pragma once\n#include <string>\n#include <unordered_map>\n#include \"math/vector.hpp\"\n#include \"math/matrix.hpp\"\n\nclass ShaderProgram {\npublic:\n    ShaderProgram() = default;\n    ~ShaderProgram();\n    \n    bool LoadFromFiles(const std::string& vertexPath, const std::string& fragmentPath);\n    bool LoadFromSource(const std::string& vertexSource, const std::string& fragmentSource);\n    \n    void Use() const;\n    bool IsValid() const { return m_programID != 0 && m_isLinked; }\n    \n    // Uniform setters\n    void SetUniform(const std::string& name, float value);\n    void SetUniform(const std::string& name, const Vector2& value);\n    void SetUniform(const std::string& name, const Vector3& value);\n    void SetUniform(const std::string& name, const Vector4& value);\n    void SetUniform(const std::string& name, const Matrix4& value);\n    void SetUniform(const std::string& name, int value);\n    \n    uint32_t GetProgramID() const { return m_programID; }\n    \nprivate:\n    uint32_t m_programID = 0;\n    uint32_t m_vertexShaderID = 0;\n    uint32_t m_fragmentShaderID = 0;\n    bool m_isLinked = false;\n    \n    mutable std::unordered_map<std::string, int> m_uniformLocations;\n    \n    uint32_t CompileShader(const std::string& source, uint32_t shaderType);\n    bool LinkProgram();\n    int GetUniformLocation(const std::string& name) const;\n    void CheckCompileErrors(uint32_t shader, const std::string& type);\n};\n\n// Basic sprite vertex shader (assets/shaders/sprite.vert)\nconst char* SPRITE_VERTEX_SHADER = R\"(\n#version 430 core\n\nlayout (location = 0) in vec2 a_Position;\nlayout (location = 1) in vec2 a_TexCoord;\nlayout (location = 2) in vec4 a_Color;\n\nuniform mat4 u_ViewProjection;\nuniform mat4 u_Transform;\n\nout vec2 v_TexCoord;\nout vec4 v_Color;\n\nvoid main() {\n    v_TexCoord = a_TexCoord;\n    v_Color = a_Color;\n    gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 0.0, 1.0);\n}\n)\";\n\n// Basic sprite fragment shader (assets/shaders/sprite.frag)\nconst char* SPRITE_FRAGMENT_SHADER = R\"(\n#version 430 core\n\nin vec2 v_TexCoord;\nin vec4 v_Color;\n\nuniform sampler2D u_Texture;\n\nout vec4 FragColor;\n\nvoid main() {\n    FragColor = texture(u_Texture, v_TexCoord) * v_Color;\n}\n)\";\n```\n\n**Batch Renderer Core Logic Skeleton:**\n\n```cpp\n// batch_renderer.hpp\n#pragma once\n#include <vector>\n#include \"rendering/shader.hpp\"\n#include \"math/vector.hpp\"\n#include \"math/matrix.hpp\"\n\nstruct SpriteVertex {\n    Vector2 position;\n    Vector2 texCoord;\n    Vector4 color;\n};\n\nstruct SpriteRenderData {\n    Matrix4 transform;\n    Vector4 color;\n    uint32_t textureID;\n    float depth;\n};\n\nclass BatchRenderer {\npublic:\n    static constexpr size_t MAX_SPRITES_PER_BATCH = 1000;\n    static constexpr size_t VERTICES_PER_SPRITE = 4;\n    static constexpr size_t INDICES_PER_SPRITE = 6;\n    \n    BatchRenderer();\n    ~BatchRenderer();\n    \n    bool Initialize();\n    void Shutdown();\n    \n    void BeginBatch(const Matrix4& viewProjection);\n    void SubmitSprite(const SpriteRenderData& sprite);\n    void EndBatch();\n    \nprivate:\n    struct BatchData {\n        std::vector<SpriteVertex> vertices;\n        std::vector<uint32_t> indices;\n        uint32_t textureID;\n        size_t spriteCount;\n    };\n    \n    uint32_t m_VAO = 0;\n    uint32_t m_VBO = 0;\n    uint32_t m_EBO = 0;\n    \n    ShaderProgram m_spriteShader;\n    Matrix4 m_viewProjection;\n    \n    std::vector<BatchData> m_batches;\n    std::vector<SpriteRenderData> m_spriteQueue;\n    \n    void FlushBatches();\n    void CreateBatch(const std::vector<SpriteRenderData>& sprites, uint32_t textureID);\n    void RenderBatch(const BatchData& batch);\n    \n    // TODO: Implement sprite sorting by depth and texture\n    void SortSprites();\n    \n    // TODO: Implement batch creation from sorted sprite queue\n    void BuildBatches();\n    \n    // TODO: Implement vertex data generation for sprite quads\n    void GenerateQuadVertices(const SpriteRenderData& sprite, std::vector<SpriteVertex>& vertices);\n};\n\n// Core batch processing implementation\nvoid BatchRenderer::EndBatch() {\n    if (m_spriteQueue.empty()) return;\n    \n    // TODO 1: Sort sprites by depth (back-to-front for transparency)\n    // Hint: Use std::sort with custom comparator on m_spriteQueue\n    SortSprites();\n    \n    // TODO 2: Group consecutive sprites with same texture into batches\n    // Hint: Iterate through sorted queue, break batches when texture changes\n    BuildBatches();\n    \n    // TODO 3: Upload vertex data and render each batch\n    // Hint: Use glBufferSubData to upload vertices, then glDrawElements\n    FlushBatches();\n    \n    // TODO 4: Clear sprite queue and batch data for next frame\n    m_spriteQueue.clear();\n    m_batches.clear();\n}\n```\n\n**Milestone Checkpoint for Rendering System:**\n\nAfter implementing the rendering system, verify the following functionality:\n\n1. **Window Creation Test**: Run the engine and verify a window appears with the correct title and resolution\n2. **Clear Color Test**: Verify the window clears to a solid color each frame (usually dark blue or black)\n3. **Shader Compilation Test**: Check console output for successful shader compilation messages\n4. **Basic Sprite Test**: Render a single white square at screen center using the sprite batch renderer\n5. **Texture Loading Test**: Load and display a simple PNG texture on a sprite quad\n6. **Batch Performance Test**: Render 100+ sprites and verify frame rate stays above 60 FPS\n\nExpected console output:\n```\nSDL2 initialized successfully\nOpenGL 4.3.0 (or higher)\nGPU: [Your graphics card name]\nSprite vertex shader compiled successfully\nSprite fragment shader compiled successfully\nShader program linked successfully\nBatch renderer initialized: VAO=1, VBO=2, EBO=3\n```\n\n**Debugging Tips for Rendering Issues:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Black screen | Shader compilation failure | Check console for compilation errors | Fix shader syntax, verify GLSL version |\n| White/pink textures | Texture loading failure | Verify file paths and formats | Check stb_image error messages, use absolute paths |\n| Sprites not visible | Incorrect transformation matrices | Log matrix values, check coordinate systems | Verify view-projection matrix, world transforms |\n| Poor performance | Too many draw calls | Count draw calls in GPU debugger | Increase batch sizes, reduce material changes |\n| Flickering sprites | Depth fighting or sorting issues | Disable depth testing temporarily | Fix sprite depth values, improve sorting |\n\n\n## Entity Component System\n\n> **Milestone(s):** Milestone 2 (Entity Component System) — complete ECS architecture with entity management, component storage, and system execution pipeline\n\nThe Entity Component System represents the **organizational backbone** of our game engine, determining how game objects are structured, how their data is stored in memory, and how game logic processes that data each frame. Unlike traditional object-oriented approaches where game objects inherit from base classes and encapsulate both data and behavior, ECS separates these concerns into three distinct architectural elements: entities as identifiers, components as pure data, and systems as pure logic.\n\nThis architectural separation enables **data-oriented design principles** that optimize for modern CPU performance characteristics, particularly cache efficiency and vectorization opportunities. The challenge lies in designing an ECS that provides both the flexibility needed for diverse game object types and the performance required to process thousands of entities at 60 frames per second within our 16.67ms frame time budget.\n\n![ECS Data Model and Relationships](./diagrams/ecs-data-model.svg)\n\n### Mental Model: Database with Specialized Workers\n\nThink of the ECS as a **specialized database system** where entities are row identifiers, components are tables with typed columns, and systems are background workers that process specific combinations of tables. Just as a database query like \"SELECT position, velocity FROM entities WHERE has_physics_body\" efficiently retrieves only the relevant data, ECS systems query for entities possessing specific component combinations and iterate through densely packed arrays of that data.\n\nIn this mental model, **entities** function like primary keys in a relational database — unique identifiers that link related data across multiple tables. An entity with ID 1203 might have a row in the `Transform` component table, a row in the `Sprite` component table, and a row in the `RigidBody` component table. The entity itself contains no data; it merely serves as the foreign key that relates these component records.\n\n**Components** correspond to database tables with strongly typed schemas. The `Transform` component table contains columns for `position`, `rotation`, and `scale`, with one row per entity that possesses transform data. Unlike traditional database tables, component tables use dense array storage where removing an entity causes the last element to fill the gap, maintaining cache-friendly contiguous memory layout.\n\n**Systems** act as specialized database workers that execute specific queries and transformations. A `MovementSystem` queries for entities with both `Transform` and `RigidBody` components, iterates through the dense arrays of position and velocity data, and updates positions based on physics calculations. The database analogy breaks down slightly here because systems modify data in-place rather than producing result sets, but the core concept of query-based processing remains.\n\nThis mental model helps explain why ECS excels at performance: database systems optimize for bulk operations on structured data, and ECS applies the same principles to game object processing. Instead of scattered object instances calling virtual methods, we have dense arrays being processed by tight loops — exactly what modern CPUs handle most efficiently.\n\n### Entity ID Management\n\nEntity identity in our ECS follows a **generation-based approach** that combines array indexing with staleness detection. Unlike simple incrementing counters that eventually overflow, or pointer-based systems that suffer from memory fragmentation, generation-based entity IDs provide both efficient storage access and robust error detection when game logic attempts to use outdated entity references.\n\nThe `Entity` structure packs two pieces of information into a single 32-bit identifier: a 22-bit array index and a 10-bit generation counter. This design supports up to 4,194,304 concurrent entities while providing 1,024 generations per array slot, which proves sufficient for detecting stale references in typical game scenarios where entities are created and destroyed frequently.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `m_id` | `uint32_t` | Packed entity identifier containing index (bits 0-21) and generation (bits 22-31) |\n\nThe entity ID encoding uses bitwise operations to pack and extract the index and generation components efficiently. The index occupies the lower 22 bits, providing direct array access for component lookups, while the generation occupies the upper 10 bits, incrementing each time an entity slot is recycled.\n\nEntity creation follows a **recycling strategy** that maintains a free list of available indices while incrementing generation counters to invalidate stale references. When `CreateEntity()` is called, the system first checks the free list for recycled indices. If available, it pops the index, increments the generation counter for that slot, and returns the new packed ID. If no recycled indices exist, it allocates a new index at the end of the entity array.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `CreateEntity` | None | `Entity` | Creates new entity with unique recycled ID from free list or new allocation |\n| `DestroyEntity` | `Entity` | `void` | Removes entity, increments generation, adds index to free list |\n| `GetIndex` | None | `uint32_t` | Extracts 22-bit array index from packed entity ID |\n| `GetGeneration` | None | `uint32_t` | Extracts 10-bit generation counter from packed entity ID |\n| `GetID` | None | `uint32_t` | Returns complete packed entity identifier |\n| `IsValid` | None | `bool` | Checks if entity ID is non-zero (NULL_ENTITY check) |\n\nEntity destruction involves a two-phase process that ensures both memory cleanup and reference invalidation. First, the `ECSWorld` removes all components associated with the entity, triggering cleanup in each component storage system. Second, the entity manager increments the generation counter for the entity's index slot and adds the index to the free list for future recycling.\n\nThe generation counter mechanism provides **automatic staleness detection** when game logic holds outdated entity references. Consider a scenario where entity 1203 (index 1203, generation 5) is destroyed and its index is recycled for a new entity 1203 (index 1203, generation 6). If old game logic attempts to access the original entity using the outdated ID, component lookups will fail because the stored generation (6) no longer matches the requested generation (5).\n\nHere's a step-by-step walkthrough of the entity lifecycle:\n\n1. **Creation Request**: Game logic calls `CreateEntity()` to spawn a new game object\n2. **Index Allocation**: Entity manager checks free list; if empty, allocates new index at end of array\n3. **Generation Assignment**: If recycling, increment generation counter for that index; if new, start at generation 1\n4. **ID Encoding**: Pack index (22 bits) and generation (10 bits) into 32-bit entity ID using bitwise operations\n5. **Registration**: Store generation counter in entity metadata array for future validation\n6. **Component Attachment**: Game logic calls `AddComponent<T>()` to attach data to the new entity\n7. **Active Usage**: Systems process entity through component queries during frame updates\n8. **Destruction Request**: Game logic calls `DestroyEntity()` when object should be removed\n9. **Component Cleanup**: ECS world removes all components, triggering destructor calls and memory deallocation\n10. **Generation Increment**: Increment generation counter to invalidate existing references to this index\n11. **Index Recycling**: Add index to free list for future entity creation requests\n\n> **Design Insight**: Generation-based entity IDs solve the \"dangling pointer\" problem common in game engines where one system destroys an entity while another system still holds a reference. Instead of crashes or undefined behavior, stale references simply fail component lookups gracefully, making debugging significantly easier.\n\n**Architecture Decision: Generation-Based Entity IDs**\n\n> **Decision: Generation-Based Entity IDs**\n> - **Context**: Game engines frequently create and destroy entities, leading to potential stale references when one system destroys an entity that another system still references. Traditional approaches like raw pointers cause crashes, while UUID-based systems waste memory and reduce cache efficiency.\n> - **Options Considered**: Raw pointers with manual lifecycle management, UUID-based globally unique identifiers, simple incrementing counters, generation-based recycling IDs\n> - **Decision**: 32-bit generation-based entity IDs with 22-bit index and 10-bit generation counter\n> - **Rationale**: Provides both efficient array-based component access (via index) and automatic stale reference detection (via generation counter) while fitting in a single 32-bit word for cache efficiency\n> - **Consequences**: Limits maximum concurrent entities to 4M and maximum generations per slot to 1024, but enables robust error detection and maintains high performance component access patterns\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Raw Pointers | Fastest access, minimal memory | Crashes on stale references, manual lifecycle | No |\n| UUID Identifiers | Globally unique, no stale refs | 128-bit overhead, slow component lookup | No |\n| Incrementing Counter | Simple implementation, unique IDs | Integer overflow, no stale detection | No |\n| Generation-Based | Fast access + stale detection, 32-bit size | Limited entities/generations per slot | **Yes** |\n\n### Component Storage Strategy\n\nComponent storage represents the **performance-critical foundation** of our ECS architecture, directly determining cache efficiency, memory usage patterns, and iteration speed for systems processing thousands of entities per frame. Our storage strategy prioritizes data-oriented design principles, organizing components in dense arrays that maximize CPU cache utilization while providing efficient insertion, removal, and query operations.\n\n![ECS Component Storage Organization](./diagrams/component-storage.svg)\n\nThe core storage mechanism uses **sparse-dense pairs** where a sparse array provides O(1) entity-to-component lookup while dense arrays enable cache-friendly iteration. This hybrid approach solves the fundamental tension between random access performance (needed for component queries) and sequential access performance (needed for system iteration).\n\n| Component | Type | Description |\n|-----------|------|-------------|\n| `ComponentArray<T>` | Template class | Dense storage container for specific component type |\n| `m_components` | `vector<T>` | Dense array containing actual component data in contiguous memory |\n| `m_entityToIndex` | `unordered_map<Entity, size_t>` | Sparse mapping from entity ID to dense array index |\n| `m_indexToEntity` | `vector<Entity>` | Parallel array mapping dense indices back to entity IDs |\n| `m_freeIndices` | `vector<size_t>` | Stack of available indices for recycling after component removal |\n\nThe **dense array strategy** ensures that component data remains tightly packed in memory regardless of entity creation and destruction patterns. When system iteration processes components, it accesses sequential memory locations that are likely to be cached together, maximizing cache hit rates and minimizing memory bandwidth requirements.\n\nComponent addition follows a **append-or-recycle pattern** that maintains density while enabling efficient insertion:\n\n1. **Entity Validation**: Verify entity ID is valid and does not already possess this component type\n2. **Index Selection**: Pop free index from recycling stack, or append to end if stack empty\n3. **Component Construction**: Construct component object in-place at selected dense array location using provided arguments\n4. **Mapping Update**: Insert entity-to-index mapping in sparse lookup table\n5. **Reverse Mapping**: Store entity ID in parallel index-to-entity array for iteration support\n6. **Archetype Update**: Notify archetype system that entity's component signature has changed\n\nComponent removal requires **swap-and-pop deletion** to maintain array density without shifting elements:\n\n1. **Lookup Validation**: Confirm entity possesses component via sparse lookup table\n2. **Index Retrieval**: Extract dense array index for the component to be removed\n3. **Component Destruction**: Call component destructor to clean up any owned resources\n4. **Swap Operation**: Move last component in dense array to fill the gap left by removed component\n5. **Mapping Updates**: Update both sparse and reverse mappings to reflect the swap operation\n6. **Index Recycling**: Push freed index onto recycling stack for future component additions\n7. **Archetype Update**: Notify archetype system of component signature change\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `AddComponent<T>` | `Entity entity, Args... args` | `T&` | Constructs component in dense array with forwarded arguments |\n| `RemoveComponent<T>` | `Entity entity` | `void` | Removes component using swap-and-pop deletion |\n| `GetComponent<T>` | `Entity entity` | `T*` | Returns component pointer or nullptr via sparse lookup |\n| `HasComponent<T>` | `Entity entity` | `bool` | Checks component existence via sparse lookup table |\n| `GetEntity` | `size_t index` | `Entity` | Maps dense array index back to entity ID |\n\nThe storage system supports **efficient iteration patterns** required by system processing. Systems typically iterate over dense component arrays using simple for loops, accessing both the component data and the associated entity ID through the parallel index-to-entity mapping. This iteration pattern achieves optimal cache performance because it accesses memory sequentially regardless of entity creation order.\n\nHere's a detailed walkthrough of component access patterns during system execution:\n\n1. **Query Initiation**: System requests entities possessing specific component combination (e.g., Transform + RigidBody)\n2. **Archetype Selection**: ECS identifies archetypes matching the component signature\n3. **Dense Array Access**: System retrieves dense component arrays for iteration\n4. **Sequential Iteration**: System loops through component arrays using simple index-based iteration\n5. **Entity Identification**: System accesses parallel index-to-entity array to identify current entity\n6. **Component Processing**: System applies logic to current component data, potentially modifying values\n7. **Cross-Component Access**: System uses entity ID to access additional components via sparse lookup\n8. **Cache Optimization**: CPU cache lines contain multiple components due to sequential access pattern\n\n**Archetype organization** groups entities sharing identical component signatures to further optimize iteration performance. An archetype represents a specific combination of component types, such as \"Transform + Sprite + RigidBody\". Entities within an archetype can be processed together without checking component existence, and their component data is stored in aligned arrays that maximize vectorization opportunities.\n\n| Archetype Field | Type | Description |\n|-----------------|------|-------------|\n| `componentSignature` | `bitset<MAX_COMPONENTS>` | Bitmask indicating which component types this archetype contains |\n| `entities` | `vector<Entity>` | Entities belonging to this archetype for batch processing |\n| `componentArrays` | `array<void*, MAX_COMPONENTS>` | Pointers to dense component arrays for each component type |\n\nArchetype transitions occur when entities gain or lose components, requiring movement between archetype storage areas. This operation involves copying component data from source to destination archetypes and updating entity-to-archetype mappings. While archetype transitions have higher overhead than simple component modifications, they enable extremely efficient system iteration for entities that remain stable.\n\n> **Performance Insight**: The cache-friendly nature of dense component arrays can improve system iteration performance by 5-10x compared to traditional object-oriented approaches where game object data is scattered across heap allocations. Modern CPUs can process sequential arrays much more efficiently than pointer-chasing through object hierarchies.\n\n**Architecture Decision: Dense Array Component Storage**\n\n> **Decision: Dense Array Component Storage with Archetype Organization**\n> - **Context**: ECS systems must iterate over thousands of components per frame within a 16.67ms budget. Traditional object-oriented storage scatters component data across memory, causing cache misses and poor iteration performance.\n> - **Options Considered**: Array-of-structs with component inheritance, hash map storage by entity ID, sparse component arrays with holes, dense arrays with sparse lookup\n> - **Decision**: Dense arrays for component data with sparse lookup tables and archetype grouping\n> - **Rationale**: Dense arrays maximize cache efficiency during system iteration, sparse lookup provides O(1) component access, and archetypes eliminate component existence checks during processing\n> - **Consequences**: Requires complex bookkeeping for component addition/removal and archetype transitions, but enables high-performance iteration and vectorization opportunities\n\n| Storage Option | Pros | Cons | Cache Performance | Chosen? |\n|----------------|------|------|-------------------|---------|\n| Object Hierarchy | Familiar OOP model | Scattered memory, virtual calls | Poor (pointer chasing) | No |\n| Hash Map Storage | Simple implementation | Poor iteration locality | Poor (random access) | No |\n| Sparse Arrays | Direct entity indexing | Memory waste, false sharing | Fair (holes break locality) | No |\n| Dense Arrays | Optimal cache usage | Complex bookkeeping | Excellent (sequential) | **Yes** |\n\n### System Update Pipeline\n\nThe system update pipeline orchestrates the **execution order and data dependencies** between different game logic systems, ensuring that each frame processes entity updates in a deterministic sequence that respects inter-system dependencies while maximizing opportunities for parallel execution where safe.\n\nOur pipeline design follows a **query-driven execution model** where systems declare their component requirements upfront, and the ECS schedules system execution based on data access patterns and explicit dependency relationships. This approach enables both automatic parallelization of independent systems and deterministic ordering for systems with read-after-write dependencies.\n\nSystem registration involves **compile-time dependency analysis** where each system specifies its component access patterns (read-only, write-only, read-write) and explicit dependencies on other systems. The ECS uses this information to construct a dependency graph that determines execution order and identifies opportunities for parallel execution within each frame.\n\n| System Property | Type | Description |\n|-----------------|------|-------------|\n| `componentSignature` | `bitset<MAX_COMPONENTS>` | Bitmask indicating required component types for system queries |\n| `readComponents` | `set<ComponentType>` | Component types this system reads but does not modify |\n| `writeComponents` | `set<ComponentType>` | Component types this system modifies during execution |\n| `dependencies` | `vector<SystemType>` | Other systems that must execute before this system |\n| `updateFrequency` | `float` | Target update rate in Hz (for systems that don't need 60fps) |\n\nThe **execution scheduling algorithm** processes systems in topologically sorted order based on their dependency graph, grouping independent systems into parallel execution batches where data dependencies permit concurrent execution:\n\n1. **Dependency Graph Construction**: Build directed graph where edges represent \"must execute before\" relationships\n2. **Topological Sort**: Order systems to respect all dependency constraints while minimizing total execution phases\n3. **Parallel Batch Identification**: Group systems with no data conflicts into concurrent execution batches\n4. **Resource Conflict Detection**: Identify systems that write to shared component types and serialize their execution\n5. **Update Frequency Grouping**: Schedule systems with different update rates (e.g., AI at 30Hz, rendering at 60Hz)\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `RegisterSystem<T>` | `Args... args` | `void` | Adds system to execution pipeline with dependency analysis |\n| `UpdateSystems` | `float deltaTime` | `void` | Executes all registered systems in dependency-aware order |\n| `SetSystemDependency<A, B>` | None | `void` | Declares that system A must execute before system B |\n| `GetSystemUpdateTime<T>` | None | `float` | Returns average execution time for performance monitoring |\n\nQuery execution within each system follows a **batch processing model** that maximizes cache efficiency and enables vectorization opportunities. When a system executes, it queries for all entities possessing its required component combination, then processes them in large batches rather than individually.\n\nHere's the detailed system execution sequence for a typical frame update:\n\n1. **Frame Initialization**: Calculate delta time and prepare system execution context\n2. **Dependency Resolution**: Sort systems based on dependency graph and component access patterns\n3. **Parallel Batch Identification**: Group independent systems for concurrent execution where safe\n4. **System Query Phase**: Each system queries ECS for entities matching its component signature\n5. **Entity Set Retrieval**: Return dense component arrays and entity lists for efficient iteration\n6. **Batch Processing**: System iterates through component arrays using cache-friendly sequential access\n7. **Component Updates**: System modifies component data in-place, maintaining memory layout\n8. **Cross-System Communication**: Systems publish events or set shared state for subsequent systems\n9. **Dependency Synchronization**: Wait for parallel systems to complete before dependent systems begin\n10. **Resource Cleanup**: Handle any component destruction or archetype transitions requested during updates\n\n**Parallel execution safety** relies on **read-write access analysis** to determine which systems can run concurrently without data races. Systems that only read shared component types can execute in parallel, while systems that write to shared types must be serialized to prevent undefined behavior.\n\n| Access Pattern | Parallel Safety | Example Systems |\n|----------------|-----------------|-----------------|\n| Read-Only Different Components | Safe | Input processing + Audio playback |\n| Read-Only Same Components | Safe | Multiple rendering passes |\n| Write Different Components | Safe | Physics simulation + Animation |\n| Write Same Components | Unsafe | Transform updates + Physics updates |\n| Read-Write Dependency | Unsafe | Movement calculation → Collision detection |\n\nThe system pipeline supports **variable update frequencies** for systems that don't require full 60fps processing. AI systems might update at 30Hz, networking at 20Hz, and physics at 120Hz, while rendering maintains the target frame rate. Each system maintains an accumulator that determines when it should execute based on elapsed time since its last update.\n\nQuery optimization occurs through **archetype-aware iteration** where systems receive pre-filtered entity lists organized by archetype. Instead of checking component existence for each entity, systems iterate through archetype buckets where all entities are guaranteed to possess the required components, eliminating conditional branches in hot loops.\n\n> **Performance Insight**: Grouping systems by data access patterns and enabling parallel execution can improve frame processing performance by 2-4x on multi-core systems, particularly for CPU-intensive operations like AI, animation, and physics that don't require strict sequential ordering.\n\n**Architecture Decision: Query-Driven System Pipeline**\n\n> **Decision: Query-Driven System Pipeline with Dependency-Aware Scheduling**\n> - **Context**: Game systems often have complex interdependencies (e.g., physics must run before rendering, input must run before movement) while also having opportunities for parallelization (e.g., audio and rendering are independent)\n> - **Options Considered**: Fixed sequential execution order, priority-based scheduling, full parallel execution with locks, dependency graph with batch parallelization\n> - **Decision**: Dependency graph construction with topological sorting and parallel batch identification\n> - **Rationale**: Enables deterministic execution order for dependent systems while maximizing parallel execution opportunities and maintaining cache-friendly iteration patterns\n> - **Consequences**: Requires upfront dependency declaration and more complex scheduling logic, but provides both performance and correctness for complex system interactions\n\n| Pipeline Option | Pros | Cons | Parallelism | Chosen? |\n|------------------|------|------|-------------|---------|\n| Fixed Sequential | Simple, predictable | No parallelism, inflexible | None | No |\n| Priority Scheduling | Flexible ordering | Non-deterministic, race conditions | Limited | No |\n| Full Parallel + Locks | Maximum concurrency | Complex synchronization, deadlocks | Maximum | No |\n| Dependency Graph | Deterministic + parallel | Complex scheduling logic | Optimal | **Yes** |\n\n### ECS Architecture Decisions\n\nThe design of our ECS architecture required several **fundamental architectural choices** that significantly impact performance, usability, and maintainability. Each decision represents a trade-off between competing concerns, and understanding these trade-offs is crucial for both implementing the system correctly and extending it in the future.\n\n**Storage Layout: Struct-of-Arrays vs Array-of-Structs**\n\n> **Decision: Struct-of-Arrays Component Storage**\n> - **Context**: Component data can be organized either as arrays of complete component objects (AoS) or as separate arrays for each component field (SoA). This choice affects cache performance, vectorization opportunities, and implementation complexity.\n> - **Options Considered**: Array-of-Structs for object cohesion, Struct-of-Arrays for cache optimization, hybrid approach with component splitting, adaptive layout based on access patterns\n> - **Decision**: Struct-of-Arrays organization with separate dense arrays for each component type\n> - **Rationale**: SoA maximizes cache line utilization when systems access only subset of component fields, enables SIMD vectorization for batch operations, and aligns with data-oriented design principles for modern CPU architectures\n> - **Consequences**: Requires more complex iteration patterns for systems accessing multiple component types, but provides significant performance advantages for systems processing large entity counts\n\nThe struct-of-arrays approach stores component data in separate arrays organized by field type rather than as complete objects. For example, instead of an array of `Transform` objects containing position, rotation, and scale fields, we maintain separate arrays for positions, rotations, and scales. This organization optimizes for systems that process only specific fields, avoiding cache pollution from unused data.\n\n| Storage Approach | Memory Layout | Cache Efficiency | Vectorization | Implementation |\n|------------------|---------------|------------------|---------------|----------------|\n| Array-of-Structs | `[pos,rot,scale][pos,rot,scale]...` | Poor (unused fields) | Limited | Simple |\n| Struct-of-Arrays | `[pos,pos,pos...][rot,rot,rot...]` | Excellent (packed fields) | Optimal | Complex |\n| Hybrid Approach | Mixed based on usage patterns | Variable | Good | Very Complex |\n\n**Archetype vs Signature-Based Organization**\n\n> **Decision: Archetype-Based Entity Organization**\n> - **Context**: Entities can be organized either by checking component signatures during iteration (signature-based) or by grouping entities with identical component sets into archetypes. This affects iteration performance and memory usage patterns.\n> - **Options Considered**: Signature-based with runtime component checks, archetype grouping with pre-sorted entities, sparse tables with component bitmasks, hybrid approach with common archetypes\n> - **Decision**: Full archetype organization where entities are grouped by identical component signatures\n> - **Rationale**: Archetype organization eliminates conditional branches during system iteration, enables optimal vectorization by guaranteeing component presence, and provides better cache locality for common entity patterns\n> - **Consequences**: Requires entity migration between archetypes when components are added/removed, increasing complexity for dynamic component modification\n\nArchetype organization groups entities with identical component signatures into specialized storage areas. Each archetype maintains aligned arrays for its specific component combination, enabling systems to iterate through guaranteed-compatible entities without runtime component existence checks.\n\n| Organization Method | Iteration Speed | Component Changes | Memory Layout | Branch Prediction |\n|---------------------|-----------------|-------------------|---------------|-------------------|\n| Signature-Based | Slow (checks per entity) | Fast (in-place) | Flexible | Poor (unpredictable) |\n| Archetype-Based | Fast (guaranteed components) | Slow (migration) | Optimal | Excellent (no branches) |\n| Sparse Tables | Medium (bitmap checks) | Medium | Good | Fair |\n\n**Component Access: Handle-Based vs Direct Pointers**\n\n> **Decision: Direct Pointer Component Access with Generation Validation**\n> - **Context**: Component access can use either direct pointers to component data or handle-based indirection for safety. This affects access performance and memory safety in the presence of component reallocation.\n> - **Options Considered**: Raw pointers with manual validation, handle-based access with indirection, smart pointers with reference counting, generation-validated direct pointers\n> - **Decision**: Direct pointers with entity generation validation for safety\n> - **Rationale**: Direct pointer access provides optimal performance for tight system loops while generation validation catches most stale reference bugs without the overhead of full handle indirection\n> - **Consequences**: Requires careful management of pointer invalidation during component array reallocation and archetype migrations\n\nThe component access strategy balances performance with safety by using direct pointers for component data access while relying on entity generation counters to detect stale references. This approach avoids the indirection overhead of handle-based systems while providing reasonable protection against common reference errors.\n\n| Access Method | Performance | Safety | Implementation | Reallocation Handling |\n|---------------|-------------|--------|----------------|----------------------|\n| Raw Pointers | Fastest | None | Simple | Manual invalidation |\n| Handle Indirection | Slower | High | Complex | Automatic |\n| Smart Pointers | Slowest | High | Medium | Reference counting |\n| Generation Validated | Fast | Good | Medium | Explicit validation |\n\n**Query Performance: Cached vs Dynamic Component Queries**\n\n> **Decision: Cached Component Queries with Invalidation Tracking**\n> - **Context**: System component queries can be evaluated dynamically each frame or cached between frames with invalidation. This affects query performance and memory usage for systems with stable entity sets.\n> - **Options Considered**: Dynamic queries each frame, cached queries with manual invalidation, cached queries with automatic tracking, hybrid caching for stable vs dynamic systems\n> - **Decision**: Cached component queries with automatic invalidation tracking based on archetype changes\n> - **Rationale**: Most systems process stable entity sets that change infrequently, making cached queries significantly faster than repeated dynamic evaluation, while automatic invalidation ensures correctness\n> - **Consequences**: Requires change tracking infrastructure and increases memory usage for query results, but provides substantial performance improvements for systems with large entity sets\n\nCached queries store the results of component lookups between frames, avoiding repeated traversal of archetype structures for systems that process stable entity populations. The caching system tracks archetype modifications and automatically invalidates affected query results.\n\n| Query Strategy | Frame Performance | Memory Usage | Complexity | Dynamic Entities |\n|----------------|-------------------|--------------|------------|------------------|\n| Dynamic Each Frame | Consistent slow | Minimal | Simple | Handles perfectly |\n| Manual Cache | Fast when valid | High | Complex | Error-prone |\n| Automatic Cache | Fast most frames | Medium | Medium | Handles correctly |\n| Hybrid Caching | Optimal | Variable | High | Best of both |\n\n### Common Pitfalls\n\nUnderstanding common implementation mistakes helps avoid subtle bugs that can be difficult to diagnose in a complex ECS system. These pitfalls often stem from the conceptual differences between ECS and traditional object-oriented patterns.\n\n⚠️ **Pitfall: Component Iterator Invalidation During Iteration**\n\nA frequent mistake occurs when systems add or remove components while iterating through component arrays, causing iterator invalidation and unpredictable behavior. This happens because component addition may trigger array reallocation, invalidating existing pointers, while component removal uses swap-and-pop deletion that changes array indices.\n\nThe problem manifests when a system processes entities and decides to add or remove components based on current state. For example, a collision system detecting overlap might try to add a `Collision` component to entities during iteration, or a health system might remove entities that reach zero health.\n\n**How to fix**: Collect modification requests during iteration and apply them after iteration completes. Use separate arrays to track entities requiring component changes, then process these requests in a second pass once iteration finishes.\n\n⚠️ **Pitfall: Cross-System Data Dependencies Without Ordering**\n\nSystems that read data written by other systems can produce inconsistent results if execution order isn't properly managed. This commonly occurs with transform hierarchies where child transforms depend on parent updates, or physics systems where collision detection depends on movement calculations.\n\nThe bug appears as frame-to-frame inconsistency where results depend on arbitrary system execution order. Child objects might lag one frame behind parent movement, or collision detection might use stale position data from the previous frame.\n\n**How to fix**: Explicitly declare system dependencies during registration and ensure the execution pipeline respects these constraints. Use dependency injection or event systems for loose coupling between systems that don't require strict ordering.\n\n⚠️ **Pitfall: Memory Fragmentation from Frequent Archetype Changes**\n\nDynamic component addition and removal can cause excessive memory allocations and fragmentation if entities frequently change archetypes. This particularly affects games with state-based entities (e.g., units that gain/lose abilities) or temporary effect systems.\n\nPerformance degrades over time as memory becomes fragmented and archetype arrays require frequent reallocation. The frame time budget gets consumed by memory management rather than game logic.\n\n**How to fix**: Design component hierarchies to minimize archetype transitions. Use component data fields to represent state changes rather than adding/removing entire components. Consider pooling strategies for temporary components or effects.\n\n⚠️ **Pitfall: Component Access After Entity Destruction**\n\nSystems holding entity references from previous frames may attempt component access after entity destruction, leading to stale pointer dereference or incorrect component data retrieval from recycled entity slots.\n\nThis typically occurs when one system destroys an entity while another system maintains a cached reference list. The destroying system recycles the entity ID, but cached references remain valid-looking until they're used.\n\n**How to fix**: Use generation-based entity validation before component access. Implement automatic reference invalidation when entities are destroyed, or design systems to re-query entity lists each frame rather than caching references across frames.\n\n### Implementation Guidance\n\nThe ECS implementation requires careful attention to memory layout, data structures, and algorithm efficiency to achieve the performance targets necessary for real-time game processing. The following code provides the foundation for a cache-friendly, high-performance entity component system.\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Entity Storage | `std::vector` with free list | Custom memory pools with generation arrays |\n| Component Arrays | `std::vector<T>` per component type | Template metaprogramming with type erasure |\n| Archetype Management | Manual type registration | Compile-time signature generation |\n| System Scheduling | Linear execution order | Task-based parallelism with work stealing |\n| Memory Allocation | Standard allocators | Custom block allocators for component data |\n\n**File Structure**\n\n```\nsrc/ecs/\n  entity.h                   ← Entity ID structure and utilities\n  entity.cpp\n  component_array.h          ← Template component storage\n  component_array.inl        ← Template implementation\n  ecs_world.h               ← Main ECS coordinator\n  ecs_world.cpp\n  system_base.h             ← System interface and registration\n  system_base.cpp\n  archetype.h               ← Archetype management\n  archetype.cpp\ntests/ecs/\n  entity_tests.cpp          ← Entity lifecycle and validation\n  component_storage_tests.cpp ← Component CRUD operations\n  system_pipeline_tests.cpp  ← System execution and dependencies\n```\n\n**Entity Infrastructure Code**\n\n```cpp\n// entity.h - Complete entity ID management system\n#pragma once\n#include <cstdint>\n#include <vector>\n#include <queue>\n\n// Entity ID bit layout: [Generation:10][Index:22]\nconstexpr uint32_t INDEX_BITS = 22;\nconstexpr uint32_t GENERATION_BITS = 10;\nconstexpr uint32_t INDEX_MASK = (1u << INDEX_BITS) - 1;\nconstexpr uint32_t GENERATION_MASK = (1u << GENERATION_BITS) - 1;\nconstexpr uint32_t MAX_ENTITIES = 1u << INDEX_BITS;\n\nstruct Entity {\n    uint32_t m_id;\n    \n    Entity() : m_id(0) {}\n    explicit Entity(uint32_t id) : m_id(id) {}\n    \n    uint32_t GetIndex() const { return m_id & INDEX_MASK; }\n    uint32_t GetGeneration() const { return (m_id >> INDEX_BITS) & GENERATION_MASK; }\n    uint32_t GetID() const { return m_id; }\n    bool IsValid() const { return m_id != 0; }\n    \n    bool operator==(const Entity& other) const { return m_id == other.m_id; }\n    bool operator!=(const Entity& other) const { return m_id != other.m_id; }\n};\n\nconstexpr Entity NULL_ENTITY{0};\n\n// Entity manager handles ID allocation and recycling\nclass EntityManager {\nprivate:\n    std::vector<uint32_t> m_generations;  // Generation per index slot\n    std::queue<uint32_t> m_freeIndices;   // Recycled indices\n    uint32_t m_nextIndex;                 // Next new index to allocate\n    \npublic:\n    EntityManager() : m_nextIndex(1) {}  // Start at 1, reserve 0 for NULL_ENTITY\n    \n    Entity CreateEntity();\n    void DestroyEntity(Entity entity);\n    bool IsValid(Entity entity) const;\n};\n\n// Hash function for Entity to use in unordered containers\nnamespace std {\n    template<>\n    struct hash<Entity> {\n        size_t operator()(const Entity& entity) const {\n            return hash<uint32_t>()(entity.GetID());\n        }\n    };\n}\n```\n\n**Component Storage Infrastructure Code**\n\n```cpp\n// component_array.h - Dense component storage template\n#pragma once\n#include \"entity.h\"\n#include <vector>\n#include <unordered_map>\n#include <cassert>\n\ntemplate<typename T>\nclass ComponentArray {\nprivate:\n    std::vector<T> m_components;                    // Dense component data\n    std::unordered_map<Entity, size_t> m_entityToIndex;  // Sparse entity lookup\n    std::vector<Entity> m_indexToEntity;           // Dense index to entity mapping\n    std::vector<size_t> m_freeIndices;             // Recycled indices for reuse\n    \npublic:\n    // Add component with perfect forwarding\n    template<typename... Args>\n    T& AddComponent(Entity entity, Args&&... args);\n    \n    // Remove component using swap-and-pop\n    void RemoveComponent(Entity entity);\n    \n    // Get component pointer (nullptr if not found)\n    T* GetComponent(Entity entity);\n    const T* GetComponent(Entity entity) const;\n    \n    // Check component existence\n    bool HasComponent(Entity entity) const;\n    \n    // Get entity for dense array index\n    Entity GetEntity(size_t index) const;\n    \n    // Iteration support\n    size_t Size() const { return m_components.size() - m_freeIndices.size(); }\n    T* Data() { return m_components.data(); }\n    const T* Data() const { return m_components.data(); }\n    \n    // Clear all components\n    void Clear();\n};\n\n// Type-erased interface for component storage\nclass IComponentArray {\npublic:\n    virtual ~IComponentArray() = default;\n    virtual void RemoveEntity(Entity entity) = 0;\n    virtual void Clear() = 0;\n};\n\n// Type-erased wrapper for ComponentArray<T>\ntemplate<typename T>\nclass ComponentArrayWrapper : public IComponentArray {\nprivate:\n    ComponentArray<T> m_array;\n    \npublic:\n    ComponentArray<T>& GetArray() { return m_array; }\n    \n    void RemoveEntity(Entity entity) override {\n        if (m_array.HasComponent(entity)) {\n            m_array.RemoveComponent(entity);\n        }\n    }\n    \n    void Clear() override {\n        m_array.Clear();\n    }\n};\n```\n\n**Core ECS Logic Skeleton**\n\n```cpp\n// ecs_world.h - Main ECS coordinator\n#pragma once\n#include \"entity.h\"\n#include \"component_array.h\"\n#include \"system_base.h\"\n#include <memory>\n#include <unordered_map>\n#include <typeindex>\n\nclass ECSWorld {\nprivate:\n    EntityManager m_entityManager;\n    std::unordered_map<std::type_index, std::unique_ptr<IComponentArray>> m_componentArrays;\n    std::vector<std::unique_ptr<SystemBase>> m_systems;\n    \n    template<typename T>\n    ComponentArray<T>* GetComponentArray();\n    \npublic:\n    // Entity management\n    Entity CreateEntity() {\n        // TODO 1: Call entity manager to create new entity ID\n        // TODO 2: Return the created entity for component attachment\n    }\n    \n    void DestroyEntity(Entity entity) {\n        // TODO 1: Validate entity exists and is valid\n        // TODO 2: Remove entity from all component arrays\n        // TODO 3: Call entity manager to recycle entity ID\n        // TODO 4: Notify systems that entity was destroyed\n    }\n    \n    // Component management\n    template<typename T, typename... Args>\n    T& AddComponent(Entity entity, Args&&... args) {\n        // TODO 1: Get or create component array for type T\n        // TODO 2: Verify entity doesn't already have this component\n        // TODO 3: Add component with perfect forwarding of arguments\n        // TODO 4: Update entity's archetype signature\n        // TODO 5: Return reference to new component\n    }\n    \n    template<typename T>\n    void RemoveComponent(Entity entity) {\n        // TODO 1: Get component array for type T\n        // TODO 2: Verify entity has this component type\n        // TODO 3: Remove component from storage\n        // TODO 4: Update entity's archetype signature\n    }\n    \n    template<typename T>\n    T* GetComponent(Entity entity) {\n        // TODO 1: Get component array for type T\n        // TODO 2: Return component pointer or nullptr\n        // Hint: Use GetComponentArray<T>() helper method\n    }\n    \n    template<typename T>\n    bool HasComponent(Entity entity) const {\n        // TODO 1: Find component array for type T\n        // TODO 2: Check if entity exists in that array\n        // TODO 3: Return boolean result\n    }\n    \n    // System management\n    template<typename T, typename... Args>\n    void RegisterSystem(Args&&... args) {\n        // TODO 1: Create system instance with forwarded arguments\n        // TODO 2: Add to systems vector for execution\n        // TODO 3: Allow system to register component dependencies\n    }\n    \n    void UpdateSystems(float deltaTime) {\n        // TODO 1: Iterate through all registered systems\n        // TODO 2: Call Update method on each system with delta time\n        // TODO 3: Handle any system-requested entity/component changes\n        // TODO 4: Apply deferred operations after all systems complete\n    }\n};\n\n// System base class for type erasure\nclass SystemBase {\npublic:\n    virtual ~SystemBase() = default;\n    virtual void Update(ECSWorld& world, float deltaTime) = 0;\n    virtual void OnEntityDestroyed(Entity entity) {}\n};\n\n// Helper template for implementing systems\ntemplate<typename Derived>\nclass System : public SystemBase {\npublic:\n    void Update(ECSWorld& world, float deltaTime) override {\n        static_cast<Derived*>(this)->Update(world, deltaTime);\n    }\n};\n```\n\n**Example System Implementation**\n\n```cpp\n// Example: MovementSystem that updates transform positions based on velocity\nclass MovementSystem : public System<MovementSystem> {\npublic:\n    void Update(ECSWorld& world, float deltaTime) {\n        // TODO 1: Query for entities with both Transform and RigidBody components\n        // TODO 2: Iterate through component arrays in parallel\n        // TODO 3: Apply velocity to position: position += velocity * deltaTime\n        // TODO 4: Apply acceleration to velocity: velocity += acceleration * deltaTime\n        // TODO 5: Handle any collision or boundary constraints\n        \n        // Implementation hint:\n        // - Use dense array iteration for performance\n        // - Access components through entity indices\n        // - Modify transform positions in-place\n    }\n};\n```\n\n**Milestone Checkpoint**\n\nAfter implementing the ECS foundation:\n\n1. **Entity Creation Test**: Create 1000 entities, verify unique IDs and proper recycling\n   ```cpp\n   // Expected: All entity IDs unique, generations increment on recycling\n   auto entities = std::vector<Entity>();\n   for (int i = 0; i < 1000; ++i) {\n       entities.push_back(world.CreateEntity());\n   }\n   // Verify no duplicate IDs\n   ```\n\n2. **Component Storage Test**: Add/remove components and verify dense array maintenance\n   ```cpp\n   // Expected: Components stored contiguously, swap-and-pop on removal\n   auto entity = world.CreateEntity();\n   auto& transform = world.AddComponent<Transform>(entity, Vector3{1,2,3});\n   assert(world.HasComponent<Transform>(entity));\n   world.RemoveComponent<Transform>(entity);\n   assert(!world.HasComponent<Transform>(entity));\n   ```\n\n3. **System Execution Test**: Register systems and verify correct update order\n   ```cpp\n   // Expected: Systems execute in registration order, receive deltaTime\n   world.RegisterSystem<MovementSystem>();\n   world.RegisterSystem<RenderSystem>();\n   world.UpdateSystems(0.016f);  // 60fps frame time\n   ```\n\n**Performance Debugging**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Slow system iteration | Non-contiguous component data | Profile cache misses | Use dense arrays, avoid pointer chasing |\n| Memory leaks | Components not destroyed | Check entity destruction | Ensure all component arrays cleaned up |\n| Stale entity access | Generation mismatch | Add entity validation | Check generations before component access |\n| Frame time spikes | Archetype migrations | Profile allocation calls | Minimize dynamic component changes |\n\n\n## Physics and Collision System\n\n> **Milestone(s):** Milestone 3 (Physics & Collision) — 2D rigid body physics with collision detection, spatial partitioning, and deterministic simulation\n\nThe physics system in a game engine is like the **laws of nature** that govern how objects move, collide, and respond to forces in your virtual world. Just as real physics determines whether a billiard ball bounces off the table's edge or sinks into a pocket, your game's physics system calculates trajectories, detects collisions, and applies realistic responses that make virtual objects behave convincingly.\n\n### Mental Model: Billiard Table Simulation\n\nUnderstanding physics simulation becomes intuitive when you think of it as an automated billiard table that plays out thousands of scenarios per second. In this mental model:\n\n**The Table Surface** represents your game world's coordinate space. Objects move across this surface according to velocity and acceleration, just like billiard balls rolling with initial momentum and gradually slowing due to friction.\n\n**The Cue Stick** represents forces applied to objects. When you apply a force to a `RigidBody`, you're essentially giving it a \"cue stick hit\" that changes its velocity. The magnitude and direction of the force determine how dramatically the object's motion changes.\n\n**Predicting the Ball's Path** is what physics integration does every frame. The system calculates where each object will be in the next instant based on its current velocity, just like an experienced player visualizing where the cue ball will travel.\n\n**The Moment of Contact** represents collision detection. The system must predict exactly when and where two objects will touch, similar to calculating the precise moment two billiard balls will collide based on their trajectories.\n\n**The Bounce and Spin** after impact represents collision response. When two objects collide, the physics system calculates how they should react — do they bounce apart, stick together, or transfer momentum? This is like calculating how billiard balls should behave after they strike each other.\n\n**Keeping Perfect Time** is why deterministic simulation matters. In a real billiard game, the laws of physics are consistent — the same shot will always produce the same result. Your physics system must maintain this consistency by using fixed time steps, ensuring that replaying the same sequence of inputs always produces identical outcomes.\n\nThis billiard table metaphor helps explain why physics systems need spatial partitioning (you only check collisions between balls that could possibly hit each other), why fixed timesteps matter (consistent \"frame rate\" for physics calculations), and why collision response is complex (different materials and impact angles produce different bounce behaviors).\n\n### Collision Detection Pipeline\n\nThe collision detection pipeline operates like a **two-stage security system** at an airport. The first stage (broad phase) quickly identifies potential threats using simple, fast checks. The second stage (narrow phase) performs detailed examination only on flagged items. This approach prevents the system from wasting computational resources on impossible collisions while ensuring accuracy for objects that might actually intersect.\n\n#### Broad Phase Spatial Partitioning\n\nThe broad phase uses **spatial partitioning** to dramatically reduce the number of collision checks from O(n²) to approximately O(n log n) or better. Without spatial partitioning, a world with 1000 objects would require 499,500 collision checks per frame. With proper partitioning, this typically reduces to a few thousand checks.\n\nThe system divides the game world into a grid or hierarchical structure where each cell contains references to objects whose bounding boxes overlap that region. When an object moves, the system updates which cells contain that object. During collision detection, each object only tests against other objects in the same cells.\n\n| Spatial Structure | Cell Update Cost | Query Cost | Memory Usage | Best For |\n|-------------------|------------------|------------|--------------|----------|\n| Uniform Grid | O(1) | O(1) average | High (sparse areas waste space) | Evenly distributed objects |\n| Quadtree | O(log n) | O(log n) | Low (adaptive subdivision) | Clustered objects |\n| Hash Grid | O(1) | O(1) average | Medium (hash collisions possible) | Mixed distributions |\n\nThe broad phase maintains a list of `CollisionPair` candidates that represents potentially colliding entities. This list gets regenerated each frame based on the current spatial partitioning state.\n\n**Broad Phase Algorithm:**\n1. Clear the previous frame's collision pair list to start fresh\n2. For each active entity with a collision component, update its spatial grid position based on its current bounding box\n3. For each grid cell that contains multiple entities, generate collision pairs between all entities in that cell\n4. For entities whose bounding boxes span multiple cells, check against entities in all overlapping cells to avoid missing collisions\n5. Apply additional broad phase filtering (such as collision layer masks) to eliminate pairs that should never collide\n6. Sort the resulting collision pairs by entity ID for consistent processing order and potential cache benefits\n7. Pass the filtered collision pair list to the narrow phase for precise geometric testing\n\n#### Narrow Phase Geometric Testing\n\nThe narrow phase performs precise geometric intersection tests on collision pairs that survived the broad phase. This stage determines not just whether objects are colliding, but also calculates the exact contact points, penetration depth, and collision normals needed for response.\n\nFor 2D games, the narrow phase typically handles several collision shape combinations:\n\n| Shape A | Shape B | Test Method | Complexity | Contact Info |\n|---------|---------|-------------|------------|--------------|\n| `AABB` | `AABB` | Interval overlap test | O(1) | Contact normal, penetration depth |\n| `Circle` | `Circle` | Distance comparison | O(1) | Contact point, penetration depth |\n| `AABB` | `Circle` | Closest point on box | O(1) | Contact point, normal |\n| `Circle` | `AABB` | Distance to closest box edge | O(1) | Contact point, normal |\n\nThe narrow phase populates detailed `CollisionPair` structures that contain all information needed for collision response:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| entityA | `Entity` | First colliding entity ID |\n| entityB | `Entity` | Second colliding entity ID |\n| contactPoint | `Vector2` | World position where collision occurred |\n| normal | `Vector2` | Unit vector pointing from A toward B at contact |\n| penetration | `float` | How far the objects have overlapped |\n| relativeVelocity | `Vector2` | Velocity of A relative to B at contact point |\n| restitution | `float` | Combined bounciness factor (0=stick, 1=perfect bounce) |\n| friction | `float` | Combined friction coefficient for tangential forces |\n\n**Narrow Phase Algorithm:**\n1. Iterate through each collision pair from the broad phase in consistent order\n2. Retrieve the collision shape components for both entities (AABB, Circle, etc.)\n3. Apply the appropriate geometric intersection test based on the shape combination\n4. If no intersection exists, skip this pair and continue to the next\n5. Calculate the contact point as the closest point between the two shapes\n6. Compute the collision normal as the unit vector pointing from the first shape toward the second\n7. Determine penetration depth as the minimum distance needed to separate the objects\n8. Store all collision information in a `CollisionPair` structure for the response phase\n9. Add the completed collision pair to the active collisions list for this frame\n\n#### Collision Detection Data Structures\n\nThe collision detection system uses several key data structures to efficiently organize and process collision information:\n\n**AABB Structure:**\n| Field | Type | Description |\n|-------|------|-------------|\n| min | `Vector2` | Bottom-left corner of bounding box |\n| max | `Vector2` | Top-right corner of bounding box |\n| center | `Vector2` | Computed center point (min + max) / 2 |\n| extents | `Vector2` | Half-width and half-height (max - min) / 2 |\n\n**Circle Structure:**\n| Field | Type | Description |\n|-------|------|-------------|\n| center | `Vector2` | World position of circle center |\n| radius | `float` | Collision radius in world units |\n\n**CollisionPair Structure:**\n| Field | Type | Description |\n|-------|------|-------------|\n| entityA | `Entity` | First entity in collision |\n| entityB | `Entity` | Second entity in collision |\n| contactPoint | `Vector2` | World position of contact |\n| normal | `Vector2` | Collision normal (A toward B) |\n| penetration | `float` | Overlap distance |\n| restitution | `float` | Bounce factor (0-1) |\n| friction | `float` | Surface friction coefficient |\n\n![Collision Detection Pipeline](./diagrams/collision-detection.svg)\n\n### Physics Integration and Timestep\n\nPhysics integration is like the **metronome** that keeps your virtual world's temporal rhythm consistent and predictable. Just as a metronome ensures musicians play at the same tempo regardless of their individual interpretations, fixed timestep integration ensures your physics simulation produces identical results regardless of frame rate variations or performance fluctuations.\n\n#### Fixed Timestep Architecture\n\nThe physics system uses a **fixed timestep accumulator** pattern that decouples physics simulation from rendering frame rate. This approach accumulates real elapsed time until enough has passed to warrant one or more physics steps, then processes physics in consistent time increments.\n\nThe accumulator pattern works by maintaining a time debt that represents how much simulation time needs to be processed. Each frame, real elapsed time gets added to this debt. The system then \"pays off\" the debt by running fixed-timestep physics updates until the remaining debt is less than one timestep.\n\n**Fixed Timestep Algorithm:**\n1. Measure the actual elapsed time since the last frame using high-precision timing\n2. Add the elapsed time to the physics time accumulator (capped to prevent spiral of death)\n3. While the accumulator contains at least one full physics timestep worth of time:\n   a. Execute one complete physics update using the fixed timestep duration\n   b. Subtract one timestep's worth of time from the accumulator\n   c. Increment the physics step counter for debugging and profiling\n4. Calculate an interpolation factor (accumulator / timestep) for smooth rendering between physics steps\n5. Store the interpolation factor for use during rendering to smooth object positions\n\nThis approach ensures that physics always runs at exactly the same rate (typically 60Hz or 120Hz), regardless of whether rendering runs at 30fps, 60fps, 144fps, or varies unpredictably.\n\n**Physics Timestep Constants:**\n| Constant | Value | Description |\n|----------|--------|-------------|\n| `PHYSICS_TIMESTEP` | 1.0f/60.0f (16.67ms) | Fixed time increment for physics |\n| `MAX_TIMESTEP` | 1.0f/20.0f (50ms) | Maximum accumulated time per frame |\n| `ACCUMULATOR_THRESHOLD` | `PHYSICS_TIMESTEP` | Minimum time needed for physics step |\n\n#### Velocity and Position Integration\n\nThe physics system uses **semi-implicit Euler integration** (also called symplectic Euler) which provides better stability than explicit Euler integration while remaining computationally simple. This integration method updates velocity first, then uses the new velocity to update position, creating a slight coupling that improves energy conservation.\n\n**Semi-Implicit Euler Integration Algorithm:**\n1. Calculate the total acceleration for this timestep by summing all forces acting on the object and dividing by mass\n2. Apply drag/damping to the current velocity: `velocity *= (1.0f - drag * timestep)`\n3. Update velocity using acceleration: `velocity += acceleration * timestep`\n4. Update position using the newly calculated velocity: `position += velocity * timestep`\n5. Clear accumulated forces for the next timestep to prevent double-application\n6. Update the object's transform component with the new position for rendering\n\nThis integration approach maintains better energy conservation than explicit Euler (which tends to add energy to the system) and avoids the computational complexity of higher-order methods like Runge-Kutta.\n\n**RigidBody Physics Integration:**\n| Step | Operation | Formula | Purpose |\n|------|-----------|---------|---------|\n| 1 | Apply drag | `velocity *= (1 - drag * dt)` | Energy dissipation |\n| 2 | Update velocity | `velocity += acceleration * dt` | Force integration |\n| 3 | Update position | `position += velocity * dt` | Motion integration |\n| 4 | Clear forces | `acceleration = Vector2::Zero()` | Reset for next frame |\n\n#### Deterministic Simulation Requirements\n\nDeterministic physics simulation means that identical inputs always produce identical outputs, which is crucial for networked games, replay systems, and debugging. Achieving determinism requires careful attention to floating-point precision, operation ordering, and algorithmic consistency.\n\nThe physics system maintains determinism through several key practices:\n\n**Consistent Operation Ordering:** All physics operations process entities in the same order every frame, typically sorted by entity ID. This prevents different execution orders from causing floating-point precision differences to accumulate differently.\n\n**Fixed-Point Arithmetic Considerations:** While the implementation uses floating-point arithmetic for simplicity, production engines often use fixed-point math to guarantee bitwise-identical results across different processors and compiler optimizations.\n\n**Collision Processing Order:** Collision pairs are sorted by entity ID before processing to ensure that simultaneous collisions always resolve in the same sequence.\n\n**Force Application Consistency:** Forces are accumulated in a consistent order and applied all at once during integration, rather than being applied immediately when generated.\n\n> **Design Insight**: The accumulator pattern elegantly solves the \"spiral of death\" problem where slow frames could cause physics to take even longer, creating a feedback loop. By capping the maximum timestep, the system gracefully degrades performance rather than becoming completely unresponsive.\n\n### Collision Response and Resolution\n\nCollision response transforms the geometric information from collision detection into realistic physical reactions. This is like a **judicial system** that not only identifies when rules are broken (collision detection finds overlapping objects) but also determines the appropriate consequences and enforces them (collision response separates objects and applies forces).\n\n#### Impulse-Based Response Calculation\n\nWhen two objects collide, the collision response system calculates **impulse forces** that instantaneously change the velocities of both objects to simulate the brief, intense forces that occur during real collisions. This approach models the fact that most game collisions happen faster than the physics timestep can resolve.\n\nThe impulse calculation considers several physical properties: the masses of both objects, their relative velocity at the contact point, the collision normal direction, and material properties like restitution (bounciness) and friction.\n\n**Impulse Magnitude Calculation Algorithm:**\n1. Calculate the relative velocity of the two objects at the contact point: `relativeVelocity = velocityA - velocityB`\n2. Project the relative velocity onto the collision normal to find the separating velocity: `separatingVelocity = dot(relativeVelocity, normal)`\n3. If the separating velocity is positive, the objects are already moving apart, so skip collision response\n4. Calculate the desired final separating velocity after collision: `finalSeparatingVelocity = -restitution * separatingVelocity`\n5. Compute the impulse magnitude needed to achieve this velocity change: `impulseMagnitude = (finalSeparatingVelocity - separatingVelocity) / (1/massA + 1/massB)`\n6. Convert the impulse magnitude to a vector: `impulseVector = impulseMagnitude * normal`\n7. Apply the impulse to object A (positive) and object B (negative) to conserve momentum\n\n**Collision Response Data:**\n| Property | Source | Usage | Range |\n|----------|---------|--------|-------|\n| Restitution | Material properties | Controls bounciness | 0.0 (sticky) to 1.0 (perfect bounce) |\n| Friction | Material properties | Resists tangential motion | 0.0 (frictionless) to 1.0+ (high grip) |\n| Mass | `RigidBody` component | Affects impulse distribution | > 0.0 (infinite mass = kinematic) |\n| Relative velocity | Current object motion | Determines collision intensity | Calculated per collision |\n\n#### Position Correction and Penetration Resolution\n\nWhen collision detection finds overlapping objects, the collision response system must **separate** them to prevent visual artifacts and physics instability. This separation process, called position correction, moves objects apart by the minimum distance needed to eliminate overlap.\n\nPosition correction uses a technique called **linear projection** that moves both objects along the collision normal by distances proportional to their masses. Lighter objects move farther than heavier objects, and immovable (kinematic) objects don't move at all.\n\n**Position Correction Algorithm:**\n1. Calculate the total mass ratio: `totalInverseMass = 1/massA + 1/massB`\n2. If total inverse mass is zero (both objects are kinematic), skip position correction\n3. Determine the correction percentage to apply this frame (typically 80% to avoid overcorrection)\n4. Calculate the total correction distance: `correctionDistance = penetrationDepth * correctionPercentage`\n5. Compute individual correction distances: `correctionA = correctionDistance * (1/massA) / totalInverseMass`\n6. Apply position corrections: `positionA += correctionA * normal` and `positionB -= (correctionDistance - correctionA) * normal`\n7. Update the transform components with the corrected positions for immediate visual feedback\n\nThe position correction system uses a percentage-based approach (typically 80-90%) rather than full correction to avoid introducing energy into the system and causing jittery behavior when objects are in resting contact.\n\n#### Friction and Tangential Forces\n\nFriction modeling adds realism by resisting motion perpendicular to the collision normal. The friction system calculates tangential impulses that oppose relative sliding motion between colliding objects.\n\n**Friction Calculation Algorithm:**\n1. Calculate the tangent vector perpendicular to the collision normal: `tangent = relativeVelocity - dot(relativeVelocity, normal) * normal`, then normalize\n2. Compute the relative velocity along the tangent: `tangentialVelocity = dot(relativeVelocity, tangent)`\n3. Calculate the friction impulse magnitude: `frictionImpulse = -tangentialVelocity / (1/massA + 1/massB)`\n4. Apply Coulomb friction limiting: `maxFriction = frictionCoefficient * abs(normalImpulse)`\n5. Clamp the friction impulse: `frictionImpulse = clamp(frictionImpulse, -maxFriction, maxFriction)`\n6. Convert to vector and apply: `frictionVector = frictionImpulse * tangent`\n7. Apply friction impulses to both objects in opposite directions\n\n**Collision Response Components:**\n| Component | Responsibility | Key Operations |\n|-----------|----------------|----------------|\n| Impulse Calculator | Velocity changes | Normal impulse, restitution |\n| Position Corrector | Separation | Linear projection, penetration resolution |\n| Friction Resolver | Tangential forces | Coulomb friction, sliding resistance |\n| Material Manager | Physical properties | Restitution, friction coefficients |\n\n> **Critical Insight**: Collision response must carefully balance realism with stability. Too much correction creates jittery behavior, while too little allows objects to sink into each other. The 80% correction percentage represents a sweet spot that works well for most game scenarios.\n\n### Physics Architecture Decisions\n\nThe physics system's architecture involves several critical design decisions that significantly impact performance, accuracy, and implementation complexity. Each decision represents a trade-off between different system qualities, and understanding these trade-offs is essential for making appropriate choices for your specific game requirements.\n\n> **Decision: Fixed vs Variable Timestep**\n> - **Context**: Physics simulation requires consistent timing to produce predictable, stable results. Different timestep approaches offer different guarantees about consistency and performance.\n> - **Options Considered**: Variable timestep (use actual frame time), Semi-fixed timestep (clamp frame time), Fixed timestep with accumulator\n> - **Decision**: Fixed timestep with accumulator pattern\n> - **Rationale**: Fixed timestep provides deterministic simulation essential for networked games, replays, and debugging. The accumulator pattern decouples physics from rendering performance while preventing the \"spiral of death\" where slow physics makes subsequent frames even slower.\n> - **Consequences**: Requires interpolation between physics states for smooth rendering, adds complexity to the main loop, but guarantees consistent behavior across different hardware and performance conditions.\n\n| Timestep Approach | Determinism | Performance | Implementation Complexity | Best For |\n|-------------------|-------------|-------------|--------------------------|----------|\n| Variable timestep | No | Excellent | Low | Simple single-player games |\n| Clamped variable | Limited | Good | Low | Most single-player games |\n| Fixed with accumulator | Yes | Good | Medium | Networked/competitive games |\n| Multiple timesteps | Yes | Complex | High | Advanced simulation games |\n\n> **Decision: Spatial Partitioning Algorithm**\n> - **Context**: Collision detection requires checking interactions between objects, which scales as O(n²) without optimization. Spatial partitioning reduces this cost by grouping nearby objects.\n> - **Options Considered**: Uniform grid, Adaptive quadtree, Spatial hashing\n> - **Decision**: Uniform grid with configurable cell size\n> - **Rationale**: Uniform grids provide O(1) insertion/removal and work well for games with relatively even object distribution. The simplicity aids debugging and the performance is predictable.\n> - **Consequences**: Less efficient for games with highly clustered objects, wastes memory in sparse areas, but provides excellent performance for typical 2D games with moderate object density.\n\n| Spatial Structure | Insert/Remove | Query | Memory | Object Distribution |\n|-------------------|---------------|-------|--------|-------------------|\n| Uniform Grid | O(1) | O(1) avg | High | Even distribution |\n| Quadtree | O(log n) | O(log n) | Low | Clustered objects |\n| Hash Grid | O(1) | O(1) avg | Medium | Mixed distribution |\n| No partitioning | O(1) | O(n) | Low | Very few objects (<50) |\n\n> **Decision: Collision Response Method**\n> - **Context**: When objects collide, the system must calculate realistic physical responses while maintaining simulation stability and performance.\n> - **Options Considered**: Penalty forces (spring-based), Impulse-based response, Constraint-based solving\n> - **Decision**: Impulse-based response with position correction\n> - **Rationale**: Impulse methods provide good realism with simple implementation. Position correction prevents overlap accumulation without the complexity of constraint solvers.\n> - **Consequences**: Handles most collision scenarios well, may struggle with complex multi-contact situations, but offers excellent performance-to-quality ratio for 2D games.\n\n| Response Method | Realism | Stability | Performance | Implementation |\n|-----------------|---------|-----------|-------------|----------------|\n| Penalty forces | Medium | Poor | Excellent | Simple |\n| Impulse-based | Good | Good | Good | Medium |\n| Constraint solving | Excellent | Excellent | Poor | Complex |\n\n> **Decision: Integration Method**\n> - **Context**: Physics integration determines how forces and velocities update object positions over time. Different methods offer trade-offs between accuracy, stability, and computational cost.\n> - **Options Considered**: Explicit Euler, Semi-implicit Euler, Verlet integration, Runge-Kutta 4th order\n> - **Decision**: Semi-implicit Euler integration\n> - **Rationale**: Semi-implicit Euler provides better energy conservation than explicit Euler while remaining computationally simple. It handles typical game physics scenarios well without the complexity of higher-order methods.\n> - **Consequences**: Good stability for most game scenarios, occasional energy drift in extreme cases, but excellent performance and simplicity make it ideal for real-time games.\n\n| Integration Method | Stability | Accuracy | Performance | Energy Conservation |\n|--------------------|-----------|----------|-------------|-------------------|\n| Explicit Euler | Poor | Low | Excellent | Poor (adds energy) |\n| Semi-implicit Euler | Good | Medium | Excellent | Good |\n| Verlet | Excellent | High | Good | Excellent |\n| RK4 | Excellent | Very High | Poor | Excellent |\n\n> **Decision: Broad Phase Algorithm Selection**\n> - **Context**: The broad phase must quickly identify potentially colliding object pairs from the full set of objects in the world, minimizing expensive narrow phase tests.\n> - **Options Considered**: Grid-based partitioning, Quadtree hierarchical subdivision, Sort-and-sweep along axes\n> - **Decision**: Grid-based spatial partitioning with dynamic cell sizing\n> - **Rationale**: Grid-based approaches offer constant-time insertion and lookup with predictable memory usage. Dynamic cell sizing adapts to object density for optimal performance.\n> - **Consequences**: Excellent performance for evenly distributed objects, simple debugging and visualization, but less optimal for highly clustered scenarios compared to hierarchical approaches.\n\n**Physics System Configuration:**\n| Parameter | Default Value | Range | Impact |\n|-----------|---------------|-------|--------|\n| Physics timestep | 16.67ms (60Hz) | 8-33ms | Simulation accuracy vs performance |\n| Max accumulated time | 100ms | 50-200ms | Spiral of death prevention |\n| Grid cell size | 64 units | 32-256 units | Collision detection performance |\n| Position correction | 80% | 50-100% | Stability vs convergence speed |\n| Velocity threshold | 0.01 units/s | 0.001-0.1 | Sleep/wake optimization |\n\n#### Common Pitfalls\n\n⚠️ **Pitfall: Variable Timestep Physics**\nPhysics that uses variable frame time (delta time from rendering) becomes non-deterministic and unstable. Fast-moving objects may tunnel through thin barriers during slow frames, while collision detection becomes inconsistent across different frame rates. The solution is implementing fixed timestep physics with an accumulator pattern that processes physics in consistent increments regardless of rendering performance.\n\n⚠️ **Pitfall: Missing Collision Velocity Checks**\nApplying collision response to objects that are already separating can cause them to \"stick\" together unnaturally. Always check that the relative velocity indicates the objects are approaching (`dot(relativeVelocity, normal) < 0`) before applying impulse forces. Objects moving apart should not have their separation velocity reduced.\n\n⚠️ **Pitfall: Excessive Position Correction**\nCorrecting 100% of penetration depth every frame causes objects to jitter when they come to rest against each other. Use partial correction (80-90%) to allow small overlaps that get resolved gradually, providing stable resting contact between objects.\n\n⚠️ **Pitfall: Broad Phase Cell Size Mismatch**\nUsing grid cells that are too small relative to object sizes forces objects to span multiple cells, increasing collision checks. Conversely, cells that are too large fail to eliminate distant objects from consideration. Optimal cell size is typically 1-2 times the average object size.\n\n⚠️ **Pitfall: Ignoring Mass in Collision Response**\nTreating all objects as having equal mass during collision response violates physical realism and creates strange behavior where small objects can dramatically affect large ones. Always consider inverse mass ratios when distributing impulse forces and position corrections between colliding objects.\n\n⚠️ **Pitfall: Tunneling Through Thin Objects**\nFast-moving objects can pass completely through thin barriers between physics frames. Implement continuous collision detection for high-speed objects or use swept collision volumes that consider the object's path between frames rather than just its current position.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Math Library | Custom `Vector2`/`Vector3` structs | GLM (OpenGL Mathematics) library |\n| Spatial Partitioning | Fixed uniform grid | Dynamic quadtree or spatial hash |\n| Physics Integration | Semi-implicit Euler | Verlet integration with constraints |\n| Collision Shapes | AABB and Circle only | Convex polygons and compound shapes |\n| Memory Management | Standard containers | Custom memory pools for hot objects |\n\n#### Recommended File Structure\n\n```cpp\nengine/\n  physics/\n    physics_world.h           ← Main physics system coordinator\n    physics_world.cpp\n    collision_detection.h     ← Broad and narrow phase collision detection\n    collision_detection.cpp\n    collision_response.h      ← Impulse calculation and position correction\n    collision_response.cpp\n    spatial_grid.h           ← Uniform grid spatial partitioning\n    spatial_grid.cpp\n    integrator.h             ← Physics integration (Euler, Verlet, etc.)\n    integrator.cpp\n    physics_components.h     ← RigidBody, Collider, and related components\n    physics_math.h          ← Vector math and physics utility functions\n    physics_math.cpp\n  components/\n    transform.h             ← Position, rotation, scale component\n    rigid_body.h           ← Physics properties: mass, velocity, forces\n    collider.h             ← Collision shapes: AABB, Circle, etc.\n```\n\n#### Infrastructure Starter Code\n\n**Physics Math Utilities (Complete Implementation):**\n\n```cpp\n// physics/physics_math.h\n#pragma once\n#include \"../engine_data_model.h\"\n#include <cmath>\n#include <algorithm>\n\nnamespace Physics {\n    \n// Vector operations optimized for physics calculations\ninline float Dot(const Vector2& a, const Vector2& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ninline float LengthSquared(const Vector2& v) {\n    return v.x * v.x + v.y * v.y;\n}\n\ninline float Length(const Vector2& v) {\n    return std::sqrt(LengthSquared(v));\n}\n\ninline Vector2 Normalize(const Vector2& v) {\n    float len = Length(v);\n    if (len < 1e-6f) return Vector2{0.0f, 0.0f};\n    return Vector2{v.x / len, v.y / len};\n}\n\ninline Vector2 Project(const Vector2& v, const Vector2& normal) {\n    return normal * Dot(v, normal);\n}\n\ninline Vector2 Reject(const Vector2& v, const Vector2& normal) {\n    return v - Project(v, normal);\n}\n\n// AABB operations for collision detection\nstruct AABBTest {\n    static bool Intersects(const AABB& a, const AABB& b) {\n        return (a.min.x <= b.max.x && a.max.x >= b.min.x) &&\n               (a.min.y <= b.max.y && a.max.y >= b.min.y);\n    }\n    \n    static Vector2 ClosestPointOnAABB(const AABB& box, const Vector2& point) {\n        return Vector2{\n            std::clamp(point.x, box.min.x, box.max.x),\n            std::clamp(point.y, box.min.y, box.max.y)\n        };\n    }\n    \n    static float PenetrationDepth(const AABB& a, const AABB& b) {\n        float xPenetration = std::min(a.max.x - b.min.x, b.max.x - a.min.x);\n        float yPenetration = std::min(a.max.y - b.min.y, b.max.y - a.min.y);\n        return std::min(xPenetration, yPenetration);\n    }\n};\n\n// Circle collision operations\nstruct CircleTest {\n    static bool Intersects(const Circle& a, const Circle& b) {\n        float distanceSquared = LengthSquared(a.center - b.center);\n        float radiusSum = a.radius + b.radius;\n        return distanceSquared <= radiusSum * radiusSum;\n    }\n    \n    static float PenetrationDepth(const Circle& a, const Circle& b) {\n        float distance = Length(a.center - b.center);\n        return (a.radius + b.radius) - distance;\n    }\n};\n\n} // namespace Physics\n```\n\n**Spatial Grid Implementation (Complete):**\n\n```cpp\n// physics/spatial_grid.h\n#pragma once\n#include \"../ecs/ecs_world.h\"\n#include \"../engine_data_model.h\"\n#include <vector>\n#include <unordered_map>\n\nclass SpatialGrid {\nprivate:\n    struct GridCell {\n        std::vector<Entity> entities;\n    };\n    \n    float m_cellSize;\n    std::unordered_map<uint64_t, GridCell> m_grid;\n    \n    uint64_t GetCellKey(int x, int y) const {\n        return (static_cast<uint64_t>(x) << 32) | static_cast<uint64_t>(y);\n    }\n    \n    Vector2 WorldToGrid(const Vector2& worldPos) const {\n        return Vector2{\n            std::floor(worldPos.x / m_cellSize),\n            std::floor(worldPos.y / m_cellSize)\n        };\n    }\n\npublic:\n    explicit SpatialGrid(float cellSize = 64.0f) : m_cellSize(cellSize) {}\n    \n    void Clear() {\n        for (auto& [key, cell] : m_grid) {\n            cell.entities.clear();\n        }\n    }\n    \n    void Insert(Entity entity, const AABB& bounds) {\n        Vector2 minCell = WorldToGrid(bounds.min);\n        Vector2 maxCell = WorldToGrid(bounds.max);\n        \n        for (int x = static_cast<int>(minCell.x); x <= static_cast<int>(maxCell.x); ++x) {\n            for (int y = static_cast<int>(minCell.y); y <= static_cast<int>(maxCell.y); ++y) {\n                uint64_t key = GetCellKey(x, y);\n                m_grid[key].entities.push_back(entity);\n            }\n        }\n    }\n    \n    std::vector<CollisionPair> GetPotentialCollisions() const {\n        std::vector<CollisionPair> pairs;\n        \n        for (const auto& [key, cell] : m_grid) {\n            const auto& entities = cell.entities;\n            for (size_t i = 0; i < entities.size(); ++i) {\n                for (size_t j = i + 1; j < entities.size(); ++j) {\n                    pairs.push_back({entities[i], entities[j]});\n                }\n            }\n        }\n        \n        return pairs;\n    }\n};\n```\n\n#### Core Logic Skeleton Code\n\n**Physics World Main Coordinator:**\n\n```cpp\n// physics/physics_world.h\n#pragma once\n#include \"../ecs/ecs_world.h\"\n#include \"spatial_grid.h\"\n#include \"collision_detection.h\"\n#include \"collision_response.h\"\n#include <vector>\n\nclass PhysicsWorld {\nprivate:\n    ECSWorld* m_ecsWorld;\n    SpatialGrid m_spatialGrid;\n    CollisionDetection m_collisionDetection;\n    CollisionResponse m_collisionResponse;\n    \n    float m_accumulator;\n    float m_timestep;\n    int m_maxStepsPerFrame;\n    \n    std::vector<CollisionPair> m_activeCollisions;\n\npublic:\n    PhysicsWorld(ECSWorld* ecsWorld, float timestep = 1.0f/60.0f);\n    \n    // Main physics update called from game loop\n    void Update(float deltaTime) {\n        // TODO 1: Add deltaTime to accumulator (clamp to prevent spiral of death)\n        // TODO 2: While accumulator >= timestep, perform fixed physics steps\n        // TODO 3: For each step: integrate forces, detect collisions, resolve responses\n        // TODO 4: Update transform components with new positions\n        // TODO 5: Calculate interpolation factor for smooth rendering\n        // Hint: Clamp deltaTime to 50ms max to prevent spiral of death\n    }\n\nprivate:\n    void StepSimulation(float dt) {\n        // TODO 1: Apply forces and integrate velocities/positions for all RigidBody components\n        // TODO 2: Update spatial grid with new entity positions\n        // TODO 3: Run broad phase collision detection to get potential pairs\n        // TODO 4: Run narrow phase to test actual intersections\n        // TODO 5: Apply collision responses and position corrections\n        // Hint: Process systems in order - integration first, then collision detection, then response\n    }\n    \n    void IntegrateMotion(float dt) {\n        // TODO 1: Query ECS for all entities with Transform and RigidBody components\n        // TODO 2: For each entity, apply semi-implicit Euler integration\n        // TODO 3: Update velocity: velocity += acceleration * dt\n        // TODO 4: Apply drag: velocity *= (1 - drag * dt)\n        // TODO 5: Update position: position += velocity * dt\n        // TODO 6: Update Transform component with new position\n        // Hint: Use ComponentQuery to iterate efficiently over entities\n    }\n};\n```\n\n**Collision Detection System:**\n\n```cpp\n// physics/collision_detection.h\n#pragma once\n#include \"../ecs/ecs_world.h\"\n#include \"../engine_data_model.h\"\n#include \"spatial_grid.h\"\n\nclass CollisionDetection {\nprivate:\n    ECSWorld* m_ecsWorld;\n    SpatialGrid* m_spatialGrid;\n\npublic:\n    CollisionDetection(ECSWorld* ecs, SpatialGrid* grid) \n        : m_ecsWorld(ecs), m_spatialGrid(grid) {}\n    \n    std::vector<CollisionPair> DetectCollisions() {\n        // TODO 1: Clear and rebuild spatial grid with current entity positions\n        // TODO 2: Get potential collision pairs from broad phase (spatial grid)\n        // TODO 3: For each potential pair, perform narrow phase geometric test\n        // TODO 4: If collision detected, calculate contact info (point, normal, penetration)\n        // TODO 5: Create CollisionPair with complete contact information\n        // TODO 6: Return list of actual collisions for response processing\n        // Hint: Sort collision pairs by entity ID for deterministic processing\n    }\n\nprivate:\n    bool TestAABBvsAABB(const AABB& a, const AABB& b, CollisionPair& result) {\n        // TODO 1: Check if bounding boxes overlap using interval test\n        // TODO 2: If overlapping, calculate penetration depth in X and Y\n        // TODO 3: Choose axis with minimum penetration as collision normal\n        // TODO 4: Calculate contact point as center of overlap region\n        // TODO 5: Set collision normal pointing from first object toward second\n        // TODO 6: Fill CollisionPair structure with contact information\n        // Hint: Penetration depth = min(maxA - minB, maxB - minA) for each axis\n    }\n    \n    bool TestCirclevsCircle(const Circle& a, const Circle& b, CollisionPair& result) {\n        // TODO 1: Calculate distance between circle centers\n        // TODO 2: Check if distance <= sum of radii (collision condition)\n        // TODO 3: Calculate penetration depth = radiusSum - distance\n        // TODO 4: Calculate collision normal = normalize(centerB - centerA)\n        // TODO 5: Calculate contact point on line between centers\n        // TODO 6: Fill CollisionPair with calculated contact information\n        // Hint: Handle edge case where circles have identical centers\n    }\n};\n```\n\n**Collision Response System:**\n\n```cpp\n// physics/collision_response.h\n#pragma once\n#include \"../ecs/ecs_world.h\"\n#include \"../engine_data_model.h\"\n\nclass CollisionResponse {\nprivate:\n    ECSWorld* m_ecsWorld;\n    float m_positionCorrectionPercent;\n    \npublic:\n    CollisionResponse(ECSWorld* ecs, float correctionPercent = 0.8f)\n        : m_ecsWorld(ecs), m_positionCorrectionPercent(correctionPercent) {}\n    \n    void ResolveCollisions(const std::vector<CollisionPair>& collisions) {\n        // TODO 1: For each collision pair, retrieve RigidBody components for both entities\n        // TODO 2: Calculate relative velocity at contact point\n        // TODO 3: Check if objects are separating (skip if already moving apart)\n        // TODO 4: Calculate impulse magnitude using restitution and mass\n        // TODO 5: Apply impulse to both objects (equal and opposite)\n        // TODO 6: Apply position correction to separate overlapping objects\n        // Hint: Process all velocity changes first, then all position corrections\n    }\n\nprivate:\n    void ApplyImpulse(Entity entityA, Entity entityB, const CollisionPair& collision) {\n        // TODO 1: Get RigidBody components for both entities\n        // TODO 2: Calculate relative velocity: velA - velB\n        // TODO 3: Project relative velocity onto collision normal\n        // TODO 4: If separating velocity > 0, objects already separating - return\n        // TODO 5: Calculate impulse: (-(1 + restitution) * separatingVel) / (1/massA + 1/massB)\n        // TODO 6: Apply impulse to velocities: velA += impulse/massA, velB -= impulse/massB\n        // Hint: Handle infinite mass (kinematic) objects by using massInv = 0\n    }\n    \n    void CorrectPositions(Entity entityA, Entity entityB, const CollisionPair& collision) {\n        // TODO 1: Calculate total inverse mass = 1/massA + 1/massB\n        // TODO 2: If total inverse mass == 0, both objects kinematic - return\n        // TODO 3: Calculate correction magnitude = penetration * correctionPercent\n        // TODO 4: Distribute correction based on mass ratios\n        // TODO 5: Move objects apart along collision normal\n        // TODO 6: Update Transform components with corrected positions\n        // Hint: Lighter objects move more than heavier objects\n    }\n};\n```\n\n#### Language-Specific Hints\n\n**C++ Physics Implementation Tips:**\n- Use `std::vector::reserve()` for collision pair containers to avoid repeated allocations during detection\n- Implement custom `Vector2` operators (`+`, `-`, `*`, `/`) for clean physics math code\n- Use `constexpr` for physics constants like `PHYSICS_TIMESTEP` to enable compile-time optimization\n- Consider `std::unordered_set` for tracking active collision pairs between frames\n- Use `alignas(16)` for `Vector2` structures to enable SIMD optimization in math operations\n\n**Memory Management for Physics:**\n- Pre-allocate collision pair vectors based on expected maximum object count\n- Use object pools for frequently created/destroyed physics components\n- Consider structure-of-arrays layout for hot physics data (separate position, velocity arrays)\n- Profile memory usage during collision detection - spatial partitioning can fragment memory\n\n**Performance Optimization:**\n- Implement sleeping for stationary objects to skip physics processing\n- Use squared distance comparisons to avoid expensive `sqrt()` calls\n- Batch similar collision shape tests together for better instruction cache usage\n- Consider fixed-point arithmetic for networked games requiring bitwise determinism\n\n#### Milestone Checkpoint\n\nAfter implementing the physics system, verify the following behavior:\n\n**Test Command:** Create a simple test scene with falling objects and static platforms.\n\n**Expected Results:**\n1. **Gravity Integration**: Objects with `RigidBody` components fall at consistent acceleration regardless of frame rate\n2. **Collision Detection**: Moving objects stop when they hit static platforms, with collision pairs logged to console\n3. **Collision Response**: Objects bounce realistically based on restitution values, with conservation of momentum\n4. **Spatial Partitioning**: Performance remains stable with 100+ objects (measure frame times)\n5. **Determinism**: Same input sequence produces identical simulation results across multiple runs\n\n**Manual Verification Steps:**\n1. Drop 10 identical objects from the same height - they should hit the ground simultaneously\n2. Adjust restitution from 0.0 to 1.0 - observe bouncing behavior from sticky to perfectly elastic\n3. Test collision between objects of different masses - lighter objects should be affected more\n4. Enable collision pair debug drawing - verify broad phase eliminates distant objects\n5. Measure physics step timing - should remain constant regardless of rendering frame rate\n\n**Performance Benchmarks:**\n- 100 objects: < 2ms per physics step\n- 500 objects: < 8ms per physics step\n- Spatial grid: < 1ms rebuild time per frame\n- Memory usage: < 1MB for collision data structures\n\n\n## Resource and Scene Management\n\n> **Milestone(s):** Milestone 4 (Resource & Scene Management) — asset loading, caching, and scene serialization system with reference counting and lifecycle management\n\nResource and scene management forms the **operational backbone** of a game engine, controlling how assets flow from disk storage into active memory and GPU resources. This system determines whether your engine can efficiently load and unload game content, transition between levels without memory leaks, and provide consistent access to shared resources across multiple game objects. The complexity lies not just in loading files, but in managing resource lifecycles, handling loading failures gracefully, and maintaining performance during scene transitions.\n\n### Mental Model: Library Check-out System\n\nUnderstanding resource management as a **library check-out system** provides intuitive insight into the core responsibilities and challenges. In a physical library, patrons check out books using a catalog system that tracks which books are available, who has borrowed them, and when they must be returned. The librarian maintains an inventory system that prevents duplicate acquisitions, handles damaged or missing books, and ensures popular resources remain accessible.\n\nSimilarly, a game engine's resource manager acts as a **digital librarian** that maintains a catalog of available assets (textures, meshes, audio clips, scene files), tracks which game systems are currently using each resource through **reference counting**, and automatically returns memory to the system when no entities need a particular asset anymore. The resource handles act like library cards—they provide indirect access to the actual resource while allowing the system to track usage and validate that the requested resource still exists.\n\nWhen a rendering system requests a texture for a sprite, it doesn't receive a direct memory pointer. Instead, it gets a `TextureHandle` that represents a **validated loan** of that resource. The resource manager maintains the actual texture data in GPU memory and can revoke access, reload damaged resources, or substitute fallback assets transparently. This indirection enables sophisticated lifecycle management that would be impossible with direct pointer access.\n\nThe scene management system extends this metaphor to **entire collections** of related resources. Loading a new game level is like checking out a complete course syllabus—dozens of related books, videos, and materials that must be acquired together, used in coordination, and returned as a group when the course ends.\n\n### Asset Loading Pipeline\n\nThe asset loading pipeline transforms files stored on disk into GPU-ready resources that can be efficiently accessed during frame rendering. This process involves multiple stages of validation, format conversion, and memory allocation that must handle both successful loads and various failure modes gracefully.\n\n#### File Format Support Strategy\n\nThe engine supports a **curated set of standard formats** chosen for broad compatibility and efficient loading characteristics. Rather than attempting to support every possible file format, the pipeline focuses on formats that provide good compression, fast loading times, and reliable cross-platform behavior.\n\n| Asset Type | Primary Format | Fallback Format | Loading Library | GPU Format | Rationale |\n|------------|----------------|-----------------|-----------------|------------|-----------|\n| Textures | PNG | JPEG | stb_image | RGBA8 | Lossless with transparency, widely supported |\n| 3D Meshes | OBJ | Custom Binary | tinyobjloader | Vertex Buffers | Text format for debugging, binary for performance |\n| Audio | WAV | OGG Vorbis | Custom + stb_vorbis | PCM Samples | Uncompressed for low latency, compressed for music |\n| Scenes | JSON | Binary | nlohmann::json | Entity-Component Data | Human readable for development, compact for shipping |\n| Shaders | GLSL | SPIR-V | Custom | Compiled Programs | Source for development, bytecode for deployment |\n\nThe loading pipeline implements a **format detection system** that examines file headers and extensions to determine the appropriate loader. This allows the engine to handle assets regardless of whether they have correct file extensions, and provides fallback options when primary loaders fail.\n\n#### Resource Loading State Machine\n\nEach resource progresses through a well-defined set of states during its lifecycle, from initial load request through active use and eventual cleanup. The state machine ensures consistent behavior and prevents common errors like using resources before they're ready or accessing freed memory.\n\n| Current State | Trigger Event | Next State | Actions Taken |\n|---------------|---------------|------------|---------------|\n| Unloaded | Load Request | Loading | Allocate handle, start async load, increment ref count |\n| Loading | Load Complete | Loaded | Store resource data, mark handle valid, notify waiters |\n| Loading | Load Failed | Error | Store error message, mark handle invalid, notify waiters |\n| Loaded | Additional Request | Loaded | Increment reference count, return existing handle |\n| Loaded | Release Request | Loaded | Decrement reference count, check for zero refs |\n| Loaded | Ref Count Zero | Unloaded | Free GPU memory, deallocate handle, mark invalid |\n| Error | Retry Request | Loading | Reset error state, restart async load process |\n| Error | Release Request | Unloaded | Clean up error state, deallocate handle |\n\n![Resource Loading and Caching](./diagrams/resource-lifecycle.svg)\n\nThe state machine implementation uses **atomic operations** for state transitions to ensure thread safety during asynchronous loading. Multiple game systems can request the same resource simultaneously without creating race conditions or duplicate loading operations.\n\n#### Asynchronous Loading Architecture\n\nModern games require **non-blocking asset loading** to maintain smooth frame rates during level transitions and streaming scenarios. The engine implements a **worker thread pool** dedicated to asset loading operations, allowing the main game thread to continue processing input and rendering while resources load in the background.\n\nThe asynchronous loading system consists of several coordinated components:\n\n1. **Load Request Queue**: Thread-safe queue where game systems submit asset loading requests with priority levels and completion callbacks\n2. **Worker Thread Pool**: Fixed number of background threads that process loading requests in priority order\n3. **Completion Notification System**: Mechanism for notifying requesting systems when loads complete or fail\n4. **Memory Staging Area**: Temporary storage for loaded asset data before transfer to final GPU or main memory locations\n5. **Progress Tracking**: System for monitoring loading progress and providing feedback to loading screens\n\nThe loading process follows this detailed sequence:\n\n1. Game system calls `ResourceManager::LoadAsync<TextureHandle>(\"texture.png\", callback)`\n2. Resource manager checks cache for existing handle with same path\n3. If found, increments reference count and invokes callback immediately with existing handle\n4. If not found, allocates new handle in Loading state and queues load request\n5. Worker thread dequeues request and opens file using appropriate format loader\n6. Raw file data is decoded into engine-native format (RGBA8 for textures, vertex arrays for meshes)\n7. Decoded data is transferred to GPU memory using OpenGL texture creation calls\n8. Handle state transitions to Loaded, GPU resource ID is stored in handle\n9. Completion callback is invoked on main thread with valid handle\n10. Requesting system can now use handle for rendering operations\n\n#### GPU Resource Upload Pipeline\n\nLoading asset data from disk represents only half of the resource loading challenge. The loaded data must be efficiently transferred to GPU memory and organized for optimal rendering performance. This **upload pipeline** handles the conversion from CPU-accessible asset data to GPU resources like textures, vertex buffers, and shader programs.\n\nThe GPU upload process varies significantly by resource type:\n\n**Texture Upload Process:**\n1. Decode image file into RGBA8 pixel array using `stb_image`\n2. Generate OpenGL texture object with `glGenTextures`\n3. Bind texture and configure filtering, wrapping, and mipmap parameters\n4. Upload pixel data to GPU with `glTexImage2D`\n5. Generate mipmaps for distance-based level-of-detail if requested\n6. Store texture ID and dimensions in `TextureHandle` for future access\n\n**Mesh Upload Process:**\n1. Parse OBJ file into arrays of vertex positions, normals, and texture coordinates\n2. Interleave vertex attributes into single array matching shader input layout\n3. Generate vertex buffer object (VBO) and vertex array object (VAO) with OpenGL\n4. Upload vertex data to GPU memory with `glBufferData`\n5. Configure vertex attribute pointers for position, normal, and texcoord data\n6. Store VAO ID and vertex count in `MeshHandle` for rendering\n\nThe upload pipeline implements **batching optimizations** to minimize GPU state changes. Multiple resources of the same type are uploaded together, texture atlases combine multiple small textures into larger GPU allocations, and vertex buffers are packed to reduce draw call overhead.\n\n> **Design Insight**: GPU memory allocation is expensive and permanent until explicitly freed. The upload pipeline front-loads all allocation costs during loading to ensure rendering performance remains consistent during gameplay.\n\n### Resource Cache and Handles\n\nThe resource cache provides **unified access** to all loaded assets through a handle-based system that abstracts memory management and provides thread-safe access patterns. Rather than exposing raw pointers to GPU resources, the engine issues handles that can be validated, reference-counted, and revoked when necessary.\n\n#### Handle-Based Resource Access\n\nResource handles solve several critical problems with direct pointer access: they prevent dangling pointer crashes when resources are unloaded, enable automatic memory management through reference counting, and provide type safety by encoding resource types directly in the handle value.\n\nEach resource handle contains three essential pieces of information encoded in a 64-bit unsigned integer:\n\n| Bit Range | Component | Purpose | Example Value |\n|-----------|-----------|---------|---------------|\n| 0-31 | Resource ID | Unique identifier within resource type | 1247 |\n| 32-47 | Version | Prevents access to freed and reallocated handles | 23 |\n| 48-63 | Type | Distinguishes texture, mesh, audio, scene handles | TYPE_TEXTURE |\n\nThe handle encoding enables **constant-time validation** and **type-safe access** without requiring string lookups or hash table operations. The resource manager can immediately determine whether a handle is valid by checking if the version matches the stored version for that resource ID.\n\n```\nHandle Structure (64-bit):\n[TYPE:16][VERSION:16][ID:32]\n```\n\nThe version component provides **ABA problem protection**—it prevents accessing a resource handle that points to a memory location that has been freed and reallocated for a different resource. Each time a resource ID is recycled, its version increments, making old handles detectably invalid.\n\n#### Reference Counting and Automatic Cleanup\n\nThe resource cache implements **automatic reference counting** to track which game systems are actively using each resource. When a system requests a resource handle, the reference count increments. When the system releases the handle (either explicitly or through destructor calls), the count decrements. Resources with zero references become candidates for automatic cleanup.\n\n| Operation | Reference Count Change | Cache Behavior |\n|-----------|------------------------|----------------|\n| `LoadResource()` | +1 | If resource exists, return existing handle; otherwise start loading |\n| `Handle Copy Constructor` | +1 | Multiple handles can reference same resource |\n| `Handle Destructor` | -1 | Automatically called when handles go out of scope |\n| `Release()` explicit call | -1 | Manual release for precise control |\n| Count reaches zero | N/A | Resource marked for cleanup, GPU memory freed |\n| `LoadResource()` after cleanup | +1 | Resource reloaded from disk if needed again |\n\nThe reference counting system uses **atomic operations** to ensure thread safety when multiple systems access the same resource simultaneously. The cache can handle scenarios like one system requesting a resource while another system is releasing its reference to the same resource.\n\n#### Cache Implementation Architecture\n\nThe resource cache organizes resources by type using **separate storage pools** for textures, meshes, audio clips, and scene data. This organization enables type-specific optimizations and prevents resource ID conflicts between different asset types.\n\n```\nCache Organization:\nResourceCache\n├── TexturePool: vector<TextureResource>\n├── MeshPool: vector<MeshResource> \n├── AudioPool: vector<AudioResource>\n└── ScenePool: vector<SceneResource>\n\nEach Pool Entry:\n- ResourceData: GPU IDs, dimensions, format info\n- ReferenceCount: atomic<uint32_t>\n- Version: uint16_t for handle validation\n- State: enum {Loading, Loaded, Error}\n- LoadPath: string for reloading\n```\n\nThe cache implements **generational garbage collection** for resource cleanup. Rather than immediately freeing resources when reference counts reach zero, the cache marks them as **candidates for collection** and performs cleanup during dedicated maintenance phases. This approach prevents performance hitches during gameplay and allows recently-used resources to remain cached for potential reuse.\n\n#### Thread Safety and Concurrent Access\n\nModern game engines require **concurrent access** to the resource cache from multiple threads: the main thread during rendering, background threads during loading, and potentially audio threads accessing sound resources. The cache implementation provides thread safety without compromising performance for the common case of accessing already-loaded resources.\n\nThe thread safety strategy combines **lock-free reads** for loaded resources with **fine-grained locking** for modification operations:\n\n1. **Handle Validation**: Uses atomic loads to read handle versions and resource states without locking\n2. **Reference Counting**: Uses atomic increment/decrement operations for thread-safe counting\n3. **Resource Loading**: Uses per-resource mutexes to prevent duplicate loading of the same asset\n4. **Cache Cleanup**: Uses write locks during garbage collection phases to ensure consistency\n\nThis design ensures that the common operations—validating handles and accessing loaded resource data—never block, while expensive operations like loading and cleanup use appropriate synchronization.\n\n> **Design Insight**: The resource cache optimizes for the 95% case where resources are already loaded and simply need to be accessed. Handle validation and resource data retrieval use lock-free atomic operations, while the rare cases of loading new resources or cleaning up unused resources accept the overhead of mutex synchronization.\n\n### Scene Serialization and Transitions\n\nScene management orchestrates the **coordinated loading and unloading** of entire game levels, including all entities, components, and referenced resources. Unlike individual resource loading, scene transitions must handle complex dependency graphs, maintain referential integrity, and provide atomic success-or-rollback behavior to prevent partially-loaded game states.\n\n#### Scene Data Format and Structure\n\nGame scenes represent **complete snapshots** of the entity-component world state at a specific point in time, along with metadata about required resources and system configurations. The engine supports both human-readable JSON format for development and compact binary format for production deployment.\n\nThe scene file structure captures all information needed to reconstruct the game world:\n\n| Section | Content | Example |\n|---------|---------|---------|\n| Scene Metadata | Version, creation date, dependencies | `{\"version\": 1, \"engine_version\": \"0.1.0\"}` |\n| Resource Manifest | List of all required assets with checksums | `{\"textures\": [\"player.png\", \"background.jpg\"]}` |\n| Entity Definitions | Complete entity-component data | `{\"entity_1\": {\"Transform\": {...}, \"Sprite\": {...}}}` |\n| System Configuration | Scene-specific system parameters | `{\"physics\": {\"gravity\": -9.8, \"timestep\": 0.016}}` |\n| Scene Graph | Hierarchical entity relationships | `{\"root\": {\"children\": [\"entity_1\", \"entity_2\"]}}` |\n\nThe serialization format uses **stable entity IDs** that remain consistent across save/load cycles, enabling save game compatibility and networking scenarios where entity references must be synchronized between different game instances.\n\n#### Entity-Component Serialization\n\nConverting the runtime entity-component state into serialized form requires handling **component polymorphism** and **resource references** while maintaining the data-oriented memory layout benefits of the ECS architecture. The serialization system must serialize each component type using its specific format while preserving entity relationships and component interdependencies.\n\n| Component Type | Serialization Format | Special Handling |\n|----------------|---------------------|------------------|\n| `Transform` | Direct value copy | None—simple POD structure |\n| `Sprite` | Texture handle conversion | Convert handle to asset path string |\n| `RigidBody` | Physics state with references | Handle collision shape references |\n| `AudioSource` | Audio settings + clip reference | Convert audio handle to asset path |\n| Custom Components | Reflection-based or manual | User-provided serialization functions |\n\nThe serialization process follows this detailed procedure:\n\n1. **Entity Enumeration**: Iterate through all valid entities in the ECS world, collecting their component signatures\n2. **Resource Path Resolution**: Convert all resource handles back to their original file paths for inclusion in the resource manifest\n3. **Component Serialization**: For each entity, serialize all attached components using type-specific serialization functions\n4. **Reference Validation**: Ensure all entity references (parent/child relationships, collision target references) point to entities that exist in the scene\n5. **Manifest Generation**: Create the complete list of external resources required by the serialized entities\n6. **File Writing**: Write the complete scene data to disk using either JSON or binary format with integrity checksums\n\nThe reverse process during scene loading validates the resource manifest, loads all required assets, creates entities with the correct IDs, and attaches components with properly-resolved resource references.\n\n#### Scene Transition Pipeline\n\nScene transitions represent one of the most complex operations in game engine architecture, requiring **atomic state management** to prevent partially-loaded game worlds and **resource lifecycle coordination** to avoid memory leaks and dangling references.\n\n![Scene Transition Flow](./diagrams/scene-management.svg)\n\nThe scene transition pipeline implements a **two-phase commit protocol** that ensures either complete success or complete rollback:\n\n**Phase 1: Preparation and Validation**\n1. Parse new scene file and validate format version compatibility\n2. Check resource manifest against available storage and memory limits\n3. Begin preloading all required resources in background threads\n4. Validate that all entity references and component dependencies can be satisfied\n5. Prepare temporary entity storage for the new scene data\n\n**Phase 2: Atomic Transition**\n6. Pause all game systems to prevent updates during transition\n7. Store current scene state if save-on-transition is requested\n8. Destroy all entities in current scene and decrement resource reference counts\n9. Create new entities from serialized data with resolved resource handles\n10. Resume game systems with new scene data active\n\nThe pipeline provides **rollback capability** if any step fails: if resource loading fails in Phase 1, the current scene remains unchanged; if entity creation fails in Phase 2, the system can restore the previous scene state and report the specific error.\n\n#### Memory Management During Transitions\n\nScene transitions create significant **memory pressure** as the system simultaneously holds resources for the outgoing scene (until cleanup completes) and incoming scene (during loading). The transition pipeline implements several strategies to minimize peak memory usage and prevent out-of-memory conditions:\n\n**Resource Sharing**: Resources used by both the current and incoming scene (common UI textures, sound effects, character assets) maintain their reference counts and avoid unnecessary unload/reload cycles.\n\n**Streaming Prioritization**: Critical resources for the new scene (player character, ground textures) receive loading priority over less essential assets (background music, ambient sound effects).\n\n**Cleanup Scheduling**: Resources from the previous scene are freed in dependency order—first entities release component references, then components release resource handles, finally resources with zero references free their GPU memory.\n\n**Memory Pool Recycling**: Entity and component storage pools retain their allocated memory between scenes, avoiding repeated heap allocation overhead for similarly-sized game levels.\n\nThe transition pipeline monitors available memory throughout the process and can implement **aggressive cleanup** (immediately freeing unused resources) or **conservative caching** (retaining recently-used resources) based on current memory pressure.\n\n> **Design Insight**: Scene transitions are the most memory-intensive operation in game engines. The two-phase commit protocol ensures atomic success/failure behavior, but the engine must carefully balance memory usage, loading performance, and user experience during the transition period.\n\n### Resource Architecture Decisions\n\nThe resource management system requires several fundamental architecture decisions that affect performance, memory usage, and implementation complexity throughout the engine. Each decision involves significant trade-offs that impact how game developers interact with the engine and what scenarios the engine can handle effectively.\n\n> **Decision: Handle-Based vs Direct Pointer Access**\n> - **Context**: Game systems need access to loaded resources like textures and meshes, but direct pointers create lifetime management problems\n> - **Options Considered**: Direct GPU resource pointers, weak pointer systems, handle-based access with validation\n> - **Decision**: Handle-based access with embedded versioning and reference counting\n> - **Rationale**: Handles prevent dangling pointer crashes, enable automatic memory management, and provide type safety with minimal runtime overhead\n> - **Consequences**: Enables safe resource lifecycle management but requires handle validation on each access and complicates direct resource manipulation\n\n| Option | Pros | Cons | Memory Overhead | Performance Impact |\n|--------|------|------|-----------------|-------------------|\n| Direct Pointers | Zero overhead, simple access | Dangling pointer crashes, manual lifetime management | None | Fastest access |\n| Weak Pointers | Automatic cleanup detection | Complex implementation, reference counting overhead | High (shared_ptr control blocks) | Moderate (atomic operations) |\n| **Handle-Based** | Safe lifetime management, type safety, validation | Handle validation cost, indirection overhead | Low (64-bit handles) | Low (single table lookup) |\n\nThe handle-based approach provides the best balance of safety, performance, and implementation simplicity for an educational engine that must handle resource loading errors gracefully.\n\n> **Decision: Synchronous vs Asynchronous Resource Loading**\n> - **Context**: Asset loading from disk can cause frame rate hitches, but asynchronous loading complicates resource availability checking\n> - **Options Considered**: Synchronous blocking loads, fully asynchronous with callbacks, hybrid approach with optional synchronous fallback\n> - **Decision**: Asynchronous loading with completion callbacks and synchronous fallback for critical resources\n> - **Rationale**: Maintains smooth frame rates during normal gameplay while allowing immediate loading for essential resources like fallback textures\n> - **Consequences**: Enables smooth gameplay experience but requires callback-based programming patterns and careful loading state management\n\n| Option | Pros | Cons | Implementation Complexity | User Experience |\n|--------|------|------|---------------------------|-----------------|\n| Synchronous Only | Simple implementation, immediate availability | Frame rate hitches, poor UX | Low | Poor (loading pauses) |\n| **Async + Sync Fallback** | Smooth performance, flexibility | Complex state management | Medium | Good (responsive with fallbacks) |\n| Async Only | Best performance, consistent patterns | Complex availability checking | High | Excellent (never blocks) |\n\nThe hybrid approach provides flexibility for different use cases while maintaining reasonable implementation complexity for educational purposes.\n\n> **Decision: JSON vs Binary Scene Serialization**\n> - **Context**: Scene files need to store entity-component data, with requirements for both human readability during development and compact size for distribution\n> - **Options Considered**: JSON only, binary only, hybrid format with JSON for development and binary for shipping\n> - **Decision**: Hybrid approach with JSON as primary format and binary as optimization option\n> - **Rationale**: JSON enables easy debugging, version control, and manual editing during development, while binary provides space efficiency for final game distribution\n> - **Consequences**: Supports both development and production needs but requires maintaining two serialization code paths\n\n| Option | Pros | Cons | File Size | Debug Ability | Chosen? |\n|--------|------|------|-----------|---------------|---------|\n| JSON Only | Human readable, standard tooling | Large files, slower parsing | Large | Excellent | For development |\n| Binary Only | Compact, fast parsing | Opaque files, hard to debug | Small | Poor | No |\n| **Hybrid Format** | Best of both worlds | Dual implementation complexity | Flexible | Good | Yes |\n\nThe hybrid approach acknowledges that development and production have different priorities and provides appropriate tools for each scenario.\n\n> **Decision: Reference Counting vs Garbage Collection**\n> - **Context**: Resources must be automatically freed when no longer in use, but different cleanup strategies have different performance characteristics\n> - **Options Considered**: Manual cleanup only, reference counting with immediate cleanup, mark-and-sweep garbage collection\n> - **Decision**: Reference counting with deferred cleanup during maintenance phases\n> - **Rationale**: Provides predictable resource cleanup without garbage collection pauses, while deferred cleanup prevents performance hitches from expensive GPU resource deallocation\n> - **Consequences**: Enables deterministic resource management with controlled cleanup timing but requires careful handling of circular references\n\n| Option | Pros | Cons | Cleanup Timing | Performance Impact |\n|--------|------|------|----------------|-------------------|\n| Manual Only | Full control, no overhead | Error-prone, memory leaks | Immediate | None |\n| **Reference Counting** | Automatic, deterministic | Cannot handle cycles, cleanup overhead | Predictable | Low |\n| Garbage Collection | Handles cycles, simple usage | Pause times, complex implementation | Unpredictable | Variable |\n\nReference counting provides the right balance of automation and predictability for a real-time game engine that cannot tolerate garbage collection pauses.\n\n### Common Pitfalls\n\nResource management presents several recurring challenges that can cause memory leaks, performance problems, or hard-to-debug crashes. Understanding these pitfalls helps developers implement robust resource systems from the beginning.\n\n⚠️ **Pitfall: Resource Handle Validation Skipping**\n\nMany developers skip handle validation checks in performance-critical code paths, assuming that handles will always remain valid throughout frame processing. However, resources can become invalid due to loading failures, memory pressure, or scene transitions that occur asynchronously.\n\n**Why this breaks**: Accessing an invalid handle can return stale resource data, cause OpenGL errors when using deallocated texture IDs, or crash the application when dereferencing null pointers in the resource storage arrays.\n\n**How to avoid**: Always call `IsValid()` on resource handles before accessing resource data, especially after scene transitions or during error recovery scenarios. The validation cost is minimal compared to debugging crashes caused by invalid resource access.\n\n⚠️ **Pitfall: Circular Resource Dependencies**\n\nScene files can inadvertently create circular references where Scene A references resources that depend on Scene B, which in turn references resources from Scene A. Reference counting systems cannot automatically clean up circular dependencies, leading to memory leaks.\n\n**Why this breaks**: Resources involved in circular references never reach zero reference count, preventing automatic cleanup. Over multiple scene transitions, memory usage grows continuously until the application runs out of memory.\n\n**How to avoid**: Design resource dependencies as a directed acyclic graph (DAG). Use dependency analysis tools during scene authoring to detect potential cycles, and implement explicit cleanup phases during scene transitions that break circular references.\n\n⚠️ **Pitfall: GPU Resource Upload Without Context Validation**\n\nLoading resources asynchronously requires transferring data to GPU memory using OpenGL calls, but these calls are only valid when the correct graphics context is active. Background loading threads often lack proper graphics context setup.\n\n**Why this breaks**: OpenGL calls from threads without active contexts either fail silently, cause graphics driver crashes, or corrupt GPU memory by writing to invalid locations.\n\n**How to avoid**: Implement a **two-stage loading process**: background threads handle file I/O and decode asset data into CPU memory, then the main thread with active graphics context handles GPU resource upload during designated upload phases.\n\n⚠️ **Pitfall: Scene Transition Atomicity Violations**\n\nFailing to implement atomic scene transitions can leave the game in partially-loaded states where some entities exist from the old scene while others belong to the new scene. This creates inconsistent game world state.\n\n**Why this breaks**: Systems processing entities during partial transitions may encounter missing components, invalid references between entities from different scenes, or resource handles that point to unloaded assets.\n\n**How to avoid**: Use the two-phase commit protocol for scene transitions: complete all loading and validation before making any changes to the active scene state. If any step fails, rollback to the previous consistent state rather than leaving the system in an intermediate configuration.\n\n### Implementation Guidance\n\nThe resource management system represents the most complex subsystem in the game engine, requiring careful coordination between file I/O, memory management, GPU resource handling, and multi-threaded programming. This implementation provides complete working code for the infrastructure components while leaving the core resource management logic for learners to implement.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option | Trade-offs |\n|-----------|---------------|-----------------|------------|\n| File I/O | Standard C++ fstream | Memory-mapped files with OS APIs | fstream is portable but slower; mmap is faster but platform-specific |\n| JSON Parsing | nlohmann::json library | Custom parser with faster allocation | nlohmann is full-featured but allocates heavily; custom parser needs more code |\n| Image Loading | stb_image single-header library | FreeImage or SOIL libraries | stb_image is lightweight; other libraries support more formats |\n| Threading | std::thread with std::mutex | Lock-free queues and atomics | Standard threading is easier to debug; lock-free is faster but complex |\n| GPU Upload | OpenGL immediate calls | Command buffers with batch upload | Immediate calls are simple; batching reduces driver overhead |\n\nFor an educational implementation, the simple options provide the best learning experience while avoiding unnecessary complexity in non-core areas.\n\n#### Recommended File Structure\n\n```cpp\n// Resource Management Module Organization\nsrc/\n├── resource/\n│   ├── ResourceManager.h           ← Main resource cache and handle management\n│   ├── ResourceManager.cpp         ← Core logic (learner implements)\n│   ├── ResourceHandle.h            ← Handle implementation (provided)\n│   ├── ResourceHandle.cpp          ← Handle validation and encoding\n│   ├── AssetLoaders.h              ← File format loading interfaces\n│   ├── AssetLoaders.cpp            ← Texture, mesh, audio loaders (provided)\n│   ├── ResourceTypes.h             ← Resource data structures\n│   └── AsyncLoader.h               ← Background loading system (provided)\n├── scene/\n│   ├── Scene.h                     ← Scene data structure and interface\n│   ├── Scene.cpp                   ← Scene logic (learner implements)\n│   ├── SceneSerializer.h           ← JSON/binary serialization interface\n│   ├── SceneSerializer.cpp         ← Serialization logic (learner implements)\n│   └── SceneManager.h              ← Scene transition management\n└── common/\n    ├── Handle.h                    ← Generic handle template\n    └── ThreadSafeQueue.h           ← Queue for async loading\n```\n\nThis organization separates the core learning challenges (resource management, scene serialization) from the supporting infrastructure that learners can use directly.\n\n#### Infrastructure Starter Code (Complete)\n\n**Handle.h - Generic Handle Template**\n```cpp\n#pragma once\n#include <cstdint>\n\ntemplate<typename T>\nclass Handle {\npublic:\n    static constexpr uint64_t NULL_HANDLE = 0;\n    static constexpr uint64_t TYPE_BITS = 16;\n    static constexpr uint64_t VERSION_BITS = 16;\n    static constexpr uint64_t ID_BITS = 32;\n    \n    static constexpr uint64_t TYPE_SHIFT = 48;\n    static constexpr uint64_t VERSION_SHIFT = 32;\n    static constexpr uint64_t ID_MASK = 0xFFFFFFFF;\n    static constexpr uint64_t VERSION_MASK = 0xFFFF;\n    static constexpr uint64_t TYPE_MASK = 0xFFFF;\n    \nprivate:\n    uint64_t m_handle;\n    \npublic:\n    Handle() : m_handle(NULL_HANDLE) {}\n    Handle(uint64_t handle) : m_handle(handle) {}\n    Handle(uint16_t type, uint16_t version, uint32_t id) \n        : m_handle(((uint64_t)type << TYPE_SHIFT) | \n                   ((uint64_t)version << VERSION_SHIFT) | \n                   (uint64_t)id) {}\n    \n    bool IsValid() const { return m_handle != NULL_HANDLE; }\n    uint32_t GetID() const { return m_handle & ID_MASK; }\n    uint16_t GetVersion() const { return (m_handle >> VERSION_SHIFT) & VERSION_MASK; }\n    uint16_t GetType() const { return (m_handle >> TYPE_SHIFT) & TYPE_MASK; }\n    uint64_t GetHandle() const { return m_handle; }\n    \n    bool operator==(const Handle& other) const { return m_handle == other.m_handle; }\n    bool operator!=(const Handle& other) const { return m_handle != other.m_handle; }\n};\n\n// Specific handle types with compile-time type safety\nenum class ResourceType : uint16_t {\n    TEXTURE = 1,\n    MESH = 2,\n    AUDIO = 3,\n    SCENE = 4\n};\n\nclass TextureHandle : public Handle<TextureHandle> {\npublic:\n    TextureHandle() : Handle() {}\n    TextureHandle(uint16_t version, uint32_t id) \n        : Handle(static_cast<uint16_t>(ResourceType::TEXTURE), version, id) {}\n};\n\nclass MeshHandle : public Handle<MeshHandle> {\npublic:\n    MeshHandle() : Handle() {}\n    MeshHandle(uint16_t version, uint32_t id) \n        : Handle(static_cast<uint16_t>(ResourceType::MESH), version, id) {}\n};\n\nclass AudioHandle : public Handle<AudioHandle> {\npublic:\n    AudioHandle() : Handle() {}\n    AudioHandle(uint16_t version, uint32_t id) \n        : Handle(static_cast<uint16_t>(ResourceType::AUDIO), version, id) {}\n};\n\nclass SceneHandle : public Handle<SceneHandle> {\npublic:\n    SceneHandle() : Handle() {}\n    SceneHandle(uint16_t version, uint32_t id) \n        : Handle(static_cast<uint16_t>(ResourceType::SCENE), version, id) {}\n};\n```\n\n**AssetLoaders.h - File Format Loading**\n```cpp\n#pragma once\n#include <string>\n#include <vector>\n#include <memory>\n\nstruct TextureData {\n    std::vector<uint8_t> pixels;\n    int width;\n    int height;\n    int channels;\n};\n\nstruct MeshData {\n    std::vector<float> vertices;\n    std::vector<uint32_t> indices;\n    int vertexCount;\n    int indexCount;\n};\n\nstruct AudioData {\n    std::vector<float> samples;\n    int sampleRate;\n    int channels;\n    float duration;\n};\n\n// Complete image loading implementation using stb_image\nclass ImageLoader {\npublic:\n    static bool LoadPNG(const std::string& filepath, TextureData& output);\n    static bool LoadJPEG(const std::string& filepath, TextureData& output);\n    static bool LoadImage(const std::string& filepath, TextureData& output); // Auto-detect format\n};\n\n// Complete mesh loading implementation using tinyobjloader\nclass MeshLoader {\npublic:\n    static bool LoadOBJ(const std::string& filepath, MeshData& output);\n};\n\n// Complete audio loading implementation\nclass AudioLoader {\npublic:\n    static bool LoadWAV(const std::string& filepath, AudioData& output);\n    static bool LoadOGG(const std::string& filepath, AudioData& output);\n};\n```\n\n**ThreadSafeQueue.h - Async Loading Infrastructure**\n```cpp\n#pragma once\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n\ntemplate<typename T>\nclass ThreadSafeQueue {\nprivate:\n    std::queue<T> m_queue;\n    mutable std::mutex m_mutex;\n    std::condition_variable m_condition;\n\npublic:\n    void Push(const T& item) {\n        std::lock_guard<std::mutex> lock(m_mutex);\n        m_queue.push(item);\n        m_condition.notify_one();\n    }\n    \n    bool TryPop(T& item) {\n        std::lock_guard<std::mutex> lock(m_mutex);\n        if (m_queue.empty()) return false;\n        item = m_queue.front();\n        m_queue.pop();\n        return true;\n    }\n    \n    void WaitAndPop(T& item) {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        m_condition.wait(lock, [this] { return !m_queue.empty(); });\n        item = m_queue.front();\n        m_queue.pop();\n    }\n    \n    bool Empty() const {\n        std::lock_guard<std::mutex> lock(m_mutex);\n        return m_queue.empty();\n    }\n    \n    size_t Size() const {\n        std::lock_guard<std::mutex> lock(m_mutex);\n        return m_queue.size();\n    }\n};\n```\n\n#### Core Logic Skeleton (Learner Implementation)\n\n**ResourceManager.h - Core Resource Management Interface**\n```cpp\n#pragma once\n#include \"ResourceHandle.h\"\n#include \"AssetLoaders.h\"\n#include \"ThreadSafeQueue.h\"\n#include <unordered_map>\n#include <atomic>\n#include <thread>\n#include <functional>\n\nstruct TextureResource {\n    uint32_t textureID;  // OpenGL texture object\n    int width, height;\n    uint16_t version;\n    std::atomic<uint32_t> referenceCount;\n    std::string filepath;\n};\n\nstruct MeshResource {\n    uint32_t VAO, VBO, EBO;  // OpenGL vertex array and buffer objects\n    int vertexCount, indexCount;\n    uint16_t version;\n    std::atomic<uint32_t> referenceCount;\n    std::string filepath;\n};\n\nenum class LoadingState {\n    Unloaded,\n    Loading,\n    Loaded,\n    Error\n};\n\nstruct LoadRequest {\n    std::string filepath;\n    ResourceType type;\n    std::function<void(bool success)> callback;\n    int priority;\n};\n\nclass ResourceManager {\nprivate:\n    // Resource storage pools\n    std::vector<TextureResource> m_textures;\n    std::vector<MeshResource> m_meshes;\n    std::vector<AudioResource> m_audioClips;\n    \n    // Handle management\n    std::unordered_map<std::string, TextureHandle> m_textureHandles;\n    std::unordered_map<std::string, MeshHandle> m_meshHandles;\n    std::unordered_map<std::string, AudioHandle> m_audioHandles;\n    \n    // Async loading infrastructure\n    ThreadSafeQueue<LoadRequest> m_loadQueue;\n    std::vector<std::thread> m_workerThreads;\n    std::atomic<bool> m_shouldStop;\n    \n    // Thread safety\n    std::mutex m_textureMutex;\n    std::mutex m_meshMutex;\n    std::mutex m_audioMutex;\n    \npublic:\n    ResourceManager();\n    ~ResourceManager();\n    \n    // Core resource loading interface\n    TextureHandle LoadTexture(const std::string& filepath);\n    MeshHandle LoadMesh(const std::string& filepath);\n    AudioHandle LoadAudio(const std::string& filepath);\n    \n    // Async loading with callbacks\n    void LoadTextureAsync(const std::string& filepath, std::function<void(TextureHandle)> callback);\n    void LoadMeshAsync(const std::string& filepath, std::function<void(MeshHandle)> callback);\n    void LoadAudioAsync(const std::string& filepath, std::function<void(AudioHandle)> callback);\n    \n    // Resource access and validation\n    TextureResource* GetTexture(TextureHandle handle);\n    MeshResource* GetMesh(MeshHandle handle);\n    AudioResource* GetAudio(AudioHandle handle);\n    \n    bool IsValid(TextureHandle handle) const;\n    bool IsValid(MeshHandle handle) const;\n    bool IsValid(AudioHandle handle) const;\n    \n    // Reference counting\n    void AddReference(TextureHandle handle);\n    void AddReference(MeshHandle handle);  \n    void AddReference(AudioHandle handle);\n    \n    void RemoveReference(TextureHandle handle);\n    void RemoveReference(MeshHandle handle);\n    void RemoveReference(AudioHandle handle);\n    \n    // Cleanup and maintenance\n    void RunGarbageCollection();\n    void ProcessAsyncUploads();\n    \n    // Initialization and shutdown\n    bool Initialize();\n    void Shutdown();\n    \nprivate:\n    // TODO: Implement these core methods\n    TextureHandle CreateTextureHandle(const std::string& filepath);\n    MeshHandle CreateMeshHandle(const std::string& filepath);\n    AudioHandle CreateAudioHandle(const std::string& filepath);\n    \n    void WorkerThreadFunction();\n    void ProcessLoadRequest(const LoadRequest& request);\n    \n    bool LoadTextureFromFile(const std::string& filepath, TextureResource& resource);\n    bool LoadMeshFromFile(const std::string& filepath, MeshResource& resource);\n    bool LoadAudioFromFile(const std::string& filepath, AudioResource& resource);\n    \n    void UploadTextureToGPU(const TextureData& data, TextureResource& resource);\n    void UploadMeshToGPU(const MeshData& data, MeshResource& resource);\n};\n```\n\n**Core Resource Manager Implementation (Learner Implements)**\n```cpp\n// ResourceManager.cpp - Core methods for learner to implement\n\nTextureHandle ResourceManager::LoadTexture(const std::string& filepath) {\n    // TODO 1: Check if texture is already loaded in m_textureHandles map\n    // TODO 2: If found, increment reference count and return existing handle\n    // TODO 3: If not found, create new TextureResource entry in m_textures vector\n    // TODO 4: Load texture data from file using ImageLoader::LoadImage\n    // TODO 5: Upload texture data to GPU using UploadTextureToGPU\n    // TODO 6: Create TextureHandle with version and ID, store in m_textureHandles map\n    // TODO 7: Set reference count to 1 and return handle\n    // Hint: Use std::lock_guard<std::mutex> for thread safety\n}\n\nbool ResourceManager::IsValid(TextureHandle handle) const {\n    // TODO 1: Extract ID and version from handle using GetID() and GetVersion()\n    // TODO 2: Check if ID is within bounds of m_textures vector\n    // TODO 3: Compare handle version with stored version in TextureResource\n    // TODO 4: Return true only if both bounds check and version check pass\n    // Hint: Invalid handles have ID 0 or version mismatch\n}\n\nvoid ResourceManager::RemoveReference(TextureHandle handle) {\n    // TODO 1: Validate handle using IsValid() - return early if invalid\n    // TODO 2: Get TextureResource using handle ID as index into m_textures\n    // TODO 3: Atomically decrement reference count using fetch_sub(1)\n    // TODO 4: If reference count reaches 0, mark resource for cleanup\n    // TODO 5: Consider immediate cleanup vs deferred garbage collection\n    // Hint: Use atomic operations to avoid race conditions with other threads\n}\n\nvoid ResourceManager::WorkerThreadFunction() {\n    // TODO 1: Loop while m_shouldStop is false\n    // TODO 2: Wait for load request from m_loadQueue using WaitAndPop\n    // TODO 3: Process request based on ResourceType (TEXTURE, MESH, AUDIO)\n    // TODO 4: Load file data using appropriate loader (ImageLoader, MeshLoader, etc.)\n    // TODO 5: Signal main thread that GPU upload is ready\n    // TODO 6: Invoke completion callback with success/failure result\n    // Hint: Worker threads only do file I/O, GPU upload happens on main thread\n}\n\nvoid ResourceManager::ProcessAsyncUploads() {\n    // TODO 1: Check queue of completed file loads waiting for GPU upload\n    // TODO 2: For each completed load, upload data to GPU (OpenGL calls)\n    // TODO 3: Update resource state from Loading to Loaded or Error\n    // TODO 4: Store GPU resource IDs (texture ID, VAO, etc.) in resource struct\n    // TODO 5: Invoke any completion callbacks waiting for this resource\n    // Hint: This method runs on main thread with active OpenGL context\n}\n```\n\n**Scene.h - Scene Data Structure**\n```cpp\n#pragma once\n#include \"../ecs/ECSWorld.h\"\n#include \"ResourceHandle.h\"\n#include <nlohmann/json.hpp>\n#include <string>\n#include <vector>\n\nstruct SceneMetadata {\n    std::string name;\n    std::string version;\n    std::string engineVersion;\n    std::vector<std::string> requiredResources;\n};\n\nclass Scene {\nprivate:\n    SceneMetadata m_metadata;\n    std::vector<Entity> m_entities;\n    std::unordered_map<std::string, TextureHandle> m_textureReferences;\n    std::unordered_map<std::string, MeshHandle> m_meshReferences;\n    std::unordered_map<std::string, AudioHandle> m_audioReferences;\n    \npublic:\n    Scene(const std::string& name);\n    ~Scene();\n    \n    // Entity management\n    void AddEntity(Entity entity);\n    void RemoveEntity(Entity entity);\n    const std::vector<Entity>& GetEntities() const { return m_entities; }\n    \n    // Resource references\n    void AddResourceReference(const std::string& name, TextureHandle handle);\n    void AddResourceReference(const std::string& name, MeshHandle handle);\n    void AddResourceReference(const std::string& name, AudioHandle handle);\n    \n    // Serialization interface\n    bool SaveToFile(const std::string& filepath, ECSWorld& world) const;\n    bool LoadFromFile(const std::string& filepath, ECSWorld& world, ResourceManager& resources);\n    \n    // JSON conversion\n    nlohmann::json ToJSON(ECSWorld& world) const;\n    bool FromJSON(const nlohmann::json& json, ECSWorld& world, ResourceManager& resources);\n    \n    // Metadata access\n    const SceneMetadata& GetMetadata() const { return m_metadata; }\n    void SetMetadata(const SceneMetadata& metadata) { m_metadata = metadata; }\n};\n```\n\n**Scene Implementation (Learner Implements)**\n```cpp\n// Scene.cpp - Serialization methods for learner to implement\n\nbool Scene::SaveToFile(const std::string& filepath, ECSWorld& world) const {\n    // TODO 1: Create JSON object using ToJSON method\n    // TODO 2: Open output file stream for writing\n    // TODO 3: Write JSON data to file with proper formatting\n    // TODO 4: Ensure file is properly closed and handle write errors\n    // TODO 5: Return true on success, false on any error\n    // Hint: Use std::ofstream and check file.good() for error handling\n}\n\nnlohmann::json Scene::ToJSON(ECSWorld& world) const {\n    nlohmann::json sceneJson;\n    \n    // TODO 1: Serialize scene metadata (name, version, engine version)\n    // TODO 2: Build resource manifest by collecting all resource references\n    // TODO 3: Iterate through m_entities and serialize each entity\n    // TODO 4: For each entity, get all components and serialize them\n    // TODO 5: Convert resource handles back to asset path strings\n    // TODO 6: Handle component polymorphism using type registration\n    // Hint: Use world.GetComponent<T>() to retrieve components by type\n}\n\nbool Scene::FromJSON(const nlohmann::json& json, ECSWorld& world, ResourceManager& resources) {\n    // TODO 1: Parse and validate scene metadata from JSON\n    // TODO 2: Preload all resources listed in the resource manifest\n    // TODO 3: Create entities with the correct IDs from serialized data\n    // TODO 4: For each entity, deserialize and attach all components\n    // TODO 5: Resolve resource path strings back to valid handles\n    // TODO 6: Validate that all entity references are satisfied\n    // TODO 7: Return false if any step fails, true on complete success\n    // Hint: Check that all required resources loaded successfully before creating entities\n}\n```\n\n#### Language-Specific Implementation Hints\n\n**C++ Resource Management:**\n- Use `std::unique_ptr` for automatic cleanup of resource data structures\n- Implement RAII (Resource Acquisition Is Initialization) pattern for GPU resources\n- Use `std::atomic<uint32_t>` for thread-safe reference counting without mutex overhead\n- Call `glGenTextures`, `glBindTexture`, `glTexImage2D` for texture uploads\n- Call `glGenBuffers`, `glBindBuffer`, `glBufferData` for mesh uploads\n- Use `std::lock_guard<std::mutex>` for automatic lock management\n\n**OpenGL Integration:**\n- Check `glGetError()` after each OpenGL call during development\n- Use `GL_RGBA8` internal format for texture uploads\n- Generate mipmaps with `glGenerateMipmap(GL_TEXTURE_2D)` for distance-based filtering\n- Store OpenGL object IDs (texture, VBO, VAO) in resource structures\n- Call `glDeleteTextures`, `glDeleteBuffers` during resource cleanup\n\n**JSON Serialization with nlohmann::json:**\n- Use `json[\"key\"] = value` syntax for simple value assignment  \n- Use `json.contains(\"key\")` to check for optional fields before access\n- Handle missing or malformed JSON gracefully with try/catch blocks\n- Use `json.dump(4)` for pretty-printed output with 4-space indentation\n- Convert handles to strings with `std::to_string(handle.GetID())`\n\n**Threading and Async Loading:**\n- Create worker threads in ResourceManager constructor, join in destructor\n- Use `std::this_thread::sleep_for()` to avoid busy-waiting in worker threads\n- Signal main thread using `std::condition_variable` when uploads are ready\n- Only make OpenGL calls from the main thread with active graphics context\n- Use `std::atomic<bool>` for thread-safe shutdown signaling\n\n#### Milestone Checkpoints\n\n**After implementing ResourceManager core methods:**\n```bash\n# Test basic resource loading\n./engine_test --test_resource_loading\nExpected output:\n✓ Texture loading: player.png (512x512, handle=0x100001)\n✓ Handle validation: valid handle returns true\n✓ Handle validation: invalid handle returns false\n✓ Reference counting: increment/decrement works correctly\n```\n\n**After implementing async loading system:**\n```bash  \n# Test background loading without frame hitches\n./engine_test --test_async_loading --monitor_framerate\nExpected output:\n✓ Started loading 50 textures asynchronously\n✓ Frame rate maintained >55fps during loading\n✓ All textures loaded successfully\n✓ No memory leaks detected\n```\n\n**After implementing scene serialization:**\n```bash\n# Test scene save/load roundtrip\n./engine_test --test_scene_serialization\nExpected output:\n✓ Created scene with 100 entities, 300 components\n✓ Saved scene to test_scene.json (45.2 KB)\n✓ Loaded scene successfully, entity count matches\n✓ All component data matches original values\n✓ All resource handles resolved correctly\n```\n\n**Signs of problems and debugging:**\n- **Black textures**: Check that image loading succeeded and data uploaded to correct OpenGL texture ID\n- **Crashes during cleanup**: Verify reference counting prevents access to freed resources  \n- **Memory leaks**: Check that RemoveReference decrements correctly and cleanup occurs\n- **Loading hangs**: Ensure worker threads process requests and main thread handles uploads\n- **Scene corruption**: Validate JSON structure and handle loading failures gracefully\n\nThe resource and scene management system represents the foundation for all content in your game engine. Take time to implement each component thoroughly—the complexity invested here pays dividends in reliability and performance throughout the rest of the engine development process.\n\n\n## System Interactions and Data Flow\n\n> **Milestone(s):** All milestones (1-4) — understanding system interactions is critical throughout development as subsystems are built incrementally and must coordinate effectively\n\nUnderstanding how engine subsystems communicate is like orchestrating a **symphony orchestra**. Each section (rendering, physics, ECS, resource management) plays its own part with specialized instruments and timing, but they must coordinate through a conductor (the main game loop) to create harmonious gameplay. Without proper coordination, you get cacophony—frame drops, visual glitches, physics explosions, and resource leaks. The conductor ensures each section plays at the right tempo, responds to cues from other sections, and maintains perfect timing even when individual musicians (systems) encounter difficulties.\n\nThe complexity arises because game engines operate under strict real-time constraints. Unlike web applications where a slow database query might add a few hundred milliseconds to response time, a game engine has exactly 16.67 milliseconds to process input, update game state, simulate physics, and render a frame. Miss this deadline, and players immediately notice stuttering, input lag, or visual artifacts. This temporal pressure shapes every aspect of how systems interact and communicate.\n\n### Frame Processing Lifecycle\n\nThe **frame processing lifecycle** is the heartbeat of the game engine—a carefully choreographed sequence that repeats 60 times per second. Think of it as a **factory assembly line** where each station (subsystem) has specific responsibilities, operates on a fixed schedule, and passes work to the next station. The assembly line must maintain constant throughput regardless of variations in workload, and any station that falls behind affects the entire production schedule.\n\n![Frame Processing Pipeline](./diagrams/frame-processing-flow.svg)\n\nThe frame lifecycle consists of five distinct phases, each with specific timing constraints and data dependencies. Understanding the order and timing of these phases is crucial because violating dependencies or exceeding time budgets leads to visible performance problems.\n\n#### Phase 1: Input Processing and Event Handling\n\nThe frame begins with **input processing**, where the engine polls the operating system for user input events, window events, and system notifications. This phase acts like a **mail sorting facility**—collecting all incoming messages, categorizing them by type, and routing them to appropriate handlers. The Window system takes primary responsibility for this phase, interfacing directly with SDL2 or GLFW to retrieve events from the OS event queue.\n\nInput processing must complete within the first 1-2 milliseconds of the frame to ensure responsive controls. The Window system performs several critical operations:\n\n1. **Event Polling**: The `PollEvents()` method retrieves all queued events from the OS, including keyboard presses, mouse movements, window resize notifications, and system messages\n2. **Event Classification**: Each event gets categorized by type and priority—immediate events like window close requests get processed immediately, while gameplay input gets queued for the ECS systems\n3. **Input State Updates**: Current keyboard and mouse state gets updated in global input managers, providing systems with immediate access to \"is key pressed\" queries\n4. **Event Distribution**: Events get distributed to registered listeners through callback mechanisms or event queues, allowing systems to respond to relevant input\n\nThe Window system maintains several critical data structures during input processing:\n\n| Data Structure | Type | Purpose |\n|---|---|---|\n| `m_eventQueue` | `vector<InputEvent>` | Stores processed input events for ECS systems |\n| `m_keyboardState` | `array<bool, 256>` | Current state of all keyboard keys |\n| `m_mouseState` | `MouseState` | Current mouse position and button states |\n| `m_resizeCallback` | `ResizeCallback` | Callback for window resize events |\n| `m_closeRequested` | `bool` | Flag indicating application should terminate |\n\nInput processing includes several error handling considerations. Network disconnections for multiplayer games, gamepad disconnections, or window focus changes all require graceful handling without disrupting the frame pipeline.\n\n#### Phase 2: ECS World Update and System Execution\n\nFollowing input processing, the **ECS world update** phase processes all game logic through the registered system pipeline. This phase resembles a **data processing factory** where specialized machines (systems) operate on conveyor belts of component data, transforming entity state according to game rules. The ECSWorld coordinates this phase, ensuring systems execute in dependency order and receive accurate delta time information.\n\nThe system execution phase typically consumes 8-10 milliseconds of the 16.67-millisecond frame budget, making it the most time-critical phase. The ECSWorld orchestrates system execution through several mechanisms:\n\n1. **System Dependency Resolution**: Systems execute in predetermined order based on data dependencies—input systems run before movement systems, movement systems run before animation systems\n2. **Component Query Processing**: Each system queries for entities matching its component signature, receiving dense arrays of component data for cache-efficient iteration\n3. **Delta Time Propagation**: All systems receive the current frame's delta time, ensuring frame-rate-independent behavior\n4. **Cross-System Communication**: Systems communicate through component modifications, event queues, or shared state managers\n\nThe ECSWorld maintains execution metadata throughout the update phase:\n\n| Execution Data | Type | Purpose |\n|---|---|---|\n| `m_systemRegistry` | `vector<unique_ptr<System>>` | All registered systems in execution order |\n| `m_frameTime` | `float` | Delta time for current frame |\n| `m_componentQueries` | `QueryCache` | Cached entity lists for common component signatures |\n| `m_systemTimings` | `map<SystemID, float>` | Performance profiling data for each system |\n| `m_eventBus` | `EventBus` | Inter-system communication channel |\n\nSystem execution involves careful memory management and performance monitoring. Each system's execution time gets tracked to identify performance bottlenecks, and memory allocations are minimized through object pooling and component reuse strategies.\n\n> **Critical Insight**: The ECS update phase determines frame rate stability more than any other phase. A single poorly optimized system that takes 20 milliseconds will cause visible stuttering regardless of how efficiently other systems perform.\n\n#### Phase 3: Physics Simulation with Fixed Timestep\n\nThe **physics simulation phase** advances the physical world using a fixed timestep accumulator pattern, decoupling physics determinism from rendering frame rate. Think of this as a **precision clockwork mechanism**—it ticks at exactly 60Hz regardless of whether the overall frame runs at 30fps, 60fps, or 120fps. This phase typically runs after ECS updates but before rendering, ensuring visual output reflects the most recent physics state.\n\nPhysics simulation uses a fundamentally different timing model than other engine systems. While rendering and ECS updates use variable delta time (the actual time elapsed since last frame), physics uses a fixed timestep to ensure deterministic, reproducible simulation. The physics system maintains a time accumulator that tracks how much \"physics time\" needs processing:\n\n1. **Accumulator Management**: The current frame's delta time gets added to a time accumulator, representing physics simulation debt\n2. **Fixed Timestep Processing**: While the accumulator contains at least `PHYSICS_TIMESTEP` seconds (typically 1/60th second), the physics world advances by exactly that amount\n3. **Multiple Physics Steps**: High frame rates may process multiple physics steps per frame, while low frame rates process fractional steps\n4. **Interpolation**: Rendering systems interpolate between physics positions to smooth visual motion at arbitrary frame rates\n\nThe physics system maintains several timing-critical data structures:\n\n| Physics Timing Data | Type | Purpose |\n|---|---|---|\n| `m_accumulator` | `float` | Time debt requiring physics processing |\n| `m_fixedTimestep` | `float` | Constant time increment (typically 1/60 second) |\n| `m_maxAccumulator` | `float` | Maximum accumulated time to prevent spiral of death |\n| `m_interpolationFactor` | `float` | Blending factor for smooth rendering |\n| `m_stepCount` | `int` | Number of physics steps processed this frame |\n\nThe physics simulation phase includes collision detection and response, which involves complex spatial queries and geometric computations. The collision system maintains spatial partitioning structures (grids or quadtrees) that require incremental updates as entities move through space.\n\n**Decision: Fixed vs Variable Timestep Physics**\n- **Context**: Physics simulation can use either variable delta time (matching frame rate) or fixed timestep (constant time increment)\n- **Options Considered**:\n  - Variable timestep: Simple implementation, matches rendering frame rate\n  - Fixed timestep with accumulator: More complex, deterministic behavior\n  - Hybrid approach: Fixed physics with variable rendering interpolation\n- **Decision**: Fixed timestep with accumulator pattern\n- **Rationale**: Deterministic physics behavior is essential for gameplay consistency, network synchronization, and replay systems. Variable timestep physics produces different results on different hardware, making debugging and testing nearly impossible\n- **Consequences**: Added complexity in time management, but ensures consistent behavior across all hardware and frame rates\n\n| Timestep Option | Pros | Cons |\n|---|---|---|\n| Variable | Simple implementation, lower input lag | Non-deterministic, hardware-dependent behavior |\n| Fixed | Deterministic, consistent across hardware | More complex timing, potential frame rate coupling |\n| Hybrid | Best visual quality with deterministic physics | Most complex implementation |\n\n#### Phase 4: Rendering Pipeline Execution\n\nThe **rendering phase** transforms the current world state into visual output, operating like a **3D photography studio** with multiple stages of scene preparation, lighting setup, and final image composition. The Renderer coordinates this phase, collecting visual data from ECS components, organizing it for efficient GPU processing, and issuing draw commands that produce the final frame. This phase typically consumes 4-6 milliseconds on modern hardware but can vary dramatically based on scene complexity.\n\n![Graphics Rendering Pipeline](./diagrams/rendering-pipeline.svg)\n\nRendering operates on snapshot data from the completed ECS and physics updates, ensuring visual consistency throughout the frame. The rendering pipeline processes visual data through several stages:\n\n1. **Scene Culling**: The Renderer queries the ECSWorld for all entities with visual components (`Transform`, `Sprite`, `Mesh`), filtering out objects outside the camera frustum\n2. **Depth Sorting**: Visual elements get sorted by depth/layer to ensure correct drawing order and optimal GPU state management\n3. **Batch Preparation**: Similar rendering operations get grouped together to minimize GPU state changes and draw calls\n4. **GPU Command Generation**: The BatchRenderer generates vertex buffers, sets shader uniforms, and issues draw calls to the graphics API\n5. **Frame Presentation**: The completed frame gets presented through the Window system's swap chain\n\nThe rendering phase maintains several performance-critical data structures:\n\n| Rendering Data | Type | Purpose |\n|---|---|---|\n| `m_renderQueue` | `vector<RenderCommand>` | GPU commands sorted by state changes |\n| `m_activeBatch` | `BatchData` | Current geometry batch being assembled |\n| `m_viewMatrix` | `Matrix4` | Camera transformation for world-to-screen projection |\n| `m_visibleEntities` | `vector<Entity>` | Entities within camera frustum |\n| `m_frameStats` | `RenderStats` | Performance metrics for current frame |\n\nThe rendering system interfaces heavily with the Resource Manager during this phase, requesting textures, shaders, and mesh data through handle-based access. These resource requests must complete immediately since rendering operates under strict timing constraints.\n\n#### Phase 5: Frame Finalization and Timing Control\n\nThe final phase handles **frame finalization**—presenting the completed frame to screen, updating timing statistics, and preparing for the next frame cycle. This phase operates like a **quality control checkpoint** in the assembly line, ensuring the finished product meets timing requirements before releasing it to consumers (players). The Application class coordinates this phase, working with the Window system and FrameTimer to maintain consistent frame pacing.\n\nFrame finalization involves several critical operations:\n\n1. **Buffer Swapping**: The Window system's `SwapBuffers()` method presents the completed frame and switches to the next render target\n2. **V-Sync Coordination**: If vertical synchronization is enabled, the system waits for display refresh to prevent screen tearing\n3. **Timing Updates**: The FrameTimer calculates the actual frame duration and updates delta time for the next frame\n4. **Performance Monitoring**: Frame timing statistics get updated for performance analysis and debugging\n5. **Memory Cleanup**: Temporary allocations from the current frame get released, and garbage collection runs if needed\n\nThe frame finalization phase maintains timing and performance data:\n\n| Finalization Data | Type | Purpose |\n|---|---|---|\n| `m_frameCounter` | `uint64_t` | Total frames rendered since startup |\n| `m_averageFrameTime` | `float` | Rolling average of recent frame durations |\n| `m_frameTiming` | `RingBuffer<float>` | Recent frame times for analysis |\n| `m_performanceStats` | `FrameStats` | Detailed timing breakdown by phase |\n| `m_vsyncEnabled` | `bool` | Whether vertical synchronization is active |\n\n#### Frame Lifecycle Error Handling\n\nEach phase of the frame lifecycle includes specific error handling mechanisms to ensure graceful degradation rather than catastrophic failure. The frame processing pipeline implements several resilience strategies:\n\n**Input Processing Errors**: Device disconnections or invalid input events get logged but don't interrupt frame processing. Missing input devices get detected and handled through fallback input methods.\n\n**ECS Update Errors**: System execution exceptions get caught and logged, allowing other systems to continue processing. Malformed component data gets validated and corrected where possible.\n\n**Physics Simulation Errors**: Numerical instability or collision detection failures trigger fallback behaviors like entity separation or velocity clamping. The physics system includes debugging modes that visualize problematic interactions.\n\n**Rendering Errors**: Shader compilation failures, texture loading errors, or GPU driver issues trigger fallback rendering paths using basic shaders and default textures. The rendering system maintains error state that prevents cascading failures.\n\n**Timing Errors**: Frame rate drops or system suspension get handled through the accumulator pattern, preventing physics simulation from becoming unstable during temporary performance problems.\n\n### Inter-System Communication\n\nSystems within a game engine must coordinate and exchange information while maintaining loose coupling and performance efficiency. This coordination resembles a **corporate communication network** where different departments (systems) need to share information and coordinate actions without creating bottlenecks or dependencies that slow down operations. The key challenge is enabling rich communication while preserving the performance benefits of data-oriented design and avoiding the coupling problems that plague traditional object-oriented architectures.\n\n![Engine System Architecture](./diagrams/system-architecture.svg)\n\nGame engine systems communicate through several complementary mechanisms, each optimized for different types of interactions and timing requirements. The communication architecture balances immediate responsiveness for critical interactions with deferred processing for non-urgent coordination.\n\n#### Component-Based State Sharing\n\nThe primary communication mechanism between systems occurs through **shared component state** within the ECS architecture. This approach treats components as a **shared database** where systems read and write specific data fields to coordinate behavior. Components act as communication contracts—when one system modifies a component, other systems that query for that component type automatically see the updated state during their execution.\n\nComponent-based communication provides several advantages for game engine architectures. It maintains data locality by keeping related information together in component arrays, enables efficient batch processing of similar operations, and provides automatic state synchronization without explicit message passing overhead. Systems remain loosely coupled because they depend only on component interfaces, not on specific system implementations.\n\nCommon component-based communication patterns include:\n\n**Transform Propagation**: The physics system updates `RigidBody` velocity and the `Transform` position, while the rendering system reads `Transform` data to position visual elements. This creates automatic coordination between physics simulation and visual representation without direct system dependencies.\n\n**Animation State Sharing**: Animation systems modify `Transform` and `Sprite` components to represent current animation frames, while physics systems read these values to maintain collision shape alignment with visual appearance.\n\n**Health and Damage Communication**: Combat systems modify `Health` components to represent damage effects, while UI systems read `Health` components to update health bars, and AI systems use health values for decision making.\n\nThe ECS architecture provides efficient component access through query systems:\n\n| Communication Pattern | Read Components | Write Components | Systems Involved |\n|---|---|---|---|\n| Physics-Rendering Sync | `Transform`, `RigidBody` | `Transform` | Physics, Rendering |\n| Animation Updates | `Transform`, `AnimationState` | `Transform`, `Sprite` | Animation, Rendering |\n| Combat Resolution | `Health`, `Damage` | `Health`, `CombatState` | Combat, AI, UI |\n| Input Processing | `InputComponent` | `Movement`, `Transform` | Input, Movement |\n\nComponent-based communication includes timing considerations because system execution order determines which systems see updated component state during each frame. The ECSWorld ensures systems execute in dependency order to maintain consistent data flow.\n\n#### Event Queue Architecture\n\nFor **asynchronous communication** and **decoupled notifications**, the engine implements an event queue system that enables systems to broadcast information without knowing which systems need to receive it. This approach functions like a **company-wide bulletin board** where departments can post announcements that other departments check and respond to as needed. Event queues handle communications that don't require immediate response and help break circular dependencies between systems.\n\nThe event system provides temporal decoupling—events posted during one frame get processed during subsequent frames, preventing immediate recursion and allowing systems to maintain clear execution phases. This temporal separation is crucial for maintaining deterministic behavior and avoiding cascade effects where one system's operation triggers another system, which triggers another, creating unpredictable execution patterns.\n\nEvent-based communication serves several specific use cases:\n\n**Entity Lifecycle Events**: When entities are created or destroyed, the ECS system posts lifecycle events that allow other systems to perform cleanup or initialization without direct coupling to entity management code.\n\n**Collision Notifications**: The physics system posts collision events when entities collide, allowing audio systems to play sound effects, particle systems to create visual effects, and gameplay systems to apply damage without the physics system knowing about these higher-level concepts.\n\n**Resource Loading Completion**: The resource management system posts events when assets complete loading, allowing systems that depend on specific resources to respond appropriately.\n\n**User Interface Events**: UI systems post events for button clicks, menu selections, and dialog responses, allowing gameplay systems to respond to player choices without UI systems depending on specific game logic.\n\nThe event queue implementation maintains several key data structures:\n\n| Event System Data | Type | Purpose |\n|---|---|---|\n| `m_eventQueue` | `ThreadSafeQueue<Event>` | Queue of pending events for processing |\n| `m_eventHandlers` | `map<EventType, vector<Handler>>` | Registered handlers for each event type |\n| `m_eventPool` | `ObjectPool<Event>` | Memory pool for event allocation |\n| `m_deferredEvents` | `vector<Event>` | Events scheduled for future frames |\n\nEvent processing occurs during specific phases of the frame lifecycle to ensure predictable timing and avoid mid-frame state changes that could cause inconsistent behavior.\n\n**Decision: Event Queue vs Direct System References**\n- **Context**: Systems need to communicate and coordinate without creating tight coupling or performance bottlenecks\n- **Options Considered**:\n  - Direct system references: Systems hold pointers to other systems they need to communicate with\n  - Global event queue: Centralized event broadcasting with registration-based handling\n  - Component-only communication: All coordination through shared component state\n- **Decision**: Hybrid approach using component-based communication for frequent updates and event queues for infrequent notifications\n- **Rationale**: Component-based communication provides optimal performance for high-frequency interactions like physics-rendering coordination, while event queues handle infrequent notifications without coupling systems\n- **Consequences**: Adds complexity through dual communication channels, but provides both performance and flexibility benefits\n\n#### Callback and Observer Patterns\n\nFor **immediate response communication** where systems need to react instantly to specific conditions, the engine implements callback and observer patterns. These mechanisms function like **emergency notification systems** that bypass normal communication channels when critical events require immediate attention. Callback-based communication typically handles resource loading completion, error conditions, and user input processing where delayed response would cause poor user experience.\n\nCallback patterns provide synchronous communication for situations where event queue delays would be problematic. Resource loading systems use callbacks to notify requesters immediately when assets become available, allowing rendering systems to update textures or models within the same frame. Input systems use callbacks to provide immediate response to critical input like pause requests or window close commands.\n\nThe engine implements several callback mechanisms:\n\n**Resource Loading Callbacks**: When systems request assets through the Resource Manager, they provide callback functions that execute immediately when loading completes, allowing seamless integration of new resources.\n\n**Window Event Callbacks**: The Window system provides callbacks for resize events, focus changes, and close requests that require immediate response to maintain proper application behavior.\n\n**Physics Collision Callbacks**: High-priority collision events like damage triggers or pickup detection use callbacks to ensure immediate response within the same physics timestep.\n\n**Error Condition Callbacks**: Critical errors like graphics context loss or file system failures trigger callbacks that allow systems to initiate recovery procedures immediately.\n\nCallback registration and management requires careful lifetime management:\n\n| Callback Management | Type | Purpose |\n|---|---|---|\n| `m_resourceCallbacks` | `map<Handle, function<void(Resource*)>>` | Callbacks waiting for resource loading |\n| `m_collisionCallbacks` | `vector<function<void(CollisionPair)>>` | Physics collision response functions |\n| `m_windowCallbacks` | `WindowCallbackRegistry` | Window event response functions |\n| `m_errorCallbacks` | `vector<function<void(ErrorCode)>>` | Error recovery callback functions |\n\n#### System Dependency Management\n\nManaging **execution dependencies** between systems ensures consistent data flow and prevents race conditions where systems access component data in inconsistent states. This coordination resembles **project task scheduling** where certain tasks must complete before others can begin, and the project manager (ECSWorld) ensures proper sequencing to avoid conflicts and maintain quality output.\n\nThe ECSWorld maintains a **system dependency graph** that determines execution order based on component access patterns. Systems that write to components must execute before systems that read from those same components during the same frame. The dependency resolver analyzes component signatures to automatically determine safe execution orders.\n\nSystem dependency resolution involves several analysis phases:\n\n1. **Component Access Analysis**: Each system declares which component types it reads and writes during registration\n2. **Dependency Graph Construction**: The ECSWorld builds a directed graph where edges represent data dependencies between systems\n3. **Cycle Detection**: The dependency analyzer checks for circular dependencies that would prevent consistent execution order\n4. **Topological Sorting**: Systems get sorted into execution order that respects all data dependencies\n5. **Parallel Execution Groups**: Systems with no dependencies between them get grouped for potential parallel execution\n\nThe dependency management system maintains execution metadata:\n\n| Dependency Data | Type | Purpose |\n|---|---|---|\n| `m_systemGraph` | `DependencyGraph` | System execution dependencies |\n| `m_executionOrder` | `vector<SystemID>` | Resolved system execution sequence |\n| `m_parallelGroups` | `vector<vector<SystemID>>` | Systems that can run concurrently |\n| `m_accessPatterns` | `map<SystemID, ComponentAccess>` | Read/write patterns for each system |\n\nSystem dependency management includes error detection for common problems like circular dependencies or conflicting access patterns that could cause data races.\n\n⚠️ **Pitfall: Ignoring System Execution Order**\nMany learners implement systems without considering execution dependencies, leading to inconsistent behavior where the same input produces different outputs depending on system registration order. For example, if a movement system runs after the rendering system, entity positions update after visual output, causing a one-frame delay in visual movement. The fix is explicitly analyzing component access patterns and ensuring systems execute in dependency order.\n\n### Resource Loading Dependencies\n\nThe resource loading and management system creates complex dependencies between engine subsystems because graphics, audio, and gameplay systems all depend on loaded assets to function correctly. This dependency web resembles a **supply chain network** where manufacturing plants (systems) depend on raw materials (assets) delivered by suppliers (resource managers), and production cannot begin until all required materials arrive at the correct locations and times.\n\nResource dependencies create unique challenges for game engines because asset loading involves file system I/O, network requests, and GPU memory allocation—all operations that can fail, take unpredictable amounts of time, or complete at arbitrary points during frame processing. The engine must coordinate resource requests from multiple systems while maintaining frame rate stability and providing graceful fallback behavior when resources are unavailable.\n\n![Resource Loading and Caching](./diagrams/resource-lifecycle.svg)\n\nThe resource loading architecture addresses several complex dependency scenarios that arise during game engine operation.\n\n#### Synchronous vs Asynchronous Loading Patterns\n\nResource loading systems must balance **immediate availability** requirements against **frame rate stability** concerns. Some resources like default shaders and error textures must be available immediately when systems start, while other resources like level-specific textures and models can load asynchronously without disrupting gameplay. Understanding this distinction is like differentiating between **emergency supplies** that must always be available and **specialty materials** that can be ordered when needed.\n\n**Synchronous loading** blocks system execution until resources become available, providing immediate access but potentially causing frame rate drops during loading operations. The engine uses synchronous loading for critical resources that systems cannot function without:\n\n**Bootstrap Resources**: Default shaders, error textures, and system fonts must load synchronously during engine initialization because multiple systems depend on their immediate availability.\n\n**Scene Transition Resources**: When transitioning between game levels, critical assets for the new scene must load synchronously to prevent visual glitches or missing content.\n\n**Error Recovery Resources**: Fallback assets used when primary resources fail to load must be available immediately to maintain visual consistency.\n\nSynchronous loading operations use immediate resource access patterns:\n\n| Loading Operation | Resource Type | Typical Duration | Systems Blocked |\n|---|---|---|---|\n| Default shader compilation | `ShaderProgram` | 50-100ms | All rendering systems |\n| Error texture loading | `TextureResource` | 5-10ms | Rendering, UI systems |\n| System font loading | `FontResource` | 10-20ms | UI, text rendering systems |\n| Configuration file parsing | `ConfigData` | 1-5ms | All systems using config |\n\n**Asynchronous loading** performs resource operations on background threads, allowing main thread systems to continue processing while assets load. The engine uses asynchronous loading for non-critical resources that systems can function without temporarily:\n\n**Level Assets**: Textures, models, and audio specific to game levels can load in the background while players interact with currently loaded content.\n\n**Streaming Content**: Large assets like high-resolution textures or detailed models can stream asynchronously based on player proximity or predicted need.\n\n**Prefetch Operations**: Assets likely to be needed in the near future can begin loading before systems explicitly request them, reducing perceived loading times.\n\nAsynchronous loading requires coordination mechanisms to handle completion notifications and resource availability checking:\n\n```\nAsync Loading Workflow:\n1. System requests resource through ResourceManager::LoadTextureAsync()\n2. ResourceManager queues LoadRequest in background thread queue\n3. Worker thread processes file I/O and GPU upload\n4. Completion callback notifies requesting system\n5. System begins using newly available resource\n```\n\nThe Resource Manager maintains separate data structures for tracking synchronous and asynchronous operations:\n\n| Loading State | Type | Purpose |\n|---|---|---|\n| `m_syncRequests` | `vector<LoadRequest>` | Immediate loading operations |\n| `m_asyncQueue` | `ThreadSafeQueue<LoadRequest>` | Background loading queue |\n| `m_completionCallbacks` | `map<Handle, Callback>` | Async completion notifications |\n| `m_loadingStates` | `map<Handle, LoadState>` | Resource availability tracking |\n\n#### Handle-Based Resource Access\n\nThe engine implements **handle-based resource access** to decouple systems from resource storage details and provide safe access to assets that might not be loaded yet. Handles function like **claim tickets** at a coat check—they provide proof of ownership and enable retrieval, but don't guarantee the item is immediately available. This indirection enables sophisticated resource management features like hot reloading, memory management, and error recovery.\n\nHandle-based access provides several critical benefits for resource management. Systems can request resources and receive handles immediately, even if the actual loading occurs asynchronously. Handles remain valid across resource reloading operations, allowing systems to continue using updated assets without code changes. Handle validation prevents crashes when resources fail to load or become corrupted.\n\nThe Handle<T> system implements type-safe resource access:\n\n| Handle Component | Bits | Purpose |\n|---|---|---|\n| Resource ID | 32 | Unique identifier for resource instance |\n| Resource Version | 16 | Version counter for hot reloading detection |\n| Resource Type | 16 | Type information for validation |\n\nHandle validation occurs during resource access to ensure systems receive valid resources or appropriate fallback assets:\n\n1. **Handle Validity Check**: The `IsValid()` method verifies the handle contains a non-zero resource ID and matches the expected resource type\n2. **Version Verification**: The handle version gets compared against the current resource version to detect stale references\n3. **Loading State Check**: The resource manager verifies the resource has completed loading and is available for use\n4. **Fallback Resolution**: If the primary resource is unavailable, the system provides appropriate fallback resources\n\nSystems interact with the resource manager through handle-based APIs that abstract loading complexity:\n\n| Resource Access Method | Parameters | Returns | Behavior |\n|---|---|---|\n| `LoadTexture(filepath)` | `string filepath` | `TextureHandle` | Immediate loading, blocks until complete |\n| `LoadTextureAsync(filepath, callback)` | `string filepath, Callback` | `TextureHandle` | Background loading with notification |\n| `GetTexture(handle)` | `TextureHandle` | `TextureResource*` | Retrieves loaded resource or nullptr |\n| `IsResourceLoaded(handle)` | `Handle<T>` | `bool` | Checks loading completion status |\n\n#### Cross-System Resource Sharing\n\nMultiple engine systems often require access to the same resources, creating **shared dependency relationships** that the resource manager must coordinate efficiently. This sharing resembles a **public library system** where multiple patrons can access the same books, but the library must track usage, prevent conflicts, and ensure resources remain available as long as anyone needs them.\n\nResource sharing enables memory efficiency by preventing duplicate loading of identical assets. When multiple systems request the same texture file, the resource manager loads it once and provides handles to all requesters. Reference counting automatically manages resource lifetime—when the last system releases its handle, the resource manager can safely unload the asset to free memory.\n\nThe resource manager implements several sharing mechanisms:\n\n**Reference Counting**: Each resource maintains an atomic reference count that tracks how many systems currently hold handles to it. The `AddReference()` and `RemoveReference()` methods provide thread-safe reference management.\n\n**Shared Handle Distribution**: Multiple requests for the same resource filepath return handles pointing to the same resource instance, preventing duplicate loading operations.\n\n**Automatic Cleanup**: Resources with zero reference counts become eligible for garbage collection, automatically freeing memory without requiring explicit cleanup from systems.\n\n**Hot Reloading Support**: When resources get updated on disk, the resource manager can reload them and update all existing handles simultaneously, allowing systems to automatically use updated content.\n\nCommon resource sharing patterns in game engines include:\n\n| Sharing Pattern | Resource Types | Systems Involved | Coordination Mechanism |\n|---|---|---|---|\n| Shared Textures | UI elements, sprites | Rendering, UI, particle systems | Reference counted handles |\n| Common Shaders | Material rendering | All graphics systems | Shared shader program instances |\n| Audio Clips | Sound effects | Audio, physics, gameplay systems | Instance-based playback with shared data |\n| Model Assets | Character meshes | Rendering, physics, animation systems | Shared geometry with per-instance transforms |\n\nResource sharing includes error handling for situations where shared resources become corrupted or unavailable. The resource manager provides fallback mechanisms that ensure systems continue functioning even when shared resources encounter problems.\n\n**Decision: Reference Counting vs Garbage Collection**\n- **Context**: Resource lifetime management needs to balance automatic cleanup with performance predictability\n- **Options Considered**:\n  - Manual resource management: Systems explicitly load and unload resources\n  - Reference counting: Automatic cleanup when reference count reaches zero\n  - Garbage collection: Periodic cleanup of unused resources\n- **Decision**: Reference counting with periodic garbage collection\n- **Rationale**: Reference counting provides immediate cleanup of unused resources while garbage collection handles edge cases like circular references. This combination provides both memory efficiency and predictable performance\n- **Consequences**: Slightly increased complexity in handle management, but prevents both memory leaks and unexpected cleanup delays\n\n#### Resource Loading Error Recovery\n\nResource loading operations can fail for numerous reasons including missing files, corrupted data, insufficient memory, or graphics driver problems. The engine must provide **graceful degradation** and **recovery mechanisms** that allow systems to continue functioning when resources are unavailable. This resilience resembles **supply chain redundancy** where critical operations maintain backup suppliers and alternative materials when primary sources encounter problems.\n\nError recovery in resource loading involves several strategies that prevent cascading failures when individual assets cannot be loaded. The resource manager implements fallback hierarchies, retry mechanisms, and error reporting that enable systems to adapt to resource loading failures without crashing or producing broken visual output.\n\n**Fallback Resource Hierarchies** provide alternative assets when primary resources fail to load. Each resource type includes default fallback instances that guarantee systems always receive valid resources:\n\n**Texture Fallbacks**: Missing textures get replaced with generated error textures (typically bright magenta checkerboards) that clearly indicate loading failures while maintaining rendering functionality.\n\n**Shader Fallbacks**: Failed shader compilation triggers fallback to basic unlit shaders that provide minimal but functional rendering capability.\n\n**Mesh Fallbacks**: Missing 3D models get replaced with simple geometric primitives like cubes or spheres that preserve collision boundaries and visual presence.\n\n**Audio Fallbacks**: Failed audio loading results in silent playback that maintains audio system functionality without generating errors.\n\nThe resource manager maintains fallback resources for each major resource type:\n\n| Resource Type | Primary Loading | Fallback Resource | Error Indication |\n|---|---|---|---|\n| `TextureResource` | File-based PNG/JPG | Generated error texture | Magenta checkerboard pattern |\n| `ShaderProgram` | File-based GLSL | Basic unlit shader | Solid color rendering |\n| `MeshResource` | File-based OBJ/FBX | Generated cube mesh | Bright wireframe outline |\n| `AudioResource` | File-based WAV/MP3 | Silent audio buffer | No audio output |\n\n**Retry Mechanisms** handle transient failures like temporary file system issues or network interruptions. The resource manager implements exponential backoff retry logic that attempts to reload failed resources without overwhelming the system with repeated failure attempts.\n\n**Error Reporting and Logging** provide detailed information about resource loading failures to aid debugging and content pipeline issues. The resource manager logs failure reasons, file paths, and system state to help developers identify and resolve asset problems.\n\nResource loading error recovery includes several implementation considerations:\n\n1. **Error Classification**: Different error types (file not found vs corrupted data vs insufficient memory) receive different recovery strategies\n2. **System Notification**: Systems receive notifications when resources fail to load so they can adapt behavior appropriately\n3. **Graceful Degradation**: Visual and audio quality degrades gradually rather than failing completely when resources are unavailable\n4. **Recovery Monitoring**: The resource manager tracks error rates and patterns to identify systemic problems with the content pipeline\n\n⚠️ **Pitfall: Cascading Resource Failures**\nWhen primary resources fail to load, systems often request additional fallback resources, which can also fail and trigger more resource requests, creating cascading failures that consume all available loading bandwidth. The fix is implementing circuit breaker patterns that limit retry attempts and provide guaranteed-available fallback resources that never require additional loading operations.\n\nThe resource loading dependency system creates the foundation for robust asset management that supports both development workflows and production deployment scenarios. Understanding these dependency patterns helps developers build systems that gracefully handle the complex resource loading scenarios encountered in real game development environments.\n\n### Implementation Guidance\n\nBuilding effective system interactions requires careful attention to timing, data flow, and error handling. The following implementation provides concrete structures and patterns for coordinating engine subsystems efficiently.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Event Queue | `std::queue` with mutex | Lock-free circular buffer (SPSC) |\n| Message Passing | Function pointers | `std::function` with type erasure |\n| Resource Handles | 64-bit integers with validation | Typed handles with version counters |\n| Timing Control | `std::chrono::steady_clock` | Platform-specific high-resolution timers |\n| Threading | `std::thread` with `std::mutex` | Thread pool with work stealing |\n\n#### Recommended File Structure\n\n```cpp\nengine/\n  core/\n    Application.h/.cpp          // Main application framework\n    FrameTimer.h/.cpp          // Frame timing and control\n    EventSystem.h/.cpp         // Inter-system communication\n  \n  systems/\n    SystemManager.h/.cpp       // System registration and execution\n    SystemBase.h              // Base class for all systems\n    InputSystem.h/.cpp        // Input processing and distribution\n  \n  resources/\n    ResourceManager.h/.cpp     // Asset loading and caching\n    Handle.h                  // Resource handle implementation\n    ResourceTypes.h           // Resource type definitions\n  \n  communication/\n    EventQueue.h/.cpp         // Thread-safe event queuing\n    CallbackRegistry.h/.cpp   // Callback management\n    MessageBus.h/.cpp         // System message passing\n```\n\n#### Frame Processing Infrastructure\n\nComplete frame timing and control system that manages the main game loop and coordinates system execution:\n\n```cpp\n// FrameTimer.h - Complete frame timing implementation\n#pragma once\n#include <chrono>\n#include <vector>\n\nclass FrameTimer {\npublic:\n    static constexpr float TARGET_FPS = 60.0f;\n    static constexpr float TARGET_FRAME_TIME = 1.0f / TARGET_FPS;\n    static constexpr float MAX_ACCUMULATED_TIME = 0.1f; // Prevent spiral of death\n    \nprivate:\n    std::chrono::steady_clock::time_point m_lastFrameTime;\n    std::chrono::steady_clock::time_point m_currentFrameTime;\n    float m_deltaTime;\n    float m_frameTimeAccumulator;\n    std::vector<float> m_frameTimeHistory;\n    size_t m_historyIndex;\n    uint64_t m_frameCounter;\n    \npublic:\n    FrameTimer() \n        : m_deltaTime(0.0f)\n        , m_frameTimeAccumulator(0.0f)\n        , m_frameTimeHistory(60, TARGET_FRAME_TIME)  // Track last 60 frames\n        , m_historyIndex(0)\n        , m_frameCounter(0)\n    {\n        m_lastFrameTime = std::chrono::steady_clock::now();\n        m_currentFrameTime = m_lastFrameTime;\n    }\n    \n    void Update() {\n        m_currentFrameTime = std::chrono::steady_clock::now();\n        auto elapsed = std::chrono::duration<float>(m_currentFrameTime - m_lastFrameTime);\n        m_deltaTime = elapsed.count();\n        \n        // Clamp delta time to prevent huge jumps\n        m_deltaTime = std::min(m_deltaTime, MAX_ACCUMULATED_TIME);\n        \n        // Update frame time history for averaging\n        m_frameTimeHistory[m_historyIndex] = m_deltaTime;\n        m_historyIndex = (m_historyIndex + 1) % m_frameTimeHistory.size();\n        \n        m_lastFrameTime = m_currentFrameTime;\n        m_frameCounter++;\n    }\n    \n    float GetDeltaTime() const { return m_deltaTime; }\n    float GetAverageFrameTime() const {\n        float sum = 0.0f;\n        for (float time : m_frameTimeHistory) {\n            sum += time;\n        }\n        return sum / m_frameTimeHistory.size();\n    }\n    uint64_t GetFrameCount() const { return m_frameCounter; }\n};\n\n// EventSystem.h - Complete event communication system\n#pragma once\n#include <functional>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <typeindex>\n\nenum class EventType : uint32_t {\n    EntityCreated,\n    EntityDestroyed,\n    CollisionDetected,\n    ResourceLoaded,\n    ResourceFailed,\n    WindowResized,\n    WindowClosed\n};\n\nstruct Event {\n    EventType type;\n    uint64_t timestamp;\n    void* data;\n    size_t dataSize;\n    \n    Event(EventType t, void* d = nullptr, size_t size = 0) \n        : type(t), data(d), dataSize(size) {\n        timestamp = std::chrono::steady_clock::now().time_since_epoch().count();\n    }\n};\n\nclass EventSystem {\nprivate:\n    std::queue<Event> m_eventQueue;\n    std::unordered_map<EventType, std::vector<std::function<void(const Event&)>>> m_handlers;\n    std::mutex m_queueMutex;\n    std::mutex m_handlersMutex;\n    \npublic:\n    template<typename EventData>\n    void PostEvent(EventType type, const EventData& data) {\n        std::lock_guard<std::mutex> lock(m_queueMutex);\n        // Allocate event data on heap for thread safety\n        EventData* eventData = new EventData(data);\n        m_eventQueue.emplace(type, eventData, sizeof(EventData));\n    }\n    \n    void PostEvent(EventType type) {\n        std::lock_guard<std::mutex> lock(m_queueMutex);\n        m_eventQueue.emplace(type);\n    }\n    \n    void Subscribe(EventType type, std::function<void(const Event&)> handler) {\n        std::lock_guard<std::mutex> lock(m_handlersMutex);\n        m_handlers[type].push_back(std::move(handler));\n    }\n    \n    void ProcessEvents() {\n        std::queue<Event> eventsToProcess;\n        \n        // Move events to local queue for processing\n        {\n            std::lock_guard<std::mutex> lock(m_queueMutex);\n            eventsToProcess.swap(m_eventQueue);\n        }\n        \n        // Process events without holding locks\n        while (!eventsToProcess.empty()) {\n            const Event& event = eventsToProcess.front();\n            \n            {\n                std::lock_guard<std::mutex> lock(m_handlersMutex);\n                auto it = m_handlers.find(event.type);\n                if (it != m_handlers.end()) {\n                    for (auto& handler : it->second) {\n                        handler(event);\n                    }\n                }\n            }\n            \n            // Clean up event data\n            if (event.data) {\n                delete[] static_cast<char*>(event.data);\n            }\n            \n            eventsToProcess.pop();\n        }\n    }\n};\n```\n\n#### System Coordination Framework\n\nCore system execution pipeline with dependency management:\n\n```cpp\n// SystemManager.h - System execution coordination\n#pragma once\n#include \"SystemBase.h\"\n#include <memory>\n#include <vector>\n#include <unordered_map>\n#include <typeindex>\n\nclass SystemManager {\nprivate:\n    std::vector<std::unique_ptr<SystemBase>> m_systems;\n    std::unordered_map<std::type_index, size_t> m_systemIndices;\n    std::vector<std::vector<size_t>> m_executionGroups;  // Systems grouped by dependencies\n    bool m_systemsInitialized;\n    \npublic:\n    SystemManager() : m_systemsInitialized(false) {}\n    \n    template<typename SystemType, typename... Args>\n    void RegisterSystem(Args&&... args) {\n        auto system = std::make_unique<SystemType>(std::forward<Args>(args)...);\n        std::type_index typeIndex(typeid(SystemType));\n        \n        m_systemIndices[typeIndex] = m_systems.size();\n        m_systems.push_back(std::move(system));\n        \n        m_systemsInitialized = false;  // Need to rebuild execution order\n    }\n    \n    template<typename SystemType>\n    SystemType* GetSystem() {\n        std::type_index typeIndex(typeid(SystemType));\n        auto it = m_systemIndices.find(typeIndex);\n        if (it != m_systemIndices.end()) {\n            return static_cast<SystemType*>(m_systems[it->second].get());\n        }\n        return nullptr;\n    }\n    \n    void Initialize() {\n        for (auto& system : m_systems) {\n            system->Initialize();\n        }\n        BuildExecutionOrder();\n        m_systemsInitialized = true;\n    }\n    \n    void UpdateSystems(float deltaTime) {\n        if (!m_systemsInitialized) {\n            return;\n        }\n        \n        // Execute systems in dependency order\n        for (const auto& group : m_executionGroups) {\n            for (size_t systemIndex : group) {\n                m_systems[systemIndex]->Update(deltaTime);\n            }\n        }\n    }\n    \nprivate:\n    void BuildExecutionOrder() {\n        // TODO 1: Analyze component read/write dependencies for each system\n        // TODO 2: Build dependency graph based on component access patterns\n        // TODO 3: Perform topological sort to determine execution order\n        // TODO 4: Group systems with no dependencies for potential parallel execution\n        // TODO 5: Store execution groups in m_executionGroups\n        \n        // Simple implementation: execute in registration order\n        m_executionGroups.clear();\n        for (size_t i = 0; i < m_systems.size(); ++i) {\n            m_executionGroups.push_back({i});\n        }\n    }\n};\n\n// SystemBase.h - Base interface for all systems\n#pragma once\n\nclass SystemBase {\npublic:\n    virtual ~SystemBase() = default;\n    virtual void Initialize() = 0;\n    virtual void Update(float deltaTime) = 0;\n    virtual void Shutdown() = 0;\n    \n    // Dependency analysis for execution ordering\n    virtual std::vector<std::type_index> GetReadComponents() const = 0;\n    virtual std::vector<std::type_index> GetWriteComponents() const = 0;\n};\n```\n\n#### Resource Loading Coordination\n\nComplete resource management system with async loading and handle validation:\n\n```cpp\n// ResourceManager.h - Complete resource loading infrastructure\n#pragma once\n#include \"Handle.h\"\n#include <unordered_map>\n#include <thread>\n#include <atomic>\n#include <functional>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n\nenum class ResourceType : uint16_t {\n    Texture = 1,\n    Mesh = 2,\n    Audio = 3,\n    Shader = 4\n};\n\nenum class LoadState {\n    Unloaded,\n    Loading,\n    Loaded,\n    Failed\n};\n\nstruct LoadRequest {\n    std::string filepath;\n    ResourceType type;\n    std::function<void(Handle<void>, LoadState)> callback;\n    int priority;\n    \n    bool operator<(const LoadRequest& other) const {\n        return priority < other.priority;  // Higher priority first\n    }\n};\n\ntemplate<typename T>\nstruct ResourceEntry {\n    T resource;\n    std::atomic<LoadState> state;\n    std::atomic<uint32_t> referenceCount;\n    uint16_t version;\n    std::string filepath;\n    \n    ResourceEntry() : state(LoadState::Unloaded), referenceCount(0), version(1) {}\n};\n\nclass ResourceManager {\nprivate:\n    // Resource storage by type\n    std::vector<ResourceEntry<TextureResource>> m_textures;\n    std::vector<ResourceEntry<MeshResource>> m_meshes;\n    std::vector<ResourceEntry<AudioResource>> m_audioClips;\n    \n    // Handle mapping\n    std::unordered_map<std::string, TextureHandle> m_textureHandles;\n    std::unordered_map<std::string, MeshHandle> m_meshHandles;\n    std::unordered_map<std::string, AudioHandle> m_audioHandles;\n    \n    // Async loading infrastructure\n    std::priority_queue<LoadRequest> m_loadQueue;\n    std::vector<std::thread> m_workerThreads;\n    std::mutex m_queueMutex;\n    std::condition_variable m_queueCondition;\n    std::atomic<bool> m_shouldStop;\n    \n    // Thread-safe resource access\n    std::mutex m_texturesMutex;\n    std::mutex m_meshesMutex;\n    std::mutex m_audioMutex;\n    \npublic:\n    ResourceManager() : m_shouldStop(false) {\n        // Start worker threads for async loading\n        size_t numThreads = std::max(1u, std::thread::hardware_concurrency() / 2);\n        for (size_t i = 0; i < numThreads; ++i) {\n            m_workerThreads.emplace_back(&ResourceManager::WorkerThread, this);\n        }\n    }\n    \n    ~ResourceManager() {\n        Shutdown();\n    }\n    \n    TextureHandle LoadTexture(const std::string& filepath) {\n        // TODO 1: Check if texture already loaded, return existing handle if found\n        // TODO 2: Create new texture entry and handle\n        // TODO 3: Load texture data from file synchronously\n        // TODO 4: Upload texture data to GPU\n        // TODO 5: Update texture entry state to Loaded\n        // TODO 6: Return valid handle\n        return TextureHandle{};  // Placeholder\n    }\n    \n    void LoadTextureAsync(const std::string& filepath, \n                         std::function<void(TextureHandle, LoadState)> callback) {\n        // TODO 1: Check if texture already exists, call callback immediately if loaded\n        // TODO 2: Create texture entry and handle for async loading\n        // TODO 3: Queue load request with callback\n        // TODO 4: Wake worker thread to process request\n    }\n    \n    TextureResource* GetTexture(TextureHandle handle) {\n        // TODO 1: Validate handle (check ID, version, type)\n        // TODO 2: Check if resource is in Loaded state\n        // TODO 3: Return resource pointer or nullptr if invalid/not loaded\n        return nullptr;  // Placeholder\n    }\n    \n    void AddReference(TextureHandle handle) {\n        // TODO 1: Validate handle\n        // TODO 2: Increment reference count atomically\n    }\n    \n    void RemoveReference(TextureHandle handle) {\n        // TODO 1: Validate handle\n        // TODO 2: Decrement reference count atomically\n        // TODO 3: Queue for cleanup if reference count reaches zero\n    }\n    \nprivate:\n    void WorkerThread() {\n        while (!m_shouldStop) {\n            LoadRequest request;\n            \n            // Wait for work\n            {\n                std::unique_lock<std::mutex> lock(m_queueMutex);\n                m_queueCondition.wait(lock, [this] { \n                    return !m_loadQueue.empty() || m_shouldStop; \n                });\n                \n                if (m_shouldStop) break;\n                \n                request = m_loadQueue.top();\n                m_loadQueue.pop();\n            }\n            \n            // Process load request\n            ProcessLoadRequest(request);\n        }\n    }\n    \n    void ProcessLoadRequest(const LoadRequest& request) {\n        // TODO 1: Load resource data from file based on request.type\n        // TODO 2: Upload to GPU if necessary (textures, meshes)\n        // TODO 3: Update resource entry state\n        // TODO 4: Call completion callback with result\n    }\n    \n    void Shutdown() {\n        m_shouldStop = true;\n        m_queueCondition.notify_all();\n        \n        for (auto& thread : m_workerThreads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n};\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Rendering Foundation):**\n- Run: Create window, verify frame loop runs at stable 60fps\n- Test: `FrameTimer` reports consistent delta times around 16.67ms\n- Verify: Window processes close events and terminates gracefully\n\n**After Milestone 2 (ECS Implementation):**\n- Run: Create entities, add components, register systems\n- Test: System execution order respects component dependencies\n- Verify: `EventSystem` delivers events between systems correctly\n\n**After Milestone 3 (Physics Integration):**\n- Run: Physics simulation with multiple bodies and collisions\n- Test: Fixed timestep maintains deterministic behavior\n- Verify: Collision events trigger appropriate system responses\n\n**After Milestone 4 (Resource Management):**\n- Run: Load textures and meshes both synchronously and asynchronously\n- Test: Resource handles remain valid across hot reloading\n- Verify: Reference counting prevents premature resource cleanup\n\n#### Debugging System Interactions\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---|---|---|\n| Inconsistent entity behavior | System execution order wrong | Log system execution sequence | Implement proper dependency analysis |\n| Frame rate drops during loading | Synchronous loading on main thread | Profile frame phases | Move asset loading to background threads |\n| Visual glitches after scene change | Resource cleanup during transition | Check resource reference counts | Implement two-phase scene transitions |\n| Events not delivered | Event processing timing wrong | Check event queue processing order | Process events at start of frame cycle |\n| Handle validation failures | Stale handles after hot reload | Log handle version mismatches | Update handle versions during resource reload |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones (1-4) — robust error handling is essential throughout development as each subsystem introduces failure modes that must be handled gracefully\n\nGame engines operate in an unforgiving real-time environment where failures can cascade rapidly across interconnected systems. Think of error handling in a game engine like **emergency protocols in an air traffic control tower** — when one system fails, you need immediate detection, graceful degradation, and rapid recovery to prevent the entire operation from collapsing. Unlike typical applications that can afford to crash and restart, game engines must maintain the illusion of a continuous, responsive world even when components fail.\n\nThe challenge of game engine error handling stems from three fundamental constraints. First, the **frame time budget** of 16.67 milliseconds leaves no room for expensive recovery operations during normal frame processing. Second, the **interdependency between systems** means that a graphics driver crash can affect physics simulation, or a resource loading failure can break rendering. Third, the **real-time nature** of games means users expect immediate feedback when something goes wrong, not cryptic error messages or frozen screens.\n\nModern game engines must handle failures across multiple domains simultaneously. Graphics hardware can lose context, run out of memory, or encounter driver bugs. Physics simulations can encounter numerical instability, object tunneling, or collision jitter. Resource loading can fail due to corrupted files, network timeouts, or insufficient memory. Each failure mode requires a different recovery strategy that maintains engine stability while preserving game state integrity.\n\nThe mental model for effective game engine error handling is a **layered defense system** with multiple fallback positions. The outer layer attempts to prevent errors through validation and defensive programming. The middle layer detects errors early and attempts local recovery. The inner layer provides graceful degradation and user notification when recovery isn't possible. Each layer has clearly defined responsibilities and failure escalation paths.\n\n### Graphics and Shader Error Recovery\n\nGraphics errors represent some of the most critical failures in game engines because rendering failures are immediately visible to users and can cascade through the entire frame pipeline. The graphics system operates in a hostile environment where driver bugs, hardware limitations, and resource exhaustion are constant threats that must be anticipated and handled gracefully.\n\n#### OpenGL Context Loss Recovery\n\nOpenGL context loss occurs when the graphics driver resets due to GPU hangs, driver crashes, or system power management events. When context loss happens, all GPU resources become invalid and must be recreated from scratch. The engine must detect this condition quickly and rebuild the entire graphics state without crashing or corrupting the frame pipeline.\n\n| Context Loss Scenario | Trigger Condition | Detection Method | Recovery Strategy |\n|----------------------|-------------------|------------------|-------------------|\n| GPU Driver Crash | Invalid GPU commands | `glGetError()` returns `GL_CONTEXT_LOST` | Full context recreation |\n| Power Management | System enters sleep mode | Render commands fail silently | Resource validation and reload |\n| Hardware Failure | GPU memory corruption | Frame buffer corruption | Fallback to software rendering |\n| Driver Update | Graphics driver replacement | Context creation failure | Context recreation with validation |\n| Resource Exhaustion | Out of video memory | Texture/buffer allocation fails | Resource cleanup and retry |\n\nThe context loss recovery process follows a structured sequence that rebuilds graphics state incrementally. First, the `Window` detects context loss by monitoring OpenGL error states and render command success. When context loss is detected, the system enters recovery mode and stops all rendering operations to prevent further corruption. Next, the `Renderer` invalidates all cached OpenGL state including vertex array objects, buffer objects, and texture handles. The system then recreates the OpenGL context through the windowing system and reinitializes all graphics resources from their CPU-side copies.\n\n**Context Loss Detection Implementation:**\n\n| Detection Point | Check Method | Error Condition | Action Taken |\n|-----------------|--------------|-----------------|--------------|\n| Frame Start | `glGetError()` after swap | `GL_CONTEXT_LOST` | Enter recovery mode |\n| Texture Upload | Check `glTexImage2D` result | Function returns false | Mark texture invalid |\n| Shader Compilation | Check compilation status | Compilation fails | Use fallback shader |\n| Buffer Binding | Verify buffer object validity | Buffer ID invalid | Recreate buffer |\n| Draw Call Execution | Monitor `glDrawElements` | Silent failure | Validate all state |\n\nThe `ShaderProgram` class maintains CPU-side copies of all shader source code and compilation parameters to enable rapid recreation after context loss. When the graphics context is restored, shaders are recompiled in dependency order, starting with the most critical rendering programs and falling back to simpler shaders if compilation fails. The system validates each shader compilation step and provides detailed error reporting to help diagnose driver-specific issues.\n\n> **Recovery Strategy**: The key insight for context loss recovery is maintaining **parallel state tracking** — every GPU resource must have a CPU-side representation that can be used to recreate the resource exactly. This doubles memory usage but enables robust recovery from any graphics failure.\n\n#### Shader Compilation Error Handling\n\nShader compilation failures can occur due to syntax errors in shader source code, driver bugs that reject valid GLSL, or hardware limitations that prevent certain shader features from working. The shader system must detect these failures early and provide meaningful fallbacks that maintain visual continuity while reporting diagnostic information.\n\nThe `ShaderProgram` compilation process implements a multi-stage validation pipeline that catches errors at each compilation phase. First, the system validates shader source code syntax using regex patterns to catch common mistakes before attempting GPU compilation. Next, individual shaders are compiled with detailed error reporting that captures line numbers and error descriptions. The system then attempts program linking and validates all uniform and attribute bindings. Finally, a runtime validation pass ensures the shader can execute successfully with typical input data.\n\n| Shader Error Type | Detection Phase | Error Symptoms | Recovery Action |\n|-------------------|----------------|----------------|-----------------|\n| Syntax Error | Source compilation | Compilation log contains errors | Use fallback shader |\n| Link Error | Program linking | Link status reports failure | Try alternative shader variants |\n| Uniform Error | Runtime validation | Uniform location is -1 | Skip uniform updates |\n| Attribute Error | Vertex setup | Attribute location invalid | Use default vertex format |\n| Hardware Limitation | Feature detection | Extension not supported | Disable advanced features |\n\nThe shader fallback system maintains a hierarchy of increasingly simple shaders that can substitute for complex programs when compilation fails. A sophisticated PBR shader might fall back to basic Phong lighting, then to unlit textured rendering, and finally to solid color rendering if all other options fail. This ensures that objects remain visible even when advanced rendering features are unavailable.\n\n**Shader Error Recovery Flowchart:**\n\n1. **Attempt Primary Shader Compilation**: Load vertex and fragment shader source files and compile them individually\n2. **Validate Compilation Results**: Check compilation status and parse error logs for specific failure information  \n3. **Try Progressive Fallbacks**: If compilation fails, attempt simpler shader variants in order of decreasing complexity\n4. **Cache Working Configurations**: Remember which shaders work on the current hardware to avoid repeated failures\n5. **Report Diagnostic Information**: Log shader errors with full context including GPU vendor, driver version, and source code\n6. **Update Rendering Pipeline**: Ensure fallback shaders provide compatible uniforms and vertex attributes\n7. **Validate Runtime Performance**: Confirm fallback shaders maintain acceptable frame rate performance\n\n> **Decision: Fallback Shader Strategy**\n> - **Context**: Shader compilation can fail due to driver bugs, hardware limitations, or syntax errors, but rendering must continue\n> - **Options Considered**: (1) Crash on shader failure, (2) Skip rendering for failed objects, (3) Progressive fallback system\n> - **Decision**: Implement progressive fallback with multiple shader complexity levels\n> - **Rationale**: Maintains visual continuity while providing graceful degradation path for unsupported hardware\n> - **Consequences**: Requires maintaining multiple shader variants but ensures rendering never completely fails\n\n#### Texture Loading Error Recovery\n\nTexture loading failures can stem from corrupted image files, unsupported formats, insufficient GPU memory, or file system errors. The texture system must handle these failures gracefully while providing visual feedback that helps identify missing assets without breaking the rendering pipeline.\n\nThe `TextureResource` loading pipeline implements comprehensive validation at each stage of the texture creation process. File validation occurs first, checking for file existence, read permissions, and basic format headers before attempting full image decoding. Image decoding validation ensures pixel data integrity and handles format conversion errors gracefully. GPU upload validation confirms texture creation success and handles out-of-memory conditions by reducing texture quality or using compression.\n\n| Texture Error Source | Failure Symptoms | Detection Method | Recovery Strategy |\n|----------------------|------------------|------------------|-------------------|\n| Missing File | File not found error | `fopen()` returns null | Use default \"missing\" texture |\n| Corrupted Data | Image decode failure | PNG/JPEG library error | Try alternative formats |\n| Format Unsupported | Decode returns invalid data | Invalid pixel format | Convert to supported format |\n| GPU Memory Full | Texture creation fails | `glTexImage2D` error | Reduce texture resolution |\n| Size Limitations | Texture too large | Exceeds `GL_MAX_TEXTURE_SIZE` | Resize to maximum supported |\n\nThe fallback texture system provides a clear visual indication when textures fail to load while maintaining rendering pipeline compatibility. A default \"missing texture\" pattern uses a distinctive purple/pink checkerboard that's immediately recognizable to developers while remaining visually acceptable to end users. For production builds, the system can substitute placeholder textures that match expected content categories (terrain, character, UI, etc.).\n\n**Texture Memory Management Strategy:**\n\n| Memory Pressure Level | Detection Criteria | Response Action | Fallback Quality |\n|-----------------------|-------------------|-----------------|------------------|\n| Normal Operation | All textures load successfully | No action required | Full resolution |\n| Mild Pressure | Occasional allocation failures | Compress new textures | 50% resolution |\n| High Pressure | Frequent allocation failures | Compress existing textures | 25% resolution |\n| Critical Pressure | Most allocations fail | Unload unused textures | Essential only |\n| Out of Memory | All allocations fail | Emergency garbage collection | Minimum viable set |\n\n### Physics Simulation Edge Cases\n\nPhysics simulations are inherently unstable numerical systems that can exhibit chaotic behavior when edge cases aren't handled properly. Small numerical errors can compound rapidly, leading to objects flying apart, falling through floors, or jittering uncontrollably. The physics system must implement robust error detection and correction mechanisms that maintain simulation stability while preserving realistic behavior.\n\n#### Tunneling Prevention\n\n**Tunneling** occurs when fast-moving objects pass completely through thin barriers between physics timesteps without collision detection registering contact. This happens because discrete collision detection only checks object positions at specific time intervals, missing intermediate collisions that occur between frames. High-speed projectiles are particularly susceptible to tunneling through walls, floors, or other collision geometry.\n\nThe tunneling prevention system combines multiple strategies to ensure collision detection captures all contacts regardless of object velocity. **Continuous collision detection** traces the path of fast-moving objects between timesteps, checking for intersections along the entire movement trajectory rather than just at endpoints. **Swept volume testing** expands collision shapes to cover the entire movement path, ensuring collision detection captures any intermediate contacts.\n\n| Tunneling Scenario | Object Velocity | Collision Shape | Prevention Method |\n|--------------------|----------------|-----------------|-------------------|\n| Bullet vs Thin Wall | >1000 units/sec | Small sphere | Continuous raycast |\n| Fast Character vs Floor | >500 units/sec | Capsule | Swept shape test |\n| Projectile vs Moving Target | Relative >800 units/sec | AABB | Temporal coherence |\n| Small Object vs Mesh | >300 units/sec | Point | Expanded bounding volume |\n| Rotating Object | >720 degrees/sec | Complex shape | Conservative advancement |\n\nThe **Conservative Advancement Algorithm** provides the most robust solution to tunneling by advancing simulation time in small increments until the first collision is detected. This algorithm calculates the time of impact for each potential collision pair and advances the simulation to the earliest collision time, resolves that collision, then continues with remaining simulation time. This ensures no collisions are missed regardless of object velocity or simulation timestep size.\n\n**Tunneling Detection Process:**\n\n1. **Calculate Movement Bounds**: For each moving object, compute the swept AABB that encompasses start and end positions\n2. **Identify Potential Tunneling**: Check if movement distance exceeds collision shape dimensions or barrier thickness\n3. **Perform Continuous Query**: Raycast or sweep test along movement path to detect intermediate collisions\n4. **Calculate Impact Time**: Determine exact time when collision first occurs along movement trajectory\n5. **Advance to Collision**: Move simulation forward to collision time and process impact normally\n6. **Continue with Remaining Time**: Apply remaining timestep after collision resolution\n7. **Validate Final State**: Ensure no objects remain in penetrating state after tunneling prevention\n\n> **Decision: Tunneling Prevention Strategy**\n> - **Context**: Fast-moving objects can pass through barriers between timesteps, breaking physics consistency\n> - **Options Considered**: (1) Smaller timesteps, (2) Velocity clamping, (3) Continuous collision detection\n> - **Decision**: Implement selective continuous collision detection for high-velocity objects\n> - **Rationale**: Maintains simulation stability without performance penalty for slow-moving objects\n> - **Consequences**: Adds complexity but prevents the most common physics simulation failures\n\n#### Collision Jitter Reduction\n\n**Collision jitter** manifests as rapid oscillation when objects are in resting contact, caused by numerical precision errors that cause objects to alternate between penetrating and separating states each frame. This creates visually distracting vibration and can destabilize stacks of objects or cause perpetual motion in systems that should be at rest.\n\nThe jitter reduction system addresses numerical instability through several complementary techniques. **Penetration tolerance** allows small overlaps to persist without correction, reducing sensitivity to floating-point errors. **Velocity damping** gradually reduces oscillation energy in objects that are nearly at rest. **Position correction limiting** prevents overcorrection that can cause objects to separate too far and fall back together.\n\n| Jitter Source | Manifestation | Root Cause | Correction Method |\n|---------------|---------------|-------------|-------------------|\n| Floating Point Error | Micro-oscillation | Limited numerical precision | Penetration tolerance |\n| Overcorrection | Bouncing separation | Excessive position correction | Correction damping |\n| Velocity Accumulation | Growing oscillation | Energy not being removed | Velocity damping |\n| Timestep Quantization | Frame-rate dependent jitter | Discrete simulation steps | Temporal smoothing |\n| Constraint Conflicts | Chaotic movement | Contradictory constraints | Constraint prioritization |\n\nThe **Baumgarte Stabilization** technique provides robust jitter reduction by combining position correction with velocity adjustment. When objects are penetrating, the system calculates both the position correction needed to separate them and a velocity bias that prevents them from moving back together immediately. The velocity bias gradually decreases over multiple frames, allowing objects to settle into stable contact without oscillation.\n\n**Jitter Reduction Parameters:**\n\n| Parameter | Typical Value | Purpose | Effect of Tuning |\n|-----------|---------------|---------|------------------|\n| `PENETRATION_TOLERANCE` | 0.01f units | Minimum overlap to ignore | Higher = more stable, less precise |\n| `POSITION_CORRECTION_PERCENT` | 0.8f | Fraction of overlap to correct | Lower = less aggressive correction |\n| `VELOCITY_DAMPING_FACTOR` | 0.98f per second | Rate of energy removal | Higher = more damping |\n| `REST_VELOCITY_THRESHOLD` | 0.5f units/sec | Speed below which damping applies | Higher = more objects affected |\n| `CORRECTION_ITERATIONS` | 4 | Solver iteration count | More = stabler but slower |\n\n> **Performance vs Stability Trade-off**: Jitter reduction requires careful parameter tuning because aggressive stabilization can make physics feel \"mushy\" or unresponsive, while insufficient stabilization causes visible artifacts. The sweet spot varies by game genre and visual style.\n\n#### Numerical Stability Maintenance\n\nPhysics simulations accumulate numerical errors over time that can cause catastrophic instability if not managed proactively. Small floating-point precision errors compound through integration steps, constraint solving, and collision response calculations, eventually leading to explosive behavior where objects gain infinite energy or assume invalid positions.\n\nThe numerical stability system monitors simulation health through multiple invariants and corrective mechanisms. **Energy conservation tracking** ensures the total system energy remains bounded and decreases over time due to damping. **Position bounds validation** detects objects that have moved to extreme coordinates indicating numerical overflow. **Velocity clamping** prevents objects from exceeding physically reasonable speeds that could cause integration errors.\n\n| Stability Metric | Normal Range | Warning Threshold | Critical Threshold | Corrective Action |\n|-------------------|--------------|-------------------|-------------------|-------------------|\n| Total System Energy | Game dependent | 2x initial | 10x initial | Apply global damping |\n| Maximum Object Velocity | <100 units/sec | >500 units/sec | >1000 units/sec | Clamp velocity |\n| Integration Error | <0.01 units | >0.1 units | >1.0 units | Reduce timestep |\n| Constraint Error | <0.001 units | >0.01 units | >0.1 units | Reset constraints |\n| Floating Point Validity | All finite values | NaN detected | Infinity detected | Reset object state |\n\nThe **Simulation Health Monitor** runs continuously during physics updates, checking for early warning signs of numerical instability. When warning thresholds are exceeded, the system applies gentle corrective measures like increased damping or constraint relaxation. When critical thresholds are reached, the system performs emergency stabilization including object state reset or temporary constraint disabling.\n\n**Numerical Error Detection Algorithm:**\n\n1. **Pre-Integration Validation**: Check all object states for NaN/infinity values before physics step\n2. **Energy Delta Calculation**: Measure total system energy change and compare to expected damping\n3. **Velocity Magnitude Monitoring**: Track maximum object velocities and identify outliers\n4. **Position Bounds Checking**: Ensure all objects remain within reasonable world coordinates\n5. **Integration Error Estimation**: Calculate position prediction error for validation\n6. **Constraint Violation Measurement**: Check how well constraints are being satisfied\n7. **Corrective Action Application**: Apply appropriate stabilization measures based on error severity\n8. **Post-Integration Validation**: Verify simulation state remains stable after corrections\n\n⚠️ **Pitfall: Ignoring Accumulated Numerical Error**\nMany physics implementations ignore small numerical errors assuming they won't compound significantly. However, floating-point errors in iterative constraint solvers can grow exponentially, causing stable simulations to suddenly explode after running for extended periods. Always implement error bounds checking and periodic state normalization to prevent long-term instability.\n\n### Resource Loading Failure Handling\n\nResource loading operates in an uncertain environment where files can be corrupted, network connections can fail, and memory can be exhausted at any time. The resource management system must handle these failures gracefully while maintaining game functionality and providing clear feedback about asset problems.\n\n#### Fallback Resource Strategy\n\nWhen resource loading fails, the system must provide immediate substitutes that maintain game functionality while clearly indicating missing content. The fallback strategy implements a hierarchy of increasingly generic replacements that ensure rendering and audio systems never encounter null resources that could cause crashes.\n\nThe **Fallback Resource Hierarchy** provides multiple levels of replacement content based on resource type and criticality. Essential gameplay resources receive high-quality fallbacks that preserve game mechanics, while cosmetic resources use simple placeholders that maintain visual consistency. The system maintains pre-loaded fallback resources in memory that are immediately available when primary loading fails.\n\n| Resource Type | Primary Fallback | Secondary Fallback | Emergency Fallback |\n|---------------|------------------|-------------------|-------------------|\n| Character Texture | Default character skin | Solid color texture | Magenta error texture |\n| Environment Mesh | Low-detail substitute | Bounding box mesh | Single triangle |\n| Audio Clip | Silence placeholder | Beep sound | No audio output |\n| Animation Data | T-pose default | Identity transforms | Static pose |\n| Font Resource | System default font | Basic bitmap font | ASCII-only fallback |\n\nThe fallback selection process considers both the semantic meaning of missing resources and their impact on gameplay. A missing weapon texture might fall back to a generic weapon appearance, preserving the object's gameplay function while indicating the visual problem. A missing level mesh might use a simple geometric placeholder that maintains collision properties while clearly showing the missing content.\n\n**Fallback Resource Implementation:**\n\n| Fallback Strategy | Resource Coverage | Memory Cost | Quality Impact |\n|-------------------|-------------------|-------------|----------------|\n| Type-Specific Defaults | High semantic accuracy | Medium | Maintains game feel |\n| Generic Placeholders | Universal compatibility | Low | Clear error indication |\n| Procedural Generation | Infinite variety | Very Low | Acceptable quality |\n| Community Fallbacks | High visual quality | High | Professional appearance |\n| Asset Bundling | Guaranteed availability | Very High | Perfect fidelity |\n\n> **Decision: Fallback Resource Quality Level**\n> - **Context**: Resource loading failures require immediate substitutes but fallback quality affects user experience\n> - **Options Considered**: (1) Minimal placeholders, (2) High-quality defaults, (3) Procedural generation\n> - **Decision**: Type-specific defaults with clear error indication\n> - **Rationale**: Balances development effort with user experience while making missing assets obvious during development\n> - **Consequences**: Requires creating and maintaining fallback assets but prevents confusing user experiences\n\n#### Asynchronous Loading Error Propagation\n\nAsynchronous resource loading introduces complexity in error handling because failures occur on background threads and must be communicated back to game systems safely. The async loading system must ensure errors are reported promptly while maintaining thread safety and avoiding race conditions.\n\nThe **Error Propagation Pipeline** channels loading failures through a thread-safe communication system that delivers error information to the appropriate game systems. Background loading threads detect failures immediately and package error details into thread-safe messages that are queued for main thread processing. The main thread processes these error messages during the resource update phase and takes appropriate corrective action.\n\n| Error Source | Detection Thread | Propagation Method | Main Thread Action |\n|--------------|------------------|-------------------|-------------------|\n| File Not Found | Worker Thread | Error message queue | Load fallback resource |\n| Decode Failure | Worker Thread | Error message with details | Try alternative decoder |\n| Memory Exhaustion | Worker Thread | Priority error message | Free unused resources |\n| Network Timeout | Network Thread | Timeout notification | Retry with backoff |\n| Validation Failure | Worker Thread | Validation error report | Reject resource |\n\nThe `ThreadSafeQueue<LoadRequest>` system handles error communication by embedding error information directly in the loading request structure. When a loading operation fails, the worker thread updates the request status and error details, then pushes the failed request back to the main thread for error handling. This approach ensures all error information is preserved and properly synchronized.\n\n**Async Error Communication Flow:**\n\n1. **Background Loading**: Worker thread attempts resource loading operation\n2. **Error Detection**: Loading operation fails with specific error code and message\n3. **Error Packaging**: Thread packages error details into LoadRequest structure\n4. **Thread-Safe Queuing**: Error information is queued for main thread processing\n5. **Main Thread Processing**: Game loop processes error queue during resource update phase\n6. **Error Classification**: System determines error severity and appropriate response\n7. **Fallback Activation**: Appropriate fallback resource is loaded and assigned\n8. **User Notification**: Error is logged and optionally reported to user interface\n\n⚠️ **Pitfall: Race Conditions in Error Handling**\nAsync error handling can create race conditions where the main thread might try to use a resource that's failed loading but hasn't been marked as failed yet. Always use atomic operations or proper synchronization when updating resource status, and never assume a resource is valid just because it's not marked as failed.\n\n#### User Notification and Diagnostics\n\nWhen resource loading fails, users and developers need clear information about what went wrong and how to fix it. The notification system provides layered feedback that ranges from detailed diagnostic information for developers to simple status updates for end users.\n\nThe **Diagnostic Information System** captures comprehensive details about loading failures including file paths, error codes, system state, and recovery actions taken. For developers, this information appears in detailed log files with timestamps and stack traces. For end users, the system provides simplified notifications that explain the impact without technical details.\n\n| User Type | Notification Level | Information Provided | Presentation Method |\n|-----------|-------------------|---------------------|-------------------|\n| Developer | Full Diagnostic | Complete error details, stack trace, system state | Console log, debug overlay |\n| QA Tester | Intermediate | Resource name, error type, impact on functionality | In-game notification |\n| End User | Simplified | General problem description, suggested actions | Status message |\n| Support Staff | Technical Summary | Error categorization, frequency, system specs | Automated reports |\n| Analytics | Statistical | Error rates, patterns, hardware correlation | Telemetry dashboard |\n\nThe notification system implements **Error Categorization** that groups similar failures to avoid spamming users with redundant messages. If multiple textures fail to load due to memory exhaustion, the system reports a single \"insufficient video memory\" error rather than individual texture failures. This aggregation provides clearer diagnosis while reducing notification noise.\n\n**Error Reporting Data Structure:**\n\n| Field Name | Type | Purpose | Audience |\n|------------|------|---------|----------|\n| `errorCode` | `uint32_t` | Specific failure classification | Developers |\n| `errorMessage` | `string` | Human-readable description | All users |\n| `resourcePath` | `string` | Failed resource identifier | Developers/QA |\n| `systemState` | `string` | Memory/GPU status snapshot | Support staff |\n| `recoverActions` | `vector<string>` | Steps taken to handle failure | QA/Support |\n| `userImpact` | `enum` | Severity of user experience impact | End users |\n| `frequency` | `uint32_t` | How often this error occurs | Analytics |\n| `timestamp` | `uint64_t` | When error occurred | All audiences |\n\n> **User Experience Consideration**: Error notifications must strike a balance between providing useful information and avoiding alarm. End users don't need to know about fallback texture loading, but they should be informed if core gameplay features are affected by resource failures.\n\n### Implementation Guidance\n\nThe error handling implementation requires careful coordination between multiple engine subsystems to ensure failures are detected early, reported clearly, and handled gracefully without compromising performance or stability.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Logging | `printf` to console + file output | Structured logging with `spdlog` library |\n| Thread Communication | `std::mutex` + `std::queue` | Lock-free `boost::lockfree::queue` |\n| Graphics Debugging | Manual `glGetError()` checks | `GL_KHR_debug` callback system |\n| Physics Validation | Manual bounds checking | Continuous simulation monitoring |\n| Resource Validation | File existence + basic checks | Comprehensive asset validation pipeline |\n\n#### Recommended File Structure\n\nThe error handling code is distributed across multiple engine subsystems but centralized reporting provides consistent behavior:\n\n```cpp\nengine/\n├── core/\n│   ├── error_manager.h          // Central error reporting and categorization\n│   ├── error_manager.cpp        \n│   └── diagnostic_logger.h      // Detailed diagnostic information capture\n├── graphics/\n│   ├── gl_error_handler.h       // OpenGL-specific error detection\n│   ├── shader_validator.h       // Shader compilation error handling\n│   └── texture_fallbacks.h      // Graphics fallback resource system\n├── physics/\n│   ├── simulation_monitor.h     // Physics stability monitoring\n│   └── collision_validator.h    // Collision detection validation\n├── resources/\n│   ├── loading_error_handler.h  // Resource loading failure management\n│   └── fallback_manager.h       // Fallback resource coordination\n└── utils/\n    ├── thread_safe_queue.h      // Async error communication\n    └── performance_monitor.h    // System performance tracking\n```\n\n#### Graphics Error Detection Infrastructure\n\n```cpp\n// Complete OpenGL error checking wrapper that can be enabled/disabled for performance\nclass GLErrorChecker {\nprivate:\n    static bool s_enableChecking;\n    static std::unordered_map<GLenum, std::string> s_errorStrings;\n    \npublic:\n    static void EnableChecking(bool enable) { s_enableChecking = enable; }\n    \n    static bool CheckErrors(const char* operation, const char* file, int line) {\n        if (!s_enableChecking) return true;\n        \n        // TODO 1: Call glGetError() and store result\n        // TODO 2: If no error (GL_NO_ERROR), return true\n        // TODO 3: Look up error string in s_errorStrings map\n        // TODO 4: Log error with operation, file, and line information\n        // TODO 5: Check for context lost condition and trigger recovery\n        // TODO 6: Return false to indicate error occurred\n        // Hint: Use GL_CONTEXT_LOST_KHR for context loss detection\n    }\n    \n    static void InitializeErrorStrings() {\n        // Pre-populate error code to string mapping\n        s_errorStrings[GL_INVALID_ENUM] = \"Invalid enum parameter\";\n        s_errorStrings[GL_INVALID_VALUE] = \"Invalid value parameter\";\n        s_errorStrings[GL_INVALID_OPERATION] = \"Invalid operation for current state\";\n        s_errorStrings[GL_OUT_OF_MEMORY] = \"Insufficient GPU memory\";\n        s_errorStrings[GL_CONTEXT_LOST_KHR] = \"Graphics context lost\";\n    }\n};\n\n// Macro for automatic error checking with file/line information\n#define GL_CHECK(operation) \\\n    do { \\\n        operation; \\\n        GLErrorChecker::CheckErrors(#operation, __FILE__, __LINE__); \\\n    } while(0)\n\n// Shader compilation with comprehensive error handling\nclass ShaderCompiler {\npublic:\n    static bool CompileShader(uint32_t shaderID, const std::string& source, \n                             GLenum shaderType, std::string& errorLog) {\n        // TODO 1: Set shader source using glShaderSource\n        // TODO 2: Compile shader using glCompileShader  \n        // TODO 3: Check compilation status with glGetShaderiv(GL_COMPILE_STATUS)\n        // TODO 4: If compilation failed, retrieve error log with glGetShaderInfoLog\n        // TODO 5: Parse error log to extract line numbers and error descriptions\n        // TODO 6: Format user-friendly error message with context\n        // TODO 7: Return compilation success status\n        // Hint: Reserve adequate buffer size for error log (e.g., 1024 bytes)\n    }\n    \n    static bool LinkProgram(uint32_t programID, std::string& errorLog) {\n        // TODO 1: Link program using glLinkProgram\n        // TODO 2: Check link status with glGetProgramiv(GL_LINK_STATUS)  \n        // TODO 3: If linking failed, retrieve error log with glGetProgramInfoLog\n        // TODO 4: Validate program using glValidateProgram for additional checks\n        // TODO 5: Return linking success status\n    }\n};\n```\n\n#### Physics Stability Monitoring System\n\n```cpp\n// Comprehensive physics simulation health monitoring\nclass PhysicsMonitor {\nprivate:\n    struct SimulationMetrics {\n        float totalEnergy;\n        float maxVelocity;\n        float maxPosition;\n        uint32_t nanDetectedCount;\n        uint32_t tunnellingEvents;\n        uint32_t jitterObjects;\n    };\n    \n    SimulationMetrics m_currentMetrics;\n    SimulationMetrics m_baselineMetrics;\n    std::vector<float> m_energyHistory;\n    float m_stabilityThreshold;\n    \npublic:\n    bool ValidateSimulationState(const std::vector<RigidBody>& bodies) {\n        // TODO 1: Calculate total kinetic and potential energy\n        // TODO 2: Find maximum object velocity and position magnitude\n        // TODO 3: Check for NaN/infinity values in all object states\n        // TODO 4: Compare current metrics against baseline and thresholds\n        // TODO 5: Update energy history for trend analysis\n        // TODO 6: Detect objects with excessive jitter (rapid velocity changes)\n        // TODO 7: Count potential tunnelling candidates (high velocity vs size ratio)\n        // TODO 8: Return false if any critical thresholds exceeded\n        // Hint: Use std::isfinite() to check for invalid floating point values\n    }\n    \n    void ApplyStabilizationMeasures(std::vector<RigidBody>& bodies) {\n        // TODO 1: Apply velocity clamping to objects exceeding speed limits\n        // TODO 2: Reset positions for objects outside world bounds\n        // TODO 3: Apply additional damping to jittery objects\n        // TODO 4: Disable physics for objects with invalid state\n        // TODO 5: Log all corrective actions taken\n    }\n};\n\n// Tunnelling prevention for high-speed objects\nclass TunnellingPreventer {\npublic:\n    static bool CheckForTunnelling(const RigidBody& body, const Transform& oldTransform, \n                                  const Transform& newTransform, float deltaTime) {\n        // TODO 1: Calculate movement distance this frame\n        // TODO 2: Get collision shape dimensions\n        // TODO 3: Check if movement distance > shape size (potential tunnelling)\n        // TODO 4: If potential tunnelling, perform continuous collision detection\n        // TODO 5: Raycast from old position to new position\n        // TODO 6: If collision detected, calculate exact impact time and position\n        // TODO 7: Return true if tunnelling would occur without intervention\n    }\n    \n    static Vector3 CalculateSafePosition(const RigidBody& body, \n                                       const CollisionPair& collision, \n                                       float impactTime) {\n        // TODO 1: Calculate position at exact impact time\n        // TODO 2: Apply collision normal offset to prevent penetration\n        // TODO 3: Validate safe position doesn't cause new overlaps\n        // TODO 4: Return corrected position that prevents tunnelling\n    }\n};\n```\n\n#### Resource Loading Error Recovery System\n\n```cpp\n// Thread-safe error communication between async loaders and main thread\ntemplate<typename T>\nclass ThreadSafeErrorQueue {\nprivate:\n    mutable std::mutex m_mutex;\n    std::queue<T> m_queue;\n    std::condition_variable m_condition;\n    bool m_shutdown;\n    \npublic:\n    void Push(const T& item) {\n        // TODO 1: Lock mutex for thread-safe access\n        // TODO 2: Add item to queue\n        // TODO 3: Notify waiting threads that item is available\n        // TODO 4: Handle shutdown condition gracefully\n    }\n    \n    bool TryPop(T& item) {\n        // TODO 1: Try to lock mutex (don't block)\n        // TODO 2: If queue empty, return false immediately\n        // TODO 3: Copy front item and remove from queue\n        // TODO 4: Return true indicating successful pop\n    }\n    \n    bool WaitAndPop(T& item, std::chrono::milliseconds timeout) {\n        // TODO 1: Lock mutex and wait for item or timeout\n        // TODO 2: Check for shutdown condition\n        // TODO 3: If item available, copy and remove from queue\n        // TODO 4: Return success status\n    }\n};\n\n// Comprehensive resource loading error information\nstruct ResourceLoadError {\n    std::string resourcePath;\n    ResourceType resourceType;\n    uint32_t errorCode;\n    std::string errorMessage;\n    std::string systemState;\n    std::vector<std::string> recoveryActions;\n    std::chrono::time_point<std::chrono::steady_clock> timestamp;\n    uint32_t retryCount;\n    \n    // Error severity classification\n    enum class Severity {\n        INFO,       // Fallback used successfully\n        WARNING,    // Non-critical resource failed\n        ERROR,      // Important resource failed\n        CRITICAL    // Essential resource failed\n    } severity;\n};\n\n// Fallback resource manager with type-specific defaults\nclass FallbackResourceManager {\nprivate:\n    std::unordered_map<ResourceType, std::vector<Handle<void>>> m_fallbackHierarchy;\n    \npublic:\n    void InitializeFallbacks() {\n        // TODO 1: Load default fallback textures (error, missing, etc.)\n        // TODO 2: Create fallback audio clips (silence, beep)\n        // TODO 3: Generate fallback meshes (cube, sphere, plane)\n        // TODO 4: Set up fallback fonts and UI resources\n        // TODO 5: Organize fallbacks into quality hierarchy\n        // Hint: Load fallbacks during engine initialization to guarantee availability\n    }\n    \n    Handle<void> GetFallbackResource(ResourceType type, uint32_t qualityLevel) {\n        // TODO 1: Look up fallback hierarchy for resource type\n        // TODO 2: Select appropriate quality level (prefer highest available)\n        // TODO 3: Validate fallback resource is loaded and valid\n        // TODO 4: Log fallback usage for diagnostic purposes\n        // TODO 5: Return handle to fallback resource\n        // Hint: Always have at least one fallback per type to prevent null handles\n    }\n};\n```\n\n#### Milestone Checkpoints\n\n**Graphics Error Recovery Validation:**\n- Run engine with deliberately corrupted shader files — verify fallback shaders load\n- Simulate GPU memory exhaustion — confirm texture quality reduction works\n- Trigger context loss (minimize/restore window) — validate full recovery\n- Expected: Rendering continues with fallbacks, detailed error logs generated\n\n**Physics Stability Verification:**\n- Create high-speed projectiles — verify tunnelling prevention activates\n- Spawn jittery contact scenarios — confirm stabilization reduces oscillation  \n- Inject NaN values into physics state — validate error detection and correction\n- Expected: Simulation remains stable, diagnostic logs show corrective actions\n\n**Resource Loading Resilience Testing:**\n- Delete required texture files — verify fallback textures appear\n- Corrupt audio files — confirm silent fallbacks prevent crashes\n- Fill disk space during loading — validate graceful degradation\n- Expected: Game continues running, missing content clearly indicated\n\nThe comprehensive error handling system ensures your game engine remains stable and provides meaningful feedback when failures occur, creating a robust foundation for game development.\n\n\n## Testing Strategy and Milestones\n\n> **Milestone(s):** All milestones (1-4) — comprehensive testing strategy that validates each subsystem independently and as an integrated whole\n\nTesting a game engine is like **quality assuring a movie production pipeline**. Just as a film studio needs to verify that cameras capture footage properly, editors can process it, sound engineers can mix it, and projectors can display the final result, a game engine requires validation at every stage: individual systems must work in isolation, data must flow correctly between systems, and the complete pipeline must deliver smooth interactive experiences under performance constraints.\n\nThe fundamental challenge in game engine testing lies in the **real-time constraint**. Unlike traditional software where correctness is the primary concern, game engines must maintain consistent performance while handling thousands of entities, processing physics simulations, and rendering frames within a strict 16.67 millisecond budget. This creates unique testing requirements that blend functional verification with performance validation and stability analysis.\n\nGame engines also exhibit **emergent behavior** where the interaction between simple systems creates complex outcomes. A sprite might render incorrectly not because the rendering system is broken, but because the ECS query returns stale transforms, the physics system failed to update positions, or resource loading introduced memory corruption. This interconnectedness demands both isolated unit testing and comprehensive integration testing that exercises realistic game scenarios.\n\n### Milestone Verification Checkpoints\n\nEach milestone represents a foundational capability that all subsequent development depends upon. Think of these checkpoints as **structural inspections during construction** — before adding the next floor, you must verify that the current foundation can support the additional load. Failing to properly validate each milestone leads to cascading failures that become exponentially harder to debug as complexity increases.\n\nThe verification approach follows a three-tier strategy: **functional validation** ensures the system works correctly, **performance validation** ensures it meets real-time constraints, and **integration validation** ensures it cooperates properly with other subsystems.\n\n#### Milestone 1: Window & Rendering Foundation Verification\n\n**Mental Model: Theater Stage Setup**\n\nBefore actors can perform, the stage crew must verify that lighting works, curtains open and close properly, and sound equipment functions. Similarly, the rendering foundation must be thoroughly validated before any game content can be displayed.\n\nThe rendering system verification follows a systematic progression from basic functionality through performance stress testing:\n\n| Verification Phase | Test Objective | Success Criteria | Common Failure Modes |\n|-------------------|---------------|------------------|---------------------|\n| Window Creation | OS integration works | Window appears with correct dimensions, title, and responds to close events | Window fails to appear, wrong size, or crashes on creation |\n| Graphics Context | GPU communication established | OpenGL context initializes, can clear screen to different colors | Context creation fails, extensions missing, or driver compatibility issues |\n| Basic Drawing | Primitive rendering works | Single textured quad renders at correct position and size | Black screen, texture not loading, incorrect positioning |\n| Shader System | Programmable pipeline functions | Custom shaders compile, link, and render with different colors/effects | Shader compilation errors, linking failures, uniform variables not working |\n| Batch Rendering | Performance optimization active | Multiple sprites render efficiently with minimal draw calls | Poor performance, visual artifacts, incorrect sprite ordering |\n\n**Functional Validation Tests:**\n\n1. **Window Lifecycle Test**: Create window, resize it, minimize/restore, and close cleanly. The `Window` class should handle all events without memory leaks or crashes.\n\n2. **Graphics Context Robustness**: Initialize OpenGL context, verify required extensions exist, and handle context loss scenarios gracefully.\n\n3. **Texture Loading Pipeline**: Load various image formats (PNG, JPG), handle invalid files, and verify GPU upload completes successfully.\n\n4. **Shader Compilation Verification**: Load valid vertex/fragment shader pairs, test compilation error handling with malformed shaders, and verify uniform variable access.\n\n5. **Basic Sprite Rendering**: Draw single sprite with correct position, rotation, scale, and color. Verify texture coordinates map properly and alpha blending works.\n\n**Performance Validation Tests:**\n\n1. **Frame Rate Consistency**: Render 100 sprites and measure frame times. Should maintain 60 FPS consistently without significant variance.\n\n2. **Batch Efficiency**: Compare rendering 1000 individual sprites versus batched rendering. Batching should reduce draw calls from 1000 to 1-10.\n\n3. **Memory Usage Stability**: Run rendering loop for extended periods and verify no memory leaks in texture or shader resources.\n\n**Integration Validation Tests:**\n\n1. **Event Processing**: Verify window events (resize, input) are processed correctly during active rendering.\n\n2. **Resource Cleanup**: Ensure proper cleanup when window closes or graphics context is lost.\n\n> **Critical Checkpoint**: After Milestone 1, you should be able to run a simple program that opens a window, loads a texture, and displays a rotating sprite at 60 FPS without memory leaks or crashes.\n\n#### Milestone 2: Entity Component System Verification\n\n**Mental Model: Database Query Performance Testing**\n\nThe ECS is like a specialized database optimized for real-time queries. Just as database administrators run performance tests to ensure query response times meet SLA requirements, ECS verification must validate both correctness and performance under realistic entity loads.\n\nECS testing focuses heavily on **data integrity** and **performance characteristics** because subtle bugs in entity management or component storage can corrupt game state in ways that manifest much later:\n\n| Verification Phase | Test Objective | Success Criteria | Performance Target |\n|-------------------|---------------|------------------|-------------------|\n| Entity Management | ID recycling works correctly | Create/destroy entities without ID collisions or leaks | Handle 10,000+ entities |\n| Component Storage | Data remains consistent | Add/remove components maintains entity-component relationships | O(1) access times |\n| System Execution | Iteration is cache-friendly | Systems process entities efficiently without skipping or duplicating | Process 5,000+ entities per system |\n| Query Performance | Component filtering is fast | Multi-component queries return correct entity sets | Sub-millisecond query times |\n\n**Functional Validation Tests:**\n\n1. **Entity ID Recycling**: Create entities until ID space fills, destroy some, create new ones. Verify IDs are recycled correctly and no collisions occur.\n\n2. **Component Lifetime Management**: Add components to entities, remove them, verify memory is cleaned up and entity relationships remain consistent.\n\n3. **System Execution Order**: Register systems with dependencies, verify execution order respects dependency graph.\n\n4. **Multi-Component Queries**: Create entities with various component combinations, run queries for specific signatures, verify correct entities are returned.\n\n5. **Entity Destruction Cascade**: Destroy entities with multiple components, verify all component references are cleaned up properly.\n\n**Performance Validation Tests:**\n\n1. **Component Iteration Performance**: Time system iteration over 10,000 entities with various component densities. Should complete in under 1ms per system.\n\n2. **Memory Layout Efficiency**: Measure cache miss rates during component iteration using performance counters or profiling tools.\n\n3. **Query Scalability**: Benchmark query performance as entity count increases from 1,000 to 100,000 entities.\n\n**Integration Validation Tests:**\n\n1. **Rendering Integration**: Create entities with `Transform` and `Sprite` components, verify rendering system processes them correctly.\n\n2. **Component Modification During Iteration**: Test adding/removing components while systems are executing, ensure no crashes or data corruption.\n\n> **Critical Checkpoint**: After Milestone 2, you should be able to create 10,000 entities with mixed components, run multiple systems that process them in under 1ms each, and destroy entities without memory leaks.\n\n#### Milestone 3: Physics & Collision Verification\n\n**Mental Model: Scientific Experiment Validation**\n\nPhysics simulation is like conducting repeatable scientific experiments. The same initial conditions must always produce identical results, energy should be conserved (within numerical precision), and the simulation should remain stable over extended periods.\n\nPhysics testing requires special attention to **numerical stability** and **determinism**. Small floating-point errors can accumulate over time, leading to objects slowly gaining energy, falling through floors, or exhibiting other non-physical behaviors:\n\n| Verification Phase | Test Objective | Success Criteria | Stability Requirement |\n|-------------------|---------------|------------------|----------------------|\n| Collision Detection | Geometric accuracy | AABB and circle intersections detected correctly | No false positives/negatives |\n| Physics Integration | Energy conservation | Objects don't gain energy spontaneously | Energy drift < 1% over 1000 frames |\n| Collision Response | Realistic behavior | Objects bounce and separate naturally | No penetration or jitter |\n| Spatial Partitioning | Performance scaling | Collision detection remains fast with many objects | O(n log n) or better |\n| Timestep Stability | Deterministic results | Same inputs always produce same outputs | Bit-identical across runs |\n\n**Functional Validation Tests:**\n\n1. **Basic Collision Detection**: Test AABB vs AABB and circle vs circle intersection with known geometric cases, verify accuracy.\n\n2. **Physics Integration**: Drop objects under gravity, measure velocities and positions, verify they match analytical solutions.\n\n3. **Collision Response**: Collide objects with different masses and velocities, verify momentum and energy are conserved approximately.\n\n4. **Spatial Partitioning Correctness**: Distribute objects across space, verify spatial queries return correct neighbor sets.\n\n5. **Edge Case Handling**: Test objects at cell boundaries, very small objects, and high-velocity collisions.\n\n**Performance Validation Tests:**\n\n1. **Collision Scaling**: Measure collision detection time as object count increases. Should scale better than O(n²).\n\n2. **Physics Timestep Consistency**: Run physics simulation and measure frame processing times. Should complete reliably within timestep budget.\n\n3. **Memory Access Pattern**: Profile cache performance during collision detection, optimize for spatial locality.\n\n**Stability Validation Tests:**\n\n1. **Energy Conservation**: Run simulation with bouncing balls for 10,000 timesteps, verify total energy remains approximately constant.\n\n2. **Determinism Verification**: Run identical scenarios multiple times, verify positions and velocities match exactly.\n\n3. **Numerical Stability**: Test extreme cases (very light/heavy objects, high velocities, many contacts) and verify simulation remains stable.\n\n**Integration Validation Tests:**\n\n1. **ECS Integration**: Verify physics system correctly updates `Transform` components, rendering system displays updated positions.\n\n2. **Multi-System Coordination**: Test physics running alongside other systems without interference or race conditions.\n\n> **Critical Checkpoint**: After Milestone 3, you should be able to simulate 500+ rigid bodies with realistic physics behavior, stable energy levels over extended periods, and deterministic results across multiple runs.\n\n#### Milestone 4: Resource & Scene Management Verification\n\n**Mental Model: Library Management System**\n\nResource management is like running a library where books (assets) must be checked out, tracked, returned, and replaced when damaged. The system must handle concurrent requests, prevent loss of materials, and maintain accurate records even when patrons behave unexpectedly.\n\nResource system testing emphasizes **lifecycle management** and **concurrency safety** because resource leaks and loading race conditions are common sources of instability:\n\n| Verification Phase | Test Objective | Success Criteria | Reliability Target |\n|-------------------|---------------|------------------|-------------------|\n| Asset Loading | File formats supported | Load textures, meshes, audio from various formats | Handle corrupt/missing files |\n| Reference Counting | No resource leaks | Resources freed when no longer referenced | Zero leaks over extended use |\n| Async Loading | Thread safety | Background loading without blocking main thread | No race conditions |\n| Scene Serialization | Data persistence | Save/load scenes with full fidelity | Bit-identical round trips |\n| Transition Handling | State consistency | Scene changes maintain resource consistency | No crashes during transitions |\n\n**Functional Validation Tests:**\n\n1. **Multi-Format Loading**: Load assets in different formats, verify content loads correctly and GPU resources are created properly.\n\n2. **Reference Counting Accuracy**: Load resources, create multiple handles, release handles, verify cleanup occurs when reference count reaches zero.\n\n3. **Async Loading Pipeline**: Request multiple assets asynchronously, verify they load in background and complete callbacks execute correctly.\n\n4. **Scene Serialization Round-Trip**: Create complex scene with entities and components, save to file, load into new scene, verify identical state.\n\n5. **Resource Handle Validation**: Test access to invalid handles, ensure graceful failure without crashes.\n\n**Performance Validation Tests:**\n\n1. **Loading Throughput**: Measure asset loading speed for various file sizes, optimize for typical game content volumes.\n\n2. **Memory Efficiency**: Monitor memory usage during loading, verify resources are shared appropriately and freed promptly.\n\n3. **Cache Hit Rates**: Test resource cache effectiveness, measure how often duplicate requests are satisfied from cache.\n\n**Concurrency Validation Tests:**\n\n1. **Thread Safety**: Load resources from multiple threads simultaneously, verify no data corruption or crashes occur.\n\n2. **Main Thread Integration**: Verify async loading completions are processed safely on main thread without blocking.\n\n**Integration Validation Tests:**\n\n1. **Cross-System Resource Usage**: Load textures used by rendering system, verify proper coordination between resource manager and renderer.\n\n2. **Scene Transition Stability**: Test transitions between different scenes, verify resources load/unload correctly and no references remain dangling.\n\n> **Critical Checkpoint**: After Milestone 4, you should be able to load complex scenes with hundreds of assets, transition between scenes without memory leaks, and handle loading errors gracefully.\n\n### Component Unit Testing\n\nUnit testing individual engine subsystems is like **testing car components on a test bench** before assembling the complete vehicle. Each component must demonstrate correct behavior in isolation before being integrated into the larger system. Game engine unit testing requires special techniques because many components interact closely with hardware, operate under performance constraints, or manage complex internal state.\n\nThe key insight for game engine unit testing is that **behavioral correctness** is often more important than exact implementation details. A physics system that conserves energy and prevents tunneling is correct regardless of the specific integration method used. This leads to testing strategies that verify observable outcomes rather than internal implementation steps.\n\n#### ECS Query System Testing\n\n**Mental Model: Database Query Validation**\n\nTesting ECS queries is like validating database queries — you create known data sets, run queries, and verify the result sets contain exactly the expected records. However, ECS queries must also meet performance requirements since they execute every frame.\n\nThe ECS query system requires comprehensive testing because subtle bugs can cause systems to process incorrect entity sets, leading to game logic errors that are difficult to trace back to the ECS layer:\n\n| Test Category | Test Objective | Validation Approach | Performance Requirement |\n|--------------|---------------|-------------------|------------------------|\n| Single Component Queries | Correct entity filtering | Create entities with/without components, verify query results | Sub-millisecond execution |\n| Multi-Component Queries | Intersection logic | Test AND, OR, NOT combinations of component requirements | O(n) scaling with entity count |\n| Component Modification | Iteration stability | Add/remove components during iteration, verify no corruption | No iterator invalidation |\n| Query Caching | Performance optimization | Repeated queries should use cached results when possible | 10x speedup for cached queries |\n| Memory Layout | Cache efficiency | Verify component iteration accesses memory sequentially | Minimal cache misses |\n\n**Core Test Scenarios:**\n\n1. **Entity Set Validation Tests**: Create a known population of entities with specific component combinations. Run queries for various component signatures and verify the returned entity sets exactly match expected results.\n\n2. **Component Addition/Removal Tests**: Start with entities lacking required components, add components, run queries, verify entities appear in results. Remove components and verify entities disappear from subsequent queries.\n\n3. **Performance Scaling Tests**: Create entity populations ranging from 100 to 100,000 entities, measure query execution time, verify it scales linearly or better.\n\n4. **Concurrent Modification Tests**: Run queries while other threads add/remove entities and components, verify results remain consistent and no crashes occur.\n\n5. **Memory Access Pattern Tests**: Use profiling tools to verify component iteration accesses memory in cache-friendly patterns with minimal random access.\n\n**Test Implementation Strategy:**\n\nThe testing approach uses **controlled entity populations** where the test setup creates entities with known component combinations, making it easy to predict correct query results:\n\n```\nTest Setup: \n- 100 entities with Transform component only\n- 50 entities with Transform + Sprite components  \n- 25 entities with Transform + Sprite + RigidBody components\n- 25 entities with Sprite component only\n\nQuery Test Cases:\n- Query<Transform>() should return 175 entities (100+50+25)\n- Query<Transform, Sprite>() should return 75 entities (50+25)  \n- Query<Transform, Sprite, RigidBody>() should return 25 entities\n- Query<Sprite>() should return 100 entities (50+25+25)\n```\n\n#### Collision Detection Testing\n\n**Mental Model: Geometric Proof Verification**\n\nCollision detection testing is like verifying geometric proofs — you create scenarios with known mathematical answers and verify the algorithm produces correct results. The challenge is covering edge cases that might not occur during typical gameplay but could cause crashes or incorrect physics behavior.\n\nCollision detection requires both **correctness testing** and **performance validation** because errors can cause objects to fall through floors or tunnel through barriers, while poor performance can cause frame rate drops:\n\n| Test Category | Test Objective | Validation Method | Accuracy Requirement |\n|--------------|---------------|------------------|-------------------|\n| Basic Intersection | Geometric accuracy | Test known overlapping/non-overlapping cases | Zero false positives/negatives |\n| Edge Cases | Boundary handling | Objects at exact boundaries, zero-size objects | Consistent behavior |\n| Performance | Scaling behavior | Time detection with increasing object counts | O(n log n) or better |\n| Spatial Partitioning | Optimization correctness | Verify spatial queries return same results as brute force | Identical result sets |\n| Numerical Precision | Floating-point stability | Test with very small/large coordinates | Stable results |\n\n**Core Test Scenarios:**\n\n1. **Known Geometry Tests**: Create AABB and circle pairs with manually calculated intersection results, verify collision detection matches analytical solutions.\n\n2. **Boundary Case Tests**: Test objects that exactly touch at edges, objects with zero dimensions, and objects at floating-point precision limits.\n\n3. **Spatial Partitioning Validation**: Compare spatial partitioning results against brute-force collision detection, verify identical collision pairs are detected.\n\n4. **Performance Regression Tests**: Benchmark collision detection time with fixed object distributions, alert when performance degrades significantly.\n\n5. **Numerical Stability Tests**: Run collision detection with very large or very small coordinates, verify results remain consistent and don't produce NaN values.\n\n#### Resource Loading Testing\n\n**Mental Model: File System Stress Testing**\n\nResource loading testing is like stress testing a file system — you need to verify it handles various file formats, sizes, corruption scenarios, and concurrent access patterns without losing data or crashing.\n\nResource loading testing must cover **file format variations**, **error conditions**, and **concurrency scenarios** because games load assets from diverse sources and must handle missing files, network interruptions, or corrupted data gracefully:\n\n| Test Category | Test Objective | Test Scenarios | Error Handling |\n|--------------|---------------|----------------|----------------|\n| Format Support | Multi-format loading | PNG, JPG, OBJ, WAV files with various parameters | Graceful degradation |\n| Error Conditions | Resilient loading | Missing files, corrupted data, insufficient memory | Clear error messages |\n| Concurrency | Thread safety | Multiple threads loading different/same resources | No race conditions |\n| Cache Behavior | Efficiency | Duplicate load requests should return cached results | Reference sharing |\n| Memory Management | Resource cleanup | Resources freed when no longer referenced | Zero leaks |\n\n**Core Test Scenarios:**\n\n1. **Multi-Format Validation**: Load assets in different formats with various compression settings, color depths, and resolutions. Verify loaded data matches expected content.\n\n2. **Error Condition Testing**: Test loading from non-existent files, corrupted files, and files with incorrect headers. Verify appropriate error codes are returned and no crashes occur.\n\n3. **Concurrent Loading Tests**: Start multiple loading operations from different threads targeting the same and different files. Verify thread safety and proper resource sharing.\n\n4. **Reference Counting Validation**: Create multiple handles to the same resource, release handles in various orders, verify cleanup occurs exactly when the last reference is released.\n\n5. **Memory Pressure Testing**: Load large numbers of resources until memory is exhausted, verify graceful handling and cleanup of partially loaded resources.\n\n### System Integration Testing\n\nIntegration testing for game engines is like **rehearsing a complete orchestra performance** — while individual musicians might play their parts perfectly, the complete performance requires precise timing, coordination, and handling of unexpected situations like missed cues or equipment failures.\n\nGame engine integration testing focuses on **frame processing pipelines**, **cross-system data flow**, and **performance under realistic loads**. The goal is to verify that all subsystems work together to deliver consistent interactive experiences without crashes, memory leaks, or performance degradation.\n\n#### Frame Processing Pipeline Testing\n\n**Mental Model: Manufacturing Assembly Line Validation**\n\nThe frame processing pipeline is like a manufacturing assembly line where each station (system) performs operations on products (entities) flowing through the line. Integration testing validates that the assembly line maintains throughput, quality, and timing under various load conditions.\n\nFrame processing integration testing must verify **system execution order**, **data consistency across frames**, and **performance stability** because errors in frame processing can cause visual glitches, input lag, or game logic inconsistencies:\n\n| Integration Aspect | Test Objective | Validation Criteria | Performance Target |\n|-------------------|---------------|-------------------|-------------------|\n| System Execution Order | Dependencies respected | Systems run in correct sequence without race conditions | Deterministic execution |\n| Data Flow Consistency | Information propagates | Changes in one system visible to dependent systems | One-frame propagation delay |\n| Frame Time Budget | Performance stability | Complete frame processing within 16.67ms target | 95% of frames meet deadline |\n| Memory Stability | Resource management | No memory growth or leaks during extended operation | Stable memory usage |\n| Error Propagation | Failure isolation | Errors in one system don't crash other systems | Graceful degradation |\n\n**Frame Processing Test Scenarios:**\n\n1. **Complete Game Loop Integration**: Run realistic game scenarios with moving entities, collisions, rendering, and user input. Verify all systems coordinate properly and maintain target frame rate.\n\n2. **System Dependency Validation**: Create scenarios where systems have clear dependencies (physics updates positions, rendering uses updated positions), verify execution order ensures consistency.\n\n3. **Performance Stress Testing**: Gradually increase entity counts, collision complexity, and rendering load until frame rate drops, identify bottlenecks and scaling limits.\n\n4. **Error Injection Testing**: Introduce controlled failures in individual systems (resource loading errors, physics instabilities, rendering failures), verify other systems continue operating.\n\n5. **Extended Operation Testing**: Run game engine continuously for hours or days, monitor memory usage, frame rate consistency, and resource cleanup.\n\n**Cross-System Data Flow Validation:**\n\nThe frame processing pipeline requires careful validation of how data flows between systems because **temporal coupling** can create subtle bugs where systems read stale data or miss important updates:\n\n```\nFrame N Processing Order:\n1. Input System: Updates input component states\n2. Game Logic Systems: Process gameplay rules using input\n3. Physics System: Updates positions/velocities  \n4. Collision System: Resolves collisions, modifies positions\n5. Animation System: Updates sprite frames based on time\n6. Rendering System: Draws entities using final positions\n\nValidation Points:\n- Physics system sees input changes from Frame N\n- Rendering system sees position changes from Frame N physics\n- No system uses data that's more than 1 frame old\n```\n\n#### Scene Transition Integration Testing\n\n**Mental Model: Theater Set Changes**\n\nScene transitions are like complex set changes during a theater performance — the old set must be struck, new sets must be assembled, lighting must be reconfigured, and actors must be repositioned, all while maintaining the illusion of continuity for the audience.\n\nScene transition testing validates **resource lifecycle management**, **state consistency**, and **transition timing** because errors during scene changes can cause crashes, memory leaks, or inconsistent game state:\n\n| Transition Aspect | Test Objective | Success Criteria | Reliability Target |\n|------------------|---------------|------------------|-------------------|\n| Resource Cleanup | No memory leaks | All old scene resources freed completely | Zero leaked resources |\n| Asset Loading | New content ready | All required assets loaded before scene activation | 100% loading success |\n| State Consistency | No data corruption | Entity-component relationships remain valid | Zero state corruption |\n| Transition Timing | Smooth experience | Scene changes complete within acceptable time | < 2 second transitions |\n| Error Recovery | Failure resilience | Failed transitions don't corrupt current scene | Graceful fallback |\n\n**Scene Transition Test Scenarios:**\n\n1. **Resource Lifecycle Validation**: Create scenes with shared and unique resources, perform transitions, verify shared resources remain loaded and unique resources are freed appropriately.\n\n2. **State Transfer Testing**: Test scenarios where some game state must persist across scene transitions (player inventory, global settings), verify data survives the transition correctly.\n\n3. **Loading Failure Recovery**: Simulate asset loading failures during scene transitions, verify the system can recover gracefully without corrupting the current scene.\n\n4. **Rapid Transition Testing**: Perform multiple scene transitions in quick succession, verify the system handles overlapping load/unload operations correctly.\n\n5. **Memory Pressure Testing**: Perform scene transitions while memory is nearly exhausted, verify graceful handling and cleanup prioritization.\n\n#### Performance Integration Testing\n\n**Mental Model: Orchestra Tempo Maintenance**\n\nPerformance integration testing is like validating that an orchestra maintains consistent tempo throughout a complex musical piece, even during challenging passages with many instruments playing intricate parts simultaneously.\n\nPerformance testing must validate **frame rate consistency**, **scalability limits**, and **resource usage patterns** under realistic game loads because performance problems often emerge only when multiple systems are operating simultaneously:\n\n| Performance Aspect | Test Objective | Measurement Method | Target Criteria |\n|-------------------|---------------|------------------|----------------|\n| Frame Rate Stability | Consistent timing | Frame time histograms over extended periods | 95% frames within 16.67ms |\n| CPU Usage Distribution | Work balance | Profiling system execution times | No single system dominates |\n| Memory Usage Patterns | Resource efficiency | Memory allocation/deallocation tracking | Minimal garbage collection |\n| GPU Resource Usage | Graphics efficiency | Draw call counts, texture memory usage | Optimal batching achieved |\n| Scalability Limits | Performance boundaries | Entity counts where performance degrades | Graceful degradation |\n\n**Performance Integration Test Scenarios:**\n\n1. **Realistic Game Simulation**: Create scenarios that mimic actual gameplay with typical entity counts, interaction patterns, and content complexity. Measure performance over extended periods.\n\n2. **Scalability Boundary Testing**: Gradually increase system load (entities, collisions, rendering complexity) until performance targets are no longer met. Identify specific bottlenecks and scaling limits.\n\n3. **Resource Contention Testing**: Create scenarios where multiple systems compete for shared resources (memory, CPU cache, GPU bandwidth), measure impact on individual system performance.\n\n4. **Background Loading Impact**: Run performance tests while background asset loading is active, verify main thread performance remains stable.\n\n5. **Memory Fragmentation Analysis**: Run extended performance tests while monitoring memory allocation patterns, identify potential fragmentation issues that could cause performance degradation over time.\n\n**Benchmark Suite Development:**\n\nA comprehensive benchmark suite provides **repeatable performance validation** across different hardware configurations and development stages:\n\n| Benchmark Category | Measurement Target | Validation Criteria | Hardware Coverage |\n|-------------------|------------------|-------------------|------------------|\n| Entity Processing | ECS system performance | Entities processed per millisecond | Low-end to high-end CPUs |\n| Rendering Throughput | Graphics performance | Sprites/polygons rendered per frame | Integrated to discrete GPUs |\n| Physics Simulation | Collision performance | Rigid bodies simulated per frame | Various CPU architectures |\n| Asset Loading | I/O performance | MB loaded per second | HDD, SSD, network storage |\n| Memory Efficiency | Resource usage | Peak and average memory consumption | Limited to abundant RAM |\n\nThe benchmark suite should run automatically during development to detect performance regressions and provide consistent metrics for optimization efforts.\n\n### Implementation Guidance\n\nThis testing strategy transforms from design concept into practical validation code that builds confidence in each engine subsystem. The implementation focuses on creating a comprehensive test suite that can run automatically and provide clear feedback about system correctness and performance.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option | Rationale |\n|-----------|--------------|-----------------|-----------|\n| Test Framework | Simple assertion macros with manual test registration | Google Test with parameterized tests and fixtures | Start simple, upgrade for complex test scenarios |\n| Performance Measurement | Basic timing with std::chrono | Profiling integration with Tracy or Optick | Manual timing sufficient initially, profiler needed for optimization |\n| Memory Testing | Manual leak detection with reference counting | Valgrind or Address Sanitizer integration | Platform-specific tools for comprehensive validation |\n| Graphics Testing | Manual visual verification | Automated screenshot comparison | Visual verification adequate for educational project |\n| Benchmark Automation | Manual execution and timing | Continuous integration with performance tracking | Manual acceptable for learning, CI valuable for production |\n\n#### Recommended File Structure\n\n```cpp\nproject-root/\n├── engine/\n│   ├── core/              ← Core engine systems\n│   ├── rendering/         ← Graphics pipeline \n│   ├── ecs/              ← Entity Component System\n│   ├── physics/          ← Physics and collision\n│   └── resources/        ← Asset and scene management\n├── tests/\n│   ├── unit/             ← Individual system tests\n│   │   ├── test_ecs.cpp\n│   │   ├── test_physics.cpp\n│   │   ├── test_rendering.cpp\n│   │   └── test_resources.cpp\n│   ├── integration/      ← Cross-system tests\n│   │   ├── test_frame_processing.cpp\n│   │   ├── test_scene_transitions.cpp\n│   │   └── test_performance.cpp\n│   ├── assets/          ← Test asset files\n│   │   ├── textures/\n│   │   ├── meshes/\n│   │   └── scenes/\n│   └── framework/       ← Testing utilities\n│       ├── test_framework.h\n│       ├── performance_timer.h\n│       └── mock_systems.h\n└── benchmarks/          ← Performance validation\n    ├── ecs_benchmark.cpp\n    ├── physics_benchmark.cpp\n    └── rendering_benchmark.cpp\n```\n\n#### Testing Framework Infrastructure\n\nComplete testing infrastructure that provides assertion macros, test registration, and performance measurement capabilities:\n\n```cpp\n// tests/framework/test_framework.h\n#pragma once\n#include <string>\n#include <vector>\n#include <functional>\n#include <chrono>\n#include <iostream>\n\nnamespace TestFramework {\n    \nstruct TestResult {\n    std::string testName;\n    bool passed;\n    std::string errorMessage;\n    double executionTimeMs;\n};\n\nclass TestRunner {\npublic:\n    static TestRunner& Instance() {\n        static TestRunner instance;\n        return instance;\n    }\n    \n    void RegisterTest(const std::string& name, std::function<void()> testFunc);\n    std::vector<TestResult> RunAllTests();\n    void RunTestsByPattern(const std::string& pattern);\n    \nprivate:\n    std::vector<std::pair<std::string, std::function<void()>>> m_tests;\n};\n\n// Simple assertion macros\n#define ASSERT_TRUE(condition) \\\n    if (!(condition)) { \\\n        throw std::runtime_error(\"Assertion failed: \" #condition \" at \" __FILE__ \":\" + std::to_string(__LINE__)); \\\n    }\n\n#define ASSERT_FALSE(condition) ASSERT_TRUE(!(condition))\n\n#define ASSERT_EQ(expected, actual) \\\n    if ((expected) != (actual)) { \\\n        throw std::runtime_error(\"Expected \" + std::to_string(expected) + \" but got \" + std::to_string(actual)); \\\n    }\n\n#define ASSERT_NEAR(expected, actual, tolerance) \\\n    if (std::abs((expected) - (actual)) > (tolerance)) { \\\n        throw std::runtime_error(\"Values not within tolerance\"); \\\n    }\n\n// Test registration macro\n#define TEST(testName) \\\n    void Test_##testName(); \\\n    struct TestRegistrar_##testName { \\\n        TestRegistrar_##testName() { \\\n            TestFramework::TestRunner::Instance().RegisterTest(#testName, Test_##testName); \\\n        } \\\n    }; \\\n    static TestRegistrar_##testName registrar_##testName; \\\n    void Test_##testName()\n\n// Performance testing utilities\nclass PerformanceTimer {\npublic:\n    void Start() { m_startTime = std::chrono::high_resolution_clock::now(); }\n    void Stop() { m_endTime = std::chrono::high_resolution_clock::now(); }\n    double GetMilliseconds() const {\n        auto duration = m_endTime - m_startTime;\n        return std::chrono::duration_cast<std::chrono::duration<double, std::milli>>(duration).count();\n    }\n    \nprivate:\n    std::chrono::high_resolution_clock::time_point m_startTime, m_endTime;\n};\n\n} // namespace TestFramework\n```\n\n#### ECS Unit Testing Implementation\n\nComplete test suite for ECS functionality with entity management, component storage, and system execution validation:\n\n```cpp\n// tests/unit/test_ecs.cpp\n#include \"test_framework.h\"\n#include \"engine/ecs/ecs_world.h\"\n#include \"engine/ecs/components.h\"\n#include <unordered_set>\n\nusing namespace TestFramework;\n\nTEST(EntityCreationAndDestruction) {\n    // TODO 1: Create ECSWorld instance\n    // TODO 2: Create multiple entities and verify they have unique IDs\n    // TODO 3: Destroy some entities and create new ones\n    // TODO 4: Verify ID recycling works correctly\n    // TODO 5: Ensure destroyed entity IDs are not reused immediately (generation counter)\n}\n\nTEST(ComponentAdditionAndRemoval) {\n    // TODO 1: Create entities and add various components\n    // TODO 2: Verify GetComponent returns correct component data\n    // TODO 3: Remove components and verify they're no longer accessible\n    // TODO 4: Test adding components to destroyed entities (should fail gracefully)\n    // TODO 5: Verify component memory is cleaned up properly\n}\n\nTEST(SystemExecutionAndQueries) {\n    // TODO 1: Create test system that processes Transform components\n    // TODO 2: Create entities with and without Transform components\n    // TODO 3: Run system and verify only entities with Transform are processed\n    // TODO 4: Test multi-component queries (Transform + Sprite)\n    // TODO 5: Verify system execution order respects dependencies\n}\n\nTEST(ComponentStoragePerformance) {\n    PerformanceTimer timer;\n    const int ENTITY_COUNT = 10000;\n    \n    // TODO 1: Create large number of entities with Transform components\n    // TODO 2: Time component iteration performance\n    // TODO 3: Verify iteration completes within performance budget (< 1ms)\n    // TODO 4: Test component addition/removal performance\n    // TODO 5: Measure memory usage and verify cache-friendly access patterns\n}\n\nTEST(ConcurrentEntityManagement) {\n    // TODO 1: Test adding/removing entities from multiple threads\n    // TODO 2: Verify no race conditions in ID generation\n    // TODO 3: Test component modification during system iteration\n    // TODO 4: Ensure data consistency under concurrent access\n    // TODO 5: Verify no crashes or data corruption occur\n}\n```\n\n#### Physics System Testing Implementation\n\nComprehensive physics testing that validates collision detection accuracy, energy conservation, and numerical stability:\n\n```cpp\n// tests/unit/test_physics.cpp\n#include \"test_framework.h\"\n#include \"engine/physics/collision_system.h\"\n#include \"engine/physics/physics_integrator.h\"\n#include \"engine/math/vector2.h\"\n\nusing namespace TestFramework;\n\nTEST(AABBCollisionDetection) {\n    // TODO 1: Create AABB pairs with known intersection results\n    // TODO 2: Test overlapping cases (partial and complete overlap)\n    // TODO 3: Test non-overlapping cases (separated by various distances)\n    // TODO 4: Test edge cases (exactly touching, zero-size boxes)\n    // TODO 5: Verify no false positives or false negatives\n}\n\nTEST(PhysicsEnergyConservation) {\n    // TODO 1: Create physics simulation with bouncing balls\n    // TODO 2: Calculate initial total kinetic energy\n    // TODO 3: Run simulation for many timesteps\n    // TODO 4: Verify energy remains approximately constant (< 1% drift)\n    // TODO 5: Test with different object masses and velocities\n}\n\nTEST(CollisionResponseAccuracy) {\n    // TODO 1: Set up collision between objects with known masses and velocities\n    // TODO 2: Calculate expected post-collision velocities using physics equations\n    // TODO 3: Run collision response system\n    // TODO 4: Verify actual velocities match expected within tolerance\n    // TODO 5: Test various collision scenarios (head-on, glancing, stationary targets)\n}\n\nTEST(SpatialPartitioningPerformance) {\n    PerformanceTimer timer;\n    const int OBJECT_COUNT = 1000;\n    \n    // TODO 1: Create large number of collision objects in grid pattern\n    // TODO 2: Time collision detection with and without spatial partitioning\n    // TODO 3: Verify spatial partitioning provides significant speedup\n    // TODO 4: Verify spatial partitioning returns identical results to brute force\n    // TODO 5: Test performance scaling as object count increases\n}\n\nTEST(PhysicsNumericalStability) {\n    // TODO 1: Run long physics simulation (10000+ timesteps)\n    // TODO 2: Monitor for NaN or infinite values in positions/velocities\n    // TODO 3: Test with very small and very large coordinate values\n    // TODO 4: Verify objects don't spontaneously gain energy\n    // TODO 5: Test collision jitter prevention mechanisms\n}\n```\n\n#### Integration Testing Implementation\n\nEnd-to-end testing that validates complete frame processing pipelines and system coordination:\n\n```cpp\n// tests/integration/test_frame_processing.cpp\n#include \"test_framework.h\"\n#include \"engine/core/application.h\"\n#include \"engine/core/timer.h\"\n\nusing namespace TestFramework;\n\nTEST(CompleteFrameProcessing) {\n    Application app;\n    WindowConfig config{\"Test Window\", 800, 600, false, false, true, 0};\n    \n    // TODO 1: Initialize application with test configuration\n    // TODO 2: Create test scene with entities having Transform, Sprite, RigidBody components\n    // TODO 3: Run multiple frame processing cycles\n    // TODO 4: Verify all systems execute in correct order\n    // TODO 5: Verify frame time remains within budget (16.67ms target)\n    // TODO 6: Check for memory leaks after extended operation\n}\n\nTEST(SystemCoordinationValidation) {\n    // TODO 1: Create entities that require coordination between multiple systems\n    // TODO 2: Physics system modifies positions, rendering system uses updated positions\n    // TODO 3: Verify data flows correctly between systems within same frame\n    // TODO 4: Test input processing affects game logic systems\n    // TODO 5: Ensure no system reads stale data from previous frames\n}\n\nTEST(SceneTransitionIntegration) {\n    // TODO 1: Create two different scenes with unique resource requirements\n    // TODO 2: Load first scene and verify all resources loaded correctly\n    // TODO 3: Transition to second scene\n    // TODO 4: Verify first scene resources cleaned up properly\n    // TODO 5: Verify second scene resources loaded and functional\n    // TODO 6: Test rapid scene transitions and error recovery\n}\n\nTEST(PerformanceStressTest) {\n    PerformanceTimer timer;\n    const int STRESS_ENTITY_COUNT = 5000;\n    \n    // TODO 1: Create large number of entities with full component sets\n    // TODO 2: Run frame processing under heavy load\n    // TODO 3: Measure frame processing time distribution\n    // TODO 4: Identify performance bottlenecks and scaling limits\n    // TODO 5: Verify graceful degradation when limits exceeded\n}\n```\n\n#### Milestone Verification Scripts\n\nAutomated validation scripts that provide clear pass/fail results for each milestone:\n\n```cpp\n// tests/milestone_verification.cpp\n#include \"test_framework.h\"\n#include \"engine/core/application.h\"\n\nnamespace MilestoneVerification {\n\nbool VerifyMilestone1() {\n    std::cout << \"=== Milestone 1: Window & Rendering Foundation ===\\n\";\n    \n    // TODO 1: Test window creation with various configurations\n    // TODO 2: Verify OpenGL context initialization\n    // TODO 3: Test basic sprite rendering functionality\n    // TODO 4: Verify shader compilation and linking\n    // TODO 5: Test batch rendering performance\n    // Return true if all tests pass\n    \n    return true; // Placeholder\n}\n\nbool VerifyMilestone2() {\n    std::cout << \"=== Milestone 2: Entity Component System ===\\n\";\n    \n    // TODO 1: Test entity creation and ID recycling\n    // TODO 2: Verify component storage and retrieval\n    // TODO 3: Test system execution and queries\n    // TODO 4: Verify performance meets targets\n    // TODO 5: Test concurrent access safety\n    \n    return true; // Placeholder\n}\n\nbool VerifyMilestone3() {\n    std::cout << \"=== Milestone 3: Physics & Collision ===\\n\";\n    \n    // TODO 1: Test collision detection accuracy\n    // TODO 2: Verify physics integration stability\n    // TODO 3: Test collision response realism\n    // TODO 4: Verify spatial partitioning performance\n    // TODO 5: Test deterministic behavior\n    \n    return true; // Placeholder\n}\n\nbool VerifyMilestone4() {\n    std::cout << \"=== Milestone 4: Resource & Scene Management ===\\n\";\n    \n    // TODO 1: Test asset loading for various formats\n    // TODO 2: Verify reference counting accuracy\n    // TODO 3: Test scene serialization round-trips\n    // TODO 4: Verify async loading thread safety\n    // TODO 5: Test error handling and recovery\n    \n    return true; // Placeholder\n}\n\n} // namespace MilestoneVerification\n\nint main() {\n    bool allMilestonesPassed = true;\n    \n    allMilestonesPassed &= MilestoneVerification::VerifyMilestone1();\n    allMilestonesPassed &= MilestoneVerification::VerifyMilestone2();\n    allMilestonesPassed &= MilestoneVerification::VerifyMilestone3();\n    allMilestonesPassed &= MilestoneVerification::VerifyMilestone4();\n    \n    if (allMilestonesPassed) {\n        std::cout << \"\\n✅ All milestones verified successfully!\\n\";\n        return 0;\n    } else {\n        std::cout << \"\\n❌ Some milestones failed verification.\\n\";\n        return 1;\n    }\n}\n```\n\n#### Language-Specific Testing Hints\n\n**C++ Testing Best Practices:**\n- Use RAII for test fixture setup/teardown to ensure resource cleanup\n- Leverage `std::chrono::high_resolution_clock` for accurate performance measurement  \n- Use `std::unique_ptr` and smart pointers to detect memory leaks automatically\n- Enable compiler warnings (`-Wall -Wextra`) to catch potential issues early\n- Use address sanitizer (`-fsanitize=address`) during development for memory error detection\n\n**Performance Measurement Guidelines:**\n- Run performance tests multiple times and report average/median/95th percentile\n- Warm up caches before timing critical sections\n- Use CPU performance counters when available for detailed analysis\n- Disable optimization during correctness testing, enable for performance testing\n- Measure both CPU time and wall clock time to detect threading issues\n\n**Graphics Testing Considerations:**\n- Initialize graphics context before running rendering tests\n- Use offscreen framebuffers for automated graphics testing\n- Verify OpenGL error state after each graphics operation\n- Test with different GPU vendors and driver versions when possible\n- Use simple geometric shapes for deterministic visual verification\n\n#### Debugging Integration Test Failures\n\n| Failure Symptom | Likely Root Cause | Diagnostic Approach | Resolution Strategy |\n|----------------|------------------|-------------------|-------------------|\n| Frame rate drops during testing | Performance bottleneck in system coordination | Profile individual system execution times | Optimize slowest system or reduce test load |\n| Memory usage grows during tests | Resource leaks in asset loading or ECS | Track allocation/deallocation patterns | Add reference counting validation |\n| Crashes during scene transitions | Race condition or invalid resource handles | Use thread sanitizer and handle validation | Add synchronization and handle checking |\n| Physics simulation becomes unstable | Numerical precision issues or timestep problems | Monitor energy conservation and NaN detection | Adjust integration method or timestep |\n| Rendering artifacts in integration tests | State leakage between graphics operations | Check OpenGL error state and context validity | Add state cleanup between render operations |\n\nThis comprehensive testing strategy ensures each engine subsystem works correctly in isolation and coordinates properly with other systems to deliver smooth interactive experiences. The combination of unit testing, integration testing, and milestone verification provides confidence that the game engine meets both functional and performance requirements.\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones (1-4) — debugging techniques are essential throughout development as each subsystem introduces unique failure modes and diagnostic challenges\n\nBuilding a game engine is like performing **surgery on a moving patient** — the system must continue running at 60 frames per second while you diagnose and fix problems. Unlike traditional software where you can pause execution and examine state, game engines operate under real-time constraints where debugging itself can disrupt the very timing issues you're trying to solve.\n\nThe debugging process for game engines requires a fundamentally different mindset than typical application development. You're debugging not just logic errors, but performance issues, timing-dependent race conditions, GPU state corruption, and numerical stability problems in physics simulations. Each subsystem introduces its own category of failures: graphics drivers can crash, physics simulations can explode, resources can fail to load, and the ECS can become corrupted. The challenge is developing systematic approaches to isolate problems across multiple interacting systems.\n\nThis guide provides structured approaches to the most common categories of issues learners encounter when building game engines. Rather than generic debugging advice, we focus on engine-specific problems with concrete diagnostic steps and solutions.\n\n### Graphics and Rendering Issues\n\nThe rendering subsystem presents the most visually obvious failures — when graphics break, you immediately see black screens, corrupted textures, or missing geometry. However, graphics problems are also among the most difficult to debug because they involve complex interactions between CPU code, GPU drivers, and graphics hardware.\n\n#### Mental Model: Film Production Pipeline\n\nThink of graphics debugging like troubleshooting a **film production pipeline** where problems can occur at multiple stages: script writing (shader code), equipment setup (OpenGL state), filming (draw calls), and post-production (framebuffer operations). Just as a film director must isolate whether problems are in the script, camera, lighting, or editing room, graphics debugging requires systematically checking each stage of the rendering pipeline.\n\n#### Black Screen Issues\n\nThe dreaded black screen is often a new developer's first encounter with graphics debugging. Black screens typically indicate complete rendering pipeline failure rather than partial corruption.\n\n| Symptom | Likely Cause | Diagnostic Steps | Solution |\n|---------|--------------|------------------|----------|\n| Window opens but shows black | OpenGL context not created | Check `Window::Initialize()` return value | Verify graphics drivers, try different OpenGL version |\n| Context exists but black screen | Viewport not set correctly | Call `glGetIntegerv(GL_VIEWPORT)` | Set viewport to window dimensions in resize callback |\n| Viewport correct but no rendering | Shader compilation failure | Check `ShaderProgram::m_isLinked` flag | Add shader error logging, check GLSL syntax |\n| Shaders link but geometry missing | Vertex attributes not bound | Call `glGetAttribLocation()` for each attribute | Verify vertex format matches shader inputs |\n| Attributes bound but still black | Matrices not set or incorrect | Print view-projection matrix values | Check matrix multiplication order and coordinate system |\n\n⚠️ **Pitfall: Assuming Silent Failures**\nOpenGL operates on a state machine principle where errors are queued rather than throwing exceptions immediately. A common mistake is not checking for OpenGL errors after each significant operation. The engine should use `GLErrorChecker::CheckErrors()` after every OpenGL call during development, even though this impacts performance.\n\n#### Texture Loading and Display Problems\n\nTexture problems manifest as pink/magenta rectangles (indicating missing textures), corrupted imagery, or textures that appear but with wrong colors or orientations.\n\n| Problem Type | Visual Symptom | Root Cause | Diagnostic Approach |\n|--------------|----------------|------------|-------------------|\n| Missing textures | Pink/magenta rectangles | Texture ID is 0 or invalid | Check `TextureHandle::IsValid()` before binding |\n| Corrupted colors | Wrong colors, banding | Incorrect pixel format during upload | Verify `GL_RGB` vs `GL_RGBA` matches image data |\n| Flipped textures | Upside-down or mirrored | Y-coordinate origin mismatch | Adjust texture coordinates or flip during loading |\n| Blurry textures | Loss of detail, soft appearance | Incorrect filtering parameters | Set `GL_NEAREST` for pixel art, check mipmap generation |\n| Black textures | Loaded but appear black | Premultiplied alpha or wrong format | Check alpha channel, try `GL_RGBA8` format explicitly |\n\nThe texture loading pipeline involves multiple stages where failures can occur:\n\n1. **File Loading**: The image decoder reads the file from disk and extracts pixel data\n2. **Format Conversion**: Pixel data is converted to OpenGL-compatible format (RGB/RGBA)\n3. **GPU Upload**: Converted data is transferred to graphics memory via `glTexImage2D`\n4. **Binding and Sampling**: Texture is bound to a texture unit and sampled in shaders\n\n> **Design Insight**: Texture debugging requires validating each stage independently. Create a simple test texture (like a 2x2 checkerboard pattern) programmatically to isolate whether problems are in file loading or GPU operations.\n\n#### Shader Compilation and Linking Errors\n\nShader errors are particularly challenging because GLSL error messages vary significantly between graphics drivers and often provide cryptic line numbers or syntax descriptions.\n\n**Shader Error Categories:**\n\n| Error Type | Common Messages | Typical Causes | Resolution Strategy |\n|------------|-----------------|----------------|-------------------|\n| Compilation | \"syntax error\", \"undeclared identifier\" | GLSL syntax errors, typos | Parse error logs, check GLSL version compatibility |\n| Linking | \"undefined reference\", \"type mismatch\" | Vertex/fragment interface mismatch | Verify `out` variables match `in` variables exactly |\n| Uniform | \"uniform location not found\" | Wrong uniform names or unused uniforms | Check spelling, verify uniform isn't optimized out |\n| Attribute | \"attribute location invalid\" | Vertex format doesn't match shader | Print attribute locations, compare with vertex layout |\n\nThe shader system should implement comprehensive error reporting:\n\n```cpp\nbool ShaderCompiler::CompileShader(uint32_t shaderID, const string& source, GLenum shaderType, string& errorLog) {\n    // TODO 1: Compile shader and check GL_COMPILE_STATUS\n    // TODO 2: If compilation failed, retrieve info log with glGetShaderInfoLog\n    // TODO 3: Parse error log to extract line numbers and error descriptions\n    // TODO 4: Append original source with line numbers for context\n    // TODO 5: Return false with detailed error message in errorLog parameter\n}\n```\n\n⚠️ **Pitfall: Silent Uniform Failures**\nOpenGL silently ignores `glUniform` calls for uniforms that don't exist or were optimized out during linking. The shader system should validate uniform locations during development and warn about unused uniforms that might indicate typos.\n\n#### OpenGL State Management Issues\n\nOpenGL's state machine nature creates debugging challenges when previous rendering operations leave the graphics context in unexpected states.\n\n**Common State Corruption Issues:**\n\n| State Category | Symptoms | Detection Method | Prevention Strategy |\n|----------------|----------|------------------|-------------------|\n| Texture binding | Wrong textures on wrong objects | Check `GL_TEXTURE_BINDING_2D` | Bind texture 0 after rendering |\n| Shader program | Wrong shader effects | Query `GL_CURRENT_PROGRAM` | Use RAII shader binding guards |\n| Vertex arrays | Wrong geometry rendered | Check `GL_VERTEX_ARRAY_BINDING` | Unbind VAO after batch completion |\n| Blend state | Transparency artifacts | Query blend function parameters | Reset blend state between frames |\n| Depth testing | Z-fighting or missing occlusion | Check `GL_DEPTH_TEST` enable state | Clear depth buffer each frame |\n\nThe `GLErrorChecker` utility should provide detailed state introspection during debugging sessions:\n\n```cpp\nclass GLErrorChecker {\n    static unordered_map<GLenum, string> s_errorStrings;\n    static bool s_enableChecking;\n    \npublic:\n    static bool CheckErrors(const char* operation, const char* file, int line);\n    static void DumpCurrentState();  // Prints all relevant GL state\n    static void EnableChecking(bool enable) { s_enableChecking = enable; }\n};\n\n#ifdef DEBUG\n#define GL_CHECK(call) do { call; GLErrorChecker::CheckErrors(#call, __FILE__, __LINE__); } while(0)\n#else\n#define GL_CHECK(call) call\n#endif\n```\n\n### Performance and Memory Issues\n\nPerformance problems in game engines are insidious because they often develop gradually as content is added, making them difficult to notice until frame rates drop below acceptable thresholds. Unlike functional bugs that cause immediate failures, performance issues require systematic measurement and profiling.\n\n#### Mental Model: Traffic Management System\n\nThink of performance debugging like managing **traffic flow in a city** — bottlenecks can occur at intersections (system boundaries), traffic lights (synchronization points), or road capacity limits (memory bandwidth). Just as traffic engineers use sensors and cameras to identify problem areas, performance debugging requires continuous monitoring of frame times, memory allocation patterns, and system resource usage.\n\n#### Frame Rate Drops and Timing Issues\n\nFrame rate instability manifests as stuttering, irregular motion, or complete freezes. These problems often stem from systems exceeding their frame time budget or creating timing dependencies between subsystems.\n\n| Performance Issue | Observable Symptoms | Measurement Approach | Typical Solutions |\n|-------------------|-------------------|-------------------|------------------|\n| Inconsistent frame times | Stuttering movement, frame drops | Track delta time variance over 1000 frames | Implement fixed timestep with accumulator |\n| CPU-bound rendering | High CPU usage, low GPU utilization | Profile rendering thread with sampling profiler | Reduce draw calls through batching |\n| GPU-bound rendering | Low CPU usage, high GPU load | Use GPU profiler to identify bottlenecks | Optimize shaders, reduce overdraw |\n| Memory allocation spikes | Frame drops during loading | Track allocation patterns with heap profiler | Pre-allocate pools, avoid per-frame allocation |\n| System blocking operations | Periodic freezes | Monitor system call duration | Move file I/O to background threads |\n\n**Frame Time Budget Analysis:**\n\nThe engine operates under strict timing constraints where each frame must complete within approximately 16.67 milliseconds for 60 FPS target frame rate. Understanding how this budget is distributed across subsystems helps identify optimization priorities:\n\n| Subsystem | Typical Budget | Measurement Method | Optimization Focus |\n|-----------|---------------|-------------------|-------------------|\n| Input Processing | 0.5ms | Time `PollEvents()` duration | Batch input events, avoid per-event allocation |\n| ECS System Updates | 4-6ms | Profile each system individually | Cache-friendly iteration, reduce component copying |\n| Physics Simulation | 2-4ms | Time `StepSimulation()` calls | Spatial partitioning efficiency, collision pair reduction |\n| Rendering Pipeline | 8-10ms | GPU profiler timestamps | Draw call batching, shader optimization |\n| Resource Loading | 0ms (background) | Monitor async queue depth | Prevent blocking main thread |\n\n⚠️ **Pitfall: Ignoring Variance**\nAverage frame time can be misleading — a system that averages 14ms but occasionally spikes to 30ms will cause noticeable stuttering. Performance monitoring should track both average and 99th percentile frame times to identify systems causing occasional but severe performance drops.\n\n#### Memory Leaks and Resource Management\n\nGame engines are particularly susceptible to memory leaks because they manage large amounts of temporary data (vertex buffers, textures, audio clips) that must be explicitly freed. Unlike application software, games cannot rely on garbage collection or process termination to clean up resources.\n\n**Memory Leak Categories:**\n\n| Leak Type | Growth Pattern | Detection Method | Prevention Strategy |\n|-----------|---------------|------------------|-------------------|\n| Resource handles | Steady growth during gameplay | Monitor `ResourceManager` handle counts | Implement reference counting with automatic cleanup |\n| Texture memory | Spikes during level loading | Track GPU memory usage | Unload unused textures during scene transitions |\n| Physics objects | Growth correlates with entity creation | Count rigid bodies vs. entities | Ensure `DestroyEntity()` removes physics components |\n| ECS components | Slow growth over time | Monitor component array sizes | Verify component removal recycles storage slots |\n| Temporary allocations | Sawtooth pattern each frame | Heap profiler allocation tracking | Use memory pools for frequent small allocations |\n\nThe engine should implement comprehensive memory tracking to detect leaks early in development:\n\n```cpp\nclass MemoryTracker {\n    struct AllocationInfo {\n        size_t size;\n        string file;\n        int line;\n        steady_clock::time_point timestamp;\n    };\n    \n    static unordered_map<void*, AllocationInfo> s_allocations;\n    static atomic<size_t> s_totalAllocated;\n    \npublic:\n    static void RecordAllocation(void* ptr, size_t size, const char* file, int line);\n    static void RecordDeallocation(void* ptr);\n    static void DumpLeaks();  // Print all unfreed allocations\n    static size_t GetTotalAllocated() { return s_totalAllocated.load(); }\n};\n```\n\n#### Inefficient ECS Iteration Patterns\n\nThe Entity Component System's performance benefits depend on cache-friendly iteration patterns. Poor ECS usage can actually be slower than traditional object-oriented approaches due to cache misses and unnecessary data movement.\n\n**ECS Performance Anti-Patterns:**\n\n| Anti-Pattern | Performance Impact | Diagnostic Signs | Corrective Action |\n|--------------|-------------------|------------------|-------------------|\n| Random entity access | Cache misses, poor branch prediction | High L3 cache miss rate | Use archetype-based iteration instead |\n| Excessive component copying | Memory bandwidth waste | High memory usage during system updates | Pass components by reference |\n| Mixed data types in hot loops | Cache line pollution | Poor instruction per cycle metrics | Separate hot/cold component data |\n| Sparse component arrays | Memory fragmentation | Low memory utilization efficiency | Implement dense packing with index mapping |\n| Cross-system data dependencies | Pipeline stalls | Systems waiting for data | Restructure component ownership |\n\nThe ECS implementation should provide profiling hooks to identify performance bottlenecks:\n\n```cpp\ntemplate<typename... Components>\nclass SystemProfiler {\n    steady_clock::time_point m_startTime;\n    size_t m_entitiesProcessed;\n    string m_systemName;\n    \npublic:\n    SystemProfiler(const string& name) : m_systemName(name), m_startTime(steady_clock::now()) {}\n    \n    ~SystemProfiler() {\n        auto duration = steady_clock::now() - m_startTime;\n        auto microseconds = duration_cast<std::chrono::microseconds>(duration).count();\n        \n        // TODO 1: Log system execution time and entity count\n        // TODO 2: Calculate entities processed per microsecond\n        // TODO 3: Track worst-case execution times over multiple frames\n        // TODO 4: Detect systems exceeding frame time budget\n    }\n};\n\n#define PROFILE_SYSTEM(name) SystemProfiler profiler(name)\n```\n\n### Physics Simulation Problems\n\nPhysics simulation debugging requires understanding both the mathematical foundations of rigid body dynamics and the numerical methods used to approximate continuous physics in discrete timesteps. Physics bugs often manifest as seemingly impossible behavior — objects falling through solid floors, explosive energy accumulation, or deterministic simulations producing different results on identical inputs.\n\n#### Mental Model: Forensic Investigation\n\nPhysics debugging is like **forensic investigation** — you must reconstruct what happened during collision events using evidence from before and after the collision. Since physics operates on predictions (where will this object be next frame?), debugging requires validating both the prediction logic and the correction mechanisms when predictions prove wrong.\n\n#### Objects Falling Through Floors (Tunneling)\n\nTunneling occurs when fast-moving objects pass completely through thin barriers between physics timesteps. This is one of the most common and frustrating physics bugs because it appears to violate basic physical laws.\n\n**Tunneling Root Causes:**\n\n| Cause | Physics Explanation | Detection Method | Solution Approach |\n|-------|-------------------|------------------|-------------------|\n| Excessive velocity | Object moves farther than barrier thickness per timestep | Compare velocity * timestep to collider size | Clamp maximum velocity or reduce timestep |\n| Large timestep | Too much time passes between collision checks | Monitor physics timestep accumulation | Use fixed timestep with smaller intervals |\n| Thin collision geometry | Barriers too thin relative to object speed | Measure barrier thickness vs. object bounds | Increase barrier thickness or use swept collision |\n| Missed collision detection | Spatial partitioning fails to find collision pairs | Verify broad phase detects all potential pairs | Expand spatial partition cells or use continuous detection |\n| Numerical precision loss | Floating-point errors in position calculations | Check for NaN or infinite position values | Use double precision for critical calculations |\n\nThe `TunnellingPreventer` utility helps detect potential tunneling before it occurs:\n\n```cpp\nclass TunnellingPreventer {\npublic:\n    static bool CheckForTunnelling(const RigidBody& body, const Transform& oldTransform, \n                                   const Transform& newTransform, float deltaTime) {\n        // TODO 1: Calculate movement distance between old and new positions\n        // TODO 2: Get the smallest dimension of the object's collision bounds\n        // TODO 3: If movement distance > bounds dimension, potential tunneling detected\n        // TODO 4: Log warning with object ID, velocity, and suggested max safe velocity\n        // TODO 5: Return true if tunneling risk detected, false otherwise\n    }\n    \n    static float CalculateMaxSafeVelocity(const AABB& bounds, float timestep) {\n        // TODO 1: Find the smallest dimension of the bounding box\n        // TODO 2: Calculate maximum safe distance per timestep (e.g., 0.5 * min dimension)\n        // TODO 3: Return safe distance divided by timestep to get max velocity\n    }\n};\n```\n\n#### Jittery Collisions and Resting Contact\n\nCollision jitter occurs when objects in resting contact (like a box sitting on the ground) rapidly oscillate between slightly penetrating and slightly separated states. This creates visually distracting vibration and can accumulate energy over time.\n\n**Jitter Analysis Framework:**\n\n| Jitter Type | Visual Appearance | Physical Cause | Stabilization Method |\n|-------------|------------------|----------------|-------------------|\n| Penetration jitter | Rapid up-down oscillation | Position correction overshoots | Reduce `POSITION_CORRECTION_PERCENT` |\n| Velocity jitter | Object appears to vibrate | Impulse response too aggressive | Apply velocity damping in resting contact |\n| Stacking jitter | Tower of objects vibrates | Accumulated correction errors | Process collisions in stability order |\n| Rotational jitter | Objects spin rapidly | Torque from off-center collisions | Separate linear and angular damping |\n| Temporal jitter | Inconsistent behavior over time | Variable timestep effects | Enforce fixed timestep accumulator |\n\n> **Design Insight**: Jitter reduction involves balancing responsiveness against stability. Too much damping makes collisions feel sluggish, while too little creates visible oscillation. The physics system should provide tunable parameters for different object types (e.g., heavy objects need less damping than light objects).\n\n#### Non-Deterministic Physics Behavior\n\nDeterministic physics simulation means identical initial conditions always produce identical results, which is critical for networked games and debugging reproducibility. Non-determinism usually stems from floating-point precision variations or execution order dependencies.\n\n**Determinism Validation System:**\n\n```cpp\nclass PhysicsMonitor {\n    struct SimulationMetrics {\n        float totalEnergy;\n        float maxVelocity;\n        float maxPosition;\n        uint32_t nanDetectedCount;\n    };\n    \n    SimulationMetrics m_currentMetrics;\n    SimulationMetrics m_baselineMetrics;\n    vector<float> m_energyHistory;\n    \npublic:\n    void RecordSimulationState(const vector<RigidBody>& bodies) {\n        // TODO 1: Calculate total kinetic and potential energy of all bodies\n        // TODO 2: Find maximum velocity and position magnitudes\n        // TODO 3: Count any NaN or infinite values in physics data\n        // TODO 4: Store metrics for comparison with baseline or previous frames\n        // TODO 5: Detect energy conservation violations or explosive growth\n    }\n    \n    bool ValidateSimulationState(const vector<RigidBody>& bodies) {\n        // TODO 1: Check all positions and velocities for NaN or infinity\n        // TODO 2: Verify energy conservation within acceptable tolerance\n        // TODO 3: Detect objects with impossible velocities (faster than light)\n        // TODO 4: Validate that all collision normals are unit vectors\n        // TODO 5: Return false if any validation checks fail\n    }\n};\n```\n\n**Determinism Threat Analysis:**\n\n| Threat Source | Manifestation | Detection Strategy | Mitigation Approach |\n|---------------|---------------|-------------------|-------------------|\n| Floating-point variance | Slightly different collision outcomes | Compare simulation checksums | Use consistent rounding modes |\n| Execution order | Different results based on iteration order | Run same simulation multiple times | Sort entities by ID before processing |\n| Temporal precision | Accumulating timestep errors | Track simulation drift over time | Use rational timestep representation |\n| Parallel processing | Race conditions in collision resolution | Single-thread determinism test | Eliminate shared state or use deterministic ordering |\n| Memory layout | Different results on different platforms | Cross-platform validation tests | Use fixed-size types and explicit padding |\n\n### Debugging Tools and Techniques\n\nEffective game engine debugging requires specialized tools and techniques adapted to real-time constraints and multi-system complexity. Traditional debuggers often disrupt timing-sensitive code, so game engines need non-invasive monitoring and logging systems.\n\n#### Mental Model: Air Traffic Control System\n\nThink of debugging tools like **air traffic control systems** — they provide continuous monitoring of multiple moving objects (entities), track their trajectories (transforms), identify conflicts (collisions), and maintain communication logs (event traces) without disrupting the ongoing operation of the system.\n\n#### Graphics Debugging and Profiling Tools\n\nGraphics debugging requires tools that can capture and analyze GPU state without significantly impacting performance during capture.\n\n**Recommended Graphics Debugging Tools:**\n\n| Tool Category | Recommended Tools | Use Cases | Integration Approach |\n|---------------|------------------|-----------|-------------------|\n| OpenGL Debuggers | RenderDoc, Nsight Graphics | Capture frame state, analyze draw calls | Hook into `SwapBuffers()` for automated capture |\n| GPU Profilers | AMD Radeon GPU Profiler, Intel GPA | Measure GPU timing, identify bottlenecks | Insert timestamp queries around rendering phases |\n| Shader Debuggers | GLSL-Debugger, Visual Studio Graphics | Step through shader execution | Add debug variants of critical shaders |\n| Memory Trackers | GPU PerfStudio, custom allocation hooks | Track GPU memory usage | Override texture/buffer allocation functions |\n| State Validators | Custom OpenGL state checker | Detect state leaks between frames | Query and validate state at frame boundaries |\n\nThe engine should provide built-in graphics debugging infrastructure:\n\n```cpp\nclass GraphicsDebugger {\n    static bool s_captureNextFrame;\n    static vector<DrawCallInfo> s_drawCallHistory;\n    \n    struct DrawCallInfo {\n        steady_clock::time_point timestamp;\n        string shaderName;\n        uint32_t vertexCount;\n        uint32_t textureCount;\n        Matrix4 modelViewProjection;\n    };\n    \npublic:\n    static void BeginFrame() {\n        if (s_captureNextFrame) {\n            s_drawCallHistory.clear();\n            // TODO 1: Insert GPU timestamp query for frame start\n            // TODO 2: Capture current OpenGL state snapshot\n        }\n    }\n    \n    static void RecordDrawCall(const string& shaderName, uint32_t vertices, const Matrix4& mvp) {\n        // TODO 1: Record timestamp and call parameters\n        // TODO 2: Capture bound textures and their dimensions\n        // TODO 3: Store current vertex array configuration\n        // TODO 4: Calculate estimated GPU cost for this draw call\n    }\n    \n    static void EndFrame() {\n        if (s_captureNextFrame) {\n            // TODO 1: Insert GPU timestamp query for frame end\n            // TODO 2: Generate frame analysis report\n            // TODO 3: Export data in RenderDoc-compatible format\n            // TODO 4: Reset capture flag\n            s_captureNextFrame = false;\n        }\n    }\n};\n```\n\n#### Performance Profiling and Bottleneck Analysis\n\nGame engine profiling must operate with minimal overhead while providing detailed timing information across multiple subsystems running concurrently.\n\n**Multi-Level Profiling Strategy:**\n\n| Profiling Level | Granularity | Overhead | Information Provided |\n|-----------------|-------------|----------|-------------------|\n| Frame-level | Per-frame timing | <0.1ms | Overall frame budget distribution |\n| System-level | Per-system execution | <0.5ms | ECS system performance comparison |\n| Function-level | Individual function calls | 1-2ms | Hotspot identification within systems |\n| Micro-level | Critical inner loops | 5-10ms | Cache performance and instruction analysis |\n\n```cpp\nclass PerformanceProfiler {\n    struct ProfileNode {\n        string name;\n        steady_clock::time_point startTime;\n        steady_clock::time_point endTime;\n        vector<ProfileNode> children;\n        uint64_t callCount;\n    };\n    \n    static thread_local stack<ProfileNode*> s_nodeStack;\n    static ProfileNode s_rootNode;\n    \npublic:\n    class ScopedTimer {\n        ProfileNode* m_node;\n    public:\n        ScopedTimer(const string& name) {\n            // TODO 1: Create new ProfileNode with current timestamp\n            // TODO 2: Add to parent node's children (or root if stack empty)\n            // TODO 3: Push onto node stack for nested timing\n        }\n        \n        ~ScopedTimer() {\n            // TODO 1: Record end timestamp\n            // TODO 2: Increment call count\n            // TODO 3: Pop from node stack\n            // TODO 4: Calculate exclusive time (total minus children)\n        }\n    };\n    \n    static void GenerateReport() {\n        // TODO 1: Walk profile tree and calculate percentages\n        // TODO 2: Identify functions exceeding frame time budget\n        // TODO 3: Sort by exclusive time to find real bottlenecks\n        // TODO 4: Export to external profiler format (Chrome tracing)\n    }\n};\n\n#define PROFILE_SCOPE(name) PerformanceProfiler::ScopedTimer timer(name)\n```\n\n#### Logging and Event Tracing Systems\n\nGame engines generate massive amounts of diagnostic information that must be filtered, formatted, and stored efficiently without impacting frame rate performance.\n\n**Hierarchical Logging Architecture:**\n\n| Log Level | Use Cases | Performance Impact | Storage Strategy |\n|-----------|-----------|-------------------|------------------|\n| TRACE | Detailed execution flow | High (debug only) | Memory buffer, periodic flush |\n| DEBUG | System state changes | Medium | Async file writing |\n| INFO | Major events, milestones | Low | Immediate console output |\n| WARNING | Recoverable errors | Minimal | Immediate file and console |\n| ERROR | System failures | Minimal | Immediate all outputs |\n\n```cpp\nclass EngineLogger {\n    enum LogLevel { TRACE = 0, DEBUG = 1, INFO = 2, WARNING = 3, ERROR = 4 };\n    \n    struct LogEntry {\n        steady_clock::time_point timestamp;\n        LogLevel level;\n        string category;\n        string message;\n        string file;\n        int line;\n    };\n    \n    static ThreadSafeQueue<LogEntry> s_logQueue;\n    static thread s_writerThread;\n    static atomic<LogLevel> s_filterLevel;\n    \npublic:\n    static void Log(LogLevel level, const string& category, const string& message, \n                   const char* file, int line) {\n        if (level < s_filterLevel.load()) return;\n        \n        // TODO 1: Create LogEntry with current timestamp and parameters\n        // TODO 2: Push to thread-safe queue for background processing\n        // TODO 3: If ERROR level, also output immediately to stderr\n        // TODO 4: Trigger flush if queue becomes too full\n    }\n    \nprivate:\n    static void WriterThreadMain() {\n        // TODO 1: Wait for log entries in queue\n        // TODO 2: Batch multiple entries for efficient I/O\n        // TODO 3: Format entries with timestamp, level, category\n        // TODO 4: Write to appropriate outputs (console, file, network)\n    }\n};\n\n#define LOG_TRACE(category, ...) EngineLogger::Log(EngineLogger::TRACE, category, fmt::format(__VA_ARGS__), __FILE__, __LINE__)\n#define LOG_DEBUG(category, ...) EngineLogger::Log(EngineLogger::DEBUG, category, fmt::format(__VA_ARGS__), __FILE__, __LINE__)\n#define LOG_INFO(category, ...)  EngineLogger::Log(EngineLogger::INFO, category, fmt::format(__VA_ARGS__), __FILE__, __LINE__)\n#define LOG_WARN(category, ...)  EngineLogger::Log(EngineLogger::WARNING, category, fmt::format(__VA_ARGS__), __FILE__, __LINE__)\n#define LOG_ERROR(category, ...) EngineLogger::Log(EngineLogger::ERROR, category, fmt::format(__VA_ARGS__), __FILE__, __LINE__)\n```\n\n#### Memory Analysis and Leak Detection\n\nMemory debugging in game engines requires tracking both CPU heap allocations and GPU resource allocations across multiple subsystems with different lifecycle patterns.\n\n**Comprehensive Memory Tracking System:**\n\n| Memory Category | Tracking Method | Leak Indicators | Analysis Tools |\n|-----------------|----------------|-----------------|---------------|\n| CPU Heap | Override global new/delete | Growing heap size over time | Allocation call stacks |\n| GPU Textures | Hook `glGenTextures`/`glDeleteTextures` | Texture count increases | Texture usage patterns |\n| GPU Buffers | Monitor VBO/VAO creation/destruction | Buffer memory growth | Buffer size distribution |\n| ECS Components | Track component array growth | Array size vs. entity count | Component lifecycle analysis |\n| Resource Handles | Monitor handle creation/reference counts | Handles with zero references | Resource dependency graphs |\n\n```cpp\nclass MemoryAnalyzer {\n    struct AllocationSite {\n        string function;\n        string file;\n        int line;\n        size_t totalAllocated;\n        size_t allocationCount;\n        vector<size_t> allocationSizes;\n    };\n    \n    static unordered_map<void*, AllocationSite> s_activeAllocations;\n    static unordered_map<string, AllocationSite> s_allocationSites;\n    static mutex s_allocationMutex;\n    \npublic:\n    static void* TrackedMalloc(size_t size, const char* function, const char* file, int line) {\n        void* ptr = malloc(size);\n        if (ptr) {\n            lock_guard<mutex> lock(s_allocationMutex);\n            \n            // TODO 1: Record allocation site information\n            // TODO 2: Add to active allocations map\n            // TODO 3: Update allocation site statistics\n            // TODO 4: Check for memory usage thresholds\n        }\n        return ptr;\n    }\n    \n    static void TrackedFree(void* ptr) {\n        if (ptr) {\n            lock_guard<mutex> lock(s_allocationMutex);\n            // TODO 1: Remove from active allocations\n            // TODO 2: Update allocation site statistics\n            // TODO 3: Check for double-free attempts\n        }\n        free(ptr);\n    }\n    \n    static void GenerateLeakReport() {\n        // TODO 1: Analyze active allocations by allocation site\n        // TODO 2: Identify allocations that are growing over time\n        // TODO 3: Generate call stack information for leak sources\n        // TODO 4: Export leak data for external memory analyzers\n    }\n};\n\n#ifdef DEBUG_MEMORY\n#define TRACKED_NEW new(__FUNCTION__, __FILE__, __LINE__)\n#define TRACKED_DELETE TrackedFree\n#else\n#define TRACKED_NEW new\n#define TRACKED_DELETE delete\n#endif\n```\n\n### Implementation Guidance\n\nThe debugging infrastructure should be built incrementally alongside the core engine systems, with each milestone adding appropriate debugging capabilities for the subsystems being developed.\n\n#### Technology Recommendations\n\n| Debugging Category | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Graphics Debugging | `glGetError()` after each call + manual state checking | RenderDoc integration with automatic frame capture |\n| Performance Profiling | Manual timestamp logging with `std::chrono` | Integrated profiler with Chrome tracing export |\n| Memory Tracking | Override global `new`/`delete` with allocation logging | Valgrind/AddressSanitizer integration |\n| Logging System | Simple `printf` with log levels | Structured logging with async file writing |\n| Physics Debugging | Manual energy conservation checking | Integrated physics visualizer with collision display |\n\n#### Recommended Module Structure\n\n```cpp\nproject-root/\n  src/engine/\n    debug/\n      GraphicsDebugger.h/.cpp     ← Graphics state validation and capture\n      PerformanceProfiler.h/.cpp  ← Hierarchical timing profiler\n      MemoryTracker.h/.cpp        ← Allocation tracking and leak detection\n      EngineLogger.h/.cpp         ← Async logging system\n      PhysicsMonitor.h/.cpp       ← Physics simulation validation\n      DebugRenderer.h/.cpp        ← On-screen debug visualization\n    tools/\n      ProfileViewer/              ← External profiler data viewer\n      MemoryAnalyzer/             ← Memory usage analysis tools\n  tests/\n    debugging/\n      debug_integration_test.cpp  ← End-to-end debugging workflow tests\n      profiler_test.cpp           ← Performance profiler accuracy tests\n      memory_tracker_test.cpp     ← Memory tracking correctness tests\n```\n\n#### Core Debugging Infrastructure\n\n**Graphics Error Checking System:**\n```cpp\nclass GLErrorChecker {\n    static bool s_enableChecking;\n    static unordered_map<GLenum, string> s_errorStrings;\n    \npublic:\n    static bool CheckErrors(const char* operation, const char* file, int line) {\n        if (!s_enableChecking) return true;\n        \n        // TODO 1: Call glGetError() in loop until GL_NO_ERROR\n        // TODO 2: For each error, look up human-readable string\n        // TODO 3: Log error with operation name, file, and line number\n        // TODO 4: Include current OpenGL state context in error message\n        // TODO 5: Return false if any errors were found\n        return true;\n    }\n    \n    static void Initialize() {\n        // TODO 1: Populate s_errorStrings map with all OpenGL error codes\n        // TODO 2: Check if OpenGL debug context is available\n        // TODO 3: Register debug callback if supported\n        // TODO 4: Set initial checking enable state based on build configuration\n    }\n};\n```\n\n**Performance Timer Utility:**\n```cpp\nclass PerformanceTimer {\n    steady_clock::time_point m_startTime;\n    steady_clock::time_point m_endTime;\n    bool m_running;\n    \npublic:\n    void Start() {\n        // TODO 1: Record current high-resolution timestamp\n        // TODO 2: Set running flag to true\n        // TODO 3: Clear any previous end time\n        m_startTime = steady_clock::now();\n        m_running = true;\n    }\n    \n    void Stop() {\n        // TODO 1: Record end timestamp\n        // TODO 2: Set running flag to false\n        // TODO 3: Validate that Start() was called first\n        m_endTime = steady_clock::now();\n        m_running = false;\n    }\n    \n    double GetMilliseconds() const {\n        // TODO 1: Calculate duration between start and end times\n        // TODO 2: Convert to milliseconds with fractional precision\n        // TODO 3: Return 0.0 if timer hasn't been stopped\n        auto duration = m_endTime - m_startTime;\n        return duration_cast<duration<double, milli>>(duration).count();\n    }\n};\n```\n\n#### Language-Specific Debugging Hints\n\n**C++ Debugging Best Practices:**\n- Use `std::chrono::steady_clock` for performance timing (immune to system clock changes)\n- Leverage RAII with scoped timing classes to ensure measurements are always completed\n- Use `thread_local` storage for profiler data to avoid synchronization overhead\n- Implement custom memory allocators for debugging builds with allocation tracking\n- Use `__FUNCTION__`, `__FILE__`, and `__LINE__` macros for automatic source location tracking\n\n**OpenGL Debugging Techniques:**\n- Always check for OpenGL errors after context creation and major state changes\n- Use `glObjectLabel()` to assign names to OpenGL objects for clearer debug output\n- Implement fallback shaders that render solid colors when primary shaders fail to compile\n- Save framebuffer contents to disk files when rendering appears incorrect\n- Use `glFinish()` during debugging to force GPU/CPU synchronization for accurate timing\n\n#### Milestone Debugging Checkpoints\n\n**Milestone 1 - Rendering Foundation:**\n- **Verify**: Window creates successfully and displays solid color background\n- **Test**: Modify clear color and confirm visual changes\n- **Debug**: If black screen appears, check OpenGL context creation and viewport settings\n- **Tools**: Use graphics debugger to capture first successful frame\n\n**Milestone 2 - Entity Component System:**\n- **Verify**: Entity creation/destruction cycles properly with no memory growth\n- **Test**: Create 10,000 entities, destroy half, verify memory usage returns to baseline\n- **Debug**: If component queries return wrong entities, validate archetype organization\n- **Tools**: Profile ECS system iteration performance with 1000+ entities\n\n**Milestone 3 - Physics and Collision:**\n- **Verify**: Objects fall under gravity and stop when hitting ground (no tunneling)\n- **Test**: Stack boxes and verify stable resting contact without jitter\n- **Debug**: If objects explode or oscillate, check impulse calculation and timestep\n- **Tools**: Visualize collision shapes and contact points on screen\n\n**Milestone 4 - Resource Management:**\n- **Verify**: Texture loading works for PNG/JPG files with correct colors and orientation\n- **Test**: Load scene, transition to different scene, verify old resources are freed\n- **Debug**: If textures appear corrupted, check pixel format and OpenGL texture parameters\n- **Tools**: Monitor resource reference counts and detect handle leaks\n\n#### Common Debugging Scenarios\n\n| Scenario | Diagnostic Steps | Expected Findings | Resolution |\n|----------|-----------------|------------------|------------|\n| \"Everything compiles but window is black\" | 1. Check OpenGL context creation 2. Verify viewport size 3. Test shader compilation | Context creation succeeds, viewport matches window, shaders fail to compile | Add shader error logging and fix GLSL syntax errors |\n| \"Frame rate drops over time\" | 1. Profile frame time distribution 2. Monitor memory allocation 3. Track resource handle counts | Memory usage grows steadily, handle counts increase | Implement proper resource cleanup and reference counting |\n| \"Physics objects behave randomly\" | 1. Check for NaN values in positions 2. Verify timestep consistency 3. Monitor energy conservation | NaN detected after certain collisions | Add numerical stability checks and clamp extreme values |\n| \"Textures look wrong/corrupted\" | 1. Validate image loading format 2. Check OpenGL texture parameters 3. Verify texture coordinate setup | Image format doesn't match OpenGL expectations | Convert pixel data to match OpenGL format requirements |\n\n\n## Future Extensions\n\n> **Milestone(s):** All milestones (1-4) — future extensions build upon the foundation established across all development phases and demonstrate how architectural decisions enable advanced features\n\nA well-architected game engine is like a **city's infrastructure** — while the initial construction provides essential services like power, water, and roads, the real test of good urban planning comes when the city needs to grow. Can you add new neighborhoods without tearing up existing streets? Can the power grid scale to support skyscrapers? Can the transportation system adapt to autonomous vehicles? Similarly, the architectural decisions made throughout our four-milestone engine development create the foundation that either enables or constrains future capabilities.\n\nThe modular design philosophy we've established — with clear separation between rendering, ECS, physics, and resource management — acts as expansion joints in our engine's architecture. Each subsystem communicates through well-defined interfaces, making it possible to enhance individual components without cascading changes throughout the codebase. The handle-based resource system provides indirection that allows for advanced resource streaming. The data-oriented ECS design enables parallelization. The fixed-timestep physics architecture supports networked multiplayer. These aren't accidents — they're the natural result of thinking beyond immediate requirements.\n\nThis section explores three categories of advanced features that our engine architecture naturally supports: enhanced rendering capabilities that transform visual fidelity, expanded engine systems that broaden functionality beyond core game mechanics, and performance optimizations that scale to handle demanding modern game requirements. Each extension leverages the architectural foundation we've built while introducing new design challenges and opportunities.\n\n### Advanced Rendering Features\n\n> **Mental Model: Photography Studio Evolution**\n> Think of our current rendering system as a basic portrait studio with essential lighting and a backdrop. Advanced rendering features are like upgrading to a professional film studio with multiple lighting rigs, green screens, post-processing equipment, and real-time color correction. Each new capability builds on the existing infrastructure while adding layers of sophistication.\n\nThe rendering foundation established in Milestone 1 provides the infrastructure for sophisticated visual enhancements. Our shader compilation system, batch rendering architecture, and GPU resource management create the scaffolding needed for advanced lighting models, shadow rendering, and post-processing effects. These extensions transform our engine from a functional rendering pipeline into a visually compelling graphics system.\n\n#### Dynamic Lighting and Shadow Systems\n\nOur current rendering pipeline processes sprites and meshes with simple texture sampling and vertex colors. Advanced lighting extends this foundation by introducing multiple light sources, surface materials, and shadow casting. The architectural hooks already exist in our `ShaderProgram` system — we simply need to expand the uniform variable system to support light parameters and shadow maps.\n\n| Lighting Component | Purpose | Integration Point | Data Requirements |\n|-------------------|---------|-------------------|------------------|\n| Directional Light | Sun-like illumination | ECS component on entities | Direction vector, color, intensity |\n| Point Light | Localized illumination | ECS component with Transform | Position, color, intensity, attenuation |\n| Spot Light | Focused illumination | ECS component with Transform | Position, direction, cone angles, color |\n| Shadow Map | Depth-based shadow rendering | Framebuffer render target | Resolution, light space matrix |\n| Material Properties | Surface light response | Component with mesh data | Albedo, normal, metallic, roughness |\n\nThe lighting calculation pipeline integrates naturally with our existing ECS architecture. A `LightingSystem` would query entities with light components during the rendering phase, uploading light parameters as uniform arrays to the fragment shader. Our `BatchRenderer` requires minimal modification — the same geometry batching applies, but with expanded shader programs that perform light calculations per-pixel.\n\nShadow mapping introduces the concept of multi-pass rendering, where the scene is rendered multiple times from different perspectives. Our `Renderer` interface can be extended with a `RenderToFramebuffer` method that captures depth information from the light's perspective. The resulting shadow map texture becomes an additional uniform input to the main rendering pass, where shadow coordinates are calculated and compared for shadow determination.\n\n> **Critical Insight: Shader Hot-Swapping**\n> Advanced rendering features require rapid iteration on shader code. Our `ShaderProgram` architecture supports this by detecting file changes and recompiling shaders at runtime, allowing artists and programmers to see lighting changes immediately without engine restarts.\n\n#### Post-Processing Pipeline\n\nPost-processing effects transform the final rendered image through screen-space operations like bloom, tone mapping, and depth-of-field blur. These effects require a **full-screen quad rendering** approach where the scene is first rendered to an off-screen framebuffer, then processed through multiple shader passes before final presentation.\n\n| Post-Process Effect | Visual Impact | Shader Requirements | Performance Cost |\n|--------------------|---------------|-------------------|------------------|\n| Bloom | Bright objects glow | Gaussian blur passes | Medium (multiple passes) |\n| Tone Mapping | HDR to display range | Single pass with LUT | Low (single pass) |\n| Depth of Field | Camera focus simulation | Blur with depth testing | High (complex blur) |\n| Screen Space Ambient Occlusion | Contact shadows | Depth buffer sampling | High (many samples) |\n| Temporal Anti-Aliasing | Edge smoothing | Previous frame history | Medium (memory bandwidth) |\n\nThe post-processing pipeline requires extending our `Renderer` with framebuffer management capabilities. A `PostProcessManager` component would maintain a chain of render targets and associated shaders, applying effects in sequence. Our existing `BatchRenderer` handles the full-screen quad rendering — it's simply a sprite that covers the entire screen with the previous render pass as its texture.\n\nEach post-processing effect becomes a self-contained shader program with its associated framebuffer configuration. The pipeline supports **effect chaining** where the output of one effect becomes the input to the next. Memory management requires careful attention — multiple full-screen render targets can consume significant GPU memory, requiring adaptive resolution scaling based on available video memory.\n\n> **Architecture Decision: Render Graph vs Linear Pipeline**\n> - **Context**: Post-processing effects have dependencies and optimal execution orders that vary by scene content\n> - **Options Considered**: \n>   1. Linear pipeline (fixed effect order)\n>   2. Render graph (dynamic dependency resolution)\n>   3. Hybrid approach (linear with optional branches)\n> - **Decision**: Linear pipeline with optional branches\n> - **Rationale**: Provides 80% of the flexibility with 20% of the complexity. Most post-processing workflows follow predictable patterns, but occasional branching (skip expensive effects on low-end hardware) provides necessary adaptability\n> - **Consequences**: Enables immediate implementation while preserving upgrade path to full render graph when complexity demands justify the investment\n\n#### Modern Rendering Techniques\n\nAdvanced rendering techniques like physically-based rendering (PBR) and compute shader integration represent significant extensions to our graphics pipeline. These features require substantial shader program expansion and new GPU resource management patterns, but our existing architecture provides the foundation for implementation.\n\nPBR rendering replaces ad-hoc lighting calculations with physically accurate material models. The mathematical complexity increases significantly, but the integration points remain the same — expanded uniform variables for material properties, enhanced fragment shaders for lighting calculations, and additional textures for surface detail maps.\n\n| PBR Component | Physical Meaning | Texture Input | Shader Calculation |\n|---------------|------------------|---------------|-------------------|\n| Albedo | Surface color without lighting | RGB texture | Diffuse color basis |\n| Normal Map | Surface micro-geometry | RGB encoded vectors | Tangent space transformation |\n| Metallic | Conductor vs dielectric | Grayscale texture | Specular reflection behavior |\n| Roughness | Surface micro-facet distribution | Grayscale texture | Light scattering calculation |\n| Ambient Occlusion | Ambient light blocking | Grayscale texture | Ambient light attenuation |\n\nCompute shaders introduce GPU-based computation for non-rendering tasks like particle simulation, procedural animation, and advanced lighting calculations. Our `ShaderProgram` system requires extension to support compute shader compilation and dispatch. The key architectural challenge is **CPU-GPU synchronization** — ensuring compute results are available when needed by the rendering pipeline.\n\nThe integration approach leverages our existing handle-based resource system. Compute buffers become a new resource type managed by the `ResourceManager`, with `ComputeBufferHandle` providing safe access similar to texture and mesh handles. Systems that depend on compute results can query buffer availability before proceeding with dependent calculations.\n\n### Engine System Extensions\n\nBeyond enhanced visuals, a mature game engine provides systems for audio, networking, scripting, and development tools. Our architectural foundation — particularly the ECS design and event-driven communication patterns — creates natural integration points for these advanced capabilities.\n\n#### Audio System Integration\n\nGame audio encompasses environmental soundscapes, dynamic music, and interactive sound effects that respond to game state changes. An audio system integrates with our engine through ECS components that represent sound sources and listeners, with spatial audio calculations updating based on entity transforms.\n\n| Audio Component Type | ECS Integration | Behavior | Resource Dependencies |\n|---------------------|----------------|----------|---------------------|\n| Audio Source | Component with Transform | 3D positioned sound | AudioHandle references |\n| Audio Listener | Component with Transform | Player ear position | None (singleton) |\n| Audio Mixer | System processor | Volume and effect management | Audio configuration |\n| Music Manager | System processor | Dynamic music transitions | Music track AudioHandles |\n| Sound Pool | Resource optimization | Reusable audio instances | Pooled AudioHandle groups |\n\nThe audio pipeline follows our established resource loading patterns. Audio files become `AudioResource` objects managed by the `ResourceManager`, with `AudioHandle` references providing safe access. The `AudioSystem` queries entities with audio components during each frame, calculating 3D spatial audio parameters based on source and listener transforms.\n\nAudio streaming introduces **background loading** requirements similar to texture streaming. Large audio files can't be fully loaded into memory simultaneously, requiring a streaming buffer system that loads audio data on-demand. Our existing asynchronous resource loading infrastructure supports this through prioritized loading queues and completion callbacks.\n\n> **Critical Design Challenge: Audio Threading**\n> Audio processing requires consistent timing to avoid glitches, while game logic runs on variable frame times. The solution is an independent audio thread that maintains its own fixed-rate update loop, communicating with the main thread through lock-free queues for parameter updates and trigger events.\n\n#### Networking and Multiplayer Support\n\nNetworked multiplayer transforms a single-player game engine into a distributed system where game state must remain synchronized across multiple clients. Our deterministic physics simulation and serializable ECS architecture provide the foundation for reliable multiplayer implementation.\n\nThe networking extension introduces **client-server** and **peer-to-peer** communication patterns. Client-server architecture designates one instance as authoritative, with clients sending input and receiving state updates. Peer-to-peer architecture distributes authority, requiring more complex conflict resolution but eliminating single points of failure.\n\n| Networking Pattern | Authority Model | Synchronization Approach | Failure Handling |\n|-------------------|----------------|-------------------------|------------------|\n| Client-Server | Server authoritative | Input prediction + rollback | Client reconnection |\n| Peer-to-Peer | Distributed consensus | Shared simulation state | Majority voting |\n| Hybrid | Dynamic authority | Region-based authority | Authority migration |\n\nOur ECS architecture supports networking through **component replication**. Network-relevant components are marked with replication flags, and a `NetworkSystem` serializes component changes for transmission. The receiving system applies updates to local entity state, with conflict resolution handling simultaneous modifications.\n\nThe serialization system extends our existing scene serialization infrastructure. Network messages use the same `ToJSON`/`FromJSON` patterns established for scene persistence, ensuring consistency between save/load and network synchronization. Delta compression reduces bandwidth by transmitting only changed component values rather than complete entity state.\n\n> **Architecture Decision: Lockstep vs Client-Server**\n> - **Context**: Multiplayer games require synchronized game state across multiple machines with varying network latency\n> - **Options Considered**:\n>   1. Lockstep simulation (all clients run identical simulation)\n>   2. Client-server (authoritative server, predictive clients)\n>   3. Hybrid (deterministic simulation with periodic reconciliation)\n> - **Decision**: Client-server with input prediction\n> - **Rationale**: Provides best balance of responsiveness and security. Lockstep requires perfect synchronization and is vulnerable to cheating. Pure server authority has poor responsiveness. Client-server with prediction provides immediate feedback while maintaining server authority\n> - **Consequences**: Requires rollback and replay systems for mispredictions, but enables responsive multiplayer with cheat protection\n\n#### Scripting System Integration\n\nScripting languages like Lua or Python enable rapid gameplay iteration without engine recompilation. A scripting system integrates with our ECS architecture by allowing scripts to define custom components and systems, extending game behavior through interpreted code rather than compiled C++.\n\nThe scripting integration creates a **dual-language** architecture where performance-critical systems remain in C++ while gameplay logic moves to scripts. This separation requires careful API design to expose engine functionality to scripts without compromising performance or stability.\n\n| Scripting Integration Point | C++ Responsibility | Script Responsibility | Communication Method |\n|----------------------------|-------------------|---------------------|---------------------|\n| Component Definition | Storage and iteration | Data structure and behavior | Registration callbacks |\n| System Logic | ECS query and execution | Gameplay rules and reactions | Function call binding |\n| Event Handling | Event queue management | Event response logic | Callback registration |\n| Resource Access | Handle validation and lifecycle | Content specification and usage | Proxy object wrapping |\n\nThe implementation approach embeds a scripting interpreter within the engine process, with bidirectional binding between C++ engine code and script functions. Scripts define custom components as data tables, while C++ provides the underlying storage and iteration infrastructure. Custom systems written in scripts receive callbacks during the system update phase, with access to entity queries and component modification through bound API functions.\n\nScript sandboxing becomes important for security and stability. Scripts should not directly access memory or file systems, instead operating through controlled engine APIs. Resource access follows our handle-based pattern, with script proxies providing safe access to textures, audio, and other assets.\n\n#### Development Tools and Editor Integration\n\nProfessional game development requires editor tools for level design, asset management, and debugging. Our engine architecture supports editor integration through **reflection** systems that expose internal data structures and **immediate mode GUI** systems that provide runtime debugging interfaces.\n\n| Editor Component | Purpose | Integration Approach | Implementation Requirements |\n|-----------------|---------|---------------------|---------------------------|\n| Scene Editor | Visual level design | ECS entity manipulation | Transform gizmos, selection |\n| Asset Browser | Resource management | ResourceManager integration | Thumbnail generation, metadata |\n| Performance Profiler | Runtime analysis | System timing collection | Frame time graphs, memory usage |\n| Component Inspector | Entity debugging | Reflection-based UI | Property editing, type introspection |\n| Console Window | Command execution | Script system integration | Command parsing, output display |\n\nThe editor architecture follows a **plugin** pattern where each tool is a self-contained module that interfaces with the engine through well-defined APIs. This separation allows editor features to be developed independently while maintaining engine stability. The editor runs alongside the game, sharing the same ECS world but with additional systems for tool functionality.\n\nReflection support requires extending our component system with **metadata** that describes component fields, types, and constraints. This metadata enables automatic GUI generation for component editing without manual interface programming for each component type. The reflection system integrates with our serialization infrastructure, ensuring that editor modifications can be saved and loaded consistently.\n\n### Performance and Scalability\n\nModern games demand performance that scales from mobile devices to high-end gaming PCs. Our engine architecture provides multiple optimization pathways through multi-threading, job systems, and GPU compute integration. These performance extensions build upon our data-oriented design foundation while introducing parallel processing complexity.\n\n#### Multi-Threading and Job Systems\n\nGame engines are naturally parallel — rendering, physics, and audio can execute simultaneously while the main thread coordinates overall execution. A **job system** architecture decomposes frame processing into independent work units that execute across multiple CPU cores.\n\nOur ECS design supports parallelization through **component archetype** organization. Systems that operate on disjoint component sets can execute simultaneously, while systems with overlapping component access require synchronization. The challenge is **dependency management** — ensuring systems execute in the correct order while maximizing parallel execution opportunities.\n\n| Threading Model | Coordination Approach | Scalability Characteristics | Implementation Complexity |\n|-----------------|----------------------|---------------------------|-------------------------|\n| Thread Pool | Work stealing queues | Scales with available cores | Medium (queue management) |\n| Task Graph | Dependency resolution | Optimal parallel scheduling | High (graph construction) |\n| Pipeline | Stage-based processing | Predictable parallel patterns | Low (fixed pipeline stages) |\n\nThe job system implementation extends our existing `System` execution infrastructure. Instead of sequential system updates, systems generate **job descriptions** that specify their component requirements and processing functions. A job scheduler analyzes dependencies and assigns work to available threads, ensuring that systems with conflicting component access don't execute simultaneously.\n\nMemory access patterns become critical for multi-threaded performance. Our component storage system's dense arrays provide **cache-friendly** iteration patterns that work well with parallel processing. Thread-local memory pools reduce allocation contention, while lock-free data structures enable safe concurrent access to shared resources.\n\n> **Critical Performance Insight: False Sharing**\n> Multi-threaded component processing can suffer from false sharing when adjacent components are processed by different threads. The solution is **component padding** or **interleaved processing** patterns that ensure each thread works on cache-line-aligned memory regions.\n\n#### GPU Compute Integration\n\nModern GPUs provide massive parallel processing capability beyond graphics rendering. **Compute shaders** enable GPU-accelerated physics simulation, procedural content generation, and AI processing. Our engine architecture supports compute integration through extended shader management and CPU-GPU synchronization patterns.\n\nCompute shader integration follows our established resource management patterns. Compute buffers become a new resource type with associated handles and lifecycle management. The key challenge is **synchronization** — ensuring compute results are available when needed by dependent systems while avoiding CPU-GPU pipeline stalls.\n\n| Compute Application | Parallel Advantage | Integration Requirements | Synchronization Needs |\n|--------------------|-------------------|------------------------|---------------------|\n| Particle Physics | Thousands of independent particles | Particle component storage | Position buffer readback |\n| Procedural Animation | Vertex-level skeletal animation | Mesh vertex buffer access | Animation frame synchronization |\n| Pathfinding | Parallel graph traversal | Spatial grid representation | Path result availability |\n| Procedural Generation | Noise evaluation and terrain synthesis | Heightmap texture generation | Terrain mesh creation |\n\nThe implementation approach extends our `ShaderProgram` system with compute shader compilation and dispatch capabilities. Compute operations become part of the frame processing pipeline, with careful scheduling to avoid resource conflicts between compute and graphics operations. Buffer mapping and unmapping require explicit management to ensure data consistency across CPU and GPU operations.\n\nAsynchronous compute enables **parallel GPU processing** where compute operations execute concurrently with graphics rendering. This requires sophisticated resource management to ensure compute operations don't interfere with ongoing rendering, typically through double-buffered resource patterns.\n\n#### Memory Management Optimization\n\nAdvanced performance requires sophisticated memory management that goes beyond basic allocation and deallocation. **Memory pools**, **object recycling**, and **cache-aware data layout** optimize allocation patterns and improve cache performance for performance-critical game loops.\n\nOur ECS architecture already provides foundation-level memory management through dense component arrays and handle-based resource access. Performance optimization builds upon this foundation with specialized allocators and memory access pattern analysis.\n\n| Memory Optimization | Performance Impact | Implementation Requirements | Trade-offs |\n|--------------------|-------------------|---------------------------|-----------|\n| Memory Pools | Eliminates allocation overhead | Pre-allocated block management | Memory over-allocation |\n| Object Recycling | Reduces garbage collection | Object lifecycle tracking | Initialization overhead |\n| Custom Allocators | Cache-friendly allocation | Platform-specific optimization | Implementation complexity |\n| Memory Mapping | Large file handling | Virtual memory management | Address space consumption |\n\nMemory pool implementation extends our component storage with **pre-allocated** blocks for frequently created and destroyed objects. Particle systems, temporary collision pairs, and network messages benefit from pooled allocation patterns that eliminate allocation overhead during performance-critical frame processing.\n\nCache optimization requires **data layout** analysis of our component storage patterns. Struct-of-arrays organization provides good cache performance for system iteration, but cross-system component access may benefit from **hybrid** layouts that group related components for spatial locality.\n\nMemory profiling integration provides runtime analysis of allocation patterns and memory usage trends. This profiling data informs optimization decisions and helps identify memory leaks or excessive allocation in performance-critical code paths.\n\n> **Architecture Decision: Custom Allocators vs Standard Library**\n> - **Context**: Game engines require predictable memory allocation performance with minimal fragmentation and low latency\n> - **Options Considered**:\n>   1. Standard library allocators (malloc/free, new/delete)\n>   2. Custom game-specific allocators (pools, stacks, rings)\n>   3. Hybrid approach (custom for hot paths, standard for cold paths)\n> - **Decision**: Hybrid approach with custom allocators for performance-critical systems\n> - **Rationale**: Standard allocators provide good general performance but can't optimize for specific game engine access patterns. Custom allocators for components, rendering, and physics provide predictable performance. Standard allocators for initialization and tool code reduce implementation burden\n> - **Consequences**: Requires allocator interface abstraction and careful memory ownership tracking, but enables optimal performance for frame-critical systems\n\n### Common Extension Pitfalls\n\n⚠️ **Pitfall: Feature Creep Without Architecture Evolution**\nMany engine extensions fail because they're bolted onto existing systems without considering architectural implications. Adding networking to a single-player engine, for example, requires fundamental changes to state management and update ordering. The solution is to evaluate how each extension affects core architectural assumptions and modify foundational systems as needed rather than creating workarounds.\n\n⚠️ **Pitfall: Performance Optimization Too Early**\nAdvanced performance features like multi-threading and GPU compute introduce significant complexity that can destabilize a working engine. Implement these optimizations only after establishing baseline functionality and identifying actual performance bottlenecks through profiling. Premature optimization often creates bugs that are difficult to diagnose and fix.\n\n⚠️ **Pitfall: Breaking Interface Compatibility**\nEngine extensions should enhance existing systems without breaking established APIs. Adding lighting support, for example, should extend the rendering pipeline rather than replacing it entirely. Design extensions as **additive** features that can be enabled or disabled without affecting core engine functionality.\n\n⚠️ **Pitfall: Ignoring Resource Constraints**\nAdvanced features often assume abundant memory and processing power. Real games run on constrained hardware with limited memory and battery life. Design extensions with **scalability** from the beginning, providing quality settings and graceful degradation when resources are limited.\n\n### Implementation Guidance\n\nThe future extensions described above build upon the four-milestone foundation, demonstrating how architectural decisions made during core development enable advanced capabilities. This section provides concrete starting points for implementing selected extensions.\n\n#### Technology Recommendations\n\n| Extension Category | Foundational Technology | Advanced Integration |\n|-------------------|------------------------|---------------------|\n| Advanced Rendering | OpenGL 3.3 + GLSL shaders | Vulkan with compute shaders |\n| Audio System | OpenAL or SDL2 Audio | FMOD or Steam Audio |\n| Networking | UDP sockets + serialization | ENet or custom reliable UDP |\n| Scripting Integration | Lua with C++ binding | Python with pybind11 |\n| Multi-threading | std::thread with work queues | Intel TBB or custom job system |\n| Development Tools | Dear ImGui for immediate mode UI | Custom editor with Qt or web UI |\n\n#### Recommended Extension Implementation Order\n\nExtensions should be implemented in dependency order, building upon previously established capabilities:\n\n```\nengine-extensions/\n  rendering/\n    lighting/\n      directional_light.h          ← Basic lighting components\n      point_light.h                ← Extends ECS with light entities\n      shadow_mapper.h              ← Framebuffer-based shadow rendering\n    post_processing/\n      post_process_manager.h       ← Pipeline for chained effects\n      bloom_effect.h               ← Gaussian blur-based bloom\n      tone_mapper.h                ← HDR to LDR conversion\n  systems/\n    audio/\n      audio_system.h               ← 3D positioned audio processing\n      audio_streaming.h            ← Background audio loading\n    networking/\n      network_system.h             ← Component replication\n      client_server.h              ← Authority and prediction\n    scripting/\n      lua_integration.h            ← Embedded Lua interpreter\n      script_component.h           ← Script-defined components\n  performance/\n    threading/\n      job_system.h                 ← Multi-threaded system execution\n      thread_pool.h                ← Work stealing implementation\n    compute/\n      compute_shader.h             ← GPU compute integration\n      buffer_manager.h             ← CPU-GPU synchronization\n```\n\n#### Advanced Rendering Infrastructure\n\nThe lighting and post-processing extensions require framebuffer management and multi-pass rendering capabilities:\n\n```cpp\n// Framebuffer management for advanced rendering\nclass FramebufferManager {\nprivate:\n    struct FramebufferConfig {\n        uint32_t width;\n        uint32_t height;\n        GLenum colorFormat;\n        bool hasDepth;\n        bool hasStencil;\n    };\n    \n    unordered_map<string, uint32_t> m_framebuffers;\n    unordered_map<string, uint32_t> m_colorTextures;\n    unordered_map<string, uint32_t> m_depthTextures;\n    \npublic:\n    // TODO: Create framebuffer with specified configuration\n    bool CreateFramebuffer(const string& name, const FramebufferConfig& config);\n    \n    // TODO: Bind framebuffer for rendering (use 0 for default framebuffer)\n    void BindFramebuffer(const string& name);\n    \n    // TODO: Get color texture handle for use in subsequent passes\n    uint32_t GetColorTexture(const string& name);\n    \n    // TODO: Get depth texture for shadow mapping or depth effects\n    uint32_t GetDepthTexture(const string& name);\n    \n    // TODO: Resize framebuffer when window dimensions change\n    void ResizeFramebuffer(const string& name, uint32_t width, uint32_t height);\n};\n\n// Multi-pass rendering coordinator\nclass RenderPassManager {\nprivate:\n    struct RenderPass {\n        string name;\n        string framebuffer;    // Target framebuffer name\n        ShaderProgram shader;  // Shader for this pass\n        function<void()> setupCallback;  // Pass-specific setup\n    };\n    \n    vector<RenderPass> m_passes;\n    FramebufferManager* m_framebufferManager;\n    \npublic:\n    // TODO: Add render pass to execution pipeline\n    void AddPass(const string& name, const string& framebuffer, \n                 const ShaderProgram& shader, function<void()> setup);\n    \n    // TODO: Execute all passes in sequence\n    void ExecutePasses();\n    \n    // TODO: Clear all registered passes (for dynamic pipeline changes)\n    void ClearPasses();\n};\n```\n\n#### ECS-Integrated Audio System\n\nThe audio system demonstrates how new engine systems integrate with our established ECS architecture:\n\n```cpp\n// Audio components that integrate with existing ECS\nstruct AudioSource {\n    AudioHandle audioClip;\n    float volume = 1.0f;\n    float pitch = 1.0f;\n    bool looping = false;\n    bool is3D = true;\n    float maxDistance = 100.0f;\n    bool isPlaying = false;\n};\n\nstruct AudioListener {\n    float masterVolume = 1.0f;\n    Vector3 velocity = {0, 0, 0};  // For doppler effects\n};\n\n// Audio system that processes spatial audio each frame\nclass AudioSystem {\nprivate:\n    void* m_audioContext;  // OpenAL context or similar\n    Entity m_listenerEntity;\n    unordered_map<Entity, uint32_t> m_activeSources;\n    \npublic:\n    // TODO: Initialize audio context and set up 3D audio parameters\n    bool Initialize();\n    \n    // TODO: Update all audio sources based on 3D positions relative to listener\n    void Update(ECSWorld* world, float deltaTime) {\n        // TODO: Find listener entity and get its transform\n        // TODO: Query all entities with AudioSource and Transform components\n        // TODO: For each audio source, calculate 3D position relative to listener\n        // TODO: Update OpenAL source position, velocity, and attenuation\n        // TODO: Start or stop sources based on isPlaying flag changes\n    }\n    \n    // TODO: Trigger one-shot audio playback at specific world position\n    void PlaySoundAtPosition(AudioHandle audio, Vector3 position, float volume);\n    \n    // TODO: Clean up audio context and release resources\n    void Shutdown();\n};\n```\n\n#### Job System Foundation\n\nMulti-threading support requires careful integration with the existing ECS system execution pipeline:\n\n```cpp\n// Job description for work that can execute in parallel\nstruct Job {\n    function<void()> workFunction;\n    vector<ComponentTypeID> requiredComponents;\n    vector<ComponentTypeID> modifiedComponents;\n    string debugName;\n};\n\n// Thread-safe job queue with work stealing\nclass JobSystem {\nprivate:\n    vector<thread> m_workers;\n    vector<ThreadSafeQueue<Job>> m_jobQueues;  // One queue per worker thread\n    atomic<bool> m_shouldStop{false};\n    uint32_t m_numThreads;\n    \n    // TODO: Worker thread main loop that steals work from other queues when idle\n    void WorkerThreadMain(uint32_t threadIndex);\n    \npublic:\n    // TODO: Start worker threads (typically numCores - 1 to leave main thread free)\n    bool Initialize(uint32_t numThreads = thread::hardware_concurrency() - 1);\n    \n    // TODO: Add job to least loaded worker queue\n    void SubmitJob(const Job& job);\n    \n    // TODO: Wait for all currently queued jobs to complete\n    void WaitForCompletion();\n    \n    // TODO: Execute systems in parallel where component dependencies allow\n    void ExecuteSystemsParallel(vector<System*>& systems, ECSWorld* world, float deltaTime) {\n        // TODO: Analyze component dependencies between systems\n        // TODO: Group systems into parallel batches based on component conflicts\n        // TODO: Execute each batch in parallel, synchronizing between batches\n        // TODO: Handle systems that require exclusive access to components\n    }\n    \n    // TODO: Shutdown worker threads gracefully\n    void Shutdown();\n};\n```\n\n#### Extension Integration Checkpoints\n\nEach extension category has specific verification steps to ensure proper integration:\n\n**Lighting System Verification:**\n1. Compile and run engine with a scene containing multiple point lights\n2. Verify lights affect sprite and mesh rendering with realistic falloff\n3. Test shadow map generation by observing shadow casting from directional light\n4. Confirm performance remains acceptable with 10+ dynamic lights\n\n**Audio System Verification:**\n1. Play positioned audio that changes volume based on camera distance\n2. Test audio streaming by loading large audio files without frame drops\n3. Verify multiple simultaneous audio sources mix properly\n4. Confirm audio continues playing during physics simulation and rendering\n\n**Multi-threading Verification:**\n1. Profile frame time with and without parallel system execution enabled\n2. Test thread safety by running intensive workloads without crashes\n3. Verify deterministic behavior by comparing single-threaded and multi-threaded results\n4. Monitor CPU usage to confirm work is distributed across available cores\n\nThe extension architecture demonstrates how thoughtful foundational design enables sophisticated future capabilities while maintaining the modular, testable structure established during core engine development.\n\n\n## Glossary\n\n> **Milestone(s):** All milestones (1-4) — terminology reference needed throughout development to ensure consistent understanding of game engine concepts and implementation details\n\nUnderstanding game engine development requires mastery of specialized terminology from multiple domains: computer graphics, physics simulation, software architecture, and real-time systems. This glossary serves as both a learning aid for newcomers and a reference for consistent terminology throughout the project. Each term includes not only its definition but also its context within game engine architecture and relationships to other concepts.\n\n### Mental Model: Technical Dictionary with Context\n\nThink of this glossary as a **specialized technical dictionary for a foreign language**. Game engine development has evolved its own vocabulary that combines terms from graphics programming, physics simulation, software architecture, and performance optimization. Just as a foreign language dictionary provides not only translations but also usage examples and cultural context, this glossary explains not just what each term means, but how it fits into the broader ecosystem of game engine architecture and why understanding it matters for implementation success.\n\n### Core Architecture Terminology\n\nThe foundation of game engine terminology centers around the major architectural patterns and design principles that govern how game engines organize code, data, and system interactions.\n\n| Term | Definition | Context | Related Concepts |\n|------|------------|---------|------------------|\n| **Entity Component System (ECS)** | Architectural pattern separating data (components) from behavior (systems) with entities as unique identifiers | Primary architecture for game object management in modern engines | Entity, Component, System, Archetype |\n| **Data-Oriented Design** | Programming approach that organizes data by access patterns rather than conceptual relationships | Optimization philosophy underlying ECS and cache-friendly data structures | Cache-friendly, Struct-of-arrays, Hot/cold data |\n| **Frame Time Budget** | Maximum time available per frame to maintain target framerate (16.67ms for 60fps) | Performance constraint that drives all system design decisions | Fixed timestep, Frame processing pipeline |\n| **Handle-Based Access** | Indirect resource access through validated handles instead of raw pointers | Memory safety and resource lifecycle management strategy | Resource handles, Generation counter, Handle validation |\n| **Archetype** | Group of entities sharing identical component signatures | ECS optimization technique for efficient component iteration | Component signature, Dense storage, System queries |\n| **Component Signature** | Bitset indicating which component types an entity possesses | Fast matching mechanism for system queries and archetype assignment | Bitset operations, Entity queries, System execution |\n\n**Real-time System Constraints** define the performance and behavioral requirements that distinguish game engines from general-purpose applications. Unlike traditional software that can take variable time to complete operations, game engines must maintain consistent frame rates and deterministic behavior under strict time constraints.\n\n| Term | Definition | Context | Implementation Impact |\n|------|------------|---------|----------------------|\n| **Deterministic Simulation** | Identical inputs always produce identical outputs regardless of timing | Critical for physics simulation and networked gameplay | Fixed timestep, Floating-point precision, Accumulator pattern |\n| **Frame Processing Pipeline** | Sequence of input, update, physics, and rendering phases repeated each frame | Organizing principle for all engine subsystems | System ordering, Data dependencies, Parallel execution |\n| **Cache-Friendly** | Memory layout optimized for CPU cache performance | Performance optimization for component iteration and bulk operations | Struct-of-arrays, Dense storage, Prefetching |\n| **Fixed Timestep** | Constant time increment for deterministic physics simulation | Decouples simulation accuracy from rendering framerate | Accumulator pattern, Spiral of death, Interpolation |\n| **Accumulator Pattern** | Time debt system that decouples physics from rendering frame rate | Ensures deterministic physics while allowing variable rendering framerate | Fixed timestep, Frame time budget, Interpolation |\n\n### Entity Component System Terminology\n\nThe ECS architecture introduces specialized terminology for entity management, component storage, and system execution that differs significantly from traditional object-oriented approaches.\n\n| Term | Definition | Storage Implications | Performance Characteristics |\n|------|------------|---------------------|----------------------------|\n| **Dense Storage** | Contiguous array storage without gaps for maximum cache efficiency | Components stored in packed arrays with index mapping | O(1) iteration, excellent cache locality |\n| **Sparse Storage** | Hash table or similar structure allowing gaps but direct entity ID indexing | Components accessed directly by entity ID | O(1) random access, poor iteration performance |\n| **Struct-of-Arrays (SoA)** | Organizing data with separate arrays for each field type | Each component type has separate arrays for each field | Optimal for SIMD operations, complex access patterns |\n| **Array-of-Structs (AoS)** | Organizing data with objects containing all fields together | Components stored as complete structures in arrays | Simple access patterns, suboptimal cache usage |\n| **Generation Counter** | Version number to detect stale handle references after entity recycling | Entity IDs include generation bits incremented on reuse | Prevents use-after-free errors, validates handle lifetime |\n| **Component Archetype** | Entities grouped by identical component signatures for efficient iteration | Systems process entire archetypes rather than individual entities | Minimizes component storage fragmentation |\n\n**Entity Lifecycle Management** encompasses the creation, modification, and destruction of entities within the ECS framework. Understanding these patterns is crucial for preventing memory leaks and maintaining system performance.\n\n| Operation | Purpose | Implementation Strategy | Performance Impact |\n|-----------|---------|-------------------------|-------------------|\n| **Entity Recycling** | Reuse destroyed entity IDs to prevent ID exhaustion | Maintain free list of available entity slots | Prevents unbounded ID growth |\n| **Component Addition** | Attach new component data to existing entity | May require archetype migration and storage reallocation | O(1) amortized with occasional O(n) migration |\n| **Component Removal** | Detach component data while preserving entity | Triggers archetype change and component cleanup | O(1) removal with potential archetype fragmentation |\n| **Archetype Migration** | Move entity between component signature groups | Copy entity's components to new archetype storage | O(k) where k is number of components |\n| **Entity Destruction** | Remove entity and all associated components | Mark ID for recycling and cleanup all component storage | O(k) component cleanup operations |\n\n### Graphics and Rendering Terminology\n\nGraphics programming introduces extensive terminology for GPU interaction, shader management, and rendering pipeline optimization. These concepts are fundamental to understanding how game engines transform 3D world data into 2D screen pixels.\n\n| Term | Definition | GPU Interaction | Performance Implications |\n|------|------------|-----------------|-------------------------|\n| **Vertex Buffer** | GPU memory storing vertex attribute data (position, texture coordinates, colors) | Uploaded once, referenced multiple times in draw calls | Minimizes CPU-GPU data transfer overhead |\n| **Shader Program** | Linked vertex and fragment shaders that define rendering appearance | Compiled on GPU, switched between draw operations | State changes expensive, batch similar materials |\n| **Draw Call** | GPU command to render geometry using current shader and vertex data | Synchronization point between CPU and GPU | Minimize count through batching |\n| **State Change** | GPU pipeline reconfiguration between draw operations | Flushes GPU pipeline and reconfigures rendering state | Expensive operation, group similar rendering work |\n| **Batch Rendering** | Grouping similar draw operations to minimize GPU state changes | Collect sprites/meshes with same material before submission | Reduces draw calls from thousands to dozens |\n| **Uniform Variable** | Shader parameter constant across entire draw call | Set once per draw call, accessible to all vertices/pixels | Efficient way to pass transformation matrices |\n\n**Rendering Pipeline Stages** represent the sequence of operations that transform 3D geometry into final pixel colors. Each stage has specific responsibilities and performance characteristics that influence overall rendering efficiency.\n\n| Stage | Input | Processing | Output | Optimization Focus |\n|-------|-------|------------|--------|-------------------|\n| **Vertex Shader** | Vertex attributes | Transform vertices to clip space | Transformed vertices | Minimize matrix operations |\n| **Primitive Assembly** | Transformed vertices | Group vertices into triangles | Primitive shapes | Handled automatically by GPU |\n| **Rasterization** | Triangles in clip space | Generate pixel fragments | Fragment candidates | Reduce overdraw through culling |\n| **Fragment Shader** | Fragment data | Calculate final pixel color | Colored fragments | Optimize texture sampling |\n| **Depth Testing** | Fragment depth values | Discard occluded fragments | Visible fragments | Enable early-Z rejection |\n| **Blending** | Final fragment colors | Combine with framebuffer | Final pixel colors | Minimize alpha blending |\n\n**Texture and Resource Management** within the rendering system involves loading, caching, and efficiently accessing graphics assets during frame rendering.\n\n| Resource Type | Storage Location | Access Pattern | Management Strategy |\n|---------------|------------------|----------------|-------------------|\n| **Texture Resources** | GPU VRAM | Random access by fragment shader | Handle-based with reference counting |\n| **Mesh Resources** | GPU vertex/index buffers | Sequential access during draw calls | Batch similar geometry together |\n| **Shader Resources** | GPU program memory | State changes between material types | Cache compiled programs, minimize switches |\n| **Framebuffer Resources** | GPU render targets | Write during rendering, read for effects | Double-buffering for temporal effects |\n\n### Physics and Collision Terminology\n\nPhysics simulation introduces terminology from mechanical engineering and computational geometry, adapted for real-time constraints and numerical stability requirements.\n\n| Term | Definition | Simulation Role | Numerical Considerations |\n|------|------------|-----------------|------------------------|\n| **Rigid Body** | Object with fixed shape that moves and rotates as unit | Primary physics entity with mass, velocity, acceleration | Assumes infinite stiffness for computational efficiency |\n| **Semi-Implicit Euler** | Integration method updating velocity first, then position | More stable than explicit Euler for stiff systems | Reduces energy accumulation in oscillating systems |\n| **Impulse Response** | Instantaneous velocity changes simulating collision forces | Handles collision resolution without force accumulation | Avoids integration instabilities from large forces |\n| **Position Correction** | Separating overlapping objects to prevent visual artifacts | Maintains non-penetration constraint after collision | Balances realism with numerical stability |\n| **Penetration Depth** | Distance two collision shapes have overlapped | Determines correction magnitude and impulse strength | Must handle floating-point precision limitations |\n| **Contact Manifold** | Set of contact points between colliding objects | Provides detailed collision geometry for response | More contacts improve stability but increase cost |\n\n**Collision Detection Pipeline** consists of multiple phases designed to efficiently identify and process object interactions in large game worlds.\n\n| Phase | Purpose | Algorithm | Performance Characteristics |\n|-------|---------|-----------|----------------------------|\n| **Broad Phase** | Identify potentially colliding object pairs | Spatial partitioning (grid, quadtree, sweep-and-prune) | Reduces O(n²) to O(n log n) complexity |\n| **Narrow Phase** | Precise geometric intersection testing | Shape-specific algorithms (AABB, circle, polygon) | O(1) per pair but expensive geometric operations |\n| **Collision Response** | Apply forces and position corrections | Impulse-based response with constraint solving | Must maintain energy conservation and stability |\n| **Contact Resolution** | Handle resting contact and friction | Iterative constraint solver or direct analytical solution | Balances realism with computational cost |\n\n**Spatial Partitioning Techniques** organize game world objects to accelerate collision detection and other spatial queries.\n\n| Technique | Structure | Best Use Cases | Performance Trade-offs |\n|-----------|-----------|----------------|----------------------|\n| **Uniform Grid** | Regular grid cells | Evenly distributed, similar-sized objects | Simple implementation, poor for clustered objects |\n| **Quadtree/Octree** | Hierarchical space subdivision | Uneven object distribution, large world spaces | Adaptive resolution, more complex traversal |\n| **Sweep and Prune** | Sorted interval lists | Many moving objects, coherent motion | Excellent temporal coherence, poor for teleporting |\n| **Hash Grid** | Hash table with spatial keys | Large worlds with sparse occupation | Constant-time insertion, potential hash collisions |\n\n### Resource and Asset Management Terminology\n\nResource management encompasses the loading, caching, and lifecycle management of game assets including textures, audio files, meshes, and scene data.\n\n| Term | Definition | Lifecycle Stage | Memory Management |\n|------|------------|-----------------|------------------|\n| **Resource Handle** | Indirect reference to loaded asset with validation | Provides stable reference across resource reloading | Prevents dangling pointers and use-after-free |\n| **Reference Counting** | Automatic cleanup based on usage tracking | Determines when resources can be safely unloaded | Shared ownership model with circular reference prevention |\n| **Asynchronous Loading** | Background file loading without blocking main thread | Improves responsiveness during asset streaming | Requires thread-safe completion notification |\n| **Resource Manifest** | List of all assets required by scene or level | Enables predictive loading and dependency resolution | Prevents missing asset errors at runtime |\n| **Hot Reloading** | Replace assets while application is running | Development feature for rapid iteration | Requires handle indirection and asset versioning |\n| **Asset Streaming** | Load/unload resources based on player proximity | Manages memory usage in large game worlds | Complex prediction and prioritization algorithms |\n\n**Asset Loading Pipeline** transforms raw file data into GPU-ready resources through multiple processing stages.\n\n| Stage | Input Format | Processing | Output Format | Error Handling |\n|-------|--------------|------------|---------------|----------------|\n| **File Loading** | Raw bytes from disk | I/O operations, compression | Memory buffer | File not found, corruption detection |\n| **Format Parsing** | Raw file data | PNG/JPG/OBJ decoding | Structured data | Invalid format, version mismatch |\n| **GPU Upload** | CPU asset data | Texture/buffer creation | GPU resources | Out of memory, driver failures |\n| **Handle Creation** | GPU resource IDs | Indirection table entry | Validated handle | Resource limit exhaustion |\n\n**Resource Caching Strategies** balance memory usage with access performance by maintaining frequently-used assets in fast storage.\n\n| Strategy | Cache Policy | Eviction Algorithm | Use Cases |\n|----------|--------------|-------------------|-----------|\n| **LRU (Least Recently Used)** | Replace oldest accessed items | Track access timestamps | General-purpose caching |\n| **Reference Counting** | Keep while in use, discard when unused | Automatic based on handle lifetime | Predictable memory management |\n| **Priority-Based** | Assign importance scores to resources | Evict lowest priority items first | Performance-critical assets |\n| **Spatial Locality** | Cache based on world position | Predict based on player movement | Open world streaming |\n\n### Memory Management and Performance Terminology\n\nGame engines require sophisticated memory management strategies to maintain consistent performance under real-time constraints.\n\n| Term | Definition | Performance Impact | Implementation Strategy |\n|------|------------|-------------------|------------------------|\n| **Memory Pool** | Pre-allocated memory blocks for frequent allocations | Eliminates allocation overhead and fragmentation | Fixed-size blocks for specific object types |\n| **Object Pooling** | Reuse objects instead of allocation/deallocation | Reduces garbage collection pressure | Maintain free lists of reusable objects |\n| **Cache Line** | Unit of data transfer between main memory and CPU cache (typically 64 bytes) | Determines memory access efficiency | Align frequently accessed data to cache boundaries |\n| **False Sharing** | Cache line conflicts in multi-threaded access | Degrades performance in parallel systems | Separate frequently modified data by cache line size |\n| **Memory Alignment** | Positioning data at specific byte boundaries | Enables SIMD instructions and reduces access cost | Use compiler attributes or manual padding |\n| **Garbage Collection** | Automatic cleanup of unused resources | Can cause frame rate stutters if not managed | Use reference counting or manual lifetime management |\n\n**Performance Profiling Terminology** helps identify and resolve performance bottlenecks in game engine systems.\n\n| Metric | Measurement | Interpretation | Optimization Target |\n|--------|-------------|----------------|-------------------|\n| **Frame Time** | Milliseconds per frame | Must stay under 16.67ms for 60fps | Identify bottleneck systems |\n| **Draw Calls** | GPU rendering commands per frame | Each call has overhead, minimize count | Batch rendering optimization |\n| **Cache Misses** | CPU cache access failures | Indicates poor data locality | Memory layout optimization |\n| **Context Switches** | Thread scheduling changes | High count indicates contention | Reduce thread synchronization |\n| **Memory Bandwidth** | Bytes transferred per second | Bottleneck for large data sets | Data structure optimization |\n| **Instruction Cache Misses** | CPU instruction fetch failures | Indicates code size or branching issues | Code organization and size |\n\n### Debugging and Development Terminology\n\nGame engine development requires specialized debugging techniques due to real-time constraints and complex system interactions.\n\n| Term | Definition | Use Case | Implementation |\n|------|------------|----------|----------------|\n| **Graphics Debugger** | Tool for capturing and analyzing GPU rendering commands | Debug rendering issues, optimize draw calls | RenderDoc, Nsight Graphics, Intel GPA |\n| **Memory Leak Detection** | Tracking allocations without corresponding deallocations | Prevent gradual memory exhaustion | Custom allocators with tracking |\n| **Assertion Macros** | Debug-only checks that crash on invalid conditions | Catch programming errors during development | Compile out in release builds |\n| **Performance Profiler** | Tool measuring execution time and resource usage | Identify performance bottlenecks | Intel VTune, AMD CodeXL, custom timers |\n| **Hot Code Paths** | Frequently executed code sections | Focus optimization efforts on high-impact areas | Profile-guided optimization |\n| **Instrumentation** | Adding measurement code to track system behavior | Gather performance data and usage patterns | Minimal overhead monitoring |\n\n**Common Debugging Scenarios** in game engine development often involve system interactions that are difficult to isolate and reproduce.\n\n| Problem Type | Symptoms | Investigation Approach | Common Causes |\n|--------------|----------|------------------------|---------------|\n| **Rendering Issues** | Black screen, incorrect graphics | Graphics debugger, shader validation | Context loss, state leaks, uniform errors |\n| **Physics Instability** | Objects jittering or flying apart | Energy monitoring, collision visualization | Timestep issues, penetration resolution |\n| **Memory Corruption** | Random crashes, data anomalies | Memory debuggers, bounds checking | Buffer overflows, use-after-free |\n| **Performance Regression** | Frame rate drops, stuttering | Profiling comparison, system timing | Algorithm complexity, cache misses |\n| **Race Conditions** | Intermittent failures, data corruption | Thread synchronization analysis | Shared data access, missing locks |\n\n### Advanced Architecture Patterns\n\nAdvanced game engine development introduces sophisticated architectural patterns that address scalability, maintainability, and performance challenges in large systems.\n\n| Pattern | Purpose | Implementation Complexity | Benefits |\n|---------|---------|-------------------------|----------|\n| **Job System** | Parallel work distribution across CPU cores | High - requires work stealing queues | Maximizes CPU utilization |\n| **Entity Queries** | Efficient selection of entities matching component criteria | Medium - requires archetype optimization | Fast system iteration |\n| **Event Systems** | Decoupled communication between engine subsystems | Medium - callback management | Loose coupling, extensibility |\n| **Command Buffers** | Deferred execution of rendering or logic operations | Medium - requires serialization | Thread safety, batching |\n| **Dependency Injection** | Providing system dependencies through interfaces | Low to Medium | Testability, modularity |\n| **State Machines** | Formal state management for complex game logic | Medium - state transition validation | Predictable behavior |\n\n**Concurrent Programming Patterns** address the challenges of multi-threaded game engine development while maintaining performance and correctness.\n\n| Pattern | Thread Safety | Performance Impact | Complexity |\n|---------|---------------|-------------------|------------|\n| **Lock-Free Queues** | Atomic operations without mutex locking | High performance, but complex | High implementation complexity |\n| **Reader-Writer Locks** | Multiple readers, exclusive writers | Good for read-heavy workloads | Medium complexity, potential deadlocks |\n| **Thread-Local Storage** | Per-thread data to avoid synchronization | Excellent performance | Low complexity, memory overhead |\n| **Work Stealing** | Distribute work dynamically between threads | Excellent load balancing | High implementation complexity |\n| **Message Passing** | Thread communication through queues | Eliminates shared state issues | Medium complexity, copying overhead |\n\n### Implementation Guidance\n\nGame engine terminology spans multiple specialized domains, and understanding these concepts requires both theoretical knowledge and practical experience with real implementations. The following guidance helps translate terminology into working code.\n\n#### Technology Recommendations\n\n| Component | Simple Approach | Advanced Approach |\n|-----------|-----------------|------------------|\n| Terminology Management | Static header file with constants | Dynamic string table with validation |\n| Documentation | Inline comments with examples | Generated documentation system |\n| API Consistency | Naming convention guidelines | Automated style checking |\n| Type Safety | Strong typing with distinct types | Template-based type system |\n\n#### Recommended File Organization\n\n```cpp\n// engine/include/terminology.h - Central terminology definitions\nnamespace Engine {\n    // Entity Component System terminology\n    using EntityID = uint32_t;\n    using ComponentTypeID = uint16_t;\n    using ArchetypeID = uint32_t;\n    \n    // Resource management terminology  \n    template<typename T>\n    class Handle;\n    using TextureHandle = Handle<TextureResource>;\n    using MeshHandle = Handle<MeshResource>;\n    \n    // Physics simulation terminology\n    struct RigidBody;\n    struct CollisionPair;\n    \n    // Rendering pipeline terminology\n    struct SpriteRenderData;\n    class BatchRenderer;\n}\n\n// engine/include/constants.h - Named constants\nnamespace Engine::Constants {\n    constexpr float TARGET_FPS = 60.0f;\n    constexpr uint32_t MAX_ENTITIES = 4194304;\n    constexpr float PHYSICS_TIMESTEP = 1.0f / 60.0f;\n    constexpr uint32_t MAX_SPRITES_PER_BATCH = 1000;\n}\n\n// engine/include/enums.h - Engine enumerations\nnamespace Engine {\n    enum class ResourceType : uint16_t {\n        Texture = 1,\n        Mesh = 2,\n        Audio = 3,\n        Scene = 4\n    };\n    \n    enum class ComponentStorageType {\n        Dense,\n        Sparse,\n        Hybrid\n    };\n}\n```\n\n#### Core Type Definitions\n\n```cpp\n// Entity identification with generation counter\nstruct Entity {\n    uint32_t m_id;\n    \n    uint32_t GetIndex() const { \n        return m_id & ((1 << INDEX_BITS) - 1); \n    }\n    \n    uint32_t GetGeneration() const { \n        return (m_id >> INDEX_BITS) & ((1 << GENERATION_BITS) - 1); \n    }\n    \n    bool operator==(const Entity& other) const { \n        return m_id == other.m_id; \n    }\n};\n\n// Resource handle with type safety and validation\ntemplate<typename ResourceType>\nclass Handle {\nprivate:\n    uint64_t m_handle;\n    \npublic:\n    Handle() : m_handle(NULL_HANDLE) {}\n    explicit Handle(uint64_t handle) : m_handle(handle) {}\n    \n    uint32_t GetID() const { \n        return static_cast<uint32_t>(m_handle & ID_MASK); \n    }\n    \n    uint16_t GetVersion() const { \n        return static_cast<uint16_t>((m_handle >> VERSION_SHIFT) & VERSION_MASK); \n    }\n    \n    uint16_t GetType() const { \n        return static_cast<uint16_t>((m_handle >> TYPE_SHIFT) & TYPE_MASK); \n    }\n    \n    bool IsValid() const { \n        return m_handle != NULL_HANDLE; \n    }\n};\n\n// Component storage interface for different strategies\ntemplate<typename ComponentType>\nclass ComponentStorage {\npublic:\n    virtual ~ComponentStorage() = default;\n    virtual ComponentType* AddComponent(Entity entity, const ComponentType& component) = 0;\n    virtual bool RemoveComponent(Entity entity) = 0;\n    virtual ComponentType* GetComponent(Entity entity) = 0;\n    virtual bool HasComponent(Entity entity) const = 0;\n    virtual void ForEach(std::function<void(Entity, ComponentType&)> callback) = 0;\n};\n```\n\n#### Terminology Validation System\n\n```cpp\n// Development-time terminology validation\nclass TerminologyValidator {\nprivate:\n    std::unordered_set<std::string> m_validTerms;\n    std::unordered_map<std::string, std::string> m_termDefinitions;\n    \npublic:\n    TerminologyValidator() {\n        // TODO: Load terminology from configuration\n        RegisterTerm(\"entity\", \"Unique identifier for game object\");\n        RegisterTerm(\"component\", \"Data container attached to entity\");\n        RegisterTerm(\"system\", \"Logic processor for component data\");\n        // ... register all engine terms\n    }\n    \n    void RegisterTerm(const std::string& term, const std::string& definition) {\n        m_validTerms.insert(term);\n        m_termDefinitions[term] = definition;\n    }\n    \n    bool ValidateCodebase(const std::string& sourceDirectory) {\n        // TODO: Scan source files for terminology usage\n        // TODO: Report inconsistencies and unknown terms\n        // TODO: Generate terminology usage report\n        return true;\n    }\n    \n    std::string GetDefinition(const std::string& term) const {\n        auto it = m_termDefinitions.find(term);\n        return (it != m_termDefinitions.end()) ? it->second : \"Unknown term\";\n    }\n};\n```\n\n#### Documentation Generation\n\n```cpp\n// Automatic documentation generation from terminology\nclass DocumentationGenerator {\nprivate:\n    std::vector<std::pair<std::string, std::string>> m_glossaryEntries;\n    \npublic:\n    void AddGlossaryEntry(const std::string& term, const std::string& definition) {\n        m_glossaryEntries.emplace_back(term, definition);\n    }\n    \n    void GenerateMarkdownGlossary(const std::string& outputPath) {\n        std::ofstream file(outputPath);\n        file << \"# Engine Terminology\\n\\n\";\n        \n        // Sort entries alphabetically\n        std::sort(m_glossaryEntries.begin(), m_glossaryEntries.end());\n        \n        for (const auto& [term, definition] : m_glossaryEntries) {\n            file << \"## \" << term << \"\\n\\n\";\n            file << definition << \"\\n\\n\";\n        }\n    }\n    \n    void GenerateCodeDocumentation(const std::string& outputPath) {\n        // TODO: Generate API documentation with terminology links\n        // TODO: Cross-reference terminology usage in code\n        // TODO: Validate that all public APIs use consistent terminology\n    }\n};\n```\n\n#### Development Workflow Integration\n\n```cpp\n// Integration with development tools for terminology consistency\nclass TerminologyIntegration {\npublic:\n    // Validate pull requests for terminology consistency\n    static bool ValidatePullRequest(const std::string& diffContent) {\n        // TODO: Parse code changes\n        // TODO: Check new terminology against approved glossary\n        // TODO: Report terminology violations\n        return true;\n    }\n    \n    // Generate IDE autocomplete for engine terminology  \n    static void GenerateIDEConfig(const std::string& outputPath) {\n        // TODO: Export terminology as IDE snippets\n        // TODO: Generate code completion databases\n        // TODO: Create terminology-aware refactoring rules\n    }\n    \n    // Validate API naming consistency\n    static std::vector<std::string> ValidateAPINaming() {\n        std::vector<std::string> violations;\n        // TODO: Check that public APIs follow terminology conventions\n        // TODO: Verify consistent naming patterns\n        // TODO: Report deviations from established patterns\n        return violations;\n    }\n};\n```\n\n#### Milestone Checkpoints\n\n**Milestone 1 Terminology Validation:**\n- Verify consistent use of rendering terminology in graphics code\n- Validate that all shader variables use established naming conventions\n- Confirm that window and context management uses standard terms\n\n**Milestone 2 Terminology Validation:**\n- Check ECS terminology consistency across entity, component, and system code\n- Validate that component storage terminology matches implementation\n- Verify system execution terminology aligns with architectural decisions\n\n**Milestone 3 Terminology Validation:**  \n- Confirm physics terminology matches simulation approach\n- Validate collision detection terminology in broad/narrow phase code\n- Check that spatial partitioning uses consistent terminology\n\n**Milestone 4 Terminology Validation:**\n- Verify resource management terminology in loading and caching systems\n- Validate scene serialization terminology matches data structures\n- Check that asset pipeline terminology aligns with implementation\n\n#### Common Implementation Pitfalls\n\n⚠️ **Pitfall: Inconsistent Terminology Usage**\nMany developers introduce their own terms or use established terms incorrectly, creating confusion and maintenance difficulties. For example, using \"GameObject\" instead of \"Entity\" or \"Mesh\" instead of \"RigidBody\" for physics objects breaks the established terminology patterns and makes code harder to understand.\n\n**Solution:** Establish terminology early in development and enforce it through code reviews and automated validation. Create a central header file with type aliases that enforce consistent naming throughout the codebase.\n\n⚠️ **Pitfall: Terminology Drift Over Time**\nAs projects evolve, terminology can gradually drift from original definitions, leading to confusion between team members and inconsistent API design. This often happens when new features are added without considering existing terminology patterns.\n\n**Solution:** Regular terminology audits during development milestones, automated checking for consistency, and maintaining a living glossary document that evolves with the project while preserving established patterns.\n"}