{"html":"<h1 id=\"build-your-own-graphql-engine-design-document\">Build Your Own GraphQL Engine: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system builds a complete GraphQL execution engine that can parse GraphQL queries, reflect database schemas automatically, and compile queries to efficient SQL. The key architectural challenge is bridging the conceptual gap between GraphQL&#39;s hierarchical query model and relational databases&#39; tabular structure while maintaining performance and type safety.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides foundational context for all milestones, establishing the problem domain and mental models that will guide the entire project.</p>\n</blockquote>\n<p>GraphQL has revolutionized API development by providing a declarative, client-driven query language that enables applications to request exactly the data they need. However, building a robust GraphQL execution engine—particularly one that efficiently bridges GraphQL queries to relational databases—is a complex undertaking requiring expertise across parsing, type systems, query execution, database introspection, and query compilation. This project addresses the educational gap between using GraphQL libraries and understanding their internals by building a complete, simplified GraphQL engine from the ground up.</p>\n<h3 id=\"mental-model-restaurant-menu-vs-kitchen\">Mental Model: Restaurant Menu vs. Kitchen</h3>\n<p>Imagine a restaurant with two distinct spaces: the <strong>dining room</strong> where customers order from a menu, and the <strong>kitchen</strong> where chefs prepare meals. This analogy perfectly captures the GraphQL engine architecture:</p>\n<ul>\n<li><p><strong>GraphQL Query = Customer Order</strong>: The customer (client) selects specific items from the menu (GraphQL schema) in a particular combination. They don&#39;t specify <em>how</em> the food should be prepared—just what they want in the final result. A GraphQL query similarly declares what data is needed without specifying how to fetch it from the database.</p>\n</li>\n<li><p><strong>GraphQL Schema = Restaurant Menu</strong>: The menu defines all possible dishes (types) and their available customizations (fields with arguments). Some dishes require special preparation (resolvers), while others are simple combinations of existing items. The menu&#39;s structure determines what combinations are valid (type validation).</p>\n</li>\n<li><p><strong>GraphQL Engine = Kitchen System</strong>: The kitchen receives the order and must:</p>\n<ol>\n<li><strong>Parse the order</strong> (Parser) - Understand exactly which dishes and modifications were requested</li>\n<li><strong>Check inventory</strong> (Type System) - Verify all ingredients (data types) are available and compatible</li>\n<li><strong>Plan preparation</strong> (Execution Engine) - Determine the optimal sequence of cooking steps (resolvers)</li>\n<li><strong>Gather ingredients</strong> (Schema Reflection) - Auto-discover what&#39;s in the pantry (database schema)</li>\n<li><strong>Cook efficiently</strong> (SQL Compilation) - Combine preparation steps to avoid redundant work (N+1 problem)</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p><strong>Key Insight:</strong> Just as a skilled kitchen can prepare multiple parts of an order in parallel (appetizers while entrees cook) and combine similar preparation steps (chopping all vegetables at once), a good GraphQL engine executes independent fields concurrently and batches related database operations.</p>\n</blockquote>\n<h3 id=\"the-graphql-database-translation-problem\">The GraphQL-Database Translation Problem</h3>\n<p>The fundamental challenge in building a GraphQL engine lies in the <strong>impedance mismatch</strong> between GraphQL&#39;s hierarchical, graph-based query model and relational databases&#39; tabular, set-based structure. This mismatch creates several specific technical challenges:</p>\n<table>\n<thead>\n<tr>\n<th>Challenge</th>\n<th>GraphQL Perspective</th>\n<th>Relational Database Perspective</th>\n<th>Technical Consequence</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Data Shape</strong></td>\n<td>Nested objects with arbitrary depth</td>\n<td>Flat tables with foreign key relationships</td>\n<td>Requires JOINs or multiple queries to reconstruct hierarchy</td>\n</tr>\n<tr>\n<td><strong>Field Selection</strong></td>\n<td>Client selects exact fields needed</td>\n<td>SQL <code>SELECT *</code> fetches all columns</td>\n<td>Must generate SQL with only requested columns to avoid over-fetching</td>\n</tr>\n<tr>\n<td><strong>Nullability</strong></td>\n<td>Explicit non-null (<code>!</code>) types with propagation rules</td>\n<td>NULL-able columns with three-valued logic</td>\n<td>Must enforce GraphQL&#39;s strict null propagation, which differs from SQL semantics</td>\n</tr>\n<tr>\n<td><strong>Type System</strong></td>\n<td>Strong, static types with interfaces and unions</td>\n<td>Primitive types with constraints and referential integrity</td>\n<td>Requires mapping SQL types to GraphQL scalars and enforcing type safety</td>\n</tr>\n<tr>\n<td><strong>Query Structure</strong></td>\n<td>Recursive selection sets with fragments</td>\n<td>Linear SQL statements with fixed structure</td>\n<td>Must flatten nested selections into SQL JOIN hierarchy</td>\n</tr>\n</tbody></table>\n<h4 id=\"concrete-example-the-n1-query-problem\">Concrete Example: The N+1 Query Problem</h4>\n<p>Consider a simple GraphQL query fetching blog posts with their authors:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">graphql</span><pre class=\"arch-pre shiki-highlighted\"><code>query {\n  posts {\n    title\n    content\n    author {\n      name\n      email\n    }\n  }\n}</code></pre></div>\n\n<p>A naive implementation might execute:</p>\n<ol>\n<li><code>SELECT id, title, content, author_id FROM posts</code> (1 query)</li>\n<li>For each post: <code>SELECT name, email FROM authors WHERE id = ?</code> (N queries)</li>\n</ol>\n<p>This results in <strong>N+1 queries</strong> (1 for posts, N for authors). The engine must instead generate:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">title</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">content</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">authors</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">authors</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">email</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> posts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">LEFT JOIN</span><span style=\"color:#E1E4E8\"> authors </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">author_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> authors</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span></span></code></pre></div>\n\n<p>But this becomes more complex with one-to-many relationships (comments on posts) requiring lateral joins or separate batched queries. The translation problem involves:</p>\n<ul>\n<li>Analyzing the GraphQL AST to understand relationship patterns</li>\n<li>Generating optimal SQL JOIN structures</li>\n<li>Batching independent lookups using IN clauses</li>\n<li>Maintaining type safety and nullability semantics</li>\n</ul>\n<h4 id=\"architecture-decision-translation-strategy\">Architecture Decision: Translation Strategy</h4>\n<blockquote>\n<p><strong>Decision: AST-to-SQL Direct Compilation</strong></p>\n</blockquote>\n<ul>\n<li><strong>Context</strong>: We need to translate GraphQL queries to database queries with minimal overhead. Three main approaches exist: resolver-per-field (naive N+1), batched resolvers with DataLoader, or direct AST-to-SQL compilation.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Resolver-per-field</strong>: Each field has a resolver function; simple but leads to N+1 queries</li>\n<li><strong>DataLoader pattern</strong>: Resolvers request data, DataLoader batches similar requests; good for caching but adds abstraction layer</li>\n<li><strong>Direct AST-to-SQL compilation</strong>: Analyze the entire query, generate optimized SQL; complex but maximum performance</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Direct AST-to-SQL compilation for the core engine, with optional DataLoader for custom resolvers</li>\n<li><strong>Rationale</strong>: <ul>\n<li>Educational value: Compilation demonstrates query optimization principles clearly</li>\n<li>Performance: Single optimized SQL query minimizes round-trips</li>\n<li>Predictability: Deterministic SQL generation easier to debug than distributed resolver timing</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Must implement full query analysis and SQL generation</li>\n<li>Less flexible for custom business logic in resolvers</li>\n<li>Better for database-heavy applications, worse for microservice aggregation</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Resolver-per-field</td>\n<td>Simple to implement, flexible for custom logic</td>\n<td>Severe N+1 problem, poor performance</td>\n<td>Rejected for core engine (educational anti-pattern)</td>\n</tr>\n<tr>\n<td>DataLoader pattern</td>\n<td>Good for microservices, handles caching</td>\n<td>Added complexity, still multiple queries</td>\n<td>Supplemental pattern for custom resolvers</td>\n</tr>\n<tr>\n<td>Direct compilation</td>\n<td>Maximum performance, single query, deterministic</td>\n<td>Complex implementation, less flexible</td>\n<td><strong>Primary approach</strong> - best for learning and performance</td>\n</tr>\n</tbody></table>\n<h3 id=\"existing-solutions-comparison\">Existing Solutions Comparison</h3>\n<p>Several production GraphQL engines address the database translation problem with different architectures and trade-offs. Understanding these helps clarify our design choices and educational objectives.</p>\n<h4 id=\"hasura-declarative-configuration-engine\">Hasura: Declarative Configuration Engine</h4>\n<p>Hasura takes a <strong>declarative, metadata-driven approach</strong>:</p>\n<ul>\n<li><strong>Architecture</strong>: PostgreSQL-focused, generates GraphQL schema from database metadata with fine-grained permissions</li>\n<li><strong>Translation Strategy</strong>: AST-to-SQL compilation with extensive optimizations (predicate pushdown, join elimination)</li>\n<li><strong>Strengths</strong>: <ul>\n<li>Excellent performance through query compilation</li>\n<li>Real-time subscriptions via PostgreSQL LISTEN/NOTIFY</li>\n<li>Rich permission system declaratively configured</li>\n</ul>\n</li>\n<li><strong>Limitations</strong>:<ul>\n<li>Primarily PostgreSQL-only (though expanding)</li>\n<li>Limited custom business logic without external services</li>\n<li>Opinionated schema generation</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- Hasura internally generates SQL like this from GraphQL:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> json_agg(__root) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  SELECT</span><span style=\"color:#E1E4E8\"> json_build_object(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'id'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'title'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">title</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'author'</span><span style=\"color:#E1E4E8\">, author_obj</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ) </span><span style=\"color:#F97583\">AS</span><span style=\"color:#E1E4E8\"> __root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  FROM</span><span style=\"color:#E1E4E8\"> posts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  LEFT JOIN</span><span style=\"color:#E1E4E8\"> LATERAL (</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    SELECT</span><span style=\"color:#E1E4E8\"> json_build_object(</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">authors</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">AS</span><span style=\"color:#E1E4E8\"> author_obj</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    FROM</span><span style=\"color:#E1E4E8\"> authors </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> authors</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">author_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ) </span><span style=\"color:#F97583\">ON</span><span style=\"color:#E1E4E8\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">AS</span><span style=\"color:#E1E4E8\"> __root</span></span></code></pre></div>\n\n<h4 id=\"postgraphile-reflection-driven-with-plugins\">PostGraphile: Reflection-Driven with Plugins</h4>\n<p>PostGraphile uses <strong>PostgreSQL reflection and convention-over-configuration</strong>:</p>\n<ul>\n<li><strong>Architecture</strong>: Reflects database schema, uses PostgreSQL comments for metadata, plugin system for extensibility</li>\n<li><strong>Translation Strategy</strong>: Smart defaults with plugin-based query building</li>\n<li><strong>Strengths</strong>:<ul>\n<li>Extremely fast schema generation from existing databases</li>\n<li>Customizable via plugin ecosystem</li>\n<li>Leverages PostgreSQL features (ROW SECURITY, etc.)</li>\n</ul>\n</li>\n<li><strong>Limitations</strong>:<ul>\n<li>PostgreSQL-specific</li>\n<li>Learning curve for customization</li>\n<li>Less control over exact GraphQL schema shape</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"custom-implementation-apollographql-js\">Custom Implementation (Apollo/GraphQL-JS)</h4>\n<p>The <strong>resolver-based approach</strong> used by most custom GraphQL servers:</p>\n<ul>\n<li><strong>Architecture</strong>: Manual schema definition, resolver functions for each field</li>\n<li><strong>Translation Strategy</strong>: Manual ORM/query calls within resolvers, DataLoader for batching</li>\n<li><strong>Strengths</strong>:<ul>\n<li>Complete control over business logic</li>\n<li>Database-agnostic (works with any data source)</li>\n<li>Mature ecosystem (Apollo, GraphQL-JS)</li>\n</ul>\n</li>\n<li><strong>Limitations</strong>:<ul>\n<li>Manual N+1 optimization required</li>\n<li>Boilerplate code for common patterns</li>\n<li>Performance depends on developer discipline</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"our-educational-approach\">Our Educational Approach</h4>\n<p>Our engine borrows concepts from all three but prioritizes <strong>educational transparency</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Hasura (Production)</th>\n<th>PostGraphile (Production)</th>\n<th>Custom (Typical)</th>\n<th>Our Engine (Educational)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Schema Generation</strong></td>\n<td>Metadata-driven</td>\n<td>Reflection + conventions</td>\n<td>Manual definition</td>\n<td><strong>Reflection + explicit mapping</strong></td>\n</tr>\n<tr>\n<td><strong>Query Translation</strong></td>\n<td>AST-to-SQL compiler</td>\n<td>Plugin-based compilation</td>\n<td>Resolver functions</td>\n<td><strong>AST-to-SQL with visible steps</strong></td>\n</tr>\n<tr>\n<td><strong>Performance Focus</strong></td>\n<td>Maximum optimization</td>\n<td>Good defaults with plugins</td>\n<td>Developer-dependent</td>\n<td><strong>Optimized but transparent</strong></td>\n</tr>\n<tr>\n<td><strong>Learning Value</strong></td>\n<td>Black box</td>\n<td>Convention magic</td>\n<td>Business logic focus</td>\n<td><strong>White box with clear algorithms</strong></td>\n</tr>\n<tr>\n<td><strong>Database Support</strong></td>\n<td>PostgreSQL-first</td>\n<td>PostgreSQL-only</td>\n<td>Any</td>\n<td><strong>Adapter pattern with reference impl</strong></td>\n</tr>\n<tr>\n<td><strong>Custom Logic</strong></td>\n<td>Remote schemas/actions</td>\n<td>Plugin system</td>\n<td>First-class</td>\n<td><strong>Hybrid: compiled + resolver fallback</strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Philosophy</strong>: Our engine makes compilation steps explicit—learners can trace a GraphQL query through parsing, type checking, AST analysis, JOIN generation, and SQL parameterization. Where Hasura hides complexity for production simplicity, we expose it for learning.</p>\n</blockquote>\n<h4 id=\"why-build-from-scratch\">Why Build From Scratch?</h4>\n<p>Existing solutions work well for production but obscure the underlying mechanics:</p>\n<ol>\n<li><strong>Abstraction Layers Hide Fundamentals</strong>: Tools like Hasura generate SQL automatically, but developers don&#39;t learn <em>how</em> the translation works</li>\n<li><strong>Missing Mental Models</strong>: Without understanding the compilation pipeline, debugging performance issues becomes guesswork</li>\n<li><strong>Educational Gap</strong>: Tutorials focus on using GraphQL, not implementing execution engines</li>\n<li><strong>Customization Limitations</strong>: When existing tools don&#39;t fit a use case, developers lack the foundation to build their own solutions</li>\n</ol>\n<p>This project fills that gap by building a <strong>pedagogical reference implementation</strong> that:</p>\n<ul>\n<li>Shows each transformation step explicitly</li>\n<li>Provides extensibility points learners can modify</li>\n<li>Includes common pitfalls and debugging guidance</li>\n<li>Balances simplicity with real-world concerns</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Note</strong>: This section provides initial setup and mental model implementation. The detailed component implementations will follow in subsequent sections.</p>\n</blockquote>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Why for This Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Language</strong></td>\n<td>Python 3.9+</td>\n<td>Rust or Go</td>\n<td>Python chosen for readability and educational accessibility</td>\n</tr>\n<tr>\n<td><strong>HTTP Server</strong></td>\n<td>Flask (synchronous)</td>\n<td>FastAPI (async)</td>\n<td>Flask&#39;s simplicity reduces cognitive load for learning core concepts</td>\n</tr>\n<tr>\n<td><strong>Database</strong></td>\n<td>SQLite (file-based)</td>\n<td>PostgreSQL (production)</td>\n<td>SQLite requires no setup, focuses on SQL generation not connection management</td>\n</tr>\n<tr>\n<td><strong>SQL Building</strong></td>\n<td>String concatenation</td>\n<td>SQLAlchemy Core</td>\n<td>Starting with strings shows the raw SQL; can evolve to builder pattern</td>\n</tr>\n<tr>\n<td><strong>Testing</strong></td>\n<td>unittest/pytest</td>\n<td>pytest with async</td>\n<td>unittest is standard library, sufficient for learning</td>\n</tr>\n<tr>\n<td><strong>Type Hints</strong></td>\n<td>Basic type hints</td>\n<td>mypy strict</td>\n<td>Type hints improve readability without complexity</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Create this directory structure from the beginning to maintain separation of concerns:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql-engine/\n├── README.md\n├── pyproject.toml           # Python project configuration\n├── requirements.txt         # Dependencies\n├── src/\n│   ├── graphql_engine/\n│   │   ├── __init__.py\n│   │   ├── main.py          # HTTP server entry point\n│   │   ├── parser/          # Milestone 1\n│   │   │   ├── __init__.py\n│   │   │   ├── lexer.py     # Tokenizer\n│   │   │   ├── parser.py    # Recursive descent parser\n│   │   │   └── ast.py       # AST node definitions\n│   │   ├── type_system/     # Milestone 2\n│   │   │   ├── __init__.py\n│   │   │   ├── types.py     # GraphQL type classes\n│   │   │   ├── schema.py    # Schema construction/validation\n│   │   │   └── introspection.py\n│   │   ├── execution/       # Milestone 3\n│   │   │   ├── __init__.py\n│   │   │   ├── executor.py  # Query execution engine\n│   │   │   ├── resolvers.py # Default resolver logic\n│   │   │   └── dataloader.py# DataLoader implementation\n│   │   ├── reflection/      # Milestone 4\n│   │   │   ├── __init__.py\n│   │   │   ├── reflector.py # Database schema reflection\n│   │   │   ├── sql_types.py # SQL-to-GraphQL type mapping\n│   │   │   └── relationships.py\n│   │   ├── compilation/     # Milestone 5\n│   │   │   ├── __init__.py\n│   │   │   ├── compiler.py  # AST-to-SQL compiler\n│   │   │   ├── sql_builder.py\n│   │   │   └── query_plan.py\n│   │   └── utils/\n│   │       ├── __init__.py\n│   │       ├── errors.py    # Custom exception classes\n│   │       └── logging.py   # Debug logging helpers\n└── tests/\n    ├── __init__.py\n    ├── test_parser.py\n    ├── test_type_system.py\n    ├── test_execution.py\n    ├── test_reflection.py\n    └── test_compilation.py</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Create a simple HTTP server that will accept GraphQL queries. This isn&#39;t the learning focus but is necessary to test the engine:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/graphql_engine/main.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Simple HTTP server for the GraphQL engine.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This provides a test harness - the real learning is in the components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> flask </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Flask, request, jsonify</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">app </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Flask(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># These will be implemented in later milestones</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.type_system </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLSchema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.execution </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> execute_query</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In-memory schema cache (will be populated via reflection)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">schema_cache: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLSchema] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@app.route</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'/graphql'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">methods</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#9ECBFF\">'POST'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> graphql_endpoint</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Standard GraphQL HTTP endpoint.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Expects JSON with 'query' and optionally 'variables', 'operationName'.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.get_json()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> data </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> 'query'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> data:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> jsonify({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'errors'</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Must provide query parameter'</span><span style=\"color:#E1E4E8\">}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }), </span><span style=\"color:#79B8FF\">400</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data[</span><span style=\"color:#9ECBFF\">'query'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        variables </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data.get(</span><span style=\"color:#9ECBFF\">'variables'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operation_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data.get(</span><span style=\"color:#9ECBFF\">'operationName'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: In Milestone 4, this will reflect the database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For now, use a placeholder schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> 'default'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> schema_cache:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            schema_cache[</span><span style=\"color:#9ECBFF\">'default'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> GraphQLSchema()  </span><span style=\"color:#6A737D\"># Will be populated later</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> schema_cache[</span><span style=\"color:#9ECBFF\">'default'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Parse the query (Milestone 1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        document_ast </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_query(query)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Execute the query (Milestone 3)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> execute_query(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            schema</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">schema,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            document_ast</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">document_ast,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            variable_values</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">variables,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            operation_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">operation_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> jsonify(result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Better error formatting based on error type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        app.logger.exception(</span><span style=\"color:#9ECBFF\">\"GraphQL execution error\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> jsonify({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'errors'</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(e)}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }), </span><span style=\"color:#79B8FF\">500</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@app.route</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'/health'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> health_check</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Simple health endpoint for deployment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> jsonify({</span><span style=\"color:#9ECBFF\">'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'healthy'</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> '__main__'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    app.run(</span><span style=\"color:#FFAB70\">debug</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5000</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>Here&#39;s the initial AST structure that will be used throughout the engine. Learners will expand this in Milestone 1:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/graphql_engine/parser/ast.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Abstract Syntax Tree node definitions for GraphQL.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">These data structures represent parsed GraphQL queries.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any, Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Location</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Source location for error reporting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, column </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.column</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Node</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all AST nodes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loc: Optional[Location] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Source location (optional in some cases)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Document</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Root node representing a complete GraphQL document.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    definitions: List[</span><span style=\"color:#9ECBFF\">'Definition'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Definition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base for definitions (operations, fragments).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OperationDefinition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Definition</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"An operation (query, mutation, subscription).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # 'query', 'mutation', 'subscription'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variable_definitions: List[</span><span style=\"color:#9ECBFF\">'VariableDefinition'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives: List[</span><span style=\"color:#9ECBFF\">'Directive'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selection_set: </span><span style=\"color:#9ECBFF\">'SelectionSet'</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Will be set during parsing</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SelectionSet</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A set of selections (fields, fragment spreads).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selections: List[</span><span style=\"color:#9ECBFF\">'Selection'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Selection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base for selections within a selection set.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Field</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Selection</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A field selection within a selection set.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alias: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    arguments: List[</span><span style=\"color:#9ECBFF\">'Argument'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives: List[</span><span style=\"color:#9ECBFF\">'Directive'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selection_set: Optional[SelectionSet] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # None for scalar fields</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add remaining AST node classes:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - FragmentDefinition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - FragmentSpread  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - InlineFragment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - VariableDefinition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Directive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Value nodes (IntValue, StringValue, Variable, etc.)</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><strong>Python Type Hints</strong>: Use <code>from typing import ...</code> extensively. This improves readability and helps catch errors early.</li>\n<li><strong>Dataclasses</strong>: Use <code>@dataclass</code> for AST nodes and data structures—they auto-generate <code>__init__</code>, <code>__repr__</code>, and support default values.</li>\n<li><strong>Error Handling</strong>: Create a custom exception hierarchy in <code>utils/errors.py</code>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> GraphQLError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"\"\"Base class for all GraphQL errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> GraphQLSyntaxError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"\"\"Raised when query syntax is invalid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> GraphQLValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       \"\"\"Raised when query fails validation against schema.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       pass</span></span></code></pre></div>\n<ol start=\"4\">\n<li><strong>Testing</strong>: Write tests alongside implementation. Use <code>unittest.TestCase</code> with descriptive method names.</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After setting up the project structure and starter code:</p>\n<ol>\n<li><strong>Verify Setup</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">   cd</span><span style=\"color:#9ECBFF\"> graphql-engine</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> venv</span><span style=\"color:#9ECBFF\"> venv</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   source</span><span style=\"color:#9ECBFF\"> venv/bin/activate</span><span style=\"color:#6A737D\">  # On Windows: venv\\Scripts\\activate</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   pip</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> flask</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#9ECBFF\"> src/graphql_engine/main.py</span></span></code></pre></div>\n<ol start=\"2\">\n<li><strong>Test HTTP Server</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:5000/health</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should return: {\"status\": \"healthy\"}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:5000/graphql</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '{\"query\": \"{ __typename }\"}'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Will fail with \"NotImplementedError\" - this is expected at this stage</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Expected Behavior</strong>: The server starts without errors. The <code>/graphql</code> endpoint returns a 500 error with &quot;NotImplementedError&quot; since the parser and executor aren&#39;t built yet. This confirms the infrastructure works.</p>\n</li>\n<li><p><strong>Common Setup Issues</strong>:</p>\n<ul>\n<li><strong>Import errors</strong>: Ensure <code>src/graphql_engine/__init__.py</code> exists (can be empty)</li>\n<li><strong>Module not found</strong>: Run from project root or set <code>PYTHONPATH</code></li>\n<li><strong>Port already in use</strong>: Change port in <code>app.run(port=5001)</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;ModuleNotFoundError: No module named &#39;graphql_engine&#39;&quot;</td>\n<td>Python can&#39;t find the module</td>\n<td>Check <code>sys.path</code>, ensure running from project root</td>\n<td>Run with <code>PYTHONPATH=src python src/graphql_engine/main.py</code></td>\n</tr>\n<tr>\n<td>Flask server starts but crashes on first request</td>\n<td>Missing dependencies</td>\n<td>Check terminal for import errors</td>\n<td><code>pip install flask</code></td>\n</tr>\n<tr>\n<td>AST node attributes are <code>None</code> when they shouldn&#39;t be</td>\n<td>Parser not setting fields correctly</td>\n<td>Add debug prints in parser to trace node creation</td>\n<td>Ensure each parsing method returns fully populated nodes</td>\n</tr>\n<tr>\n<td>SQL query has syntax errors</td>\n<td>String concatenation issues</td>\n<td>Print generated SQL before execution</td>\n<td>Use parameterized queries, not string interpolation</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the foundational scope for all five milestones, defining the absolute minimum required for the system to be considered complete, the quality attributes that guide design decisions, and explicit boundaries that prevent scope creep.</p>\n</blockquote>\n<p>This section defines the precise boundaries of our GraphQL engine—what it must achieve to be functionally complete and what it deliberately excludes to maintain focus on the core educational objectives. Building a GraphQL engine is a complex endeavor with many potential rabbit holes; clear scope definition is essential to deliver a working system while providing deep learning in the fundamental challenges of query languages, type systems, and database integration.</p>\n<h3 id=\"must-have-requirements\">Must-Have Requirements</h3>\n<blockquote>\n<p><strong>Mental Model:</strong> The <strong>Minimum Viable Kitchen</strong> — Imagine building a restaurant kitchen from scratch. You must have at minimum: a heat source (stove), refrigeration, prep surfaces, and basic utensils. Without any one of these, you cannot function. Our must-have requirements are these irreducible components—the absolute essentials needed to transform a GraphQL query into database results.</p>\n</blockquote>\n<p>The system must implement the complete pipeline from GraphQL query string to database results, corresponding directly to our five milestones. Each milestone delivers a critical, non-negotiable component; together they form a functioning engine.</p>\n<table>\n<thead>\n<tr>\n<th>Requirement Category</th>\n<th>Specific Capabilities</th>\n<th>Corresponding Milestone</th>\n<th>Success Metric</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Query Parsing</strong></td>\n<td>- Lexical analysis of GraphQL query strings into tokens<br>- Recursive descent parsing producing a complete AST<br>- Support for queries, mutations, fragments, variables, and directives<br>- Accurate source location tracking for error messages</td>\n<td>Milestone 1: GraphQL Parser</td>\n<td>Given any valid GraphQL query per the specification, the parser produces a correctly structured AST. For invalid queries, it produces descriptive errors with line/column positions.</td>\n</tr>\n<tr>\n<td><strong>Type System &amp; Schema</strong></td>\n<td>- Representation of all GraphQL type kinds (Object, Scalar, Interface, Union, Enum, InputObject, List, NonNull)<br>- Schema construction with validation for consistency (no circular references, valid interface implementations)<br>- Built-in introspection support (<code>__schema</code>, <code>__type</code>, <code>__typename</code>)<br>- Custom scalar type support with serialization/parsing functions</td>\n<td>Milestone 2: Schema &amp; Type System</td>\n<td>A GraphQL schema can be defined programmatically, validated without internal contradictions, and correctly respond to introspection queries.</td>\n</tr>\n<tr>\n<td><strong>Query Execution</strong></td>\n<td>- Field resolver invocation with correct argument coercion and context propagation<br>- Recursive resolution of nested selection sets<br>- Proper null propagation according to GraphQL specification (null bubbles to nearest nullable parent)<br>- Error collection allowing partial results<br>- Concurrent execution of independent sibling fields</td>\n<td>Milestone 3: Query Execution Engine</td>\n<td>Given a schema with resolver functions, any valid query returns correctly shaped data, handles nulls appropriately, and reports field errors without crashing.</td>\n</tr>\n<tr>\n<td><strong>Database Schema Reflection</strong></td>\n<td>- Connection to PostgreSQL (or similar SQL database) and introspection of tables, columns, and foreign keys<br>- Automatic mapping of SQL types to GraphQL scalar types (INT→GraphQLInt, VARCHAR→GraphQLString, etc.)<br>- Generation of GraphQL object types from tables with fields for columns and relationships<br>- Creation of primary key query fields and filter arguments for list fields</td>\n<td>Milestone 4: Database Schema Reflection</td>\n<td>Connecting to a sample database (e.g., a blog with Users, Posts, Comments) produces a complete GraphQL schema with proper types and relationships without manual configuration.</td>\n</tr>\n<tr>\n<td><strong>Query-to-SQL Compilation</strong></td>\n<td>- Translation of GraphQL field selections to SQL SELECT columns (no over-fetching)<br>- Generation of appropriate SQL JOINs for nested object fields based on foreign keys<br>- Prevention of N+1 queries via batching or single-query JOINs<br>- Parameterized WHERE clauses from GraphQL filter arguments<br>- Support for pagination (LIMIT/OFFSET) and ordering</td>\n<td>Milestone 5: Query to SQL Compilation</td>\n<td>A GraphQL query requesting nested relationships compiles to a single SQL query (or minimal set) that executes efficiently without Cartesian products or N+1 issues.</td>\n</tr>\n</tbody></table>\n<p><strong>Core End-to-End Flow:</strong> The system must successfully chain these components: Parse a GraphQL query string → validate it against a schema (either programmatically defined or reflected from a database) → compile it to optimized SQL → execute the SQL → transform database results into the GraphQL response shape. This pipeline represents the complete <strong>impedance mismatch</strong> bridge between GraphQL&#39;s hierarchical queries and relational database tables.</p>\n<h3 id=\"quality-attributes\">Quality Attributes</h3>\n<blockquote>\n<p><strong>Mental Model:</strong> The <strong>Kitchen&#39;s Performance Characteristics</strong> — Beyond having basic equipment, a great kitchen must be: <em>fast</em> (low latency from order to plate), <em>accurate</em> (orders exactly match what was requested), <em>adaptable</em> (can handle special dietary requirements), and <em>educational</em> (apprentices can learn why techniques work). These are our quality attributes—the &quot;ilities&quot; that guide how we build, not just what we build.</p>\n</blockquote>\n<p>While functional requirements define <em>what</em> the system does, quality attributes define <em>how well</em> it does them and influence architectural decisions. For this educational project, we prioritize in this order:</p>\n<table>\n<thead>\n<tr>\n<th>Attribute</th>\n<th>Priority</th>\n<th>Definition &amp; Measurement</th>\n<th>Architectural Implications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Educational Value</strong></td>\n<td>Highest</td>\n<td>The system&#39;s design must expose core concepts clearly, avoid excessive abstraction, and provide learning opportunities at each milestone. Measured by how easily a learner can trace through the codebase and understand each transformation.</td>\n<td>- Clear separation of concerns with well-defined component boundaries<br>- Minimal use of &quot;magic&quot; or hidden automation<br>- Extensive comments explaining <em>why</em> not just <em>what</em><br>- Straightforward data structures over optimized but obscure ones</td>\n</tr>\n<tr>\n<td><strong>Correctness</strong></td>\n<td>High</td>\n<td>The system must adhere to the GraphQL specification for parsing, validation, and execution semantics. Measured by passing a curated suite of specification-compliance tests.</td>\n<td>- Reference implementation of GraphQL spec algorithms (e.g., null propagation, type coercion)<br>- Comprehensive validation at each stage (parse, validate, execute)<br>- Use of property-based testing to ensure edge cases handled</td>\n</tr>\n<tr>\n<td><strong>Extensibility</strong></td>\n<td>Medium</td>\n<td>The architecture must allow for future enhancements (custom directives, additional database adapters, query caching) without major rewrites. Measured by how cleanly new features can be added with minimal modification to existing code.</td>\n<td>- Plugin interfaces for database adapters, custom scalar parsers, and directive handlers<br>- Abstract base classes for type definitions and execution strategies<br>- Configuration objects for reflection and compilation options</td>\n</tr>\n<tr>\n<td><strong>Performance</strong></td>\n<td>Medium-Low</td>\n<td>The system should avoid obvious performance pitfalls (N+1 queries, Cartesian products) but need not be production-optimized. Measured by basic benchmarks showing linear scaling with query complexity.</td>\n<td>- Query compilation to efficient SQL as primary performance strategy<br>- Simple DataLoader pattern for batching (but not advanced connection pooling)<br>- Acceptable to trade some performance for clarity in educational code</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Quality Attribute Prioritization</strong></p>\n<ul>\n<li><strong>Context:</strong> Building a GraphQL engine involves trade-offs between performance, correctness, maintainability, and educational value. Different production systems (Hasura, PostGraphile) prioritize performance and scalability.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Production-grade optimization:</strong> Prioritize performance and scalability above all, using advanced compilation techniques, connection pooling, and caching.</li>\n<li><strong>Educational clarity first:</strong> Prioritize readable, straightforward code that clearly demonstrates concepts, accepting performance trade-offs.</li>\n<li><strong>Balanced approach:</strong> Attempt to achieve both good performance and good educational value through careful abstraction.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Prioritize educational clarity first, with correctness as a close second.</li>\n<li><strong>Rationale:</strong> This project&#39;s primary goal is learning, not deployment to production. Learners must be able to read and understand every component. Over-optimization often obscures fundamental algorithms with complex abstractions. However, correctness is non-negotiable for understanding GraphQL semantics properly.</li>\n<li><strong>Consequences:</strong> The code will be more verbose and less performant than production systems, but each algorithm will be explicit and traceable. Performance pitfalls will be addressed pedagogically (e.g., demonstrating N+1 problem then fixing it) rather than preemptively hidden.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Production-grade optimization</td>\n<td>- High performance<br>- Demonstrates real-world scaling techniques</td>\n<td>- Complex code obscures fundamentals<br>- Requires advanced database/compiler knowledge</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Educational clarity first</td>\n<td>- Maximum learning value<br>- Easier debugging for learners<br>- Clear mapping to specification</td>\n<td>- Suboptimal performance<br>- May require refactoring for extensions</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Balanced approach</td>\n<td>- Good trade-off for both goals<br>- More realistic architecture</td>\n<td>- Harder to achieve both well<br>- Risk of being neither clear nor fast</td>\n<td>❌</td>\n</tr>\n</tbody></table>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<blockquote>\n<p><strong>Mental Model:</strong> The <strong>&quot;Not On the Menu&quot; List</strong> — Every restaurant decides what it won&#39;t serve: perhaps no vegan options, no late-night service, no catering. These exclusions let the kitchen focus on perfecting its core offerings. Our non-goals are deliberate exclusions that keep the project scope manageable and focused on core educational objectives.</p>\n</blockquote>\n<p>The following features are explicitly <strong>out of scope</strong> for the initial implementation. This prevents scope creep and ensures we deliver a complete, functional engine that teaches the fundamentals without being overwhelmed by advanced features.</p>\n<table>\n<thead>\n<tr>\n<th>Non-Goal</th>\n<th>Reason for Exclusion</th>\n<th>Potential Future Extension</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Authorization &amp; Permissions</strong></td>\n<td>Implementing row-level security, role-based access control, or field-level permissions adds significant complexity that distracts from core execution engine concepts.</td>\n<td>Could be added as a middleware layer that filters ASTs or wraps resolvers, or via schema directives.</td>\n</tr>\n<tr>\n<td><strong>Subscriptions (Real-time)</strong></td>\n<td>GraphQL subscriptions require WebSocket handling, pub/sub infrastructure, and stateful connections—a substantial separate system from query execution.</td>\n<td>Could be implemented as a separate transport layer using the same parsing/validation but with event-driven resolvers.</td>\n</tr>\n<tr>\n<td><strong>Federation &amp; Schema Stitching</strong></td>\n<td>Combining multiple GraphQL schemas involves complex query planning and delegation logic that builds upon (rather than teaches) core execution.</td>\n<td>Once the base engine is built, federation could be added as a separate query planning layer.</td>\n</tr>\n<tr>\n<td><strong>Advanced SQL Features</strong></td>\n<td>Window functions, Common Table Expressions (CTEs), stored procedure calls, or database-specific optimizations like materialized views.</td>\n<td>These could be exposed via custom directives or special field types after the core compilation works.</td>\n</tr>\n<tr>\n<td><strong>Mutation Execution Beyond CRUD</strong></td>\n<td>Complex transactional logic, conditional updates, or operations spanning multiple tables in a single mutation.</td>\n<td>The basic CRUD mutation generation from reflected schemas provides a foundation; custom resolvers can handle complex logic.</td>\n</tr>\n<tr>\n<td><strong>Query Caching</strong></td>\n<td>Persistent query caching, response caching with invalidation, or database query result caching.</td>\n<td>Simple in-memory caching could be added at the DataLoader or SQL compilation level.</td>\n</tr>\n<tr>\n<td><strong>Multiple Database Dialects</strong></td>\n<td>Full support for SQLite, MySQL, SQL Server, etc., with their type system differences and SQL variations.</td>\n<td>The architecture includes adapter interfaces; we&#39;ll focus on PostgreSQL as the reference implementation.</td>\n</tr>\n<tr>\n<td><strong>GraphQL Schema Directives</strong></td>\n<td>Custom schema directives for code generation, validation, or metadata (e.g., <code>@deprecated</code> is built-in, but not custom ones).</td>\n<td>Directive visitors could be added to the schema building and query compilation phases.</td>\n</tr>\n<tr>\n<td><strong>File Uploads</strong></td>\n<td>Multipart form handling or streaming file uploads via GraphQL mutations.</td>\n<td>This is typically handled outside GraphQL execution or via custom scalar types.</td>\n</tr>\n<tr>\n<td><strong>Performance Monitoring &amp; Tracing</strong></td>\n<td>Query complexity analysis, Apollo Tracing, or OpenTelemetry integration.</td>\n<td>Could be added as execution context extensions that collect timing data.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The most important non-goal is <strong>production readiness</strong>. This engine is designed for learning, not for deploying to production environments. We deliberately choose simpler implementations that reveal the underlying mechanisms over optimized, black-box solutions. This means our engine will be slower, handle fewer concurrent requests, and lack many features needed for production use—but it will teach you exactly how GraphQL engines work at their core.</p>\n</blockquote>\n<p><strong>Boundary Enforcement:</strong> Each component design will reference these non-goals to ensure we don&#39;t inadvertently expand scope. For example, the SQL compiler will generate straightforward JOINs rather than attempting to optimize for specific database index structures. The execution engine will use simple concurrent futures rather than sophisticated work-stealing thread pools.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Educational Focus)</th>\n<th>Advanced Option (If Extending)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Language &amp; Runtime</td>\n<td><strong>Python 3.10+</strong> (standard library, clear syntax, rapid iteration)</td>\n<td>Go or Rust (performance, concurrency model)</td>\n</tr>\n<tr>\n<td>HTTP Server (for testing)</td>\n<td><code>http.server</code> (built-in) or <code>Flask</code> (minimal dependencies)</td>\n<td><code>FastAPI</code> (async, automatic OpenAPI) or <code>aiohttp</code></td>\n</tr>\n<tr>\n<td>Database Adapter</td>\n<td><code>psycopg2</code> (PostgreSQL, synchronous, straightforward)</td>\n<td><code>asyncpg</code> (async, faster) or SQLAlchemy (abstraction)</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td><code>pytest</code> with <code>pytest-asyncio</code> for async tests</td>\n<td>Same, plus <code>hypothesis</code> for property-based testing</td>\n</tr>\n<tr>\n<td>Type Hints</td>\n<td>Extensive use of <code>typing</code> module (<code>Dict</code>, <code>List</code>, <code>Optional</code>, etc.)</td>\n<td><code>pydantic</code> for data validation or <code>mypy</code> strict checking</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql-engine/\n├── README.md\n├── pyproject.toml\n├── src/\n│   └── graphql_engine/\n│       ├── __init__.py\n│       ├── exceptions.py          # Custom exception types\n│       │\n│       ├── parsing/               # Milestone 1\n│       │   ├── __init__.py\n│       │   ├── lexer.py           # Tokenizer\n│       │   ├── parser.py          # Recursive descent parser\n│       │   ├── ast.py             # AST node classes\n│       │   └── errors.py          # Parse error with location\n│       │\n│       ├── type_system/           # Milestone 2\n│       │   ├── __init__.py\n│       │   ├── types.py           # Base GraphQLType, ScalarType, ObjectType, etc.\n│       │   ├── schema.py          # Schema class and validation\n│       │   ├── introspection.py   # __schema, __type resolvers\n│       │   └── values.py          # Value coercion utilities\n│       │\n│       ├── execution/             # Milestone 3\n│       │   ├── __init__.py\n│       │   ├── executor.py        # Main execute_query function\n│       │   ├── resolver.py        # Resolver registry and calling\n│       │   ├── errors.py          # GraphQLError collection\n│       │   ├── dataloader.py      # Simple DataLoader implementation\n│       │   └── context.py         # ExecutionContext class\n│       │\n│       ├── reflection/            # Milestone 4\n│       │   ├── __init__.py\n│       │   ├── adapter.py         # DatabaseAdapter base class\n│       │   ├── postgres_adapter.py # PostgreSQL implementation\n│       │   ├── mapper.py          # Table→Type, Column→Field mapping\n│       │   ├── relationship.py    # Foreign key detection\n│       │   └── naming.py          # Name conversion utilities\n│       │\n│       ├── compilation/           # Milestone 5\n│       │   ├── __init__.py\n│       │   ├── compiler.py        # AST-to-SQL compiler\n│       │   ├── sql_builder.py     # SQL string builder with parameterization\n│       │   ├── joins.py           # JOIN generation logic\n│       │   ├── filters.py         # WHERE clause generation\n│       │   └── pagination.py      # LIMIT/OFFSET handling\n│       │\n│       └── utils/\n│           ├── __init__.py\n│           ├── visitation.py      # AST visitor pattern\n│           └── introspection.py   # Helper for schema inspection\n│\n└── tests/                         # Comprehensive test suite\n    ├── __init__.py\n    ├── test_parsing.py\n    ├── test_type_system.py\n    ├── test_execution.py\n    ├── test_reflection.py\n    ├── test_compilation.py\n    └── integration/               # End-to-end tests</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<p>Since the educational focus is on the GraphQL engine itself, here&#39;s complete starter code for a simple HTTP server and database adapter that learners can use immediately:</p>\n<p><strong><code>src/graphql_engine/server/http_server.py</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Simple HTTP server for testing GraphQL engine.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Educational purpose only - not production ready.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> http.server </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HTTPServer, BaseHTTPRequestHandler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.parsing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.execution </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> execute_query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.type_system </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLRequestHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseHTTPRequestHandler</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles POST requests with GraphQL queries in JSON body.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, schema: Schema, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> schema</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> do_POST</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle GraphQL query POST request.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.headers.get(</span><span style=\"color:#9ECBFF\">'Content-Length'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        body </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.rfile.read(content_length).decode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            request_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.loads(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_data.get(</span><span style=\"color:#9ECBFF\">'query'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            variables </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_data.get(</span><span style=\"color:#9ECBFF\">'variables'</span><span style=\"color:#E1E4E8\">, {})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            operation_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_data.get(</span><span style=\"color:#9ECBFF\">'operationName'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Parse and execute</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            document_ast </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_query(query)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> execute_query(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                schema</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.schema,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                document_ast</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">document_ast,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                variable_values</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">variables,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                operation_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">operation_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            response_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.dumps(result, </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">).encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_header(</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'application/json'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_header(</span><span style=\"color:#9ECBFF\">'Content-Length'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(response_data)))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.wfile.write(response_data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            error_response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'errors'</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(e)}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            response_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.dumps(error_response).encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_header(</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'application/json'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_header(</span><span style=\"color:#9ECBFF\">'Content-Length'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(response_data)))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.wfile.write(response_data)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> start_test_server</span><span style=\"color:#E1E4E8\">(schema: Schema, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'localhost'</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Start a simple HTTP server for testing GraphQL queries.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> GraphQLRequestHandler(schema, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HTTPServer((host, port), handler)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"GraphQL test server running at http://</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">host</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">port</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Send POST requests with JSON body: </span><span style=\"color:#79B8FF\">{{</span><span style=\"color:#9ECBFF\">'query': '</span><span style=\"color:#79B8FF\">{{</span><span style=\"color:#9ECBFF\"> ... </span><span style=\"color:#79B8FF\">}}</span><span style=\"color:#9ECBFF\">', 'variables': </span><span style=\"color:#79B8FF\">{{</span><span style=\"color:#9ECBFF\">...</span><span style=\"color:#79B8FF\">}}}}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server.serve_forever()</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<p>For the main execution function that learners will implement in Milestone 3:</p>\n<p><strong><code>src/graphql_engine/execution/executor.py</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core query execution engine.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Implements GraphQL execution algorithm per specification.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.type_system </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema, ObjectType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.parsing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Document, OperationDefinition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.execution.context </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ExecutionContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.execution.errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> execute_query</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema: Schema,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    document_ast: Document,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variable_values: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_value: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Execute a GraphQL query against a schema.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        schema: The GraphQL schema to execute against</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        document_ast: Parsed AST of the GraphQL query document</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        variable_values: Dictionary of variable values provided with the request</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        operation_name: Name of operation to execute if document contains multiple</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        context_value: Shared context passed to all resolvers</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Dictionary containing 'data' and/or 'errors' keys per GraphQL spec</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> Implementation Steps (Milestone 3):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    1. Validate that document_ast contains at least one operation definition</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    2. If operation_name is provided, find the named operation; otherwise use the only operation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    3. Coerce variable values to types defined in operation's variable definitions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    4. Create ExecutionContext with schema, variable values, and context_value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    5. Get root type (Query, Mutation, or Subscription) from schema based on operation type</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    6. Execute selection set starting with root type and empty parent value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    7. Collect any errors that occurred during execution</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    8. Return {'data': result} if no errors, or {'data': result, 'errors': [...]} if errors</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    9. Ensure null propagation: if a non-null field resolves to null, bubble up appropriately</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    10. Handle lists: if field type is List, execute for each item in parent value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate document_ast has definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Select operation based on operation_name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Coerce variable values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create ExecutionContext</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Get root type from schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Execute selection set (call execute_selection_set)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Collect errors from context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Format response according to GraphQL spec</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> execute_selection_set</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selection_set,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_type: ObjectType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_value: Any,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context: ExecutionContext</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Execute a selection set for a given parent type and value.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> Implementation Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    1. Initialize result dict to hold field results</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    2. For each selection in selection_set:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        a. If it's a Field: execute_field and add to result dict</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        b. If it's a FragmentSpread: resolve fragment and execute its selection set</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        c. If it's an InlineFragment: check type condition and execute if matches</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    3. Return result dict</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    4. Handle parallelism: sibling fields without dependencies can execute concurrently</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> execute_field</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    field,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_type: ObjectType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_value: Any,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context: ExecutionContext</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Execute a single field resolution.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> Implementation Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    1. Get field definition from parent_type</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    2. Coerce field arguments using variable values from context</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    3. Get resolver function for field (default: parent_value[field_name])</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    4. Call resolver with (parent_value, args, context, info)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    5. If resolver returns None and field type is Non-Null: throw error</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    6. If resolver returns a value and field has a selection set: recursively execute</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    7. Return coerced value (apply List/NonNull wrappers as needed)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li><strong>Python Type Hints:</strong> Use <code>from typing import List, Dict, Optional, Any, Union</code> extensively. Define <code>TypedDict</code> for complex return structures.</li>\n<li><strong>Async/Await:</strong> Consider using <code>asyncio</code> for concurrent field execution. Use <code>asyncio.gather()</code> for parallel sibling field resolution.</li>\n<li><strong>Error Handling:</strong> Raise custom exceptions like <code>GraphQLError</code> with message and optional locations. Catch exceptions at field boundaries to allow partial results.</li>\n<li><strong>DataLoader Pattern:</strong> Implement a simple <code>DataLoader</code> class that batches <code>load()</code> calls and caches results per request.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong>\nAfter implementing the core execution engine (Milestone 3), run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_execution.py</span><span style=\"color:#79B8FF\"> -xvs</span></span></code></pre></div>\n<p>Expected output: All tests pass, demonstrating:</p>\n<ol>\n<li>Simple field resolution returns correct data</li>\n<li>Nested fields resolve recursively</li>\n<li>Null propagation works correctly (non-null field resolving to null bubbles up)</li>\n<li>List fields work with lists of objects</li>\n<li>Field errors are collected without crashing execution</li>\n</ol>\n<p><strong>G. Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Cannot read property &#39;x&#39; of undefined&quot; in resolver</td>\n<td>Parent value not passed correctly to nested resolver</td>\n<td>Print parent_value in execute_field</td>\n<td>Ensure each field resolver receives the correct parent (object from previous level)</td>\n</tr>\n<tr>\n<td>All fields return null</td>\n<td>Resolver functions not registered or default resolver fails</td>\n<td>Check field definition has resolver; add print to default resolver</td>\n<td>Implement proper resolver lookup or ensure parent objects have matching attribute names</td>\n</tr>\n<tr>\n<td>Non-null error bubbles to root incorrectly</td>\n<td>Null propagation logic missing type checking</td>\n<td>Add debug prints to see when null is encountered and what field type is</td>\n<td>Implement spec rule: if field is NonNull and returns null, bubble null to parent; if parent is nullable, set to null</td>\n</tr>\n<tr>\n<td>Sibling fields execute sequentially</td>\n<td>Missing parallel execution</td>\n<td>Add timing logs to see fields execute one after another</td>\n<td>Use <code>asyncio.gather()</code> or <code>concurrent.futures</code> for independent fields</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the architectural blueprint for all five milestones, showing how components fit together and how data flows through the system. It establishes the overall structure before diving into individual component details.</p>\n</blockquote>\n<p>The GraphQL engine architecture bridges two fundamentally different worlds: GraphQL&#39;s hierarchical, client-centric query model and relational databases&#39; tabular, set-oriented structure. This <strong>impedance mismatch</strong> is the central architectural challenge we must solve. Rather than a monolithic blob, we decompose the system into five focused components, each with a clear responsibility and interface, connected by well-defined data transformations.</p>\n<h3 id=\"system-component-diagram\">System Component Diagram</h3>\n<blockquote>\n<p><strong>Mental Model: The Restaurant Kitchen Analogy</strong></p>\n<p>Think of the GraphQL engine as a high-end restaurant kitchen. The <strong>Parser</strong> is the order-taker who listens to the customer&#39;s complex request and writes it down in the kitchen&#39;s internal shorthand (the AST). The <strong>Type System</strong> is the recipe book that defines what ingredients are available and how they can be combined. The <strong>Execution Engine</strong> is the head chef who coordinates the preparation, calling on various station chefs (resolvers) to prepare each component of the meal. The <strong>Schema Reflection</strong> is the inventory system that automatically catalogs what&#39;s in the pantry (database) and creates recipes for it. Finally, the <strong>SQL Compiler</strong> is the sous-chef who optimizes the cooking process—instead of making each component separately (N+1 problem), they plan an efficient sequence that uses shared ingredients and parallel cooking stations to prepare everything in minimal time.</p>\n</blockquote>\n<p><img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Fsystem-component-diagram.svg\" alt=\"GraphQL Engine System Components\"></p>\n<p><img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Fparsing-sequence.svg\" alt=\"Query Parsing Sequence Diagram\"></p>\n<p><img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Fast-class-diagram.svg\" alt=\"Ast Class Diagram\"></p>\n<p>The system comprises five core components that transform a GraphQL query string into database results:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Input</th>\n<th>Output</th>\n<th>Analogy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>GraphQL Parser</strong></td>\n<td>Converts GraphQL query strings into Abstract Syntax Trees (ASTs)</td>\n<td>GraphQL query string (<code>String</code>)</td>\n<td>Validated AST (<code>Document</code>)</td>\n<td>Order-taker translating customer request to kitchen ticket</td>\n</tr>\n<tr>\n<td><strong>Schema &amp; Type System</strong></td>\n<td>Defines and validates GraphQL types, provides introspection</td>\n<td>Type definitions, database metadata</td>\n<td>Complete <code>GraphQLSchema</code> with all types</td>\n<td>Recipe book defining available dishes and ingredients</td>\n</tr>\n<tr>\n<td><strong>Query Execution Engine</strong></td>\n<td>Executes queries by calling resolver functions</td>\n<td><code>GraphQLSchema</code>, query AST, variables, context</td>\n<td>Structured JSON response</td>\n<td>Head chef coordinating station chefs to prepare meal</td>\n</tr>\n<tr>\n<td><strong>Database Schema Reflection</strong></td>\n<td>Auto-generates GraphQL types from database schema</td>\n<td>Database connection, configuration options</td>\n<td>Generated GraphQL types and resolvers</td>\n<td>Inventory system cataloging pantry contents</td>\n</tr>\n<tr>\n<td><strong>Query to SQL Compiler</strong></td>\n<td>Compiles GraphQL queries to optimized SQL</td>\n<td>Query AST, schema metadata, variable values</td>\n<td>Parameterized SQL query + execution plan</td>\n<td>Sous-chef optimizing cooking process to minimize steps</td>\n</tr>\n</tbody></table>\n<h4 id=\"component-interactions-and-data-flow\">Component Interactions and Data Flow</h4>\n<p>The components interact through well-defined interfaces, creating a pipeline that transforms data at each stage:</p>\n<ol>\n<li><p><strong>Schema Building Path</strong>: The Database Schema Reflection component reads database metadata and generates GraphQL types, which feed into the Schema &amp; Type System component to build a complete schema.</p>\n</li>\n<li><p><strong>Query Execution Path</strong>: A GraphQL query string flows through the Parser → Type System (for validation) → Execution Engine → SQL Compiler (for database queries) → Database → Back through the chain as results.</p>\n</li>\n<li><p><strong>Introspection Path</strong>: Special GraphQL introspection queries follow the same execution path but are handled by built-in resolvers in the Type System component.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Architecture Decision: Separation of Concerns via Pipeline</strong></p>\n<p><strong>Context</strong>: We need to transform GraphQL queries into database results while maintaining clarity, testability, and the ability to evolve components independently. The system must handle both hand-written schemas and auto-generated ones from databases.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Monolithic Engine</strong>: Single component that handles parsing, validation, execution, and SQL generation in one intertwined codebase.</li>\n<li><strong>Pipeline Architecture</strong>: Clear separation with each component focusing on one transformation, passing data through well-defined interfaces.</li>\n<li><strong>Plugin Architecture</strong>: Core engine with extensible plugins for parsing, execution, SQL generation, etc.</li>\n</ol>\n<p><strong>Decision</strong>: Pipeline Architecture with clear interfaces between components.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Testability</strong>: Each component can be tested in isolation with mock inputs/outputs.</li>\n<li><strong>Educational Value</strong>: Clear boundaries help learners understand each transformation step.</li>\n<li><strong>Evolution</strong>: Components can be swapped or upgraded independently (e.g., different SQL dialects).</li>\n<li><strong>Debugging</strong>: Failures can be pinpointed to specific transformation stages.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: Clear mental model, easier to understand and debug, enables incremental development.</li>\n<li><strong>Negative</strong>: Some overhead in data marshaling between components, requires careful interface design.</li>\n<li><strong>Mitigation</strong>: Use immutable data structures that can be passed efficiently by reference.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Monolithic Engine</td>\n<td>Fewer interface boundaries, potentially faster</td>\n<td>Hard to test, difficult to understand, tightly coupled</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Pipeline Architecture</td>\n<td>Clear separation, testable, educational, modular</td>\n<td>Data marshaling overhead, interface design complexity</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Plugin Architecture</td>\n<td>Extremely flexible, ecosystem potential</td>\n<td>Complex plugin API, harder for learners, over-engineering</td>\n<td>❌</td>\n</tr>\n</tbody></table>\n<h3 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h3>\n<blockquote>\n<p><strong>Mental Model: The Workshop Organization</strong></p>\n<p>Imagine each component as a specialized workshop station. The <strong>Parser Workshop</strong> has lexing tools and grammar charts. The <strong>Type System Workshop</strong> has blueprint diagrams and validation checklists. The <strong>Execution Workshop</strong> has assembly lines and quality control stations. The <strong>Reflection Workshop</strong> has database connection tools and mapping tables. The <strong>SQL Compiler Workshop</strong> has query planning boards and optimization tools. Each workshop has its own tools, organized in labeled drawers (modules), with clear paths between workshops for moving work-in-progress.</p>\n</blockquote>\n<p>A clean directory structure is critical for managing complexity and maintaining separation of concerns. Below is the recommended organization for a Python implementation:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql-engine/\n├── pyproject.toml              # Project configuration and dependencies\n├── README.md\n├── examples/                   # Example schemas and queries\n│   ├── blog/\n│   └── ecommerce/\n├── src/\n│   └── graphql_engine/         # Main package\n│       ├── __init__.py\n│       ├── exceptions.py       # Custom exception types\n│       ├── constants.py        # Constants (type names, directives, etc.)\n│       ├── parser/             # Component 1: GraphQL Parser\n│       │   ├── __init__.py\n│       │   ├── lexer.py        # Tokenizer/Lexer\n│       │   ├── parser.py       # Recursive descent parser\n│       │   ├── ast.py          # AST node class definitions\n│       │   └── errors.py       # Parse error types\n│       ├── type_system/        # Component 2: Schema &amp; Type System\n│       │   ├── __init__.py\n│       │   ├── types.py        # Base GraphQLType and all type classes\n│       │   ├── schema.py       # GraphQLSchema class and validation\n│       │   ├── introspection.py # Introspection resolver implementations\n│       │   └── validation.py   # Schema validation rules\n│       ├── execution/          # Component 3: Query Execution Engine\n│       │   ├── __init__.py\n│       │   ├── executor.py     # Main Executor class\n│       │   ├── resolvers.py    # Default resolver implementations\n│       │   ├── dataloader.py   # DataLoader pattern implementation\n│       │   ├── errors.py       # Execution error handling\n│       │   └── context.py      # ExecutionContext class\n│       ├── reflection/         # Component 4: Database Schema Reflection\n│       │   ├── __init__.py\n│       │   ├── reflector.py    # Main SchemaReflector class\n│       │   ├── adapters/       # Database-specific adapters\n│       │   │   ├── __init__.py\n│       │   │   ├── postgres.py\n│       │   │   ├── mysql.py\n│       │   │   └── sqlite.py\n│       │   ├── type_mapping.py # SQL-to-GraphQL type mapping\n│       │   └── naming.py       # Naming convention utilities\n│       ├── sql_compiler/       # Component 5: Query to SQL Compilation\n│       │   ├── __init__.py\n│       │   ├── compiler.py     # Main SQLCompiler class\n│       │   ├── ir.py           # Intermediate Representation structures\n│       │   ├── builders.py     # SQL query builder utilities\n│       │   ├── joins.py        # JOIN generation logic\n│       │   └── parameters.py   # Query parameterization\n│       └── server/             # Optional HTTP server wrapper\n│           ├── __init__.py\n│           ├── http_handler.py # HTTP request/response handling\n│           └── graphiql.py     # GraphiQL IDE endpoint\n└── tests/                      # Comprehensive test suite\n    ├── __init__.py\n    ├── test_parser/\n    ├── test_type_system/\n    ├── test_execution/\n    ├── test_reflection/\n    └── test_sql_compiler/</code></pre></div>\n\n<h4 id=\"module-responsibilities-and-public-interfaces\">Module Responsibilities and Public Interfaces</h4>\n<p>Each module exposes a clean public API while hiding implementation details:</p>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Public Classes/Functions</th>\n<th>Purpose</th>\n<th>Dependencies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parser</code></td>\n<td><code>parse_query(query_str)</code>, <code>parse_schema(sdl_str)</code>, <code>Document</code>, <code>Location</code></td>\n<td>Convert strings to ASTs</td>\n<td>None (pure text processing)</td>\n</tr>\n<tr>\n<td><code>type_system</code></td>\n<td><code>GraphQLSchema</code>, <code>GraphQLObjectType</code>, <code>GraphQLScalarType</code>, <code>build_schema()</code></td>\n<td>Define and validate types</td>\n<td><code>parser</code> for SDL parsing</td>\n</tr>\n<tr>\n<td><code>execution</code></td>\n<td><code>execute_query(schema, document, ...)</code>, <code>ExecutionContext</code>, <code>DataLoader</code></td>\n<td>Execute queries against schema</td>\n<td><code>parser</code>, <code>type_system</code></td>\n</tr>\n<tr>\n<td><code>reflection</code></td>\n<td><code>SchemaReflector</code>, <code>reflect_schema(connection)</code>, database adapters</td>\n<td>Generate schema from database</td>\n<td><code>type_system</code> for type building</td>\n</tr>\n<tr>\n<td><code>sql_compiler</code></td>\n<td><code>SQLCompiler</code>, <code>compile_to_sql(query_ast, schema)</code>, <code>CompiledQuery</code></td>\n<td>Convert GraphQL to SQL</td>\n<td><code>parser</code>, <code>type_system</code>, <code>reflection</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Layered Dependencies</strong></p>\n<p><strong>Context</strong>: Components have natural dependencies (e.g., Execution needs Parser and Type System, SQL Compiler needs all previous components). We must manage these dependencies to avoid circular references and ensure clean separation.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Flat Structure</strong>: All components in same module level with bidirectional imports.</li>\n<li><strong>Layered Architecture</strong>: Lower layers don&#39;t know about higher layers (Parser → Type System → Execution → Reflection/SQL Compiler).</li>\n<li><strong>Dependency Injection</strong>: All components receive dependencies via constructor injection.</li>\n</ol>\n<p><strong>Decision</strong>: Layered Architecture with unidirectional dependencies.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Clear Dependency Flow</strong>: Natural progression from parsing → typing → execution → compilation.</li>\n<li><strong>No Circular Dependencies</strong>: Prevents import loops and spaghetti code.</li>\n<li><strong>Progressive Learning</strong>: Learners can build and test components in dependency order.</li>\n<li><strong>Simplified Testing</strong>: Lower layers can be tested without higher layers.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: Clean mental model, predictable dependencies, easier to reason about.</li>\n<li><strong>Negative</strong>: Higher layers can&#39;t easily call back to lower layers (though rarely needed).</li>\n<li><strong>Mitigation</strong>: Use callback interfaces when upward communication is genuinely needed.</li>\n</ul>\n</blockquote>\n<h3 id=\"end-to-end-data-flow\">End-to-End Data Flow</h3>\n<blockquote>\n<p><strong>Mental Model: The Manufacturing Assembly Line</strong></p>\n<p>Picture a car manufacturing plant where raw materials (GraphQL query strings) enter at one end and finished cars (JSON responses) exit at the other. At Station 1 (Parser), the query sheet metal is cut and shaped into standardized parts (AST nodes). At Station 2 (Type System), each part is inspected against blueprints to ensure it fits specifications. At Station 3 (Execution), the assembly line coordinates workers (resolvers) to assemble components. For database-backed fields, instead of hand-crafting each part, Station 4 (SQL Compiler) designs efficient machine tools (SQL queries) that mass-produce precisely the needed components. Station 5 (Database) is the raw materials warehouse that feeds these machines. Finally, quality control assembles everything into the final product.</p>\n</blockquote>\n<p><img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Fdata-flow-end-to-end.svg\" alt=\"End-to-End Data Flow Diagram\"></p>\n<p>The complete transformation pipeline for a typical query involves eight distinct data format transformations:</p>\n<h4 id=\"step-by-step-data-transformation-pipeline\">Step-by-Step Data Transformation Pipeline</h4>\n<ol>\n<li><p><strong>Input Reception</strong>:</p>\n<ul>\n<li><strong>Format</strong>: HTTP POST request with JSON body</li>\n<li><strong>Content</strong>: <code>{&quot;query&quot;: &quot;query { user(id: 1) { name email } }&quot;, &quot;variables&quot;: {...}, &quot;operationName&quot;: &quot;...&quot;}</code></li>\n<li><strong>Source</strong>: Client application (e.g., React frontend, mobile app)</li>\n</ul>\n</li>\n<li><p><strong>GraphQL Query String Extraction</strong>:</p>\n<ul>\n<li><strong>Action</strong>: Extract the <code>query</code> field from the JSON payload</li>\n<li><strong>Format</strong>: Raw GraphQL query string</li>\n<li><strong>Example</strong>: <code>&quot;query GetUser($id: ID!) { user(id: $id) { name email posts { title } } }&quot;</code></li>\n<li><strong>Note</strong>: Variables are kept separate for later substitution</li>\n</ul>\n</li>\n<li><p><strong>Lexical Analysis (Tokenizer)</strong>:</p>\n<ul>\n<li><p><strong>Action</strong>: Break string into tokens with type and position</p>\n</li>\n<li><p><strong>Input</strong>: <code>&quot;query { user(id: 1) { name } }&quot;</code></p>\n</li>\n<li><p><strong>Output</strong>: List of <code>Token</code> objects:</p>\n<table>\n<thead>\n<tr>\n<th>Token Type</th>\n<th>Value</th>\n<th>Location (line:column)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NAME</td>\n<td>&quot;query&quot;</td>\n<td>1:1</td>\n</tr>\n<tr>\n<td>BRACE_L</td>\n<td>&quot;{&quot;</td>\n<td>1:7</td>\n</tr>\n<tr>\n<td>NAME</td>\n<td>&quot;user&quot;</td>\n<td>1:9</td>\n</tr>\n<tr>\n<td>PAREN_L</td>\n<td>&quot;(&quot;</td>\n<td>1:13</td>\n</tr>\n<tr>\n<td>NAME</td>\n<td>&quot;id&quot;</td>\n<td>1:14</td>\n</tr>\n<tr>\n<td>COLON</td>\n<td>&quot;:&quot;</td>\n<td>1:16</td>\n</tr>\n<tr>\n<td>INT</td>\n<td>&quot;1&quot;</td>\n<td>1:18</td>\n</tr>\n<tr>\n<td>PAREN_R</td>\n<td>&quot;)&quot;</td>\n<td>1:19</td>\n</tr>\n<tr>\n<td>BRACE_L</td>\n<td>&quot;{&quot;</td>\n<td>1:21</td>\n</tr>\n<tr>\n<td>NAME</td>\n<td>&quot;name&quot;</td>\n<td>1:23</td>\n</tr>\n<tr>\n<td>BRACE_R</td>\n<td>&quot;}&quot;</td>\n<td>1:27</td>\n</tr>\n<tr>\n<td>BRACE_R</td>\n<td>&quot;}&quot;</td>\n<td>1:29</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n<li><p><strong>Syntactic Analysis (Parser)</strong>:</p>\n<ul>\n<li><strong>Action</strong>: Build AST from token stream using recursive descent</li>\n<li><strong>Output</strong>: <code>Document</code> AST with <code>OperationDefinition</code>, <code>SelectionSet</code>, <code>Field</code>, <code>Argument</code> nodes</li>\n<li><strong>Structure</strong>:</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>     Document\n     └── OperationDefinition (type: &quot;query&quot;, name: None)\n         └── SelectionSet\n             └── Field (name: &quot;user&quot;)\n                 ├── Argument (name: &quot;id&quot;, value: IntValue(1))\n                 └── SelectionSet\n                     └── Field (name: &quot;name&quot;)</code></pre></div>\n\n<ol start=\"5\">\n<li><p><strong>Schema Validation</strong>:</p>\n<ul>\n<li><strong>Action</strong>: Check AST against schema type definitions</li>\n<li><strong>Checks</strong>: Field existence, argument type compatibility, required arguments provided</li>\n<li><strong>Output</strong>: Validated query AST or detailed validation errors</li>\n<li><strong>Critical Validation Rules</strong>:<ol>\n<li>All selected fields must exist on the parent type</li>\n<li>All required arguments must be provided</li>\n<li>Variable types must match parameter types</li>\n<li>Fragments must be used on compatible types</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>Execution Planning</strong>:</p>\n<ul>\n<li><strong>Action</strong>: Analyze query to determine resolution strategy</li>\n<li><strong>For Database Fields</strong>: Pass to SQL Compiler</li>\n<li><strong>For Custom Resolvers</strong>: Schedule resolver execution</li>\n<li><strong>Output</strong>: Execution plan with parallelizable units</li>\n</ul>\n</li>\n<li><p><strong>SQL Compilation</strong> (for database-backed fields):</p>\n<ul>\n<li><strong>Action</strong>: Convert GraphQL field selections to SQL query</li>\n<li><strong>Input</strong>: <code>Field</code> AST nodes, schema type information, variable values</li>\n<li><strong>Process</strong>:<ol>\n<li>Analyze selection tree to determine required tables and columns</li>\n<li>Generate JOINs based on foreign key relationships</li>\n<li>Apply WHERE clauses from arguments</li>\n<li>Add ORDER BY/LIMIT for pagination</li>\n</ol>\n</li>\n<li><strong>Output</strong>: Parameterized SQL query + bind parameters</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">     SELECT</span><span style=\"color:#9ECBFF\"> \"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"email\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     FROM</span><span style=\"color:#9ECBFF\"> \"users\"</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#9ECBFF\"> \"user\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     WHERE</span><span style=\"color:#9ECBFF\"> \"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> $</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#6A737D\">  -- $1 = 1</span></span></code></pre></div>\n\n<ol start=\"8\">\n<li><p><strong>Database Query Execution</strong>:</p>\n<ul>\n<li><strong>Action</strong>: Execute compiled SQL with parameters</li>\n<li><strong>Format</strong>: Database-specific query + parameter binding</li>\n<li><strong>Output</strong>: Raw database rows (list of dictionaries/records)</li>\n</ul>\n</li>\n<li><p><strong>Result Shaping</strong>:</p>\n<ul>\n<li><strong>Action</strong>: Transform database rows to GraphQL response shape</li>\n<li><strong>Process</strong>: Map column values to field names, nest related objects</li>\n<li><strong>Output</strong>: Nested dictionaries matching query structure</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">     {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       \"user\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">         \"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">         \"email\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"alice@example.com\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     }</span></span></code></pre></div>\n\n<ol start=\"10\">\n<li><strong>Error Collection &amp; Final Response Assembly</strong>:<ul>\n<li><strong>Action</strong>: Gather any field errors, apply error masking if needed</li>\n<li><strong>Output</strong>: Final GraphQL response JSON:</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">      {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"data\"</span><span style=\"color:#E1E4E8\">: { </span><span style=\"color:#FDAEB7;font-style:italic\">...</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"errors\"</span><span style=\"color:#E1E4E8\">: [ </span><span style=\"color:#FDAEB7;font-style:italic\">...</span><span style=\"color:#E1E4E8\"> ]  </span><span style=\"color:#6A737D\">// Only if errors occurred</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span></code></pre></div>\n\n<h4 id=\"concrete-walk-through-example\">Concrete Walk-Through Example</h4>\n<p>Let&#39;s trace a complete example query through the pipeline:</p>\n<p><strong>Initial HTTP Request</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">http</span><pre class=\"arch-pre shiki-highlighted\"><code>POST /graphql HTTP/1.1\nContent-Type: application/json\n\n{\n  &quot;query&quot;: &quot;query GetUserWithPosts($userId: ID!) { user(id: $userId) { name email posts(limit: 5) { title publishedAt } } }&quot;,\n  &quot;variables&quot;: { &quot;userId&quot;: &quot;42&quot; },\n  &quot;operationName&quot;: &quot;GetUserWithPosts&quot;\n}</code></pre></div>\n\n<p><strong>Step 1-2</strong>: Extract query string and variables:</p>\n<ul>\n<li>Query: <code>&quot;query GetUserWithPosts($userId: ID!) { user(id: $userId) { name email posts(limit: 5) { title publishedAt } } }&quot;</code></li>\n<li>Variables: <code>{&quot;userId&quot;: &quot;42&quot;}</code></li>\n</ul>\n<p><strong>Step 3-4</strong>: Parser produces AST:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Document\n├── OperationDefinition\n│   ├── operation_type: &quot;query&quot;\n│   ├── name: &quot;GetUserWithPosts&quot;\n│   ├── variable_definitions:\n│   │   └── VariableDefinition\n│   │       ├── name: &quot;userId&quot;\n│   │       └── type: NonNullType(of: NamedType(name: &quot;ID&quot;))\n│   └── selection_set: SelectionSet\n│       └── Field\n│           ├── name: &quot;user&quot;\n│           ├── arguments:\n│           │   └── Argument\n│           │       ├── name: &quot;id&quot;\n│           │       └── value: Variable(name: &quot;userId&quot;)\n│           └── selection_set: SelectionSet\n│               ├── Field(name: &quot;name&quot;)\n│               ├── Field(name: &quot;email&quot;)\n│               └── Field(name: &quot;posts&quot;)\n│                   ├── arguments:\n│                   │   └── Argument\n│                   │       ├── name: &quot;limit&quot;\n│                   │       └── value: IntValue(value: 5)\n│                   └── selection_set: SelectionSet\n│                       ├── Field(name: &quot;title&quot;)\n│                       └── Field(name: &quot;publishedAt&quot;)</code></pre></div>\n\n<p><strong>Step 5</strong>: Type System validates:</p>\n<ul>\n<li><code>User</code> type has fields <code>name</code>, <code>email</code>, <code>posts</code></li>\n<li><code>posts</code> field returns <code>[Post]</code> type</li>\n<li><code>Post</code> type has fields <code>title</code>, <code>publishedAt</code></li>\n<li><code>user</code> argument <code>id</code> expects <code>ID!</code> → variable <code>userId</code> is <code>ID!</code> ✓</li>\n<li><code>posts</code> argument <code>limit</code> expects <code>Int</code> → value <code>5</code> is <code>Int</code> ✓</li>\n</ul>\n<p><strong>Step 6-7</strong>: SQL Compiler analyzes and generates:</p>\n<ul>\n<li>Need <code>users</code> table columns: <code>id</code>, <code>name</code>, <code>email</code></li>\n<li>Need <code>posts</code> table columns: <code>id</code>, <code>title</code>, <code>published_at</code>, <code>author_id</code></li>\n<li>Relationship: <code>posts.author_id</code> → <code>users.id</code></li>\n<li>Generate SQL with JOIN:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#9ECBFF\"> \"user__id\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#9ECBFF\"> \"user__name\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"email\"</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#9ECBFF\"> \"user__email\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"posts\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#9ECBFF\"> \"posts__id\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"posts\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"title\"</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#9ECBFF\"> \"posts__title\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"posts\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"published_at\"</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#9ECBFF\"> \"posts__published_at\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#9ECBFF\"> \"users\"</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#9ECBFF\"> \"user\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">LEFT JOIN</span><span style=\"color:#E1E4E8\"> LATERAL (</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  SELECT</span><span style=\"color:#9ECBFF\"> \"posts\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#F97583\">*</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  FROM</span><span style=\"color:#9ECBFF\"> \"posts\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  WHERE</span><span style=\"color:#9ECBFF\"> \"posts\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"author_id\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"id\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  ORDER BY</span><span style=\"color:#9ECBFF\"> \"posts\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"published_at\"</span><span style=\"color:#F97583\"> DESC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  LIMIT</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">AS</span><span style=\"color:#9ECBFF\"> \"posts\"</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> TRUE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WHERE</span><span style=\"color:#9ECBFF\"> \"user\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> $</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#6A737D\">  -- $1 = 42</span></span></code></pre></div>\n\n<p><strong>Step 8</strong>: Database returns rows:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[\n  {\n    &quot;user__id&quot;: 42,\n    &quot;user__name&quot;: &quot;Alice&quot;,\n    &quot;user__email&quot;: &quot;alice@example.com&quot;,\n    &quot;posts__id&quot;: 101,\n    &quot;posts__title&quot;: &quot;GraphQL Tutorial&quot;,\n    &quot;posts__published_at&quot;: &quot;2023-10-01 14:30:00&quot;\n  },\n  {\n    &quot;user__id&quot;: 42,\n    &quot;user__name&quot;: &quot;Alice&quot;,\n    &quot;user__email&quot;: &quot;alice@example.com&quot;,\n    &quot;posts__id&quot;: 102,\n    &quot;posts__title&quot;: &quot;Database Design&quot;,\n    &quot;posts__published_at&quot;: &quot;2023-10-05 09:15:00&quot;\n  }\n]</code></pre></div>\n\n<p><strong>Step 9</strong>: Result shaping transforms to nested structure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"user\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"email\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"alice@example.com\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"posts\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"title\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"GraphQL Tutorial\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"publishedAt\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2023-10-01T14:30:00Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"title\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Database Design\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"publishedAt\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2023-10-05T09:15:00Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Step 10</strong>: Final response assembly (no errors):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"data\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"user\"</span><span style=\"color:#E1E4E8\">: { </span><span style=\"color:#FDAEB7;font-style:italic\">...</span><span style=\"color:#E1E4E8\"> }  </span><span style=\"color:#6A737D\">// as above</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"data-formats-at-each-stage\">Data Formats at Each Stage</h4>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Data Format</th>\n<th>Key Properties</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. Client Request</td>\n<td>HTTP + JSON</td>\n<td>Contains query string, variables, operation name</td>\n<td><code>{&quot;query&quot;: &quot;{ user { name } }&quot;, &quot;variables&quot;: {}}</code></td>\n</tr>\n<tr>\n<td>2. Extracted Query</td>\n<td>GraphQL String</td>\n<td>Raw query text with possible variables</td>\n<td><code>&quot;query { user(id: 1) { name } }&quot;</code></td>\n</tr>\n<tr>\n<td>3. Token Stream</td>\n<td>List of <code>Token</code></td>\n<td>Linear sequence with type, value, location</td>\n<td><code>[Token(NAME, &quot;query&quot;, 1:1), Token(BRACE_L, &quot;{&quot;, 1:7), ...]</code></td>\n</tr>\n<tr>\n<td>4. AST</td>\n<td><code>Document</code> object</td>\n<td>Tree structure with nodes preserving source locations</td>\n<td><code>Document(definitions=[OperationDefinition(...)])</code></td>\n</tr>\n<tr>\n<td>5. Validated AST</td>\n<td><code>Document</code> + type info</td>\n<td>AST annotated with resolved types</td>\n<td>Field node knows it resolves to <code>User</code> type</td>\n</tr>\n<tr>\n<td>6. Execution Plan</td>\n<td><code>ExecutionPlan</code></td>\n<td>Graph of resolvers with dependencies</td>\n<td><code>[SQLResolver(table=&quot;users&quot;), CustomResolver(field=&quot;bio&quot;)]</code></td>\n</tr>\n<tr>\n<td>7. Compiled SQL</td>\n<td><code>CompiledQuery</code></td>\n<td>SQL string + parameter bindings</td>\n<td><code>(&quot;SELECT ... WHERE id = $1&quot;, [42])</code></td>\n</tr>\n<tr>\n<td>8. Database Results</td>\n<td>List of rows</td>\n<td>Tabular data, possibly with aliased columns</td>\n<td><code>[{&quot;user__name&quot;: &quot;Alice&quot;, &quot;posts__title&quot;: &quot;...&quot;}]</code></td>\n</tr>\n<tr>\n<td>9. Shaped Results</td>\n<td>Nested dict</td>\n<td>Hierarchical structure matching query</td>\n<td><code>{&quot;user&quot;: {&quot;name&quot;: &quot;Alice&quot;, &quot;posts&quot;: [...]}}</code></td>\n</tr>\n<tr>\n<td>10. Final Response</td>\n<td>GraphQL Response JSON</td>\n<td>Standard GraphQL response format</td>\n<td><code>{&quot;data&quot;: ..., &quot;errors&quot;: [...]}</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: Each transformation makes the data more specialized for the next stage&#39;s needs. The AST is optimized for tree traversal, the SQL is optimized for database execution, and the final JSON is optimized for client consumption. This separation allows each component to use the most appropriate data structure for its task.</p>\n</blockquote>\n<h4 id=\"common-pitfalls-in-data-flow-design\">Common Pitfalls in Data Flow Design</h4>\n<p>⚠️ <strong>Pitfall: Premature SQL Generation</strong></p>\n<ul>\n<li><strong>Description</strong>: Generating SQL immediately after parsing, before understanding the full query structure.</li>\n<li><strong>Why Wrong</strong>: Cannot optimize across nested relationships, leads to N+1 queries.</li>\n<li><strong>Fix</strong>: First build complete execution plan analyzing all nested selections, then generate optimized SQL with JOINs.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Losing Location Information</strong></p>\n<ul>\n<li><strong>Description</strong>: Not preserving source locations through the pipeline.</li>\n<li><strong>Why Wrong</strong>: Error messages cannot point to the exact location in the original query.</li>\n<li><strong>Fix</strong>: Every AST node should store its <code>Location</code> (line, column) and propagate it through transformations.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Mixing Validation and Execution</strong></p>\n<ul>\n<li><strong>Description</strong>: Performing validation during execution (e.g., checking field existence when resolving).</li>\n<li><strong>Why Wrong</strong>: Errors surface late, performance overhead on every execution.</li>\n<li><strong>Fix</strong>: Complete all validation before execution begins in a dedicated validation phase.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Inefficient Result Shaping</strong></p>\n<ul>\n<li><strong>Description</strong>: Transforming database rows to JSON by iterating over the AST for each row.</li>\n<li><strong>Why Wrong</strong>: O(n × m) complexity for n rows and m fields.</li>\n<li><strong>Fix</strong>: Pre-compute transformation mapping from column aliases to response paths, apply once per row.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning Focus)</th>\n<th>Advanced Option (Production Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTTP Server</strong></td>\n<td>Python <code>http.server</code> module</td>\n<td>FastAPI or Starlette with async support</td>\n</tr>\n<tr>\n<td><strong>Parser Implementation</strong></td>\n<td>Hand-written recursive descent parser</td>\n<td>Generated parser using ANTLR or Lark</td>\n</tr>\n<tr>\n<td><strong>Type Representation</strong></td>\n<td>Python classes with dict-based fields</td>\n<td>Immutable data classes with slots</td>\n</tr>\n<tr>\n<td><strong>Database Access</strong></td>\n<td>SQLite with <code>sqlite3</code> module</td>\n<td>PostgreSQL with <code>asyncpg</code> or SQLAlchemy</td>\n</tr>\n<tr>\n<td><strong>SQL Building</strong></td>\n<td>String concatenation with f-strings</td>\n<td>SQLAlchemy Core or custom query builder</td>\n</tr>\n<tr>\n<td><strong>Async Execution</strong></td>\n<td>Synchronous execution (simpler)</td>\n<td>Asyncio with concurrent resolvers</td>\n</tr>\n<tr>\n<td><strong>Testing</strong></td>\n<td><code>unittest</code> with mock databases</td>\n<td><code>pytest</code> with test containers</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-starter-project-structure\">B. Recommended Starter Project Structure</h4>\n<p>For learners starting the implementation, begin with this minimal structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>my-graphql-engine/\n├── src/\n│   └── graphql_engine/\n│       ├── __init__.py\n│       ├── parser.py        # Start with parser (Milestone 1)\n│       ├── types.py         # Add for Milestone 2\n│       ├── execution.py     # Add for Milestone 3\n│       ├── reflection.py    # Add for Milestone 4\n│       └── sql_compiler.py  # Add for Milestone 5\n└── tests/\n    ├── test_parser.py\n    ├── test_types.py\n    └── ...</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Here&#39;s complete starter code for the HTTP server layer (not the core learning goal but needed to run the engine):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/graphql_engine/server/http_handler.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">HTTP handler for GraphQL requests. This is infrastructure code that learners</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">can use as-is without implementing the HTTP layer themselves.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> http.server </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseHTTPRequestHandler, HTTPServer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> traceback</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLHTTPHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseHTTPRequestHandler</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles HTTP POST requests with GraphQL queries.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, graphql_executor, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initialize with a GraphQL executor function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.graphql_executor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> graphql_executor</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> do_POST</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle POST requests to /graphql endpoint.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.path </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '/graphql'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.headers.get(</span><span style=\"color:#9ECBFF\">'Content-Length'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> content_length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.wfile.write(</span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">'{\"error\": \"Empty request body\"}'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Read and parse JSON request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            body </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.rfile.read(content_length)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            request_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.loads(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Extract GraphQL query components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_data.get(</span><span style=\"color:#9ECBFF\">'query'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            variables </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_data.get(</span><span style=\"color:#9ECBFF\">'variables'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            operation_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_data.get(</span><span style=\"color:#9ECBFF\">'operationName'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> query:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Missing 'query' field in request\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Execute GraphQL query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.graphql_executor(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                query</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">query,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                variables</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">variables,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                operation_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">operation_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Send successful response</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_header(</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'application/json'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.wfile.write(json.dumps(result).encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> json.JSONDecodeError:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_header(</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'application/json'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.wfile.write(json.dumps({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"error\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Invalid JSON in request body\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }).encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Internal server error</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_header(</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'application/json'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            error_response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"error\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(e),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"traceback\"</span><span style=\"color:#E1E4E8\">: traceback.format_exc() </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.debug </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.wfile.write(json.dumps(error_response).encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> do_GET</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Serve GraphiQL interface at root path.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.path </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#F97583\"> or</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.path </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '/graphiql'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_header(</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'text/html'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.wfile.write(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._graphiql_html().encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.send_response(</span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_headers()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _graphiql_html</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return HTML for GraphiQL interface.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;!DOCTYPE html></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;html></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;head></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            &#x3C;title>GraphiQL&#x3C;/title></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            &#x3C;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/graphiql/0.17.5/graphiql.min.css\"></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;/head></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;body></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            &#x3C;div id=\"graphiql\" style=\"height: 100vh;\">&#x3C;/div></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.8.0/umd/react.production.min.js\">&#x3C;/script></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.8.0/umd/react-dom.production.min.js\">&#x3C;/script></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/graphiql/0.17.5/graphiql.min.js\">&#x3C;/script></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            &#x3C;script></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                function graphQLFetcher(params) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    return fetch('/graphql', {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        method: 'POST',</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        headers: {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                            'Content-Type': 'application/json',</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        },</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        body: JSON.stringify(params),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    }).then(response => response.json());</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                ReactDOM.render(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    React.createElement(GraphiQL, { fetcher: graphQLFetcher }),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    document.getElementById('graphiql')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                );</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            &#x3C;/script></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;/body></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;/html></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> log_message</span><span style=\"color:#E1E4E8\">(self, format, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Override to control logging output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Optional: Implement logging to file or stdout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.address_string()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> - </span><span style=\"color:#79B8FF\">{format</span><span style=\"color:#F97583\"> %</span><span style=\"color:#E1E4E8\"> args</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> start_server</span><span style=\"color:#E1E4E8\">(executor, host</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'localhost'</span><span style=\"color:#E1E4E8\">, port</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">8000</span><span style=\"color:#E1E4E8\">, debug</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Start HTTP server with GraphQL endpoint.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        executor: Function that accepts (query, variables, operation_name) </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                  and returns GraphQL response</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        host: Server hostname</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        port: Server port</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        debug: Enable debug mode with tracebacks in errors</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> GraphQLHTTPHandler(executor, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handler.debug </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> debug</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HTTPServer((host, port), handler)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"GraphQL server running at http://</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">host</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">port</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">/\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"GraphiQL interface at http://</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">host</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">port</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">/graphiql\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        server.serve_forever()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> KeyboardInterrupt</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Shutting down server...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        server.server_close()</span></span></code></pre></div>\n\n<h4 id=\"d-core-pipeline-skeleton-code\">D. Core Pipeline Skeleton Code</h4>\n<p>Here&#39;s the main execution pipeline that learners will implement component by component:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/graphql_engine/__init__.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Main GraphQL engine entry point. This orchestrates all components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .type_system </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLSchema, validate_query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .execution </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> execute_query </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> execute_query_internal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .reflection </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> reflect_schema_from_db</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .sql_compiler </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SQLCompiler</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main GraphQL engine coordinating all components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, schema: Optional[GraphQLSchema] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize engine with optional schema.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            schema: Pre-built GraphQL schema. If None, can be built from DB.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> schema</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.sql_compiler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SQLCompiler() </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> schema </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        query: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        variables: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operation_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Execute a GraphQL query through the complete pipeline.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            query: GraphQL query string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            variables: Dictionary of variable values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            operation_name: Name of operation to execute (if multiple in query)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            context: Execution context (auth, dataloaders, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            GraphQL response dictionary with 'data' and/or 'errors' keys</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            GraphQLError: For parsing, validation, or execution errors</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse query string into AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Call parse_query() to get Document AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Handle parse errors with proper error formatting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate query against schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Call validate_query() with schema and parsed AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Collect all validation errors (don't stop on first error)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If validation passes, execute query</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Call execute_query_internal() with schema, AST, variables, context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   This will internally use SQL compiler for database fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Format response according to GraphQL spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Ensure response has 'data' key (even if null)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Include 'errors' key only if errors occurred</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Preserve error paths and locations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> reflect_schema_from_database</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        connection_string: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dialect: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"postgresql\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate GraphQL schema from database metadata.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            connection_string: Database connection string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            dialect: Database dialect ('postgresql', 'mysql', 'sqlite')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Connect to database using appropriate adapter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Use connection_string to establish database connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Introspect database metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Query information_schema for tables, columns, foreign keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Detect relationships and primary keys</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Generate GraphQL types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Create GraphQLObjectType for each table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Map SQL types to GraphQL scalar types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Create fields for relationships</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Build complete schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Create Query type with root fields for each table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Add mutations for create/update/delete operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Register custom resolvers for relationship fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Initialize SQL compiler with schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Create SQLCompiler instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Pass table/relationship metadata for query planning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-for-python\">E. Language-Specific Hints for Python</h4>\n<ul>\n<li><strong>Use Python&#39;s <code>enum.Enum</code></strong> for token types and AST node types for type safety</li>\n<li><strong>Use <code>@dataclass</code> decorator</strong> for AST nodes to automatically get <code>__init__</code>, <code>__repr__</code>, and equality methods</li>\n<li><strong>Use <code>typing</code> module extensively</strong> for type hints—helps catch errors early and serves as documentation</li>\n<li><strong>For recursive structures</strong> (like ASTs), use forward references with string literals: <code>&#39;Node&#39;</code> instead of <code>Node</code></li>\n<li><strong>Use Python&#39;s <code>contextvars</code></strong> for execution context that propagates through async calls</li>\n<li><strong>For SQL parameterization</strong>, always use query parameters (<code>?</code> or <code>%s</code>) never string formatting to prevent injection</li>\n<li><strong>Use <code>asyncio.gather()</code></strong> for parallel resolver execution when implementing async version</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint-for-high-level-architecture\">F. Milestone Checkpoint for High-Level Architecture</h4>\n<p>After setting up the project structure (before implementing any components):</p>\n<ol>\n<li><p><strong>Verify Structure</strong>: Run <code>tree my-graphql-engine/</code> (or equivalent) to confirm directory structure matches recommendations.</p>\n</li>\n<li><p><strong>Test HTTP Starter</strong>: Create a simple test file to verify the HTTP server works:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # test_server.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> src.graphql_engine.server.http_handler </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> start_server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   def</span><span style=\"color:#B392F0\"> dummy_executor</span><span style=\"color:#E1E4E8\">(query, variables, operation_name):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"data\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Hello GraphQL\"</span><span style=\"color:#E1E4E8\">}}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"__main__\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       # Should start server on localhost:8000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       start_server(dummy_executor, </span><span style=\"color:#FFAB70\">debug</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n<ul>\n<li>Expected: Server starts, visit <code>http://localhost:8000/graphiql</code> shows GraphiQL interface</li>\n<li>Send test query <code>{ test }</code> should return <code>{&quot;data&quot;: {&quot;test&quot;: &quot;Hello GraphQL&quot;}}</code></li>\n</ul>\n<ol start=\"3\">\n<li><strong>Import Check</strong>: Create <code>src/graphql_engine/__init__.py</code> with the skeleton <code>GraphQLEngine</code> class above. Verify no syntax errors:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> py_compile</span><span style=\"color:#9ECBFF\"> src/graphql_engine/__init__.py</span></span></code></pre></div>\n\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>❌ &quot;ModuleNotFoundError: No module named &#39;graphql_engine&#39;&quot; → Check PYTHONPATH or install package in development mode (<code>pip install -e .</code>)</li>\n<li>❌ HTTP server fails to start → Port 8000 might be in use, try <code>port=8001</code></li>\n<li>❌ GraphiQL interface doesn&#39;t load → Check internet connection (CDN resources) or use local GraphiQL build</li>\n</ul>\n<h4 id=\"g-debugging-tips-for-architecture-issues\">G. Debugging Tips for Architecture Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Circular import error</td>\n<td>Components importing each other</td>\n<td>Check import statements in each module</td>\n<td>Reorganize to follow layered dependencies (Parser → Type System → Execution)</td>\n</tr>\n<tr>\n<td>Memory usage grows with queries</td>\n<td>AST nodes not being garbage collected</td>\n<td>Use <code>tracemalloc</code> to track allocations</td>\n<td>Ensure AST nodes don&#39;t hold references to execution state</td>\n</tr>\n<tr>\n<td>Response missing nested data</td>\n<td>Result shaping not handling joins properly</td>\n<td>Log raw database rows and compare to expected structure</td>\n<td>Check SQL compiler column aliasing and result mapping logic</td>\n</tr>\n<tr>\n<td>Queries slow with depth</td>\n<td>Generating separate SQL per level instead of joins</td>\n<td>Enable SQL logging and count queries</td>\n<td>Implement join detection in SQL compiler for nested fields</td>\n</tr>\n<tr>\n<td>Can&#39;t find database tables</td>\n<td>Reflection querying wrong schema</td>\n<td>Log the exact SQL used for introspection</td>\n<td>Check database permissions and schema name in connection</td>\n</tr>\n</tbody></table>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the foundational data structures that underpin all five milestones. The AST node types (Milestone 1) capture the parsed query, the type system types (Milestone 2) define the schema, the execution context (Milestone 3) manages runtime state, and the SQL intermediate representation (Milestone 5) bridges the GraphQL and SQL worlds.</p>\n</blockquote>\n<p>The data model is the backbone of our GraphQL engine—it defines how we represent GraphQL queries, schemas, execution state, and database operations in memory. Think of it as the <strong>blueprint language</strong> that all components use to communicate. If the components were departments in a company (parsing, execution, compilation), the data model would be the standard forms and documents they exchange.</p>\n<p>This section details four core families of data structures:</p>\n<ol>\n<li><strong>AST Node Types</strong>: The parsed, in-memory tree representation of a GraphQL query string.</li>\n<li><strong>Type System Types</strong>: The definitions of allowed data shapes (scalars, objects, etc.) that constitute a GraphQL schema.</li>\n<li><strong>Execution Context and State</strong>: The runtime workspace that tracks progress, errors, and shared data during query resolution.</li>\n<li><strong>SQL Intermediate Representation (IR)</strong>: A bridge structure that captures the intent of a GraphQL query in SQL terms before generating the final SQL string.</li>\n</ol>\n<h3 id=\"ast-node-types\">AST Node Types</h3>\n<p><strong>Mental Model: The Family Tree</strong>\nThink of a GraphQL query as a family tree. The <code>Document</code> is the entire family (the query document). <code>OperationDefinition</code> nodes are the main branches (query, mutation, subscription). Each branch has smaller twigs (<code>SelectionSet</code>), which hold leaves (<code>Field</code>). Some leaves have their own mini-branches (nested <code>SelectionSet</code>). Fragments are like sub-trees that can be grafted onto multiple branches. The AST is this entire family tree drawn on paper, with every member&#39;s name, location, and relationships explicitly recorded.</p>\n<p>The Abstract Syntax Tree (AST) is the primary output of the parser (Milestone 1). It is a lossless, structured representation of the GraphQL query string that preserves every syntactic detail—field names, arguments, directives, fragment spreads, and their exact locations in the source text. This tree is what the execution engine and SQL compiler will later traverse.</p>\n<p>All AST nodes inherit from a base <code>Node</code> type, which provides source location tracking. This is crucial for meaningful error messages (e.g., &quot;Argument &#39;id&#39; expected type &#39;ID!&#39; at line 5, column 12&quot;).</p>\n<h4 id=\"core-ast-node-hierarchy-and-data-structures\">Core AST Node Hierarchy and Data Structures</h4>\n<p>The following table details the complete hierarchy and fields of each AST node type. The inheritance relationship is: <code>Document</code> → <code>Definition</code> → <code>OperationDefinition</code> → <code>SelectionSet</code> → <code>Selection</code> → <code>Field</code>. Parallel branches exist for fragments and other definitions.</p>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Parent Type</th>\n<th>Fields</th>\n<th>Field Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Location</code></td>\n<td>(none)</td>\n<td><code>line</code></td>\n<td><code>int</code></td>\n<td>1-indexed line number in the source text.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>column</code></td>\n<td><code>int</code></td>\n<td>1-indexed column number in the source text.</td>\n</tr>\n<tr>\n<td><code>Node</code></td>\n<td>(none)</td>\n<td><code>loc</code></td>\n<td><code>Optional[Location]</code></td>\n<td>Source location of this node. Present if the parser was configured to include it.</td>\n</tr>\n<tr>\n<td><code>Document</code></td>\n<td><code>Node</code></td>\n<td><code>definitions</code></td>\n<td><code>List[Definition]</code></td>\n<td>List of operation and fragment definitions in this document.</td>\n</tr>\n<tr>\n<td><code>Definition</code></td>\n<td><code>Node</code></td>\n<td>(none, base class)</td>\n<td></td>\n<td>Abstract base for definitions in a document.</td>\n</tr>\n<tr>\n<td><code>OperationDefinition</code></td>\n<td><code>Definition</code></td>\n<td><code>operation_type</code></td>\n<td><code>str</code></td>\n<td>One of: &quot;query&quot;, &quot;mutation&quot;, &quot;subscription&quot;.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>name</code></td>\n<td><code>Optional[str]</code></td>\n<td>Optional name of the operation (e.g., &quot;GetUser&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>variable_definitions</code></td>\n<td><code>List[VariableDefinition]</code></td>\n<td>Variable declarations (<code>($id: ID!)</code>).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>directives</code></td>\n<td><code>List[Directive]</code></td>\n<td>Operation-level directives (e.g., <code>@deprecated</code>).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>selection_set</code></td>\n<td><code>SelectionSet</code></td>\n<td>The root selection set of fields to fetch.</td>\n</tr>\n<tr>\n<td><code>FragmentDefinition</code></td>\n<td><code>Definition</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Name of the fragment (e.g., &quot;UserFields&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>type_condition</code></td>\n<td><code>NamedType</code></td>\n<td>The type this fragment applies to (e.g., <code>User</code>).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>directives</code></td>\n<td><code>List[Directive]</code></td>\n<td>Fragment-level directives.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>selection_set</code></td>\n<td><code>SelectionSet</code></td>\n<td>The selection set of fields to include when this fragment is spread.</td>\n</tr>\n<tr>\n<td><code>SelectionSet</code></td>\n<td><code>Node</code></td>\n<td><code>selections</code></td>\n<td><code>List[Selection]</code></td>\n<td>List of fields, fragment spreads, or inline fragments.</td>\n</tr>\n<tr>\n<td><code>Selection</code></td>\n<td><code>Node</code></td>\n<td>(none, base class)</td>\n<td></td>\n<td>Abstract base for items in a selection set.</td>\n</tr>\n<tr>\n<td><code>Field</code></td>\n<td><code>Selection</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>The name of the field as defined in the schema (e.g., &quot;email&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>alias</code></td>\n<td><code>Optional[str]</code></td>\n<td>Optional alias for the field (e.g., &quot;userEmail: email&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>arguments</code></td>\n<td><code>List[Argument]</code></td>\n<td>List of arguments provided to this field.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>directives</code></td>\n<td><code>List[Directive]</code></td>\n<td>Field-level directives (e.g., <code>@include(if: $show)</code>).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>selection_set</code></td>\n<td><code>Optional[SelectionSet]</code></td>\n<td>Nested selection set for object-type fields. <code>None</code> for scalar fields.</td>\n</tr>\n<tr>\n<td><code>FragmentSpread</code></td>\n<td><code>Selection</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Name of the fragment to spread (e.g., &quot;UserFields&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>directives</code></td>\n<td><code>List[Directive]</code></td>\n<td>Directives applied to this spread.</td>\n</tr>\n<tr>\n<td><code>InlineFragment</code></td>\n<td><code>Selection</code></td>\n<td><code>type_condition</code></td>\n<td><code>Optional[NamedType]</code></td>\n<td>Optional type condition (e.g., <code>... on User</code>). If <code>None</code>, it&#39;s an unconditional inline fragment.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>directives</code></td>\n<td><code>List[Directive]</code></td>\n<td>Directives applied to this inline fragment.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>selection_set</code></td>\n<td><code>SelectionSet</code></td>\n<td>The selection set for this fragment.</td>\n</tr>\n<tr>\n<td><code>Argument</code></td>\n<td><code>Node</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Name of the argument (e.g., &quot;id&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>value</code></td>\n<td><code>Value</code></td>\n<td>The value provided, which can be a literal, variable, list, or object.</td>\n</tr>\n<tr>\n<td><code>Directive</code></td>\n<td><code>Node</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Name of the directive (e.g., &quot;include&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>arguments</code></td>\n<td><code>List[Argument]</code></td>\n<td>Arguments passed to the directive.</td>\n</tr>\n<tr>\n<td><code>VariableDefinition</code></td>\n<td><code>Node</code></td>\n<td><code>variable</code></td>\n<td><code>Variable</code></td>\n<td>The variable being defined (e.g., <code>$id</code>).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>type</code></td>\n<td><code>Type</code></td>\n<td>The expected GraphQL type (e.g., <code>ID!</code>).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>default_value</code></td>\n<td><code>Optional[Value]</code></td>\n<td>Optional default value if the variable is not provided.</td>\n</tr>\n<tr>\n<td><code>Variable</code></td>\n<td><code>Value</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Name of the variable without the <code>$</code> prefix (e.g., &quot;id&quot;).</td>\n</tr>\n<tr>\n<td><code>NamedType</code></td>\n<td><code>Type</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Name of the referenced type (e.g., &quot;User&quot;, &quot;ID&quot;).</td>\n</tr>\n<tr>\n<td><code>ListType</code></td>\n<td><code>Type</code></td>\n<td><code>type</code></td>\n<td><code>Type</code></td>\n<td>The type of items in the list (e.g., <code>[String]</code>).</td>\n</tr>\n<tr>\n<td><code>NonNullType</code></td>\n<td><code>Type</code></td>\n<td><code>type</code></td>\n<td><code>Type</code></td>\n<td>The wrapped type that is made non-null (e.g., <code>String!</code>).</td>\n</tr>\n<tr>\n<td><code>Value</code></td>\n<td><code>Node</code></td>\n<td>(none, base class)</td>\n<td></td>\n<td>Abstract base for all value literals and variables.</td>\n</tr>\n<tr>\n<td><code>IntValue</code></td>\n<td><code>Value</code></td>\n<td><code>value</code></td>\n<td><code>int</code></td>\n<td>Integer literal (e.g., <code>42</code>).</td>\n</tr>\n<tr>\n<td><code>FloatValue</code></td>\n<td><code>Value</code></td>\n<td><code>value</code></td>\n<td><code>float</code></td>\n<td>Floating-point literal (e.g., <code>3.14</code>).</td>\n</tr>\n<tr>\n<td><code>StringValue</code></td>\n<td><code>Value</code></td>\n<td><code>value</code></td>\n<td><code>str</code></td>\n<td>String literal (e.g., <code>&quot;hello&quot;</code>).</td>\n</tr>\n<tr>\n<td><code>BooleanValue</code></td>\n<td><code>Value</code></td>\n<td><code>value</code></td>\n<td><code>bool</code></td>\n<td>Boolean literal (<code>true</code> or <code>false</code>).</td>\n</tr>\n<tr>\n<td><code>EnumValue</code></td>\n<td><code>Value</code></td>\n<td><code>value</code></td>\n<td><code>str</code></td>\n<td>Enum literal (e.g., <code>PUBLISHED</code>).</td>\n</tr>\n<tr>\n<td><code>NullValue</code></td>\n<td><code>Value</code></td>\n<td>(none)</td>\n<td></td>\n<td>Represents the literal <code>null</code>.</td>\n</tr>\n<tr>\n<td><code>ListValue</code></td>\n<td><code>Value</code></td>\n<td><code>values</code></td>\n<td><code>List[Value]</code></td>\n<td>List of values (e.g., <code>[&quot;a&quot;, &quot;b&quot;]</code>).</td>\n</tr>\n<tr>\n<td><code>ObjectValue</code></td>\n<td><code>Value</code></td>\n<td><code>fields</code></td>\n<td><code>List[ObjectField]</code></td>\n<td>Key-value pairs (e.g., <code>{x: 1, y: 2}</code>).</td>\n</tr>\n<tr>\n<td><code>ObjectField</code></td>\n<td><code>Node</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Field name in the object literal.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>value</code></td>\n<td><code>Value</code></td>\n<td>The value for this field.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Immutable AST</strong></p>\n<ul>\n<li><strong>Context</strong>: The AST is produced by the parser and then read by multiple downstream components (validator, executor, compiler). These components may traverse the tree concurrently or in multiple passes.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Mutable AST with parent pointers</strong>: Nodes contain references to their parent, allowing easy upward traversal. Nodes can be modified in-place (e.g., fragment expansion).</li>\n<li><strong>Immutable AST without parent pointers</strong>: Nodes are frozen after creation; traversal is only downward via children. Modifications require creating new trees.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Immutable AST without parent pointers.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Thread Safety</strong>: Immutability guarantees safe concurrent traversal, which is useful for parallel field execution and static analysis.</li>\n<li><strong>Predictability</strong>: The AST reflects exactly what was parsed, making debugging easier. Fragment expansion can be done as a separate transformation pass that produces a new tree.</li>\n<li><strong>Simpler Memory Management</strong>: No circular references (parent-child) ease garbage collection in some languages and prevent accidental leaks.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Fragment expansion and other transformations must copy the affected subtree, which has a memory/performance cost.</li>\n<li>Traversing upward (e.g., from a field to its enclosing operation) requires external context tracking or a separate visitor pattern that maintains a stack.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Common Pitfalls in AST Design:</strong></p>\n<ul>\n<li>⚠️ <strong>Pitfall: Forgetting Location Tracking</strong><ul>\n<li><strong>Description</strong>: Omitting the <code>loc</code> field or not populating it during parsing.</li>\n<li><strong>Why it&#39;s wrong</strong>: Error messages become useless (&quot;Error in query&quot; without line/column). Debugging complex queries becomes a guessing game.</li>\n<li><strong>Fix</strong>: Ensure every node created by the parser receives a <code>Location</code> object. The tokenizer must track line/column numbers for each token.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: Mixing Value and Type Hierarchies</strong><ul>\n<li><strong>Description</strong>: Representing <code>IntValue</code> and <code>IntType</code> with the same class because both contain an integer.</li>\n<li><strong>Why it&#39;s wrong</strong>: They are fundamentally different concepts. A value is a runtime literal; a type is a schema definition. Merging them causes confusion in later stages (e.g., type checking).</li>\n<li><strong>Fix</strong>: Maintain separate class hierarchies for <code>Value</code> and <code>Type</code> nodes, even if they look similar.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: Overlooking Directive Locations</strong><ul>\n<li><strong>Description</strong>: Not storing directives on all applicable AST nodes (operations, fields, fragments, etc.).</li>\n<li><strong>Why it&#39;s wrong</strong>: Directives like <code>@include</code>, <code>@skip</code>, or custom directives are part of the query semantics and must be available to the executor.</li>\n<li><strong>Fix</strong>: Include a <code>directives: List[Directive]</code> field on every node type that can have directives per the GraphQL spec.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"type-system-types\">Type System Types</h3>\n<p><strong>Mental Model: The Building Code</strong>\nIf the GraphQL schema were a city, the type system would be its building code. It defines what structures are allowed (<code>ObjectType</code> = houses, <code>ScalarType</code> = bricks), how they connect (<code>InterfaceType</code> = blueprints for neighborhoods), and the rules they must follow (<code>NonNull</code> = required safety features). Just as a building inspector ensures constructions follow the code, the type system validates that queries and data conform to the schema.</p>\n<p>The type system represents the GraphQL schema defined by the user or reflected from the database (Milestone 2, Milestone 4). It is a runtime model used to validate queries, guide execution, and generate introspection responses. Each GraphQL type kind has a corresponding class, with a common base <code>GraphQLType</code>.</p>\n<h4 id=\"type-system-class-hierarchy-and-data-structures\">Type System Class Hierarchy and Data Structures</h4>\n<p>The following table details all type system classes, their fields, and purposes. The hierarchy is: <code>GraphQLType</code> → <code>ScalarType</code>, <code>ObjectType</code>, <code>InterfaceType</code>, <code>UnionType</code>, <code>EnumType</code>, <code>InputObjectType</code>, with wrapper types <code>ListType</code> and <code>NonNullType</code> also extending <code>GraphQLType</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Parent Type</th>\n<th>Fields</th>\n<th>Field Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GraphQLType</code></td>\n<td>(none)</td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>The name of the type (e.g., &quot;User&quot;, &quot;ID&quot;). For wrapper types, this is often derived (e.g., &quot;[User]&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>description</code></td>\n<td><code>Optional[str]</code></td>\n<td>Optional description for documentation/introspection.</td>\n</tr>\n<tr>\n<td><code>ScalarType</code></td>\n<td><code>GraphQLType</code></td>\n<td><code>serialize</code></td>\n<td><code>Callable[[Any], Any]</code></td>\n<td>Function to convert a Python value to a suitable output format (e.g., datetime to ISO string).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>parse_value</code></td>\n<td><code>Callable[[Any], Any]</code></td>\n<td>Function to convert a variable value (JSON) to the internal representation.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>parse_literal</code></td>\n<td><code>Callable[[Value], Any]</code></td>\n<td>Function to convert an AST literal node to the internal representation.</td>\n</tr>\n<tr>\n<td><code>ObjectType</code></td>\n<td><code>GraphQLType</code></td>\n<td><code>fields</code></td>\n<td><code>Dict[str, GraphQLField]</code></td>\n<td>Map of field name to field definition.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>interfaces</code></td>\n<td><code>List[InterfaceType]</code></td>\n<td>List of interfaces this object implements.</td>\n</tr>\n<tr>\n<td><code>GraphQLField</code></td>\n<td>(none)</td>\n<td><code>type</code></td>\n<td><code>GraphQLType</code></td>\n<td>The return type of this field.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>args</code></td>\n<td><code>Dict[str, GraphQLArgument]</code></td>\n<td>Map of argument name to argument definition.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>resolve</code></td>\n<td><code>Optional[Callable]</code></td>\n<td>Optional resolver function. If <code>None</code>, a default property resolver is used.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>description</code></td>\n<td><code>Optional[str]</code></td>\n<td>Field description.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>deprecation_reason</code></td>\n<td><code>Optional[str]</code></td>\n<td>If set, the field is deprecated with this reason.</td>\n</tr>\n<tr>\n<td><code>GraphQLArgument</code></td>\n<td>(none)</td>\n<td><code>type</code></td>\n<td><code>GraphQLType</code></td>\n<td>The expected type of the argument.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>default_value</code></td>\n<td><code>Any</code></td>\n<td>Default value if the argument is not provided.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>description</code></td>\n<td><code>Optional[str]</code></td>\n<td>Argument description.</td>\n</tr>\n<tr>\n<td><code>InterfaceType</code></td>\n<td><code>GraphQLType</code></td>\n<td><code>fields</code></td>\n<td><code>Dict[str, GraphQLField]</code></td>\n<td>Map of field name to field definition (abstract).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>resolve_type</code></td>\n<td><code>Optional[Callable[[Any], ObjectType]]</code></td>\n<td>Optional function to determine the concrete object type for a given value.</td>\n</tr>\n<tr>\n<td><code>UnionType</code></td>\n<td><code>GraphQLType</code></td>\n<td><code>types</code></td>\n<td><code>List[ObjectType]</code></td>\n<td>List of possible object types that this union can represent.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>resolve_type</code></td>\n<td><code>Optional[Callable[[Any], ObjectType]]</code></td>\n<td>Optional function to determine the concrete object type for a given value.</td>\n</tr>\n<tr>\n<td><code>EnumType</code></td>\n<td><code>GraphQLType</code></td>\n<td><code>values</code></td>\n<td><code>Dict[str, EnumValue]</code></td>\n<td>Map of enum value name to its definition.</td>\n</tr>\n<tr>\n<td><code>EnumValue</code></td>\n<td>(none)</td>\n<td><code>value</code></td>\n<td><code>Any</code></td>\n<td>The underlying value (often a string matching the name).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>description</code></td>\n<td><code>Optional[str]</code></td>\n<td>Description of this enum value.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>deprecation_reason</code></td>\n<td><code>Optional[str]</code></td>\n<td>Deprecation reason, if applicable.</td>\n</tr>\n<tr>\n<td><code>InputObjectType</code></td>\n<td><code>GraphQLType</code></td>\n<td><code>fields</code></td>\n<td><code>Dict[str, GraphQLInputField]</code></td>\n<td>Map of field name to input field definition.</td>\n</tr>\n<tr>\n<td><code>GraphQLInputField</code></td>\n<td>(none)</td>\n<td><code>type</code></td>\n<td><code>GraphQLType</code></td>\n<td>The expected type of the input field.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>default_value</code></td>\n<td><code>Any</code></td>\n<td>Default value if not provided.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>description</code></td>\n<td><code>Optional[str]</code></td>\n<td>Field description.</td>\n</tr>\n<tr>\n<td><code>ListType</code></td>\n<td><code>GraphQLType</code></td>\n<td><code>of_type</code></td>\n<td><code>GraphQLType</code></td>\n<td>The type of items in the list.</td>\n</tr>\n<tr>\n<td><code>NonNullType</code></td>\n<td><code>GraphQLType</code></td>\n<td><code>of_type</code></td>\n<td><code>GraphQLType</code></td>\n<td>The wrapped type that is made non-null.</td>\n</tr>\n<tr>\n<td><code>Schema</code></td>\n<td>(none)</td>\n<td><code>query_type</code></td>\n<td><code>ObjectType</code></td>\n<td>The root query object type.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>mutation_type</code></td>\n<td><code>Optional[ObjectType]</code></td>\n<td>Optional root mutation object type.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>subscription_type</code></td>\n<td><code>Optional[ObjectType]</code></td>\n<td>Optional root subscription object type.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>types</code></td>\n<td><code>Dict[str, GraphQLType]</code></td>\n<td>Map of all named types in the schema, keyed by name.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>directives</code></td>\n<td><code>Dict[str, GraphQLDirective]</code></td>\n<td>Map of all directives supported by the schema.</td>\n</tr>\n<tr>\n<td><code>GraphQLDirective</code></td>\n<td>(none)</td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Name of the directive (e.g., &quot;include&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>locations</code></td>\n<td><code>List[str]</code></td>\n<td>Where this directive can be used (e.g., [&quot;FIELD&quot;, &quot;FRAGMENT_SPREAD&quot;]).</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>args</code></td>\n<td><code>Dict[str, GraphQLArgument]</code></td>\n<td>Arguments the directive accepts.</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><code>description</code></td>\n<td><code>Optional[str]</code></td>\n<td>Directive description.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Dual-Type Representation for Wrappers</strong></p>\n<ul>\n<li><strong>Context</strong>: GraphQL has type modifiers: <code>List</code> and <code>NonNull</code>. These can be nested (e.g., <code>[String!]!</code>). We need to represent these in memory for type validation and introspection.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Inline flags</strong>: Add <code>is_list</code> and <code>is_non_null</code> boolean fields to <code>GraphQLType</code>, with an <code>inner_type</code> field for the wrapped type. Nesting is represented by chaining <code>inner_type</code>.</li>\n<li><strong>Wrapper objects</strong>: Create separate <code>ListType</code> and <code>NonNullType</code> classes that wrap another <code>GraphQLType</code>. Nesting is represented by a chain of wrapper objects.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Wrapper objects (<code>ListType</code>, <code>NonNullType</code>).</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Spec Compliance</strong>: The GraphQL introspection system returns wrapper types as separate objects with <code>kind</code> fields. The wrapper object approach maps directly to this.</li>\n<li><strong>Type Safety</strong>: The type system can use isinstance checks (<code>isinstance(t, ListType)</code>) which is clearer than checking boolean flags.</li>\n<li><strong>Recursive Simplicity</strong>: Algorithms for unwrapping (e.g., getting the underlying named type) become simple loops (<code>while isinstance(t, WrapperType): t = t.of_type</code>).</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Slightly more memory overhead due to many small objects.</li>\n<li>Equality checks require recursive traversal (e.g., two <code>[String!]</code> types are equal only if their inner types are equal).</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Common Pitfalls in Type System Design:</strong></p>\n<ul>\n<li>⚠️ <strong>Pitfall: Confusing Input and Output Types</strong><ul>\n<li><strong>Description</strong>: Using the same class for <code>ObjectType</code> and <code>InputObjectType</code>, or allowing input types to be used as output field types.</li>\n<li><strong>Why it&#39;s wrong</strong>: GraphQL strictly separates input and output types. Input types cannot have arguments or interfaces; output types cannot be used as argument types. Mixing them leads to validation errors and runtime confusion.</li>\n<li><strong>Fix</strong>: Maintain separate class hierarchies for input and output types, with validation during schema building that ensures correct usage.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: Missing Circular Reference Detection</strong><ul>\n<li><strong>Description</strong>: Allowing a type to reference itself indefinitely (e.g., <code>type User { friends: [User] }</code> is valid, but <code>type Circular { field: Circular }</code> as an input type is not).</li>\n<li><strong>Why it&#39;s wrong</strong>: GraphQL forbids circular references in input types. Infinite recursion during validation or serialization can crash the engine.</li>\n<li><strong>Fix</strong>: During schema building, perform a depth-first search to detect cycles in input type references, and raise a validation error.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: Forgetting Introspection Types</strong><ul>\n<li><strong>Description</strong>: Not including the built-in introspection types (<code>__Schema</code>, <code>__Type</code>, <code>__Field</code>, etc.) in the schema&#39;s type map.</li>\n<li><strong>Why it&#39;s wrong</strong>: GraphQL introspection queries (used by tools like GraphiQL) will fail, breaking developer experience.</li>\n<li><strong>Fix</strong>: Always add the introspection types to the schema&#39;s <code>types</code> dictionary. They can be generated statically.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"execution-context-and-state\">Execution Context and State</h3>\n<p><strong>Mental Model: The Restaurant Ticket</strong>\nImagine a GraphQL query as a customer&#39;s order at a restaurant. The <strong>execution context</strong> is the kitchen ticket attached to that order. It tracks the order&#39;s progress through different stations (resolvers), any special instructions (context variables like allergy info), errors (&quot;86 salmon&quot;), and the final assembled dishes (data). As the ticket moves through the kitchen, each station adds its output and notes.</p>\n<p>The execution context holds all runtime information needed to resolve a GraphQL query (Milestone 3). It is passed to every resolver function, providing access to shared resources, the current field&#39;s information, and a place to collect errors. It also manages the <strong>DataLoader</strong> instances that batch and cache database requests to solve the N+1 problem.</p>\n<h4 id=\"execution-state-data-structures\">Execution State Data Structures</h4>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Fields</th>\n<th>Field Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ExecutionContext</code></td>\n<td><code>schema</code></td>\n<td><code>Schema</code></td>\n<td>The GraphQL schema being executed against.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>document_ast</code></td>\n<td><code>Document</code></td>\n<td>The parsed AST of the operation to execute.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>operation_name</code></td>\n<td><code>Optional[str]</code></td>\n<td>Name of the operation to execute (if multiple in document).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>variable_values</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Map of variable name to coerced value.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>context_value</code></td>\n<td><code>Any</code></td>\n<td>The user-provided context object (often includes database connection, auth info).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>root_value</code></td>\n<td><code>Any</code></td>\n<td>The initial value for the root type (often <code>None</code>).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>fragments</code></td>\n<td><code>Dict[str, FragmentDefinition]</code></td>\n<td>Map of fragment name to AST definition, for quick lookup.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>errors</code></td>\n<td><code>List[GraphQLError]</code></td>\n<td>Errors collected during execution.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>data_loaders</code></td>\n<td><code>Dict[str, DataLoader]</code></td>\n<td>Map of loader name to DataLoader instance for batching.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>path</code></td>\n<td><code>List[PathSegment]</code></td>\n<td>Current execution path as a stack (e.g., <code>[&quot;user&quot;, &quot;friends&quot;, 0, &quot;name&quot;]</code>).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>field_resolver</code></td>\n<td><code>Callable</code></td>\n<td>The default field resolver function (falls back to property access).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>type_resolver</code></td>\n<td><code>Callable</code></td>\n<td>The default type resolver for abstract types.</td>\n</tr>\n<tr>\n<td><code>GraphQLError</code></td>\n<td><code>message</code></td>\n<td><code>str</code></td>\n<td>Human-readable error message.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>locations</code></td>\n<td><code>List[Location]</code></td>\n<td>Source locations where the error occurred (from AST nodes).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>path</code></td>\n<td><code>List[PathSegment]</code></td>\n<td>Execution path to the field where the error originated.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>original_error</code></td>\n<td><code>Optional[Exception]</code></td>\n<td>The underlying exception that caused this error, if any.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>extensions</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Optional map for custom error metadata.</td>\n</tr>\n<tr>\n<td><code>PathSegment</code></td>\n<td>(union type)</td>\n<td><code>str | int</code></td>\n<td>Either a field name (for object fields) or an index (for list items).</td>\n</tr>\n<tr>\n<td><code>DataLoader</code></td>\n<td><code>batch_load_fn</code></td>\n<td><code>Callable[[List[Any]], List[Any]]</code></td>\n<td>Function that receives a list of keys and returns a list of values or promises.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>cache</code></td>\n<td><code>Dict[Any, Any]</code></td>\n<td>Map of key to resolved value (or promise).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>queue</code></td>\n<td><code>List[Any]</code></td>\n<td>Keys pending batch resolution.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>max_batch_size</code></td>\n<td><code>int</code></td>\n<td>Maximum number of keys to batch in one call.</td>\n</tr>\n<tr>\n<td><code>ExecutionResult</code></td>\n<td><code>data</code></td>\n<td><code>Optional[Dict[str, Any]]</code></td>\n<td>The result data if execution succeeded (partial data may be present even with errors).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>errors</code></td>\n<td><code>List[GraphQLError]</code></td>\n<td>Errors encountered during execution.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>extensions</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Optional extension metadata for the response.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Mutable Execution Context vs. Immutable Per-Resolve Context</strong></p>\n<ul>\n<li><strong>Context</strong>: Resolver functions need access to execution state (path, variables, context value). This state changes as execution traverses the query tree.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Mutable shared context</strong>: A single <code>ExecutionContext</code> object passed to all resolvers, with mutable fields like <code>path</code> updated in-place as execution depth changes.</li>\n<li><strong>Immutable per-resolve context</strong>: Create a new context object for each field resolution, copying or deriving state (e.g., appending to path).</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Mutable shared context with careful stack management.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Performance</strong>: Creating new context objects for every field (potentially thousands) adds overhead. Mutation is cheaper.</li>\n<li><strong>Simplicity</strong>: The path can be managed as an explicit stack: push before resolving a field, pop after. This mirrors the natural recursion of execution.</li>\n<li><strong>Predictability</strong>: The context is single-threaded per request, so mutability is safe. Concurrency is handled at the field level via async, not threads.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Resolvers must not modify context fields they shouldn&#39;t (e.g., they shouldn&#39;t mutate <code>path</code> directly). Provide helper methods (<code>context.push_path(), context.pop_path()</code>).</li>\n<li>Special care needed for parallel execution of sibling fields—each parallel branch needs a snapshot of the path or must coordinate to avoid corrupting the shared path.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Algorithm for Field Execution with Context:</strong></p>\n<ol>\n<li><strong>Initialize context</strong>: Create <code>ExecutionContext</code> with schema, document, variables, root value, and empty error list.</li>\n<li><strong>Select operation</strong>: If <code>operation_name</code> is provided, find the matching <code>OperationDefinition</code> in the document; otherwise, if there&#39;s exactly one operation, use it.</li>\n<li><strong>Coerce variables</strong>: For each <code>VariableDefinition</code> in the operation, coerce the input <code>variable_values</code> using the variable&#39;s type. Add errors to context for invalid values.</li>\n<li><strong>Execute operation</strong>: Call <code>execute_operation(context, root_type, root_value)</code>:<ol>\n<li>Determine the root object type (<code>query_type</code>, <code>mutation_type</code>, or <code>subscription_type</code>).</li>\n<li>Create a <code>SelectionSet</code> from the operation&#39;s <code>selection_set</code>.</li>\n<li>Call <code>execute_fields(context, root_type, root_value, selection_set)</code>.</li>\n</ol>\n</li>\n<li><strong>Execute fields</strong> (recursive):<ol>\n<li>Create an empty <code>result_dict</code>.</li>\n<li>For each <code>selection</code> in the <code>selection_set</code>:<ul>\n<li>If selection is a <code>Field</code>:<ol>\n<li><strong>Push path</strong>: Append field&#39;s alias or name to <code>context.path</code>.</li>\n<li><strong>Resolve field</strong>: Call <code>resolve_field(context, parent_type, parent_value, field)</code>.</li>\n<li><strong>Pop path</strong>: Remove the last element from <code>context.path</code>.</li>\n<li>Store the resolved value in <code>result_dict</code> under the output key (alias or name).</li>\n</ol>\n</li>\n<li>If selection is a <code>FragmentSpread</code> or <code>InlineFragment</code>:<ol>\n<li>Check type condition against <code>parent_type</code>. If it doesn&#39;t apply, skip.</li>\n<li>Recursively <code>execute_fields</code> with the fragment&#39;s <code>selection_set</code>.</li>\n<li>Merge results into <code>result_dict</code>.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>Return <code>result_dict</code>.</li>\n</ol>\n</li>\n<li><strong>Resolve field</strong>:<ol>\n<li><strong>Coerce arguments</strong>: For each argument in the field&#39;s AST, coerce the value using the argument&#39;s type from the schema.</li>\n<li><strong>Get resolver</strong>: Look up the resolver function for this field on the parent type. If none, use <code>context.field_resolver</code>.</li>\n<li><strong>Call resolver</strong>: Invoke resolver with <code>(parent_value, arguments, context, info)</code>, where <code>info</code> is a <code>ResolveInfo</code> object containing field details.</li>\n<li><strong>Handle result</strong>:<ul>\n<li>If resolver returns an exception, add a <code>GraphQLError</code> to context.</li>\n<li>If resolver returns a value, coerce it to the field&#39;s declared type (handling nullability, lists, etc.).</li>\n<li>If the coerced value is an object type and the field has a <code>selection_set</code>, recursively <code>execute_fields</code>.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>Common Pitfalls in Execution State Design:</strong></p>\n<ul>\n<li>⚠️ <strong>Pitfall: Not Propagating Null Correctly</strong><ul>\n<li><strong>Description</strong>: When a non-null field resolves to <code>null</code>, the engine fails to bubble that null up to the nearest nullable parent, causing the entire query to fail incorrectly.</li>\n<li><strong>Why it&#39;s wrong</strong>: GraphQL spec requires that if a non-null field returns null, that null propagates, making the parent field null (or if the parent is also non-null, continuing up). This allows partial data to be returned with errors.</li>\n<li><strong>Fix</strong>: In <code>resolve_field</code>, after coercing the value, if the result is <code>null</code> and the field&#39;s type is <code>NonNullType</code>, add an error to context and return <code>null</code>. The caller (<code>execute_fields</code>) must detect this and propagate it.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: Forgetting to Clone Path for Parallel Execution</strong><ul>\n<li><strong>Description</strong>: When resolving sibling fields in parallel (e.g., <code>{ user { name email } }</code>), using a mutable shared <code>path</code> leads to race conditions where one field&#39;s path overwrites another&#39;s.</li>\n<li><strong>Why it&#39;s wrong</strong>: Errors will have incorrect paths, making debugging impossible. Execution may become non-deterministic.</li>\n<li><strong>Fix</strong>: Before dispatching parallel field resolution, take a snapshot of the current path (or create a new context copy) for each branch. Alternatively, make <code>path</code> immutable and pass it as an argument to <code>resolve_field</code>.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: DataLoader Cache Pollution Across Requests</strong><ul>\n<li><strong>Description</strong>: Using a single <code>DataLoader</code> instance across multiple GraphQL requests, causing cached data from one user to leak to another.</li>\n<li><strong>Why it&#39;s wrong</strong>: Security and data isolation violation. User A might see User B&#39;s data if IDs happen to match.</li>\n<li><strong>Fix</strong>: Create a new <code>DataLoader</code> instance per request, attached to <code>ExecutionContext.data_loaders</code>. The cache is then request-scoped and garbage-collected after the request.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"sql-intermediate-representation\">SQL Intermediate Representation</h3>\n<p><strong>Mental Model: The Construction Plan</strong>\nTranslating a GraphQL query to SQL is like turning an architect&#39;s sketch (GraphQL) into a builder&#39;s detailed plan (SQL). The <strong>SQL IR</strong> is that plan—a step-by-step breakdown that says: &quot;We need to query the <code>users</code> table, join with <code>posts</code> on <code>user_id</code>, filter where <code>status = &#39;active&#39;</code>, and return columns <code>id</code>, <code>name</code>, and <code>posts.title</code>.&quot; It&#39;s an intermediate representation that&#39;s closer to SQL than GraphQL but not yet a specific SQL dialect string, allowing for optimizations and parameter binding.</p>\n<p>The SQL IR bridges the GraphQL AST and the final SQL query (Milestone 5). It is a tree or pipeline structure that captures the relational operations needed to fulfill the GraphQL query: which tables to select from, how to join them, what filters to apply, and what columns to return. This IR can be optimized (e.g., reorder joins, push down filters) before being rendered to a specific SQL dialect.</p>\n<h4 id=\"sql-ir-data-structures\">SQL IR Data Structures</h4>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Fields</th>\n<th>Field Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SQLQuery</code></td>\n<td><code>root_select</code></td>\n<td><code>SQLSelect</code></td>\n<td>The top-level SELECT statement (often corresponds to the GraphQL query root).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>variables</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Map of parameter names to values for safe SQL parameterization.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>result_mapper</code></td>\n<td><code>Callable[[Dict], Dict]</code></td>\n<td>Function to transform flat SQL row results into nested GraphQL response shape.</td>\n</tr>\n<tr>\n<td><code>SQLSelect</code></td>\n<td><code>from_table</code></td>\n<td><code>SQLTable</code></td>\n<td>Primary table or subquery being selected from.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>joins</code></td>\n<td><code>List[SQLJoin]</code></td>\n<td>List of joins to other tables.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>where</code></td>\n<td><code>Optional[SQLExpression]</code></td>\n<td>WHERE clause condition expression.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>order_by</code></td>\n<td><code>List[SQLOrderBy]</code></td>\n<td>ORDER BY clauses.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>limit</code></td>\n<td><code>Optional[int]</code></td>\n<td>LIMIT clause.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>offset</code></td>\n<td><code>Optional[int]</code></td>\n<td>OFFSET clause.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>columns</code></td>\n<td><code>List[SQLColumn]</code></td>\n<td>Columns to select (can be from primary table or joined tables).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>distinct</code></td>\n<td><code>bool</code></td>\n<td>Whether to add DISTINCT.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>group_by</code></td>\n<td><code>List[SQLColumn]</code></td>\n<td>GROUP BY columns (for aggregations).</td>\n</tr>\n<tr>\n<td><code>SQLTable</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Database table name (or alias).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>schema</code></td>\n<td><code>Optional[str]</code></td>\n<td>Database schema (e.g., &quot;public&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>alias</code></td>\n<td><code>Optional[str]</code></td>\n<td>Alias for this table in the query (e.g., &quot;u&quot; for &quot;users AS u&quot;).</td>\n</tr>\n<tr>\n<td><code>SQLJoin</code></td>\n<td><code>type</code></td>\n<td><code>str</code></td>\n<td>Join type: &quot;INNER&quot;, &quot;LEFT&quot;, &quot;RIGHT&quot;, &quot;FULL&quot;.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>table</code></td>\n<td><code>SQLTable</code></td>\n<td>The table being joined.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>on</code></td>\n<td><code>SQLExpression</code></td>\n<td>ON clause condition (e.g., &quot;users.id = posts.user_id&quot;).</td>\n</tr>\n<tr>\n<td><code>SQLColumn</code></td>\n<td><code>table</code></td>\n<td><code>SQLTable</code></td>\n<td>Table this column belongs to.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Column name.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>alias</code></td>\n<td><code>Optional[str]</code></td>\n<td>Output alias (e.g., &quot;userName&quot; for &quot;name AS userName&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>expression</code></td>\n<td><code>Optional[str]</code></td>\n<td>Optional raw SQL expression (e.g., &quot;COUNT(*)&quot; instead of a simple column).</td>\n</tr>\n<tr>\n<td><code>SQLExpression</code></td>\n<td><code>kind</code></td>\n<td><code>str</code></td>\n<td>Node type: &quot;binary&quot;, &quot;unary&quot;, &quot;literal&quot;, &quot;column&quot;, &quot;parameter&quot;.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>operator</code></td>\n<td><code>Optional[str]</code></td>\n<td>For binary/unary: &quot;=&quot;, &quot;&gt;&quot;, &quot;AND&quot;, &quot;NOT&quot;, etc.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>left</code></td>\n<td><code>Optional[SQLExpression]</code></td>\n<td>Left operand.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>right</code></td>\n<td><code>Optional[SQLExpression]</code></td>\n<td>Right operand.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>value</code></td>\n<td><code>Any</code></td>\n<td>For literal/parameter: the value.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>column</code></td>\n<td><code>Optional[SQLColumn]</code></td>\n<td>For column reference: the column.</td>\n</tr>\n<tr>\n<td><code>SQLOrderBy</code></td>\n<td><code>column</code></td>\n<td><code>SQLColumn</code></td>\n<td>Column to order by.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>direction</code></td>\n<td><code>str</code></td>\n<td>&quot;ASC&quot; or &quot;DESC&quot;.</td>\n</tr>\n<tr>\n<td><code>SQLParameter</code></td>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Parameter placeholder name (e.g., &quot;$1&quot;, &quot;:id&quot;).</td>\n</tr>\n<tr>\n<td></td>\n<td><code>value</code></td>\n<td><code>Any</code></td>\n<td>The value to bind.</td>\n</tr>\n<tr>\n<td></td>\n<td><code>type</code></td>\n<td><code>str</code></td>\n<td>SQL type hint (e.g., &quot;int&quot;, &quot;text&quot;).</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: SQL IR as a Tree vs. Pipeline</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to represent relational operations that can be nested (subqueries, joins of joins). The structure should support both simple flat queries and complex nested ones.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Pipeline model</strong>: A linear sequence of operations (Scan → Filter → Join → Project) similar to relational algebra. Each stage transforms a result set.</li>\n<li><strong>Tree model</strong>: A hierarchical SELECT tree where each SELECT can have JOIN children, and JOINs can have their own SELECT subtrees. This mirrors SQL&#39;s nested nature.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Tree model centered on <code>SQLSelect</code>.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Natural Mapping</strong>: GraphQL&#39;s nested selections map directly to nested <code>SQLSelect</code> nodes (via joins). A field <code>user { posts { comments } }</code> becomes a main SELECT for users, a JOIN to posts, and a sub-SELECT for comments.</li>\n<li><strong>SQL Generation Simplicity</strong>: Walking the tree and emitting SQL is straightforward—each <code>SQLSelect</code> renders to a SELECT clause, with joins rendered as JOIN clauses in the same SELECT.</li>\n<li><strong>Optimization Opportunities</strong>: The tree can be rearranged (join reordering, filter push-down) by rewriting subtrees without changing the overall pipeline abstraction.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Some operations that are naturally pipeline (e.g., LIMIT after ORDER BY) must be represented as fields within the same <code>SQLSelect</code> node, not as separate stages.</li>\n<li>Handling correlated subqueries (where a subquery references columns from outer query) requires careful design of column references across tree levels.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Algorithm for Generating SQL IR from GraphQL AST:</strong></p>\n<ol>\n<li><strong>Analyze selection set</strong>: Traverse the GraphQL AST starting at the root field (e.g., <code>query { users { ... } }</code>). Identify the primary table mapping from the root field name (<code>users</code> → <code>users</code> table).</li>\n<li><strong>Create root SQLSelect</strong>: Instantiate <code>SQLSelect</code> with <code>from_table</code> set to the primary table.</li>\n<li><strong>Process selections recursively</strong>:<ul>\n<li>For each field in the selection set:<ul>\n<li>If field is a scalar (maps to a column):<ol>\n<li>Add a <code>SQLColumn</code> to <code>columns</code> list, mapping GraphQL field name to table column name.</li>\n</ol>\n</li>\n<li>If field is an object (maps to a relationship):<ol>\n<li>Determine relationship type (one-to-one, one-to-many) via foreign key metadata.</li>\n<li>For one-to-one: Add a <code>SQLJoin</code> to the related table, and recursively process the nested selection set, adding columns from the joined table.</li>\n<li>For one-to-many: This becomes either a <strong>lateral join</strong> (for nested array) or a separate batch query. For simplicity, initially implement as a separate batch query (DataLoader pattern).</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Apply filters</strong>: Convert GraphQL field arguments (e.g., <code>where: { status: &quot;active&quot; }</code>) into <code>SQLExpression</code> trees attached to <code>where</code>.</li>\n<li><strong>Apply pagination</strong>: Convert <code>first</code>, <code>after</code>, <code>offset</code> arguments into <code>limit</code>/<code>offset</code> or cursor-based conditions.</li>\n<li><strong>Apply ordering</strong>: Convert <code>orderBy</code> argument into <code>SQLOrderBy</code> list.</li>\n<li><strong>Collect parameters</strong>: Extract all literal values from GraphQL arguments and replace them with <code>SQLParameter</code> placeholders in the SQL IR, storing the actual values in <code>SQLQuery.variables</code>.</li>\n</ol>\n<p><strong>Common Pitfalls in SQL IR Design:</strong></p>\n<ul>\n<li>⚠️ <strong>Pitfall: Generating Cartesian Products</strong><ul>\n<li><strong>Description</strong>: When joining multiple one-to-many relationships in the same query level (e.g., <code>user { posts, comments }</code>), a naive JOIN leads to a Cartesian product between posts and comments for each user.</li>\n<li><strong>Why it&#39;s wrong</strong>: Results explode in size (user with 10 posts and 10 comments yields 100 rows), causing performance issues and incorrect data aggregation.</li>\n<li><strong>Fix</strong>: For multiple one-to-many relationships, use <strong>separate queries</strong> (DataLoader batches) or <strong>lateral joins</strong> that keep the relationships separate. The SQL IR should mark such relationships as requiring separate batch execution.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: Not Parameterizing Values</strong><ul>\n<li><strong>Description</strong>: Embedding literal values directly into SQL expressions as strings, leading to SQL injection vulnerabilities.</li>\n<li><strong>Why it&#39;s wrong</strong>: Unsafe. A GraphQL argument <code>where: { name: &quot;&#39;; DROP TABLE users; --&quot; }</code> could cause disaster.</li>\n<li><strong>Fix</strong>: Always use <code>SQLParameter</code> nodes for values. The SQL renderer should replace these with placeholders (<code>$1</code>, <code>%s</code>) and pass values separately to the database driver.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: Ignoring Column Aliasing Conflicts</strong><ul>\n<li><strong>Description</strong>: When joining tables with same column names (e.g., <code>users.id</code> and <code>posts.id</code>), selecting both without aliases leads to duplicate column names in result set, causing mapping errors.</li>\n<li><strong>Why it&#39;s wrong</strong>: Database drivers may overwrite one column with another, or the result mapper cannot distinguish which <code>id</code> belongs to which table.</li>\n<li><strong>Fix</strong>: Automatically alias columns in <code>SQLColumn</code> using a naming scheme (e.g., <code>users__id</code>, <code>posts__id</code>). The <code>result_mapper</code> must use these aliases to reconstruct nested objects.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (for learning)</th>\n<th>Advanced Option (for production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>AST &amp; Type System</strong></td>\n<td>Pure Python classes with <code>dataclasses</code> or <code>attrs</code> for immutable nodes.</td>\n<td>Use a library like <code>graphql-core</code> for reference implementation, or <code>pydantic</code> with validation.</td>\n</tr>\n<tr>\n<td><strong>Execution Context</strong></td>\n<td>Plain Python dict for context, manual path stack management.</td>\n<td>Use <code>contextvars</code> for async context, <code>asyncio</code> for parallel resolution.</td>\n</tr>\n<tr>\n<td><strong>SQL IR</strong></td>\n<td>Simple namedtuple-like classes, string templating for SQL generation.</td>\n<td>Use SQLAlchemy Core as a SQL abstraction layer, or a dedicated SQL builder like <code>pypika</code>.</td>\n</tr>\n<tr>\n<td><strong>DataLoader</strong></td>\n<td>Manual batching with dictionary caches per request.</td>\n<td>Use <code>aiodataloader</code> library for async batching and caching.</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql_engine/\n├── ast/\n│   ├── __init__.py\n│   ├── nodes.py          # All AST node classes (Location, Document, Field, etc.)\n│   └── parser.py         # Lexer and recursive descent parser (parse_query)\n├── type_system/\n│   ├── __init__.py\n│   ├── types.py          # GraphQLType, ScalarType, ObjectType, etc.\n│   ├── schema.py         # Schema class and validation logic\n│   └── introspection.py  # Introspection type definitions and resolver\n├── execution/\n│   ├── __init__.py\n│   ├── context.py        # ExecutionContext, GraphQLError\n│   ├── executor.py       # execute_query, field resolution algorithms\n│   ├── resolver.py       # Default field resolver, type resolver\n│   └── dataloader.py     # DataLoader class\n├── sql/\n│   ├── __init__.py\n│   ├── ir.py             # SQL IR classes (SQLQuery, SQLSelect, etc.)\n│   ├── compiler.py       # AST-to-SQL IR compilation logic\n│   └── renderer.py       # SQL IR to parameterized SQL string (for PostgreSQL, SQLite)\n├── reflection/\n│   ├── __init__.py\n│   ├── introspector.py   # Database metadata queries\n│   └── mapper.py         # Maps tables to GraphQL types, columns to fields\n└── server.py             # HTTP server (optional, for testing)</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Here is a complete, ready-to-use implementation of the <code>Location</code> and base <code>Node</code> classes, which are prerequisites for the AST:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># ast/nodes.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, List, Union, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Location</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Source location in a GraphQL document.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">      # 1-indexed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">    # 1-indexed</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.column</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Node</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all AST nodes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    __slots__</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'loc'</span><span style=\"color:#E1E4E8\">,)  </span><span style=\"color:#6A737D\"># Saves memory, ensures immutability</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, loc: Optional[Location] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.loc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> loc</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cls_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__class__</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__name__</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fields </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \", \"</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">k</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">=</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">v</span><span style=\"color:#F97583\">!r</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> k, v </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__dict__</span><span style=\"color:#E1E4E8\">.items() </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> k </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> 'loc'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.loc:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">cls_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">fields</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, loc=</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.loc</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">cls_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">fields</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>AST Node Skeleton (to be completed by learner):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># ast/nodes.py (continued)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Document</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Complete GraphQL document with definitions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    definitions: List[</span><span style=\"color:#9ECBFF\">'Definition'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get operation by name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get fragment by name</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Definition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base for OperationDefinition and FragmentDefinition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OperationDefinition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Definition</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A query, mutation, or subscription operation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # 'query', 'mutation', 'subscription'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variable_definitions: List[</span><span style=\"color:#9ECBFF\">'VariableDefinition'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives: List[</span><span style=\"color:#9ECBFF\">'Directive'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selection_set: </span><span style=\"color:#9ECBFF\">'SelectionSet'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to validate variable usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to collect referenced fragment names</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SelectionSet</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A set of fields/fragments selected on an object.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selections: List[</span><span style=\"color:#9ECBFF\">'Selection'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to flatten fragments (expand FragmentSpread)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get all field names</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Define remaining AST classes: Field, FragmentDefinition, FragmentSpread,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#       InlineFragment, Argument, Directive, VariableDefinition, Variable,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#       NamedType, ListType, NonNullType, and all Value subclasses (IntValue, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#       Follow the table structure exactly.</span></span></code></pre></div>\n\n<p><strong>Type System Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># type_system/types.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Callable, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLType</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all GraphQL types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.description </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> description</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get introspection representation (__Type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to check type equality (handling wrappers)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ScalarType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL scalar type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, serialize: Callable, parse_value: Callable,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 parse_literal: Callable, description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(name, description)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.serialize </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> serialize</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parse_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parse_literal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_literal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add built-in scalars (Int, Float, String, Boolean, ID) as class constants</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ObjectType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL object type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, fields: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'GraphQLField'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 interfaces: Optional[List[</span><span style=\"color:#9ECBFF\">'InterfaceType'</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(name, description)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.fields </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fields</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.interfaces </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> interfaces </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get field by name (including from interfaces)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to validate interface implementations</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Define GraphQLField, GraphQLArgument, InterfaceType, UnionType,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#       EnumType, EnumValue, InputObjectType, GraphQLInputField,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#       ListType, NonNullType, Schema, GraphQLDirective.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#       Follow the table structure exactly.</span></span></code></pre></div>\n\n<p><strong>ExecutionContext Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># execution/context.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Any, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..ast.nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Document, Location</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..type_system.schema </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PathSegment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ExecutionContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Runtime context for executing a GraphQL query.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema: Schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    document_ast: Document</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variable_values: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_value: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_value: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fragments: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Maps name to FragmentDefinition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    errors: List[</span><span style=\"color:#9ECBFF\">'GraphQLError'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data_loaders: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'DataLoader'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path: List[PathSegment] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    field_resolver: Callable </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type_resolver: Callable </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method push_path(segment) -> context manager (for `with context.push_path(...):`)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method get_data_loader(key, batch_load_fn) -> returns existing or creates new DataLoader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to coerce variable values based on operation's variable definitions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL execution error with location and path.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    locations: List[Location] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path: List[PathSegment] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_error: Optional[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    extensions: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to format error for JSON response (per GraphQL spec)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add class method from_exception to wrap Python exceptions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement DataLoader class with batch scheduling and caching.</span></span></code></pre></div>\n\n<p><strong>SQL IR Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># sql/ir.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SQLQuery</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Complete SQL query representation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_select: </span><span style=\"color:#9ECBFF\">'SQLSelect'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variables: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result_mapper: Optional[Callable[[Dict], Dict]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to render to SQL string with placeholders</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to execute via database adapter</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SQLSelect</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A SELECT statement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    from_table: </span><span style=\"color:#9ECBFF\">'SQLTable'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    joins: List[</span><span style=\"color:#9ECBFF\">'SQLJoin'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    where: Optional[</span><span style=\"color:#9ECBFF\">'SQLExpression'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    order_by: List[</span><span style=\"color:#9ECBFF\">'SQLOrderBy'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    limit: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    columns: List[</span><span style=\"color:#9ECBFF\">'SQLColumn'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    distinct: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    group_by: List[</span><span style=\"color:#9ECBFF\">'SQLColumn'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to add column with auto-alias</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to find join by table name</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Define SQLTable, SQLJoin, SQLColumn, SQLExpression, SQLOrderBy, SQLParameter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#       Follow the table structure exactly.</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-python\">Language-Specific Hints (Python)</h4>\n<ul>\n<li>Use <code>@dataclass(frozen=True)</code> for immutable AST nodes to ensure hashability and prevent accidental mutation.</li>\n<li>For type checking, use <code>typing</code> module extensively. Consider <code>Protocol</code> for resolver interfaces.</li>\n<li>Use <code>contextvars.ContextVar</code> for async context if you implement async resolvers.</li>\n<li>For SQL parameterization, use <code>%s</code> placeholders with PostgreSQL&#39;s <code>psycopg2</code> or SQLite&#39;s <code>sqlite3</code>. Never use string formatting.</li>\n<li>Use <code>asyncio.gather</code> for parallel field resolution in async executors.</li>\n<li>Consider <code>functools.lru_cache</code> for memoizing schema introspection results.</li>\n</ul>\n<h4 id=\"milestone-checkpoint-for-data-model\">Milestone Checkpoint for Data Model</h4>\n<p>After implementing the data structures above (but before implementing parsers or executors), you should be able to run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> graphql_engine/ast/nodes.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>Expected: Tests for AST node creation and equality should pass. Example test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_field_node</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Location(</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">column</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    field </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Field(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">alias</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[], </span><span style=\"color:#FFAB70\">directives</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[], </span><span style=\"color:#FFAB70\">selection_set</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">loc</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">loc)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> field.name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"id\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> field.loc </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> loc</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(field, Node)</span></span></code></pre></div>\n\n<p>Signs something is wrong:</p>\n<ul>\n<li><strong>Error</strong>: <code>TypeError: cannot set attribute</code> on a frozen dataclass. → You tried to modify an immutable node. Ensure you&#39;re not mutating after creation.</li>\n<li><strong>Error</strong>: <code>RecursionError</code> when printing a node. → Likely circular reference in <code>__repr__</code>. Check that you&#39;re not following relationships indefinitely (e.g., <code>Field</code> referencing its parent <code>SelectionSet</code>).</li>\n<li><strong>Warning</strong>: Mypy reports missing fields. → Check that you&#39;ve implemented all fields from the tables above.</li>\n</ul>\n<h2 id=\"component-1-graphql-parser\">Component 1: GraphQL Parser</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 1: GraphQL Parser, which focuses on converting GraphQL query strings into Abstract Syntax Trees (ASTs).</p>\n</blockquote>\n<h3 id=\"responsibility-and-scope\">Responsibility and Scope</h3>\n<p>The GraphQL Parser is the system&#39;s <strong>front door</strong>—it takes raw GraphQL query strings from clients and transforms them into structured, machine-readable representations. Think of it as the <strong>optical character recognition</strong> system for a document scanner: it doesn&#39;t understand the content&#39;s meaning (that&#39;s for validators and executors), but it must perfectly recognize and digitize every character, word, and sentence structure.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>In Scope</th>\n<th>Out of Scope</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Lexical Analysis</strong></td>\n<td>Break query string into tokens (keywords, identifiers, punctuation)</td>\n<td>Validate token semantics (e.g., &quot;query&quot; vs. &quot;mutation&quot; meaning)</td>\n</tr>\n<tr>\n<td><strong>Syntactic Analysis</strong></td>\n<td>Build AST following GraphQL grammar rules</td>\n<td>Validate AST against schema (type checking, field existence)</td>\n</tr>\n<tr>\n<td><strong>Source Location Tracking</strong></td>\n<td>Record line/column for every AST node</td>\n<td>Error recovery and intelligent suggestions</td>\n</tr>\n<tr>\n<td><strong>Document Structure</strong></td>\n<td>Parse operations, fragments, variables, directives</td>\n<td>Execute operations or resolve field values</td>\n</tr>\n<tr>\n<td><strong>Literal Value Parsing</strong></td>\n<td>Convert string/number/boolean literals to Python values</td>\n<td>Validate literal ranges (e.g., Int within 32-bit range)</td>\n</tr>\n<tr>\n<td><strong>Query Document Assembly</strong></td>\n<td>Build complete <code>Document</code> AST with all definitions</td>\n<td>Optimize or normalize the query structure</td>\n</tr>\n</tbody></table>\n<p>The parser&#39;s output is a <strong>syntactically correct but semantically unvalidated</strong> AST. It ensures the query is well-formed according to GraphQL&#39;s grammar, but doesn&#39;t verify that referenced types exist, fields are valid, or variables match their declared types. This separation follows the <strong>compiler principle</strong> of separating syntax (form) from semantics (meaning).</p>\n<h3 id=\"mental-model-language-translator\">Mental Model: Language Translator</h3>\n<p>Imagine you&#39;re <strong>translating a restaurant order from a customer&#39;s scribbled note into a structured kitchen ticket</strong>. The customer writes:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Large pepperoni pizza, extra cheese\nNo mushrooms\nAdd: 2 garlic bread\nDiet Coke</code></pre></div>\n\n<p>A human translator would:</p>\n<ol>\n<li><strong>Tokenize</strong>: Recognize &quot;Large&quot; as size, &quot;pepperoni&quot; as topping, &quot;2&quot; as quantity</li>\n<li><strong>Structure</strong>: Group items into categories (pizza, sides, drinks)</li>\n<li><strong>Resolve references</strong>: Link &quot;extra cheese&quot; to the pizza, not the garlic bread</li>\n<li><strong>Handle modifiers</strong>: Apply &quot;No mushrooms&quot; as an exclusion, not an addition</li>\n</ol>\n<p>The GraphQL parser does exactly this translation:</p>\n<ul>\n<li><strong>Tokens</strong> = individual words and punctuation (<code>{</code>, <code>query</code>, <code>user</code>, <code>name</code>)</li>\n<li><strong>Structure</strong> = nested selection sets with fields and arguments</li>\n<li><strong>References</strong> = fragment spreads pointing to their definitions</li>\n<li><strong>Modifiers</strong> = directives (<code>@include</code>, <code>@skip</code>) and variable definitions</li>\n</ul>\n<p>The key insight is that the parser <strong>doesn&#39;t check if pepperoni is on the menu</strong> (schema validation) or <strong>whether the kitchen has garlic bread</strong> (execution)—it only ensures the order is written in valid restaurant-language syntax.</p>\n<h3 id=\"parser-interface\">Parser Interface</h3>\n<p>The parser exposes a minimal public API with two primary methods, following the principle of <strong>single responsibility</strong>—each method handles one specific input format.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n<th>Side Effects</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parse_query</code></td>\n<td><code>query_str: str</code></td>\n<td><code>Document</code></td>\n<td>Parse GraphQL query/mutation/subscription</td>\n<td>None (pure function)</td>\n</tr>\n<tr>\n<td><code>parse_schema</code></td>\n<td><code>schema_str: str</code></td>\n<td><code>List[TypeDefinition]</code></td>\n<td>Parse GraphQL Schema Definition Language</td>\n<td>None (pure function)</td>\n</tr>\n</tbody></table>\n<p><strong>Error Contract</strong>: Both methods raise <code>GraphQLSyntaxError</code> (a subclass of <code>GraphQLError</code>) for malformed input. The error includes:</p>\n<ul>\n<li><code>message</code>: Human-readable description</li>\n<li><code>locations</code>: List of <code>Location</code> objects (line, column)</li>\n<li><code>original_error</code>: The underlying parsing exception if applicable</li>\n</ul>\n<p><strong>Input Examples</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">graphql</span><pre class=\"arch-pre shiki-highlighted\"><code># parse_query input\nquery GetUser($id: ID!) {\n  user(id: $id) {\n    name\n    email\n  }\n}\n\n# parse_schema input  \ntype User {\n  id: ID!\n  name: String\n  email: String\n}</code></pre></div>\n\n<p><strong>Output Structure</strong>: The <code>parse_query</code> method returns a <code>Document</code> containing:</p>\n<ul>\n<li><code>definitions</code>: List of operation and fragment definitions</li>\n<li>Source location information on every node</li>\n<li>Complete tree structure mirroring the query&#39;s nesting</li>\n</ul>\n<h3 id=\"parsing-algorithm\">Parsing Algorithm</h3>\n<p>The parser implements <strong>recursive descent parsing with single-token lookahead</strong>, which naturally matches GraphQL&#39;s nested but not overly complex grammar. The algorithm proceeds in two phases: <strong>lexical analysis</strong> (tokenization) followed by <strong>syntactic analysis</strong> (AST construction).</p>\n<h4 id=\"phase-1-lexical-analysis-tokenizer\">Phase 1: Lexical Analysis (Tokenizer)</h4>\n<p>The tokenizer scans the query string left-to-right, grouping characters into tokens while discarding meaningless whitespace and comments.</p>\n<p><strong>Token Types Table</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Token Type</th>\n<th>Examples</th>\n<th>Description</th>\n<th>Special Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NAME</code></td>\n<td><code>query</code>, <code>user</code>, <code>_id</code></td>\n<td>GraphQL names (letters, digits, underscores)</td>\n<td>Case-sensitive, cannot start with digit</td>\n</tr>\n<tr>\n<td><code>INT</code></td>\n<td><code>42</code>, <code>0</code>, <code>-10</code></td>\n<td>Integer values</td>\n<td>No decimal point, supports negative</td>\n</tr>\n<tr>\n<td><code>FLOAT</code></td>\n<td><code>3.14</code>, <code>-2.5e-3</code></td>\n<td>Floating-point values</td>\n<td>Scientific notation support</td>\n</tr>\n<tr>\n<td><code>STRING</code></td>\n<td><code>&quot;hello&quot;</code>, <code>&quot;line\\nbreak&quot;</code></td>\n<td>String literals</td>\n<td>Escapes: <code>\\\\</code>, <code>\\&quot;</code>, <code>\\/</code>, <code>\\b</code>, <code>\\f</code>, <code>\\n</code>, <code>\\r</code>, <code>\\t</code>, <code>\\uXXXX</code></td>\n</tr>\n<tr>\n<td><code>PUNCTUATION</code></td>\n<td><code>{</code>, <code>}</code>, <code>(</code>, <code>)</code>, <code>:</code>, <code>@</code>, <code>$</code>, <code>!</code></td>\n<td>Syntax punctuation</td>\n<td>Single characters</td>\n</tr>\n<tr>\n<td><code>SPREAD</code></td>\n<td><code>...</code></td>\n<td>Fragment spread operator</td>\n<td>Three consecutive periods</td>\n</tr>\n<tr>\n<td><code>BLOCK_STRING</code></td>\n<td><code>&quot;&quot;&quot;multiline string&quot;&quot;&quot;</code></td>\n<td>Triple-quoted strings</td>\n<td>Handles leading/trailing whitespace specially</td>\n</tr>\n</tbody></table>\n<p><strong>Tokenizer Algorithm</strong>:</p>\n<ol>\n<li><strong>Initialize</strong>: Set <code>position = 0</code>, <code>line = 1</code>, <code>column = 1</code></li>\n<li><strong>Skip ignorables</strong>: Advance past whitespace (<code> </code>, <code>\\t</code>, <code>,</code>) and comments (<code># comment</code>)</li>\n<li><strong>Identify token</strong>:<ul>\n<li>If <code>char == &#39;&quot;&#39;</code>: Check for <code>&quot;&quot;&quot;</code> (block string) else parse regular string</li>\n<li>If <code>char.isalpha() or char == &#39;_&#39;</code>: Parse NAME token</li>\n<li>If <code>char.isdigit() or (char == &#39;-&#39; and next_char.isdigit())</code>: Parse INT/FLOAT</li>\n<li>If <code>char == &#39;.&#39;</code>: Check for <code>...</code> (SPREAD) else error</li>\n<li>Otherwise: Match single-character PUNCTUATION</li>\n</ul>\n</li>\n<li><strong>Emit token</strong>: Create token with value, line, column, and advance position</li>\n<li><strong>Repeat</strong> until end of input</li>\n</ol>\n<p><strong>Location Tracking</strong>: Each token records its starting <code>(line, column)</code> position, enabling precise error reporting. The tokenizer increments:</p>\n<ul>\n<li><code>line</code> on <code>\\n</code> or <code>\\r\\n</code></li>\n<li><code>column</code> resets to 1 after newline, increments by 1 otherwise</li>\n</ul>\n<h4 id=\"phase-2-syntactic-analysis-parser\">Phase 2: Syntactic Analysis (Parser)</h4>\n<p>The parser consumes tokens using <strong>predictive parsing</strong>—at each step, it examines the next token to decide which grammar rule applies. GraphQL&#39;s grammar is LL(1), meaning one token lookahead is sufficient.</p>\n<p><strong>Grammar Rules Simplified</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Document → Definition+\nDefinition → OperationDefinition | FragmentDefinition\nOperationDefinition → OperationType Name? VariableDefinitions? Directives? SelectionSet\nSelectionSet → '{' Selection+ '}'\nSelection → Field | FragmentSpread | InlineFragment\nField → Alias? Name Arguments? Directives? SelectionSet?</code></pre></div>\n\n<p><strong>Parsing Algorithm Steps</strong>:</p>\n<ol>\n<li><p><strong>Parse Document</strong>:</p>\n<ul>\n<li>While tokens remain, parse a Definition</li>\n<li>Add to <code>definitions</code> list</li>\n<li>Return <code>Document(definitions)</code></li>\n</ul>\n</li>\n<li><p><strong>Parse Definition</strong>:</p>\n<ul>\n<li>Peek at next token:<ul>\n<li><code>NAME</code> = could be operation or fragment</li>\n<li><code>{</code> = anonymous operation</li>\n<li>Otherwise error</li>\n</ul>\n</li>\n<li>If token is <code>fragment</code>: Parse <code>FragmentDefinition</code></li>\n<li>Else: Parse <code>OperationDefinition</code></li>\n</ul>\n</li>\n<li><p><strong>Parse OperationDefinition</strong>:</p>\n<ul>\n<li>Parse operation type (<code>query</code>, <code>mutation</code>, <code>subscription</code>)</li>\n<li>Optional: Parse name (if <code>NAME</code> token)</li>\n<li>Optional: Parse variable definitions (if <code>(</code> token)</li>\n<li>Optional: Parse directives</li>\n<li>Parse <code>SelectionSet</code></li>\n</ul>\n</li>\n<li><p><strong>Parse SelectionSet</strong> (recursive core):</p>\n<ul>\n<li>Expect <code>{</code> token</li>\n<li>While next token ≠ <code>}</code>: Parse Selection</li>\n<li>Expect <code>}</code> token</li>\n<li>Return <code>SelectionSet(selections)</code></li>\n</ul>\n</li>\n<li><p><strong>Parse Selection</strong>:</p>\n<ul>\n<li>Peek at tokens:<ul>\n<li><code>...</code> → <code>FragmentSpread</code> or <code>InlineFragment</code></li>\n<li><code>NAME</code> → <code>Field</code></li>\n</ul>\n</li>\n<li>For <code>Field</code>: Parse optional alias, name, arguments, directives, optional nested <code>SelectionSet</code></li>\n</ul>\n</li>\n<li><p><strong>Parse Fragments</strong>:</p>\n<ul>\n<li><code>FragmentSpread</code>: Parse <code>...</code> followed by name and optional directives</li>\n<li><code>InlineFragment</code>: Parse <code>...</code> optional type condition, directives, and <code>SelectionSet</code></li>\n<li><code>FragmentDefinition</code>: Parse <code>fragment</code> keyword, name, type condition, directives, <code>SelectionSet</code></li>\n</ul>\n</li>\n<li><p><strong>Parse Value Literals</strong> (used in arguments, defaults):</p>\n<ul>\n<li>Dispatch based on token type:<ul>\n<li><code>$</code> → <code>Variable</code></li>\n<li><code>NAME</code> → <code>EnumValue</code> or <code>BooleanValue</code> or <code>NullValue</code></li>\n<li><code>[</code> → <code>ListValue</code></li>\n<li><code>{</code> → <code>ObjectValue</code></li>\n<li>Number/string tokens → corresponding scalar values</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>Recursive Nature</strong>: Notice how <code>parseSelectionSet</code> calls <code>parseSelection</code>, which for <code>Field</code> may call <code>parseSelectionSet</code> again—this <strong>recursive descent</strong> naturally handles GraphQL&#39;s arbitrarily nested structure.</p>\n<p><strong>Example Walkthrough</strong>: Parsing <code>query { user { name } }</code></p>\n<ol>\n<li>Token stream: [<code>NAME(query)</code>, <code>{</code>, <code>NAME(user)</code>, <code>{</code>, <code>NAME(name)</code>, <code>}</code>, <code>}</code>]</li>\n<li><code>parseDocument</code>: Parse Definition</li>\n<li><code>parseDefinition</code>: Anonymous operation (starts with <code>{</code>)</li>\n<li><code>parseOperationDefinition</code>: Default operation type = &quot;query&quot;, parse <code>SelectionSet</code></li>\n<li><code>parseSelectionSet</code>: Expect <code>{</code>, parse Selection(s)</li>\n<li><code>parseSelection</code>: <code>Field</code> with name &quot;user&quot;, parse nested <code>SelectionSet</code></li>\n<li><code>parseSelectionSet</code>: Expect <code>{</code>, parse Selection(s)</li>\n<li><code>parseSelection</code>: <code>Field</code> with name &quot;name&quot;, no nested selection set</li>\n<li>Backtrack, building nested AST: <code>Field(name=&quot;name&quot;)</code> → <code>SelectionSet([field])</code> → <code>Field(name=&quot;user&quot;, selection_set=SelectionSet)</code> → <code>SelectionSet([field])</code> → <code>OperationDefinition</code> → <code>Document</code></li>\n</ol>\n<h3 id=\"architecture-decision-parser-approach\">Architecture Decision: Parser Approach</h3>\n<blockquote>\n<p><strong>Decision: Recursive Descent Parser Over Parser Generator</strong></p>\n<p><strong>Context</strong>: GraphQL has a well-specified, moderately complex grammar with nested structures (selection sets within fields), optional elements (aliases, directives), and context-sensitive rules (fragments must be defined before use in single document). We need a parser that is educational, debuggable, and maintainable for learners.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Parser Generator (ANTLR, Lark)</strong>: Define grammar in BNF/EBNF, generate parser code</li>\n<li><strong>Parsing Expression Grammar (PEG)</strong>: Use PEG library with grammar rules</li>\n<li><strong>Manual Recursive Descent</strong>: Hand-written parser with explicit parsing methods</li>\n</ol>\n<p><strong>Decision</strong>: Implement manual recursive descent parser in pure Python.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Educational Value</strong>: Recursive descent makes the parsing process transparent—learners can trace execution step-by-step, seeing exactly how tokens become AST nodes. Parser generators are &quot;magic boxes&quot; that hide the transformation.</li>\n<li><strong>Error Reporting Quality</strong>: Hand-written parsers can produce precise, context-aware error messages (&quot;Expected &#39;}&#39; after selection set&quot; vs. generic &quot;syntax error&quot;).</li>\n<li><strong>Incremental Development</strong>: We can implement and test one grammar rule at a time (parseField, parseArgument, etc.).</li>\n<li><strong>No External Dependencies</strong>: Keeps the project self-contained and avoids version compatibility issues.</li>\n<li><strong>GraphQL-Specific Optimizations</strong>: We can add memoization for repeated fragments or optimize based on GraphQL&#39;s specific patterns.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>More Initial Code</strong>: ~500-800 lines vs. ~50 lines of grammar definition</li>\n<li><strong>Maintenance Burden</strong>: Grammar changes require manual code updates</li>\n<li><strong>Potential for Bugs</strong>: More opportunities for off-by-one errors in lookahead logic</li>\n<li><strong>Excellent Debuggability</strong>: Stack traces show exactly which parsing method failed</li>\n</ul>\n</blockquote>\n<p><strong>Comparison Table</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Parser Generator</strong></td>\n<td>Concise grammar definition, automatic error recovery, proven correctness</td>\n<td>Opaque transformation, steep learning curve, external dependency</td>\n<td>Hides the learning value—students wouldn&#39;t understand how parsing works</td>\n</tr>\n<tr>\n<td><strong>PEG Library</strong></td>\n<td>Natural grammar expression, good error messages, Python integration</td>\n<td>Still hides implementation details, performance overhead</td>\n<td>Less educational than seeing the recursive calls explicitly</td>\n</tr>\n<tr>\n<td><strong>Recursive Descent</strong></td>\n<td>Transparent, excellent error messages, no dependencies, debuggable</td>\n<td>More code to write, manual maintenance</td>\n<td><strong>CHOSEN</strong>: Maximizes learning, aligns with compiler education tradition</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Note</strong>: We use <strong>single-token lookahead</strong> rather than backtracking because GraphQL&#39;s grammar is LL(1). The parser examines the next token (<code>peek()</code>) to decide which path to take, without needing to rewind. This keeps the implementation simple and efficient.</p>\n<h3 id=\"common-parser-pitfalls\">Common Parser Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Incorrect String Escaping</strong></p>\n<ul>\n<li><strong>Description</strong>: Treating <code>\\&quot;</code> as two characters (backslash + quote) rather than an escaped quote</li>\n<li><strong>Why Wrong</strong>: Results in malformed string values, breaks JSON serialization</li>\n<li><strong>Fix</strong>: Implement proper escape sequence handling: <code>\\\\</code>, <code>\\&quot;</code>, <code>\\/</code>, <code>\\b</code>, <code>\\f</code>, <code>\\n</code>, <code>\\r</code>, <code>\\t</code>, <code>\\uXXXX</code> (4 hex digits)</li>\n<li><strong>Test Case</strong>: <code>&quot;Quote: \\&quot;, Newline: \\n, Unicode: \\u00A9&quot;</code> → Should parse as <code>Quote: &quot;, Newline: (newline), Unicode: ©</code></li>\n</ul>\n<p>⚠️ <strong>Pitfall: Missing Block String Handling</strong></p>\n<ul>\n<li><strong>Description</strong>: Treating <code>&quot;&quot;&quot;multiline\\nstring&quot;&quot;&quot;</code> as three separate string tokens</li>\n<li><strong>Why Wrong</strong>: Block strings have different escaping rules and handle whitespace specially per GraphQL spec</li>\n<li><strong>Fix</strong>: Detect <code>&quot;&quot;&quot;</code> sequence, parse until closing <code>&quot;&quot;&quot;</code>, apply &quot;trim indentation&quot; algorithm</li>\n<li><strong>Test Case</strong>: <code>&quot;&quot;&quot;Hello\\n  World&quot;&quot;&quot;</code> → Should parse as <code>Hello\\n  World</code> (no trimming since consistent indent)</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Location Tracking Offsets</strong></p>\n<ul>\n<li><strong>Description</strong>: Line/column counters get misaligned after multi-character tokens or newlines</li>\n<li><strong>Why Wrong</strong>: Error messages point to wrong location, confusing debugging</li>\n<li><strong>Fix</strong>: Update position counters <strong>before</strong> emitting token (token gets starting position), handle <code>\\r\\n</code> as single newline</li>\n<li><strong>Diagnostic</strong>: Parse <code>{\\n  user\\n}</code> → Field &quot;user&quot; should be at line 2, column 3, not line 1, column 5</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Fragment Spread vs. Inline Fragment Confusion</strong></p>\n<ul>\n<li><strong>Description</strong>: Misparsing <code>... on User</code> as a fragment spread named &quot;on&quot; followed by &quot;User&quot;</li>\n<li><strong>Why Wrong</strong>: <code>on</code> is a keyword in type conditions, not a valid fragment name</li>\n<li><strong>Fix</strong>: After <code>...</code>, check if next token is <code>NAME</code> and <strong>not</strong> <code>on</code> → fragment spread; if <code>on</code> → inline fragment</li>\n<li><strong>Edge Case</strong>: <code>... on</code> (no type condition) is invalid but should be caught in validation, not parsing</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Variable vs. Argument Ambiguity</strong></p>\n<ul>\n<li><strong>Description</strong>: Confusing <code>field(arg: $value)</code> (argument with variable value) vs. <code>$value</code> alone (variable definition)</li>\n<li><strong>Why Wrong</strong>: Parser tries to parse <code>$value</code> as an argument name (missing colon)</li>\n<li><strong>Fix</strong>: <code>$</code> is only valid starting variable tokens; in argument context, <code>:</code> must follow argument name before value</li>\n<li><strong>Rule</strong>: In <code>parseArguments</code>, after parsing name, expect <code>:</code>, then parse value (which may be a <code>Variable</code>)</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Unicode in Names</strong></p>\n<ul>\n<li><strong>Description</strong>: Rejecting valid Unicode characters in GraphQL names like <code>user_123</code> or <code>_valid</code></li>\n<li><strong>Why Wrong</strong>: GraphQL names support <code>[_A-Za-z][_0-9A-Za-z]*</code> with Unicode letters allowed</li>\n<li><strong>Fix</strong>: Use Unicode-aware character classification: <code>char.isalpha()</code> or <code>char == &#39;_&#39;</code> for first char</li>\n<li><strong>Test</strong>: <code>query_αβγ { field }</code> should parse correctly (Greek letters in name)</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommendation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Tokenizer</strong></td>\n<td>Manual character-by-character scanning</td>\n<td>Regex-based with <code>re.Scanner</code></td>\n<td><strong>Manual scanning</strong> (educational, precise control)</td>\n</tr>\n<tr>\n<td><strong>Token Representation</strong></td>\n<td><code>NamedTuple</code> with type/value/location</td>\n<td>Dataclass with methods</td>\n<td><strong><code>NamedTuple</code></strong> (immutable, lightweight, clear)</td>\n</tr>\n<tr>\n<td><strong>Parser State</strong></td>\n<td>Instance variables on Parser class</td>\n<td>Functional style with returned state tuples</td>\n<td><strong>Instance variables</strong> (simpler to debug)</td>\n</tr>\n<tr>\n<td><strong>Error Handling</strong></td>\n<td>Exception-based with custom <code>GraphQLSyntaxError</code></td>\n<td>Result type (<code>Ok</code>/<code>Err</code>) monadic style</td>\n<td><strong>Exceptions</strong> (Pythonic, easy control flow)</td>\n</tr>\n<tr>\n<td><strong>AST Nodes</strong></td>\n<td>Dataclasses with inheritance</td>\n<td><code>NamedTuple</code> with manual dispatch</td>\n<td><strong>Dataclasses</strong> (clean, mutable during building)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql-engine/\n├── pyproject.toml              # Project configuration\n├── README.md\n├── src/\n│   └── graphql_engine/\n│       ├── __init__.py\n│       ├── error.py            # GraphQLError, GraphQLSyntaxError\n│       ├── ast/                # AST node definitions\n│       │   ├── __init__.py\n│       │   ├── nodes.py        # All AST node classes\n│       │   └── location.py     # Location class\n│       ├── parser/\n│       │   ├── __init__.py     # Public API: parse_query, parse_schema\n│       │   ├── lexer.py        # Token, Tokenizer, TokenType enum\n│       │   ├── parser.py       # Parser class with recursive methods\n│       │   └── grammar.py      # Grammar constants (keywords, punctuation)\n│       └── utils/\n│           └── helpers.py      # String helpers, position tracking\n└── tests/\n    ├── __init__.py\n    ├── test_lexer.py\n    ├── test_parser.py\n    └── fixtures/\n        └── example_queries.graphql</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong><code>src/graphql_engine/error.py</code></strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"GraphQL error definitions.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Any, Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Location</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Source location for error reporting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.column</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all GraphQL errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    locations: List[Location] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path: List[Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_error: Optional[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    extensions: dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.locations:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            locs </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \", \"</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(loc) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> loc </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.locations)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> (locations: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">locs</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.message</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLSyntaxError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Syntax error during parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_lexer</span><span style=\"color:#E1E4E8\">(cls, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, line: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, column: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">\"GraphQLSyntaxError\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create syntax error from lexer position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Syntax error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            locations</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[Location(</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">line, </span><span style=\"color:#FFAB70\">column</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">column)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_parser</span><span style=\"color:#E1E4E8\">(cls, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, token) -> </span><span style=\"color:#9ECBFF\">\"GraphQLSyntaxError\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create syntax error from parser token.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Syntax error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> at '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">token.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            locations</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[Location(</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">token.line, </span><span style=\"color:#FFAB70\">column</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">token.column)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span></code></pre></div>\n\n<p><strong><code>src/graphql_engine/ast/location.py</code></strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"AST location tracking.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Location</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Source location for AST nodes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_token</span><span style=\"color:#E1E4E8\">(cls, token) -> Optional[</span><span style=\"color:#9ECBFF\">\"Location\"</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create Location from token if token has location info.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(token, </span><span style=\"color:#9ECBFF\">'line'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(token, </span><span style=\"color:#9ECBFF\">'column'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">token.line, </span><span style=\"color:#FFAB70\">column</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">token.column)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span></code></pre></div>\n\n<p><strong><code>src/graphql_engine/utils/helpers.py</code></strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"String and position utilities.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_name_start</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if character can start a GraphQL name.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> char.isalpha() </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '_'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_name_continuation</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if character can continue a GraphQL name.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> char.isalnum() </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '_'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> decode_unicode_escape</span><span style=\"color:#E1E4E8\">(match: re.Match) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Decode \\uXXXX escape sequence.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hex_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> match.group(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> chr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(hex_str, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Invalid Unicode, return replacement character</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\ufffd</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_string_value</span><span style=\"color:#E1E4E8\">(string_literal: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse GraphQL string literal with escape sequences.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Remove surrounding quotes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> string_literal[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Replace escape sequences</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    replacements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#DBEDFF\">\"</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'\"'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#DBEDFF\">/</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#DBEDFF\">b</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\b</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#DBEDFF\">f</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\f</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#DBEDFF\">n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#DBEDFF\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#DBEDFF\">t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> pattern, replacement </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> replacements:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.sub(pattern, replacement, content)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Replace Unicode escapes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.sub(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#DBEDFF\">u</span><span style=\"color:#79B8FF\">([0-9a-fA-F]</span><span style=\"color:#F97583\">{4}</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, decode_unicode_escape, content)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> content</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> calculate_line_column</span><span style=\"color:#E1E4E8\">(source: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Calculate line and column for a position in source string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> position </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(source):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(source) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Count lines from start to position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, char </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(source):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> position:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            column </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Handle \\r\\n as single newline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(source) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> source[i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            column </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            column </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> line, column</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong><code>src/graphql_engine/ast/nodes.py</code></strong> (Partial skeleton):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"AST node definitions using dataclasses.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Any, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .location </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Location</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Node</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all AST nodes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loc: Optional[Location] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Document</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Root node representing a complete GraphQL document.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    definitions: List[</span><span style=\"color:#9ECBFF\">'Definition'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get operation by name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get fragment by name</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Definition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for definitions (operations, fragments).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OperationDefinition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Definition</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Operation definition (query, mutation, subscription).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"query\"</span><span style=\"color:#6A737D\">  # \"query\", \"mutation\", \"subscription\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variable_definitions: List[</span><span style=\"color:#9ECBFF\">'VariableDefinition'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives: List[</span><span style=\"color:#9ECBFF\">'Directive'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selection_set: </span><span style=\"color:#9ECBFF\">'SelectionSet'</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\">: SelectionSet())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to validate operation type is valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get all variable names used</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SelectionSet</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Collection of fields/fragments within {...}.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selections: List[</span><span style=\"color:#9ECBFF\">'Selection'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to check if selection set is empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get all field names in selection set</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Selection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for selections (fields, fragment spreads, inline fragments).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Field</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Selection</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Field selection with optional alias, arguments, directives.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alias: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    arguments: List[</span><span style=\"color:#9ECBFF\">'Argument'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives: List[</span><span style=\"color:#9ECBFF\">'Directive'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selection_set: Optional[SelectionSet] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add property to get actual field name (alias or name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to get argument value by name</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Continue implementing all AST nodes from NAMING CONVENTIONS:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - FragmentDefinition, FragmentSpread, InlineFragment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Argument, Directive, VariableDefinition, Variable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - NamedType, ListType, NonNullType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - All Value subclasses (IntValue, StringValue, ListValue, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Use the exact field names from the naming conventions table</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Note: Use forward references as strings for types not defined yet</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Example: selection_set: Optional['SelectionSet'] = None</span></span></code></pre></div>\n\n<p><strong><code>src/graphql_engine/parser/lexer.py</code></strong> (Partial skeleton):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"GraphQL lexer/tokenizer.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum, auto</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..error </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLSyntaxError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Types of GraphQL tokens.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EOF</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NAME</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FLOAT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STRING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCK_STRING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PUNCTUATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SPREAD</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add all token types from the Token Types Table</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A GraphQL token with value and location.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: TokenType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Token(</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.type.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, '</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">', </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.column</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Tokenizer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Converts GraphQL source string into tokens.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, source: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.line </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.column </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_char: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._advance()  </span><span style=\"color:#6A737D\"># Initialize current_char</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _advance</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Advance to next character in source.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement character advancement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Update position, line, column</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Handle \\r\\n as single newline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Set current_char or None if EOF</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _peek</span><span style=\"color:#E1E4E8\">(self) -> Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Look at next character without consuming it.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return next character without advancing position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _skip_whitespace_and_comments</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Skip over whitespace and comments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Advance past spaces, tabs, commas, and #-comments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Comments run from # to end of line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _read_name</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read a GraphQL name token.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Starting from current_char (already validated as name start)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Collect characters while is_name_continuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Return collected string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _read_number</span><span style=\"color:#E1E4E8\">(self) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, TokenType]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read integer or float literal.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Optional leading minus sign</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Integer part</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Optional decimal point and fractional part  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Optional exponent (e/E with optional +/- and digits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return (value_string, TokenType.INT or TokenType.FLOAT)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _read_string</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read regular string literal with escapes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Starting quote</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Characters with escape sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Closing quote</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Use parse_string_value helper for escape processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _read_block_string</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read triple-quoted block string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Starting \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Content with special whitespace handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Closing \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Implement \"trim indentation\" algorithm from GraphQL spec</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> next_token</span><span style=\"color:#E1E4E8\">(self) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return next token from source.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._skip_whitespace_and_comments()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_char </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> Token(TokenType.</span><span style=\"color:#79B8FF\">EOF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.line, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.column)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_line </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.line</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_column </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.column</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement token detection logic:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check for spread (...)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check for name start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check for number start (digit or - followed by digit)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check for string (\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check for block string (\"\"\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Otherwise single-character punctuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Call appropriate _read_* method and return Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: For unknown character, raise GraphQLSyntaxError.from_lexer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> tokenize</span><span style=\"color:#E1E4E8\">(self) -> List[Token]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return all tokens from source.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            token </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.next_token()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tokens.append(token)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> token.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TokenType.</span><span style=\"color:#79B8FF\">EOF</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> tokens</span></span></code></pre></div>\n\n<p><strong><code>src/graphql_engine/parser/parser.py</code></strong> (Partial skeleton):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Recursive descent parser for GraphQL.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..error </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLSyntaxError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..ast.nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> *</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .lexer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tokenizer, Token, TokenType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parses GraphQL documents from tokens.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, source: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tokenizer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Tokenizer(source)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tokens: List[Token] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._fill_tokens()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _fill_tokens</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Pre-load all tokens.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.tokenizer.tokenize()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _peek</span><span style=\"color:#E1E4E8\">(self) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Look at current token without consuming it.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return token at current position or EOF if at end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _advance</span><span style=\"color:#E1E4E8\">(self) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Consume and return current token.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return current token and advance position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _expect</span><span style=\"color:#E1E4E8\">(self, token_type: TokenType, value: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Expect and consume a specific token type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if current token matches expected type/value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # If match: advance and return token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # If no match: raise GraphQLSyntaxError.from_parser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_document</span><span style=\"color:#E1E4E8\">(self) -> Document:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse a complete GraphQL document.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement according to parsing algorithm steps:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Create empty definitions list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. While not at EOF: parse_definition and add to list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Return Document(definitions)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_definition</span><span style=\"color:#E1E4E8\">(self) -> Definition:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse a single definition (operation or fragment).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check current token:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - If NAME and value is \"fragment\": return parse_fragment_definition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - If NAME and value is operation type: return parse_operation_definition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - If { (anonymous operation): return parse_operation_definition with default type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Otherwise: raise syntax error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_operation_definition</span><span style=\"color:#E1E4E8\">(self, operation_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"query\"</span><span style=\"color:#E1E4E8\">) -> OperationDefinition:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse operation definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement according to grammar:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Parse optional name (if NAME token)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Parse optional variable definitions (if '(')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Parse optional directives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. Parse selection_set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 5. Return OperationDefinition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_selection_set</span><span style=\"color:#E1E4E8\">(self) -> SelectionSet:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse {...} selection set.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement recursive parsing:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Expect '{'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Create empty selections list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. While token ≠ '}': parse_selection and add to list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. Expect '}'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 5. Return SelectionSet(selections)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_selection</span><span style=\"color:#E1E4E8\">(self) -> Selection:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse field, fragment spread, or inline fragment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check tokens:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - If ...: return parse_fragment (spread or inline)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Otherwise: return parse_field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_field</span><span style=\"color:#E1E4E8\">(self) -> Field:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse field selection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement field parsing:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Parse optional alias (NAME followed by ':')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Parse field name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Parse optional arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. Parse optional directives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 5. Parse optional selection_set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 6. Return Field with all components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement remaining parsing methods:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - parse_fragment_definition, parse_fragment_spread, parse_inline_fragment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - parse_arguments, parse_directives, parse_variable_definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - parse_value, parse_variable, parse_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - All value literal parsers (int, float, string, list, object, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_query</span><span style=\"color:#E1E4E8\">(self) -> Document:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Public API: Parse GraphQL query string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parse_document()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> GraphQLSyntaxError:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Wrap any unexpected error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> GraphQLSyntaxError(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unexpected parsing error: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                locations</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ) </span><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> e</span></span></code></pre></div>\n\n<p><strong><code>src/graphql_engine/parser/__init__.py</code></strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Public parser API.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Parser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..error </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLSyntaxError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_query</span><span style=\"color:#E1E4E8\">(query_str: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Document:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse GraphQL query string into AST Document.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        query_str: GraphQL query/mutation/subscription string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Document AST node</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        GraphQLSyntaxError: If query has syntax errors</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Parser(query_str)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> parser.parse_query()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_schema</span><span style=\"color:#E1E4E8\">(schema_str: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#9ECBFF\">'TypeDefinition'</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse GraphQL Schema Definition Language.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        schema_str: GraphQL SDL string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        List of type definitions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        GraphQLSyntaxError: If schema has syntax errors</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement in Milestone 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    raise</span><span style=\"color:#79B8FF\"> NotImplementedError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Schema parsing will be implemented in Milestone 2\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<p><strong>Python-Specific Implementation Tips</strong>:</p>\n<ol>\n<li><p><strong>String Handling</strong>: Use <code>str.isdigit()</code>, <code>str.isalpha()</code>, <code>str.isalnum()</code> for character classification. For Unicode names, Python&#39;s methods already handle Unicode correctly.</p>\n</li>\n<li><p><strong>Escape Sequences</strong>: Use <code>re.sub()</code> with a dictionary of replacements for efficient escape sequence processing.</p>\n</li>\n<li><p><strong>Block Strings</strong>: Implement the GraphQL spec&#39;s &quot;trim indentation&quot; algorithm:</p>\n<ul>\n<li>Split into lines</li>\n<li>Find common leading whitespace (excluding first/last lines)</li>\n<li>Remove that whitespace from all lines</li>\n<li>Join with <code>\\n</code></li>\n</ul>\n</li>\n<li><p><strong>Error Messages</strong>: Include both the expected and actual token in error messages: <code>f&quot;Expected &#39;{expected}&#39;, got &#39;{actual.value}&#39;&quot;</code>.</p>\n</li>\n<li><p><strong>Testing</strong>: Use <code>pytest</code> with <code>@pytest.mark.parametrize</code> to test multiple query variations.</p>\n</li>\n<li><p><strong>Performance</strong>: For educational code, clarity beats optimization. Use lists for token storage, simple loops for scanning.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>What to Test After Implementing Parser</strong>:</p>\n<ol>\n<li><strong>Basic Queries</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_parser.py::test_parse_simple_query</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   <strong>Expected</strong>: Test passes, AST contains correct operation type and field names.</p>\n<ol start=\"2\">\n<li><strong>Error Detection</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_parser.py::test_syntax_errors</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   <strong>Expected</strong>: Tests verify that malformed queries raise <code>GraphQLSyntaxError</code> with correct line/column.</p>\n<ol start=\"3\">\n<li><strong>Fragment Handling</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_parser.py::test_fragments</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   <strong>Expected</strong>: Named fragments and inline fragments parse correctly with type conditions.</p>\n<ol start=\"4\">\n<li><strong>Manual Verification</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> graphql_engine.parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   query </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   query GetUser($id: ID!) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">     user(id: $id) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       email @include(if: $showEmail)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">     }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   ast </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_query(query)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Operations: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(ast.definitions)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Variables: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">ast.definitions[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].variable_definitions</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n<p>   <strong>Expected Output</strong>: Shows 1 operation with 1 variable definition and 2 fields.</p>\n<p><strong>Signs Something Is Wrong</strong>:</p>\n<ul>\n<li><strong>Error messages point to wrong line/column</strong>: Check location tracking in tokenizer</li>\n<li><strong>Fragments not being recognized</strong>: Verify <code>...</code> token detection and <code>on</code> keyword handling</li>\n<li><strong>Nested fields cause infinite recursion</strong>: Check <code>parse_selection_set</code> termination condition</li>\n<li><strong>String values have backslashes in them</strong>: Escape sequence processing incomplete</li>\n</ul>\n<p><strong>Diagnostic Tools</strong>:</p>\n<ul>\n<li>Add <code>__repr__</code> methods to AST nodes for readable debugging</li>\n<li>Create a simple AST visualizer: <code>print_ast(ast, indent=0)</code></li>\n<li>Log tokens during parsing: <code>print(f&quot;Parsing {self._peek()}&quot;)</code></li>\n</ul>\n<hr>\n<h2 id=\"component-2-schema-amp-type-system\">Component 2: Schema &amp; Type System</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds directly to Milestone 2: Schema &amp; Type System, which focuses on building the foundational type system that defines what data can be queried and how it&#39;s structured. This component validates that the building plans (type definitions) are consistent and safe before any execution occurs.</p>\n</blockquote>\n<h3 id=\"responsibility-and-scope\">Responsibility and Scope</h3>\n<p>The <strong>Schema &amp; Type System</strong> component serves as the structural blueprint and validation engine for our GraphQL engine. Think of it as the city planning department that reviews architectural blueprints before construction begins—it ensures all buildings (types) follow zoning laws (GraphQL specification), connect properly via roads (relationships), and can safely accommodate residents (data).</p>\n<p><strong>Primary responsibilities include:</strong></p>\n<ul>\n<li><strong>Type Definition Storage:</strong> Representing all GraphQL type kinds (Object, Scalar, Enum, Interface, Union, InputObject, List, NonNull) in memory as structured data</li>\n<li><strong>Schema Construction:</strong> Assembling individual type definitions into a coherent, validated <code>Schema</code> that serves as the single source of truth for what queries are valid</li>\n<li><strong>Type Validation:</strong> Performing comprehensive consistency checks to detect issues like circular references, missing interface implementations, and type name conflicts</li>\n<li><strong>Introspection Implementation:</strong> Providing the built-in <code>__schema</code>, <code>__type</code>, and <code>__typename</code> meta-fields that allow clients to query the schema structure itself</li>\n<li><strong>Type Resolution:</strong> Mapping type names (like <code>&quot;User&quot;</code>) to their corresponding type definitions during query parsing and execution</li>\n</ul>\n<p><strong>Key boundaries and what this component does NOT do:</strong></p>\n<ul>\n<li>Does NOT execute queries or call resolver functions (that&#39;s Component 3&#39;s responsibility)</li>\n<li>Does NOT generate types from databases (that&#39;s Component 4&#39;s responsibility)</li>\n<li>Does NOT validate query structure against schema (that&#39;s a separate validation phase)</li>\n<li>Does NOT handle runtime type coercions during execution (though it defines the rules for them)</li>\n</ul>\n<p>The schema acts as a contract between the GraphQL service and its clients. Once built and validated, it becomes immutable for the duration of execution, ensuring consistent behavior.</p>\n<h3 id=\"mental-model-building-inspector\">Mental Model: Building Inspector</h3>\n<p>Imagine you&#39;re constructing a complex building with many rooms, hallways, and connections. The <strong>type system</strong> is like the complete set of architectural blueprints that define:</p>\n<table>\n<thead>\n<tr>\n<th>Blueprint Element</th>\n<th>GraphQL Equivalent</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Room specifications</td>\n<td><code>ObjectType</code></td>\n<td>Defines what &quot;furniture&quot; (fields) exists in each room and how to access them</td>\n</tr>\n<tr>\n<td>Room connections</td>\n<td><code>InterfaceType</code>/<code>UnionType</code></td>\n<td>Defines common hallways (interfaces) that connect similar rooms, or elevator banks (unions) that group different room types</td>\n</tr>\n<tr>\n<td>Furniture inventory</td>\n<td><code>ScalarType</code></td>\n<td>Defines the basic building blocks (strings, numbers) that make up the furniture</td>\n</tr>\n<tr>\n<td>Delivery instructions</td>\n<td><code>InputObjectType</code></td>\n<td>Defines how to deliver new furniture (input data) to the building</td>\n</tr>\n<tr>\n<td>Building codes</td>\n<td>Validation rules</td>\n<td>Ensures blueprints don&#39;t create fire hazards (circular references) or illegal structures</td>\n</tr>\n</tbody></table>\n<p>The <strong>schema building process</strong> is the building inspector&#39;s review. They check that:</p>\n<ol>\n<li>Every room has proper exits (interface implementations are complete)</li>\n<li>No room leads to infinite hallways (no circular type references in input types)</li>\n<li>All furniture fits through the doors (field argument types are compatible)</li>\n<li>The building has a main entrance (<code>Query</code> type) and possibly service entrances (<code>Mutation</code> and <code>Subscription</code> types)</li>\n</ol>\n<p>When introspection queries arrive, it&#39;s like giving visitors a self-guided tour map—the building inspector provides a simplified version of the blueprints that shows what&#39;s publicly accessible without revealing construction secrets.</p>\n<h3 id=\"type-system-interface\">Type System Interface</h3>\n<p>The type system exposes a clean API for defining types, building schemas, and querying type information. Here are the key interfaces:</p>\n<table>\n<thead>\n<tr>\n<th>Method/Function</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_schema()</code></td>\n<td><code>query_type: ObjectType</code>, <code>mutation_type: Optional[ObjectType]</code>, <code>subscription_type: Optional[ObjectType]</code>, <code>types: Optional[List[GraphQLType]]</code>, <code>directives: Optional[List[GraphQLDirective]]</code></td>\n<td><code>Schema</code></td>\n<td>Constructs a validated schema from type definitions. Automatically includes introspection types and validates all type references.</td>\n</tr>\n<tr>\n<td><code>get_type(schema, name)</code></td>\n<td><code>schema: Schema</code>, <code>name: str</code></td>\n<td><code>Optional[GraphQLType]</code></td>\n<td>Looks up a type by name in the schema&#39;s type registry. Used internally during query validation and execution.</td>\n</tr>\n<tr>\n<td><code>is_input_type(type)</code></td>\n<td><code>type: GraphQLType</code></td>\n<td><code>bool</code></td>\n<td>Returns <code>True</code> if the type can be used as an input (scalar, enum, input object, or lists/non-nulls thereof). Critical for validating field arguments.</td>\n</tr>\n<tr>\n<td><code>is_output_type(type)</code></td>\n<td><code>type: GraphQLType</code></td>\n<td><code>bool</code></td>\n<td>Returns <code>True</code> if the type can be used as output (object, interface, union, scalar, enum, or lists/non-nulls thereof).</td>\n</tr>\n<tr>\n<td><code>assert_valid_schema(schema)</code></td>\n<td><code>schema: Schema</code></td>\n<td><code>None</code> (raises <code>GraphQLError</code> on failure)</td>\n<td>Performs comprehensive validation of schema consistency. Called automatically by <code>create_schema()</code>.</td>\n</tr>\n<tr>\n<td><code>introspection_schema()</code></td>\n<td>(none)</td>\n<td><code>Schema</code></td>\n<td>Returns the built-in introspection schema that powers <code>__schema</code> and <code>__type</code> queries. This is merged with user-defined schemas.</td>\n</tr>\n</tbody></table>\n<p>The core data structures follow the naming conventions exactly. Here&#39;s the complete set of type definitions with all fields:</p>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Fields</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GraphQLType</code></td>\n<td><code>name: str</code>, <code>description: Optional[str]</code></td>\n<td>Base class for all GraphQL types. The <code>description</code> field supports documentation that appears in tools like GraphiQL.</td>\n</tr>\n<tr>\n<td><code>ScalarType</code></td>\n<td>Inherits from <code>GraphQLType</code> plus: <code>serialize: Callable</code>, <code>parse_value: Callable</code>, <code>parse_literal: Callable</code></td>\n<td>Represents leaf values like strings, numbers, or custom types. The three functions handle conversion between Python values, JSON values, and AST literals.</td>\n</tr>\n<tr>\n<td><code>ObjectType</code></td>\n<td>Inherits from <code>GraphQLType</code> plus: <code>fields: Dict[str, GraphQLField]</code>, <code>interfaces: List[InterfaceType]</code></td>\n<td>Represents a concrete object with fields. Each field has its own type and arguments. Objects can implement multiple interfaces.</td>\n</tr>\n<tr>\n<td><code>GraphQLField</code></td>\n<td><code>type: GraphQLType</code>, <code>args: Dict[str, GraphQLArgument]</code>, <code>resolve: Optional[Callable]</code>, <code>description: Optional[str]</code>, <code>deprecation_reason: Optional[str]</code></td>\n<td>A field on an object type. The <code>resolve</code> function is stored here but only invoked by the execution engine.</td>\n</tr>\n<tr>\n<td><code>GraphQLArgument</code></td>\n<td><code>type: GraphQLType</code>, <code>default_value: Any</code>, <code>description: Optional[str]</code></td>\n<td>An argument to a field. Default values are used when the argument isn&#39;t provided in the query.</td>\n</tr>\n<tr>\n<td><code>InterfaceType</code></td>\n<td>Inherits from <code>GraphQLType</code> plus: <code>fields: Dict[str, GraphQLField]</code>, <code>resolve_type: Optional[Callable]</code></td>\n<td>Abstract type defining a set of fields that implementing objects must include. <code>resolve_type</code> determines which concrete object type to use at runtime.</td>\n</tr>\n<tr>\n<td><code>UnionType</code></td>\n<td>Inherits from <code>GraphQLType</code> plus: <code>types: List[ObjectType]</code>, <code>resolve_type: Optional[Callable]</code></td>\n<td>Represents a type that could be one of several object types. Like interfaces but without shared fields definition.</td>\n</tr>\n<tr>\n<td><code>EnumType</code></td>\n<td>Inherits from <code>GraphQLType</code> plus: <code>values: Dict[str, EnumValue]</code></td>\n<td>Fixed set of allowed string values. The <code>EnumValue</code> includes <code>value: Any</code>, <code>description: Optional[str]</code>, and <code>deprecation_reason: Optional[str]</code>.</td>\n</tr>\n<tr>\n<td><code>InputObjectType</code></td>\n<td>Inherits from <code>GraphQLType</code> plus: <code>fields: Dict[str, GraphQLInputField]</code></td>\n<td>Used for complex inputs, like in mutations. Similar to objects but for input values only.</td>\n</tr>\n<tr>\n<td><code>GraphQLInputField</code></td>\n<td><code>type: GraphQLType</code>, <code>default_value: Any</code>, <code>description: Optional[str]</code></td>\n<td>A field on an input object. Simpler than <code>GraphQLField</code> as it has no arguments or resolver.</td>\n</tr>\n<tr>\n<td><code>Schema</code></td>\n<td><code>query_type: ObjectType</code>, <code>mutation_type: Optional[ObjectType]</code>, <code>subscription_type: Optional[ObjectType]</code>, <code>types: Dict[str, GraphQLType]</code>, <code>directives: Dict[str, GraphQLDirective]</code></td>\n<td>The complete schema containing all types. The <code>types</code> dictionary includes all types referenced in the schema (including built-in scalars and introspection types).</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The separation between <code>ObjectType</code> (for output) and <code>InputObjectType</code> (for input) is fundamental to GraphQL&#39;s design. Output types can have resolvers and support interfaces/unions, while input types must be serializable and cannot have those features. This distinction prevents confusing and potentially insecure patterns.</p>\n</blockquote>\n<h3 id=\"schema-building-algorithm\">Schema Building Algorithm</h3>\n<p>Building a valid schema involves multiple validation passes to ensure internal consistency. Here&#39;s the step-by-step algorithm:</p>\n<ol>\n<li><p><strong>Collect All Types</strong>: Starting from the root operation types (<code>query_type</code>, <code>mutation_type</code>, <code>subscription_type</code>), recursively traverse all referenced types:</p>\n<ul>\n<li>For each <code>ObjectType</code>, collect its fields&#39; return types and argument types</li>\n<li>For each <code>InterfaceType</code>, collect its fields&#39; return types and argument types  </li>\n<li>For each <code>UnionType</code>, collect its member types</li>\n<li>For each field&#39;s arguments, collect the argument types</li>\n<li>For <code>ListType</code> and <code>NonNullType</code>, collect their wrapped types</li>\n</ul>\n</li>\n<li><p><strong>Validate Type Uniqueness</strong>: Ensure no two types share the same name (case-sensitive). Built-in types (<code>Int</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code>, <code>ID</code>, introspection types) are included and cannot be redefined.</p>\n</li>\n<li><p><strong>Validate Root Operation Types</strong>: </p>\n<ul>\n<li>The <code>query_type</code> must be an <code>ObjectType</code> and is required</li>\n<li>If provided, <code>mutation_type</code> and <code>subscription_type</code> must be <code>ObjectType</code></li>\n<li>These types must exist in the collected types</li>\n</ul>\n</li>\n<li><p><strong>Validate Object Types</strong> (for each <code>ObjectType</code>):</p>\n<ul>\n<li>Validate each field&#39;s name is unique within the object</li>\n<li>Validate field argument names are unique within each field</li>\n<li>Validate field argument types are input types (<code>is_input_type</code> returns true)</li>\n<li>Validate interfaces: for each interface the object claims to implement:<ul>\n<li>The interface must be an <code>InterfaceType</code></li>\n<li>The object must include all fields from the interface (name, type, and arguments must match exactly)</li>\n<li>Interface field arguments must be identical (same name, type, and default value)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Validate Interface Types</strong> (for each <code>InterfaceType</code>):</p>\n<ul>\n<li>Validate each field&#39;s name is unique within the interface</li>\n<li>Validate field argument names are unique within each field</li>\n<li>Validate field argument types are input types</li>\n<li>Check for circular interface implementations (interface A cannot implement interface B if B implements A, directly or indirectly)</li>\n</ul>\n</li>\n<li><p><strong>Validate Union Types</strong> (for each <code>UnionType</code>):</p>\n<ul>\n<li>Must have at least one member type</li>\n<li>All member types must be <code>ObjectType</code> (not interfaces, scalars, etc.)</li>\n<li>Member type names must be unique within the union</li>\n</ul>\n</li>\n<li><p><strong>Validate Enum Types</strong> (for each <code>EnumType</code>):</p>\n<ul>\n<li>Must have at least one value</li>\n<li>Enum value names must be unique within the enum</li>\n<li>Values must follow GraphQL name rules (only letters, numbers, and underscore)</li>\n</ul>\n</li>\n<li><p><strong>Validate Input Object Types</strong> (for each <code>InputObjectType</code>):</p>\n<ul>\n<li>Validate each field&#39;s name is unique within the input object</li>\n<li>Validate field types are input types</li>\n<li><strong>Crucially, detect circular references</strong>: No input object field can eventually reference itself through nested input objects. Use depth-first search with a visited set.</li>\n</ul>\n</li>\n<li><p><strong>Validate Scalar Types</strong>: Built-in scalars are pre-defined. Custom scalars must provide all three conversion functions (<code>serialize</code>, <code>parse_value</code>, <code>parse_literal</code>).</p>\n</li>\n<li><p><strong>Validate Directives</strong>: For each directive defined in the schema:</p>\n<ul>\n<li>Validate directive name follows naming conventions</li>\n<li>Validate directive locations are valid (QUERY, MUTATION, FIELD, etc.)</li>\n<li>Validate directive arguments follow the same rules as field arguments</li>\n</ul>\n</li>\n<li><p><strong>Build Type Map</strong>: Create a dictionary mapping type names to type instances, including all built-in types and introspection types. This map becomes the source of truth for type lookups.</p>\n</li>\n<li><p><strong>Mark Schema as Validated</strong>: Once all validation passes, the schema is considered valid and immutable. Any attempt to modify types after validation should raise an error.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Design Principle:</strong> Schema validation is idempotent. Calling <code>assert_valid_schema()</code> on an already-validated schema should return immediately. This allows the validation to be lazy but also eagerly checked during development.</p>\n</blockquote>\n<h3 id=\"architecture-decision-type-representation\">Architecture Decision: Type Representation</h3>\n<blockquote>\n<p><strong>Decision: Object-Oriented Type Hierarchy with Immutable Schemas</strong></p>\n<ul>\n<li><strong>Context:</strong> We need to represent all GraphQL type kinds in Python while maintaining type safety, enabling easy validation, and supporting introspection. The representation must be both human-friendly for schema builders and efficient for the execution engine.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Functional/Data-Centric Approach:</strong> Types as plain dictionaries with <code>kind</code> fields, using functional validators</li>\n<li><strong>Object-Oriented with Mutable Types:</strong> Classes with inheritance, allowing types to be modified after creation</li>\n<li><strong>Object-Oriented with Immutable Types:</strong> Classes with inheritance where types are frozen after schema creation</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Object-oriented hierarchy with immutable schemas (Option 3). Each type kind gets its own class inheriting from <code>GraphQLType</code>, and once a schema is built, its types cannot be modified.</li>\n<li><strong>Rationale:</strong> <ul>\n<li><strong>Type Safety:</strong> Python&#39;s class hierarchy provides natural &quot;is-a&quot; relationships that match GraphQL&#39;s type system (an <code>ObjectType</code> <em>is a</em> <code>GraphQLType</code>)</li>\n<li><strong>Performance:</strong> Method dispatch via <code>isinstance()</code> checks is faster than dictionary <code>kind</code> checks</li>\n<li><strong>Immutability:</strong> Prevents subtle bugs where types change during execution. Once validated, the schema is a reliable contract</li>\n<li><strong>Introspection:</strong> Natural place to attach behavior (like validation methods) to type classes</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li>Slightly more boilerplate than dictionary approach</li>\n<li>Requires careful design of base classes to avoid deep inheritance</li>\n<li>Schema building becomes a two-phase process: create mutable type definitions, then freeze into immutable schema</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Functional/Data-Centric</td>\n<td>Simple serialization, minimal boilerplate</td>\n<td>Type checking requires manual <code>kind</code> checks, harder to attach behavior</td>\n<td>Lacks type safety and makes validation code more complex</td>\n</tr>\n<tr>\n<td>OO with Mutable Types</td>\n<td>Flexible for dynamic schema modifications</td>\n<td>Risk of runtime errors if types change during execution</td>\n<td>Mutability introduces race conditions and validation caching issues</td>\n</tr>\n<tr>\n<td><strong>OO with Immutable Types</strong></td>\n<td><strong>Type-safe, performant, reliable execution contract</strong></td>\n<td><strong>Two-phase build process, slightly more code</strong></td>\n<td><strong>Chosen for safety and performance</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-type-system-pitfalls\">Common Type System Pitfalls</h3>\n<p>Building a type system involves subtle traps that can lead to confusing errors or security issues. Here are the most common pitfalls and how to avoid them:</p>\n<p>⚠️ <strong>Pitfall 1: Circular References in Input Types</strong></p>\n<ul>\n<li><strong>Description:</strong> Allowing input object fields that eventually reference themselves, like <code>type Input { self: Input }</code>. This creates infinite recursion during query validation and execution.</li>\n<li><strong>Why It&#39;s Wrong:</strong> GraphQL explicitly forbids circular input references because they can&#39;t be serialized or validated. The specification states input types must be finite.</li>\n<li><strong>Fix:</strong> During input object validation, perform a depth-first search from each input object, tracking visited types. If you encounter the same type again, raise a validation error with the circular path.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 2: Incomplete Interface Implementation</strong></p>\n<ul>\n<li><strong>Description:</strong> An object type claims to implement an interface but misses fields, has field type mismatches, or argument differences.</li>\n<li><strong>Why It&#39;s Wrong:</strong> Breaks the Liskov Substitution Principle—clients expecting interface fields can&#39;t rely on them being present. Causes runtime errors when queries request interface fields on objects that don&#39;t implement them.</li>\n<li><strong>Fix:</strong> When validating interface implementation, compare each interface field with the object&#39;s corresponding field:<ul>\n<li>Field names must match exactly</li>\n<li>Field types must be identical (use deep equality, not just name comparison)</li>\n<li>Arguments must match in name, type, and default value</li>\n<li>Object can have additional fields not in the interface (that&#39;s allowed)</li>\n</ul>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall 3: Confusing Input and Output Types</strong></p>\n<ul>\n<li><strong>Description:</strong> Using output types (objects, interfaces, unions) as field arguments or input object fields, or using input types as field return types.</li>\n<li><strong>Why It&#39;s Wrong:</strong> GraphQL&#39;s type system strictly separates input and output types for good reason. Input types must be serializable (no resolvers, no async), while output types can have behaviors.</li>\n<li><strong>Fix:</strong> Implement <code>is_input_type()</code> and <code>is_output_type()</code> helpers that understand type wrappers (<code>ListType</code>, <code>NonNullType</code>). During validation:<ul>\n<li>Field argument types must be input types</li>\n<li>Input object field types must be input types  </li>\n<li>Field return types must be output types</li>\n</ul>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall 4: Missing Nullable Wrapping Validation</strong></p>\n<ul>\n<li><strong>Description:</strong> Not validating that certain type positions (like list elements) can be nullable when they should be, or vice versa.</li>\n<li><strong>Why It&#39;s Wrong:</strong> GraphQL has specific rules: lists can contain null values unless wrapped in NonNull, but fields can be made non-null. Getting this wrong causes unexpected null errors or missing data.</li>\n<li><strong>Fix:</strong> Follow GraphQL&#39;s type modifier rules: <code>NonNullType</code> can wrap any type except another <code>NonNullType</code>. <code>ListType</code> can wrap any type. Validate these constraints when building types.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 5: Forgetting Built-in Introspection Types</strong></p>\n<ul>\n<li><strong>Description:</strong> Not including <code>__Schema</code>, <code>__Type</code>, <code>__Field</code>, <code>__InputValue</code>, <code>__EnumValue</code>, and <code>__Directive</code> in the type map, or not adding <code>__schema</code>, <code>__type</code>, and <code>__typename</code> fields.</li>\n<li><strong>Why It&#39;s Wrong:</strong> Introspection is a required part of the GraphQL specification. Clients like GraphiQL rely on it to provide autocomplete and documentation.</li>\n<li><strong>Fix:</strong> Always merge the built-in introspection schema with user-defined types. The <code>__typename</code> meta-field should be automatically added to every object and interface type.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Technology Note:</strong> For the type system component, we&#39;ll use Python&#39;s class system with <code>dataclasses</code> for clean representation and <code>typing</code> module for type hints. Since schemas are built once and read many times, we&#39;ll use immutable patterns after validation.</p>\n</blockquote>\n<h4 id=\"a-recommended-file-structure\">A. Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql_engine/\n├── __init__.py\n├── type_system/           # Component 2: Schema &amp; Type System\n│   ├── __init__.py\n│   ├── types.py          # All type class definitions\n│   ├── schema.py         # Schema class and validation logic\n│   ├── introspection.py  # Built-in introspection types and resolvers\n│   ├── scalars.py        # Built-in scalar definitions\n│   └── validation/       # Schema validation rules\n│       ├── __init__.py\n│       ├── rules.py      # Individual validation rules\n│       └── validator.py  # Validation orchestration\n└── parser/               # Component 1 (already built)\n    └── ...</code></pre></div>\n\n<h4 id=\"b-infrastructure-starter-code\">B. Infrastructure Starter Code</h4>\n<p>Here&#39;s complete, working code for the foundational type classes. Learners should place this in <code>type_system/types.py</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#79B8FF\"> __future__</span><span style=\"color:#F97583\"> import</span><span style=\"color:#E1E4E8\"> annotations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Callable, Dict, List, Optional, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Base type that all GraphQL types inherit from</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLType</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all GraphQL types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Built-in scalar types</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ScalarType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL scalar type definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialize: Callable[[Any], Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parse_value: Callable[[Any], Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parse_literal: Callable[[Any], Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Field definition for object and interface types</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLField</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A field on a GraphQL object or interface type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: GraphQLType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLArgument] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resolve: Optional[Callable[[Any, Any, Any, Any], Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deprecation_reason: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Argument definition for fields and directives</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLArgument</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"An argument to a field or directive.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: GraphQLType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    default_value: Optional[Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Object type with fields and interfaces</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ObjectType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL object type definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fields: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLField] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    interfaces: List[InterfaceType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Interface type definition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InterfaceType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL interface type definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fields: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLField] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resolve_type: Optional[Callable[[Any, Any], </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Union type definition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UnionType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL union type definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    types: List[ObjectType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resolve_type: Optional[Callable[[Any, Any], </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Enum value definition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EnumValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A value in a GraphQL enum type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: Any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deprecation_reason: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Enum type definition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EnumType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL enum type definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, EnumValue] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Input field definition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLInputField</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A field on a GraphQL input object type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: GraphQLType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    default_value: Optional[Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Input object type definition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InputObjectType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL input object type definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fields: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLInputField] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type modifiers (List and NonNull)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ListType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL list type wrapper.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    of_type: GraphQLType </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Override name to be derived from of_type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        object</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__setattr__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'[</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.of_type.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">]'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NonNullType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLType</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL non-null type wrapper.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    of_type: GraphQLType </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Override name to be derived from of_type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        object</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__setattr__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.of_type.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">!'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Schema definition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Schema</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Root GraphQL schema containing all types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    query_type: ObjectType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutation_type: Optional[ObjectType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscription_type: Optional[ObjectType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    types: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLDirective] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">repr</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Directive definition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLDirective</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GraphQL directive definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    locations: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLArgument] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span></code></pre></div>\n\n<h4 id=\"c-core-logic-skeleton\">C. Core Logic Skeleton</h4>\n<p>Learners should implement the schema validation logic in <code>type_system/schema.py</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .types </span><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> *</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_schema</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    query_type: ObjectType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutation_type: Optional[ObjectType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscription_type: Optional[ObjectType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    additional_types: Optional[List[GraphQLType]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives: Optional[List[GraphQLDirective]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> Schema:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Create and validate a complete GraphQL schema.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        query_type: The root query type (required)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        mutation_type: Optional root mutation type</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        subscription_type: Optional root subscription type</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        additional_types: Extra types to include in the schema</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        directives: Custom directives supported by the schema</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        A validated, immutable Schema object</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        GraphQLError: If the schema is invalid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Collect all types starting from root operation types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Start with query_type, mutation_type, subscription_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Recursively collect referenced types (field types, argument types, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Include built-in scalar types (Int, Float, String, Boolean, ID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Include introspection types (from get_introspection_types())</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Add any additional_types provided</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Build type map: Dict[str, GraphQLType] mapping names to instances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Check for duplicate type names (case-sensitive)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Built-in types cannot be redefined</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate all types according to GraphQL specification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Call validate_schema() with the complete type map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - This should check: object types, interfaces, unions, enums, input objects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create directives dictionary if directives provided</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return frozen Schema object with all validated components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_schema</span><span style=\"color:#E1E4E8\">(schema: Schema) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validate a complete schema for consistency.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This implements the validation rules from the GraphQL specification.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Should be called automatically by create_schema().</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        GraphQLError: With descriptive message about the first violation found</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate root operation types exist and are ObjectType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate all objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Check field uniqueness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Check argument uniqueness and valid types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Verify interface implementations are complete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate all interfaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Check field uniqueness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Check for circular interface implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate all unions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Must have at least one member type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Members must be ObjectType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate all enums</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Must have at least one value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Value names must be unique</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Validate all input objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Check field uniqueness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Verify no circular references (use depth-first search)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Validate directives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Check valid locations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Validate directive arguments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_input_type</span><span style=\"color:#E1E4E8\">(type_: GraphQLType) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Return True if the type can be used as an input type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Input types are: scalars, enums, input objects, and lists/non-nulls thereof.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Output types (objects, interfaces, unions) cannot be used as inputs.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle type modifiers (ListType, NonNullType)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Unwrap to the inner type and check recursively</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check the base type kind</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Return True for: ScalarType, EnumType, InputObjectType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Return False for: ObjectType, InterfaceType, UnionType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_output_type</span><span style=\"color:#E1E4E8\">(type_: GraphQLType) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Return True if the type can be used as an output type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Output types are: objects, interfaces, unions, scalars, enums, and lists/non-nulls thereof.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Input objects cannot be used as outputs.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle type modifiers (ListType, NonNullType)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check the base type kind</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Return True for: ObjectType, InterfaceType, UnionType, ScalarType, EnumType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Return False for: InputObjectType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"d-language-specific-hints\">D. Language-Specific Hints</h4>\n<ul>\n<li><strong>Use <code>@dataclass(frozen=True)</code></strong> for immutability. This prevents accidental modifications after schema creation.</li>\n<li><strong>Implement <code>__post_init__</code></strong> for computed fields like <code>ListType.name</code> that depends on <code>of_type.name</code>.</li>\n<li><strong>For circular reference detection</strong>, use a depth-first search with a <code>visited</code> set. Python&#39;s recursion limit may be hit for very deep chains, so consider iterative approach or <code>sys.setrecursionlimit()</code>.</li>\n<li><strong>Use <code>typing.get_type_hints()</code></strong> for better introspection of your own types during development.</li>\n<li><strong>Consider <code>functools.lru_cache</code></strong> for expensive validation results that are called repeatedly.</li>\n</ul>\n<h4 id=\"e-milestone-checkpoint\">E. Milestone Checkpoint</h4>\n<p>After implementing Component 2, learners should test their type system:</p>\n<ol>\n<li><strong>Run the validation tests:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> graphql_engine/type_system/tests/</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><p><strong>Expected output should show:</strong></p>\n<ul>\n<li>All built-in scalar types are defined and have conversion functions</li>\n<li>Simple schema creation succeeds with valid types</li>\n<li>Invalid schemas raise descriptive <code>GraphQLError</code> messages</li>\n<li>Introspection types are present in every schema</li>\n</ul>\n</li>\n<li><p><strong>Manual verification steps:</strong></p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Create a simple valid schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> graphql_engine.type_system </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_schema, ObjectType, GraphQLField, ScalarType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Define a simple object type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   user_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ObjectType(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">       name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"User\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">       fields</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"id\"</span><span style=\"color:#E1E4E8\">: GraphQLField(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ScalarType(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"ID\"</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"name\"</span><span style=\"color:#E1E4E8\">: GraphQLField(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ScalarType(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"String\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Create schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_schema(</span><span style=\"color:#FFAB70\">query_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">user_type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Verify introspection types exist</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   assert</span><span style=\"color:#9ECBFF\"> \"__Schema\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> schema.types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   assert</span><span style=\"color:#9ECBFF\"> \"__Type\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> schema.types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   assert</span><span style=\"color:#9ECBFF\"> \"__typename\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> user_type.fields  </span><span style=\"color:#6A737D\"># Auto-added field</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Schema created successfully!\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li><strong>Error:</strong> &quot;Type &#39;String&#39; not found&quot; → Forgot to include built-in scalar types</li>\n<li><strong>Error:</strong> &quot;Can&#39;t add field to frozen dataclass&quot; → Trying to modify types after schema creation</li>\n<li><strong>Error:</strong> Maximum recursion depth exceeded → Circular reference detection not working</li>\n<li><strong>Missing:</strong> No <code>__typename</code> field on objects → Introspection field addition not implemented</li>\n</ul>\n</li>\n<li><p><strong>Debugging tips:</strong></p>\n<ul>\n<li>Visualize the type hierarchy using the class diagram: <img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Ftype-system-class-diagram.svg\" alt=\"Type System Class Diagram\"></li>\n<li>Print the schema&#39;s type map to see all registered types</li>\n<li>Use <code>graphql_engine.parser.parse_schema()</code> to parse SDL and test against your type builder</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"component-3-query-execution-engine\">Component 3: Query Execution Engine</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 3: Query Execution, which focuses on executing GraphQL queries against a schema, resolving fields, handling errors, and managing data fetching efficiently.</p>\n</blockquote>\n<h3 id=\"responsibility-and-scope\">Responsibility and Scope</h3>\n<p>The <strong>Query Execution Engine</strong> is the core runtime that transforms parsed GraphQL queries into actual data. It&#39;s responsible for coordinating the entire resolution process from the root of the query down to every leaf field. The engine doesn&#39;t fetch data itself but orchestrates a network of <strong>resolver functions</strong> that do the actual work.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>In Scope</th>\n<th>Out of Scope</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Resolver Invocation</strong></td>\n<td>Calling the appropriate resolver function for each field with correct arguments, parent value, and context.</td>\n<td>Implementing business logic within resolvers (provided by user).</td>\n</tr>\n<tr>\n<td><strong>Error Propagation</strong></td>\n<td>Collecting field errors, maintaining partial results, and following GraphQL error spec for null propagation.</td>\n<td>Retry logic or external error reporting (e.g., to monitoring services).</td>\n</tr>\n<tr>\n<td><strong>Parallel Execution</strong></td>\n<td>Executing independent sibling fields concurrently when possible to improve performance.</td>\n<td>Distributed execution across multiple machines or microservices.</td>\n</tr>\n<tr>\n<td><strong>Null Handling</strong></td>\n<td>Enforcing GraphQL&#39;s nullability rules: non-null field errors bubble up to nearest nullable parent.</td>\n<td>Database NULL value interpretation (handled by SQL compiler).</td>\n</tr>\n<tr>\n<td><strong>Argument Coercion</strong></td>\n<td>Converting raw variable/argument values (strings, numbers) to the expected GraphQL type (Int, Float, etc.).</td>\n<td>Complex input validation beyond type correctness (e.g., business rules).</td>\n</tr>\n<tr>\n<td><strong>DataLoader Integration</strong></td>\n<td>Providing infrastructure for batching and caching to solve N+1 query problems.</td>\n<td>Implementing specific batch loading logic for every data source.</td>\n</tr>\n<tr>\n<td><strong>Context Management</strong></td>\n<td>Passing a shared <code>ExecutionContext</code> object through all resolvers for request-scoped state.</td>\n<td>Authentication/authorization logic (though context may hold user info).</td>\n</tr>\n</tbody></table>\n<p>The execution engine is purely synchronous in its core algorithm, but it can be extended to support asynchronous resolvers (returning promises/futures). Its primary output is an <code>ExecutionResult</code> containing the final data and any errors encountered.</p>\n<h3 id=\"mental-model-assembly-line\">Mental Model: Assembly Line</h3>\n<p>Think of query execution as an <strong>automobile assembly line</strong>. The raw materials (the query AST and root value) enter at the start. The assembly line has multiple stations (resolvers), each responsible for adding a specific part (field data) to the growing vehicle (result object). The conveyor belt moves the partially assembled vehicle from station to station.</p>\n<p><strong>Key parallels:</strong></p>\n<ul>\n<li><strong>Work Order (Query AST):</strong> The blueprint specifying exactly which parts to install and in what order.</li>\n<li><strong>Assembly Stations (Resolvers):</strong> Specialized workers that know how to fetch or compute specific parts (field values).</li>\n<li><strong>Conveyor Belt (Execution Path):</strong> The sequential flow from root fields down to nested selections.</li>\n<li><strong>Quality Control (Error Handling):</strong> If a station fails to install a required part (non-null field error), the entire vehicle might be scrapped (null propagated upward), but optional parts can be missing without halting production.</li>\n<li><strong>Parallel Workstations (Sibling Fields):</strong> Some stations can work simultaneously on different parts of the same vehicle (parallel field execution).</li>\n</ul>\n<p>This mental model emphasizes that execution is a <strong>coordinated, sequential process</strong> where each step builds upon previous results, with strict rules about what happens when things go wrong.</p>\n<h3 id=\"execution-interface\">Execution Interface</h3>\n<p>The public API of the execution engine is intentionally minimal. The primary entry point is a single function that accepts all necessary inputs and returns a complete result.</p>\n<table>\n<thead>\n<tr>\n<th>Method Signature</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>execute_query(schema, document_ast, variable_values=None, operation_name=None, context_value=None, root_value=None)</code></td>\n<td><code>ExecutionResult</code></td>\n<td>Executes a GraphQL query/mutation against the provided schema. This is the main public interface.</td>\n</tr>\n<tr>\n<td><code>execute_query</code> Parameters</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>schema</code></td>\n<td><code>Schema</code></td>\n<td>The GraphQL schema defining types and resolvers.</td>\n</tr>\n<tr>\n<td><code>document_ast</code></td>\n<td><code>Document</code></td>\n<td>The parsed AST from <code>parse_query</code>.</td>\n</tr>\n<tr>\n<td><code>variable_values</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Values for variables defined in the operation.</td>\n</tr>\n<tr>\n<td><code>operation_name</code></td>\n<td><code>Optional[str]</code></td>\n<td>Name of operation to execute if document contains multiple.</td>\n</tr>\n<tr>\n<td><code>context_value</code></td>\n<td><code>Any</code></td>\n<td>Arbitrary value passed to all resolvers (e.g., database connection, user info).</td>\n</tr>\n<tr>\n<td><code>root_value</code></td>\n<td><code>Any</code></td>\n<td>Initial parent value for root-level resolvers (often <code>None</code> or a special root object).</td>\n</tr>\n</tbody></table>\n<p>The <code>ExecutionContext</code> type is created internally and contains all the runtime state:</p>\n<table>\n<thead>\n<tr>\n<th><code>ExecutionContext</code> Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>schema</code></td>\n<td><code>Schema</code></td>\n<td>Reference to the schema being executed against.</td>\n</tr>\n<tr>\n<td><code>document_ast</code></td>\n<td><code>Document</code></td>\n<td>The parsed query document.</td>\n</tr>\n<tr>\n<td><code>operation_name</code></td>\n<td><code>Optional[str]</code></td>\n<td>Name of the operation being executed.</td>\n</tr>\n<tr>\n<td><code>variable_values</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Values for variables after coercion.</td>\n</tr>\n<tr>\n<td><code>context_value</code></td>\n<td><code>Any</code></td>\n<td>The context value passed from user (immutable during execution).</td>\n</tr>\n<tr>\n<td><code>root_value</code></td>\n<td><code>Any</code></td>\n<td>The root value passed from user.</td>\n</tr>\n<tr>\n<td><code>fragments</code></td>\n<td><code>Dict[str, FragmentDefinition]</code></td>\n<td>Map of fragment name to definition for quick lookup.</td>\n</tr>\n<tr>\n<td><code>errors</code></td>\n<td><code>List[GraphQLError]</code></td>\n<td>Accumulated errors during execution.</td>\n</tr>\n<tr>\n<td><code>data_loaders</code></td>\n<td><code>Dict[str, DataLoader]</code></td>\n<td>Map of DataLoader instances for batching.</td>\n</tr>\n<tr>\n<td><code>path</code></td>\n<td><code>List[PathSegment]</code></td>\n<td>Current field path (list of field names/array indices) for error tracking.</td>\n</tr>\n<tr>\n<td><code>field_resolver</code></td>\n<td><code>Callable</code></td>\n<td>Default function to resolve fields when no resolver is defined.</td>\n</tr>\n<tr>\n<td><code>type_resolver</code></td>\n<td><code>Callable</code></td>\n<td>Default function to resolve concrete type for abstract types.</td>\n</tr>\n</tbody></table>\n<p>The <code>ExecutionResult</code> is the final output:</p>\n<table>\n<thead>\n<tr>\n<th><code>ExecutionResult</code> Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>data</code></td>\n<td><code>Optional[Dict]</code></td>\n<td>The result data if execution succeeded (may be partial with errors).</td>\n</tr>\n<tr>\n<td><code>errors</code></td>\n<td><code>List[GraphQLError]</code></td>\n<td>List of errors encountered during execution.</td>\n</tr>\n<tr>\n<td><code>extensions</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Optional extension metadata for profiling, tracing, etc.</td>\n</tr>\n</tbody></table>\n<h3 id=\"execution-algorithm\">Execution Algorithm</h3>\n<p>The execution follows a <strong>depth-first, recursive resolution</strong> pattern with special handling for null propagation and parallel execution. Below is the step-by-step algorithm for the main <code>execute_query</code> function:</p>\n<ol>\n<li><p><strong>Operation Selection:</strong></p>\n<ol>\n<li>Extract all operation definitions from <code>document_ast.definitions</code>.</li>\n<li>If <code>operation_name</code> is provided, find the operation with that name. If not found, raise an error.</li>\n<li>If <code>operation_name</code> is <code>None</code> and there&#39;s exactly one operation, select it. If there are multiple operations, raise an error (must specify name).</li>\n<li>The selected operation must be either <code>query</code> or <code>mutation</code> (subscriptions are out of scope).</li>\n</ol>\n</li>\n<li><p><strong>Variable Coercion:</strong></p>\n<ol>\n<li>For each <code>VariableDefinition</code> in the operation&#39;s <code>variable_definitions</code>:<ul>\n<li>Get the provided value from <code>variable_values</code> dict.</li>\n<li>If no value provided, check for <code>default_value</code>. If present, use it.</li>\n<li>If no value and no default, and the variable type is non-null, raise an error.</li>\n<li><strong>Coerce</strong> the value to match the variable&#39;s GraphQL type using the type system&#39;s <code>parse_value</code> functions (for scalars) or recursive validation (for input objects/lists).</li>\n<li>Store coerced value in the execution context&#39;s <code>variable_values</code>.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Fragment Collection:</strong></p>\n<ol>\n<li>Gather all <code>FragmentDefinition</code> nodes from the document into a dictionary keyed by name for O(1) lookup during execution.</li>\n</ol>\n</li>\n<li><p><strong>Root Field Execution:</strong></p>\n<ol>\n<li>Determine the root <code>ObjectType</code> based on operation type: <code>schema.query_type</code> for queries, <code>schema.mutation_type</code> for mutations.</li>\n<li>Create initial <code>ExecutionContext</code> with all the prepared state.</li>\n<li>Call <code>execute_operation(execution_context, operation, root_object_type, root_value)</code>.<ul>\n<li><strong><code>execute_operation</code> algorithm:</strong><ol>\n<li>Initialize an empty result map <code>{}</code>.</li>\n<li>Call <code>execute_selection_set(execution_context, operation.selection_set, root_object_type, root_value, result_map)</code>.</li>\n<li>Return <code>result_map</code>.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Selection Set Execution (<code>execute_selection_set</code>):</strong></p>\n<ol>\n<li>For each <code>selection</code> in the selection set:<ul>\n<li>If selection is a <code>Field</code>:<ul>\n<li>Call <code>execute_field(execution_context, parent_type, parent_value, field)</code>.</li>\n</ul>\n</li>\n<li>If selection is a <code>FragmentSpread</code>:<ul>\n<li>Look up the fragment definition by name.</li>\n<li>Check if the fragment&#39;s <code>type_condition</code> matches <code>parent_type</code> (using <code>does_fragment_condition_match</code>).</li>\n<li>If it matches, recursively execute the fragment&#39;s <code>selection_set</code> via <code>execute_selection_set</code>.</li>\n</ul>\n</li>\n<li>If selection is an <code>InlineFragment</code>:<ul>\n<li>Check if the fragment&#39;s <code>type_condition</code> matches <code>parent_type</code> (or if no condition, it always matches).</li>\n<li>If it matches, recursively execute the fragment&#39;s <code>selection_set</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Field Execution (<code>execute_field</code>):</strong></p>\n<ol>\n<li><strong>Field Definition Lookup:</strong> Get the <code>GraphQLField</code> definition from <code>parent_type.fields[field.name]</code>.</li>\n<li><strong>Argument Coercion:</strong> For each argument in the field definition&#39;s <code>args</code>, compute its value:<ul>\n<li>If the field AST has an <code>Argument</code> with matching name, use its value (coercing literals/variables).</li>\n<li>Otherwise, use the argument&#39;s <code>default_value</code> if defined.</li>\n<li>If no value and argument is non-null, raise an error.</li>\n</ul>\n</li>\n<li><strong>Path Tracking:</strong> Push the field&#39;s name (or alias) onto <code>execution_context.path</code>.</li>\n<li><strong>Resolver Selection:</strong><ul>\n<li>Use the field definition&#39;s <code>resolve</code> function if provided.</li>\n<li>Otherwise, use the default <code>execution_context.field_resolver</code> (which typically returns a property from the parent object).</li>\n</ul>\n</li>\n<li><strong>Resolver Invocation:</strong> Call the resolver with arguments: <code>(parent_value, args, execution_context.context_value, info)</code> where <code>info</code> is an object containing field metadata, schema, and path.</li>\n<li><strong>Result Processing:</strong><ul>\n<li>If resolver raises an exception, catch it, add a <code>GraphQLError</code> to <code>execution_context.errors</code>, and set <code>result = None</code>.</li>\n<li>If resolver returns a value, call <code>complete_value(execution_context, field.type, result)</code>.</li>\n</ul>\n</li>\n<li><strong>Path Popping:</strong> Pop from <code>execution_context.path</code>.</li>\n<li>Return the completed value.</li>\n</ol>\n</li>\n<li><p><strong>Value Completion (<code>complete_value</code>):</strong></p>\n<ol>\n<li>If <code>value</code> is <code>None</code>:<ul>\n<li>If the expected type is non-null (<code>NonNullType</code>), add an error and return <code>None</code> (error will bubble).</li>\n<li>Otherwise, return <code>None</code>.</li>\n</ul>\n</li>\n<li>If expected type is a <code>ListType</code>:<ul>\n<li>Ensure <code>value</code> is iterable. For each item, recursively call <code>complete_value</code> with the list&#39;s inner type.</li>\n<li>Return a new list with completed items. If any item completion results in <code>None</code> (due to non-null error), the entire list becomes <code>None</code>.</li>\n</ul>\n</li>\n<li>If expected type is a <code>ScalarType</code> or <code>EnumType</code>:<ul>\n<li>Call the type&#39;s <code>serialize</code> function to ensure the value is in the correct output format.</li>\n</ul>\n</li>\n<li>If expected type is an <code>ObjectType</code>, <code>InterfaceType</code>, or <code>UnionType</code>:<ul>\n<li>Determine the concrete <code>ObjectType</code> (for interfaces/unions, use <code>resolve_type</code> callback).</li>\n<li>Call <code>execute_selection_set</code> with this concrete type and the <code>value</code> as the new parent.</li>\n<li>Return the resulting map.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Parallel Execution:</strong> Sibling fields (fields at the same nesting level in a selection set) have no implicit dependencies. The engine can execute them concurrently. In practice, this is implemented by:</p>\n<ul>\n<li>Gathering all field promises/futures at a given level.</li>\n<li>Waiting for all to complete before proceeding to nested selections.</li>\n<li>This is especially powerful when combined with <code>DataLoader</code> batching.</li>\n</ul>\n</li>\n<li><p><strong>Result Assembly:</strong> After the root operation completes, package the final <code>result_map</code> and collected <code>errors</code> into an <code>ExecutionResult</code> and return it.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> The algorithm&#39;s recursive structure mirrors the GraphQL query&#39;s hierarchical shape. Each level of recursion corresponds to a level of nesting in the query, with the <code>complete_value</code> function handling type-specific behavior at each step.</p>\n</blockquote>\n<h3 id=\"architecture-decision-execution-strategy\">Architecture Decision: Execution Strategy</h3>\n<blockquote>\n<p><strong>Decision: Synchronous Core with Async/Await Integration</strong></p>\n<ul>\n<li><strong>Context:</strong> GraphQL resolvers often need to fetch data from asynchronous sources (databases, APIs). The execution engine must support this without blocking. We must choose between a purely synchronous design, a callback-based async design, or leveraging modern async/await patterns.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Purely Synchronous:</strong> All resolvers return plain values. Simple to implement but cannot handle I/O efficiently.</li>\n<li><strong>Callback/Promise-based:</strong> Resolvers return promises/tasks; engine manages a promise chain. Matches JavaScript&#39;s GraphQL.js but adds complexity.</li>\n<li><strong>Async/Await Core:</strong> Engine uses <code>async</code>/<code>await</code> throughout; resolvers can be sync or async. Leverages Python&#39;s <code>asyncio</code> natively.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Implement a <strong>synchronous core</strong> with clear extension points for async execution. The base algorithm assumes synchronous resolvers, but we provide an alternative <code>execute_query_async</code> entry point that uses <code>asyncio</code> for async resolvers. This keeps the learning curve gentle while allowing real-world use.</li>\n<li><strong>Rationale:</strong><ul>\n<li><strong>Educational Value:</strong> Understanding the synchronous algorithm is foundational; async adds complexity that can be layered on later.</li>\n<li><strong>Language Support:</strong> Python&#39;s <code>asyncio</code> is not trivial for beginners; offering both modes caters to different skill levels.</li>\n<li><strong>Performance:</strong> For many use cases (especially with DataLoader batching), synchronous execution with threaded pools is sufficient.</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li>Learners must implement two execution paths if they want full async support.</li>\n<li>The synchronous engine cannot natively await async resolvers; they must be wrapped.</li>\n<li>The design allows incremental adoption: start with sync, then add async later.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Purely Synchronous</strong></td>\n<td>Simple implementation, easy to debug, no event loop complexity.</td>\n<td>Cannot efficiently handle I/O-bound resolvers, poor real-world performance.</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Callback/Promise-based</strong></td>\n<td>Matches GraphQL.js pattern, enables non-blocking I/O.</td>\n<td>Complex control flow, callback hell, difficult error handling.</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Async/Await Core</strong></td>\n<td>Native Python support, clean syntax, excellent for I/O.</td>\n<td>Requires <code>asyncio</code> understanding, all resolvers must be async, harder to debug.</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Sync Core + Async Extension</strong></td>\n<td>Gentle learning curve, incremental adoption, supports both models.</td>\n<td>Two execution paths to maintain, sync-to-async bridging required.</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-execution-pitfalls\">Common Execution Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Missing Null Propagation</strong></p>\n<ul>\n<li><strong>Description:</strong> When a non-null field resolver returns <code>None</code> or raises an error, the engine must &quot;bubble up&quot; the null to the nearest nullable parent field per the GraphQL spec. Forgetting this rule leads to incorrect partial results or type errors.</li>\n<li><strong>Why It&#39;s Wrong:</strong> The spec is explicit: if a non-null field errors, its parent becomes <code>null</code> (if nullable), or continues bubbling. Violating this breaks client expectations and causes invalid response shapes.</li>\n<li><strong>Fix:</strong> In <code>complete_value</code>, when encountering a <code>None</code> value for a <code>NonNullType</code>, add an error and return <code>None</code>. The caller (<code>execute_field</code>) must then propagate this <code>None</code> upward appropriately.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Naive N+1 Query Problem</strong></p>\n<ul>\n<li><strong>Description:</strong> Resolving a list of objects, then resolving a related field on each object triggers separate database queries (N+1). This cripples performance.</li>\n<li><strong>Why It&#39;s Wrong:</strong> Executing hundreds of queries for a single GraphQL request is inefficient and can overload the database.</li>\n<li><strong>Fix:</strong> Implement the <strong>DataLoader pattern</strong>. Create a <code>DataLoader</code> per request that batches individual loader calls into a single batched query. The execution engine should provide a <code>data_loaders</code> dict in the context for resolvers to use.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Improper Error Handling Swallowing Exceptions</strong></p>\n<ul>\n<li><strong>Description:</strong> If a resolver raises an exception and the engine doesn&#39;t catch it, the entire query fails with a generic 500 error, losing the specific error details.</li>\n<li><strong>Why It&#39;s Wrong:</strong> GraphQL requires errors to be captured per-field and included in the <code>errors</code> array of the response, allowing partial data with errors.</li>\n<li><strong>Fix:</strong> Wrap every resolver invocation in a try-catch. Convert caught exceptions to <code>GraphQLError</code> with appropriate <code>path</code> and <code>locations</code>. Add to <code>execution_context.errors</code> but continue executing other fields.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Executing Resolvers in Wrong Order (Depth-First vs. Breadth-First)</strong></p>\n<ul>\n<li><strong>Description:</strong> The execution order matters for side effects and optimal batching. A naive depth-first approach might serialize independent sibling fields unnecessarily.</li>\n<li><strong>Why It&#39;s Wrong:</strong> Missing opportunities for parallel execution reduces performance. For mutations, the spec requires sequential execution in the order they appear.</li>\n<li><strong>Fix:</strong> Separate query and mutation execution. For queries, use a <strong>breadth-first approach</strong> for sibling fields to enable batching and parallelism. For mutations, enforce strict depth-first, left-to-right execution as per spec.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to Coerce Argument Values</strong></p>\n<ul>\n<li><strong>Description:</strong> Passing raw string/int values from variables directly to resolvers without converting them to the correct GraphQL type (e.g., string <code>&quot;5&quot;</code> to integer <code>5</code>).</li>\n<li><strong>Why It&#39;s Wrong:</strong> Resolvers expect correctly typed arguments; mismatches cause runtime errors or incorrect behavior.</li>\n<li><strong>Fix:</strong> In <code>execute_field</code>, for each defined argument, call <code>value_from_ast</code> (using the type system&#39;s <code>parse_literal</code>/<code>parse_value</code>) to convert AST values/variables to the appropriate Python type.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Concurrency</strong></td>\n<td><code>threading.ThreadPoolExecutor</code> for parallel field execution.</td>\n<td><code>asyncio</code> with <code>async</code>/<code>await</code> for true async I/O.</td>\n</tr>\n<tr>\n<td><strong>DataLoader</strong></td>\n<td>Custom batching cache using dictionaries and a simple batch function.</td>\n<td>Full <code>DataLoader</code> implementation with request-scoped caching, prime caching, and clear methods.</td>\n</tr>\n<tr>\n<td><strong>Error Tracking</strong></td>\n<td>Simple list of error dictionaries with message and path.</td>\n<td>Full <code>GraphQLError</code> objects with extensions, original exception wrapping, and location formatting.</td>\n</tr>\n<tr>\n<td><strong>Resolver Info</strong></td>\n<td>Pass a simple dictionary with field name, args, etc.</td>\n<td>Formal <code>ResolveInfo</code> class with schema, root value, operation, and field nodes.</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql_engine/\n│\n├── execution/\n│   ├── __init__.py\n│   ├── executor.py           # Main synchronous Executor class\n│   ├── executor_async.py     # Optional async Executor class\n│   ├── values.py             # complete_value and type-specific completion\n│   ├── errors.py             # GraphQLError class and error formatting\n│   ├── dataloader.py         # DataLoader implementation\n│   └── middleware.py         # Execution middleware (future extension)\n│\n├── schema/                   # From Component 2\n├── parser/                   # From Component 1\n└── utils/\n    └── helpers.py</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong><code>errors.py</code> - Complete GraphQLError Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, List, Any, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Location</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    locations: Optional[List[Location]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_error: Optional[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    extensions: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert error to GraphQL spec response format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_dict: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"message\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.message}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.locations:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            error_dict[</span><span style=\"color:#9ECBFF\">\"locations\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [{</span><span style=\"color:#9ECBFF\">\"line\"</span><span style=\"color:#E1E4E8\">: loc.line, </span><span style=\"color:#9ECBFF\">\"column\"</span><span style=\"color:#E1E4E8\">: loc.column} </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> loc </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.locations]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.path:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            error_dict[</span><span style=\"color:#9ECBFF\">\"path\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.extensions:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            error_dict[</span><span style=\"color:#9ECBFF\">\"extensions\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.extensions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> error_dict</span></span></code></pre></div>\n\n<p><strong><code>dataloader.py</code> - Basic DataLoader Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, List, Any, Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> collections </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> defaultdict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DataLoader</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, batch_load_fn: Callable[[List[Any]], List[Any]], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 max_batch_size: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.batch_load_fn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> batch_load_fn</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_batch_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_batch_size</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache: Dict[Any, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.queue: List[Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> load</span><span style=\"color:#E1E4E8\">(self, key: Any) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Schedule key for batch loading, return a future/promise.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check cache - if key exists, return cached value (could be promise)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add key to queue for next batch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If queue length reaches max_batch_size, dispatch batch immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return a promise that will resolve when the batch completes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> dispatch</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process all queued keys in a single batch.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If queue is empty, return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get unique keys from queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call batch_load_fn with list of keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Match results to keys and resolve/reject each promise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Clear queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clear</span><span style=\"color:#E1E4E8\">(self, key: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Remove key from cache.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.cache:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            del</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.cache[key]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clear_all</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clear entire cache.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache.clear()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.queue.clear()</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong><code>executor.py</code> - Main Executor Class:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Optional, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..schema </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema, ObjectType, GraphQLField, NonNullType, ListType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Document, OperationDefinition, Field, FragmentSpread, InlineFragment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .dataloader </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DataLoader</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ExecutionContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Define all fields from the Data Model table above</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use dataclass or simple class with __init__</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Executor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_query</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        schema: Schema,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        document_ast: Document,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        variable_values: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operation_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context_value: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        root_value: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Execute a GraphQL query synchronously.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns a dict with 'data' and 'errors' keys per GraphQL spec.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate schema is properly constructed (schema.types populated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Select operation (query/mutation) based on operation_name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Coerce variable values to their declared types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Collect fragments into a dictionary by name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create ExecutionContext with all parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Determine root operation type (query_type/mutation_type from schema)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Call execute_operation with root type and root_value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Package result and errors into ExecutionResult format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return {'data': result, 'errors': formatted_errors}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_operation</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context: ExecutionContext,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operation: OperationDefinition,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        root_type: ObjectType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        root_value: Any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute a single operation (query or mutation).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize empty result dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get selection set from operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call execute_selection_set with root_type and root_value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return result dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_selection_set</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context: ExecutionContext,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        selection_set: List[Any],  </span><span style=\"color:#6A737D\"># List of Selection nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        object_type: ObjectType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parent_value: Any,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result_map: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute all selections in a set, storing results in result_map.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: For each selection in selection_set:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2:   If selection is Field: call execute_field, store result at field's alias or name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3:   If selection is FragmentSpread: resolve fragment and execute its selection set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4:   If selection is InlineFragment: check type condition and execute its selection set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For query operations: execute sibling fields in parallel (use ThreadPoolExecutor)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: For mutation operations: execute fields strictly sequentially</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_field</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context: ExecutionContext,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parent_type: ObjectType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parent_value: Any,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        field_ast: Field</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Resolve a single field.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get field definition from parent_type.fields[field_ast.name]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Coerce field arguments using value_from_ast</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Build resolve info object with field metadata, schema, etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Get resolver function (field.resolve or default_field_resolver)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Push field name onto context.path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Try: call resolver with (parent_value, args, context.context_value, resolve_info)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Catch Exception: convert to GraphQLError, add to context.errors, set result = None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Call complete_value with field.type and the result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Pop from context.path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Return completed value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> complete_value</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context: ExecutionContext,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        field_type: Any,  </span><span style=\"color:#6A737D\"># GraphQLType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result: Any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert raw resolver result to proper GraphQL type output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If result is None: handle NonNullType error propagation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If field_type is ListType: iterate and complete each item</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If field_type is ScalarType or EnumType: call serialize</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If field_type is ObjectType: execute_selection_set on result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If field_type is InterfaceType or UnionType: resolve concrete type first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return completed value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Default Field Resolver:</strong> Implement a simple default that gets attributes from parent objects:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">  def</span><span style=\"color:#B392F0\"> default_field_resolver</span><span style=\"color:#E1E4E8\">(parent_value, args, context_value, info):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      # If parent_value is a dict, return parent_value.get(info.field_name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      # If parent_value is an object, return getattr(parent_value, info.field_name, None)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      # Otherwise return None</span></span></code></pre></div>\n<ul>\n<li><strong>Parallel Execution:</strong> Use <code>concurrent.futures.ThreadPoolExecutor</code> for synchronous parallel field execution. Remember that mutations must NOT run in parallel.</li>\n<li><strong>Value Coercion:</strong> Leverage the <code>parse_value</code> methods on scalar types you built in Component 2. For input objects, recursively coerce each field.</li>\n<li><strong>Path Tracking:</strong> Use a simple list for <code>context.path</code>. When entering a list item, append the index; when leaving, pop it.</li>\n<li><strong>Error Locations:</strong> Extract <code>line</code> and <code>column</code> from the AST nodes&#39; <code>loc</code> field to populate error locations.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the execution engine, verify it works:</p>\n<ol>\n<li><strong>Run Basic Tests:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/execution/test_basic_resolution.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   Expected output: All tests pass, showing successful field resolution.</p>\n<ol start=\"2\">\n<li><strong>Manual Test with a Simple Schema:</strong>\nCreate a test script:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> graphql_engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> build_schema, execute_query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> build_schema(</span><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">     type Query {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       hello: String</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       user(id: ID!): User</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">     }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">     type User {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       name: String</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       age: Int</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">     }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   \"\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Add resolver functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   schema.query_type.fields[</span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">].resolve </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> lambda</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">_: </span><span style=\"color:#9ECBFF\">\"World\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> execute_query(schema, </span><span style=\"color:#9ECBFF\">\"{ hello }\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(result)  </span><span style=\"color:#6A737D\"># Should show: {'data': {'hello': 'World'}, 'errors': []}</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Check for Common Issues:</strong></p>\n<ul>\n<li><strong>Symptom:</strong> Resolver exceptions crash the entire program.<ul>\n<li><strong>Diagnosis:</strong> Missing try-catch in <code>execute_field</code>.</li>\n<li><strong>Fix:</strong> Wrap resolver call and convert exceptions to <code>GraphQLError</code>.</li>\n</ul>\n</li>\n<li><strong>Symptom:</strong> Nested fields don&#39;t resolve (always return <code>null</code>).<ul>\n<li><strong>Diagnosis:</strong> <code>complete_value</code> not calling <code>execute_selection_set</code> for object types.</li>\n<li><strong>Fix:</strong> Ensure object type completion triggers further execution.</li>\n</ul>\n</li>\n<li><strong>Symptom:</strong> Non-null field errors don&#39;t bubble up.<ul>\n<li><strong>Diagnosis:</strong> Missing null propagation logic in <code>complete_value</code>.</li>\n<li><strong>Fix:</strong> When a non-null field gets <code>None</code>, add error and return <code>None</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Verify Error Handling:</strong></p>\n<ul>\n<li>Intentionally throw an exception in a resolver. The response should include <code>errors</code> array with details, but <code>data</code> may still have partial results.</li>\n<li>Test non-null field: if it returns <code>None</code>, the parent field should become <code>null</code> (if nullable).</li>\n</ul>\n</li>\n<li><p><strong>Performance Check:</strong></p>\n<ul>\n<li>Execute a query with 10 sibling fields. They should resolve concurrently (check timing).</li>\n<li>For mutations, ensure fields execute sequentially even if they don&#39;t depend on each other.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"component-4-database-schema-reflection\">Component 4: Database Schema Reflection</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 4: Database Schema Reflection, which focuses on auto-generating GraphQL schemas from database metadata by introspecting tables, columns, and relationships.</p>\n</blockquote>\n<h3 id=\"responsibility-and-scope\">Responsibility and Scope</h3>\n<p>The <strong>Database Schema Reflection</strong> component acts as a bridge between the relational database world and the GraphQL type system. It transforms the flat, tabular structure of SQL databases into the hierarchical, strongly-typed GraphQL schema that Component 2 (Type System) can understand and Component 3 (Execution Engine) can query.</p>\n<p><strong>What this component DOES:</strong></p>\n<ol>\n<li><strong>Database Connection</strong>: Establishes connections to target databases using appropriate drivers/adapters</li>\n<li><strong>Metadata Introspection</strong>: Queries database system catalogs (like <code>information_schema</code> or <code>pg_catalog</code>) to discover tables, columns, constraints, and relationships</li>\n<li><strong>Type Mapping</strong>: Converts SQL data types (INTEGER, VARCHAR, TIMESTAMP, etc.) to appropriate GraphQL scalar types (<code>Int</code>, <code>String</code>, <code>DateTime</code>, etc.)</li>\n<li><strong>Relationship Detection</strong>: Identifies foreign key constraints and translates them into GraphQL field relationships (one-to-one, one-to-many)</li>\n<li><strong>Schema Generation</strong>: Builds complete <code>ObjectType</code>, <code>InputObjectType</code>, and <code>EnumType</code> instances representing the database structure</li>\n<li><strong>Query/Mutation Generation</strong>: Creates root query fields for CRUD operations (find by ID, list with filtering/pagination) and mutation fields for create/update/delete operations</li>\n<li><strong>Configuration Application</strong>: Applies naming conventions, pluralization rules, and filtering based on configuration options</li>\n</ol>\n<p><strong>What this component does NOT do:</strong></p>\n<ul>\n<li>Execute SQL queries (that&#39;s Component 5: Query to SQL Compilation)</li>\n<li>Validate GraphQL queries (that&#39;s the type system&#39;s responsibility)</li>\n<li>Handle authentication/authorization (explicit non-goal)</li>\n<li>Support real-time schema changes (uses static reflection at startup)</li>\n</ul>\n<p><strong>Key Data Structures This Component Owns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Purpose</th>\n<th>Relationship to Existing Types</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DatabaseMetadata</code></td>\n<td>Container for all introspected database information</td>\n<td>New type specific to this component</td>\n</tr>\n<tr>\n<td><code>TableMetadata</code></td>\n<td>Information about a single database table</td>\n<td>Used to generate <code>ObjectType</code></td>\n</tr>\n<tr>\n<td><code>ColumnMetadata</code></td>\n<td>Information about a single column</td>\n<td>Used to generate <code>GraphQLField</code></td>\n</tr>\n<tr>\n<td><code>ForeignKeyMetadata</code></td>\n<td>Information about foreign key relationships</td>\n<td>Used to generate relationship fields</td>\n</tr>\n<tr>\n<td><code>TypeMapping</code></td>\n<td>Mapping rules between SQL types and GraphQL types</td>\n<td>Configuration-driven</td>\n</tr>\n<tr>\n<td><code>NamingConfig</code></td>\n<td>Rules for naming GraphQL types/fields from database names</td>\n<td>Configuration-driven</td>\n</tr>\n</tbody></table>\n<p><strong>Component Boundaries and Dependencies:</strong></p>\n<ul>\n<li><strong>Input</strong>: Database connection parameters (URL, credentials, schema name)</li>\n<li><strong>Output</strong>: A complete <code>Schema</code> object ready for Component 3 to execute queries against</li>\n<li><strong>Depends On</strong>: Component 2 (Type System) for creating type instances</li>\n<li><strong>Used By</strong>: The main application to bootstrap the GraphQL server with auto-generated schema</li>\n</ul>\n<h3 id=\"mental-model-mirror\">Mental Model: Mirror</h3>\n<p>Think of database schema reflection as holding up a <strong>mirror</strong> to your database. The mirror doesn&#39;t create anything new—it simply reflects what&#39;s already there, but in a different format that GraphQL can understand. Just as a mirror shows your reflection but in reverse, schema reflection shows your database structure but transformed from tables/columns to types/fields.</p>\n<p><strong>Key Aspects of the Mirror Analogy:</strong></p>\n<ol>\n<li><p><strong>Faithful Representation</strong>: A good mirror doesn&#39;t distort reality. Similarly, the reflection should accurately represent the database structure without hiding columns or changing data semantics.</p>\n</li>\n<li><p><strong>Perspective Shift</strong>: When you look in a mirror, you see yourself from a different perspective. Similarly, reflection transforms the database from a relational perspective (tables with foreign keys) to a GraphQL perspective (types with nested fields).</p>\n</li>\n<li><p><strong>Selective Reflection</strong>: Some mirrors are one-way or filtered. Our reflection can be configured to include/exclude certain tables, apply naming conventions, or hide sensitive columns.</p>\n</li>\n<li><p><strong>Static vs. Dynamic</strong>: A traditional mirror shows a static reflection at a moment in time. Our reflection can be either static (captured once at startup) or dynamic (refreshed periodically), with important trade-offs.</p>\n</li>\n</ol>\n<p><strong>Visualizing the Transformation:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Database Structure (Relational)      →      GraphQL Schema (Hierarchical)\n─────────────────────────────────────       ──────────────────────────────\nTable: users                           →      type User {\n  id: INTEGER (PK)                           →    id: ID!\n  name: VARCHAR(255)                         →    name: String\n  email: VARCHAR(255)                        →    email: String\n}                                            →    posts: [Post!]!   ← derived from FK\n                                            \nTable: posts                           →      type Post {\n  id: INTEGER (PK)                           →    id: ID!\n  user_id: INTEGER (FK → users.id)           →    title: String\n  title: VARCHAR(255)                        →    content: String\n  content: TEXT                              →    author: User!     ← derived from FK\n}                                            → }</code></pre></div>\n\n<p>This mental model helps understand that we&#39;re not inventing a new schema—we&#39;re faithfully representing the existing database structure in GraphQL terms, with some opinionated transformations (like converting foreign keys to nested fields).</p>\n<h3 id=\"reflection-interface\">Reflection Interface</h3>\n<p>The reflection component exposes a clean, configuration-driven API that abstracts away database-specific details. Here&#39;s the complete public interface:</p>\n<p><strong>Primary Methods:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>reflect_schema</code></td>\n<td><code>connection_config: Dict[str, Any]</code><br><code>options: ReflectionOptions</code></td>\n<td><code>Schema</code></td>\n<td>Main entry point: connects to database, introspects metadata, builds and returns GraphQL schema</td>\n</tr>\n<tr>\n<td><code>get_database_metadata</code></td>\n<td><code>connection_config: Dict[str, Any]</code><br><code>filter: Optional[TableFilter]</code></td>\n<td><code>DatabaseMetadata</code></td>\n<td>Low-level method that returns raw database metadata without building GraphQL types</td>\n</tr>\n<tr>\n<td><code>generate_types_from_metadata</code></td>\n<td><code>metadata: DatabaseMetadata</code><br><code>options: ReflectionOptions</code></td>\n<td><code>Dict[str, GraphQLType]</code></td>\n<td>Converts database metadata to GraphQL types (can be used independently)</td>\n</tr>\n<tr>\n<td><code>build_schema_from_types</code></td>\n<td><code>types: Dict[str, GraphQLType]</code><br><code>options: ReflectionOptions</code></td>\n<td><code>Schema</code></td>\n<td>Assembles types into a complete schema with query/mutation root types</td>\n</tr>\n</tbody></table>\n<p><strong>Configuration Structure (<code>ReflectionOptions</code>):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>include_tables</code></td>\n<td><code>List[str]</code></td>\n<td><code>[]</code> (all)</td>\n<td>Only reflect tables matching these patterns (supports SQL LIKE wildcards)</td>\n</tr>\n<tr>\n<td><code>exclude_tables</code></td>\n<td><code>List[str]</code></td>\n<td><code>[]</code></td>\n<td>Exclude tables matching these patterns (takes precedence over include)</td>\n</tr>\n<tr>\n<td><code>table_prefix</code></td>\n<td><code>str</code></td>\n<td><code>&quot;&quot;</code></td>\n<td>Prefix to add to all table names when generating GraphQL type names</td>\n</tr>\n<tr>\n<td><code>table_suffix</code></td>\n<td><code>str</code></td>\n<td><code>&quot;&quot;</code></td>\n<td>Suffix to add to all table names when generating GraphQL type names</td>\n</tr>\n<tr>\n<td><code>field_naming_convention</code></td>\n<td><code>NamingConvention</code></td>\n<td><code>CAMEL_CASE</code></td>\n<td>How to convert snake_case column names to GraphQL field names</td>\n</tr>\n<tr>\n<td><code>type_naming_convention</code></td>\n<td><code>NamingConvention</code></td>\n<td><code>PASCAL_CASE</code></td>\n<td>How to convert snake_case table names to GraphQL type names</td>\n</tr>\n<tr>\n<td><code>pluralization_rules</code></td>\n<td><code>Dict[str, str]</code></td>\n<td><code>{&quot;y&quot;: &quot;ies&quot;, ...}</code></td>\n<td>Rules for pluralizing type names in list fields</td>\n</tr>\n<tr>\n<td><code>type_mappings</code></td>\n<td><code>Dict[str, ScalarType]</code></td>\n<td>Built-in defaults</td>\n<td>Override default SQL-to-GraphQL type mappings</td>\n</tr>\n<tr>\n<td><code>include_relationships</code></td>\n<td><code>bool</code></td>\n<td><code>True</code></td>\n<td>Whether to generate fields for foreign key relationships</td>\n</tr>\n<tr>\n<td><code>max_relationship_depth</code></td>\n<td><code>int</code></td>\n<td><code>3</code></td>\n<td>Maximum depth for recursive relationship traversal (prevents cycles)</td>\n</tr>\n<tr>\n<td><code>include_comments</code></td>\n<td><code>bool</code></td>\n<td><code>True</code></td>\n<td>Use database column/table comments as GraphQL descriptions</td>\n</tr>\n<tr>\n<td><code>readonly</code></td>\n<td><code>bool</code></td>\n<td><code>False</code></td>\n<td>If true, only generate query fields (no mutations)</td>\n</tr>\n</tbody></table>\n<p><strong>Connection Configuration Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>database_type</code></td>\n<td><code>str</code></td>\n<td>Yes</td>\n<td><code>&quot;postgresql&quot;</code>, <code>&quot;mysql&quot;</code>, <code>&quot;sqlite&quot;</code>, etc.</td>\n</tr>\n<tr>\n<td><code>host</code></td>\n<td><code>str</code></td>\n<td>Depends</td>\n<td>Database server hostname</td>\n</tr>\n<tr>\n<td><code>port</code></td>\n<td><code>int</code></td>\n<td>Depends</td>\n<td>Database server port</td>\n</tr>\n<tr>\n<td><code>database</code></td>\n<td><code>str</code></td>\n<td>Yes</td>\n<td>Database name</td>\n</tr>\n<tr>\n<td><code>schema</code></td>\n<td><code>str</code></td>\n<td>No</td>\n<td>Schema name (for databases with multiple schemas like PostgreSQL)</td>\n</tr>\n<tr>\n<td><code>username</code></td>\n<td><code>str</code></td>\n<td>Depends</td>\n<td>Authentication username</td>\n</tr>\n<tr>\n<td><code>password</code></td>\n<td><code>str</code></td>\n<td>Depends</td>\n<td>Authentication password</td>\n</tr>\n<tr>\n<td><code>connection_string</code></td>\n<td><code>str</code></td>\n<td>Alternative</td>\n<td>Raw connection string (alternative to individual parameters)</td>\n</tr>\n<tr>\n<td><code>ssl_mode</code></td>\n<td><code>str</code></td>\n<td>No</td>\n<td><code>&quot;disable&quot;</code>, <code>&quot;require&quot;</code>, <code>&quot;verify-ca&quot;</code>, etc.</td>\n</tr>\n<tr>\n<td><code>connection_timeout</code></td>\n<td><code>int</code></td>\n<td>No</td>\n<td>Connection timeout in seconds</td>\n</tr>\n</tbody></table>\n<p><strong>Usage Example in Prose:</strong>\nA developer wants to reflect a PostgreSQL database containing e-commerce tables. They would call:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reflect_schema(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    connection_config</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"database_type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"postgresql\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"host\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"localhost\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"port\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">5432</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"database\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ecommerce\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"username\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"app_user\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"password\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"secure_password\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    options</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ReflectionOptions(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        exclude_tables</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#9ECBFF\">\"audit_%\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"temp_%\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        field_naming_convention</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">NamingConvention.</span><span style=\"color:#79B8FF\">CAMEL_CASE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        type_naming_convention</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">NamingConvention.</span><span style=\"color:#79B8FF\">PASCAL_CASE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        include_comments</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n<p>This would connect to the PostgreSQL database, introspect all tables except those starting with <code>audit_</code> or <code>temp_</code>, convert snake_case column names to camelCase field names, convert snake_case table names to PascalCase type names, and use database comments as GraphQL descriptions.</p>\n<h3 id=\"reflection-algorithm\">Reflection Algorithm</h3>\n<p>The reflection process follows a deterministic, multi-stage pipeline. Each stage transforms the data further toward a complete GraphQL schema. The state machine for this process is visualized in: <img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Freflection-state-machine.svg\" alt=\"Schema Reflection State Machine\"></p>\n<p><strong>Algorithm Steps:</strong></p>\n<ol>\n<li><strong>Connection Establishment</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   1.1. Validate connection configuration parameters\n   1.2. Load appropriate database adapter based on `database_type`\n   1.3. Establish connection using driver-specific method\n   1.4. Verify connection with a simple test query (e.g., `SELECT 1`)\n   1.5. If connection fails, raise `ConnectionError` with diagnostic information</code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Metadata Collection</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   2.1. Query `information_schema.tables` (or equivalent) for table list\n   2.2. Apply table filters (`include_tables`/`exclude_tables`)\n   2.3. For each table:\n       2.3.1. Query `information_schema.columns` for column definitions\n       2.3.2. Query `information_schema.key_column_usage` for primary/foreign keys\n       2.3.3. Query `information_schema.table_constraints` for constraint types\n       2.3.4. Query `pg_description`/equivalent for column/table comments (if `include_comments`)\n   2.4. Build `TableMetadata` objects with:\n       - Table name, schema, comment\n       - List of `ColumnMetadata` with name, type, nullable, default, comment\n       - Primary key column names\n       - List of `ForeignKeyMetadata` with target table/columns</code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Type Mapping</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   3.1. For each column in each table:\n       3.1.1. Identify base SQL type (strip precision/length modifiers)\n       3.1.2. Look up in type mapping table (default + custom overrides)\n       3.1.3. Apply GraphQL type modifiers:\n           - If column is nullable → plain type\n           - If column is NOT NULL → wrap in `NonNullType`\n           - If column is array type → wrap in `ListType`\n       3.1.4. Store mapped GraphQL type in column metadata\n   3.2. Handle special cases:\n       - Columns named `id` or ending in `_id` → map to GraphQL `ID` type\n       - Timestamp/datetime columns → map to custom `DateTime` scalar\n       - JSON/JSONB columns → map to custom `JSON` scalar</code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Relationship Analysis</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   4.1. For each foreign key constraint:\n       4.1.1. Identify source table/columns and target table/columns\n       4.1.2. Determine relationship cardinality:\n           - If target columns include primary key → one-to-one or many-to-one\n           - If source columns include primary key → one-to-one or one-to-many\n       4.1.3. Check for self-referential relationships (table references itself)\n       4.1.4. Detect join tables for many-to-many relationships\n       4.1.5. Build relationship graph with cycle detection\n       4.1.6. Stop traversing at `max_relationship_depth` to prevent infinite cycles\n   4.2. Build bidirectional field definitions:\n       - For one-to-many: parent → children as `[ChildType!]!`\n       - For many-to-one: child → parent as `ParentType!`\n       - For one-to-one: bidirectional singular references</code></pre></div>\n\n<ol start=\"5\">\n<li><strong>GraphQL Type Generation</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   5.1. For each table:\n       5.1.1. Apply naming conventions to generate type name\n       5.1.2. Create `ObjectType` with:\n           - Name: transformed table name\n           - Description: table comment (if available)\n           - Fields: column fields + relationship fields\n       5.1.3. Create `InputObjectType` for mutations:\n           - Name: `Create[TypeName]Input` / `Update[TypeName]Input`\n           - Fields: same as object type but with appropriate nullability\n   5.2. Generate enum types for:\n       - Columns with CHECK constraints limiting to specific values\n       - Columns with foreign keys to small reference/lookup tables\n   5.3. Register all types in type registry with proper dependency ordering</code></pre></div>\n\n<ol start=\"6\">\n<li><strong>Root Query/Mutation Generation</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   6.1. Build root `Query` type with:\n       6.1.1. For each table: `[typeName](id: ID!): TypeName` (single fetch)\n       6.1.2. For each table: `all[pluralTypeName](filter: FilterInput, ...): [TypeName!]!` (list)\n       6.1.3. Pagination arguments: `first`, `last`, `after`, `before`, `offset`, `limit`\n       6.1.4. Filter arguments: per-column filter inputs with operators (eq, ne, lt, gt, etc.)\n       6.1.5. Sort arguments: `orderBy: [TypeNameOrderBy!]`\n   6.2. If not `readonly`, build root `Mutation` type with:\n       6.2.1. `create[TypeName](input: CreateInput!): TypeName!`\n       6.2.2. `update[TypeName](id: ID!, input: UpdateInput!): TypeName!`\n       6.2.3. `delete[TypeName](id: ID!): TypeName!`\n   6.3. Add aggregate fields: `count[TypeName](filter: FilterInput): Int!`</code></pre></div>\n\n<ol start=\"7\">\n<li><strong>Schema Assembly</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   7.1. Create `Schema` object with:\n       7.1.1. `query_type`: Generated Query type\n       7.1.2. `mutation_type`: Generated Mutation type (if not readonly)\n       7.1.3. `types`: All generated GraphQL types\n       7.1.4. `directives`: Standard GraphQL directives\n   7.2. Run schema validation (using Component 2's `validate_schema`)\n   7.3. Return complete schema</code></pre></div>\n\n<p><strong>Concrete Walk-Through Example:</strong></p>\n<p>Consider a simple blog database with <code>users</code> and <code>posts</code> tables. The algorithm would:</p>\n<ol>\n<li>Connect to database and find tables: <code>users</code>, <code>posts</code></li>\n<li>Introspect columns:<ul>\n<li><code>users</code>: <code>id</code> (INTEGER PK), <code>name</code> (VARCHAR), <code>email</code> (VARCHAR)</li>\n<li><code>posts</code>: <code>id</code> (INTEGER PK), <code>user_id</code> (INTEGER FK), <code>title</code> (VARCHAR), <code>content</code> (TEXT)</li>\n</ul>\n</li>\n<li>Detect foreign key: <code>posts.user_id</code> → <code>users.id</code> (many-to-one)</li>\n<li>Map types: INTEGER → <code>Int</code>, VARCHAR → <code>String</code>, TEXT → <code>String</code></li>\n<li>Generate GraphQL types:<ul>\n<li><code>User</code> with fields: <code>id: ID!</code>, <code>name: String</code>, <code>email: String</code>, <code>posts: [Post!]!</code></li>\n<li><code>Post</code> with fields: <code>id: ID!</code>, <code>title: String</code>, <code>content: String</code>, <code>author: User!</code></li>\n</ul>\n</li>\n<li>Generate root fields:<ul>\n<li>Query: <code>user(id: ID!): User</code>, <code>allUsers(...): [User!]!</code>, <code>post(id: ID!): Post</code>, <code>allPosts(...): [Post!]!</code></li>\n<li>Mutation: <code>createUser(...): User!</code>, <code>createPost(...): Post!</code>, etc.</li>\n</ul>\n</li>\n<li>Assemble and validate schema</li>\n</ol>\n<h3 id=\"architecture-decision-reflection-strategy\">Architecture Decision: Reflection Strategy</h3>\n<blockquote>\n<p><strong>Decision: Static Reflection with Configuration-Driven Transformations</strong></p>\n<p><strong>Context</strong>: We need to generate a GraphQL schema from a database schema, but databases and GraphQL have different structural paradigms (tables vs. types, foreign keys vs. nested fields). We must decide how aggressively to transform the database structure and whether to reflect dynamically (on each query) or statically (once at startup).</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Pure 1:1 Reflection</strong>: Map each table to a type, each column to a field, foreign keys remain as scalar ID fields</li>\n<li><strong>Aggressive Transformation</strong>: Automatically create nested fields for relationships, generate pagination/filtering, apply naming conventions</li>\n<li><strong>Dynamic Reflection</strong>: Re-introspect database on each query or schema request</li>\n</ol>\n<p><strong>Decision</strong>: We chose <strong>Static Reflection with Configuration-Driven Transformations</strong> (a balanced approach between options 1 and 2, with static rather than dynamic reflection).</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Performance</strong>: Static reflection happens once at startup, not on every query</li>\n<li><strong>Predictability</strong>: The schema is stable during server runtime</li>\n<li><strong>Customizability</strong>: Configuration options let users choose transformation aggressiveness</li>\n<li><strong>Simplicity</strong>: Static schemas are easier to debug and document</li>\n<li><strong>Compatibility</strong>: Works with GraphQL client tools that expect stable schemas</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li>✅ Schema changes require server restart</li>\n<li>✅ Consistent performance regardless of database size</li>\n<li>✅ Can pre-compute optimized data structures</li>\n<li>❌ Doesn&#39;t automatically pick up database schema changes</li>\n<li>❌ Startup time increases with large databases</li>\n<li>❌ Memory usage for storing the complete reflected schema</li>\n</ul>\n</blockquote>\n<p><strong>Options Comparison Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Pure 1:1 Reflection</strong></td>\n<td>Simple implementation, no surprises</td>\n<td>Poor GraphQL ergonomics (manual joins in queries), doesn&#39;t leverage GraphQL&#39;s strengths</td>\n<td>Too simplistic—defeats purpose of GraphQL&#39;s nested queries</td>\n</tr>\n<tr>\n<td><strong>Aggressive Transformation</strong></td>\n<td>Best developer experience, automatic relationships</td>\n<td>May create unexpected fields, harder to customize</td>\n<td>Chosen as default but with configuration to dial back</td>\n</tr>\n<tr>\n<td><strong>Dynamic Reflection</strong></td>\n<td>Always up-to-date with database, no restarts needed</td>\n<td>Performance overhead, caching complexity, unpredictable schema</td>\n<td>Performance and stability concerns outweigh benefits</td>\n</tr>\n<tr>\n<td><strong>Static with Config</strong> (CHOSEN)</td>\n<td>Balanced, configurable, performant, predictable</td>\n<td>Requires restart for schema changes, memory overhead</td>\n<td>Best trade-off for most use cases</td>\n</tr>\n</tbody></table>\n<p><strong>Supporting Decisions:</strong></p>\n<blockquote>\n<p><strong>Decision: Use Database System Catalogs Over ORM Models</strong></p>\n<p><strong>Context</strong>: We need to introspect database structure. We could either query database system tables (<code>information_schema</code>) or use an ORM&#39;s model introspection.</p>\n<p><strong>Decision</strong>: Query database system catalogs directly.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li>Works with any database without ORM model definitions</li>\n<li>Always reflects actual database state (not potentially stale model code)</li>\n<li>Consistent across different database backends (standardized <code>information_schema</code>)</li>\n<li>No dependency on specific ORM libraries</li>\n</ul>\n<p><strong>Consequences</strong>: Must handle database-specific quirks in system catalog queries.</p>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Configuration-Driven Naming Conventions</strong></p>\n<p><strong>Context</strong>: Database naming conventions (snake_case) differ from GraphQL conventions (camelCase). We must decide how to transform names.</p>\n<p><strong>Decision</strong>: Make naming conventions configurable with sensible defaults.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li>Different teams have different preferences</li>\n<li>Legacy databases may have non-standard naming</li>\n<li>Can adapt to organizational standards</li>\n<li>Default (snake_case → camelCase) follows common GraphQL practice</li>\n</ul>\n<p><strong>Consequences</strong>: Configuration complexity increases but accommodates more use cases.</p>\n</blockquote>\n<p><strong>State Machine Transitions:</strong>\nThe reflection process follows a defined state machine (referenced earlier). Here are the detailed transitions:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DISCONNECTED</code></td>\n<td><code>connect_requested</code></td>\n<td><code>CONNECTING</code></td>\n<td>Validate connection parameters, load database adapter</td>\n</tr>\n<tr>\n<td><code>CONNECTING</code></td>\n<td><code>connection_succeeded</code></td>\n<td><code>INTROSPECTING</code></td>\n<td>Establish connection, verify with test query</td>\n</tr>\n<tr>\n<td><code>CONNECTING</code></td>\n<td><code>connection_failed</code></td>\n<td><code>ERROR</code></td>\n<td>Log error details, clean up connection resources</td>\n</tr>\n<tr>\n<td><code>INTROSPECTING</code></td>\n<td><code>metadata_collected</code></td>\n<td><code>ANALYZING</code></td>\n<td>Query system catalogs, build metadata structures</td>\n</tr>\n<tr>\n<td><code>INTROSPECTING</code></td>\n<td><code>introspection_failed</code></td>\n<td><code>ERROR</code></td>\n<td>Handle permission errors, missing tables, etc.</td>\n</tr>\n<tr>\n<td><code>ANALYZING</code></td>\n<td><code>analysis_complete</code></td>\n<td><code>GENERATING</code></td>\n<td>Map types, detect relationships, build graph</td>\n</tr>\n<tr>\n<td><code>ANALYZING</code></td>\n<td><code>circular_reference</code></td>\n<td><code>ANALYZING</code></td>\n<td>Log warning, apply max depth limit, continue</td>\n</tr>\n<tr>\n<td><code>GENERATING</code></td>\n<td><code>types_generated</code></td>\n<td><code>ASSEMBLING</code></td>\n<td>Create GraphQL types from analyzed metadata</td>\n</tr>\n<tr>\n<td><code>ASSEMBLING</code></td>\n<td><code>schema_built</code></td>\n<td><code>READY</code></td>\n<td>Assemble complete schema, run validation</td>\n</tr>\n<tr>\n<td><code>ASSEMBLING</code></td>\n<td><code>validation_failed</code></td>\n<td><code>ERROR</code></td>\n<td>Log validation errors, suggest fixes</td>\n</tr>\n<tr>\n<td><code>READY</code></td>\n<td><code>reset_requested</code></td>\n<td><code>DISCONNECTED</code></td>\n<td>Close connections, clear cached metadata</td>\n</tr>\n<tr>\n<td>Any state</td>\n<td><code>timeout</code></td>\n<td><code>ERROR</code></td>\n<td>Operation took too long, abort and clean up</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-reflection-pitfalls\">Common Reflection Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Incorrect Type Mapping</strong></p>\n<ul>\n<li><strong>Description</strong>: Mapping a SQL <code>DECIMAL(10,2)</code> to GraphQL <code>Float</code> loses precision, or mapping <code>TIMESTAMP WITH TIME ZONE</code> to <code>String</code> loses type safety.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Data loss, incorrect validation, poor client experience. GraphQL clients expect appropriate scalar types with proper coercion behavior.</li>\n<li><strong>How to Fix</strong>: Create custom scalar types for database-specific types (e.g., <code>Decimal</code>, <code>DateTime</code>, <code>JSON</code>). Use database metadata about precision/scale to choose appropriate mappings.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Missing Circular Relationship Detection</strong></p>\n<ul>\n<li><strong>Description</strong>: Database has self-referential foreign keys (e.g., <code>employee.manager_id → employee.id</code>) or circular chains (A → B → C → A), causing infinite recursion during type generation.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Infinite loops crash the reflection process or generate infinitely nested GraphQL types.</li>\n<li><strong>How to Fix</strong>: Implement cycle detection in relationship graph traversal. Use <code>max_relationship_depth</code> configuration to limit traversal. For self-references, generate a nullable field to break the cycle.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Naming Conflicts</strong></p>\n<ul>\n<li><strong>Description</strong>: Database has tables named <code>user</code> and <code>User</code> (case-insensitive in some databases but distinct in GraphQL), or a column name conflicts with a reserved GraphQL field name like <code>__typename</code>.</li>\n<li><strong>Why It&#39;s Wrong</strong>: GraphQL schema validation fails with duplicate type/field names or reserved word conflicts.</li>\n<li><strong>How to Fix</strong>: Apply name normalization (consistent casing), add prefixes/suffixes to conflicting names, rename reserved words (e.g., <code>type</code> → <code>type_</code>). Log warnings when conflicts are detected and automatically resolved.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Permission Issues</strong></p>\n<ul>\n<li><strong>Description</strong>: Database user lacks permissions to query <code>information_schema</code> or specific tables, causing incomplete or empty reflection.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Generated schema is incomplete, missing tables or columns the application actually needs to access.</li>\n<li><strong>How to Fix</strong>: Validate permissions during connection test. Provide clear error messages suggesting needed privileges. Offer <code>partial_reflection</code> mode that continues with accessible tables and logs warnings for inaccessible ones.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Handling Database-Specific Quirks</strong></p>\n<ul>\n<li><strong>Description</strong>: PostgreSQL arrays, MySQL enum columns, SQLite type affinity, SQL Server schemas—each database has unique features not present in others.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Reflection fails or produces incorrect schemas when encountering unsupported features.</li>\n<li><strong>How to Fix</strong>: Implement database adapters with specialized queries for each database type. Provide extension points for custom type handlers. Default to safe fallbacks (e.g., map unknown types to <code>String</code>).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Database Comments</strong></p>\n<ul>\n<li><strong>Description</strong>: Not using column/table comments from the database as GraphQL descriptions.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Misses opportunity for self-documenting API. GraphQL tools like GraphiQL show descriptions, improving developer experience.</li>\n<li><strong>How to Fix</strong>: Always query for comments when available. Use empty string as default when comments are absent. Make this configurable (<code>include_comments</code> option).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Generating Too Many Types</strong></p>\n<ul>\n<li><strong>Description</strong>: Reflecting every table including system tables, audit logs, temporary tables, or migration history tables.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Schema becomes bloated, confusing, and potentially exposes sensitive system information.</li>\n<li><strong>How to Fix</strong>: Provide filtering options (<code>include_tables</code>, <code>exclude_tables</code>). Default to excluding common system table patterns. Allow regex or glob pattern matching.</li>\n</ul>\n<p><strong>Error Recovery Strategies:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection failure</td>\n<td>Connection timeout or authentication error</td>\n<td>Retry with exponential backoff (max 3 attempts), then raise clear error</td>\n</tr>\n<tr>\n<td>Missing information_schema</td>\n<td>Query returns empty or permission error</td>\n<td>Fall back to database-specific system tables, log warning</td>\n</tr>\n<tr>\n<td>Circular reference detected</td>\n<td>Graph traversal depth exceeds limit</td>\n<td>Stop traversing, make field nullable to break cycle, log warning</td>\n</tr>\n<tr>\n<td>Type mapping not found</td>\n<td>SQL type not in mapping table</td>\n<td>Map to <code>String</code> scalar, log warning with suggestion for custom mapping</td>\n</tr>\n<tr>\n<td>Name conflict</td>\n<td>Duplicate normalized name detected</td>\n<td>Add numeric suffix (<code>_2</code>, <code>_3</code>), log warning with both original names</td>\n</tr>\n<tr>\n<td>Memory exhaustion</td>\n<td>Memory usage exceeds threshold during large DB reflection</td>\n<td>Process in batches, free intermediate data, log progress</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database Adapter</td>\n<td>Single database support (PostgreSQL)</td>\n<td>Pluggable adapters (PostgreSQL, MySQL, SQLite)</td>\n<td>Start with one to learn pattern, extend later</td>\n</tr>\n<tr>\n<td>Connection Pooling</td>\n<td>No pooling (create per reflection)</td>\n<td>Connection pooling with <code>aiopg</code>/<code>asyncpg</code></td>\n<td>Reflection happens rarely, pooling adds complexity</td>\n</tr>\n<tr>\n<td>Metadata Caching</td>\n<td>None (re-introspect each time)</td>\n<td>File cache of serialized metadata</td>\n<td>Speeds up development, reduces database load</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Python dictionary</td>\n<td>Pydantic models with validation</td>\n<td>Type-safe configuration with better error messages</td>\n</tr>\n<tr>\n<td>Naming Utilities</td>\n<td>Simple string replacement</td>\n<td>inflection library (pluralize, camelize)</td>\n<td>More robust handling of edge cases</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql-engine/\n├── reflection/                    # This component\n│   ├── __init__.py\n│   ├── core.py                    # Main reflection entry points\n│   ├── metadata.py                # DatabaseMetadata, TableMetadata, etc.\n│   ├── introspection/             # Database-specific adapters\n│   │   ├── __init__.py\n│   │   ├── base.py                # BaseIntrospector abstract class\n│   │   ├── postgres.py            # PostgreSQL implementation\n│   │   ├── mysql.py               # MySQL implementation\n│   │   └── sqlite.py              # SQLite implementation\n│   ├── mapping/                   # Type mapping logic\n│   │   ├── __init__.py\n│   │   ├── type_mapper.py         # SQL-to-GraphQL type mapping\n│   │   ├── naming.py              # Naming convention utilities\n│   │   └── defaults.py            # Default type mappings per database\n│   ├── generators/                # GraphQL type generators\n│   │   ├── __init__.py\n│   │   ├── object_type.py         # Generate ObjectType from table\n│   │   ├── input_type.py          # Generate InputObjectType\n│   │   ├── query.py               # Generate root Query fields\n│   │   └── mutation.py            # Generate root Mutation fields\n│   ├── analysis/                  # Relationship analysis\n│   │   ├── __init__.py\n│   │   ├── relationship.py        # Detect and analyze relationships\n│   │   ├── graph.py               # Graph traversal for cycles\n│   │   └── cardinality.py         # Determine 1:1, 1:many, many:many\n│   └── config.py                  # Configuration models\n├── types/                         # Component 2 (Type System)\n└── execution/                     # Component 3 (Execution Engine)</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete Database Adapter Base Class:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># reflection/introspection/base.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ColumnMetadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Metadata for a database column.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table_schema: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_nullable: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_primary_key: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    default_value: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    character_maximum_length: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    numeric_precision: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    numeric_scale: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    comment: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TableMetadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Metadata for a database table.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    comment: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    columns: List[ColumnMetadata]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    primary_key_columns: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    foreign_keys: List[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DatabaseMetadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Complete database metadata.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tables: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, TableMetadata]  </span><span style=\"color:#6A737D\"># key: f\"{schema}.{name}\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    enums: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]       </span><span style=\"color:#6A737D\"># enum name → list of values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    version: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                      # database version</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BaseIntrospector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract base class for database introspectors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, connection_config: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.connection_config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> connection_config</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.connection </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> connect</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Establish database connection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> introspect_tables</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               schema: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               include_tables: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               exclude_tables: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> DatabaseMetadata:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Introspect all tables in the database.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> get_table_comment</span><span style=\"color:#E1E4E8\">(self, table_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, schema: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get comment/description for a table.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> get_column_comments</span><span style=\"color:#E1E4E8\">(self, table_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, schema: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get comments for all columns in a table.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> close</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Close database connection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.connection:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.connection.close()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __enter__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Use async context manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __exit__</span><span style=\"color:#E1E4E8\">(self, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#79B8FF\"> __aenter__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.connect()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#79B8FF\"> __aexit__</span><span style=\"color:#E1E4E8\">(self, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.close()</span></span></code></pre></div>\n\n<p><strong>Complete Configuration Models with Validation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># reflection/config.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pydantic </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseModel, Field, validator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NamingConvention</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Naming convention options.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CAMEL_CASE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"camel_case\"</span><span style=\"color:#6A737D\">       # column_name → columnName</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PASCAL_CASE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"pascal_case\"</span><span style=\"color:#6A737D\">     # column_name → ColumnName</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SNAKE_CASE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"snake_case\"</span><span style=\"color:#6A737D\">       # column_name → column_name (unchanged)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    KEBAB_CASE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"kebab_case\"</span><span style=\"color:#6A737D\">       # column_name → column-name</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ReflectionOptions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseModel</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration options for schema reflection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Table filtering</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    include_tables: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exclude_tables: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Naming conventions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table_prefix: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table_suffix: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    field_naming_convention: NamingConvention </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NamingConvention.</span><span style=\"color:#79B8FF\">CAMEL_CASE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type_naming_convention: NamingConvention </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NamingConvention.</span><span style=\"color:#79B8FF\">PASCAL_CASE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Type mapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type_mappings: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Relationships</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    include_relationships: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_relationship_depth: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Field(</span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ge</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">le</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Features</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    include_comments: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    readonly: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    include_aggregates: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    include_filters: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    include_pagination: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @validator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'exclude_tables'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_filters</span><span style=\"color:#E1E4E8\">(cls, v, values):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Ensure include/exclude don't conflict in confusing ways.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> values.get(</span><span style=\"color:#9ECBFF\">'include_tables'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> v:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Warn if a table is both included and excluded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            conflicts </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(values[</span><span style=\"color:#9ECBFF\">'include_tables'</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> conflicts:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                import</span><span style=\"color:#E1E4E8\"> warnings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                warnings.warn(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    f</span><span style=\"color:#9ECBFF\">\"Tables </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">conflicts</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> are both included and excluded. \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"Exclude takes precedence.\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Main Reflection Entry Point:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># reflection/core.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .config </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ReflectionOptions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .metadata </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DatabaseMetadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .introspection </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> get_introspector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .mapping.type_mapper </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TypeMapper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .generators.object_type </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> generate_object_types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .generators.query </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> generate_root_query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .generators.mutation </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> generate_root_mutation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema, ObjectType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> reflect_schema</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connection_config: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    options: Optional[ReflectionOptions] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> Schema:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Main entry point: reflect database schema to GraphQL schema.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        connection_config: Database connection parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        options: Configuration options for reflection</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Complete GraphQL Schema object</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ConnectionError: If database connection fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ReflectionError: If schema reflection fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Connect to database using appropriate introspector</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Collect metadata (tables, columns, constraints)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Analyze relationships and build graph</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Map SQL types to GraphQL types</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Generate GraphQL types from metadata</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Generate root Query and Mutation types</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        7. Assemble and validate complete schema</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate connection_config has required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set default options if not provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Get appropriate introspector for database type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Connect to database and collect metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Apply table filtering (include_tables/exclude_tables)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Detect and analyze relationships between tables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Map SQL types to GraphQL types using TypeMapper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Generate GraphQL ObjectType for each table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Generate root Query type with query fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: If not readonly, generate root Mutation type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Assemble Schema object with all types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 12: Validate schema using Component 2's validate_schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 13: Return complete schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> get_database_metadata</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connection_config: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    include_tables: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exclude_tables: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> DatabaseMetadata:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Low-level method to get raw database metadata without building GraphQL types.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Useful for debugging or custom schema generation pipelines.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get introspector for database type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Connect to database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Introspect tables with given filters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return DatabaseMetadata object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Type Mapper with Default Mappings:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># reflection/mapping/type_mapper.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..metadata </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ColumnMetadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLType, ScalarType, ListType, NonNullType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TypeMapper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Maps SQL data types to GraphQL types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Default type mappings for PostgreSQL</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    POSTGRES_MAPPINGS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"integer\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Int\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"bigint\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Int\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"smallint\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Int\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"numeric\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Decimal\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Custom scalar</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"decimal\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Decimal\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"real\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Float\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"double precision\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Float\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"text\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"String\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"varchar\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"String\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"char\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"String\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"boolean\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Boolean\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"DateTime\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamptz\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"DateTime\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"date\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Date\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"time\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Time\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"json\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"JSON\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"jsonb\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"JSON\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"uuid\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ID\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"bytea\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"String\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Base64 encoded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, custom_mappings: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.mappings </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">POSTGRES_MAPPINGS</span><span style=\"color:#E1E4E8\">.copy()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> custom_mappings:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.mappings.update(custom_mappings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> map_column_type</span><span style=\"color:#E1E4E8\">(self, column: ColumnMetadata) -> GraphQLType:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Map a database column to a GraphQL type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            column: Column metadata including data_type, is_nullable, etc.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            GraphQL type with appropriate modifiers (List, NonNull)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            1. Get base SQL type (strip length/precision modifiers)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            2. Look up in mappings table</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            3. Apply NonNull wrapper if column is NOT NULL</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            4. Apply List wrapper if column is array type</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            5. Special handling for ID columns (name ends with _id or is primary key)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Normalize SQL type (e.g., \"varchar(255)\" → \"varchar\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Look up in self.mappings, fall back to \"String\" if not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Get GraphQL scalar type from registry or create custom scalar</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check if column is array type (ends with [] in PostgreSQL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If array, wrap in ListType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Check if column is nullable (is_nullable flag)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If NOT nullable, wrap in NonNullType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Special case: columns named 'id' or ending in '_id' → ID type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return complete type with all modifiers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_custom_mapping</span><span style=\"color:#E1E4E8\">(self, sql_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, graphql_type: GraphQLType) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a custom SQL-to-GraphQL type mapping.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate graphql_type is a scalar type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add to mappings dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Log warning if overwriting existing mapping</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Relationship Detector:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># reflection/analysis/relationship.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Set, Tuple, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..metadata </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TableMetadata, DatabaseMetadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Relationship</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a relationship between two tables.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    source_table: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # f\"{schema}.{name}\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    source_columns: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    target_table: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    target_columns: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    relationship_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # \"one_to_one\", \"one_to_many\", \"many_to_one\", \"many_to_many\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    foreign_key_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_self_referential: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RelationshipAnalyzer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Analyzes foreign keys to detect relationships between tables.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_depth: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_depth</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.relationships: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[Relationship]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.reverse_relationships: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[Relationship]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze</span><span style=\"color:#E1E4E8\">(self, metadata: DatabaseMetadata) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[Relationship]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Analyze all foreign keys to build relationship graph.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            metadata: Database metadata with tables and foreign keys</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary mapping table name to list of relationships</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            1. For each table, extract foreign key constraints</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            2. Determine relationship cardinality</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            3. Detect self-referential relationships</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            4. Build adjacency lists for forward and reverse relationships</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            5. Detect cycles and apply depth limiting</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            6. Return complete relationship graph</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize empty relationships dictionaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each table in metadata.tables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each foreign key in table.foreign_keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Determine source and target tables/columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check if self-referential (source == target)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Determine cardinality (check primary key involvement)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Create Relationship object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Add to relationships[source_table] and reverse_relationships[target_table]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: After all FKs processed, detect many-to-many via join tables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Detect cycles using DFS with max_depth limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Log warnings for circular references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 12: Return relationships dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _detect_cardinality</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           source_table: TableMetadata,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           target_table: TableMetadata,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           source_columns: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           target_columns: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Determine relationship cardinality.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Rules:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        - If target columns are primary key → many-to-one or one-to-one</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        - If source columns are primary key → one-to-many or one-to-one</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        - If both → one-to-one</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        - If neither → many-to-many (requires join table detection)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if target_columns ⊆ target_table.primary_key_columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if source_columns ⊆ source_table.primary_key_columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return appropriate relationship_type string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<p><strong>Python-Specific Recommendations:</strong></p>\n<ul>\n<li><strong>Async/Await</strong>: Use <code>async</code>/<code>await</code> for database operations to avoid blocking the event loop. Most database drivers support async (e.g., <code>asyncpg</code> for PostgreSQL, <code>aiomysql</code> for MySQL).</li>\n<li><strong>Connection Management</strong>: Use async context managers (<code>async with</code>) to ensure proper connection cleanup even on errors.</li>\n<li><strong>Type Hints</strong>: Use Python&#39;s type hints extensively. This component has complex data structures that benefit from static type checking with mypy.</li>\n<li><strong>Pydantic</strong>: Use Pydantic models for configuration validation—it provides excellent error messages and type coercion.</li>\n<li><strong>Caching</strong>: Use <code>functools.lru_cache</code> for expensive operations like type mapping lookups.</li>\n<li><strong>Logging</strong>: Use structured logging (<code>structlog</code> or <code>logging</code> with JSON formatter) to track reflection progress and issues.</li>\n</ul>\n<p><strong>Database-Specific Considerations:</strong></p>\n<ul>\n<li><strong>PostgreSQL</strong>: Use <code>asyncpg</code> for best performance. Query <code>pg_catalog</code> instead of <code>information_schema</code> for better performance with large schemas.</li>\n<li><strong>MySQL</strong>: <code>information_schema</code> can be slow on large databases. Consider caching results.</li>\n<li><strong>SQLite</strong>: No <code>information_schema</code>—use <code>PRAGMA table_info()</code> and <code>PRAGMA foreign_key_list()</code>.</li>\n<li><strong>SQL Injection</strong>: Never concatenate table/column names into SQL queries. Use parameterized queries for values, but for identifiers, validate against a whitelist or use database-specific quoting functions.</li>\n</ul>\n<p><strong>Performance Optimizations:</strong></p>\n<ul>\n<li><strong>Batch Queries</strong>: Instead of querying each table&#39;s columns individually, batch queries using <code>UNION</code> or query all columns at once with appropriate filters.</li>\n<li><strong>Parallel Introspection</strong>: Use <code>asyncio.gather()</code> to introspect multiple tables concurrently when safe to do so.</li>\n<li><strong>Metadata Caching</strong>: Serialize <code>DatabaseMetadata</code> to JSON file after first reflection. On subsequent starts, check if database schema has changed (via <code>SELECT schema_version()</code> or similar) before using cache.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>After implementing Database Schema Reflection, you should be able to:</strong></p>\n<ol>\n<li><strong>Connect and Introspect</strong>: Run a test that connects to your database and lists all tables:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   python </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">m pytest tests</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">test_reflection.py::test_connect_and_list_tables </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">v</span></span></code></pre></div>\n<p>   Expected output: Lists tables in your test database with column counts.</p>\n<ol start=\"2\">\n<li><strong>Generate GraphQL Schema</strong>: Run the reflection and output the generated GraphQL SDL:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> reflection </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> reflect_schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> test_reflection</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> reflect_schema({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"database_type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"postgresql\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"database\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"test_db\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       })</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       print</span><span style=\"color:#E1E4E8\">(schema.to_sdl())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   asyncio.run(test_reflection())</span></span></code></pre></div>\n<p>   Expected: Valid GraphQL Schema Definition Language showing types for your tables.</p>\n<ol start=\"3\">\n<li><strong>Verify Relationships</strong>: Check that foreign keys generate proper GraphQL fields:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # After reflection, verify that User type has posts: [Post!]! field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # and Post type has author: User! field</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Test Configuration Options</strong>: Apply different naming conventions and verify:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # With camelCase: user_name → userName</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # With PascalCase: user_name → UserName</span></span></code></pre></div>\n\n<p><strong>Signs Something is Wrong:</strong></p>\n<ul>\n<li><strong>No tables found</strong>: Check database permissions, schema name, connection parameters</li>\n<li><strong>Missing relationships</strong>: Check if foreign key constraints exist in database</li>\n<li><strong>Type mapping errors</strong>: Unknown SQL types need custom mappings</li>\n<li><strong>Performance issues</strong>: Large databases may timeout—increase timeout or implement paginated introspection</li>\n</ul>\n<p><strong>Verification Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run unit tests for reflection component</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> reflection/</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run integration test with actual database</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/integration/test_reflection_integration.py</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> --db-url</span><span style=\"color:#9ECBFF\"> postgresql://user:pass@localhost/test_db</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Generate and validate schema</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> scripts/generate_schema.py</span><span style=\"color:#79B8FF\"> --validate</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check for circular references</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> scripts/analyze_relationships.py</span><span style=\"color:#79B8FF\"> --max-depth</span><span style=\"color:#79B8FF\"> 5</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Reflection returns empty schema</td>\n<td>Database user lacks permissions</td>\n<td>Check introspection queries manually: <code>SELECT * FROM information_schema.tables</code></td>\n<td>Grant SELECT on <code>information_schema</code> or specific tables</td>\n</tr>\n<tr>\n<td>Missing foreign key relationships</td>\n<td>Foreign keys not defined or introspector missing them</td>\n<td>Query <code>information_schema.key_column_usage</code> directly</td>\n<td>Ensure FKs exist in DB; check introspector SQL</td>\n</tr>\n<tr>\n<td>GraphQL type name conflicts</td>\n<td>Tables with same name in different schemas</td>\n<td>Log normalized type names during generation</td>\n<td>Use schema prefix: <code>SchemaName_TableName</code></td>\n</tr>\n<tr>\n<td>Memory usage spikes</td>\n<td>Large database with many tables/columns</td>\n<td>Monitor memory during reflection; use batch processing</td>\n<td>Process tables in batches; free intermediate data</td>\n</tr>\n<tr>\n<td>Reflection times out</td>\n<td>Very large schema or slow database connection</td>\n<td>Add timeout logging at each stage</td>\n<td>Increase timeout; implement progress reporting</td>\n</tr>\n<tr>\n<td>Custom type mapping not working</td>\n<td>Mapping registered after introspection</td>\n<td>Check order of operations in <code>reflect_schema</code></td>\n<td>Register custom mappings before calling <code>map_column_type</code></td>\n</tr>\n<tr>\n<td>Circular reference crashes</td>\n<td>Self-referential FK without depth limit</td>\n<td>Check logs for &quot;max depth exceeded&quot; warnings</td>\n<td>Implement cycle detection; use <code>max_relationship_depth</code></td>\n</tr>\n<tr>\n<td>Generated schema invalid</td>\n<td>Type validation fails</td>\n<td>Run <code>validate_schema</code> on output; check error details</td>\n<td>Fix type generation logic; ensure all types are registered</td>\n</tr>\n</tbody></table>\n<p><strong>Diagnostic Tools:</strong></p>\n<ol>\n<li><strong>Metadata Inspector</strong>: Write a simple script that dumps raw database metadata to JSON for inspection:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   metadata </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> get_database_metadata(connection_config)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(json.dumps(metadata, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n<ol start=\"2\">\n<li><strong>Relationship Visualizer</strong>: Generate a DOT file of table relationships:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   analyzer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RelationshipAnalyzer()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   relationships </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> analyzer.analyze(metadata)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Output DOT format for Graphviz</span></span></code></pre></div>\n<ol start=\"3\">\n<li><strong>SQL Query Logger</strong>: Enable query logging in your database adapter to see what introspection queries are being executed.</li>\n</ol>\n<p><strong>Common Configuration Issues:</strong></p>\n<ul>\n<li><strong>Case sensitivity</strong>: PostgreSQL is case-sensitive for quoted identifiers. If your tables were created with quotes (<code>CREATE TABLE &quot;User&quot;</code>), you must reference them as <code>&quot;User&quot;</code> not <code>user</code>.</li>\n<li><strong>Schema vs Database</strong>: In PostgreSQL, <code>database.schema.table</code> vs MySQL&#39;s <code>database.table</code>. Ensure you&#39;re introspecting the correct schema.</li>\n<li><strong>Connection pools</strong>: If using connection pooling, ensure connections have the right search path or default schema set.</li>\n</ul>\n<hr>\n<h2 id=\"component-5-query-to-sql-compilation\">Component 5: Query to SQL Compilation</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 5: Query to SQL Compilation, which focuses on translating GraphQL queries into optimized SQL statements that efficiently retrieve data from relational databases while avoiding common performance pitfalls.</p>\n</blockquote>\n<h3 id=\"responsibility-and-scope\">Responsibility and Scope</h3>\n<p>The <strong>Query to SQL Compilation</strong> component bridges the conceptual gap between GraphQL&#39;s hierarchical, nested query model and relational databases&#39; tabular structure. This component transforms a validated GraphQL query AST into one or more SQL statements that can be executed against a database, returning exactly the data requested by the client in the optimal format.</p>\n<p><strong>Core responsibilities:</strong></p>\n<ul>\n<li><strong>AST-to-SQL translation:</strong> Convert GraphQL field selections into SQL <code>SELECT</code> column lists</li>\n<li><strong>JOIN generation:</strong> Translate nested object fields into appropriate SQL <code>JOIN</code> clauses based on foreign key relationships detected during schema reflection</li>\n<li><strong>Parameterization:</strong> Convert GraphQL arguments and variables into SQL parameters to prevent injection vulnerabilities</li>\n<li><strong>Batching:</strong> Combine multiple related data fetches into single SQL statements to avoid the N+1 query problem</li>\n<li><strong>Filtering and pagination:</strong> Translate GraphQL filter arguments and pagination directives (<code>first</code>, <code>after</code>, <code>where</code>) into SQL <code>WHERE</code>, <code>LIMIT</code>, <code>OFFSET</code>, and <code>ORDER BY</code> clauses</li>\n<li><strong>Type coercion:</strong> Ensure database column values are properly cast to GraphQL scalar types</li>\n</ul>\n<p><strong>Boundaries and limitations:</strong></p>\n<ul>\n<li>Does <strong>not</strong> handle GraphQL subscriptions or real-time queries</li>\n<li>Does <strong>not</strong> implement database write operations (mutations) — only query compilation</li>\n<li>Does <strong>not</strong> handle database-specific optimizations like index hints or query plan analysis</li>\n<li>Relies on the <strong>Database Schema Reflection</strong> component for table/column metadata and relationship information</li>\n<li>Assumes the GraphQL schema has been validated and all types are properly defined</li>\n</ul>\n<p><strong>Data ownership:</strong> This component owns the transformation pipeline from GraphQL AST to parameterized SQL statements, including intermediate representations like <code>SQLSelect</code> and <code>SQLExpression</code> that capture the query structure before string generation.</p>\n<h3 id=\"mental-model-travel-planner\">Mental Model: Travel Planner</h3>\n<blockquote>\n<p>Think of the SQL compiler as a <strong>travel planner</strong> for your data. When you want to visit multiple cities (tables) and see specific attractions (columns), a good travel planner doesn&#39;t book separate flights between each city (N+1 queries). Instead, they design an <strong>efficient itinerary</strong> (JOINs) that visits all desired locations in the optimal order, carrying only the luggage you need (selected columns), and following your specific preferences (filters and sorting).</p>\n</blockquote>\n<p><strong>Core analogy mappings:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Travel Planning Concept</th>\n<th>SQL Compilation Concept</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Destinations to visit</strong></td>\n<td>Tables referenced in the query</td>\n</tr>\n<tr>\n<td><strong>Attractions at each destination</strong></td>\n<td>Columns selected from each table</td>\n</tr>\n<tr>\n<td><strong>Travel routes between cities</strong></td>\n<td>Foreign key relationships enabling JOINs</td>\n</tr>\n<tr>\n<td><strong>Packing list (what to bring)</strong></td>\n<td>SELECT clause column list</td>\n</tr>\n<tr>\n<td><strong>Preferences (dates, budget)</strong></td>\n<td>WHERE clause filter conditions</td>\n</tr>\n<tr>\n<td><strong>Itinerary order</strong></td>\n<td>ORDER BY clause sorting</td>\n</tr>\n<tr>\n<td><strong>Trip duration limits</strong></td>\n<td>LIMIT/OFFSET pagination</td>\n</tr>\n<tr>\n<td><strong>Group tour vs. individual travel</strong></td>\n<td>Batched query vs. separate queries</td>\n</tr>\n</tbody></table>\n<p>The compiler&#39;s job is to analyze the complete &quot;travel plan&quot; (GraphQL query), identify all required destinations and their relationships, then generate the most efficient route that minimizes &quot;travel time&quot; (database roundtrips) while respecting all &quot;traveler preferences&quot; (query arguments).</p>\n<h3 id=\"compiler-interface\">Compiler Interface</h3>\n<p>The SQL compiler exposes a clean, focused API that accepts validated GraphQL queries and returns executable SQL statements with their parameters. The interface centers around the <code>compile_to_sql</code> method, which serves as the main entry point.</p>\n<p><strong>Public API Methods:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>compile_to_sql</code></td>\n<td><code>schema: Schema</code>, <code>document_ast: Document</code>, <code>operation_name: Optional[str] = None</code>, <code>variable_values: Dict[str, Any] = None</code>, <code>context: Dict[str, Any] = None</code></td>\n<td><code>SQLQuery</code></td>\n<td>Main compilation entry point: converts a GraphQL query into an executable SQL statement with parameters</td>\n</tr>\n<tr>\n<td><code>analyze_selections</code></td>\n<td><code>selection_set: SelectionSet</code>, <code>parent_type: GraphQLType</code>, <code>path: List[PathSegment]</code>, <code>table_alias: str</code></td>\n<td><code>Tuple[List[SQLColumn], List[SQLJoin], List[RelationshipPath]]</code></td>\n<td>Internal helper: analyzes field selections and builds SQL column and join structures</td>\n</tr>\n<tr>\n<td><code>build_where_clause</code></td>\n<td><code>arguments: List[Argument]</code>, <code>field_type: GraphQLType</code>, <code>table_metadata: TableMetadata</code>, <code>variable_values: Dict[str, Any]</code></td>\n<td><code>Optional[SQLExpression]</code></td>\n<td>Constructs SQL WHERE conditions from GraphQL filter arguments</td>\n</tr>\n<tr>\n<td><code>apply_pagination</code></td>\n<td><code>sql_select: SQLSelect</code>, <code>arguments: List[Argument]</code>, <code>variable_values: Dict[str, Any]</code>, <code>primary_key_columns: List[str]</code></td>\n<td><code>SQLSelect</code></td>\n<td>Applies LIMIT, OFFSET, and ORDER BY clauses based on pagination arguments</td>\n</tr>\n</tbody></table>\n<p><strong>The <code>SQLQuery</code> Data Structure:</strong>\nThe compilation result encapsulates everything needed to execute the query against a database:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>root_select</code></td>\n<td><code>SQLSelect</code></td>\n<td>The main SELECT statement representing the root query operation</td>\n</tr>\n<tr>\n<td><code>nested_selects</code></td>\n<td><code>List[SQLSelect]</code></td>\n<td>Additional SELECT statements for relationships that cannot be joined in a single query (e.g., many-to-many with additional filtering)</td>\n</tr>\n<tr>\n<td><code>parameters</code></td>\n<td><code>List[SQLParameter]</code></td>\n<td>Positional or named parameters to be bound to the SQL statement</td>\n</tr>\n<tr>\n<td><code>result_mapper</code></td>\n<td><code>Optional[Callable[[List[Dict]], Dict]]</code></td>\n<td>Function to transform flat SQL results into nested GraphQL response shape</td>\n</tr>\n<tr>\n<td><code>query_plan</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Execution plan metadata for debugging and optimization</td>\n</tr>\n</tbody></table>\n<p><strong>Usage Pattern:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># High-level usage example (conceptual, not code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sql_query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> compile_to_sql(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    schema</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">reflected_schema,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    document_ast</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">parsed_query,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    variable_values</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"userId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">123</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    operation_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"GetUserWithPosts\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Execute against database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db.execute(sql_query.root_select.sql, sql_query.parameters)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Transform results using the mapper</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">nested_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sql_query.result_mapper(results)</span></span></code></pre></div>\n\n<h3 id=\"compilation-algorithm\">Compilation Algorithm</h3>\n<p>The compilation process follows a systematic, multi-phase approach that transforms GraphQL AST through several intermediate representations before producing executable SQL. The algorithm ensures correctness (returning exactly requested data) while optimizing for performance (minimizing database roundtrips).</p>\n<p><strong>Phase 1: Query Analysis and Normalization</strong></p>\n<ol>\n<li><strong>Operation Selection:</strong> Identify the target operation from the <code>Document</code> AST based on <code>operation_name</code> or select the single operation if only one exists</li>\n<li><strong>Variable Substitution:</strong> Replace all GraphQL variables in the query with their actual values from <code>variable_values</code>, performing type coercion as needed</li>\n<li><strong>Fragment Expansion:</strong> Expand all fragment spreads (<code>...FragmentName</code>) and inline fragments (<code>... on Type</code>) into their full selection sets, filtered by type conditions</li>\n<li><strong>Field Flattening:</strong> Recursively traverse the selection set, building a flat list of field paths with their complete context (parent types, arguments, directives)</li>\n</ol>\n<p><strong>Phase 2: Join Planning and Relationship Analysis</strong></p>\n<ol start=\"5\">\n<li><strong>Root Table Identification:</strong> Determine the primary database table corresponding to the GraphQL query root type (from schema reflection metadata)</li>\n<li><strong>Relationship Graph Construction:</strong> For each nested field in the selection set, identify the foreign key relationship between parent and child tables using the <code>Relationship</code> metadata from schema reflection</li>\n<li><strong>Join Path Optimization:</strong> Analyze all required joins and reorder them to:<ul>\n<li>Minimize the size of intermediate result sets (filter early)</li>\n<li>Avoid cartesian products (ensure proper join conditions)</li>\n<li>Respect database join limitations (some databases limit JOIN count)</li>\n</ul>\n</li>\n<li><strong>Join Type Selection:</strong> Choose appropriate JOIN types:<ul>\n<li><code>INNER JOIN</code> for non-nullable relationships</li>\n<li><code>LEFT JOIN</code> for nullable relationships or when the parent field might be null</li>\n<li><code>LATERAL JOIN</code> for one-to-many relationships with per-row subqueries (PostgreSQL)</li>\n</ul>\n</li>\n</ol>\n<p><strong>Phase 3: SQL Generation</strong></p>\n<ol start=\"9\">\n<li><strong>Column Selection:</strong> For each requested GraphQL field, map to the corresponding database column, applying any necessary type casts or transformations</li>\n<li><strong>WHERE Clause Construction:</strong> Convert GraphQL filter arguments into SQL conditions:<ul>\n<li>Equality checks (<code>{ where: { id: { eq: 123 } } }</code>) → <code>WHERE id = $1</code></li>\n<li>Complex operators (<code>{ status: { in: [&quot;ACTIVE&quot;, &quot;PENDING&quot;] } }</code>) → <code>WHERE status IN ($1, $2)</code></li>\n<li>Nested object filters (<code>{ author: { name: { like: &quot;%John%&quot; } } }</code>) → <code>JOIN</code> with condition</li>\n</ul>\n</li>\n<li><strong>Sorting and Pagination:</strong><ul>\n<li>Convert <code>orderBy</code> arguments to <code>ORDER BY</code> clauses</li>\n<li>Implement cursor-based pagination using <code>LIMIT</code> and <code>OFFSET</code> or <code>WHERE id &gt; cursor</code> patterns</li>\n<li>Apply <code>first</code>/<code>last</code> arguments as <code>LIMIT</code> with appropriate ordering</li>\n</ul>\n</li>\n<li><strong>Parameter Binding:</strong> Replace all literal values with parameter placeholders (<code>$1</code>, <code>$2</code>, <code>?</code>) to prevent SQL injection, collecting values in the <code>parameters</code> list</li>\n</ol>\n<p><strong>Phase 4: Result Mapping Preparation</strong></p>\n<ol start=\"13\">\n<li><strong>Row-to-Object Mapping:</strong> Generate a <code>result_mapper</code> function that knows how to transform the flat SQL result set (with columns from multiple joined tables) into the nested object structure expected by GraphQL</li>\n<li><strong>Alias Handling:</strong> Respect field aliases in the GraphQL query when constructing both the SQL column aliases and the result mapping</li>\n<li><strong>Type Coercion Planning:</strong> Plan any necessary type conversions from SQL result types to GraphQL scalar types (e.g., database <code>TIMESTAMP</code> → GraphQL <code>String</code> ISO format)</li>\n</ol>\n<p><strong>Concrete Walk-Through Example:</strong></p>\n<p>Consider a GraphQL query fetching a user and their posts:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">graphql</span><pre class=\"arch-pre shiki-highlighted\"><code>query GetUser($userId: ID!) {\n  user(id: $userId) {\n    id\n    name\n    email\n    posts(first: 10, orderBy: CREATED_AT_DESC) {\n      id\n      title\n      createdAt\n    }\n  }\n}</code></pre></div>\n\n<p>The compilation algorithm processes this as:</p>\n<ol>\n<li><strong>Operation Selection:</strong> Identifies <code>GetUser</code> as the target operation</li>\n<li><strong>Variable Substitution:</strong> Replaces <code>$userId</code> with actual value (e.g., <code>123</code>)</li>\n<li><strong>Fragment Expansion:</strong> (No fragments in this query)</li>\n<li><strong>Field Flattening:</strong> Creates field paths: <code>user</code> (root), <code>user.id</code>, <code>user.name</code>, <code>user.email</code>, <code>user.posts</code>, <code>user.posts.id</code>, <code>user.posts.title</code>, <code>user.posts.createdAt</code></li>\n<li><strong>Root Table Identification:</strong> Maps <code>User</code> GraphQL type to <code>users</code> database table</li>\n<li><strong>Relationship Analysis:</strong> Identifies <code>users.id</code> → <code>posts.user_id</code> foreign key relationship</li>\n<li><strong>Join Planning:</strong> Creates plan: <code>users</code> LEFT JOIN <code>posts</code> (since user might have no posts)</li>\n<li><strong>Column Selection:</strong> Maps fields to columns: <code>id</code>→<code>users.id</code>, <code>name</code>→<code>users.name</code>, etc.</li>\n<li><strong>WHERE Clause:</strong> Adds <code>WHERE users.id = $1</code></li>\n<li><strong>Pagination:</strong> Adds <code>ORDER BY posts.created_at DESC LIMIT 10</code></li>\n<li><strong>Parameter Binding:</strong> Binds <code>$1 = 123</code></li>\n<li><strong>Result Mapping:</strong> Creates mapper that groups posts by user ID to nest them under each user</li>\n</ol>\n<p>The final SQL might resemble:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> users</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">users</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">users</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">email</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#E1E4E8\"> posts__id, </span><span style=\"color:#79B8FF\">posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">title</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#E1E4E8\"> posts__title, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">created_at</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#E1E4E8\"> posts__created_at</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> users</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">LEFT JOIN</span><span style=\"color:#E1E4E8\"> posts </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> users</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">user_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> users</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> $</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ORDER BY</span><span style=\"color:#79B8FF\"> posts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">created_at</span><span style=\"color:#F97583\"> DESC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">LIMIT</span><span style=\"color:#79B8FF\"> 10</span></span></code></pre></div>\n\n<h3 id=\"architecture-decision-compilation-approach\">Architecture Decision: Compilation Approach</h3>\n<blockquote>\n<p><strong>Decision: Single-Query JOINs with Lateral Subqueries for Complex Cases</strong></p>\n<ul>\n<li><strong>Context:</strong> We must translate nested GraphQL queries to SQL while balancing performance (minimizing roundtrips) with correctness (handling complex filtering/pagination at each relationship level). Deeply nested queries with filtering at multiple levels present particular challenges.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Pure Single-Query JOINs:</strong> Generate one massive SQL statement with all tables JOINed together</li>\n<li><strong>Separate Queries with Batching:</strong> Issue separate SQL queries per relationship level but batch them using IN clauses</li>\n<li><strong>Hybrid with Lateral Joins:</strong> Use single-query JOINs for simple cases, LATERAL JOINs for filtered one-to-many relationships</li>\n<li><strong>ORM-style N+1 then Optimize:</strong> Start with naive N+1 queries, then optimize common patterns</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Option 3 (Hybrid with Lateral Joins) for PostgreSQL, with fallback to Option 2 (Batched Separate Queries) for databases without LATERAL JOIN support</li>\n<li><strong>Rationale:</strong> <ul>\n<li><strong>Performance:</strong> Single-query JOINs minimize database roundtrips (most important for network latency)</li>\n<li><strong>Correctness:</strong> LATERAL JOINs allow applying filters/limits to nested collections per parent row (unachievable with simple JOINs)</li>\n<li><strong>Database Compatibility:</strong> Fallback strategy ensures support across different SQL dialects</li>\n<li><strong>Complexity Management:</strong> Separating simple vs. complex cases keeps the common path simple</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li><strong>Positive:</strong> Excellent performance for common query patterns, correct handling of nested filters/limits</li>\n<li><strong>Negative:</strong> More complex SQL generation logic, database-specific code paths, potential for very large SQL statements</li>\n<li><strong>Mitigation:</strong> Implement query size limits, provide EXPLAIN plan analysis for optimization hints</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Comparison of Compilation Strategies:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Single-Query JOINs</strong></td>\n<td>- Single database roundtrip<br>- Database optimizes entire query plan<br>- Consistent ordering guarantees</td>\n<td>- Cartesian product risk with many-to-many<br>- Can&#39;t limit nested collections per parent<br>- Large result sets with duplicates</td>\n<td>Shallow queries without nested filters/limits</td>\n</tr>\n<tr>\n<td><strong>Batched Separate Queries</strong></td>\n<td>- Clean separation of concerns<br>- Easy to apply per-level filters<br>- Avoids duplicate data in results</td>\n<td>- Multiple roundtrips (network overhead)<br>- Connection pool pressure<br>- Consistency timing issues</td>\n<td>Deeply nested queries with complex per-level logic</td>\n</tr>\n<tr>\n<td><strong>LATERAL JOINs</strong></td>\n<td>- Single roundtrip<br>- Correct per-parent filtering<br>- Database optimizes across joins</td>\n<td>- PostgreSQL-specific (not all DBs)<br>- Complex SQL generation<br>- Query planner may struggle</td>\n<td>One-to-many relationships with filters/limits</td>\n</tr>\n<tr>\n<td><strong>GraphQL-to-SQL Middleware</strong></td>\n<td>- Reuse existing libraries<br>- Community support<br>- Battle-tested</td>\n<td>- Less educational value<br>- Hidden complexity<br>- May not match our exact needs</td>\n<td>Production systems (not learning projects)</td>\n</tr>\n</tbody></table>\n<p><strong>Supporting Decision: Raw SQL Generation over ORM</strong></p>\n<ul>\n<li><strong>Context:</strong> We need to generate database queries that are both efficient and debuggable. Using an ORM provides abstraction but hides SQL details and limits optimization.</li>\n<li><strong>Decision:</strong> Generate raw, parameterized SQL statements rather than using an ORM query builder</li>\n<li><strong>Rationale:</strong> <ul>\n<li><strong>Transparency:</strong> Learners can see exactly what SQL is generated and debug it</li>\n<li><strong>Performance:</strong> Direct control over SQL allows specific optimizations</li>\n<li><strong>Flexibility:</strong> Can use database-specific features and syntax</li>\n<li><strong>Educational Value:</strong> Teaches SQL generation patterns directly</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong> Must handle SQL dialect differences, injection protection manually, and query string construction logic</li>\n</ul>\n<h3 id=\"common-compilation-pitfalls\">Common Compilation Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Cartesian Products from Missing Join Conditions</strong></p>\n<ul>\n<li><strong>Description:</strong> Generating SQL with multiple JOINs but forgetting the ON conditions, causing every row from one table to match with every row from another (N×M results)</li>\n<li><strong>Why It&#39;s Wrong:</strong> Explodes result set size exponentially, crashes database with memory exhaustion, returns incorrect data relationships</li>\n<li><strong>How to Fix:</strong> Always verify every JOIN has an ON clause, use foreign key relationships from schema reflection, add validation that checks for Cartesian products in generated SQL</li>\n</ul>\n<p>⚠️ <strong>Pitfall: N+1 Query Problem</strong></p>\n<ul>\n<li><strong>Description:</strong> For a list of N parent items, issuing N additional queries to fetch related child items instead of using a single JOIN or batched query</li>\n<li><strong>Why It&#39;s Wrong:</strong> Horrible performance (N+1 roundtrips), database connection exhaustion, poor scalability</li>\n<li><strong>How to Fix:</strong> Implement the DataLoader pattern for separate queries, or use JOINs/LATERAL joins for single-query approach. Always analyze the selection set to batch sibling field resolutions.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: SQL Injection Vulnerabilities</strong></p>\n<ul>\n<li><strong>Description:</strong> Concatenating user-provided values directly into SQL strings instead of using parameterized queries</li>\n<li><strong>Why It&#39;s Wrong:</strong> Critical security vulnerability allowing attackers to execute arbitrary SQL, steal data, or destroy database</li>\n<li><strong>How to Fix:</strong> Always use parameter binding (<code>$1</code>, <code>?</code>), never interpolate values. For dynamic column/table names (rarely needed), use an allowlist or strict validation.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Missing Null Propagation Handling</strong></p>\n<ul>\n<li><strong>Description:</strong> When a LEFT JOIN returns NULL for child records, incorrectly treating the entire parent record as null rather than just the nested field</li>\n<li><strong>Why It&#39;s Wrong:</strong> Violates GraphQL specification where nulls propagate to nearest nullable parent, returns incorrect empty results instead of partial data</li>\n<li><strong>How to Fix:</strong> Implement proper null handling in the result mapper, distinguish between &quot;parent not found&quot; and &quot;child relationship null&quot;. Use GraphQL&#39;s nullability rules from the schema.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect Type Mapping</strong></p>\n<ul>\n<li><strong>Description:</strong> Database <code>DECIMAL(10,2)</code> values returned as strings instead of GraphQL Float, or database <code>TIMESTAMP</code> not converted to ISO string format</li>\n<li><strong>Why It&#39;s Wrong:</strong> GraphQL clients receive data in wrong format, breaking type contracts and causing client-side errors</li>\n<li><strong>How to Fix:</strong> Use the type mapping rules established during schema reflection consistently. Apply SQL CAST operations or post-processing transformations as needed.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Unbounded Result Sets</strong></p>\n<ul>\n<li><strong>Description:</strong> Forgetting to add <code>LIMIT</code> clauses to queries that could return millions of rows, especially on list fields without <code>first</code>/<code>last</code> arguments</li>\n<li><strong>Why It&#39;s Wrong:</strong> Database and application memory exhaustion, denial of service, poor performance</li>\n<li><strong>How to Fix:</strong> Implement default limits (e.g., max 1000 rows), require pagination arguments for list fields, or implement query cost analysis to reject expensive queries.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Database Indexes</strong></p>\n<ul>\n<li><strong>Description:</strong> Generating WHERE clauses that don&#39;t align with database indexes, like applying functions to indexed columns (<code>WHERE LOWER(name) = &#39;john&#39;</code>)</li>\n<li><strong>Why It&#39;s Wrong:</strong> Forces full table scans instead of index seeks, terrible performance on large tables</li>\n<li><strong>How to Fix:</strong> Analyze common filter patterns during schema reflection, generate WHERE clauses that preserve index usability, provide hints to create appropriate indexes.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>SQL Builder</strong></td>\n<td>String concatenation with careful escaping</td>\n<td>SQLAlchemy Core or similar query builder library</td>\n</tr>\n<tr>\n<td><strong>Parameter Binding</strong></td>\n<td><code>?</code> positional placeholders with list of values</td>\n<td>Named parameters with dictionary binding</td>\n</tr>\n<tr>\n<td><strong>Database Adapter</strong></td>\n<td>DB-API 2.0 (Python&#39;s <code>sqlite3</code>, <code>psycopg2</code>)</td>\n<td>Async database driver (<code>asyncpg</code>, <code>aiosqlite</code>)</td>\n</tr>\n<tr>\n<td><strong>Result Mapping</strong></td>\n<td>Manual dictionary transformation</td>\n<td>Custom row-to-object mapper with metadata</td>\n</tr>\n<tr>\n<td><strong>Query Optimization</strong></td>\n<td>Basic join ordering heuristics</td>\n<td>EXPLAIN plan analysis and cost-based optimization</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql_engine/\n├── compiler/                           # SQL Compilation component\n│   ├── __init__.py\n│   ├── sql_builder.py                  # SQL string construction utilities\n│   ├── join_planner.py                 # JOIN analysis and optimization\n│   ├── where_builder.py                # WHERE clause generation from filters\n│   ├── pagination.py                   # Cursor-based pagination logic\n│   ├── result_mapper.py                # Flat SQL → nested GraphQL transformation\n│   ├── dialects/                       # Database-specific SQL generation\n│   │   ├── __init__.py\n│   │   ├── postgresql.py\n│   │   ├── sqlite.py\n│   │   └── mysql.py\n│   └── tests/\n│       ├── test_sql_builder.py\n│       ├── test_join_planner.py\n│       └── test_integration.py\n├── execution/                          # Execution engine (from Component 3)\n│   └── data_loader.py                  # DataLoader implementation for batching\n└── reflection/                         # Schema reflection (from Component 4)\n    └── metadata.py                     # Table/column metadata structures</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<p>Complete SQL builder utilities for safe SQL generation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># graphql_engine/compiler/sql_builder.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Safe SQL generation with parameter binding.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any, Optional, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SQLDialect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    POSTGRESQL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"postgresql\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SQLITE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"sqlite\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MYSQL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"mysql\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SQLParameter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: Any</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Optional type hint for the database</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SQLBuilder</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Builds parameterized SQL statements safely.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, dialect: SQLDialect </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SQLDialect.</span><span style=\"color:#79B8FF\">POSTGRESQL</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.dialect </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dialect</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._parameters: List[SQLParameter] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._sql_parts: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._param_counter </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_parameter</span><span style=\"color:#E1E4E8\">(self, value: Any, type_hint: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a value as a parameter and return its placeholder.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        param_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"p</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">._param_counter</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._param_counter </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._parameters.append(SQLParameter(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">param_name, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">value, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">type_hint </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> \"unknown\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.dialect </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SQLDialect.</span><span style=\"color:#79B8FF\">POSTGRESQL</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"$</span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._parameters)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.dialect </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SQLDialect.</span><span style=\"color:#79B8FF\">SQLITE</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"?\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.dialect </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SQLDialect.</span><span style=\"color:#79B8FF\">MYSQL</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"?\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_literal</span><span style=\"color:#E1E4E8\">(self, sql_fragment: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a raw SQL fragment (for keywords, column names, etc.).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._sql_parts.append(sql_fragment)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_identifier</span><span style=\"color:#E1E4E8\">(self, identifier: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a properly quoted identifier (table/column name).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.dialect </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SQLDialect.</span><span style=\"color:#79B8FF\">POSTGRESQL</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._sql_parts.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">identifier</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.dialect </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SQLDialect.</span><span style=\"color:#79B8FF\">MYSQL</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._sql_parts.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'`</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">identifier</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">`'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._sql_parts.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">identifier</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> build</span><span style=\"color:#E1E4E8\">(self) -> tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[Any]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return the SQL string and parameter values in correct order.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sql </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._sql_parts)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        param_values </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [p.value </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._parameters]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> sql, param_values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clear</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Reset the builder for reuse.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._parameters.clear()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._sql_parts.clear()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._param_counter </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<p>Main compilation entry point with detailed TODOs:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># graphql_engine/compiler/__init__.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"GraphQL to SQL compiler main entry points.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..ast </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Document, OperationDefinition, Field, SelectionSet</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema, GraphQLType, ObjectType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..reflection.metadata </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TableMetadata, Relationship</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .sql_builder </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SQLBuilder, SQLDialect</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> compile_to_sql</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema: Schema,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    document_ast: Document,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variable_values: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Compile a GraphQL query to executable SQL.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        schema: Validated GraphQL schema with database metadata</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        document_ast: Parsed GraphQL query AST</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        operation_name: Name of operation to execute (if multiple in document)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        variable_values: Values for GraphQL variables in the query</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        context: Execution context (database connection, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Dictionary with keys:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        - sql: The parameterized SQL string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        - parameters: List of parameter values to bind</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        - result_mapper: Function to map SQL results to GraphQL shape</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        - metadata: Compilation metadata for debugging</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Select the target operation from document_ast.definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - If operation_name is None and there's exactly one operation, use it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - If operation_name is specified, find the matching operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Raise error if ambiguous or not found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract and validate variable values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Merge provided variable_values with operation's variable defaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Validate types match variable definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Create a dict of resolved variable values for substitution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Expand fragments in the selection set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Gather all fragment definitions from the document</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Recursively replace fragment spreads with their actual selections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Apply type conditions for inline fragments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Analyze the root field and identify the target database table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Get the GraphQL root type from schema (query_type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Look up the table metadata associated with this GraphQL type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Determine the primary key columns for ordering/pagination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Recursively analyze nested selections and build relationship paths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - For each field in the selection set, check if it's a relationship field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Use schema reflection metadata to find foreign key relationships</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Build a tree of relationship paths from root to leaf fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate JOIN clauses for relationship paths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Determine optimal join order (filter early, minimize intermediate size)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Choose JOIN type (INNER vs LEFT) based on field nullability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Generate ON conditions using foreign key relationships</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Build SELECT column list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Map each GraphQL field to its database column</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Generate unique aliases for columns from joined tables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Include any necessary type casts (timestamp → string, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Build WHERE clause from arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Extract filter arguments from the root field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Convert GraphQL filter operators to SQL conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Handle nested object filters (author: { name: { like: ... } })</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Use parameter binding for all values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Apply sorting and pagination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Parse orderBy arguments to ORDER BY clauses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Handle cursor-based pagination (after/before arguments)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Apply LIMIT based on first/last arguments with defaults</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Generate the complete SQL statement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Use SQLBuilder to safely construct the SQL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Assemble: SELECT ... FROM ... JOIN ... WHERE ... ORDER BY ... LIMIT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Get final SQL string and parameter list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Create result mapper function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Analyze the selection tree structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Generate a function that transforms flat SQL rows to nested objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Handle field aliases and type coercion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 12: Return compilation result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Include SQL, parameters, mapper function, and metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Add query plan information for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p>Join planning algorithm skeleton:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># graphql_engine/compiler/join_planner.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Analyze relationships and plan optimal JOIN strategy.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..reflection.metadata </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Relationship, TableMetadata</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JoinPlan</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a planned SQL JOIN.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    left_table: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    right_table: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    join_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # \"INNER\", \"LEFT\", \"LATERAL\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    on_conditions: List[Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]  </span><span style=\"color:#6A737D\"># [(left_column, right_column), ...]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    relationship: Relationship</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alias: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> plan_joins</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_table: TableMetadata,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    relationships: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[Relationship]],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selection_paths: List[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> List[JoinPlan]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Plan optimal JOIN order for accessing all tables in selection_paths.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        root_table: The starting table (GraphQL query root)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        relationships: Dict mapping table names to their outgoing relationships</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        selection_paths: List of field paths like [\"user\", \"posts\", \"comments\"]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Ordered list of JoinPlan objects representing JOINs to execute</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Identify all tables needed based on selection_paths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Parse each path to determine which tables are accessed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Build set of required tables beyond the root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Find relationship paths from root to each required table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Use breadth-first search through relationship graph</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Record the shortest path to each table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Handle multiple possible paths (choose based on cardinality)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Determine optimal join order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Start with root table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Add tables in order of increasing estimated row count (if metadata available)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Apply filters early: tables with WHERE conditions join earlier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Avoid cartesian products: ensure each JOIN has a condition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Determine JOIN type for each relationship</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Use INNER JOIN for non-nullable relationships (GraphQL field is NonNull)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Use LEFT JOIN for nullable relationships</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Consider LATERAL JOIN for one-to-many with per-row limits/filters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate ON conditions for each JOIN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Use foreign key column mappings from Relationship objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - For composite keys, multiple equality conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - For self-referential relationships, use table aliases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return ordered list of JoinPlan objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Python):</strong></p>\n<ul>\n<li><strong>Parameter Binding:</strong> Use <code>%s</code> placeholders for MySQL, <code>?</code> for SQLite, <code>$1</code>, <code>$2</code> for PostgreSQL. Python&#39;s DB-API handles the differences.</li>\n<li><strong>Type Conversion:</strong> For database-specific types, use SQL CAST: <code>CAST(column AS TEXT)</code> or Python-side conversion in the result mapper.</li>\n<li><strong>Connection Management:</strong> Use connection pooling for production. For learning, simple connection-per-query is fine.</li>\n<li><strong>Async Support:</strong> Consider <code>asyncpg</code> for PostgreSQL with async/await pattern if implementing async GraphQL execution.</li>\n<li><strong>SQL Injection Prevention:</strong> Never use f-strings or <code>%</code> formatting with user input. Always use parameter binding.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p><strong>What to Test:</strong></p>\n<ol>\n<li><strong>Basic Field Selection:</strong> <code>{ users { id name } }</code> → <code>SELECT id, name FROM users</code></li>\n<li><strong>Nested Relationship:</strong> <code>{ users { posts { title } } }</code> → SQL with JOIN between users and posts</li>\n<li><strong>Filter Arguments:</strong> <code>{ users(where: { status: { eq: &quot;ACTIVE&quot; } }) { id } }</code> → <code>WHERE status = $1</code></li>\n<li><strong>Pagination:</strong> <code>{ users(first: 10, after: &quot;cursor&quot;) { id } }</code> → <code>LIMIT 10 OFFSET ...</code></li>\n<li><strong>Parameter Binding:</strong> Verify no raw values in SQL, all use placeholders</li>\n</ol>\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Example test case</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> compile_to_sql(schema, parse_query(</span><span style=\"color:#9ECBFF\">\"{ users { id name } }\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(result[</span><span style=\"color:#9ECBFF\">\"sql\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: SELECT id, name FROM users</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(result[</span><span style=\"color:#9ECBFF\">\"parameters\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: [] (empty list for simple query)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># With filter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> compile_to_sql(schema, parse_query(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '{ users(where: { id: { eq: 123 } }) { name } }'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(result[</span><span style=\"color:#9ECBFF\">\"sql\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: SELECT name FROM users WHERE id = $1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(result[</span><span style=\"color:#9ECBFF\">\"parameters\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: [123]</span></span></code></pre></div>\n\n<p><strong>Verification Steps:</strong></p>\n<ol>\n<li>Run unit tests: <code>python -m pytest graphql_engine/compiler/tests/ -v</code></li>\n<li>Test with actual database: Execute generated SQL against test database, verify results match GraphQL expectation</li>\n<li>Check for N+1: Use query logging to ensure nested fields don&#39;t cause additional queries</li>\n<li>Security check: Attempt SQL injection through GraphQL variables, verify it&#39;s blocked</li>\n</ol>\n<p><strong>Signs Something is Wrong:</strong></p>\n<ul>\n<li>❌ SQL contains literal values instead of placeholders</li>\n<li>❌ JOINs without ON clauses (cartesian product risk)</li>\n<li>❌ Missing LIMIT on list fields (unbounded queries)</li>\n<li>❌ Incorrect null handling (LEFT JOIN needed but using INNER)</li>\n<li>❌ Type errors: database numbers returned as strings to GraphQL</li>\n</ul>\n<p><strong>Debugging Approach:</strong></p>\n<ol>\n<li><strong>Log generated SQL:</strong> Add debug logging to see exactly what SQL is produced</li>\n<li><strong>EXPLAIN plans:</strong> Run <code>EXPLAIN ANALYZE</code> on generated SQL to check performance</li>\n<li><strong>AST visualization:</strong> Print the GraphQL AST to understand the selection structure</li>\n<li><strong>Step-by-step compilation:</strong> Test each compilation phase independently</li>\n</ol>\n<hr>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section spans all five milestones, showing how the individual components connect to form a complete system. It illustrates the data transformations from GraphQL string to database query and back, and how schema reflection integrates with the type system.</p>\n</blockquote>\n<p>Understanding how components interact is crucial for seeing the system as more than isolated parts. This section maps the journey of a GraphQL query through the engine, reveals how the database schema becomes a GraphQL type system, and details the precise data structures exchanged between components. Think of it as following a package through a logistics network: we trace its path, document its transformations at each hub, and understand the routing decisions that determine its final delivery.</p>\n<h3 id=\"happy-path-query-execution-flow\">Happy Path: Query Execution Flow</h3>\n<p>The happy path represents a successful GraphQL query execution from HTTP request to JSON response. This flow integrates components from Milestones 1, 2, 3, and 5, demonstrating how parsed queries become execution plans and finally database results.</p>\n<blockquote>\n<p><strong>Mental Model: Assembly Line with Quality Control</strong><br>Imagine an automotive assembly line. A raw query (sheet metal) enters the factory. The parser (stamping press) shapes it into a structured AST (car frame). The type system (quality inspection) validates the frame against blueprints. The SQL compiler (robot arm) welds on the engine and wheels (SQL generation). The execution engine (final assembly) installs the interior (resolves fields) and the database (engine) provides power. At each station, defects are caught and flagged, but the line continues for other cars (fields).</p>\n</blockquote>\n<p>The end-to-end flow follows this sequence, which you can visualize in <img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Fdata-flow-end-to-end.svg\" alt=\"End-to-End Data Flow Diagram\">:</p>\n<p><strong>Step 1: HTTP Request Ingestion</strong>\nThe process begins when an HTTP server (not part of our core engine) receives a POST request containing a GraphQL query string, optional variables, and an operation name. The server extracts these components and passes them to the engine&#39;s main entry point.</p>\n<p><strong>Step 2: Query Parsing (Milestone 1)</strong>\nThe <code>parse_query</code> function is invoked with the query string. Internally, this triggers:</p>\n<ol>\n<li><strong>Lexical Analysis</strong>: The <code>Tokenizer.tokenize()</code> method scans the string, producing a list of <code>Token</code> objects (names, punctuation, literals) with <code>Location</code> data.</li>\n<li><strong>Syntax Parsing</strong>: The <code>Parser.parse_document()</code> method consumes the token stream using recursive descent, building a complete <code>Document</code> AST. This <code>Document</code> contains one or more <code>Definition</code> nodes (typically an <code>OperationDefinition</code>).</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Transformation</th>\n<th>Input Format</th>\n<th>Output Format</th>\n<th>Key Operation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Raw string</td>\n<td><code>&quot;query { user(id:1) { name } }&quot;</code></td>\n<td><code>Document</code> with <code>OperationDefinition</code></td>\n<td>Tokenization and recursive descent parsing</td>\n</tr>\n</tbody></table>\n<p><strong>Step 3: Schema Preparation</strong>\nThe engine obtains a <code>Schema</code> object. This can come from:</p>\n<ul>\n<li><strong>Static definition</strong>: Built programmatically using <code>create_schema()</code> with hand-defined types.</li>\n<li><strong>Dynamic reflection</strong>: Generated via <code>reflect_schema()</code> from a database (integration with Milestone 4).\nThe schema is already validated and ready for execution.</li>\n</ul>\n<p><strong>Step 4: Query Validation (Integrated with Execution)</strong>\nBefore execution, the engine performs validation using the type system (Milestone 2). This happens implicitly during the execution preparation phase:</p>\n<ol>\n<li>The operation name (if provided) is used to select the correct <code>OperationDefinition</code> from the <code>Document</code>.</li>\n<li>Variable values are coerced to their defined types using <code>VariableDefinition</code> type references.</li>\n<li>The selection set is validated against the schema: fields must exist, arguments must be of correct type, fragments must be applicable.\nValidation failures produce <code>GraphQLError</code> objects and abort execution.</li>\n</ol>\n<p><strong>Step 5: SQL Compilation (Milestone 5)</strong>\nFor queries against a reflected database schema, the <code>compile_to_sql</code> function transforms the validated operation into executable SQL:</p>\n<ol>\n<li><strong>Analysis</strong>: The compiler analyzes the <code>Document</code> AST, identifying the root table from the query type and tracing nested selections through relationships.</li>\n<li><strong>Join Planning</strong>: The <code>plan_joins</code> function determines the optimal JOIN order and type based on foreign key relationships in the <code>DatabaseMetadata</code>.</li>\n<li><strong>SQL Generation</strong>: The compiler builds a <code>SQLQuery</code> object containing <code>SQLSelect</code> structures with JOINs, WHERE conditions from arguments, and ORDER BY/LIMIT from pagination arguments.</li>\n<li><strong>Parameter Binding</strong>: All GraphQL arguments are converted to <code>SQLParameter</code> objects to prevent SQL injection.</li>\n</ol>\n<p>This step produces a complete, parameterized SQL query ready for execution. You can see the detailed sequence in <img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Fsql-compilation-sequence.svg\" alt=\"GraphQL to SQL Compilation Sequence\">.</p>\n<p><strong>Step 6: Database Execution</strong>\nThe engine executes the generated SQL against the database connection:</p>\n<ol>\n<li>Parameter values are bound to the SQL placeholders.</li>\n<li>The query is sent to the database.</li>\n<li>Raw rows are returned as a list of dictionaries (or similar record format).</li>\n</ol>\n<p><strong>Step 7: Result Transformation and Field Resolution</strong>\nThe execution engine (Milestone 3) processes the results:</p>\n<ol>\n<li><strong>Root Resolution</strong>: For reflected queries, the root resolver uses a <code>result_mapper</code> function from the <code>SQLQuery</code> to transform flat SQL rows into nested structures matching the GraphQL selection shape.</li>\n<li><strong>Nested Field Resolution</strong>: For fields not satisfied by the SQL JOINs (or for custom resolvers), the engine invokes resolver functions from the <code>GraphQLField</code> definitions.</li>\n<li><strong>Parallel Execution</strong>: Sibling fields at the same level are resolved concurrently when independent.</li>\n<li><strong>Error Handling</strong>: Field-level errors are captured as <code>GraphQLError</code> objects without aborting the entire query.</li>\n<li><strong>Null Propagation</strong>: If a non-null field resolves to null or raises an error, the engine propagates null to the nearest nullable parent per GraphQL specification.</li>\n</ol>\n<p><strong>Step 8: Response Assembly</strong>\nThe execution engine assembles the final <code>ExecutionResult</code>:</p>\n<ol>\n<li>The <code>data</code> field contains the fully resolved response tree.</li>\n<li>The <code>errors</code> field contains any <code>GraphQLError</code> objects collected during execution.</li>\n<li>The result is serialized to JSON by the HTTP layer and returned to the client.</li>\n</ol>\n<p>The entire execution flow, showing resolver traversal and parallel branches, is depicted in <img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Fexecution-flowchart.svg\" alt=\"Query Execution Flowchart\">.</p>\n<blockquote>\n<p><strong>Architecture Decision: Integrated vs. Separate Validation Phase</strong></p>\n<ul>\n<li><strong>Context</strong>: GraphQL execution requires validation against the schema, but we must decide when this happens relative to parsing and execution.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Separate validation phase</strong>: Parse → Validate → Execute (clear separation, catches errors early)</li>\n<li><strong>Integrated validation</strong>: Parse → Execute with validation as first step (simpler control flow)</li>\n<li><strong>Lazy validation</strong>: Validate only the parts of the query as they&#39;re executed (optimistic, complex error handling)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Integrated validation (option 2)</li>\n<li><strong>Rationale</strong>: The GraphQL spec defines validation as occurring before execution begins, not interleaved. A separate phase would require an additional traversal of the AST. By integrating validation as the first step of execution, we maintain clear separation conceptually while avoiding duplicate AST traversal. This aligns with reference implementations like graphql-js.</li>\n<li><strong>Consequences</strong>: Validation errors prevent any resolver execution, which is correct spec behavior. The execution engine must handle validation errors as a special case before beginning resolver dispatch.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Separate validation phase</td>\n<td>Clear separation of concerns, easier to test validation independently</td>\n<td>Extra AST traversal overhead, more complex control flow</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>Integrated validation</strong></td>\n<td><strong>Single AST traversal, simpler control flow, matches reference implementations</strong></td>\n<td><strong>Validation and execution logic coupled in same component</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>Lazy validation</td>\n<td>Could avoid validating unused fragments, potential performance gain</td>\n<td>Complex error handling, violates spec requirement that validation occurs before execution</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"schema-building-and-reflection-flow\">Schema Building and Reflection Flow</h3>\n<p>Schema building can occur through two primary paths: static programmatic definition or dynamic reflection from a database. The reflection flow (Milestone 4) integrates deeply with the type system (Milestone 2) to auto-generate a complete GraphQL schema.</p>\n<blockquote>\n<p><strong>Mental Model: Archaeological Excavation</strong><br>Imagine discovering an ancient city buried underground. The reflection process is like the archaeological dig: you first survey the site (connect to database), then carefully uncover each structure (introspect tables), map the pathways between buildings (detect relationships), and finally produce a detailed model of the city (GraphQL schema) that people can explore without digging themselves.</p>\n</blockquote>\n<p>The reflection process follows a structured algorithm:</p>\n<p><strong>Step 1: Connection and Metadata Extraction</strong>\nThe <code>reflect_schema</code> function is called with database connection configuration and <code>ReflectionOptions</code>. It:</p>\n<ol>\n<li>Establishes a connection to the database using a <code>BaseIntrospector</code> adapter.</li>\n<li>Calls <code>get_database_metadata()</code> to retrieve <code>DatabaseMetadata</code> containing <code>TableMetadata</code> for each table and <code>ColumnMetadata</code> for each column.</li>\n<li>Optionally filters tables based on <code>include_tables</code>/<code>exclude_tables</code> patterns.</li>\n</ol>\n<p><strong>Step 2: Type Mapping</strong>\nFor each table, the reflection engine:</p>\n<ol>\n<li>Creates an <code>ObjectType</code> with a name derived from the table name using the configured <code>NamingConvention</code>.</li>\n<li>For each column in <code>TableMetadata.columns</code>, uses <code>TypeMapper.map_column_type()</code> to convert the SQL data type to a <code>GraphQLType</code> (wrapped with <code>NonNullType</code> if <code>is_nullable</code> is false).</li>\n<li>Adds a <code>GraphQLField</code> for each column to the object type&#39;s fields dictionary.</li>\n</ol>\n<p><strong>Step 3: Relationship Detection</strong>\nThe <code>RelationshipAnalyzer.analyze()</code> method processes foreign key constraints from the metadata:</p>\n<ol>\n<li>Identifies all foreign keys between tables.</li>\n<li>Determines cardinality (one-to-one, one-to-many) by checking uniqueness constraints.</li>\n<li>Creates <code>Relationship</code> objects linking source and target tables.</li>\n<li>For each relationship, adds appropriate fields to the GraphQL types:<ul>\n<li>For one-to-many: adds a plural field (e.g., <code>posts</code>) to the &quot;one&quot; side returning a list of the &quot;many&quot; type</li>\n<li>For many-to-one: adds a singular field (e.g., <code>author</code>) to the &quot;many&quot; side returning the &quot;one&quot; type</li>\n</ul>\n</li>\n</ol>\n<p><strong>Step 4: Root Query Type Construction</strong>\nThe reflection engine builds the root <code>Query</code> type:</p>\n<ol>\n<li>For each table, adds a field to fetch a single record by primary key (e.g., <code>user(id: ID!)</code>).</li>\n<li>For each table, adds a plural field to fetch all records with optional filtering, pagination, and ordering (e.g., <code>users(where: UserFilter, limit: Int)</code>).</li>\n<li>Adds connection fields for Relay-style cursor pagination if configured.</li>\n</ol>\n<p><strong>Step 5: Mutation Type Construction (Optional)</strong>\nIf <code>readonly</code> option is false, the engine builds a <code>Mutation</code> type:</p>\n<ol>\n<li>For each table, adds <code>create</code>, <code>update</code>, and <code>delete</code> mutations with appropriate input types.</li>\n<li>Input types (<code>InputObjectType</code>) are created from table columns, excluding computed or read-only columns.</li>\n</ol>\n<p><strong>Step 6: Schema Assembly and Validation</strong>\nThe final step uses <code>create_schema()</code> to assemble the reflected types into a complete <code>Schema</code>:</p>\n<ol>\n<li>All generated types are collected in the <code>types</code> dictionary.</li>\n<li>The root <code>Query</code> and <code>Mutation</code> types are set.</li>\n<li><code>validate_schema()</code> is called to ensure consistency (no circular references, valid interface implementations, etc.).</li>\n</ol>\n<p><strong>Step 7: Integration with Execution Engine</strong>\nThe generated <code>Schema</code> is now indistinguishable from a manually defined one and can be used directly by the query execution engine. The reflection state transitions are shown in <img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Freflection-state-machine.svg\" alt=\"Schema Reflection State Machine\">.</p>\n<table>\n<thead>\n<tr>\n<th>Reflection Stage</th>\n<th>Input</th>\n<th>Output</th>\n<th>Key Methods</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection</td>\n<td>Connection string, <code>ReflectionOptions</code></td>\n<td>Database connection</td>\n<td><code>BaseIntrospector.connect()</code></td>\n</tr>\n<tr>\n<td>Metadata extraction</td>\n<td>Database connection</td>\n<td><code>DatabaseMetadata</code></td>\n<td><code>get_database_metadata()</code></td>\n</tr>\n<tr>\n<td>Type mapping</td>\n<td><code>TableMetadata</code>, <code>ColumnMetadata</code></td>\n<td><code>ObjectType</code> with field mappings</td>\n<td><code>TypeMapper.map_column_type()</code></td>\n</tr>\n<tr>\n<td>Relationship detection</td>\n<td><code>DatabaseMetadata</code></td>\n<td><code>Dict[str, List[Relationship]]</code></td>\n<td><code>RelationshipAnalyzer.analyze()</code></td>\n</tr>\n<tr>\n<td>Root type construction</td>\n<td>All generated object types</td>\n<td><code>ObjectType</code> for Query and Mutation</td>\n<td>Custom generation logic</td>\n</tr>\n<tr>\n<td>Schema assembly</td>\n<td>All generated types</td>\n<td><code>Schema</code></td>\n<td><code>create_schema()</code>, <code>validate_schema()</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Static vs. Dynamic Reflection</strong></p>\n<ul>\n<li><strong>Context</strong>: We must decide when schema reflection occurs: at startup (static) or on-demand per request (dynamic).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Static reflection</strong>: Reflect once at server startup, cache the schema</li>\n<li><strong>Dynamic reflection</strong>: Reflect on every request or schema change</li>\n<li><strong>Hybrid approach</strong>: Reflect at startup but watch for schema changes via database event notifications</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Static reflection with optional reload triggers</li>\n<li><strong>Rationale</strong>: Database schemas change infrequently in production, and reflection requires expensive queries to information_schema. Static reflection provides predictable performance and allows schema validation at startup. We include a manual reload trigger for schema updates. This balances performance with flexibility.</li>\n<li><strong>Consequences</strong>: Schema changes require server restart or manual reload. The server must handle connection pooling separately from reflection. This approach is used by both Hasura and PostGraphile in their default configurations.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Static reflection</td>\n<td><strong>Fast query execution, startup validation catches errors early</strong></td>\n<td><strong>Schema changes require restart/reload</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>Dynamic reflection</td>\n<td>Always current with database, no restart needed</td>\n<td>Performance overhead on every request, complex caching needed</td>\n<td></td>\n</tr>\n<tr>\n<td>Hybrid approach</td>\n<td>Best of both worlds when database supports events</td>\n<td>Complex to implement, database-specific event systems</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"message-and-data-formats\">Message and Data Formats</h3>\n<p>Components communicate through well-defined data structures. These structures flow through the system, transforming at each stage. Understanding their exact shape is crucial for implementing the interfaces correctly.</p>\n<h4 id=\"ast-nodes-parser-to-type-systemexecutor\">AST Nodes (Parser to Type System/Executor)</h4>\n<p>The parser produces a <code>Document</code> containing <code>Definition</code> nodes. These are read-only data structures passed to subsequent components.</p>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Contained In</th>\n<th>Purpose</th>\n<th>Key Fields</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Document</code></td>\n<td>Output of <code>parse_query()</code></td>\n<td>Root container for all definitions in a GraphQL document</td>\n<td><code>definitions: List[Definition]</code></td>\n</tr>\n<tr>\n<td><code>OperationDefinition</code></td>\n<td><code>Document.definitions</code></td>\n<td>A query, mutation, or subscription operation</td>\n<td><code>operation_type: str</code>, <code>selection_set: SelectionSet</code>, <code>variable_definitions: List[VariableDefinition]</code></td>\n</tr>\n<tr>\n<td><code>SelectionSet</code></td>\n<td><code>OperationDefinition</code>, <code>Field</code></td>\n<td>A set of fields/fragments to be selected</td>\n<td><code>selections: List[Selection]</code></td>\n</tr>\n<tr>\n<td><code>Field</code></td>\n<td><code>SelectionSet.selections</code></td>\n<td>A single field selection with arguments and sub-selections</td>\n<td><code>name: str</code>, <code>arguments: List[Argument]</code>, <code>selection_set: Optional[SelectionSet]</code></td>\n</tr>\n<tr>\n<td><code>FragmentDefinition</code></td>\n<td><code>Document.definitions</code></td>\n<td>A reusable fragment definition</td>\n<td><code>name: str</code>, <code>type_condition: NamedType</code>, <code>selection_set: SelectionSet</code></td>\n</tr>\n<tr>\n<td><code>FragmentSpread</code></td>\n<td><code>SelectionSet.selections</code></td>\n<td>A reference to a named fragment</td>\n<td><code>name: str</code>, <code>directives: List[Directive]</code></td>\n</tr>\n<tr>\n<td><code>VariableDefinition</code></td>\n<td><code>OperationDefinition.variable_definitions</code></td>\n<td>Definition of a variable used in the operation</td>\n<td><code>variable: Variable</code>, <code>type: Type</code>, <code>default_value: Optional[Value]</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"type-system-structures-schema-building\">Type System Structures (Schema Building)</h4>\n<p>The type system components create and use these structures to represent the GraphQL schema:</p>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Used By</th>\n<th>Purpose</th>\n<th>Key Fields</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Schema</code></td>\n<td>All components</td>\n<td>Complete GraphQL schema definition</td>\n<td><code>query_type: ObjectType</code>, <code>types: Dict[str, GraphQLType]</code>, <code>directives: Dict[str, GraphQLDirective]</code></td>\n</tr>\n<tr>\n<td><code>ObjectType</code></td>\n<td>Schema, Reflection</td>\n<td>GraphQL object type with fields</td>\n<td><code>fields: Dict[str, GraphQLField]</code>, <code>interfaces: List[InterfaceType]</code></td>\n</tr>\n<tr>\n<td><code>GraphQLField</code></td>\n<td><code>ObjectType.fields</code></td>\n<td>Definition of a single field on a type</td>\n<td><code>type: GraphQLType</code>, <code>args: Dict[str, GraphQLArgument]</code>, <code>resolve: Optional[Callable]</code></td>\n</tr>\n<tr>\n<td><code>InterfaceType</code></td>\n<td>Schema</td>\n<td>GraphQL interface type</td>\n<td><code>fields: Dict[str, GraphQLField]</code>, <code>resolve_type: Optional[Callable]</code></td>\n</tr>\n<tr>\n<td><code>UnionType</code></td>\n<td>Schema</td>\n<td>GraphQL union type</td>\n<td><code>types: List[ObjectType]</code>, <code>resolve_type: Optional[Callable]</code></td>\n</tr>\n<tr>\n<td><code>InputObjectType</code></td>\n<td>Schema</td>\n<td>Input object type for arguments</td>\n<td><code>fields: Dict[str, GraphQLInputField]</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"execution-state-executor-internal\">Execution State (Executor Internal)</h4>\n<p>The execution engine maintains state throughout query resolution:</p>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Lifetime</th>\n<th>Purpose</th>\n<th>Key Fields</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ExecutionContext</code></td>\n<td>Per query execution</td>\n<td>Tracks all state during execution</td>\n<td><code>schema: Schema</code>, <code>document_ast: Document</code>, <code>variable_values: Dict[str, Any]</code>, <code>errors: List[GraphQLError]</code>, <code>data_loaders: Dict[str, DataLoader]</code>, <code>path: List[PathSegment]</code></td>\n</tr>\n<tr>\n<td><code>GraphQLError</code></td>\n<td>Error occurrence to response</td>\n<td>Represents an error in query execution</td>\n<td><code>message: str</code>, <code>locations: List[Location]</code>, <code>path: List[PathSegment]</code>, <code>extensions: Dict[str, Any]</code></td>\n</tr>\n<tr>\n<td><code>DataLoader</code></td>\n<td>Per request or context</td>\n<td>Batches and caches data fetching calls</td>\n<td><code>batch_load_fn: Callable</code>, <code>cache: Dict</code>, <code>queue: List</code>, <code>max_batch_size: int</code></td>\n</tr>\n<tr>\n<td><code>ExecutionResult</code></td>\n<td>End of execution</td>\n<td>Final result returned to caller</td>\n<td><code>data: Optional[Dict]</code>, <code>errors: List[GraphQLError]</code>, <code>extensions: Dict[str, Any]</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"sql-intermediate-representation-compiler-to-database\">SQL Intermediate Representation (Compiler to Database)</h4>\n<p>The SQL compiler produces intermediate structures that bridge GraphQL and SQL:</p>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Produced By</th>\n<th>Consumed By</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SQLQuery</code></td>\n<td><code>compile_to_sql()</code></td>\n<td>Database executor</td>\n<td>Complete executable SQL query with metadata</td>\n</tr>\n<tr>\n<td><code>SQLSelect</code></td>\n<td>SQL generation</td>\n<td><code>SQLQuery</code></td>\n<td>A single SELECT statement component</td>\n</tr>\n<tr>\n<td><code>SQLJoin</code></td>\n<td>Join planning</td>\n<td><code>SQLSelect.joins</code></td>\n<td>A JOIN between two tables</td>\n</tr>\n<tr>\n<td><code>SQLExpression</code></td>\n<td>WHERE/ON clause generation</td>\n<td><code>SQLSelect.where</code>, <code>SQLJoin.on</code></td>\n<td>A condition expression</td>\n</tr>\n<tr>\n<td><code>SQLParameter</code></td>\n<td>Parameter binding</td>\n<td>Database execution</td>\n<td>A bound parameter value</td>\n</tr>\n</tbody></table>\n<h4 id=\"database-metadata-reflection-internal\">Database Metadata (Reflection Internal)</h4>\n<p>The reflection engine uses these structures to represent database schema information:</p>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Source</th>\n<th>Purpose</th>\n<th>Key Fields</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DatabaseMetadata</code></td>\n<td><code>get_database_metadata()</code></td>\n<td>Complete database schema snapshot</td>\n<td><code>tables: Dict[str, TableMetadata]</code>, <code>enums: Dict[str, List[str]]</code>, <code>version: str</code></td>\n</tr>\n<tr>\n<td><code>TableMetadata</code></td>\n<td>Database introspection</td>\n<td>Metadata for a single table</td>\n<td><code>name: str</code>, <code>schema: str</code>, <code>columns: List[ColumnMetadata]</code>, <code>primary_key_columns: List[str]</code>, <code>foreign_keys: List[Dict[str, Any]]</code></td>\n</tr>\n<tr>\n<td><code>ColumnMetadata</code></td>\n<td>Database introspection</td>\n<td>Metadata for a single column</td>\n<td><code>name: str</code>, <code>data_type: str</code>, <code>is_nullable: bool</code>, <code>is_primary_key: bool</code>, <code>default_value: Optional[str]</code></td>\n</tr>\n<tr>\n<td><code>Relationship</code></td>\n<td><code>RelationshipAnalyzer.analyze()</code></td>\n<td>A relationship between two tables</td>\n<td><code>source_table: str</code>, <code>target_table: str</code>, <code>relationship_type: str</code>, <code>source_columns: List[str]</code>, <code>target_columns: List[str]</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight: The SQL IR as a Bridge</strong><br>The <code>SQLQuery</code> structure is the critical bridge between the GraphQL and SQL worlds. It contains both the executable SQL (as strings and parameters) and the metadata needed to transform flat SQL rows back into nested GraphQL responses. The <code>result_mapper</code> function is generated during compilation and understands how to reconstruct the hierarchical response from the denormalized JOIN results.</p>\n</blockquote>\n<h4 id=\"data-transformation-pipeline\">Data Transformation Pipeline</h4>\n<p>The complete transformation pipeline shows how data evolves through the system:</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input</th>\n<th>Output</th>\n<th>Transformation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. Lexing</td>\n<td>GraphQL query string</td>\n<td><code>List[Token]</code></td>\n<td>Character grouping into lexical tokens</td>\n</tr>\n<tr>\n<td>2. Parsing</td>\n<td><code>List[Token]</code></td>\n<td><code>Document</code> AST</td>\n<td>Recursive descent parsing builds tree structure</td>\n</tr>\n<tr>\n<td>3. Validation</td>\n<td><code>Document</code> + <code>Schema</code></td>\n<td>Validated <code>Document</code></td>\n<td>Type checking, field existence, argument validation</td>\n</tr>\n<tr>\n<td>4. SQL Compilation</td>\n<td><code>Document</code> + <code>Schema</code> + <code>DatabaseMetadata</code></td>\n<td><code>SQLQuery</code></td>\n<td>AST analysis, join planning, SQL generation</td>\n</tr>\n<tr>\n<td>5. Database Execution</td>\n<td><code>SQLQuery</code></td>\n<td><code>List[Dict]</code> (rows)</td>\n<td>Parameter binding, SQL execution, row fetching</td>\n</tr>\n<tr>\n<td>6. Result Mapping</td>\n<td><code>List[Dict]</code> + <code>SQLQuery.result_mapper</code></td>\n<td>Nested data dict</td>\n<td>Row denormalization, nesting reconstruction</td>\n</tr>\n<tr>\n<td>7. Field Resolution</td>\n<td>Nested data dict + <code>Schema</code></td>\n<td>Complete response tree</td>\n<td>Resolver invocation, error collection, null propagation</td>\n</tr>\n<tr>\n<td>8. Response Assembly</td>\n<td>Response tree + errors</td>\n<td><code>ExecutionResult</code></td>\n<td>Formatting, error inclusion, extension addition</td>\n</tr>\n</tbody></table>\n<h4 id=\"component-interface-summary\">Component Interface Summary</h4>\n<p>The primary interfaces between components are defined by these key methods:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>From Component</th>\n<th>To Component</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parse_query(query_str)</code></td>\n<td>HTTP layer/executor</td>\n<td>Parser</td>\n<td>Convert query string to AST</td>\n</tr>\n<tr>\n<td><code>create_schema(...)</code></td>\n<td>Application/reflection</td>\n<td>Type system</td>\n<td>Build validated schema from type definitions</td>\n</tr>\n<tr>\n<td><code>reflect_schema(connection_config, options)</code></td>\n<td>Application</td>\n<td>Reflection engine</td>\n<td>Generate schema from database</td>\n</tr>\n<tr>\n<td><code>execute_query(schema, document_ast, ...)</code></td>\n<td>HTTP layer</td>\n<td>Execution engine</td>\n<td>Execute query and return result</td>\n</tr>\n<tr>\n<td><code>compile_to_sql(schema, document_ast, ...)</code></td>\n<td>Execution engine</td>\n<td>SQL compiler</td>\n<td>Generate SQL from GraphQL query</td>\n</tr>\n<tr>\n<td><code>get_database_metadata(...)</code></td>\n<td>Reflection engine</td>\n<td>Database introspector</td>\n<td>Extract raw database schema information</td>\n</tr>\n</tbody></table>\n<p>The component interactions are visualized in <img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Fsystem-component-diagram.svg\" alt=\"System Component Diagram\">, showing how data flows between these interfaces.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing the data flows and interactions described above. We&#39;ll focus on wiring the components together and creating the necessary integration points.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Integration Point</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Server</td>\n<td>Flask (Python) with synchronous execution</td>\n<td>FastAPI (Python) with async/await support</td>\n</tr>\n<tr>\n<td>Database Connection Pooling</td>\n<td><code>psycopg2.pool.SimpleConnectionPool</code> (PostgreSQL)</td>\n<td><code>asyncpg</code> with built-in connection pool</td>\n</tr>\n<tr>\n<td>SQL Building</td>\n<td>String concatenation with parameter placeholders</td>\n<td>SQLAlchemy Core for dialect-aware SQL generation</td>\n</tr>\n<tr>\n<td>Result Caching</td>\n<td><code>functools.lru_cache</code> for schema reflection</td>\n<td>Redis for distributed query result caching</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<p>To organize the interactions between components, create this directory structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql_engine/\n├── __init__.py\n├── server.py                      # HTTP server integration\n├── parser/                        # Milestone 1\n│   ├── __init__.py\n│   ├── lexer.py                   # Tokenizer\n│   ├── parser.py                  # Parser, parse_query()\n│   └── ast.py                     # AST node classes\n├── type_system/                   # Milestone 2\n│   ├── __init__.py\n│   ├── schema.py                  # Schema, create_schema()\n│   ├── types.py                   # GraphQLType hierarchy\n│   ├── validation.py              # validate_schema()\n│   └── introspection.py           # Introspection query handling\n├── execution/                     # Milestone 3\n│   ├── __init__.py\n│   ├── executor.py                # execute_query(), ExecutionContext\n│   ├── resolvers.py               # Default resolvers\n│   ├── errors.py                  # GraphQLError\n│   └── dataloaders.py             # DataLoader implementation\n├── reflection/                    # Milestone 4\n│   ├── __init__.py\n│   ├── reflector.py               # reflect_schema()\n│   ├── introspectors.py           # BaseIntrospector implementations\n│   ├── type_mapper.py             # TypeMapper\n│   ├── relationship_analyzer.py   # RelationshipAnalyzer\n│   └── naming.py                  # NamingConvention utilities\n├── compilation/                   # Milestone 5\n│   ├── __init__.py\n│   ├── compiler.py                # compile_to_sql()\n│   ├── sql_builder.py             # SQLBuilder\n│   ├── join_planner.py            # plan_joins()\n│   └── ir.py                      # SQL IR classes\n└── integration.py                 # Main integration point combining all components</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Here&#39;s a complete HTTP server integration that wires the components together:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># graphql_engine/server.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> flask </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Flask, request, jsonify</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.integration </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLEngine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">app </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Flask(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_app</span><span style=\"color:#E1E4E8\">(database_url</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, schema</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create and configure the Flask application with GraphQL engine.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    global</span><span style=\"color:#E1E4E8\"> engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Initialize the GraphQL engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> GraphQLEngine()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> database_url:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Use database reflection for schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        engine.reflect_schema_from_database(database_url)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> schema:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Use provided schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        engine.set_schema(schema)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Use a minimal default schema for testing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        engine.set_default_schema()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> app</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@app.route</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'/graphql'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">methods</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#9ECBFF\">'POST'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> graphql_endpoint</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main GraphQL endpoint.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> engine </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> jsonify({</span><span style=\"color:#9ECBFF\">'errors'</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Engine not initialized'</span><span style=\"color:#E1E4E8\">}]}), </span><span style=\"color:#79B8FF\">500</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Extract GraphQL request from JSON body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.get_json()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data.get(</span><span style=\"color:#9ECBFF\">'query'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        variables </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data.get(</span><span style=\"color:#9ECBFF\">'variables'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operation_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data.get(</span><span style=\"color:#9ECBFF\">'operationName'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> query:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> jsonify({</span><span style=\"color:#9ECBFF\">'errors'</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'No query provided'</span><span style=\"color:#E1E4E8\">}]}), </span><span style=\"color:#79B8FF\">400</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Execute the query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> engine.execute(query, variables, operation_name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return the result as JSON</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> jsonify(result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logging.exception(</span><span style=\"color:#9ECBFF\">\"GraphQL execution error\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> jsonify({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'errors'</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(e)}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }), </span><span style=\"color:#79B8FF\">500</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@app.route</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'/health'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">methods</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#9ECBFF\">'GET'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> health_check</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Health check endpoint.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> jsonify({</span><span style=\"color:#9ECBFF\">'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'healthy'</span><span style=\"color:#E1E4E8\">}), </span><span style=\"color:#79B8FF\">200</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> '__main__'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # For development: create app with database connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    database_url </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> os.environ.get(</span><span style=\"color:#9ECBFF\">'DATABASE_URL'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'postgresql://localhost/test'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    app </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_app(database_url)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    app.run(</span><span style=\"color:#FFAB70\">debug</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>And the main integration class that orchestrates component interactions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># graphql_engine/integration.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.type_system.schema </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema, create_schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.execution.executor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> execute_query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.reflection.reflector </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> reflect_schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.compilation.compiler </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> compile_to_sql</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main integration point for all GraphQL engine components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.schema: Optional[Schema] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.database_connection </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.compilation_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> reflect_schema_from_database</span><span style=\"color:#E1E4E8\">(self, connection_string: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                     options: Optional[Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Reflect schema from database and enable SQL compilation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> graphql_engine.reflection.reflector </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> reflect_schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Store connection for later use by compiler</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.database_connection </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._create_connection(connection_string)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Reflect schema from database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reflection_options </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> options </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reflect_schema(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.database_connection, reflection_options)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Enable SQL compilation for this schema</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.compilation_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_schema</span><span style=\"color:#E1E4E8\">(self, schema: Schema):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Use a pre-defined schema (disables SQL compilation).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> schema</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.compilation_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_default_schema</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a minimal default schema for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Implementation creates a simple schema with a hello field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute</span><span style=\"color:#E1E4E8\">(self, query: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, variables: Optional[Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                operation_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute a GraphQL query end-to-end.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.schema:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"No schema configured\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Step 1: Parse the query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        document_ast </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_query(query)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Step 2: Compile to SQL if enabled</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sql_query </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.compilation_enabled </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.database_connection:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sql_query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> compile_to_sql(</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.schema, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                document_ast, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                operation_name, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                variables </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                {</span><span style=\"color:#9ECBFF\">'connection'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.database_connection}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Step 3: Execute the query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> execute_query(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            schema</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.schema,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            document_ast</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">document_ast,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            variable_values</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">variables,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            operation_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">operation_name,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Pass SQL query to execution context for use by resolvers</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            context_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">'sql_query'</span><span style=\"color:#E1E4E8\">: sql_query} </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> sql_query </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'data'</span><span style=\"color:#E1E4E8\">: result.data,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'errors'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._format_error(e) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> e </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> result.errors] </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> result.errors </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _create_connection</span><span style=\"color:#E1E4E8\">(self, connection_string: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a database connection based on the connection string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Simplified implementation - in reality, use proper connection pooling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> psycopg2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> psycopg2.connect(connection_string)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _format_error</span><span style=\"color:#E1E4E8\">(self, error):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format a GraphQLError for JSON response.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'message'</span><span style=\"color:#E1E4E8\">: error.message,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'locations'</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#9ECBFF\">'line'</span><span style=\"color:#E1E4E8\">: loc.line, </span><span style=\"color:#9ECBFF\">'column'</span><span style=\"color:#E1E4E8\">: loc.column} </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         for</span><span style=\"color:#E1E4E8\"> loc </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> error.locations] </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> error.locations </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'path'</span><span style=\"color:#E1E4E8\">: error.path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>Here&#39;s the skeleton for the main execution flow integration:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># graphql_engine/execution/executor.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.parser.ast </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Document</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.type_system.schema </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .execution_context </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ExecutionContext</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ExecutionResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result of executing a GraphQL query.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, data: Optional[Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, errors: Optional[List[GraphQLError]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errors </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> execute_query</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema: Schema,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    document_ast: Document,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variable_values: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_value: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_value: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> ExecutionResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Execute a GraphQL query against a schema.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This is the main entry point for query execution, integrating parsing,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    validation, and field resolution.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        schema: The GraphQL schema to execute against</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        document_ast: Parsed AST of the GraphQL query</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        variable_values: Values for variables defined in the query</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        operation_name: Name of the operation to execute if document contains multiple</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        context_value: Context object passed to all resolvers</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        root_value: Value passed to the root resolver</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ExecutionResult containing data and/or errors</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that schema is properly configured (query_type exists)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract the operation to execute from document_ast</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - If operation_name is provided, find the operation with that name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - If only one operation exists and no name provided, use that one</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Otherwise, raise an error about ambiguous operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate variable values against variable definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Coerce values to the defined types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Apply default values where variables are not provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create ExecutionContext</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Store schema, document_ast, variable_values, context_value, root_value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Initialize empty errors list and data_loaders dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate the operation against the schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Check that all selected fields exist on their respective types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Validate argument types match field definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Verify fragments are used on compatible types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - If validation fails, collect errors and return early</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Execute the operation based on its type (query/mutation/subscription)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - For queries: execute selection set starting from root_value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - For mutations: execute serially (not in parallel)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Build and return ExecutionResult with data and errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # For now, return a placeholder</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ExecutionResult(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">errors</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[])</span></span></code></pre></div>\n\n<p>And for the SQL compilation integration:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># graphql_engine/compilation/compiler.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.parser.ast </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Document</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> graphql_engine.type_system.schema </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .ir </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SQLQuery</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> compile_to_sql</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema: Schema,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    document_ast: Document,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variable_values: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> SQLQuery:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Compile a GraphQL query to an optimized SQL query.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This is the main entry point for SQL compilation, integrating AST analysis,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    join planning, and SQL generation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        schema: The GraphQL schema (must be a reflected schema)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        document_ast: Parsed AST of the GraphQL query</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        operation_name: Name of the operation to compile</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        variable_values: Values for variables used in the query</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        context: Execution context containing database connection and metadata</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        SQLQuery object containing executable SQL and parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Verify the schema is a reflected schema (has database metadata)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract the operation to compile (similar to execute_query)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Analyze the selection set to identify accessed tables and relationships</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Start from the root query type field (e.g., 'users', 'posts')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Recursively traverse nested selections, mapping them to table relationships</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Build a list of selection paths: e.g., ['users', 'users.posts', 'users.posts.comments']</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Plan JOINs using plan_joins() function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Determine optimal join order to avoid cartesian products</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Choose join types (INNER, LEFT) based on nullability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Generate table aliases for self-joins or multiple joins to same table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate SELECT clause for each table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Include only columns corresponding to selected fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Generate column aliases that map back to field names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate WHERE clause from GraphQL arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Convert filter arguments to SQL conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Handle comparison operators (eq, lt, gt, in, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Bind parameters to prevent SQL injection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Generate ORDER BY and LIMIT/OFFSET from pagination arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Build SQLQuery object with all components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Set root_select with main SELECT statement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Add nested_selects for complex cases requiring subqueries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Collect all parameters for binding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Generate result_mapper function that transforms flat rows to nested structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return the complete SQLQuery object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # For now, return a placeholder</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> SQLQuery(</span><span style=\"color:#FFAB70\">root_select</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nested_selects</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[], </span><span style=\"color:#FFAB70\">parameters</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[])</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Python-Specific Implementation Notes:</strong></p>\n<ol>\n<li><strong>Type Hints</strong>: Use Python&#39;s type hints extensively for the data structures. This provides documentation and helps catch errors early:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any, Union</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> Field</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       alias: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       arguments: List[Argument]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       directives: List[Directive]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       selection_set: Optional[SelectionSet]</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Dataclasses</strong>: Use <code>@dataclass</code> decorator for immutable data structures like AST nodes and metadata objects:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   @dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> Location</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       line: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       column: </span><span style=\"color:#79B8FF\">int</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Async/Await</strong>: For parallel field execution, use <code>asyncio.gather()</code> to resolve sibling fields concurrently:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> resolve_fields_concurrently</span><span style=\"color:#E1E4E8\">(fields):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       tasks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [resolve_field(field) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> field </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> fields]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> asyncio.gather(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">tasks, </span><span style=\"color:#FFAB70\">return_exceptions</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Connection Pooling</strong>: Use context managers for database connections to ensure proper cleanup:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   @contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   def</span><span style=\"color:#B392F0\"> get_connection</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       conn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pool.getconn()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           yield</span><span style=\"color:#E1E4E8\"> conn</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           pool.putconn(conn)</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the integration layer, verify the complete flow works:</p>\n<ol>\n<li><p><strong>Start the server</strong>: Run <code>python -m graphql_engine.server</code> and ensure it starts without errors.</p>\n</li>\n<li><p><strong>Test with a simple query</strong>: Use curl or a GraphQL client to send a query:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:5000/graphql</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '{\"query\": \"query { __schema { types { name } } }\"}'</span></span></code></pre></div>\n<p>   Expected output should include introspection data with no errors.</p>\n<ol start=\"3\">\n<li><strong>Test database reflection</strong>: Set a <code>DATABASE_URL</code> environment variable and restart. Send a query for a table that exists:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:5000/graphql</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '{\"query\": \"query { users { id, name } }\"}'</span></span></code></pre></div>\n<p>   Expected: Returns actual user data from the database or an empty array if table is empty.</p>\n<ol start=\"4\">\n<li><strong>Verify SQL generation</strong>: Enable debug logging and check that SQL queries are being generated correctly. Look for log messages showing the generated SQL with parameter placeholders.</li>\n</ol>\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li>&quot;No schema configured&quot; error: The engine wasn&#39;t initialized properly</li>\n<li>Parse errors in valid queries: Parser implementation issues</li>\n<li>&quot;Field X doesn&#39;t exist&quot; when it does in database: Reflection naming issues</li>\n<li>SQL syntax errors: SQL generation bugs, especially with JOINs</li>\n<li>Missing nested data: Result mapper not reconstructing hierarchy correctly</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Query returns empty data but no error</td>\n<td>SQL query returning no rows</td>\n<td>Log the generated SQL and execute it manually against the database</td>\n<td>Check table names, WHERE conditions, JOIN conditions</td>\n</tr>\n<tr>\n<td>Nested fields are null</td>\n<td>Result mapper not reconstructing hierarchy</td>\n<td>Print the raw SQL rows and the result mapper logic</td>\n<td>Ensure result mapper groups child records under parent keys</td>\n</tr>\n<tr>\n<td>&quot;Cannot query field X on type Y&quot;</td>\n<td>Reflection didn&#39;t create the field</td>\n<td>Check if table/column was excluded by filters, or naming convention mismatch</td>\n<td>Adjust reflection options, check naming conventions</td>\n</tr>\n<tr>\n<td>Database connection errors</td>\n<td>Connection pool exhausted or credentials wrong</td>\n<td>Check connection string, database permissions</td>\n<td>Ensure connection pool size adequate, credentials correct</td>\n</tr>\n<tr>\n<td>Cartesian product (too many rows)</td>\n<td>Missing JOIN conditions</td>\n<td>Examine generated SQL JOIN clauses</td>\n<td>Ensure every JOIN has an ON condition from foreign key</td>\n</tr>\n<tr>\n<td>Memory usage high with large queries</td>\n<td>No LIMIT clause on root query</td>\n<td>Check if pagination arguments are being applied</td>\n<td>Add default limit for collection fields, implement cursor pagination</td>\n</tr>\n<tr>\n<td>&quot;Variable $var not defined&quot;</td>\n<td>Variable parsing/validation issue</td>\n<td>Check variable definitions in operation header</td>\n<td>Ensure variable definitions are parsed and variables are passed</td>\n</tr>\n</tbody></table>\n<p>To debug effectively:</p>\n<ol>\n<li>Enable detailed logging for all components</li>\n<li>Use the GraphiQL interface (if implemented) to see query validation</li>\n<li>Test SQL queries directly against the database</li>\n<li>Add <code>print()</code> statements in the result mapper to see transformation steps</li>\n<li>Use a visualizer for AST structure to understand query shape</li>\n</ol>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section spans all five milestones, addressing failure modes and special cases that arise throughout the entire GraphQL execution pipeline. Error handling is a critical cross-cutting concern that must be addressed consistently across parsing (Milestone 1), type validation (Milestone 2), execution (Milestone 3), database reflection (Milestone 4), and SQL compilation (Milestone 5).</p>\n</blockquote>\n<h3 id=\"error-categories-and-handling\">Error Categories and Handling</h3>\n<p>Think of error handling in a GraphQL engine as a <strong>multi-layered safety net</strong>—each layer catches different types of failures while allowing the system to continue operating when possible. Unlike traditional REST APIs where a single error often terminates the entire request, GraphQL&#39;s partial results model requires careful error propagation that preserves valid data while clearly indicating what went wrong.</p>\n<p>The GraphQL specification defines specific error behaviors, but our implementation must also handle infrastructure failures (database connections, network issues) and implementation bugs. Each error category requires distinct detection strategies and recovery approaches.</p>\n<h4 id=\"error-classification-and-handling-strategies\">Error Classification and Handling Strategies</h4>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Detection Strategy</th>\n<th>Recovery Approach</th>\n<th>User Visibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Parse Errors</strong> (Milestone 1)</td>\n<td>Lexer/parser token validation, grammar rule violations</td>\n<td>Immediate termination with precise location info</td>\n<td>Full error details (line, column, expected tokens)</td>\n</tr>\n<tr>\n<td><strong>Validation Errors</strong> (Milestone 2)</td>\n<td>Schema validation passes, query validation against schema</td>\n<td>Early rejection before execution</td>\n<td>Detailed error messages about schema violations</td>\n</tr>\n<tr>\n<td><strong>Execution Errors</strong> (Milestone 3)</td>\n<td>Resolver exceptions, type coercion failures, null violations</td>\n<td>Partial execution with error propagation</td>\n<td>Errors attached to specific fields in response</td>\n</tr>\n<tr>\n<td><strong>Database Errors</strong> (Milestone 4, 5)</td>\n<td>SQL execution failures, connection issues, constraint violations</td>\n<td>Transaction rollback (if applicable), error categorization</td>\n<td>Sanitized error messages (hide DB internals)</td>\n</tr>\n<tr>\n<td><strong>Resource Errors</strong> (All)</td>\n<td>Timeouts, memory limits, connection limits</td>\n<td>Graceful degradation, circuit breaking</td>\n<td>Generic service unavailable messages</td>\n</tr>\n</tbody></table>\n<h4 id=\"parse-error-handling\">Parse Error Handling</h4>\n<p>Parse errors occur when the GraphQL query string violates the language syntax. The parser must provide <strong>actionable feedback</strong> by pinpointing exactly where the syntax diverges from expectations.</p>\n<blockquote>\n<p><strong>Decision: Parser Error Reporting</strong></p>\n<ul>\n<li><strong>Context</strong>: Learners need detailed feedback to debug malformed queries, but overly technical error messages can be confusing.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Simple &quot;syntax error&quot; messages with line numbers only</li>\n<li>Full parser state dumps (current token, expected tokens, parser stack)</li>\n<li>Human-readable messages with exact location and suggestions</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 3 with precise location tracking and clear expectations</li>\n<li><strong>Rationale</strong>: Follows GraphQL spec requirements for error locations while being learner-friendly. The <code>Location</code> type in our data model provides the necessary tracking.</li>\n<li><strong>Consequences</strong>: Requires maintaining accurate line/column tracking throughout lexing and parsing, but gives users exactly what they need to fix queries.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Parse Error Type</th>\n<th>Detection Point</th>\n<th>Error Message Format</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Unexpected Token</strong></td>\n<td>Parser expecting specific token (e.g., <code>{</code> after field name)</td>\n<td><code>Syntax error at line X, column Y: Expected &quot;{&quot;, found &quot;}&quot;</code></td>\n<td><code>query { user(id: 1 }</code> (missing closing <code>)</code>)</td>\n</tr>\n<tr>\n<td><strong>Unterminated String</strong></td>\n<td>Lexer reaches end of input without closing quote</td>\n<td><code>Syntax error at line X, column Y: Unterminated string</code></td>\n<td><code>query { name: &quot;unclosed</code></td>\n</tr>\n<tr>\n<td><strong>Invalid Number</strong></td>\n<td>Lexer fails to convert character sequence to number</td>\n<td><code>Syntax error at line X, column Y: Invalid number &quot;12.3.4&quot;</code></td>\n<td><code>query { value: 12.3.4 }</code></td>\n</tr>\n<tr>\n<td><strong>Unknown Character</strong></td>\n<td>Lexer encounters character outside valid token set</td>\n<td><code>Syntax error at line X, column Y: Unknown character &quot;@&quot;</code></td>\n<td><code>query { field @unknown }</code></td>\n</tr>\n</tbody></table>\n<p>The parser must maintain a <strong>parse stack</strong> to provide context-aware error messages. For example, when encountering a syntax error inside a nested selection set, the error should indicate &quot;while parsing selection set of field &#39;user&#39;&quot; to give context beyond just line/column numbers.</p>\n<h4 id=\"validation-error-handling\">Validation Error Handling</h4>\n<p>Validation errors occur when a syntactically correct query violates schema rules. These are caught before execution to prevent runtime failures. The validation phase performs dozens of checks defined in the GraphQL specification.</p>\n<blockquote>\n<p><strong>Decision: Validation Strictness</strong></p>\n<ul>\n<li><strong>Context</strong>: Some validation rules are essential for correctness (like type compatibility), while others are warnings (like deprecated field usage).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fail fast on first validation error</li>\n<li>Collect all validation errors before reporting</li>\n<li>Separate errors from warnings, continue execution with warnings</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 2 with all validation errors collected</li>\n<li><strong>Rationale</strong>: GraphQL spec requires returning all validation errors. This gives users complete information to fix their query without multiple round trips.</li>\n<li><strong>Consequences</strong>: More complex validation implementation that must continue after encountering errors, but provides better developer experience.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Validation Rule Category</th>\n<th>Example Checks</th>\n<th>Error Message Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Type Compatibility</strong></td>\n<td>Field type matches argument type, return type matches selection</td>\n<td><code>Field &quot;age&quot; of type &quot;String&quot; cannot represent non-string value: 42</code></td>\n</tr>\n<tr>\n<td><strong>Field Existence</strong></td>\n<td>Requested field exists on type, arguments exist</td>\n<td><code>Cannot query field &quot;email&quot; on type &quot;User&quot;. Did you mean &quot;name&quot;?</code></td>\n</tr>\n<tr>\n<td><strong>Fragment Validation</strong></td>\n<td>Fragment type conditions are valid, spreads are possible</td>\n<td><code>Fragment &quot;UserFields&quot; cannot be spread here as object of type &quot;Post&quot; can never be of type &quot;User&quot;</code></td>\n</tr>\n<tr>\n<td><strong>Variable Validation</strong></td>\n<td>Variables match defined types, required variables provided</td>\n<td><code>Variable &quot;$id&quot; of type &quot;Int!&quot; is required but not provided</code></td>\n</tr>\n<tr>\n<td><strong>Operation Validation</strong></td>\n<td>Single operation when unnamed, operation names unique</td>\n<td><code>This operation is named &quot;GetUser&quot; but no operation name was provided</code></td>\n</tr>\n</tbody></table>\n<p>Validation should implement the <strong>visitor pattern</strong> to traverse the AST once while running multiple validation rules. Each rule is a separate function that can add errors to a shared collection without stopping the traversal.</p>\n<h4 id=\"execution-error-handling\">Execution Error Handling</h4>\n<p>Execution errors occur during resolver execution and represent the most complex error handling scenario. GraphQL&#39;s <strong>partial results</strong> model means fields can fail independently, and the engine must decide how to propagate these failures.</p>\n<p><strong>Mental Model: The Fault-Tolerant Assembly Line</strong>\nImagine an assembly line where each station (resolver) processes parts of a product (data). If one station fails, we don&#39;t throw away the entire product—we mark that specific part as defective and continue assembling the rest. The final product has some missing parts, but we clearly label which ones failed and why.</p>\n<table>\n<thead>\n<tr>\n<th>Execution Error Type</th>\n<th>Detection Mechanism</th>\n<th>Null Propagation Rule</th>\n<th>Error Collection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Resolver Exception</strong></td>\n<td>Try/catch around resolver invocation</td>\n<td>If field is non-null (<code>Type!</code>), propagate to parent</td>\n<td>Add to <code>GraphQLError</code> list with path</td>\n</tr>\n<tr>\n<td><strong>Type Coercion Error</strong></td>\n<td>Value validation during argument/result conversion</td>\n<td>Follows same rules as resolver errors</td>\n<td>Add to <code>GraphQLError</code> list with path</td>\n</tr>\n<tr>\n<td><strong>Authorization Error</strong></td>\n<td>Context validation in resolvers</td>\n<td>Typically treat as resolver exception</td>\n<td>May include extensions with auth details</td>\n</tr>\n<tr>\n<td><strong>Resource Limit Error</strong></td>\n<td>Timeout detection, memory monitoring</td>\n<td>Terminate entire execution</td>\n<td>Single error at root level</td>\n</tr>\n</tbody></table>\n<p>The key challenge is <strong>null propagation</strong>: when a non-null field (<code>String!</code>) resolves to null or throws an error, the entire parent field becomes null (if nullable) or continues bubbling up. This follows the GraphQL spec&#39;s &quot;fail fast&quot; rule for non-null fields.</p>\n<p><strong>Execution error handling algorithm:</strong></p>\n<ol>\n<li>When a resolver throws an exception, catch it immediately</li>\n<li>Create a <code>GraphQLError</code> with the exception message, current field path (<code>[&quot;users&quot;, 0, &quot;email&quot;]</code>), and location from AST</li>\n<li>If the field&#39;s return type is non-null (<code>Type!</code>):<ul>\n<li>Set the field&#39;s resolved value to <code>None</code> (null)</li>\n<li>Mark the parent field as &quot;contains null from non-null child&quot;</li>\n</ul>\n</li>\n<li>If the parent field is also non-null, repeat step 3 recursively</li>\n<li>If the field is nullable (<code>Type</code> or <code>[Type]</code>):<ul>\n<li>Set the field&#39;s resolved value to <code>None</code></li>\n<li>Continue executing sibling fields</li>\n</ul>\n</li>\n<li>Add the error to <code>ExecutionContext.errors</code> list for inclusion in final response</li>\n</ol>\n<h4 id=\"database-error-handling\">Database Error Handling</h4>\n<p>Database errors bridge Milestone 4 (reflection) and Milestone 5 (SQL compilation). These errors come from the underlying database system and must be sanitized before exposing to users.</p>\n<blockquote>\n<p><strong>Decision: Database Error Sanitization</strong></p>\n<ul>\n<li><strong>Context</strong>: Raw database errors expose internal details (table names, constraint names, SQL snippets) that are security risks and confusing to GraphQL API consumers.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Pass through raw database errors (maximum debugging info, maximum risk)</li>\n<li>Completely generic errors (&quot;Database error occurred&quot;)</li>\n<li>Categorized errors with sanitized messages</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 3 with error categorization and safe messaging</li>\n<li><strong>Rationale</strong>: Balances debuggability (developers need to know what went wrong) with security (don&#39;t leak schema details). Different error categories suggest different fixes.</li>\n<li><strong>Consequences</strong>: Requires parsing database error messages (which vary by database vendor) and mapping to safe categories.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Database Error Category</th>\n<th>Detection Pattern</th>\n<th>Sanitized Message</th>\n<th>Internal Logging</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Connection Errors</strong></td>\n<td>Network timeout, authentication failure</td>\n<td>&quot;Unable to connect to database&quot;</td>\n<td>Full connection string (without password), network details</td>\n</tr>\n<tr>\n<td><strong>Constraint Violations</strong></td>\n<td>Unique constraint, foreign key violation</td>\n<td>&quot;Data validation failed&quot;</td>\n<td>Constraint name, table name, violating values</td>\n</tr>\n<tr>\n<td><strong>Syntax/Planning Errors</strong></td>\n<td>Invalid SQL, missing columns</td>\n<td>&quot;Query compilation error&quot;</td>\n<td>Generated SQL, compilation context</td>\n</tr>\n<tr>\n<td><strong>Permission Errors</strong></td>\n<td>Insufficient privileges on table/column</td>\n<td>&quot;Access denied to requested resource&quot;</td>\n<td>User/role, attempted operation</td>\n</tr>\n<tr>\n<td><strong>Resource Errors</strong></td>\n<td>Too many connections, disk full</td>\n<td>&quot;Database resource limit reached&quot;</td>\n<td>Resource type, current usage</td>\n</tr>\n</tbody></table>\n<p>The reflection component (Milestone 4) has its own state machine with explicit error states, as shown in the diagram:</p>\n<p><img src=\"/api/project/build-graphql-engine/architecture-doc/asset?path=diagrams%2Freflection-state-machine.svg\" alt=\"Schema Reflection State Machine\"></p>\n<p><strong>Reflection error recovery states:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Error Event</th>\n<th>Next State</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>connecting</code></td>\n<td>Connection timeout</td>\n<td><code>error</code></td>\n<td>Retry with exponential backoff (max 3 attempts)</td>\n</tr>\n<tr>\n<td><code>introspecting_tables</code></td>\n<td>Permission denied on information_schema</td>\n<td><code>partial</code></td>\n<td>Continue with accessible tables only, log warning</td>\n</tr>\n<tr>\n<td><code>detecting_relationships</code></td>\n<td>Circular reference detected</td>\n<td><code>ready</code></td>\n<td>Mark relationship as circular, generate appropriate GraphQL types</td>\n</tr>\n<tr>\n<td><code>building_types</code></td>\n<td>Type mapping failure</td>\n<td><code>error</code></td>\n<td>Fall back to <code>String</code> type for problematic column, continue</td>\n</tr>\n</tbody></table>\n<h4 id=\"error-response-format\">Error Response Format</h4>\n<p>All errors eventually serialize to the standard GraphQL error response format:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"data\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"user\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"posts\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#FDAEB7;font-style:italic\">...</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"errors\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"message\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Cannot return null for non-nullable field User.email\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"path\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"email\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"locations\"</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#79B8FF\">\"line\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"column\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">}],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"extensions\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"code\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"NON_NULL_VIOLATION\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2023-10-01T12:34:56Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The <code>extensions</code> field is where implementation-specific details can be added (error codes, timestamps, debug IDs for correlating with server logs).</p>\n<h3 id=\"null-and-optional-value-handling\">Null and Optional Value Handling</h3>\n<p>Null handling in GraphQL is <strong>propagative rather than terminating</strong>—a null value can &quot;bubble up&quot; through the response tree according to specific rules. This behavior fundamentally differs from most programming languages and requires careful implementation.</p>\n<p><strong>Mental Model: The Domino Chain</strong>\nImagine a chain of dominoes where each domino represents a field in your GraphQL response. Non-null fields (<code>Type!</code>) are dominoes glued to their neighbors—if one falls (becomes null), it forces the next one to fall too. Nullable fields (<code>Type</code>) are unglued dominoes—they can fall independently without affecting others. List fields (<code>[Type]</code>) are racks holding multiple domino chains—one chain can fail without toppling the entire rack.</p>\n<h4 id=\"null-propagation-rules\">Null Propagation Rules</h4>\n<table>\n<thead>\n<tr>\n<th>Type Wrapper</th>\n<th>Null Source</th>\n<th>Propagation Behavior</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Nullable field</strong> (<code>User</code>)</td>\n<td>Field resolver returns <code>None</code></td>\n<td>Field becomes <code>null</code> in response, siblings execute normally</td>\n<td><code>{ user(id: 999) { name } }</code> → <code>{&quot;data&quot;: {&quot;user&quot;: null}}</code></td>\n</tr>\n<tr>\n<td><strong>Non-null field</strong> (<code>User!</code>)</td>\n<td>Field resolver returns <code>None</code></td>\n<td>Parent field becomes <code>null</code> (if nullable), continues upward</td>\n<td><code>{ user: user(id: 999) { name } }</code> → <code>{&quot;data&quot;: {&quot;user&quot;: null}}</code></td>\n</tr>\n<tr>\n<td><strong>List of nullable</strong> (<code>[User]</code>)</td>\n<td>One element resolves to <code>None</code></td>\n<td><code>null</code> appears in list at that position</td>\n<td><code>{ users: [{name: &quot;A&quot;}, null, {name: &quot;C&quot;}] }</code></td>\n</tr>\n<tr>\n<td><strong>List of non-null</strong> (<code>[User!]</code>)</td>\n<td>One element resolves to <code>None</code></td>\n<td>Entire list becomes <code>null</code></td>\n<td><code>{ users: null }</code> (if any user is null)</td>\n</tr>\n<tr>\n<td><strong>List of non-null in non-null</strong> (<code>[User!]!</code>)</td>\n<td>One element resolves to <code>None</code></td>\n<td>Parent field becomes <code>null</code></td>\n<td><code>{ users: null }</code> (bubbles up)</td>\n</tr>\n</tbody></table>\n<p>The implementation must track <strong>null propagation chains</strong> during execution. When a resolver returns <code>None</code>, check its return type:</p>\n<ul>\n<li>If <code>NonNullType</code>: find the nearest nullable parent by walking up the type tree</li>\n<li>If nullable: stop propagation, set value to <code>null</code></li>\n<li>If inside a <code>ListType</code>: check if list elements are non-null</li>\n</ul>\n<h4 id=\"database-null-to-graphql-null-mapping\">Database NULL to GraphQL Null Mapping</h4>\n<p>Database NULL values present special challenges because different database types have different semantics for NULL:</p>\n<table>\n<thead>\n<tr>\n<th>Database NULL Context</th>\n<th>GraphQL Representation</th>\n<th>Default Behavior</th>\n<th>Override Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Nullable column with NULL</strong></td>\n<td>Field returns <code>null</code></td>\n<td>Direct mapping</td>\n<td>Custom scalar with different null handling</td>\n</tr>\n<tr>\n<td><strong>Non-nullable column</strong> (NOT NULL constraint)</td>\n<td>Field is non-null (<code>Type!</code>)</td>\n<td>Schema generation marks as non-null</td>\n<td>Can be overridden in reflection options</td>\n</tr>\n<tr>\n<td><strong>LEFT JOIN missing row</strong></td>\n<td>Nested object field returns <code>null</code></td>\n<td>Entire related object is <code>null</code></td>\n<td>Configuration to return empty object</td>\n</tr>\n<tr>\n<td><strong>Aggregate function on empty set</strong></td>\n<td><code>COUNT</code> returns 0, <code>AVG</code> returns <code>null</code></td>\n<td>Follow SQL semantics</td>\n<td>Custom resolvers to normalize</td>\n</tr>\n</tbody></table>\n<p>The reflection component (Milestone 4) must read <code>ColumnMetadata.is_nullable</code> to determine whether to generate nullable (<code>String</code>) or non-null (<code>String!</code>) GraphQL fields. However, there&#39;s a subtlety: a database column might be technically nullable but semantically required (like a <code>deleted_at</code> timestamp that&#39;s NULL for active records). The <code>ReflectionOptions</code> should allow overriding nullability decisions.</p>\n<h4 id=\"optional-arguments-and-default-values\">Optional Arguments and Default Values</h4>\n<p>GraphQL arguments can be optional with default values, which creates three possible states for each argument:</p>\n<table>\n<thead>\n<tr>\n<th>Argument State</th>\n<th>GraphQL Syntax</th>\n<th>Internal Representation</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Provided with value</strong></td>\n<td><code>user(id: 5)</code></td>\n<td><code>Argument.value = IntValue(5)</code></td>\n<td>Use provided value</td>\n</tr>\n<tr>\n<td><strong>Provided with null</strong></td>\n<td><code>user(id: null)</code></td>\n<td><code>Argument.value = NullValue()</code></td>\n<td>Use explicit null (overrides default)</td>\n</tr>\n<tr>\n<td><strong>Not provided</strong></td>\n<td><code>user</code></td>\n<td>No argument in argument list</td>\n<td>Use default value from schema</td>\n</tr>\n</tbody></table>\n<p>The execution engine must distinguish between &quot;argument not provided&quot; and &quot;argument provided as null&quot; because they have different semantics. During argument coercion:</p>\n<ol>\n<li>Check if argument exists in the query&#39;s <code>arguments</code> list</li>\n<li>If missing: use <code>GraphQLArgument.default_value</code> from schema</li>\n<li>If present: coerce the provided value to expected type</li>\n<li>If value is <code>NullValue()</code>: pass <code>None</code> to resolver (even if default exists)</li>\n</ol>\n<p>This behavior is critical for mutations where <code>null</code> might mean &quot;clear this field&quot; while absence means &quot;don&#39;t change this field.&quot;</p>\n<h3 id=\"edge-case-scenarios\">Edge Case Scenarios</h3>\n<p>Edge cases test the robustness of the GraphQL engine and often reveal bugs in less-traveled code paths. These scenarios require special handling beyond the normal execution flow.</p>\n<h4 id=\"empty-selections-and-minimal-queries\">Empty Selections and Minimal Queries</h4>\n<p>An empty selection set might seem pointless, but it&#39;s valid GraphQL and must be handled gracefully. This often occurs in automated query generation or as a placeholder.</p>\n<p><strong>Empty selection handling algorithm:</strong></p>\n<ol>\n<li>During query validation: empty selection sets are allowed on object types (returns empty object)</li>\n<li>During execution: when encountering an empty selection set:<ul>\n<li>Return empty dictionary <code>{}</code> for the field</li>\n<li>Still execute field-level directives if present</li>\n<li>Still validate field arguments</li>\n</ul>\n</li>\n<li>For interfaces/unions: empty selection sets are invalid unless <code>__typename</code> is implicitly added</li>\n</ol>\n<p>The minimal valid query <code>{ __typename }</code> (just the meta-field) should execute successfully and return <code>{&quot;data&quot;: {&quot;__typename&quot;: &quot;Query&quot;}}</code>.</p>\n<h4 id=\"circular-references\">Circular References</h4>\n<p>Circular references occur in two domains: GraphQL type definitions and database foreign key relationships. Each requires different handling strategies.</p>\n<p><strong>GraphQL type circularity:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">graphql</span><pre class=\"arch-pre shiki-highlighted\"><code>type User {\n  friends: [User!]!\n}\n\ntype Query {\n  user: User!\n}</code></pre></div>\n<p>This is valid and requires the type system to handle recursive type references during:</p>\n<ul>\n<li>Schema validation: must allow recursive types but detect infinite loops in input types</li>\n<li>Query execution: must have depth limits to prevent infinite recursion</li>\n<li>Introspection: must not get stuck in infinite loops when generating type descriptions</li>\n</ul>\n<p><strong>Database relationship circularity:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- Employee table with manager hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> employees</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  id </span><span style=\"color:#F97583\">INT</span><span style=\"color:#F97583\"> PRIMARY KEY</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  name</span><span style=\"color:#F97583\"> VARCHAR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  manager_id </span><span style=\"color:#F97583\">INT</span><span style=\"color:#F97583\"> REFERENCES</span><span style=\"color:#E1E4E8\"> employees(id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>The reflection component must detect self-referential foreign keys and generate appropriate GraphQL types without infinite recursion. The generated schema should include:</p>\n<ul>\n<li><code>Employee</code> type with <code>manager: Employee</code> field (nullable)</li>\n<li>Query field with argument to control traversal depth</li>\n<li>Automatic depth limiting in generated resolvers</li>\n</ul>\n<p><strong>Circular reference detection algorithm (reflection):</strong></p>\n<ol>\n<li>Build directed graph of table relationships from foreign keys</li>\n<li>Run cycle detection (DFS with back edges)</li>\n<li>For each cycle found:<ul>\n<li>Mark relationships in cycle with <code>is_self_referential = True</code></li>\n<li>Generate GraphQL types with nullable back-references to break infinite traversal</li>\n<li>Add <code>max_depth</code> argument to collection fields with default limit (e.g., 10)</li>\n</ul>\n</li>\n<li>During SQL compilation: apply <code>JOIN</code> limits based on query arguments</li>\n</ol>\n<h4 id=\"deeply-nested-queries\">Deeply Nested Queries</h4>\n<p>Deeply nested queries can cause performance problems (exponential JOIN explosion) and even stack overflows in recursive execution. The engine must implement <strong>reasonable limits</strong>.</p>\n<table>\n<thead>\n<tr>\n<th>Limit Type</th>\n<th>Default Value</th>\n<th>Configuration</th>\n<th>Enforcement Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Query Depth</strong></td>\n<td>20 levels</td>\n<td><code>max_query_depth</code> in execution context</td>\n<td>Query validation phase</td>\n</tr>\n<tr>\n<td><strong>Selection Width</strong></td>\n<td>50 fields per level</td>\n<td><code>max_fields_per_level</code></td>\n<td>Execution planning</td>\n</tr>\n<tr>\n<td><strong>List Size</strong></td>\n<td>1000 items</td>\n<td><code>max_list_size</code> in DataLoader</td>\n<td>SQL LIMIT clause</td>\n</tr>\n<tr>\n<td><strong>JOIN Count</strong></td>\n<td>15 tables</td>\n<td><code>max_joins</code> in SQL compiler</td>\n<td>JOIN planning</td>\n</tr>\n</tbody></table>\n<p>When limits are exceeded:</p>\n<ol>\n<li>During validation: reject query with clear error &quot;Query too deep (max 20 levels)&quot;</li>\n<li>During execution: truncate results (e.g., only return first 1000 list items)</li>\n<li>During SQL compilation: fail with suggestion to add more filters</li>\n</ol>\n<p>The limits should be configurable per-request via <code>ExecutionContext</code> for different use cases (internal API vs. public API).</p>\n<h4 id=\"large-results-and-pagination-edge-cases\">Large Results and Pagination Edge Cases</h4>\n<p>GraphQL doesn&#39;t have built-in pagination, but our auto-generated schemas include pagination arguments (<code>first</code>, <code>after</code>, <code>last</code>, <code>before</code>). These create several edge cases:</p>\n<table>\n<thead>\n<tr>\n<th>Pagination Edge Case</th>\n<th>Behavior</th>\n<th>Implementation Consideration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Negative <code>first</code>/<code>last</code></strong></td>\n<td>Validation error</td>\n<td>Must validate arguments before SQL generation</td>\n</tr>\n<tr>\n<td><strong>Both <code>first</code> and <code>last</code></strong></td>\n<td>Use <code>first</code> (GraphQL best practice)</td>\n<td>Document precedence in generated schema comments</td>\n</tr>\n<tr>\n<td><strong><code>after</code> cursor for deleted item</strong></td>\n<td>Start from next available item</td>\n<td>Cursors must be resilient to data deletion</td>\n</tr>\n<tr>\n<td><strong>Empty cursor string</strong></td>\n<td>Treat as &quot;start from beginning&quot;</td>\n<td>Validate cursor format before decoding</td>\n</tr>\n<tr>\n<td><strong><code>before</code> without <code>last</code></strong></td>\n<td>Ignore <code>before</code> or error</td>\n<td>Consistent policy needed</td>\n</tr>\n</tbody></table>\n<p>Cursor-based pagination implementation must handle:</p>\n<ul>\n<li><strong>Cursor encoding/decoding</strong>: Base64-encoded JSON with table name, primary key values, sort values</li>\n<li><strong>Cursor validation</strong>: Ensure cursor is for the correct table and query</li>\n<li><strong>Cursor stability</strong>: Cursors must remain valid across data updates (use immutable columns or timestamps)</li>\n</ul>\n<h4 id=\"type-system-edge-cases\">Type System Edge Cases</h4>\n<p>The GraphQL type system has subtle edge cases that trip up implementations:</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>GraphQL Spec Rule</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Interface field nullability</strong></td>\n<td>Implementing field can be more strict (non-null) but not more loose</td>\n<td>Validation must check interface implementation contravariantly</td>\n</tr>\n<tr>\n<td><strong>Union with overlapping types</strong></td>\n<td>Types in union must be distinct object types</td>\n<td>Schema validation ensures no type appears twice</td>\n</tr>\n<tr>\n<td><strong>Empty enum values</strong></td>\n<td>Enum must have at least one value</td>\n<td>Schema validation rejects empty enums</td>\n</tr>\n<tr>\n<td><strong>Input object default values</strong></td>\n<td>Default values must be coercible to field type</td>\n<td>Validate defaults during schema building</td>\n</tr>\n<tr>\n<td><strong>List of lists</strong> (<code>[[Int]]</code>)</td>\n<td>Valid type, must handle nested list coercion</td>\n<td>Recursive type handling in execution</td>\n</tr>\n</tbody></table>\n<p><strong>Interface implementation validation algorithm:</strong></p>\n<ol>\n<li>For each interface field, find corresponding object field</li>\n<li>Check field type compatibility:<ul>\n<li>If interface field is nullable (<code>T</code>), object field can be <code>T</code> or <code>T!</code></li>\n<li>If interface field is non-null (<code>T!</code>), object field must be <code>T!</code></li>\n<li>Covariant for object types: <code>Dog</code> can implement <code>Pet</code> if <code>Dog</code> is subtype</li>\n</ul>\n</li>\n<li>Check argument compatibility (contravariant):<ul>\n<li>Object field can omit optional interface arguments</li>\n<li>Object field arguments must have compatible types (more general)</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"sql-compilation-edge-cases\">SQL Compilation Edge Cases</h4>\n<p>The GraphQL-to-SQL compiler faces unique edge cases when bridging the hierarchical and relational models:</p>\n<table>\n<thead>\n<tr>\n<th>Compilation Edge Case</th>\n<th>Problem</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Cartesian product from multiple one-to-many</strong></td>\n<td><code>{ users { posts tags } }</code> creates <code>users × posts × tags</code></td>\n<td>Use <code>LATERAL JOIN</code> or separate queries with batching</td>\n</tr>\n<tr>\n<td><strong>Diamond relationships</strong></td>\n<td><code>{ user { posts author } }</code> where <code>posts.author</code> is same as <code>user</code></td>\n<td>Deduplicate JOINs, use table aliases</td>\n</tr>\n<tr>\n<td><strong>Polymorphic relationships</strong></td>\n<td>Interface/union types with different backing tables</td>\n<td>Generate <code>CASE</code> statements or multiple queries</td>\n</tr>\n<tr>\n<td><strong>Missing JOIN condition</strong></td>\n<td>Relationship exists in GraphQL schema but not in database (view)</td>\n<td>Fall back to separate query or error</td>\n</tr>\n<tr>\n<td><strong>SQL dialect differences</strong></td>\n<td><code>LIMIT/OFFSET</code> vs <code>FETCH NEXT</code> vs <code>TOP</code></td>\n<td>Abstract behind <code>SQLDialect</code> enum</td>\n</tr>\n</tbody></table>\n<p><strong>Diamond relationship handling algorithm:</strong></p>\n<ol>\n<li>Detect when same table appears multiple times in join tree</li>\n<li>Generate unique table aliases (<code>posts</code>, <code>posts_2</code>)</li>\n<li>Ensure JOIN conditions use correct aliases</li>\n<li>In result mapper: map aliased columns back to correct object paths</li>\n</ol>\n<p><strong>Polymorphic relationship compilation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">graphql</span><pre class=\"arch-pre shiki-highlighted\"><code>query {\n  search(query: &quot;graphql&quot;) {\n    ... on Book { title author }\n    ... on Article { title url }\n  }\n}</code></pre></div>\n<p>Compiles to:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#9ECBFF\"> 'Book'</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#E1E4E8\"> __typename, title, author </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> books </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> title </span><span style=\"color:#F97583\">LIKE</span><span style=\"color:#E1E4E8\"> ?)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">UNION ALL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#9ECBFF\"> 'Article'</span><span style=\"color:#F97583\"> AS</span><span style=\"color:#E1E4E8\"> __typename, title, </span><span style=\"color:#F97583\">url</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> articles </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> title </span><span style=\"color:#F97583\">LIKE</span><span style=\"color:#E1E4E8\"> ?)</span></span></code></pre></div>\n<p>With the result mapper using <code>__typename</code> to route to correct GraphQL types.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Error Tracking</strong></td>\n<td>List of error dictionaries in execution context</td>\n<td>Structured error tree with severity levels</td>\n</tr>\n<tr>\n<td><strong>Null Propagation</strong></td>\n<td>Simple recursion with type checking</td>\n<td>Memoization of nullability decisions</td>\n</tr>\n<tr>\n<td><strong>Database Error Parsing</strong></td>\n<td>String matching on error messages</td>\n<td>Database-specific error code mapping</td>\n</tr>\n<tr>\n<td><strong>Query Limits</strong></td>\n<td>Hard-coded constants</td>\n<td>Dynamic limits based on query complexity scoring</td>\n</tr>\n<tr>\n<td><strong>Cursor Pagination</strong></td>\n<td>Offset-based pagination (simple)</td>\n<td>Cursor-based with Base64 encoding (spec-compliant)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql-engine/\n  errors/\n    __init__.py              # Error base classes and utilities\n    parse_errors.py          # Parse error definitions (Milestone 1)\n    validation_errors.py     # Validation error definitions (Milestone 2)\n    execution_errors.py      # Execution error definitions (Milestone 3)\n    database_errors.py       # Database error handling (Milestones 4-5)\n    null_handling.py         # Null propagation logic (Milestone 3)\n    limits.py                # Query depth/width/size limits\n  execution/\n    context.py               # ExecutionContext with errors list\n    executor.py              # Error-aware executor</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete Error Base Class:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors/__init__.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Location, PathSegment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all GraphQL errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    locations: List[Location] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path: List[PathSegment] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_error: Optional[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    extensions: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert error to GraphQL response format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"message\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.message,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"locations\"</span><span style=\"color:#E1E4E8\">: [{</span><span style=\"color:#9ECBFF\">\"line\"</span><span style=\"color:#E1E4E8\">: loc.line, </span><span style=\"color:#9ECBFF\">\"column\"</span><span style=\"color:#E1E4E8\">: loc.column} </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         for</span><span style=\"color:#E1E4E8\"> loc </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.locations],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.path:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"path\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.extensions:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"extensions\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.extensions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLSyntaxError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Syntax error during parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validation error against schema.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLExecutionError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error during query execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLNonNullError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLExecutionError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Special error for non-null field violations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, field_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, path: List[PathSegment]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot return null for non-nullable field </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">field_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            path</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">path,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            extensions</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"code\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"NON_NULL_VIOLATION\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span></code></pre></div>\n\n<p><strong>Complete Null Propagation Helper:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors/null_handling.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLType, NonNullType, ListType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> should_propagate_null</span><span style=\"color:#E1E4E8\">(value: Any, field_type: GraphQLType) -> Tuple[</span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">, Optional[GraphQLType]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Determine if null should propagate upward.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns (should_propagate, nullable_parent_type).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check type wrapper chain</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field_type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Unwrap type modifiers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(current_type, (NonNullType, ListType)):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        type_stack.append(current_type)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(current_type, NonNullType):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Found non-null wrapper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # If this is the outermost non-null, propagate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> type_stack </span><span style=\"color:#F97583\">or</span><span style=\"color:#79B8FF\"> all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(t, NonNullType) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> type_stack[:</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_type.of_type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_null_propagation</span><span style=\"color:#E1E4E8\">(result: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], error: GraphQLError) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Apply null propagation rules to result dictionary.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> error.path:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Navigate to the error location in the result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, segment </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(error.path[:</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(segment, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current.get(segment, {})</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(segment, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(current, </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> segment </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(current):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current[segment]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Set the field to None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_segment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error.path[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(last_segment, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current[last_segment] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(last_segment, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(current, </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> last_segment </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(current):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current[last_segment] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Parse Error Collection:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># parser/parser.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokens</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors: List[GraphQLSyntaxError] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_document</span><span style=\"color:#E1E4E8\">(self) -> Document:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse complete GraphQL document with error collection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize definitions list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: While not at EOF, parse definition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If parse_definition returns None due to error, </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         skip to next definition using error recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Implement error recovery: skip tokens until safe point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         (next '{', '}', or top-level keyword)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: After parsing, if errors list not empty, raise first error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         or collect all for validation phase</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> expect</span><span style=\"color:#E1E4E8\">(self, token_type: TokenType, value: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Expect specific token, record error if not found.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if current token matches expected type/value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If match, consume token and return it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If no match, create GraphQLSyntaxError with:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Current token's location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Message: f\"Expected {token_type}, found {actual_token.value}\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Add to self.errors list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Implement error recovery: return synthetic token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Execution Error Handling:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># execution/executor.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Executor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_field</span><span style=\"color:#E1E4E8\">(self, parent_type: GraphQLType, field: Field, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     parent_value: Any, path: List[PathSegment]) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute single field with error handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get field definition from schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Coerce arguments with try/except for coercion errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Get resolver function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Try to execute resolver with try/except</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If resolver raises exception:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Catch it and create GraphQLExecutionError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Add error to context.errors list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Check if field type is non-null using should_propagate_null</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - If non-null, return None to trigger propagation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - If nullable, return None (field is null, error recorded)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If resolver returns value, validate it matches field type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return resolved value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Database Error Sanitization:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors/database_errors.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> sanitize_database_error</span><span style=\"color:#E1E4E8\">(error: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">, sql: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> GraphQLError:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert database exception to safe GraphQL error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check error type (psycopg2.Error, sqlite3.Error, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract error message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Categorize based on patterns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #         - \"duplicate key\" -> constraint violation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #         - \"foreign key\" -> relationship error  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #         - \"syntax error\" -> SQL compilation error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #         - \"connection\" -> database unavailable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create sanitized message per category</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Include safe details in extensions (not in message)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return GraphQLExecutionError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"e-python-specific-hints\">E. Python-Specific Hints</h4>\n<ol>\n<li><strong>Use context managers for database connections</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> database_connection</span><span style=\"color:#E1E4E8\">(config):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        conn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_connection(config)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        yield</span><span style=\"color:#E1E4E8\"> conn</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> DatabaseError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> sanitize_database_error(e)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> conn:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            conn.close()</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Leverage Python&#39;s exception chaining</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resolver(parent, args, context)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    raise</span><span style=\"color:#E1E4E8\"> GraphQLExecutionError(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Resolver failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        original_error</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">e  </span><span style=\"color:#6A737D\"># Preserve original for logging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) </span><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> e</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Use <code>functools.lru_cache</code> for nullability checking</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> functools </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lru_cache</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@lru_cache</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxsize</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_non_null_type</span><span style=\"color:#E1E4E8\">(graphql_type: GraphQLType) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Memoized check for non-null types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(graphql_type, NonNullType):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(graphql_type, ListType):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> is_non_null_type(graphql_type.of_type)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing error handling, verify with these test queries:</p>\n<ol>\n<li><strong>Parse error checkpoint</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_parser.py::test_syntax_errors</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   Expected: All 10 syntax error test cases pass with precise location information.</p>\n<ol start=\"2\">\n<li><strong>Null propagation checkpoint</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   from engine import execute_query, create_schema</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   schema = create_schema(...)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   result = execute_query(schema, '{ user(id: 999) { name email } }')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   print('Has errors:', bool(result.get('errors')))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   print('User is null:', result.get('data', {}).get('user') is None)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   \"</span></span></code></pre></div>\n<p>   Expected: When user 999 doesn&#39;t exist, <code>data.user</code> is <code>null</code> (not missing), and errors list contains appropriate error.</p>\n<ol start=\"3\">\n<li><strong>Database error checkpoint</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   from engine import reflect_schema</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   # Use invalid connection string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   try:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       schema = reflect_schema('postgresql://invalid:invalid@localhost:9999/db')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   except Exception as e:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       print('Error type:', type(e).__name__)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       print('Message contains password?', 'invalid' in str(e))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   \"</span></span></code></pre></div>\n<p>   Expected: Error is raised, but error message doesn&#39;t contain password.</p>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Query returns <code>{&quot;data&quot;: null}</code> with no errors</strong></td>\n<td>Non-null field at root resolved to null</td>\n<td>Check execution logs for which resolver returned null</td>\n<td>Make resolver return value or change field to nullable</td>\n</tr>\n<tr>\n<td><strong>Error missing location information</strong></td>\n<td>Location not passed when creating error</td>\n<td>Add <code>locations=[field.loc]</code> to error creation</td>\n<td>Ensure AST nodes have location data</td>\n</tr>\n<tr>\n<td><strong>Multiple identical errors</strong></td>\n<td>Error propagating through list fields</td>\n<td>Check if error is being added for each list element</td>\n<td>Add error once at list level, not per element</td>\n</tr>\n<tr>\n<td><strong>Database error exposes table names</strong></td>\n<td>Insufficient error sanitization</td>\n<td>Test with malformed query that causes SQL error</td>\n<td>Implement error categorization in <code>sanitize_database_error</code></td>\n</tr>\n<tr>\n<td><strong>Deep recursion crashes</strong></td>\n<td>No query depth limiting</td>\n<td>Add depth counter to execution context</td>\n<td>Implement <code>max_depth</code> validation</td>\n</tr>\n<tr>\n<td><strong>Cartesian product in results</strong></td>\n<td>Missing JOIN conditions in SQL compilation</td>\n<td>Log generated SQL and examine JOIN clauses</td>\n<td>Ensure every JOIN has ON condition</td>\n</tr>\n</tbody></table>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section spans all five milestones, providing practical troubleshooting guidance for the most common issues learners encounter while building their GraphQL execution engine. Effective debugging requires understanding how errors manifest across the entire pipeline from query parsing to SQL execution.</p>\n</blockquote>\n<p>Debugging a GraphQL engine involves tracing data through multiple transformation layers. When a query fails or returns unexpected results, the issue could originate in any component: a malformed AST from the parser, an inconsistent type definition, a resolver returning incorrect data, a mis-mapped database column, or an inefficient SQL query. This guide provides systematic approaches to isolate and fix the most common problems.</p>\n<h3 id=\"common-bugs-table\">Common Bugs Table</h3>\n<p>When building a GraphQL engine, certain patterns of mistakes appear repeatedly across implementations. The following table categorizes symptoms by component, helping you quickly identify where to look based on what you&#39;re observing.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Parser throws &quot;Unexpected token&quot; error on valid GraphQL</strong></td>\n<td>Tokenizer failing to recognize block strings, escaped strings, or unicode characters</td>\n<td>1. Check tokenizer output for the query fragment around the error location<br>2. Verify string literal handling for escape sequences (<code>\\n</code>, <code>\\u0041</code>)<br>3. Test with simplified query removing complex string values</td>\n<td>Implement proper string tokenization with full escape sequence support per GraphQL spec section 2.9</td>\n</tr>\n<tr>\n<td><strong>Query returns <code>null</code> for fields that should have data</strong></td>\n<td>1. Missing or misconfigured resolver function<br>2. Null propagation from non-null field error<br>3. Database column mismatch in SQL compilation</td>\n<td>1. Check execution logs for resolver calls<br>2. Examine error list in <code>ExecutionResult</code> for hidden null propagation errors<br>3. Verify SQL query actually returns data for the field</td>\n<td>1. Ensure resolvers are registered for all fields<br>2. Check non-null field resolvers don&#39;t return <code>None</code><br>3. Verify column aliases in SQL match field names in result mapper</td>\n</tr>\n<tr>\n<td><strong>Nested relationship fields cause N+1 database queries</strong></td>\n<td>SQL compiler generating separate queries per parent instead of JOINs</td>\n<td>1. Enable SQL logging and count queries for nested data<br>2. Check if <code>compile_to_sql</code> produces a single query with JOINs<br>3. Verify relationship detection found foreign keys</td>\n<td>1. Implement proper join planning in <code>plan_joins</code><br>2. Use <code>LATERAL JOIN</code> or batched IN queries for one-to-many relationships<br>3. Ensure <code>RelationshipAnalyzer</code> detects all foreign key constraints</td>\n</tr>\n<tr>\n<td><strong>Introspection query fails or returns incomplete schema</strong></td>\n<td>Missing or incorrect implementation of <code>__schema</code>, <code>__type</code> meta-fields</td>\n<td>1. Test introspection query against a known working GraphQL server<br>2. Verify <code>Schema</code> type includes introspection types in <code>types</code> dictionary<br>3. Check that meta-field resolvers return properly formatted data</td>\n<td>1. Implement <code>__Schema</code>, <code>__Type</code>, <code>__Field</code>, <code>__InputValue</code> types per GraphQL spec<br>2. Ensure introspection types are added to schema during <code>create_schema</code><br>3. Verify meta-field resolvers handle all type kinds correctly</td>\n</tr>\n<tr>\n<td><strong>Mutation with variables receives &quot;Variable &#39;$var&#39; is not defined&quot;</strong></td>\n<td>Parser not extracting variable definitions from operation header</td>\n<td>1. Inspect <code>OperationDefinition.variable_definitions</code> in parsed AST<br>2. Check variable definitions are being passed to execution context<br>3. Verify variable names match between definition and usage</td>\n<td>1. Ensure <code>parse_operation_definition</code> extracts <code>VariableDefinition</code> nodes<br>2. Pass <code>variable_values</code> from request to <code>execute_query</code><br>3. Validate variable usage against definitions before execution</td>\n</tr>\n<tr>\n<td><strong>Database reflection creates types with wrong scalar mappings</strong></td>\n<td><code>TypeMapper.map_column_type</code> using incorrect type mappings for database dialect</td>\n<td>1. Check raw <code>ColumnMetadata.data_type</code> from database introspection<br>2. Verify <code>POSTGRES_MAPPINGS</code> (or dialect equivalent) contains the type<br>3. Test with explicit type mappings in <code>ReflectionOptions</code></td>\n<td>1. Add missing type mappings to <code>TypeMapper</code><br>2. Handle database-specific types (PostgreSQL <code>jsonb</code>, MySQL <code>TINYINT</code>)<br>3. Implement custom mapping registration for user-defined types</td>\n</tr>\n<tr>\n<td><strong>Fragment spreads cause &quot;Unknown fragment&quot; error</strong></td>\n<td>Fragment definitions not being collected into <code>fragments</code> dictionary</td>\n<td>1. Check <code>Document.definitions</code> includes <code>FragmentDefinition</code> nodes<br>2. Verify fragment dictionary passed to <code>ExecutionContext</code><br>3. Test with inline fragment (should work if named fragments fail)</td>\n<td>1. Ensure <code>parse_document</code> collects fragments into separate dictionary<br>2. Pass fragments to execution context: <code>ExecutionContext.fragments</code><br>3. Validate fragment spreads reference defined fragments before execution</td>\n</tr>\n<tr>\n<td><strong>Query with nested lists returns incorrect nesting structure</strong></td>\n<td>Result mapper flattening nested structures incorrectly</td>\n<td>1. Examine raw SQL result rows vs expected GraphQL response shape<br>2. Check <code>result_mapper</code> in <code>SQLQuery</code> properly reconstructs hierarchy<br>3. Verify join aliases preserve parent-child relationships</td>\n<td>1. Implement result mapper that uses join aliases to reconstruct tree<br>2. Test with simple one-to-many relationship first<br>3. Use temporary table aliases that encode the selection path</td>\n</tr>\n<tr>\n<td><strong>Directives are ignored during execution</strong></td>\n<td>Directive parsing working but not applied during field resolution</td>\n<td>1. Check <code>Directive</code> nodes appear in AST for fields/fragments<br>2. Verify directive information reaches resolver via <code>ExecutionContext</code><br>3. Test with <code>@skip</code> or <code>@include</code> directives first</td>\n<td>1. Implement directive evaluation before field resolution<br>2. Apply <code>@skip</code>/<code>@include</code> during selection set reduction<br>3. Pass directive arguments to resolver functions when needed</td>\n</tr>\n<tr>\n<td><strong>Non-null field error causes entire query to return <code>null</code></strong></td>\n<td>Incorrect null propagation - null bubbling too far up</td>\n<td>1. Check if error is in <code>ExecutionResult.errors</code> with path<br>2. Verify <code>should_propagate_null</code> correctly checks field type nullability<br>3. Test with nullable parent field (should return partial data)</td>\n<td>1. Implement null propagation per GraphQL spec: only bubble to nearest nullable parent<br>2. Use <code>apply_null_propagation</code> to set nulls in result selectively<br>3. Ensure non-null errors are recorded but don&#39;t abort entire execution</td>\n</tr>\n<tr>\n<td><strong>SQL query vulnerable to injection via GraphQL arguments</strong></td>\n<td>Compiler using string concatenation instead of parameter binding</td>\n<td>1. Check generated SQL for raw values in WHERE clause instead of <code>$1</code>, <code>?</code><br>2. Verify <code>SQLParameter</code> list is populated with argument values<br>3. Test with malicious string argument containing SQL metacharacters</td>\n<td>1. Use <code>SQLBuilder</code> with parameter placeholders for all user input<br>2. Ensure <code>compile_to_sql</code> returns both SQL string and parameters dictionary<br>3. Pass parameters separately to database driver&#39;s execute method</td>\n</tr>\n<tr>\n<td><strong>Self-referential relationship causes infinite recursion</strong></td>\n<td>Relationship detection creating circular reference without depth limit</td>\n<td>1. Check <code>Relationship.is_self_referential</code> flag<br>2. Verify recursion depth limited in relationship traversal<br>3. Test with employee → manager → employee hierarchy</td>\n<td>1. Implement cycle detection in <code>RelationshipAnalyzer</code><br>2. Add <code>max_relationship_depth</code> to <code>ReflectionOptions</code><br>3. Use iterative rather than recursive traversal for relationship chains</td>\n</tr>\n<tr>\n<td><strong>Interface/union types return &quot;Abstract type must resolve to Object type&quot;</strong></td>\n<td>Missing or incorrect <code>resolve_type</code> function</td>\n<td>1. Check <code>InterfaceType.resolve_type</code> or <code>UnionType.resolve_type</code> is set<br>2. Verify resolver returns actual <code>ObjectType</code> not type name string<br>3. Test with concrete type query first, then through interface</td>\n<td>1. Implement <code>resolve_type</code> that examines value and returns appropriate ObjectType<br>2. Ensure interface implementations properly registered in schema<br>3. Use <code>__typename</code> field in query to debug runtime type resolution</td>\n</tr>\n<tr>\n<td><strong>Pagination with cursors returns inconsistent results when data changes</strong></td>\n<td>Using OFFSET/LIMIT instead of cursor-based pagination</td>\n<td>1. Check generated SQL for <code>OFFSET</code> clause<br>2. Verify cursor decoding/encoding uses stable row identifiers<br>3. Test with data insertion during pagination</td>\n<td>1. Implement cursor pagination with unique, stable sort keys<br>2. Use <code>ORDER BY</code> with unique columns and WHERE clause for cursors<br>3. Encode cursor as base64 of sort column values</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-techniques\">Debugging Techniques</h3>\n<p>Effective debugging requires more than just reading error messages—it involves instrumenting the system to observe internal state transitions. These techniques help you visualize what&#39;s happening at each stage of the GraphQL execution pipeline.</p>\n<h4 id=\"ast-visualization\">AST Visualization</h4>\n<blockquote>\n<p><strong>Mental Model:</strong> <strong>Family Tree Diagram</strong> - Think of the AST as a family tree where the query document is the ancestor, operations are the main branches, selection sets are sub-branches, and individual fields are leaves. Visualizing this tree helps you verify the parser correctly understood the query structure.</p>\n</blockquote>\n<p>When the parser seems to be misinterpreting a query, the first step is to examine the AST it produced. A well-structured visualization reveals whether:</p>\n<ul>\n<li>Selection sets are properly nested</li>\n<li>Fragments are expanded correctly</li>\n<li>Directives are attached to the right nodes</li>\n<li>Variable definitions are captured</li>\n</ul>\n<p><strong>Diagnostic Approach:</strong></p>\n<ol>\n<li><strong>Print AST with Indentation:</strong> Create a recursive function that prints each node type with increasing indentation for depth</li>\n<li><strong>Highlight Key Attributes:</strong> For each <code>Field</code> node, display <code>name</code>, <code>alias</code>, and argument count</li>\n<li><strong>Track Locations:</strong> Include <code>Location.line</code> and <code>Location.column</code> to correlate nodes with source text</li>\n<li><strong>Compare with Reference:</strong> Use a known working GraphQL implementation (like GraphQL.js) to parse the same query and compare structures</li>\n</ol>\n<p><strong>What to Look For:</strong></p>\n<ul>\n<li>Are all expected fields present in the selection set?</li>\n<li>Do fragment spreads point to existing fragment definitions?</li>\n<li>Are argument values of the correct type (e.g., <code>IntValue</code> vs <code>StringValue</code>)?</li>\n<li>Do directives appear on the expected nodes with proper arguments?</li>\n</ul>\n<h4 id=\"sql-logging\">SQL Logging</h4>\n<blockquote>\n<p><strong>Mental Model:</strong> <strong>Kitchen Ticket System</strong> - Imagine each GraphQL query generates a &quot;ticket&quot; that gets translated into cooking instructions (SQL). Logging the SQL shows you exactly what &quot;cooking instructions&quot; the kitchen is following, revealing whether the translation was correct.</p>\n</blockquote>\n<p>SQL logging is critical for debugging the query compilation and N+1 problems. By intercepting and examining the actual SQL sent to the database, you can identify:</p>\n<p><strong>Implementation Strategy:</strong></p>\n<ol>\n<li><strong>Interceptor Pattern:</strong> Wrap database connection execute methods to log SQL with timestamps</li>\n<li><strong>Query Tagging:</strong> Add a comment with GraphQL operation name to correlate SQL with GraphQL</li>\n<li><strong>Parameter Substitution:</strong> Log the actual parameter values (not placeholders) for complete queries</li>\n<li><strong>Execution Metrics:</strong> Capture query duration, row count, and explain plan results</li>\n</ol>\n<p><strong>Key Questions SQL Logging Answers:</strong></p>\n<ul>\n<li>Is the compiler generating a single query with JOINs or multiple sequential queries?</li>\n<li>Are WHERE conditions correctly parameterized to prevent injection?</li>\n<li>Do pagination clauses (LIMIT/OFFSET) match GraphQL arguments?</li>\n<li>Are unnecessary columns being selected (SELECT * vs specific columns)?</li>\n</ul>\n<p><strong>Sample Log Format:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[GRAPHQL→SQL] Operation: GetUserWithPosts\nSQL: SELECT u.id, u.name, p.id, p.title FROM users u \n     LEFT JOIN posts p ON u.id = p.user_id WHERE u.id = $1\nParameters: [123]\nDuration: 4.2ms, Rows: 5</code></pre></div>\n\n<h4 id=\"resolver-tracing\">Resolver Tracing</h4>\n<blockquote>\n<p><strong>Mental Model:</strong> <strong>Function Call Stack Recording</strong> - Imagine each resolver as a function call in a program. Tracing logs each call entry and exit with arguments and return values, creating a call graph that shows how data flows through resolvers.</p>\n</blockquote>\n<p>Resolver tracing illuminates the execution phase, showing which resolvers are called, in what order, with what arguments, and what they return. This is particularly valuable for:</p>\n<p><strong>Tracing Implementation:</strong></p>\n<ol>\n<li><strong>Wrapper Functions:</strong> Create a decorator/wrapper that logs resolver invocation</li>\n<li><strong>Context Propagation:</strong> Include unique request ID in <code>ExecutionContext</code> to correlate logs</li>\n<li><strong>Timing Information:</strong> Record start/end times to identify slow resolvers</li>\n<li><strong>Error Capture:</strong> Log exceptions before they&#39;re converted to GraphQL errors</li>\n</ol>\n<p><strong>Trace Data to Capture:</strong></p>\n<ul>\n<li>Resolver function name or field path</li>\n<li>Parent value type and ID (if applicable)</li>\n<li>Argument values received</li>\n<li>Return value or exception</li>\n<li>Duration of resolution</li>\n<li>Whether resolution was batched via DataLoader</li>\n</ul>\n<p><strong>Diagnostic Patterns:</strong></p>\n<ul>\n<li><strong>Missing Resolver Calls:</strong> If a field returns null and its resolver never logged, the resolver wasn&#39;t registered</li>\n<li><strong>Wrong Argument Values:</strong> If arguments in trace don&#39;t match expected types, check variable coercion</li>\n<li><strong>Multiple Calls for Same Data:</strong> Indicates missing DataLoader batching</li>\n<li><strong>Long Resolver Chains:</strong> Deeply nested synchronous resolvers causing performance issues</li>\n</ul>\n<h4 id=\"type-inspection\">Type Inspection</h4>\n<blockquote>\n<p><strong>Mental Model:</strong> <strong>Building Blueprint Examination</strong> - Imagine the type system as architectural blueprints for a building. Type inspection lets you examine each blueprint&#39;s details: room dimensions (field types), connections (interfaces), and structural rules (nullability constraints).</p>\n</blockquote>\n<p>When type-related errors occur (&quot;Expected type String, found Int&quot;), you need to examine the actual type definitions in the schema. Type inspection helps verify:</p>\n<p><strong>Inspection Tools:</strong></p>\n<ol>\n<li><strong>Schema Introspection Queries:</strong> Use GraphQL&#39;s built-in introspection to query type definitions</li>\n<li><strong>Programmatic Type Dumping:</strong> Write a function that prints all types with their fields and relationships</li>\n<li><strong>Validation Reports:</strong> Run schema validation and examine all warnings/errors</li>\n<li><strong>Comparison with Source:</strong> Compare runtime type definitions with source schema definitions</li>\n</ol>\n<p><strong>Critical Type Details to Verify:</strong></p>\n<ul>\n<li>Field nullability (<code>String</code> vs <code>String!</code> vs <code>[String]!</code>)</li>\n<li>Interface implementation completeness (all interface fields present)</li>\n<li>Union type membership (all possible types registered)</li>\n<li>Custom scalar serialization/parsing functions</li>\n<li>Default values for input fields and arguments</li>\n</ul>\n<p><strong>Common Type Inspection Findings:</strong></p>\n<ul>\n<li><strong>Circular Input Types:</strong> Input object fields that reference their containing type</li>\n<li><strong>Missing Interface Fields:</strong> Object types claiming to implement interfaces but missing fields</li>\n<li><strong>Type Name Collisions:</strong> Two types with same name but different definitions</li>\n<li><strong>Incorrect Type Modifiers:</strong> List wrapped in NonNull instead of NonNull wrapped in List</li>\n</ul>\n<h3 id=\"tools-and-diagnostic-approaches\">Tools and Diagnostic Approaches</h3>\n<p>Beyond manual inspection, several systematic approaches and tools can accelerate debugging. These approaches provide different perspectives on the system&#39;s behavior.</p>\n<h4 id=\"debug-logging-with-context-correlation\">Debug Logging with Context Correlation</h4>\n<blockquote>\n<p><strong>Mental Model:</strong> <strong>Forensic Timeline Reconstruction</strong> - Imagine each request as a crime scene. Debug logging creates a detailed timeline of events with evidence tags (request IDs) that let you reconstruct exactly what happened during each stage of processing.</p>\n</blockquote>\n<p>Structured debug logging provides a comprehensive view of request processing across all components. The key is correlation: every log entry should include a request identifier that connects parser logs with executor logs with SQL logs.</p>\n<p><strong>Logging Strategy Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Log Level</th>\n<th>Purpose</th>\n<th>Example Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEBUG</td>\n<td>Detailed internal state</td>\n<td><code>[DEBUG] Parser: Entering parse_selection_set at line 5, token: {</code></td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>Major component transitions</td>\n<td><code>[INFO] Executor: Starting execution of operation &#39;GetUser&#39;</code></td>\n</tr>\n<tr>\n<td>WARN</td>\n<td>Non-breaking issues</td>\n<td><code>[WARN] TypeMapper: Unknown database type &#39;jsonb&#39;, falling back to String</code></td>\n</tr>\n<tr>\n<td>ERROR</td>\n<td>Failures requiring attention</td>\n<td><code>[ERROR] SQLCompiler: Cartesian product detected in join plan</code></td>\n</tr>\n</tbody></table>\n<p><strong>Context Correlation Implementation:</strong></p>\n<ol>\n<li><strong>Request ID Generation:</strong> Create a unique ID at HTTP entry point</li>\n<li><strong>Context Passing:</strong> Include request ID in <code>ExecutionContext.context_value</code></li>\n<li><strong>Structured Logging:</strong> Use JSON format with consistent fields: <code>timestamp</code>, <code>level</code>, <code>request_id</code>, <code>component</code>, <code>message</code>, <code>extra_data</code></li>\n<li><strong>Log Aggregation:</strong> Collect logs from all components into a single stream</li>\n</ol>\n<p><strong>Diagnostic Queries You Can Answer:</strong></p>\n<ul>\n<li>How long did each phase (parse, validate, execute, compile SQL) take for a specific request?</li>\n<li>Which component first encountered an error in a failing request?</li>\n<li>What was the exact SQL generated for a query that returned unexpected data?</li>\n<li>Which resolvers were called multiple times for the same data (N+1 pattern)?</li>\n</ul>\n<h4 id=\"graphiql-integration-for-interactive-testing\">GraphiQL Integration for Interactive Testing</h4>\n<blockquote>\n<p><strong>Mental Model:</strong> <strong>Query Playground with X-Ray Vision</strong> - GraphiQL is like a playground where you can try queries while wearing X-ray glasses that let you see not just the response, but also the execution path, timing, and internal state.</p>\n</blockquote>\n<p>GraphiQL (or GraphQL Playground) provides an interactive environment to test queries with built-in diagnostics. Integrating your engine with GraphiQL gives you:</p>\n<p><strong>Enhanced GraphiQL Features:</strong></p>\n<ol>\n<li><strong>Query Validation:</strong> Real-time schema validation and error highlighting</li>\n<li><strong>Query History:</strong> Compare current query with previous working queries</li>\n<li><strong>Variable Input:</strong> Test with different variable values without modifying query text</li>\n<li><strong>Documentation Explorer:</strong> Browse schema types and fields to verify introspection</li>\n</ol>\n<p><strong>Custom Extensions for Debugging:</strong></p>\n<ol>\n<li><strong>Execution Timing Extension:</strong> Add query duration breakdown to response extensions</li>\n<li><strong>SQL Preview Extension:</strong> Show generated SQL alongside GraphQL query</li>\n<li><strong>Resolver Trace Extension:</strong> Include resolver call trace in response metadata</li>\n<li><strong>AST Viewer Extension:</strong> Display parsed AST tree structure</li>\n</ol>\n<p><strong>Integration Steps:</strong></p>\n<ol>\n<li><strong>Add GraphiQL HTML Endpoint:</strong> Serve GraphiQL interface at <code>/graphiql</code> or <code>/playground</code></li>\n<li><strong>Implement Introspection:</strong> Ensure <code>__schema</code> query works for documentation display</li>\n<li><strong>Add Custom Extensions:</strong> Extend <code>ExecutionResult.extensions</code> with debug information</li>\n<li><strong>Enable Request Logging:</strong> Log all GraphiQL queries for later analysis</li>\n</ol>\n<p><strong>Diagnostic Workflow with GraphiQL:</strong></p>\n<ol>\n<li>Start with a simple query that works in a known GraphQL server</li>\n<li>Gradually add complexity (nested fields, fragments, variables)</li>\n<li>Use query variables to test edge cases without modifying query structure</li>\n<li>Examine response extensions for timing, SQL, and trace data</li>\n<li>Compare with expected results from direct database queries</li>\n</ol>\n<h4 id=\"database-explain-plans-for-query-optimization\">Database Explain Plans for Query Optimization</h4>\n<blockquote>\n<p><strong>Mental Model:</strong> <strong>Car Engine Diagnostic Computer</strong> - An EXPLAIN plan is like plugging a diagnostic computer into a car engine. It shows you exactly how the database plans to execute the query: which indexes it will use, join order, estimated costs, and potential bottlenecks.</p>\n</blockquote>\n<p>When SQL queries are slow or inefficient, database EXPLAIN plans provide visibility into the database&#39;s execution strategy. This is particularly important for the SQL compiler component to verify it&#39;s generating optimal queries.</p>\n<p><strong>EXPLAIN Plan Analysis Workflow:</strong></p>\n<ol>\n<li><strong>Capture Generated SQL:</strong> Use SQL logging to get the exact query with parameters</li>\n<li><strong>Run EXPLAIN:</strong> Execute <code>EXPLAIN (FORMAT JSON, ANALYZE) ...</code> on the query</li>\n<li><strong>Interpret Results:</strong> Look for:<ul>\n<li><strong>Seq Scans vs Index Scans:</strong> Sequential table scans are expensive for large tables</li>\n<li><strong>Join Types:</strong> Nested loops vs hash joins vs merge joins</li>\n<li><strong>Filter Estimates:</strong> Whether row estimates match actual row counts</li>\n<li><strong>Sort Operations:</strong> In-memory sorts vs disk spills</li>\n<li><strong>Total Cost:</strong> Estimated execution cost in arbitrary units</li>\n</ul>\n</li>\n</ol>\n<p><strong>Common SQL Compiler Issues Revealed by EXPLAIN:</strong></p>\n<ul>\n<li><strong>Missing JOIN Conditions:</strong> Causing Cartesian products (explode in row count)</li>\n<li><strong>Inefficient WHERE Clauses:</strong> Not using indexes due to function wrapping or type mismatches</li>\n<li><strong>Unnecessary Columns:</strong> Selecting columns not needed for response</li>\n<li><strong>Suboptimal Join Order:</strong> Joining large tables before filtering them</li>\n</ul>\n<p><strong>Integration with GraphQL Engine:</strong></p>\n<ol>\n<li><strong>Explain Endpoint:</strong> Add <code>/explain</code> endpoint that runs EXPLAIN on generated SQL</li>\n<li><strong>Query Plan Caching:</strong> Cache explain results for frequently generated query patterns</li>\n<li><strong>Performance Regression Detection:</strong> Compare explain plans between engine versions</li>\n<li><strong>Index Recommendation:</strong> Suggest database indexes based on frequent query patterns</li>\n</ol>\n<p><strong>Sample Diagnostic Process:</strong></p>\n<ol>\n<li>GraphQL query for users with their posts runs slowly</li>\n<li>SQL logging shows query with 3 LEFT JOINs</li>\n<li>EXPLAIN reveals nested loop join on large <code>posts</code> table</li>\n<li>Diagnosis: Missing index on <code>posts.user_id</code></li>\n<li>Fix: Add index and verify new EXPLAIN plan uses index scan</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>While the previous sections focused on conceptual debugging approaches, this section provides concrete implementation strategies for building the diagnostic tools themselves.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Diagnostic Need</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging</td>\n<td>Python <code>logging</code> module with JSON formatter</td>\n<td>Structured logging with <code>structlog</code> or <code>loguru</code></td>\n</tr>\n<tr>\n<td>AST Visualization</td>\n<td>Recursive print functions with indentation</td>\n<td>Graphviz DOT generation for visual graphs</td>\n</tr>\n<tr>\n<td>SQL Interception</td>\n<td>Database driver wrapper that logs before execute</td>\n<td>SQL comment injection with query tagging</td>\n</tr>\n<tr>\n<td>Request Tracing</td>\n<td>Manual request ID generation and passing</td>\n<td>OpenTelemetry integration with distributed tracing</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td><code>time.time()</code> manual instrumentation</td>\n<td><code>cProfile</code> for function-level profiling</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure for Diagnostics:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql-engine/\n├── server.py                      # HTTP server with request ID middleware\n├── engine/\n│   ├── __init__.py\n│   ├── parser.py                  # Parser with debug logging\n│   ├── types.py                   # Type system with validation\n│   ├── executor.py                # Executor with resolver tracing\n│   ├── compiler.py                # SQL compiler with explain capability\n│   └── diagnostics/               # Diagnostic utilities\n│       ├── __init__.py\n│       ├── logger.py              # Structured logging setup\n│       ├── ast_printer.py         # AST visualization\n│       ├── sql_explainer.py       # EXPLAIN plan runner\n│       ├── tracer.py              # Request tracing\n│       └── profiler.py            # Performance profiling\n└── examples/\n    └── debug_queries.graphql      # Test queries for debugging</code></pre></div>\n\n<p><strong>Diagnostic Logger Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># engine/diagnostics/logger.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiagnosticLogger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Structured logger for GraphQL engine diagnostics.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, level: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"INFO\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(name)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger.setLevel(</span><span style=\"color:#79B8FF\">getattr</span><span style=\"color:#E1E4E8\">(logging, level))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # JSON formatter for structured logs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        class</span><span style=\"color:#B392F0\"> JSONFormatter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">logging</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Formatter</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            def</span><span style=\"color:#79B8FF\"> format</span><span style=\"color:#E1E4E8\">(self, record: logging.LogRecord) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                log_entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"timestamp\"</span><span style=\"color:#E1E4E8\">: datetime.utcnow().isoformat() </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"Z\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"level\"</span><span style=\"color:#E1E4E8\">: record.levelname,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"logger\"</span><span style=\"color:#E1E4E8\">: record.name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"message\"</span><span style=\"color:#E1E4E8\">: record.getMessage(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"request_id\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">getattr</span><span style=\"color:#E1E4E8\">(record, </span><span style=\"color:#9ECBFF\">'request_id'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"component\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">getattr</span><span style=\"color:#E1E4E8\">(record, </span><span style=\"color:#9ECBFF\">'component'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"path\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">getattr</span><span style=\"color:#E1E4E8\">(record, </span><span style=\"color:#9ECBFF\">'path'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    **</span><span style=\"color:#79B8FF\">getattr</span><span style=\"color:#E1E4E8\">(record, </span><span style=\"color:#9ECBFF\">'extra'</span><span style=\"color:#E1E4E8\">, {})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> json.dumps(log_entry)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.StreamHandler()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handler.setFormatter(JSONFormatter())</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger.addHandler(handler)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> log</span><span style=\"color:#E1E4E8\">(self, level: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            request_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            component: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            path: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            **</span><span style=\"color:#E1E4E8\">extra: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Log with structured context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        extra_record </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'request_id'</span><span style=\"color:#E1E4E8\">: request_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'component'</span><span style=\"color:#E1E4E8\">: component,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'path'</span><span style=\"color:#E1E4E8\">: path,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'extra'</span><span style=\"color:#E1E4E8\">: extra</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger.log(</span><span style=\"color:#79B8FF\">getattr</span><span style=\"color:#E1E4E8\">(logging, level), message, </span><span style=\"color:#FFAB70\">extra</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">extra_record)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global diagnostic logger instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">diag_log </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DiagnosticLogger(</span><span style=\"color:#9ECBFF\">\"graphql-engine\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Usage in components:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># diag_log.log(\"INFO\", \"Parsing query\", </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#              request_id=ctx.request_id,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#              component=\"parser\",</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#              query=query_str[:100])</span></span></code></pre></div>\n\n<p><strong>AST Printer Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># engine/diagnostics/ast_printer.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Document, Field, SelectionSet, Node</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ASTPrinter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Prints AST in human-readable indented format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> print_document</span><span style=\"color:#E1E4E8\">(self, doc: Document, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span><span style=\"color:#F97583\">TODO</span><span style=\"color:#9ECBFF\"> 1: Iterate through doc.definitions and print each\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For OperationDefinition, print operation_type and name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For FragmentDefinition, print fragment name and type_condition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call print_selection_set for each definition's selection_set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Include Location.line and Location.column for error correlation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> print_selection_set</span><span style=\"color:#E1E4E8\">(self, sel_set: SelectionSet, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span><span style=\"color:#F97583\">TODO</span><span style=\"color:#9ECBFF\"> 1: Iterate through sel_set.selections\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For Field nodes, print name, alias, and argument count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For FragmentSpread nodes, print ...name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For InlineFragment nodes, print ... on TypeCondition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Recursively print nested selection_sets with increased indent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> print_field</span><span style=\"color:#E1E4E8\">(self, field: Field, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span><span style=\"color:#F97583\">TODO</span><span style=\"color:#9ECBFF\"> 1: Print field name with optional alias (alias: name)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Print arguments in parentheses if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Print directives starting with @ if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Recursively print selection_set if field has nested selections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>SQL Explainer Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># engine/diagnostics/sql_explainer.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..compiler </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SQLQuery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> psycopg2  </span><span style=\"color:#6A737D\"># or appropriate database driver</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SQLExplainer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Runs EXPLAIN on generated SQL queries.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_connection):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db_connection </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db_connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> explain</span><span style=\"color:#E1E4E8\">(self, sql_query: SQLQuery, analyze: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span><span style=\"color:#F97583\">TODO</span><span style=\"color:#9ECBFF\"> 1: Generate EXPLAIN query from SQLQuery\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If analyze=True, add ANALYZE option (caution: executes query)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Execute EXPLAIN using database connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Parse EXPLAIN output (JSON format if supported)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Extract key metrics: total cost, seq scans, index scans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return structured explanation with warnings for inefficiencies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> find_inefficiencies</span><span style=\"color:#E1E4E8\">(self, plan: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span><span style=\"color:#F97583\">TODO</span><span style=\"color:#9ECBFF\"> 1: Check for sequential scans on large tables\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Look for nested loop joins without indexes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Detect sorts that spill to disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Identify underestimated row counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return list of specific inefficiency descriptions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Milestone Debugging Checkpoints:</strong></p>\n<p>After completing each milestone, run these specific tests to verify correctness:</p>\n<p><strong>Milestone 1 (Parser):</strong></p>\n<ul>\n<li>Run: <code>python -m pytest tests/test_parser.py -v</code></li>\n<li>Expected: All tests pass, including edge cases for strings with escapes</li>\n<li>Manual test: Parse complex query with fragments, variables, directives</li>\n<li>Diagnostic: Use <code>ASTPrinter</code> to visualize and compare with GraphQL.js output</li>\n</ul>\n<p><strong>Milestone 2 (Type System):</strong></p>\n<ul>\n<li>Run: <code>python -m pytest tests/test_types.py -v</code></li>\n<li>Expected: Schema validation passes for valid schemas, fails for invalid ones</li>\n<li>Manual test: Execute introspection query <code>{ __schema { types { name } } }</code></li>\n<li>Diagnostic: Verify all built-in types appear in introspection</li>\n</ul>\n<p><strong>Milestone 3 (Execution):</strong></p>\n<ul>\n<li>Run: <code>python -m pytest tests/test_executor.py -v</code></li>\n<li>Expected: Queries return correct data, errors handled gracefully</li>\n<li>Manual test: Execute query with null propagation and partial results</li>\n<li>Diagnostic: Enable resolver tracing to verify call order and batching</li>\n</ul>\n<p><strong>Milestone 4 (Schema Reflection):</strong></p>\n<ul>\n<li>Run: <code>python -m pytest tests/test_reflection.py -v</code></li>\n<li>Expected: Generated schema matches database structure</li>\n<li>Manual test: Reflect a sample database with relationships</li>\n<li>Diagnostic: Compare reflected GraphQL types with database metadata</li>\n</ul>\n<p><strong>Milestone 5 (SQL Compilation):</strong></p>\n<ul>\n<li>Run: <code>python -m pytest tests/test_compiler.py -v</code></li>\n<li>Expected: Generated SQL is efficient and correct</li>\n<li>Manual test: Compile nested query and run EXPLAIN to verify joins</li>\n<li>Diagnostic: SQL logging shows single query with proper parameterization</li>\n</ul>\n<p><strong>Debugging Tips for Common Scenarios:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Quick Diagnosis</th>\n<th>Immediate Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>All queries return &quot;Internal server error&quot;</td>\n<td>Check application logs for uncaught exceptions</td>\n<td>Add try-except around <code>execute_query</code> and log exception details</td>\n</tr>\n<tr>\n<td>Introspection works but queries fail</td>\n<td>Likely resolver not registered for fields</td>\n<td>Verify field resolvers attached during schema construction</td>\n</tr>\n<tr>\n<td>Query slow with deep nesting</td>\n<td>Enable SQL logging, check for N+1 queries</td>\n<td>Implement DataLoader batching for relationship fields</td>\n</tr>\n<tr>\n<td>Mutation arguments not received</td>\n<td>Check variable definitions parsing</td>\n<td>Debug <code>parse_operation_definition</code> for variable extraction</td>\n</tr>\n<tr>\n<td>Database type maps incorrectly</td>\n<td>Examine <code>ColumnMetadata.data_type</code> raw value</td>\n<td>Add custom mapping to <code>TypeMapper.register_custom_mapping</code></td>\n</tr>\n</tbody></table>\n<p>Remember that debugging is iterative: make one change at a time, test thoroughly, and use the diagnostic tools to verify the fix actually addresses the root cause. The layered architecture means issues can cascade, so always trace problems back to their origin component.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section spans all five milestones, looking beyond the core implementation to consider how the architecture accommodates evolution. While these features are explicitly out of scope for the initial implementation, the system has been designed with clear extension points for future development.</p>\n</blockquote>\n<p>The current GraphQL engine provides a solid foundation for executing queries against relational databases, but its architecture deliberately leaves room for expansion. Designing for extensibility from the beginning ensures that future features can be added with minimal disruption to the core system. This section explores four high-value extension points—schema stitching, subscriptions, custom directives, and query caching—and explains how the current architecture accommodates them through careful abstraction boundaries, pluggable components, and thoughtful data model design.</p>\n<h3 id=\"planned-extension-points\">Planned Extension Points</h3>\n<p>Four major extension areas represent natural evolutions of the GraphQL engine that align with real-world GraphQL deployment patterns. Each builds upon the existing architecture while introducing new capabilities.</p>\n<h4 id=\"schema-stitching-federating-multiple-data-sources\">Schema Stitching: Federating Multiple Data Sources</h4>\n<p><strong>Mental Model: Mosaic Artist</strong>\nThink of schema stitching as a mosaic artist who creates a unified picture from distinct pieces of colored glass. Each piece (individual GraphQL schema) has its own shape and color, but when arranged together with careful planning, they form a cohesive whole that appears as a single image to the viewer.</p>\n<p>Schema stitching allows the GraphQL engine to combine multiple GraphQL schemas—potentially from different databases, REST APIs, or other GraphQL services—into a single unified schema. This transforms the engine from a single-database query layer into a federated gateway that can aggregate data from multiple sources.</p>\n<p><strong>Extension Requirements:</strong></p>\n<ul>\n<li>Schema composition mechanism that merges type definitions and resolves naming conflicts</li>\n<li>Query planning that routes sub-queries to appropriate underlying services</li>\n<li>Field resolver delegation that forwards requests to remote services with appropriate arguments</li>\n<li>Error aggregation from multiple sources with proper source attribution</li>\n</ul>\n<p><strong>Implementation Approach:</strong>\nThe system would extend the current <code>Schema</code> type with composition metadata and introduce a <code>SchemaComposer</code> component that:</p>\n<ol>\n<li>Validates schema compatibility (no type conflicts, consistent interface implementations)</li>\n<li>Creates merged type definitions with source service annotations</li>\n<li>Generates delegation resolvers that forward field requests to appropriate services</li>\n<li>Implements query planning to minimize remote calls and batch where possible</li>\n</ol>\n<p><strong>Architecture Decision Record: Schema Composition Strategy</strong></p>\n<blockquote>\n<p><strong>Decision: Preserve Individual Schemas with Gateway Layer</strong></p>\n<ul>\n<li><strong>Context</strong>: When combining multiple GraphQL schemas, we need to decide whether to merge them at the type definition level or keep them separate with a routing layer.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Deep Merge</strong>: Combine all type definitions into a single monolithic schema, resolving conflicts through renaming or namespacing.</li>\n<li><strong>Gateway with Delegation</strong>: Maintain separate schemas with a gateway layer that routes field resolutions to appropriate services.</li>\n<li><strong>Schema Extensions</strong>: Use GraphQL schema extensions to add cross-service fields while keeping core schemas independent.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Gateway with delegation, implemented as a separate <code>SchemaStitchingGateway</code> component.</li>\n<li><strong>Rationale</strong>: This approach preserves service autonomy, allows independent schema evolution, and matches the microservices architecture pattern where each service owns its domain. The delegation model also enables progressive migration from single-database to federated queries.</li>\n<li><strong>Consequences</strong>: Requires additional query planning complexity, introduces network latency for cross-service calls, but provides clear service boundaries and incremental adoption path.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Selected?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Deep Merge</td>\n<td>Simple query execution, single schema validation</td>\n<td>Breaks service autonomy, complex conflict resolution</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Gateway with Delegation</td>\n<td>Service independence, incremental adoption</td>\n<td>Query planning complexity, network overhead</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Schema Extensions</td>\n<td>GraphQL-spec compliant, clean separation</td>\n<td>Limited tooling support, complex implementation</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"subscriptions-real-time-data-updates\">Subscriptions: Real-Time Data Updates</h4>\n<p><strong>Mental Model: Radio Broadcasting</strong>\nThink of subscriptions as a radio broadcasting system where listeners tune into specific channels. The broadcaster (GraphQL engine) transmits updates only to those subscribed to particular data changes, without requiring continuous polling from listeners. Each subscription establishes a persistent connection over which data updates flow as they occur.</p>\n<p>Subscriptions extend the GraphQL engine beyond request-response to support real-time data updates through WebSocket or Server-Sent Events connections. This enables applications to receive live updates when database data changes, such as new chat messages, stock price changes, or collaborative editing events.</p>\n<p><strong>Extension Requirements:</strong></p>\n<ul>\n<li>WebSocket or SSE transport layer for persistent bidirectional connections</li>\n<li>Subscription operation parsing and validation in the parser</li>\n<li>Pub/sub mechanism for broadcasting data changes to interested subscribers</li>\n<li>Database change detection through triggers, polling, or database notifications</li>\n<li>Subscription execution context distinct from query/mutation contexts</li>\n</ul>\n<p><strong>Implementation Approach:</strong>\nThe system would extend the current architecture with:</p>\n<ol>\n<li><strong>Transport Layer</strong>: WebSocket server that manages connection lifecycle and maps messages to subscription operations</li>\n<li><strong>Subscription Resolver Type</strong>: New resolver signature that returns an async iterator/generator instead of a value</li>\n<li><strong>Event System</strong>: Pub/sub system where database change events trigger subscription updates</li>\n<li><strong>Subscription Manager</strong>: Tracks active subscriptions, manages cleanup, and handles fan-out to multiple clients</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Subscription Component</th>\n<th>Integration Point</th>\n<th>Data Flow</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WebSocketTransport</td>\n<td>Extends HTTP server layer</td>\n<td>Handles connection upgrade, message framing, and protocol negotiation</td>\n</tr>\n<tr>\n<td>SubscriptionParser</td>\n<td>Extends GraphQL Parser (Component 1)</td>\n<td>Adds subscription operation type validation and subscription-specific syntax</td>\n</tr>\n<tr>\n<td>SubscriptionExecutor</td>\n<td>Extends Query Execution Engine (Component 3)</td>\n<td>Executes subscription resolvers, returns async iterators, manages event mapping</td>\n</tr>\n<tr>\n<td>DatabaseChangeDetector</td>\n<td>Integrates with Database Schema Reflection (Component 4)</td>\n<td>Listens to database changes via triggers, LISTEN/NOTIFY, or change data capture</td>\n</tr>\n<tr>\n<td>SubscriptionRegistry</td>\n<td>New standalone component</td>\n<td>Maps database changes to active subscriptions, manages fan-out and cleanup</td>\n</tr>\n</tbody></table>\n<h4 id=\"custom-directives-schema-level-behavior-modification\">Custom Directives: Schema-Level Behavior Modification</h4>\n<p><strong>Mental Model: Circuit Breaker Panel</strong>\nThink of custom directives as circuit breakers in an electrical panel that can be flipped to modify how power flows through specific circuits. Each directive intercepts the normal execution flow at a specific point (field resolution, argument coercion, etc.) and can modify behavior—adding authentication checks, transforming output, logging, or implementing rate limiting—without changing the underlying resolver logic.</p>\n<p>Custom directives extend the GraphQL engine&#39;s ability to modify execution behavior at the schema level through declarative annotations. This enables cross-cutting concerns like authentication, authorization, caching, logging, and data transformation to be expressed directly in the schema definition language.</p>\n<p><strong>Extension Requirements:</strong></p>\n<ul>\n<li>Directive definition and validation in the type system</li>\n<li>Directive execution hooks at various points in the query lifecycle</li>\n<li>Directive composition and ordering semantics</li>\n<li>Directive argument processing and validation</li>\n</ul>\n<p><strong>Implementation Approach:</strong>\nThe system would extend the current architecture with:</p>\n<ol>\n<li><strong>Directive Definition Language</strong>: Extend <code>GraphQLDirective</code> type to support execution hooks</li>\n<li><strong>Directive Execution Pipeline</strong>: Interceptors at parse, validate, and execute phases</li>\n<li><strong>Directive Registry</strong>: Central registry of available directives with their implementation</li>\n<li><strong>Schema Transformation</strong>: Apply directive semantics during schema building</li>\n</ol>\n<p><strong>Directive Execution Hook Points:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Hook Point</th>\n<th>Description</th>\n<th>Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>onSchema</code></td>\n<td>Applied to entire schema</td>\n<td>Schema-level metadata, global rate limiting</td>\n</tr>\n<tr>\n<td><code>onObjectType</code></td>\n<td>Applied to object type definitions</td>\n<td>Type-level permissions, data masking rules</td>\n</tr>\n<tr>\n<td><code>onFieldDefinition</code></td>\n<td>Applied to field definitions</td>\n<td>Field-level authorization, cost calculation</td>\n</tr>\n<tr>\n<td><code>onArgumentDefinition</code></td>\n<td>Applied to argument definitions</td>\n<td>Input validation, sanitization</td>\n</tr>\n<tr>\n<td><code>onFieldExecution</code></td>\n<td>Wraps field resolver execution</td>\n<td>Caching, logging, timing, error handling</td>\n</tr>\n<tr>\n<td><code>onQueryExecution</code></td>\n<td>Wraps entire query execution</td>\n<td>Request logging, tracing, overall timeout</td>\n</tr>\n</tbody></table>\n<h4 id=\"query-caching-performance-optimization-layer\">Query Caching: Performance Optimization Layer</h4>\n<p><strong>Mental Model: Library Index System</strong>\nThink of query caching as a library&#39;s card catalog system that remembers where to find frequently requested books. Instead of walking through the entire library (executing the full query) each time someone asks for popular books, the system maintains a quick-reference index (cache) that dramatically reduces lookup time for repeated requests with identical parameters.</p>\n<p>Query caching adds a performance optimization layer that stores and reuses query results to reduce database load and improve response times. This includes both query result caching (storing complete GraphQL responses) and field-level caching (storing individual field values for reuse across queries).</p>\n<p><strong>Extension Requirements:</strong></p>\n<ul>\n<li>Cache key generation from query AST, variables, and context</li>\n<li>Cache storage backend abstraction (in-memory, Redis, memcached)</li>\n<li>Cache invalidation strategies based on database mutations</li>\n<li>Cache TTL management and stale-while-revalidate patterns</li>\n<li>Partial query caching and result composition</li>\n</ul>\n<p><strong>Implementation Approach:</strong>\nThe system would extend the current architecture with:</p>\n<ol>\n<li><strong>Cache Key Generator</strong>: Creates deterministic cache keys from queries</li>\n<li><strong>Cache Layer Interface</strong>: Abstract interface supporting multiple storage backends</li>\n<li><strong>Cache Interceptor</strong>: Wraps execution engine to check cache before execution</li>\n<li><strong>Invalidation System</strong>: Listens to mutations and invalidates affected cache entries</li>\n</ol>\n<p><strong>Cache Strategy Comparison:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Implementation Complexity</th>\n<th>Cache Hit Rate</th>\n<th>Invalidation Complexity</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Full Query Caching</td>\n<td>Low</td>\n<td>Medium</td>\n<td>High</td>\n<td>Read-heavy workloads with limited query variation</td>\n</tr>\n<tr>\n<td>Field-Level Caching</td>\n<td>High</td>\n<td>High</td>\n<td>Medium</td>\n<td>Complex queries with overlapping field selections</td>\n</tr>\n<tr>\n<td>Compiled SQL Caching</td>\n<td>Medium</td>\n<td>High</td>\n<td>Low</td>\n<td>Database-heavy workloads with repeated query patterns</td>\n</tr>\n<tr>\n<td>Hybrid Approach</td>\n<td>Very High</td>\n<td>Very High</td>\n<td>High</td>\n<td>Production systems with mixed access patterns</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: The choice between these caching strategies depends heavily on the access pattern. For GraphQL APIs with high query diversity, field-level caching often provides the best balance, while for APIs with repetitive query patterns (like dashboard applications), full query caching may be more effective.</p>\n</blockquote>\n<h3 id=\"design-accommodations\">Design Accommodations</h3>\n<p>The current architecture has been intentionally designed with specific patterns and abstractions that enable these future extensions without requiring fundamental redesign. These accommodations manifest as extension points, pluggable interfaces, and carefully isolated concerns.</p>\n<h4 id=\"extension-point-inventory\">Extension Point Inventory</h4>\n<p>The following table catalogs the explicit extension points built into the current system design:</p>\n<table>\n<thead>\n<tr>\n<th>Extension Point</th>\n<th>Location</th>\n<th>Purpose</th>\n<th>Enables Feature</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GraphQLDirective.execution_hooks</code></td>\n<td><code>GraphQLDirective</code> type</td>\n<td>Directive implementation hooks</td>\n<td>Custom directives</td>\n</tr>\n<tr>\n<td><code>Schema.builders</code></td>\n<td><code>Schema</code> type</td>\n<td>Schema transformation pipeline</td>\n<td>Schema stitching, custom directives</td>\n</tr>\n<tr>\n<td><code>Executor.middleware</code></td>\n<td><code>ExecutionContext</code></td>\n<td>Execution interception</td>\n<td>Custom directives, caching, logging</td>\n</tr>\n<tr>\n<td><code>SQLCompiler.plugins</code></td>\n<td><code>SQLBuilder</code></td>\n<td>SQL generation customization</td>\n<td>Database-specific optimizations</td>\n</tr>\n<tr>\n<td><code>TypeMapper.registry</code></td>\n<td><code>TypeMapper</code> class</td>\n<td>Custom type mappings</td>\n<td>Extended database type support</td>\n</tr>\n<tr>\n<td><code>Transport.protocols</code></td>\n<td>HTTP server layer</td>\n<td>Alternative transport protocols</td>\n<td>Subscriptions (WebSocket/SSE)</td>\n</tr>\n<tr>\n<td><code>DataLoader.factory</code></td>\n<td><code>ExecutionContext</code></td>\n<td>Custom batching strategies</td>\n<td>Advanced N+1 optimization</td>\n</tr>\n<tr>\n<td><code>ReflectionOptions.hooks</code></td>\n<td><code>ReflectionOptions</code></td>\n<td>Schema generation customization</td>\n<td>Complex relationship modeling</td>\n</tr>\n</tbody></table>\n<h4 id=\"abstract-interface-design\">Abstract Interface Design</h4>\n<p>Each major component exposes abstract interfaces that allow behavior extension through polymorphism rather than modification:</p>\n<p><strong>1. Transport Layer Abstraction:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Current implementation supports only HTTP POST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Extended to support WebSocket and Server-Sent Events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TransportProtocol</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_request</span><span style=\"color:#E1E4E8\">(self, request) -> Response:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> supports_subscriptions</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<p><strong>2. Cache Backend Abstraction:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Prepared for caching layer addition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheBackend</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Any]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any, ttl: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> invalidate_pattern</span><span style=\"color:#E1E4E8\">(self, pattern: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>3. Directive Execution Abstraction:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Ready for directive system extension</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DirectiveVisitor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> visit_field_definition</span><span style=\"color:#E1E4E8\">(self, field: GraphQLField, directive: GraphQLDirective):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> visit_argument_definition</span><span style=\"color:#E1E4E8\">(self, arg: GraphQLArgument, directive: GraphQLDirective):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"schema-evolution-support\">Schema Evolution Support</h4>\n<p>The type system design supports schema evolution through several key mechanisms:</p>\n<p><strong>1. Schema Versioning Metadata:</strong>\nThe <code>Schema</code> type includes extension fields that can store version information and compatibility metadata:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n<th>Evolution Support</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>extensions</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Arbitrary metadata</td>\n<td>Stores schema version, deprecation info</td>\n</tr>\n<tr>\n<td><code>source_services</code></td>\n<td><code>List[Dict]</code></td>\n<td>Source service info</td>\n<td>Enables schema stitching tracking</td>\n</tr>\n<tr>\n<td><code>directive_locations</code></td>\n<td><code>Dict[str, List[str]]</code></td>\n<td>Custom directive bindings</td>\n<td>Supports directive registration</td>\n</tr>\n</tbody></table>\n<p><strong>2. Backward-Compatible Changes:</strong>\nThe architecture supports common GraphQL schema evolution patterns:</p>\n<ul>\n<li><strong>Additive Changes</strong>: New types, fields, and arguments can be added without breaking existing clients</li>\n<li><strong>Deprecation Flow</strong>: Fields can be marked deprecated while maintaining functionality</li>\n<li><strong>Default Values</strong>: New arguments can be added with default values for backward compatibility</li>\n<li><strong>Interface Implementation</strong>: New types can implement existing interfaces</li>\n</ul>\n<p><strong>3. Breaking Change Detection:</strong>\nThe <code>validate_schema</code> function includes hooks for schema comparison that can detect breaking changes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Extension point for schema comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_breaking_changes</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_schema: Schema, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_schema: Schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> List[BreakingChange]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Compares schemas and returns list of breaking changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Ready for extension to support custom breaking change policies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"execution-pipeline-extensibility\">Execution Pipeline Extensibility</h4>\n<p>The query execution pipeline is designed as a series of interceptable stages:</p>\n<p><strong>Execution Stage Pipeline:</strong></p>\n<ol>\n<li><strong>Parse</strong> → <code>parse_query()</code> with directive awareness</li>\n<li><strong>Validate</strong> → <code>validate_with_rules()</code> with custom validation rules</li>\n<li><strong>Plan</strong> → <code>create_execution_plan()</code> with caching/sharding decisions  </li>\n<li><strong>Execute</strong> → <code>execute_operation()</code> with middleware wrapping</li>\n<li><strong>Format</strong> → <code>format_response()</code> with error transformation</li>\n</ol>\n<p>Each stage can be intercepted or replaced through the <code>ExecutionContext</code> configuration:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Execution context includes extension points</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ExecutionContext(</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... existing fields ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validation_rules: List[ValidationRule] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Custom validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    field_middleware: List[FieldMiddleware] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Field execution hooks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    query_transformers: List[QueryTransformer] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># AST transformations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_formatters: Dict[Type[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">], ErrorFormatter] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Custom errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"database-abstraction-layer\">Database Abstraction Layer</h4>\n<p>The current database reflection and SQL compilation components are designed with dialect abstraction that enables future database support:</p>\n<p><strong>Database Dialect Interface:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SQLDialect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_type_mappings</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLType]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return database-specific type mappings\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> supports_feature</span><span style=\"color:#E1E4E8\">(self, feature: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if dialect supports specific feature (e.g., JSON, arrays)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_pagination_sql</span><span style=\"color:#E1E4E8\">(self, limit: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, offset: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate dialect-specific pagination SQL\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Current dialect implementations can be extended for:</strong></p>\n<ul>\n<li><strong>Additional Databases</strong>: MongoDB, Cassandra, Elasticsearch</li>\n<li><strong>Advanced Features</strong>: Full-text search, geospatial queries, window functions</li>\n<li><strong>Optimization Hints</strong>: Database-specific query optimizations</li>\n</ul>\n<h4 id=\"plugin-system-architecture\">Plugin System Architecture</h4>\n<p>The overall architecture follows a plugin system pattern where new capabilities can be registered without modifying core components:</p>\n<p><strong>Plugin Registration Flow:</strong></p>\n<ol>\n<li><strong>Discovery</strong>: Plugins are discovered via entry points or explicit registration</li>\n<li><strong>Initialization</strong>: Each plugin receives configuration and context</li>\n<li><strong>Integration</strong>: Plugins register themselves with appropriate extension points</li>\n<li><strong>Execution</strong>: Plugins participate in the normal execution flow</li>\n</ol>\n<p><strong>Example Plugin Contract:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLEnginePlugin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> configure_schema</span><span style=\"color:#E1E4E8\">(self, schema: Schema) -> Schema:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Transform schema during construction\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> configure_execution</span><span style=\"color:#E1E4E8\">(self, context: ExecutionContext) -> ExecutionContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add middleware or transformers to execution context\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> teardown</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clean up plugin resources\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"performance-monitoring-hooks\">Performance Monitoring Hooks</h4>\n<p>The architecture includes performance monitoring hooks that enable future observability features:</p>\n<p><strong>Instrumentation Points:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Instrumentation Point</th>\n<th>Data Collected</th>\n<th>Enables Feature</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>query_parse_start/end</code></td>\n<td>Parse duration, query size</td>\n<td>Performance monitoring</td>\n</tr>\n<tr>\n<td><code>field_resolve_start/end</code></td>\n<td>Resolver timing, parent type</td>\n<td>Resolver profiling</td>\n</tr>\n<tr>\n<td><code>sql_generation_start/end</code></td>\n<td>SQL generation time, complexity</td>\n<td>Query optimization</td>\n</tr>\n<tr>\n<td><code>database_query_start/end</code></td>\n<td>Database latency, row count</td>\n<td>Database performance analysis</td>\n</tr>\n<tr>\n<td><code>cache_hit_miss</code></td>\n<td>Cache effectiveness metrics</td>\n<td>Cache tuning</td>\n</tr>\n</tbody></table>\n<p>These hooks are implemented as no-op stubs in the current system but provide the foundation for comprehensive APM (Application Performance Monitoring) integration.</p>\n<h4 id=\"security-extension-foundation\">Security Extension Foundation</h4>\n<p>The current design includes several security-conscious patterns that enable future security extensions:</p>\n<p><strong>1. Input Validation Pipeline:</strong>\nArgument coercion and input validation occur in isolated, interceptable stages that can be extended for:</p>\n<ul>\n<li>Additional input sanitization</li>\n<li>Business rule validation</li>\n<li>Compliance checking (PCI, HIPAA, etc.)</li>\n</ul>\n<p><strong>2. Error Sanitization Layers:</strong>\nDatabase errors are sanitized before exposure, but this pipeline can be extended for:</p>\n<ul>\n<li>PII (Personally Identifiable Information) filtering</li>\n<li>Security policy enforcement</li>\n<li>Audit logging of sensitive errors</li>\n</ul>\n<p><strong>3. Query Complexity Analysis:</strong>\nThe query execution plan includes complexity metrics that can be extended for:</p>\n<ul>\n<li>Query depth limiting</li>\n<li>Field cost calculation</li>\n<li>Rate limiting based on query complexity</li>\n</ul>\n<p><strong>Common Pitfalls in Extensibility Design:</strong>\n⚠️ <strong>Pitfall: Over-Engineering Extension Points</strong></p>\n<ul>\n<li><strong>Description</strong>: Creating abstract interfaces and extension hooks for every possible future need, resulting in unnecessary complexity.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Increases initial implementation complexity, makes the system harder to understand, and may never use most extension points.</li>\n<li><strong>Fix</strong>: Apply the YAGNI (You Ain&#39;t Gonna Need It) principle. Only add extension points where there&#39;s clear evidence of future need or where the cost is minimal.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Tight Coupling Between Extension and Core</strong></p>\n<ul>\n<li><strong>Description</strong>: Extension implementations directly modify core data structures or rely on internal implementation details.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Core changes break extensions, making evolution difficult and creating maintenance burden.</li>\n<li><strong>Fix</strong>: Use the Dependency Inversion Principle. Core depends on abstractions, extensions implement those abstractions without knowing core internals.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Inconsistent Extension Patterns</strong></p>\n<ul>\n<li><strong>Description</strong>: Different components use different patterns for extensibility (callbacks, inheritance, plugins, etc.).</li>\n<li><strong>Why It&#39;s Wrong</strong>: Makes the system harder to learn and extend consistently.</li>\n<li><strong>Fix</strong>: Establish and document consistent extension patterns across the codebase, such as a unified plugin system or consistent use of strategy pattern.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Neglecting Extension Performance</strong></p>\n<ul>\n<li><strong>Description</strong>: Extension points add overhead even when not used, or poorly designed extensions degrade performance.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Impacts performance of core functionality, making extensions impractical for production use.</li>\n<li><strong>Fix</strong>: Design extension points with zero-cost abstractions where possible, use lazy initialization, and provide performance guidance for extension developers.</li>\n</ul>\n<blockquote>\n<p><strong>Design Insight</strong>: The most successful extensible systems follow the &quot;Open-Closed Principle&quot;—open for extension but closed for modification. This is achieved not by predicting every future need, but by identifying stable abstractions that encapsulate variation points. In this GraphQL engine, the key stable abstractions are: <code>GraphQLType</code> for schema definition, <code>ExecutionContext</code> for execution behavior, and <code>SQLDialect</code> for database variations.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>While the future extensions themselves are out of scope for the initial implementation, the architecture includes specific patterns and structures that make these extensions feasible. This section provides concrete guidance on how to implement the extension infrastructure.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Schema Stitching</td>\n<td>Manual schema merging with delegated resolvers</td>\n<td>Apollo Federation with query planning service</td>\n</tr>\n<tr>\n<td>Subscriptions</td>\n<td>Polling-based subscriptions with database polling</td>\n<td>WebSocket with PostgreSQL LISTEN/NOTIFY or change data capture</td>\n</tr>\n<tr>\n<td>Custom Directives</td>\n<td>Directive visitors that modify execution context</td>\n<td>AST-transforming directives with full query rewriting</td>\n</tr>\n<tr>\n<td>Query Caching</td>\n<td>In-memory LRU cache with TTL</td>\n<td>Redis cluster with cache invalidation streams</td>\n</tr>\n<tr>\n<td>Plugin System</td>\n<td>Explicit registration in application code</td>\n<td>Dynamic discovery via entry_points with dependency injection</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-plugin-directory-structure\">Recommended Plugin Directory Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>graphql-engine/\n  core/                    # Core engine (existing)\n    parser/               # Component 1\n    type_system/          # Component 2  \n    execution/            # Component 3\n    reflection/           # Component 4\n    compilation/          # Component 5\n    \n  extensions/             # Future extensions (new)\n    stitching/            # Schema stitching implementation\n      __init__.py\n      gateway.py          # Schema stitching gateway\n      delegator.py        # Field delegation logic\n      planner.py          # Cross-service query planning\n      \n    subscriptions/        # Real-time subscriptions\n      __init__.py\n      transport/          # WebSocket/SSE transport\n        websocket.py\n        sse.py\n      pubsub/             # Publish/subscribe backend\n        memory.py\n        redis.py\n      triggers/           # Database change detection\n        poller.py\n        cdc.py\n        \n    directives/           # Custom directives\n      __init__.py\n      registry.py         # Directive registry\n      builtins/           # Built-in directives\n        auth.py           # @auth directive\n        cache.py          # @cache directive\n        log.py            # @log directive\n      middleware.py       # Directive execution middleware\n      \n    caching/              # Query caching\n      __init__.py\n      backends/           # Cache storage backends\n        memory.py\n        redis.py\n      key_generation.py   # Cache key generation\n      invalidation.py     # Cache invalidation logic\n      \n    plugins/              # Plugin infrastructure\n      __init__.py\n      registry.py         # Plugin registry\n      lifecycle.py        # Plugin lifecycle management</code></pre></div>\n\n<h4 id=\"extension-infrastructure-starter-code\">Extension Infrastructure Starter Code</h4>\n<p><strong>Plugin Registry (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># extensions/plugins/registry.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Plugin registry for dynamic extension loading\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> importlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Type, Optional, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphQLEnginePlugin</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all GraphQL engine plugins\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, version: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"1.0.0\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.version </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> version</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> configure_schema</span><span style=\"color:#E1E4E8\">(self, schema: </span><span style=\"color:#9ECBFF\">'Schema'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Schema'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Transform schema during construction. Override in subclasses.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> configure_execution</span><span style=\"color:#E1E4E8\">(self, context: </span><span style=\"color:#9ECBFF\">'ExecutionContext'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'ExecutionContext'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add middleware or transformers to execution context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> teardown</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clean up plugin resources.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;Plugin </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> v</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.version</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PluginRegistry</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Central registry for managing plugins\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._plugins: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, GraphQLEnginePlugin] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._initialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register</span><span style=\"color:#E1E4E8\">(self, plugin: GraphQLEnginePlugin) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a plugin instance\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> plugin.name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._plugins:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.warning(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Plugin </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">plugin.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> already registered, overwriting\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._plugins[plugin.name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plugin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> load_from_entrypoint</span><span style=\"color:#E1E4E8\">(self, entrypoint_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"graphql_engine.plugins\"</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Load plugins from package entrypoints\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            import</span><span style=\"color:#E1E4E8\"> pkg_resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> entrypoint </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> pkg_resources.iter_entry_points(entrypoint_name):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    plugin_class </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entrypoint.load()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    plugin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plugin_class()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.register(plugin)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Loaded plugin </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">plugin.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> from </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">entrypoint.module_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to load plugin from </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">entrypoint</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> ImportError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.warning(</span><span style=\"color:#9ECBFF\">\"pkg_resources not available, skipping entrypoint loading\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> initialize_all</span><span style=\"color:#E1E4E8\">(self, schema: </span><span style=\"color:#9ECBFF\">'Schema'</span><span style=\"color:#E1E4E8\">, context: Optional[</span><span style=\"color:#9ECBFF\">'ExecutionContext'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initialize all registered plugins\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._initialized:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> name, plugin </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._plugins.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> plugin.enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    logger.debug(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Initializing plugin </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Apply schema transformations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plugin.configure_schema(schema)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Apply execution context transformations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> context:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plugin.configure_execution(context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Plugin </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> failed to initialize: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    plugin.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._initialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> teardown_all</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clean up all plugin resources\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> name, plugin </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._plugins.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> plugin.enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    plugin.teardown()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Plugin </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> failed to teardown: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_plugin</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[GraphQLEnginePlugin]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get a plugin by name\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._plugins.get(name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> list_plugins</span><span style=\"color:#E1E4E8\">(self) -> List[GraphQLEnginePlugin]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"List all registered plugins\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> list</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._plugins.values())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enable_plugin</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Enable a disabled plugin\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._plugins:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._plugins[name].enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> disable_plugin</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Disable an enabled plugin\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._plugins:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._plugins[name].enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global plugin registry instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">plugin_registry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PluginRegistry()</span></span></code></pre></div>\n\n<p><strong>Directive Middleware Skeleton (Core Logic TODOs):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># extensions/directives/middleware.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Directive execution middleware for field resolution\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, Any, Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.type_system </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> GraphQLDirective, GraphQLField, ExecutionContext</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DirectiveMiddleware</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Middleware that executes directives during field resolution\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._directive_handlers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Callable] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_directive_handler</span><span style=\"color:#E1E4E8\">(self, directive_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, handler: Callable) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a handler function for a specific directive\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate handler signature matches expected directive interface</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for naming conflicts with existing handlers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store handler in _directive_handlers dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> execute_field_with_directives</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        field: GraphQLField,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parent_value: Any,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        args: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context: ExecutionContext,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next_resolver: Callable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute a field with directive middleware wrapping\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Collect all directives attached to this field definition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Sort directives by their declared execution order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create execution chain: directive1 → directive2 → ... → resolver</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Execute the chain and return result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle errors from directive execution with proper error propagation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _create_directive_wrapper</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        directive: GraphQLDirective,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handler: Callable,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next_fn: Callable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Callable:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a wrapper function that executes a directive\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract directive arguments from directive definition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create closure that captures directive context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return function that: </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Calls handler with appropriate parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Passes result to next_fn in chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Handles exceptions according to directive configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Subscription Transport Skeleton (Core Logic TODOs):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># extensions/subscriptions/transport/websocket.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"WebSocket transport for GraphQL subscriptions\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> websockets.server </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> WebSocketServerProtocol</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WebSocketTransport</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"WebSocket-based transport for GraphQL subscriptions\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, execution_context_factory: Callable):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store execution context factory for creating per-connection contexts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize connection tracking dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set up message handlers for different GraphQL over WebSocket protocols</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_connection</span><span style=\"color:#E1E4E8\">(self, websocket: WebSocketServerProtocol) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle a new WebSocket connection\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate unique connection ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store connection in active connections registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Send connection_init acknowledgement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Enter message handling loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: On connection_close message or disconnect, clean up resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_message</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        connection_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle incoming WebSocket message\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse message type (connection_init, start, stop, connection_terminate)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For \"start\" messages: parse GraphQL operation, validate for subscriptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create subscription execution, store subscription ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return appropriate response based on protocol specification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle errors with proper error response format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> send_data</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        connection_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send subscription data to client\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Look up WebSocket connection by connection_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Format data according to GraphQL over WebSocket specification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Send data message with subscription_id and payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle send errors (connection closed, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-python\">Language-Specific Hints for Python</h4>\n<ol>\n<li><p><strong>Use <code>__init_subclass__</code> for Plugin Registration</strong>: Python 3.6+ supports <code>__init_subclass__</code> which can automatically register plugin classes without explicit registration calls.</p>\n</li>\n<li><p><strong>Leverage <code>contextvars</code> for Request-Scoped Data</strong>: For directive middleware that needs request-scoped context, use <code>contextvars</code> instead of thread locals for proper async support.</p>\n</li>\n<li><p><strong>Use <code>dataclasses</code> for Configuration Objects</strong>: Future extension configurations should use <code>@dataclass</code> for type safety and clean initialization.</p>\n</li>\n<li><p><strong>Implement <code>__slots__</code> for Performance-Critical Types</strong>: Extension data structures that are instantiated frequently should use <code>__slots__</code> to reduce memory overhead.</p>\n</li>\n<li><p><strong>Use <code>asyncio.Queue</code> for Subscription Events</strong>: For subscription implementations, <code>asyncio.Queue</code> provides a clean pattern for buffering events between database change detection and client delivery.</p>\n</li>\n</ol>\n<h4 id=\"extension-milestone-checkpoint\">Extension Milestone Checkpoint</h4>\n<p>After implementing the extension infrastructure (not the full extensions), verify the system still functions correctly:</p>\n<ol>\n<li><strong>Run Existing Tests</strong>: Execute the full test suite to ensure no regression:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   python -m pytest tests/ -v</code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Verify Plugin Loading</strong>: Test that plugins can be registered and initialized:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # test_plugin_loading.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> extensions.plugins.registry </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> plugin_registry, GraphQLEnginePlugin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> TestPlugin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">GraphQLEnginePlugin</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">           super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test-plugin\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       def</span><span style=\"color:#B392F0\"> configure_schema</span><span style=\"color:#E1E4E8\">(self, schema):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">           print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"TestPlugin configuring schema: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">schema</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           return</span><span style=\"color:#E1E4E8\"> schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Register and test</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   plugin_registry.register(TestPlugin())</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Registered plugins: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">plugin_registry.list_plugins()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Check Directive Hook Integration</strong>: Verify directives can be attached to schema types:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # test_directive_hooks.py</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   schema </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_schema(</span><span style=\"color:#79B8FF\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should be able to attach directives without errors</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Monitor Performance Impact</strong>: Run performance benchmarks to ensure extension infrastructure doesn&#39;t degrade performance:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   python benchmarks/query_performance.py --baseline</code></pre></div>\n\n<p><strong>Expected Behavior</strong>:</p>\n<ul>\n<li>All existing tests pass without modification</li>\n<li>Plugin registration and initialization logs appropriate messages</li>\n<li>Schema creation with directive annotations succeeds</li>\n<li>Performance impact is &lt;5% for non-extension use cases</li>\n</ul>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>Existing tests fail after adding extension infrastructure → Likely caused by side effects in plugin initialization</li>\n<li>Schema building fails with directive annotations → Directive integration not properly isolated</li>\n<li>Significant performance degradation → Extension hooks adding overhead in hot paths</li>\n</ul>\n<h4 id=\"debugging-extension-implementation\">Debugging Extension Implementation</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plugins not loading</td>\n<td>Entrypoint name mismatch or missing dependency</td>\n<td>Check plugin registry logs, verify <code>setup.py</code> entrypoints</td>\n<td>Correct entrypoint name, ensure package is installed</td>\n</tr>\n<tr>\n<td>Directive not executing</td>\n<td>Directive not registered or middleware not connected</td>\n<td>Add debug logging to directive middleware, check execution context</td>\n<td>Register directive handler, ensure middleware is in execution chain</td>\n</tr>\n<tr>\n<td>Subscription connections dropping</td>\n<td>WebSocket protocol violation or timeout</td>\n<td>Monitor WebSocket frames, check for keepalive messages</td>\n<td>Implement proper ping/pong, adjust timeout settings</td>\n</tr>\n<tr>\n<td>Cache returning stale data</td>\n<td>Cache invalidation not triggered by mutations</td>\n<td>Log cache operations, check invalidation triggers</td>\n<td>Connect mutation execution to cache invalidation system</td>\n</tr>\n<tr>\n<td>Schema stitching type conflicts</td>\n<td>Type merging logic too restrictive</td>\n<td>Log type merging decisions, examine conflict details</td>\n<td>Implement type namespacing or field renaming strategies</td>\n</tr>\n<tr>\n<td>Performance degradation with extensions</td>\n<td>Extension hooks in hot paths</td>\n<td>Profile execution with and without extensions, identify bottlenecks</td>\n<td>Optimize extension hooks, add conditional execution</td>\n</tr>\n<tr>\n<td>Memory leak with plugins</td>\n<td>Plugin resources not cleaned up</td>\n<td>Monitor memory usage, check plugin teardown methods</td>\n<td>Ensure all plugins implement proper teardown, use weak references</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: The most successful extension systems evolve from actual needs rather than hypothetical ones. Implement the minimal extension infrastructure needed for known requirements, then extend as real use cases emerge. The architecture should make common extensions easy and complex extensions possible, without making the simple case complex.</p>\n</blockquote>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This glossary section spans all five milestones, providing definitions for key terms used throughout the design document. Understanding this vocabulary is essential for navigating the technical concepts, data structures, and implementation patterns across all components.</p>\n</blockquote>\n<p>This glossary defines the specialized terminology, acronyms, and domain vocabulary used throughout the GraphQL engine design document. Terms are organized by conceptual domain (GraphQL, database, compiler) to help you quickly locate definitions when encountering unfamiliar concepts in the implementation guidance or design discussions.</p>\n<h3 id=\"graphql-terminology\">GraphQL Terminology</h3>\n<p>GraphQL-specific terms that describe the query language, type system, and execution model.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Abstract Syntax Tree (AST)</strong></td>\n<td>A hierarchical, tree-shaped data structure that represents the grammatical structure of a GraphQL query after parsing. Each node in the tree corresponds to a construct in the query language (operation, field, argument, fragment). The AST serves as the intermediate representation between the raw query string and the execution engine.</td>\n</tr>\n<tr>\n<td><strong>Resolver</strong></td>\n<td>A function responsible for fetching or computing the data for a specific GraphQL field. When the execution engine encounters a field in the selection set, it calls the resolver function with four arguments: parent object, arguments, context, and execution info. Resolvers can be synchronous or asynchronous and may fetch data from databases, APIs, or other sources.</td>\n</tr>\n<tr>\n<td><strong>Introspection</strong></td>\n<td>In GraphQL, this refers to the built-in capability to query the schema itself. Clients can send introspection queries (using fields like <code>__schema</code>, <code>__type</code>) to discover what types, fields, and operations are available. In the database context, introspection refers to querying the database&#39;s system catalog (like <code>information_schema</code>) to discover tables, columns, and relationships.</td>\n</tr>\n<tr>\n<td><strong>Selection Set</strong></td>\n<td>The set of fields requested within a GraphQL operation or fragment. Represented as curly braces <code>{}</code> containing field selections, it defines the shape of the response data. Selection sets can be nested: each field that returns an object type may have its own selection set. The execution engine recursively processes selection sets to build the response tree.</td>\n</tr>\n<tr>\n<td><strong>Fragment</strong></td>\n<td>A reusable unit of GraphQL selection sets. <strong>Named fragments</strong> (<code>fragment UserFields on User { ... }</code>) are defined once and can be spread multiple times using <code>...UserFields</code>. <strong>Inline fragments</strong> (<code>... on User { ... }</code>) are anonymous and include a type condition. Fragments allow clients to avoid repeating complex selections and enable polymorphic queries on interfaces and unions.</td>\n</tr>\n<tr>\n<td><strong>Directive</strong></td>\n<td>An annotation in GraphQL queries or schemas that modifies execution behavior. Directives are prefixed with <code>@</code> and can have arguments. <strong>Query directives</strong> (like <code>@include</code>, <code>@skip</code>) control field inclusion at runtime. <strong>Schema directives</strong> (like <code>@deprecated</code>) provide metadata about schema elements. Custom directives can implement authorization, formatting, or other custom logic.</td>\n</tr>\n<tr>\n<td><strong>Operation</strong></td>\n<td>A single, named unit of work in a GraphQL document. There are three types: <strong>query</strong> (read operation), <strong>mutation</strong> (write operation), and <strong>subscription</strong> (real-time updates). Each document can contain multiple operations, but only one is executed per request (identified by the <code>operationName</code>).</td>\n</tr>\n<tr>\n<td><strong>Variable</strong></td>\n<td>A named placeholder in a GraphQL operation that gets replaced with values at execution time. Variables are defined in the operation header (<code>query($id: ID!)</code>) and referenced within the query body (<code>user(id: $id)</code>). This allows clients to parameterize queries without string concatenation.</td>\n</tr>\n<tr>\n<td><strong>Type Condition</strong></td>\n<td>The <code>on Type</code> part of a fragment that specifies which object type the fragment applies to. Inline fragments and fragment definitions must include a type condition. During execution, the fragment&#39;s selection set is only included if the runtime object type matches the type condition (for interfaces/unions) or is assignable to it.</td>\n</tr>\n<tr>\n<td><strong>Type System</strong></td>\n<td>The complete collection of GraphQL type definitions (<code>ObjectType</code>, <code>ScalarType</code>, <code>InterfaceType</code>, etc.) and the rules that govern their relationships and validity. The type system defines what queries are valid, what shape responses take, and how values are coerced. It serves as a contract between client and server.</td>\n</tr>\n<tr>\n<td><strong>Interface Implementation</strong></td>\n<td>The relationship where an <code>ObjectType</code> provides all the fields defined by an <code>InterfaceType</code>. An object type can implement multiple interfaces. The type system validates that implementing objects define all interface fields with compatible types. At runtime, interface fields are resolved by the concrete object&#39;s resolvers.</td>\n</tr>\n<tr>\n<td><strong>Type Modifier</strong></td>\n<td>A wrapper type that modifies another type&#39;s behavior. <strong><code>ListType</code></strong> indicates a list/array of values of the wrapped type. <strong><code>NonNullType</code></strong> indicates the wrapped type cannot be <code>null</code>. Modifiers can be nested (e.g., <code>[String!]!</code> means a non-null list of non-null strings).</td>\n</tr>\n<tr>\n<td><strong>Input Type</strong></td>\n<td>GraphQL types that can be used as arguments to fields or directives. Includes <code>ScalarType</code>, <code>EnumType</code>, <code>InputObjectType</code>, and modifiers thereof. Distinguished from output types because input types cannot have fields with arguments and cannot form cycles. The <code>is_input_type()</code> function checks this property.</td>\n</tr>\n<tr>\n<td><strong>Output Type</strong></td>\n<td>GraphQL types that can be returned by fields. Includes <code>ObjectType</code>, <code>InterfaceType</code>, <code>UnionType</code>, <code>ScalarType</code>, <code>EnumType</code>, and modifiers thereof. Output types can have fields with complex selection sets. The <code>is_output_type()</code> function checks this property.</td>\n</tr>\n<tr>\n<td><strong>Null Propagation</strong></td>\n<td>The GraphQL specification rule where if a non-null field (<code>String!</code>) resolves to <code>null</code>, that <code>null</code> propagates upward to the nearest nullable parent field, which becomes <code>null</code> in the response. This ensures type guarantees while allowing partial results. The <code>should_propagate_null()</code> function implements this logic.</td>\n</tr>\n<tr>\n<td><strong>Parallel Execution</strong></td>\n<td>The execution engine optimization where independent sibling fields (fields at the same depth under the same parent) are resolved concurrently when possible. This improves performance for resolvers that fetch from different data sources. The engine uses async/await or threads to coordinate parallel execution.</td>\n</tr>\n<tr>\n<td><strong>Partial Results</strong></td>\n<td>GraphQL&#39;s approach to error handling where fields that resolve successfully are included in the response alongside errors from failed fields. Unlike REST, where an error typically aborts the entire response, GraphQL can return partial data with errors appended. The <code>ExecutionResult</code> contains both <code>data</code> and <code>errors</code> fields.</td>\n</tr>\n<tr>\n<td><strong>Schema Stitching</strong></td>\n<td>The technique of combining multiple GraphQL schemas (potentially from different services) into a single unified schema. The gateway pattern uses schema stitching to create a single entry point for clients while delegating to underlying services. This is a future extension point in our architecture.</td>\n</tr>\n<tr>\n<td><strong>Subscription</strong></td>\n<td>A GraphQL operation that establishes a long-lived connection (typically WebSocket) to receive real-time updates when events occur. Unlike queries/mutations that are request-response, subscriptions push data to clients. Our design includes <code>WebSocketTransport</code> as a future extension for subscriptions.</td>\n</tr>\n<tr>\n<td><strong>Custom Directives</strong></td>\n<td>User-defined schema directives that extend GraphQL execution with custom logic. Directives can be attached to schema elements (types, fields, arguments) and can modify runtime behavior through execution hooks. Our architecture includes <code>DirectiveMiddleware</code> for implementing custom directives.</td>\n</tr>\n<tr>\n<td><strong>Query Caching</strong></td>\n<td>Storing and reusing the results of GraphQL queries to improve performance. Can be implemented at multiple levels: HTTP response caching, parsed AST caching, compiled SQL caching, or database result caching. The <code>CacheBackend</code> abstract class provides an extension point for caching strategies.</td>\n</tr>\n</tbody></table>\n<h3 id=\"database-terminology\">Database Terminology</h3>\n<p>Relational database concepts essential for schema reflection and SQL compilation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Foreign Key</strong></td>\n<td>A database constraint that links a column or set of columns in one table (<code>child</code>) to the primary key columns of another table (<code>parent</code>). Foreign keys enforce referential integrity and define relationships between tables. During schema reflection, foreign keys are detected to generate GraphQL field relationships between types.</td>\n</tr>\n<tr>\n<td><strong>JOIN</strong></td>\n<td>A SQL operation that combines rows from two or more tables based on a related column between them. <strong>INNER JOIN</strong> returns rows with matching values in both tables. <strong>LEFT JOIN</strong> returns all rows from the left table with matching rows from the right (or NULLs if no match). The SQL compiler translates nested GraphQL fields into appropriate JOIN clauses.</td>\n</tr>\n<tr>\n<td><strong>Parameterization</strong></td>\n<td>The practice of using placeholders (<code>$1</code>, <code>?</code>, <code>%s</code>) in SQL statements instead of directly embedding values. Parameters are bound separately, preventing SQL injection attacks and allowing query plan reuse. Our <code>SQLBuilder</code> class automatically parameterizes values from GraphQL arguments in the <code>SQLParameter</code> structures.</td>\n</tr>\n<tr>\n<td><strong>N+1 Problem</strong></td>\n<td>A performance anti-pattern where an initial query fetches N parent records, then N additional queries (one per parent) fetch related child records. GraphQL naive execution often causes N+1 queries. Our engine prevents this through SQL JOIN compilation (single query) or DataLoader batching (batched queries).</td>\n</tr>\n<tr>\n<td><strong>Cartesian Product</strong></td>\n<td>The result of joining two or more tables without a join condition, producing all possible combinations of rows. Cartesian products explode result sizes (m × n rows) and indicate missing JOIN conditions. The SQL compiler must ensure every JOIN has an appropriate <code>ON</code> clause based on foreign keys.</td>\n</tr>\n<tr>\n<td><strong>LATERAL JOIN</strong></td>\n<td>A specialized SQL join (available in PostgreSQL, MySQL 8+) that allows a subquery in the JOIN to reference columns from preceding tables. Useful for efficiently resolving one-to-many relationships with limits/ordering per parent. The compiler may use LATERAL JOINs for nested collections with pagination.</td>\n</tr>\n<tr>\n<td><strong>Cursor Pagination</strong></td>\n<td>A pagination technique using opaque cursors (typically encoded row values) instead of numeric offsets. Cursors provide stable pagination across data changes (insertions/deletions). Our engine generates cursor-based pagination with <code>before</code>/<code>after</code> arguments that translate to SQL comparisons on indexed columns.</td>\n</tr>\n<tr>\n<td><strong>Result Mapper</strong></td>\n<td>A function that transforms flat SQL result rows (with joined columns from multiple tables) into the nested hierarchical structure expected by GraphQL. After executing a JOIN query, the result mapper walks the selection tree to reconstruct nested objects. It&#39;s part of the <code>SQLQuery</code> data structure.</td>\n</tr>\n<tr>\n<td><strong>Join Planning</strong></td>\n<td>The process of determining the optimal order and type of SQL JOINs to execute a GraphQL query. The planner analyzes relationship paths, estimates cardinalities, and avoids cartesian products. The <code>plan_joins()</code> function generates <code>JoinPlan</code> structures defining the join strategy.</td>\n</tr>\n<tr>\n<td><strong>System Catalog</strong></td>\n<td>Database-internal tables that store metadata about the database structure. In PostgreSQL: <code>pg_catalog</code>; in SQL-standard databases: <code>information_schema</code>. Schema reflection queries these catalogs to discover tables, columns, constraints, and relationships.</td>\n</tr>\n<tr>\n<td><strong>Foreign Key Constraint</strong></td>\n<td>The formal database object that enforces a foreign key relationship. Contains source table/columns, target table/columns, and referential actions (<code>ON DELETE CASCADE</code>). The <code>RelationshipAnalyzer</code> examines these constraints to build <code>Relationship</code> metadata.</td>\n</tr>\n<tr>\n<td><strong>Cardinality</strong></td>\n<td>The numerical relationship between tables in a database. <strong>One-to-one</strong>: Each parent row relates to at most one child row. <strong>One-to-many</strong>: Each parent relates to many children. <strong>Many-to-many</strong>: Requires a junction table. The analyzer detects cardinality via unique constraints and foreign key directions.</td>\n</tr>\n<tr>\n<td><strong>Diamond Relationship</strong></td>\n<td>A query pattern where the same table is accessed via multiple paths in a single GraphQL query (e.g., <code>{ user { friends { posts }, posts } }</code> where <code>posts</code> appears through two paths). The SQL compiler must use table aliases to avoid column name conflicts when joining the same table multiple times.</td>\n</tr>\n<tr>\n<td><strong>Polymorphic Relationship</strong></td>\n<td>A database pattern where different rows in a table may reference different target tables (similar to GraphQL interfaces/unions). Implemented with a type discriminator column and multiple foreign key columns (only one populated per row). This maps naturally to GraphQL interface/union types.</td>\n</tr>\n<tr>\n<td><strong>Composite Primary Key</strong></td>\n<td>A primary key consisting of multiple columns rather than a single column. Common in junction tables and certain domain models. Schema reflection must handle composite keys when generating ID arguments and JOIN conditions (matching multiple columns).</td>\n</tr>\n<tr>\n<td><strong>Impedance Mismatch</strong></td>\n<td>The structural differences between GraphQL&#39;s hierarchical, graph-like data model and relational databases&#39; tabular, set-based model. Our engine bridges this mismatch by translating nested selections to JOINs and hierarchical results to nested JSON.</td>\n</tr>\n<tr>\n<td><strong>EXPLAIN Plan</strong></td>\n<td>Database command (<code>EXPLAIN SELECT ...</code>) that shows the query execution plan—how the database will execute the SQL, including index usage, join algorithms, and cost estimates. Our <code>SQLExplainer</code> class runs EXPLAIN on generated queries to diagnose performance issues.</td>\n</tr>\n<tr>\n<td><strong>Index Hint</strong></td>\n<td>A directive to the database optimizer suggesting which index to use for a query. Some databases support syntax like <code>USE INDEX (index_name)</code>. The compiler could add index hints based on GraphQL filter arguments to improve performance (future extension).</td>\n</tr>\n<tr>\n<td><strong>Stored Procedure</strong></td>\n<td>A precompiled collection of SQL statements stored in the database. Could be used as an alternative to dynamic SQL generation for common query patterns. Our architecture could extend to call stored procedures for certain GraphQL operations.</td>\n</tr>\n<tr>\n<td><strong>Transaction Isolation</strong></td>\n<td>Database property defining how concurrent transactions see each other&#39;s changes. Levels include READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE. The execution engine could wrap GraphQL mutations in transactions with appropriate isolation levels.</td>\n</tr>\n<tr>\n<td><strong>Connection Pool</strong></td>\n<td>A cache of database connections maintained so they can be reused, reducing connection establishment overhead. The execution engine would typically use a connection pool rather than creating new connections for each GraphQL request.</td>\n</tr>\n</tbody></table>\n<h3 id=\"compiler-terminology\">Compiler Terminology</h3>\n<p>Compiler concepts used in parsing, AST transformation, and query optimization.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Lexer</strong></td>\n<td>Also called a <strong>tokenizer</strong>, this component breaks a source string (GraphQL query) into a sequence of <strong>tokens</strong>—the smallest meaningful units (keywords, identifiers, punctuation, literals). The <code>Tokenizer.tokenize()</code> method implements the lexer, producing <code>Token</code> objects with type, value, and location.</td>\n</tr>\n<tr>\n<td><strong>Parser</strong></td>\n<td>The component that analyzes the token sequence according to GraphQL grammar rules and builds an <strong>Abstract Syntax Tree (AST)</strong>. Our implementation uses <strong>recursive descent parsing</strong>, where each grammar rule corresponds to a function that may call itself recursively. The <code>Parser.parse_document()</code> method is the entry point.</td>\n</tr>\n<tr>\n<td><strong>Token</strong></td>\n<td>A single lexical unit from the source text, classified by <code>TokenType</code> (NAME, INT, STRING, PUNCTUATION, etc.). Each token has a <code>value</code> (the actual text) and <code>line</code>/<code>column</code> location for error reporting. The parser consumes tokens sequentially to construct the AST.</td>\n</tr>\n<tr>\n<td><strong>Intermediate Representation (IR)</strong></td>\n<td>A data structure that serves as an intermediate form between the source (GraphQL) and target (SQL). Our engine has multiple IRs: the AST (<code>Document</code>), execution plan, and <code>SQLQuery</code> structures. IRs are optimized and transformed before final code generation.</td>\n</tr>\n<tr>\n<td><strong>Optimization</strong></td>\n<td>The process of improving the efficiency of compiled code (SQL) without changing its semantics. Our SQL compiler performs optimizations like: eliminating unnecessary JOINs, pushing filters down, merging similar selections, and choosing optimal JOIN orders.</td>\n</tr>\n<tr>\n<td><strong>Traversal</strong></td>\n<td>The systematic visiting of nodes in a tree (AST) or graph. <strong>Depth-first traversal</strong> visits child nodes before siblings; <strong>breadth-first</strong> visits siblings before children. Our engine uses recursive traversal for: validating schemas, executing selection sets, and compiling selections to SQL.</td>\n</tr>\n<tr>\n<td><strong>Recursive Descent</strong></td>\n<td>A parsing technique where each non-terminal in the grammar corresponds to a function that may recursively call other non-terminal functions. Our parser uses recursive descent for its simplicity, error recovery, and good error messages—ideal for GraphQL&#39;s LL(1) grammar.</td>\n</tr>\n<tr>\n<td><strong>Lookahead</strong></td>\n<td>Examining upcoming tokens without consuming them, used to decide which parsing path to take. A <strong>lookahead of k</strong> means peeking at the next k tokens. GraphQL&#39;s grammar requires at most 1 token of lookahead (LL(1)), simplifying the parser implementation.</td>\n</tr>\n<tr>\n<td><strong>Syntax Error</strong></td>\n<td>An error in the query structure that violates GraphQL grammar rules (e.g., missing closing brace, unexpected token). The parser detects syntax errors and reports them with <code>GraphQLSyntaxError</code>, including <code>line</code> and <code>column</code> location from the <code>Token</code>.</td>\n</tr>\n<tr>\n<td><strong>Escape Sequence</strong></td>\n<td>In string literals, a backslash (<code>\\</code>) followed by characters with special meaning: <code>\\n</code> (newline), <code>\\t</code> (tab), <code>\\uXXXX</code> (Unicode code point). The lexer must recognize and properly decode escape sequences in <code>StringValue</code> tokens.</td>\n</tr>\n<tr>\n<td><strong>Block String</strong></td>\n<td>A triple-quoted string (<code>&quot;&quot;&quot;content&quot;&quot;&quot;</code>) in GraphQL that preserves newlines and allows unescaped quotes. Block strings have special whitespace handling: common leading indentation is removed. The lexer has a separate <code>TokenType.BLOCK_STRING</code> for these.</td>\n</tr>\n<tr>\n<td><strong>Fragment Spread</strong></td>\n<td>The syntax <code>...FragmentName</code> that references a previously defined named fragment. The parser must verify the fragment is defined and expand its selection set into the current location. Represented by the <code>FragmentSpread</code> AST node.</td>\n</tr>\n<tr>\n<td><strong>Inline Fragment</strong></td>\n<td>The syntax <code>... on Type { selection }</code> that defines an anonymous fragment with a type condition. Unlike fragment spreads, inline fragments don&#39;t have separate definitions. Represented by the <code>InlineFragment</code> AST node.</td>\n</tr>\n<tr>\n<td><strong>Backtracking</strong></td>\n<td>A parsing technique where the parser tentatively follows one production, and if it fails, rolls back to try an alternative. GraphQL&#39;s grammar is designed to avoid backtracking through careful token lookahead, making the parser more efficient and predictable.</td>\n</tr>\n<tr>\n<td><strong>Grammar Production</strong></td>\n<td>A rule in the formal grammar defining how symbols can be replaced. Example: <code>SelectionSet → { Selection* }</code>. Our parser implements each production as a method (<code>parse_selection_set()</code>) that consumes tokens according to the rule.</td>\n</tr>\n<tr>\n<td><strong>Left Recursion</strong></td>\n<td>A grammar pattern where a non-terminal appears as the first symbol of its own production (e.g., <code>Expression → Expression + Term</code>). Left recursion causes infinite loops in naive recursive descent parsers; GraphQL&#39;s grammar avoids left recursion.</td>\n</tr>\n<tr>\n<td><strong>Parse Tree</strong></td>\n<td>A detailed tree representation of how the grammar productions derive the input string. More detailed than AST, containing every syntactic detail. Our parser builds an AST (abstract) rather than a full parse tree, omitting irrelevant syntactic details.</td>\n</tr>\n<tr>\n<td><strong>Visitor Pattern</strong></td>\n<td>A design pattern for traversing complex structures (like ASTs) where operations are separated from structure traversal. A visitor interface has <code>visit_*</code> methods for each node type. Useful for validation, transformation, and code generation phases.</td>\n</tr>\n<tr>\n<td><strong>Symbol Table</strong></td>\n<td>A data structure used by compilers to track information about identifiers (types, fields, variables). In our engine, the schema acts as a symbol table mapping type names to <code>GraphQLType</code> objects. Variable definitions are tracked during parsing/validation.</td>\n</tr>\n<tr>\n<td><strong>Static Single Assignment (SSA)</strong></td>\n<td>A compiler intermediate representation where each variable is assigned exactly once. Not used directly in our GraphQL compiler, but similar principles apply to ensuring field aliases and JOIN aliases are unique in generated SQL.</td>\n</tr>\n<tr>\n<td><strong>Code Generation</strong></td>\n<td>The final compiler phase that produces target code (SQL) from the optimized intermediate representation. Our <code>SQLBuilder</code> class handles code generation, producing parameterized SQL strings from <code>SQLQuery</code> structures.</td>\n</tr>\n<tr>\n<td><strong>Peephole Optimization</strong></td>\n<td>Local optimizations that examine small sequences of instructions (or SQL fragments) and replace them with more efficient sequences. Could be applied to generated SQL (e.g., simplifying <code>WHERE 1=1</code> or removing redundant conditions).</td>\n</tr>\n<tr>\n<td><strong>Constant Folding</strong></td>\n<td>Evaluating constant expressions at compile time rather than runtime. In GraphQL, this could involve evaluating literal arguments during compilation rather than passing them as SQL parameters (but must respect security boundaries).</td>\n</tr>\n<tr>\n<td><strong>Dead Code Elimination</strong></td>\n<td>Removing code that cannot be reached or whose results are never used. In our context, this could involve removing unused fields from selections (though GraphQL explicitly requests fields, so this is less applicable).</td>\n</tr>\n<tr>\n<td><strong>Inlining</strong></td>\n<td>Replacing a function call (or fragment spread) with the body of the function/fragment. Our parser performs fragment inlining early, expanding <code>FragmentSpread</code> nodes into their constituent selections during query preparation.</td>\n</tr>\n<tr>\n<td><strong>Abstract Syntax Tree (AST) Visualization</strong></td>\n<td>A human-readable display of the AST structure, useful for debugging. Our <code>ASTPrinter</code> class provides <code>print_document()</code>, <code>print_field()</code>, etc., methods that output indented text representations of the AST.</td>\n</tr>\n<tr>\n<td><strong>Resolving</strong></td>\n<td>In compilers, the process of mapping names to their definitions. In our engine: <strong>type resolving</strong> maps type names in the AST to <code>GraphQLType</code> objects; <strong>field resolving</strong> maps field names to <code>GraphQLField</code> definitions; <strong>fragment resolving</strong> maps fragment names to <code>FragmentDefinition</code> nodes.</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Implementation Note:</strong> This glossary section doesn&#39;t require implementation code, but understanding these terms is critical for reading and implementing the other components. The tables above serve as a reference you can consult while working through the milestones.</p>\n</blockquote>\n<h4 id=\"language-specific-terminology-notes\">Language-Specific Terminology Notes</h4>\n<ul>\n<li><strong>Python-specific</strong>: When implementing in Python, note that our type definitions use Python&#39;s <code>typing</code> module for type hints. The <code>@dataclass</code> decorator is commonly used for AST nodes and data structures. Async/await is used for asynchronous resolvers and parallel execution.</li>\n<li><strong>Go-specific</strong> (if implementing in Go): Go&#39;s strong typing and interfaces align well with GraphQL&#39;s type system. Use structs for AST nodes with embedded types for inheritance-like behavior. Channels and goroutines enable parallel execution.</li>\n<li><strong>Rust-specific</strong> (if implementing in Rust): Rust&#39;s enum types with associated data are ideal for representing AST nodes and GraphQL types. The ownership model ensures safe concurrent execution. Traits can define interfaces for resolvers and data loaders.</li>\n</ul>\n<h4 id=\"terminology-usage-checklist\">Terminology Usage Checklist</h4>\n<p>Before starting implementation, ensure you understand these key concept clusters:</p>\n<ol>\n<li><strong>AST Construction</strong>: Token → Lexer → Parser → Recursive Descent → Abstract Syntax Tree</li>\n<li><strong>Type System</strong>: Scalar/Object/Interface/Union/Enum → Input/Output Types → Type Modifiers (List/NonNull)</li>\n<li><strong>Execution</strong>: Resolver → Selection Set → Parallel Execution → Null Propagation → Partial Results</li>\n<li><strong>Database Reflection</strong>: System Catalog → Foreign Key → Cardinality → Type Mapping → Naming Convention</li>\n<li><strong>SQL Compilation</strong>: JOIN → Parameterization → N+1 Problem → Cartesian Product → Result Mapper</li>\n</ol>\n<h4 id=\"quick-reference-table\">Quick Reference Table</h4>\n<p>For easy lookup during implementation, here&#39;s a condensed table of the most frequently used terms:</p>\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Key Terms</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>AST Nodes</strong></td>\n<td><code>Document</code>, <code>OperationDefinition</code>, <code>SelectionSet</code>, <code>Field</code>, <code>FragmentSpread</code>, <code>Argument</code>, <code>Directive</code></td>\n</tr>\n<tr>\n<td><strong>Type System</strong></td>\n<td><code>GraphQLType</code>, <code>ObjectType</code>, <code>ScalarType</code>, <code>InterfaceType</code>, <code>UnionType</code>, <code>EnumType</code>, <code>InputObjectType</code></td>\n</tr>\n<tr>\n<td><strong>Execution</strong></td>\n<td><code>Resolver</code>, <code>ExecutionContext</code>, <code>DataLoader</code>, <code>ExecutionResult</code>, <code>GraphQLError</code>, <code>PathSegment</code></td>\n</tr>\n<tr>\n<td><strong>SQL Compilation</strong></td>\n<td><code>SQLQuery</code>, <code>SQLSelect</code>, <code>SQLJoin</code>, <code>SQLParameter</code>, <code>JoinPlan</code>, <code>ResultMapper</code></td>\n</tr>\n<tr>\n<td><strong>Database</strong></td>\n<td><code>DatabaseMetadata</code>, <code>TableMetadata</code>, <code>ColumnMetadata</code>, <code>Relationship</code>, <code>ForeignKey</code>, <code>Cardinality</code></td>\n</tr>\n</tbody></table>\n<p>Remember that all these terms map to concrete Python classes and functions defined in the Naming Conventions section. When you encounter an unfamiliar term in the codebase, refer back to this glossary for its definition and context.</p>\n","toc":[{"level":1,"text":"Build Your Own GraphQL Engine: Design Document","id":"build-your-own-graphql-engine-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: Restaurant Menu vs. Kitchen","id":"mental-model-restaurant-menu-vs-kitchen"},{"level":3,"text":"The GraphQL-Database Translation Problem","id":"the-graphql-database-translation-problem"},{"level":4,"text":"Concrete Example: The N+1 Query Problem","id":"concrete-example-the-n1-query-problem"},{"level":4,"text":"Architecture Decision: Translation Strategy","id":"architecture-decision-translation-strategy"},{"level":3,"text":"Existing Solutions Comparison","id":"existing-solutions-comparison"},{"level":4,"text":"Hasura: Declarative Configuration Engine","id":"hasura-declarative-configuration-engine"},{"level":4,"text":"PostGraphile: Reflection-Driven with Plugins","id":"postgraphile-reflection-driven-with-plugins"},{"level":4,"text":"Custom Implementation (Apollo/GraphQL-JS)","id":"custom-implementation-apollographql-js"},{"level":4,"text":"Our Educational Approach","id":"our-educational-approach"},{"level":4,"text":"Why Build From Scratch?","id":"why-build-from-scratch"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Must-Have Requirements","id":"must-have-requirements"},{"level":3,"text":"Quality Attributes","id":"quality-attributes"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"System Component Diagram","id":"system-component-diagram"},{"level":4,"text":"Component Interactions and Data Flow","id":"component-interactions-and-data-flow"},{"level":3,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Module Responsibilities and Public Interfaces","id":"module-responsibilities-and-public-interfaces"},{"level":3,"text":"End-to-End Data Flow","id":"end-to-end-data-flow"},{"level":4,"text":"Step-by-Step Data Transformation Pipeline","id":"step-by-step-data-transformation-pipeline"},{"level":4,"text":"Concrete Walk-Through Example","id":"concrete-walk-through-example"},{"level":4,"text":"Data Formats at Each Stage","id":"data-formats-at-each-stage"},{"level":4,"text":"Common Pitfalls in Data Flow Design","id":"common-pitfalls-in-data-flow-design"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended Starter Project Structure","id":"b-recommended-starter-project-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Pipeline Skeleton Code","id":"d-core-pipeline-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints for Python","id":"e-language-specific-hints-for-python"},{"level":4,"text":"F. Milestone Checkpoint for High-Level Architecture","id":"f-milestone-checkpoint-for-high-level-architecture"},{"level":4,"text":"G. Debugging Tips for Architecture Issues","id":"g-debugging-tips-for-architecture-issues"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"AST Node Types","id":"ast-node-types"},{"level":4,"text":"Core AST Node Hierarchy and Data Structures","id":"core-ast-node-hierarchy-and-data-structures"},{"level":3,"text":"Type System Types","id":"type-system-types"},{"level":4,"text":"Type System Class Hierarchy and Data Structures","id":"type-system-class-hierarchy-and-data-structures"},{"level":3,"text":"Execution Context and State","id":"execution-context-and-state"},{"level":4,"text":"Execution State Data Structures","id":"execution-state-data-structures"},{"level":3,"text":"SQL Intermediate Representation","id":"sql-intermediate-representation"},{"level":4,"text":"SQL IR Data Structures","id":"sql-ir-data-structures"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints (Python)","id":"language-specific-hints-python"},{"level":4,"text":"Milestone Checkpoint for Data Model","id":"milestone-checkpoint-for-data-model"},{"level":2,"text":"Component 1: GraphQL Parser","id":"component-1-graphql-parser"},{"level":3,"text":"Responsibility and Scope","id":"responsibility-and-scope"},{"level":3,"text":"Mental Model: Language Translator","id":"mental-model-language-translator"},{"level":3,"text":"Parser Interface","id":"parser-interface"},{"level":3,"text":"Parsing Algorithm","id":"parsing-algorithm"},{"level":4,"text":"Phase 1: Lexical Analysis (Tokenizer)","id":"phase-1-lexical-analysis-tokenizer"},{"level":4,"text":"Phase 2: Syntactic Analysis (Parser)","id":"phase-2-syntactic-analysis-parser"},{"level":3,"text":"Architecture Decision: Parser Approach","id":"architecture-decision-parser-approach"},{"level":3,"text":"Common Parser Pitfalls","id":"common-parser-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"Component 2: Schema &amp; Type System","id":"component-2-schema-amp-type-system"},{"level":3,"text":"Responsibility and Scope","id":"responsibility-and-scope"},{"level":3,"text":"Mental Model: Building Inspector","id":"mental-model-building-inspector"},{"level":3,"text":"Type System Interface","id":"type-system-interface"},{"level":3,"text":"Schema Building Algorithm","id":"schema-building-algorithm"},{"level":3,"text":"Architecture Decision: Type Representation","id":"architecture-decision-type-representation"},{"level":3,"text":"Common Type System Pitfalls","id":"common-type-system-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Recommended File Structure","id":"a-recommended-file-structure"},{"level":4,"text":"B. Infrastructure Starter Code","id":"b-infrastructure-starter-code"},{"level":4,"text":"C. Core Logic Skeleton","id":"c-core-logic-skeleton"},{"level":4,"text":"D. Language-Specific Hints","id":"d-language-specific-hints"},{"level":4,"text":"E. Milestone Checkpoint","id":"e-milestone-checkpoint"},{"level":2,"text":"Component 3: Query Execution Engine","id":"component-3-query-execution-engine"},{"level":3,"text":"Responsibility and Scope","id":"responsibility-and-scope"},{"level":3,"text":"Mental Model: Assembly Line","id":"mental-model-assembly-line"},{"level":3,"text":"Execution Interface","id":"execution-interface"},{"level":3,"text":"Execution Algorithm","id":"execution-algorithm"},{"level":3,"text":"Architecture Decision: Execution Strategy","id":"architecture-decision-execution-strategy"},{"level":3,"text":"Common Execution Pitfalls","id":"common-execution-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"Component 4: Database Schema Reflection","id":"component-4-database-schema-reflection"},{"level":3,"text":"Responsibility and Scope","id":"responsibility-and-scope"},{"level":3,"text":"Mental Model: Mirror","id":"mental-model-mirror"},{"level":3,"text":"Reflection Interface","id":"reflection-interface"},{"level":3,"text":"Reflection Algorithm","id":"reflection-algorithm"},{"level":3,"text":"Architecture Decision: Reflection Strategy","id":"architecture-decision-reflection-strategy"},{"level":3,"text":"Common Reflection Pitfalls","id":"common-reflection-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Component 5: Query to SQL Compilation","id":"component-5-query-to-sql-compilation"},{"level":3,"text":"Responsibility and Scope","id":"responsibility-and-scope"},{"level":3,"text":"Mental Model: Travel Planner","id":"mental-model-travel-planner"},{"level":3,"text":"Compiler Interface","id":"compiler-interface"},{"level":3,"text":"Compilation Algorithm","id":"compilation-algorithm"},{"level":3,"text":"Architecture Decision: Compilation Approach","id":"architecture-decision-compilation-approach"},{"level":3,"text":"Common Compilation Pitfalls","id":"common-compilation-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Happy Path: Query Execution Flow","id":"happy-path-query-execution-flow"},{"level":3,"text":"Schema Building and Reflection Flow","id":"schema-building-and-reflection-flow"},{"level":3,"text":"Message and Data Formats","id":"message-and-data-formats"},{"level":4,"text":"AST Nodes (Parser to Type System/Executor)","id":"ast-nodes-parser-to-type-systemexecutor"},{"level":4,"text":"Type System Structures (Schema Building)","id":"type-system-structures-schema-building"},{"level":4,"text":"Execution State (Executor Internal)","id":"execution-state-executor-internal"},{"level":4,"text":"SQL Intermediate Representation (Compiler to Database)","id":"sql-intermediate-representation-compiler-to-database"},{"level":4,"text":"Database Metadata (Reflection Internal)","id":"database-metadata-reflection-internal"},{"level":4,"text":"Data Transformation Pipeline","id":"data-transformation-pipeline"},{"level":4,"text":"Component Interface Summary","id":"component-interface-summary"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Error Categories and Handling","id":"error-categories-and-handling"},{"level":4,"text":"Error Classification and Handling Strategies","id":"error-classification-and-handling-strategies"},{"level":4,"text":"Parse Error Handling","id":"parse-error-handling"},{"level":4,"text":"Validation Error Handling","id":"validation-error-handling"},{"level":4,"text":"Execution Error Handling","id":"execution-error-handling"},{"level":4,"text":"Database Error Handling","id":"database-error-handling"},{"level":4,"text":"Error Response Format","id":"error-response-format"},{"level":3,"text":"Null and Optional Value Handling","id":"null-and-optional-value-handling"},{"level":4,"text":"Null Propagation Rules","id":"null-propagation-rules"},{"level":4,"text":"Database NULL to GraphQL Null Mapping","id":"database-null-to-graphql-null-mapping"},{"level":4,"text":"Optional Arguments and Default Values","id":"optional-arguments-and-default-values"},{"level":3,"text":"Edge Case Scenarios","id":"edge-case-scenarios"},{"level":4,"text":"Empty Selections and Minimal Queries","id":"empty-selections-and-minimal-queries"},{"level":4,"text":"Circular References","id":"circular-references"},{"level":4,"text":"Deeply Nested Queries","id":"deeply-nested-queries"},{"level":4,"text":"Large Results and Pagination Edge Cases","id":"large-results-and-pagination-edge-cases"},{"level":4,"text":"Type System Edge Cases","id":"type-system-edge-cases"},{"level":4,"text":"SQL Compilation Edge Cases","id":"sql-compilation-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Python-Specific Hints","id":"e-python-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Common Bugs Table","id":"common-bugs-table"},{"level":3,"text":"Debugging Techniques","id":"debugging-techniques"},{"level":4,"text":"AST Visualization","id":"ast-visualization"},{"level":4,"text":"SQL Logging","id":"sql-logging"},{"level":4,"text":"Resolver Tracing","id":"resolver-tracing"},{"level":4,"text":"Type Inspection","id":"type-inspection"},{"level":3,"text":"Tools and Diagnostic Approaches","id":"tools-and-diagnostic-approaches"},{"level":4,"text":"Debug Logging with Context Correlation","id":"debug-logging-with-context-correlation"},{"level":4,"text":"GraphiQL Integration for Interactive Testing","id":"graphiql-integration-for-interactive-testing"},{"level":4,"text":"Database Explain Plans for Query Optimization","id":"database-explain-plans-for-query-optimization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Planned Extension Points","id":"planned-extension-points"},{"level":4,"text":"Schema Stitching: Federating Multiple Data Sources","id":"schema-stitching-federating-multiple-data-sources"},{"level":4,"text":"Subscriptions: Real-Time Data Updates","id":"subscriptions-real-time-data-updates"},{"level":4,"text":"Custom Directives: Schema-Level Behavior Modification","id":"custom-directives-schema-level-behavior-modification"},{"level":4,"text":"Query Caching: Performance Optimization Layer","id":"query-caching-performance-optimization-layer"},{"level":3,"text":"Design Accommodations","id":"design-accommodations"},{"level":4,"text":"Extension Point Inventory","id":"extension-point-inventory"},{"level":4,"text":"Abstract Interface Design","id":"abstract-interface-design"},{"level":4,"text":"Schema Evolution Support","id":"schema-evolution-support"},{"level":4,"text":"Execution Pipeline Extensibility","id":"execution-pipeline-extensibility"},{"level":4,"text":"Database Abstraction Layer","id":"database-abstraction-layer"},{"level":4,"text":"Plugin System Architecture","id":"plugin-system-architecture"},{"level":4,"text":"Performance Monitoring Hooks","id":"performance-monitoring-hooks"},{"level":4,"text":"Security Extension Foundation","id":"security-extension-foundation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Plugin Directory Structure","id":"recommended-plugin-directory-structure"},{"level":4,"text":"Extension Infrastructure Starter Code","id":"extension-infrastructure-starter-code"},{"level":4,"text":"Language-Specific Hints for Python","id":"language-specific-hints-for-python"},{"level":4,"text":"Extension Milestone Checkpoint","id":"extension-milestone-checkpoint"},{"level":4,"text":"Debugging Extension Implementation","id":"debugging-extension-implementation"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"GraphQL Terminology","id":"graphql-terminology"},{"level":3,"text":"Database Terminology","id":"database-terminology"},{"level":3,"text":"Compiler Terminology","id":"compiler-terminology"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Language-Specific Terminology Notes","id":"language-specific-terminology-notes"},{"level":4,"text":"Terminology Usage Checklist","id":"terminology-usage-checklist"},{"level":4,"text":"Quick Reference Table","id":"quick-reference-table"}],"title":"Build Your Own GraphQL Engine: Design Document","markdown":"# Build Your Own GraphQL Engine: Design Document\n\n\n## Overview\n\nThis system builds a complete GraphQL execution engine that can parse GraphQL queries, reflect database schemas automatically, and compile queries to efficient SQL. The key architectural challenge is bridging the conceptual gap between GraphQL's hierarchical query model and relational databases' tabular structure while maintaining performance and type safety.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** This section provides foundational context for all milestones, establishing the problem domain and mental models that will guide the entire project.\n\nGraphQL has revolutionized API development by providing a declarative, client-driven query language that enables applications to request exactly the data they need. However, building a robust GraphQL execution engine—particularly one that efficiently bridges GraphQL queries to relational databases—is a complex undertaking requiring expertise across parsing, type systems, query execution, database introspection, and query compilation. This project addresses the educational gap between using GraphQL libraries and understanding their internals by building a complete, simplified GraphQL engine from the ground up.\n\n### Mental Model: Restaurant Menu vs. Kitchen\n\nImagine a restaurant with two distinct spaces: the **dining room** where customers order from a menu, and the **kitchen** where chefs prepare meals. This analogy perfectly captures the GraphQL engine architecture:\n\n- **GraphQL Query = Customer Order**: The customer (client) selects specific items from the menu (GraphQL schema) in a particular combination. They don't specify *how* the food should be prepared—just what they want in the final result. A GraphQL query similarly declares what data is needed without specifying how to fetch it from the database.\n\n- **GraphQL Schema = Restaurant Menu**: The menu defines all possible dishes (types) and their available customizations (fields with arguments). Some dishes require special preparation (resolvers), while others are simple combinations of existing items. The menu's structure determines what combinations are valid (type validation).\n\n- **GraphQL Engine = Kitchen System**: The kitchen receives the order and must:\n  1. **Parse the order** (Parser) - Understand exactly which dishes and modifications were requested\n  2. **Check inventory** (Type System) - Verify all ingredients (data types) are available and compatible\n  3. **Plan preparation** (Execution Engine) - Determine the optimal sequence of cooking steps (resolvers)\n  4. **Gather ingredients** (Schema Reflection) - Auto-discover what's in the pantry (database schema)\n  5. **Cook efficiently** (SQL Compilation) - Combine preparation steps to avoid redundant work (N+1 problem)\n\n> **Key Insight:** Just as a skilled kitchen can prepare multiple parts of an order in parallel (appetizers while entrees cook) and combine similar preparation steps (chopping all vegetables at once), a good GraphQL engine executes independent fields concurrently and batches related database operations.\n\n### The GraphQL-Database Translation Problem\n\nThe fundamental challenge in building a GraphQL engine lies in the **impedance mismatch** between GraphQL's hierarchical, graph-based query model and relational databases' tabular, set-based structure. This mismatch creates several specific technical challenges:\n\n| Challenge | GraphQL Perspective | Relational Database Perspective | Technical Consequence |\n|-----------|---------------------|---------------------------------|------------------------|\n| **Data Shape** | Nested objects with arbitrary depth | Flat tables with foreign key relationships | Requires JOINs or multiple queries to reconstruct hierarchy |\n| **Field Selection** | Client selects exact fields needed | SQL `SELECT *` fetches all columns | Must generate SQL with only requested columns to avoid over-fetching |\n| **Nullability** | Explicit non-null (`!`) types with propagation rules | NULL-able columns with three-valued logic | Must enforce GraphQL's strict null propagation, which differs from SQL semantics |\n| **Type System** | Strong, static types with interfaces and unions | Primitive types with constraints and referential integrity | Requires mapping SQL types to GraphQL scalars and enforcing type safety |\n| **Query Structure** | Recursive selection sets with fragments | Linear SQL statements with fixed structure | Must flatten nested selections into SQL JOIN hierarchy |\n\n#### Concrete Example: The N+1 Query Problem\n\nConsider a simple GraphQL query fetching blog posts with their authors:\n\n```graphql\nquery {\n  posts {\n    title\n    content\n    author {\n      name\n      email\n    }\n  }\n}\n```\n\nA naive implementation might execute:\n1. `SELECT id, title, content, author_id FROM posts` (1 query)\n2. For each post: `SELECT name, email FROM authors WHERE id = ?` (N queries)\n\nThis results in **N+1 queries** (1 for posts, N for authors). The engine must instead generate:\n\n```sql\nSELECT posts.title, posts.content, authors.name, authors.email\nFROM posts\nLEFT JOIN authors ON posts.author_id = authors.id\n```\n\nBut this becomes more complex with one-to-many relationships (comments on posts) requiring lateral joins or separate batched queries. The translation problem involves:\n- Analyzing the GraphQL AST to understand relationship patterns\n- Generating optimal SQL JOIN structures\n- Batching independent lookups using IN clauses\n- Maintaining type safety and nullability semantics\n\n#### Architecture Decision: Translation Strategy\n\n> **Decision: AST-to-SQL Direct Compilation**\n\n- **Context**: We need to translate GraphQL queries to database queries with minimal overhead. Three main approaches exist: resolver-per-field (naive N+1), batched resolvers with DataLoader, or direct AST-to-SQL compilation.\n- **Options Considered**:\n  1. **Resolver-per-field**: Each field has a resolver function; simple but leads to N+1 queries\n  2. **DataLoader pattern**: Resolvers request data, DataLoader batches similar requests; good for caching but adds abstraction layer\n  3. **Direct AST-to-SQL compilation**: Analyze the entire query, generate optimized SQL; complex but maximum performance\n- **Decision**: Direct AST-to-SQL compilation for the core engine, with optional DataLoader for custom resolvers\n- **Rationale**: \n  - Educational value: Compilation demonstrates query optimization principles clearly\n  - Performance: Single optimized SQL query minimizes round-trips\n  - Predictability: Deterministic SQL generation easier to debug than distributed resolver timing\n- **Consequences**:\n  - Must implement full query analysis and SQL generation\n  - Less flexible for custom business logic in resolvers\n  - Better for database-heavy applications, worse for microservice aggregation\n\n| Option | Pros | Cons | Why Chosen? |\n|--------|------|------|-------------|\n| Resolver-per-field | Simple to implement, flexible for custom logic | Severe N+1 problem, poor performance | Rejected for core engine (educational anti-pattern) |\n| DataLoader pattern | Good for microservices, handles caching | Added complexity, still multiple queries | Supplemental pattern for custom resolvers |\n| Direct compilation | Maximum performance, single query, deterministic | Complex implementation, less flexible | **Primary approach** - best for learning and performance |\n\n### Existing Solutions Comparison\n\nSeveral production GraphQL engines address the database translation problem with different architectures and trade-offs. Understanding these helps clarify our design choices and educational objectives.\n\n#### Hasura: Declarative Configuration Engine\n\nHasura takes a **declarative, metadata-driven approach**:\n- **Architecture**: PostgreSQL-focused, generates GraphQL schema from database metadata with fine-grained permissions\n- **Translation Strategy**: AST-to-SQL compilation with extensive optimizations (predicate pushdown, join elimination)\n- **Strengths**: \n  - Excellent performance through query compilation\n  - Real-time subscriptions via PostgreSQL LISTEN/NOTIFY\n  - Rich permission system declaratively configured\n- **Limitations**:\n  - Primarily PostgreSQL-only (though expanding)\n  - Limited custom business logic without external services\n  - Opinionated schema generation\n\n```sql\n-- Hasura internally generates SQL like this from GraphQL:\nSELECT json_agg(__root) FROM (\n  SELECT json_build_object(\n    'id', posts.id,\n    'title', posts.title,\n    'author', author_obj\n  ) AS __root\n  FROM posts\n  LEFT JOIN LATERAL (\n    SELECT json_build_object('name', authors.name) AS author_obj\n    FROM authors WHERE authors.id = posts.author_id\n  ) ON true\n) AS __root\n```\n\n#### PostGraphile: Reflection-Driven with Plugins\n\nPostGraphile uses **PostgreSQL reflection and convention-over-configuration**:\n- **Architecture**: Reflects database schema, uses PostgreSQL comments for metadata, plugin system for extensibility\n- **Translation Strategy**: Smart defaults with plugin-based query building\n- **Strengths**:\n  - Extremely fast schema generation from existing databases\n  - Customizable via plugin ecosystem\n  - Leverages PostgreSQL features (ROW SECURITY, etc.)\n- **Limitations**:\n  - PostgreSQL-specific\n  - Learning curve for customization\n  - Less control over exact GraphQL schema shape\n\n#### Custom Implementation (Apollo/GraphQL-JS)\n\nThe **resolver-based approach** used by most custom GraphQL servers:\n- **Architecture**: Manual schema definition, resolver functions for each field\n- **Translation Strategy**: Manual ORM/query calls within resolvers, DataLoader for batching\n- **Strengths**:\n  - Complete control over business logic\n  - Database-agnostic (works with any data source)\n  - Mature ecosystem (Apollo, GraphQL-JS)\n- **Limitations**:\n  - Manual N+1 optimization required\n  - Boilerplate code for common patterns\n  - Performance depends on developer discipline\n\n#### Our Educational Approach\n\nOur engine borrows concepts from all three but prioritizes **educational transparency**:\n\n| Aspect | Hasura (Production) | PostGraphile (Production) | Custom (Typical) | Our Engine (Educational) |\n|--------|---------------------|---------------------------|------------------|---------------------------|\n| **Schema Generation** | Metadata-driven | Reflection + conventions | Manual definition | **Reflection + explicit mapping** |\n| **Query Translation** | AST-to-SQL compiler | Plugin-based compilation | Resolver functions | **AST-to-SQL with visible steps** |\n| **Performance Focus** | Maximum optimization | Good defaults with plugins | Developer-dependent | **Optimized but transparent** |\n| **Learning Value** | Black box | Convention magic | Business logic focus | **White box with clear algorithms** |\n| **Database Support** | PostgreSQL-first | PostgreSQL-only | Any | **Adapter pattern with reference impl** |\n| **Custom Logic** | Remote schemas/actions | Plugin system | First-class | **Hybrid: compiled + resolver fallback** |\n\n> **Design Philosophy**: Our engine makes compilation steps explicit—learners can trace a GraphQL query through parsing, type checking, AST analysis, JOIN generation, and SQL parameterization. Where Hasura hides complexity for production simplicity, we expose it for learning.\n\n#### Why Build From Scratch?\n\nExisting solutions work well for production but obscure the underlying mechanics:\n\n1. **Abstraction Layers Hide Fundamentals**: Tools like Hasura generate SQL automatically, but developers don't learn *how* the translation works\n2. **Missing Mental Models**: Without understanding the compilation pipeline, debugging performance issues becomes guesswork\n3. **Educational Gap**: Tutorials focus on using GraphQL, not implementing execution engines\n4. **Customization Limitations**: When existing tools don't fit a use case, developers lack the foundation to build their own solutions\n\nThis project fills that gap by building a **pedagogical reference implementation** that:\n- Shows each transformation step explicitly\n- Provides extensibility points learners can modify\n- Includes common pitfalls and debugging guidance\n- Balances simplicity with real-world concerns\n\n### Implementation Guidance\n\n> **Note**: This section provides initial setup and mental model implementation. The detailed component implementations will follow in subsequent sections.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option | Why for This Project |\n|-----------|---------------|-----------------|----------------------|\n| **Language** | Python 3.9+ | Rust or Go | Python chosen for readability and educational accessibility |\n| **HTTP Server** | Flask (synchronous) | FastAPI (async) | Flask's simplicity reduces cognitive load for learning core concepts |\n| **Database** | SQLite (file-based) | PostgreSQL (production) | SQLite requires no setup, focuses on SQL generation not connection management |\n| **SQL Building** | String concatenation | SQLAlchemy Core | Starting with strings shows the raw SQL; can evolve to builder pattern |\n| **Testing** | unittest/pytest | pytest with async | unittest is standard library, sufficient for learning |\n| **Type Hints** | Basic type hints | mypy strict | Type hints improve readability without complexity |\n\n#### B. Recommended File/Module Structure\n\nCreate this directory structure from the beginning to maintain separation of concerns:\n\n```\ngraphql-engine/\n├── README.md\n├── pyproject.toml           # Python project configuration\n├── requirements.txt         # Dependencies\n├── src/\n│   ├── graphql_engine/\n│   │   ├── __init__.py\n│   │   ├── main.py          # HTTP server entry point\n│   │   ├── parser/          # Milestone 1\n│   │   │   ├── __init__.py\n│   │   │   ├── lexer.py     # Tokenizer\n│   │   │   ├── parser.py    # Recursive descent parser\n│   │   │   └── ast.py       # AST node definitions\n│   │   ├── type_system/     # Milestone 2\n│   │   │   ├── __init__.py\n│   │   │   ├── types.py     # GraphQL type classes\n│   │   │   ├── schema.py    # Schema construction/validation\n│   │   │   └── introspection.py\n│   │   ├── execution/       # Milestone 3\n│   │   │   ├── __init__.py\n│   │   │   ├── executor.py  # Query execution engine\n│   │   │   ├── resolvers.py # Default resolver logic\n│   │   │   └── dataloader.py# DataLoader implementation\n│   │   ├── reflection/      # Milestone 4\n│   │   │   ├── __init__.py\n│   │   │   ├── reflector.py # Database schema reflection\n│   │   │   ├── sql_types.py # SQL-to-GraphQL type mapping\n│   │   │   └── relationships.py\n│   │   ├── compilation/     # Milestone 5\n│   │   │   ├── __init__.py\n│   │   │   ├── compiler.py  # AST-to-SQL compiler\n│   │   │   ├── sql_builder.py\n│   │   │   └── query_plan.py\n│   │   └── utils/\n│   │       ├── __init__.py\n│   │       ├── errors.py    # Custom exception classes\n│   │       └── logging.py   # Debug logging helpers\n└── tests/\n    ├── __init__.py\n    ├── test_parser.py\n    ├── test_type_system.py\n    ├── test_execution.py\n    ├── test_reflection.py\n    └── test_compilation.py\n```\n\n#### C. Infrastructure Starter Code\n\nCreate a simple HTTP server that will accept GraphQL queries. This isn't the learning focus but is necessary to test the engine:\n\n```python\n# src/graphql_engine/main.py\n\"\"\"\nSimple HTTP server for the GraphQL engine.\nThis provides a test harness - the real learning is in the components.\n\"\"\"\nfrom flask import Flask, request, jsonify\nimport json\nfrom typing import Dict, Any\n\napp = Flask(__name__)\n\n# These will be implemented in later milestones\nfrom graphql_engine.parser import parse_query\nfrom graphql_engine.type_system import GraphQLSchema\nfrom graphql_engine.execution import execute_query\n\n# In-memory schema cache (will be populated via reflection)\nschema_cache: Dict[str, GraphQLSchema] = {}\n\n@app.route('/graphql', methods=['POST'])\ndef graphql_endpoint():\n    \"\"\"\n    Standard GraphQL HTTP endpoint.\n    Expects JSON with 'query' and optionally 'variables', 'operationName'.\n    \"\"\"\n    try:\n        data = request.get_json()\n        \n        if not data or 'query' not in data:\n            return jsonify({\n                'errors': [{'message': 'Must provide query parameter'}]\n            }), 400\n        \n        query = data['query']\n        variables = data.get('variables') or {}\n        operation_name = data.get('operationName')\n        \n        # TODO: In Milestone 4, this will reflect the database\n        # For now, use a placeholder schema\n        if 'default' not in schema_cache:\n            schema_cache['default'] = GraphQLSchema()  # Will be populated later\n        \n        schema = schema_cache['default']\n        \n        # Parse the query (Milestone 1)\n        document_ast = parse_query(query)\n        \n        # Execute the query (Milestone 3)\n        result = execute_query(\n            schema=schema,\n            document_ast=document_ast,\n            variable_values=variables,\n            operation_name=operation_name\n        )\n        \n        return jsonify(result)\n        \n    except Exception as e:\n        # TODO: Better error formatting based on error type\n        app.logger.exception(\"GraphQL execution error\")\n        return jsonify({\n            'errors': [{'message': str(e)}]\n        }), 500\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Simple health endpoint for deployment.\"\"\"\n    return jsonify({'status': 'healthy'})\n\nif __name__ == '__main__':\n    app.run(debug=True, port=5000)\n```\n\n#### D. Core Logic Skeleton Code\n\nHere's the initial AST structure that will be used throughout the engine. Learners will expand this in Milestone 1:\n\n```python\n# src/graphql_engine/parser/ast.py\n\"\"\"\nAbstract Syntax Tree node definitions for GraphQL.\nThese data structures represent parsed GraphQL queries.\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Dict, Any, Union\n\n@dataclass\nclass Location:\n    \"\"\"Source location for error reporting.\"\"\"\n    line: int\n    column: int\n    \n    def __str__(self) -> str:\n        return f\"line {self.line}, column {self.column}\"\n\n@dataclass\nclass Node:\n    \"\"\"Base class for all AST nodes.\"\"\"\n    loc: Optional[Location] = None  # Source location (optional in some cases)\n\n@dataclass\nclass Document(Node):\n    \"\"\"Root node representing a complete GraphQL document.\"\"\"\n    definitions: List['Definition'] = field(default_factory=list)\n\n@dataclass\nclass Definition(Node):\n    \"\"\"Base for definitions (operations, fragments).\"\"\"\n    pass\n\n@dataclass\nclass OperationDefinition(Definition):\n    \"\"\"An operation (query, mutation, subscription).\"\"\"\n    operation_type: str  # 'query', 'mutation', 'subscription'\n    name: Optional[str] = None\n    variable_definitions: List['VariableDefinition'] = field(default_factory=list)\n    directives: List['Directive'] = field(default_factory=list)\n    selection_set: 'SelectionSet' = None  # Will be set during parsing\n\n@dataclass\nclass SelectionSet(Node):\n    \"\"\"A set of selections (fields, fragment spreads).\"\"\"\n    selections: List['Selection'] = field(default_factory=list)\n\n@dataclass\nclass Selection(Node):\n    \"\"\"Base for selections within a selection set.\"\"\"\n    pass\n\n@dataclass\nclass Field(Selection):\n    \"\"\"A field selection within a selection set.\"\"\"\n    name: str = \"\"\n    alias: Optional[str] = None\n    arguments: List['Argument'] = field(default_factory=list)\n    directives: List['Directive'] = field(default_factory=list)\n    selection_set: Optional[SelectionSet] = None  # None for scalar fields\n\n# TODO: Add remaining AST node classes:\n# - FragmentDefinition\n# - FragmentSpread  \n# - InlineFragment\n# - VariableDefinition\n# - Argument\n# - Directive\n# - Value nodes (IntValue, StringValue, Variable, etc.)\n```\n\n#### E. Language-Specific Hints\n\n1. **Python Type Hints**: Use `from typing import ...` extensively. This improves readability and helps catch errors early.\n2. **Dataclasses**: Use `@dataclass` for AST nodes and data structures—they auto-generate `__init__`, `__repr__`, and support default values.\n3. **Error Handling**: Create a custom exception hierarchy in `utils/errors.py`:\n   ```python\n   class GraphQLError(Exception):\n       \"\"\"Base class for all GraphQL errors.\"\"\"\n       pass\n   \n   class GraphQLSyntaxError(GraphQLError):\n       \"\"\"Raised when query syntax is invalid.\"\"\"\n       pass\n   \n   class GraphQLValidationError(GraphQLError):\n       \"\"\"Raised when query fails validation against schema.\"\"\"\n       pass\n   ```\n4. **Testing**: Write tests alongside implementation. Use `unittest.TestCase` with descriptive method names.\n\n#### F. Milestone Checkpoint\n\nAfter setting up the project structure and starter code:\n\n1. **Verify Setup**:\n   ```bash\n   cd graphql-engine\n   python -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   pip install flask\n   python src/graphql_engine/main.py\n   ```\n   \n2. **Test HTTP Server**:\n   ```bash\n   curl -X POST http://localhost:5000/health\n   # Should return: {\"status\": \"healthy\"}\n   \n   curl -X POST http://localhost:5000/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\": \"{ __typename }\"}'\n   # Will fail with \"NotImplementedError\" - this is expected at this stage\n   ```\n\n3. **Expected Behavior**: The server starts without errors. The `/graphql` endpoint returns a 500 error with \"NotImplementedError\" since the parser and executor aren't built yet. This confirms the infrastructure works.\n\n4. **Common Setup Issues**:\n   - **Import errors**: Ensure `src/graphql_engine/__init__.py` exists (can be empty)\n   - **Module not found**: Run from project root or set `PYTHONPATH`\n   - **Port already in use**: Change port in `app.run(port=5001)`\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"ModuleNotFoundError: No module named 'graphql_engine'\" | Python can't find the module | Check `sys.path`, ensure running from project root | Run with `PYTHONPATH=src python src/graphql_engine/main.py` |\n| Flask server starts but crashes on first request | Missing dependencies | Check terminal for import errors | `pip install flask` |\n| AST node attributes are `None` when they shouldn't be | Parser not setting fields correctly | Add debug prints in parser to trace node creation | Ensure each parsing method returns fully populated nodes |\n| SQL query has syntax errors | String concatenation issues | Print generated SQL before execution | Use parameterized queries, not string interpolation |\n\n---\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** This section establishes the foundational scope for all five milestones, defining the absolute minimum required for the system to be considered complete, the quality attributes that guide design decisions, and explicit boundaries that prevent scope creep.\n\nThis section defines the precise boundaries of our GraphQL engine—what it must achieve to be functionally complete and what it deliberately excludes to maintain focus on the core educational objectives. Building a GraphQL engine is a complex endeavor with many potential rabbit holes; clear scope definition is essential to deliver a working system while providing deep learning in the fundamental challenges of query languages, type systems, and database integration.\n\n### Must-Have Requirements\n\n> **Mental Model:** The **Minimum Viable Kitchen** — Imagine building a restaurant kitchen from scratch. You must have at minimum: a heat source (stove), refrigeration, prep surfaces, and basic utensils. Without any one of these, you cannot function. Our must-have requirements are these irreducible components—the absolute essentials needed to transform a GraphQL query into database results.\n\nThe system must implement the complete pipeline from GraphQL query string to database results, corresponding directly to our five milestones. Each milestone delivers a critical, non-negotiable component; together they form a functioning engine.\n\n| Requirement Category | Specific Capabilities | Corresponding Milestone | Success Metric |\n|----------------------|-----------------------|--------------------------|----------------|\n| **Query Parsing** | - Lexical analysis of GraphQL query strings into tokens<br>- Recursive descent parsing producing a complete AST<br>- Support for queries, mutations, fragments, variables, and directives<br>- Accurate source location tracking for error messages | Milestone 1: GraphQL Parser | Given any valid GraphQL query per the specification, the parser produces a correctly structured AST. For invalid queries, it produces descriptive errors with line/column positions. |\n| **Type System & Schema** | - Representation of all GraphQL type kinds (Object, Scalar, Interface, Union, Enum, InputObject, List, NonNull)<br>- Schema construction with validation for consistency (no circular references, valid interface implementations)<br>- Built-in introspection support (`__schema`, `__type`, `__typename`)<br>- Custom scalar type support with serialization/parsing functions | Milestone 2: Schema & Type System | A GraphQL schema can be defined programmatically, validated without internal contradictions, and correctly respond to introspection queries. |\n| **Query Execution** | - Field resolver invocation with correct argument coercion and context propagation<br>- Recursive resolution of nested selection sets<br>- Proper null propagation according to GraphQL specification (null bubbles to nearest nullable parent)<br>- Error collection allowing partial results<br>- Concurrent execution of independent sibling fields | Milestone 3: Query Execution Engine | Given a schema with resolver functions, any valid query returns correctly shaped data, handles nulls appropriately, and reports field errors without crashing. |\n| **Database Schema Reflection** | - Connection to PostgreSQL (or similar SQL database) and introspection of tables, columns, and foreign keys<br>- Automatic mapping of SQL types to GraphQL scalar types (INT→GraphQLInt, VARCHAR→GraphQLString, etc.)<br>- Generation of GraphQL object types from tables with fields for columns and relationships<br>- Creation of primary key query fields and filter arguments for list fields | Milestone 4: Database Schema Reflection | Connecting to a sample database (e.g., a blog with Users, Posts, Comments) produces a complete GraphQL schema with proper types and relationships without manual configuration. |\n| **Query-to-SQL Compilation** | - Translation of GraphQL field selections to SQL SELECT columns (no over-fetching)<br>- Generation of appropriate SQL JOINs for nested object fields based on foreign keys<br>- Prevention of N+1 queries via batching or single-query JOINs<br>- Parameterized WHERE clauses from GraphQL filter arguments<br>- Support for pagination (LIMIT/OFFSET) and ordering | Milestone 5: Query to SQL Compilation | A GraphQL query requesting nested relationships compiles to a single SQL query (or minimal set) that executes efficiently without Cartesian products or N+1 issues. |\n\n**Core End-to-End Flow:** The system must successfully chain these components: Parse a GraphQL query string → validate it against a schema (either programmatically defined or reflected from a database) → compile it to optimized SQL → execute the SQL → transform database results into the GraphQL response shape. This pipeline represents the complete **impedance mismatch** bridge between GraphQL's hierarchical queries and relational database tables.\n\n### Quality Attributes\n\n> **Mental Model:** The **Kitchen's Performance Characteristics** — Beyond having basic equipment, a great kitchen must be: *fast* (low latency from order to plate), *accurate* (orders exactly match what was requested), *adaptable* (can handle special dietary requirements), and *educational* (apprentices can learn why techniques work). These are our quality attributes—the \"ilities\" that guide how we build, not just what we build.\n\nWhile functional requirements define *what* the system does, quality attributes define *how well* it does them and influence architectural decisions. For this educational project, we prioritize in this order:\n\n| Attribute | Priority | Definition & Measurement | Architectural Implications |\n|-----------|----------|---------------------------|----------------------------|\n| **Educational Value** | Highest | The system's design must expose core concepts clearly, avoid excessive abstraction, and provide learning opportunities at each milestone. Measured by how easily a learner can trace through the codebase and understand each transformation. | - Clear separation of concerns with well-defined component boundaries<br>- Minimal use of \"magic\" or hidden automation<br>- Extensive comments explaining *why* not just *what*<br>- Straightforward data structures over optimized but obscure ones |\n| **Correctness** | High | The system must adhere to the GraphQL specification for parsing, validation, and execution semantics. Measured by passing a curated suite of specification-compliance tests. | - Reference implementation of GraphQL spec algorithms (e.g., null propagation, type coercion)<br>- Comprehensive validation at each stage (parse, validate, execute)<br>- Use of property-based testing to ensure edge cases handled |\n| **Extensibility** | Medium | The architecture must allow for future enhancements (custom directives, additional database adapters, query caching) without major rewrites. Measured by how cleanly new features can be added with minimal modification to existing code. | - Plugin interfaces for database adapters, custom scalar parsers, and directive handlers<br>- Abstract base classes for type definitions and execution strategies<br>- Configuration objects for reflection and compilation options |\n| **Performance** | Medium-Low | The system should avoid obvious performance pitfalls (N+1 queries, Cartesian products) but need not be production-optimized. Measured by basic benchmarks showing linear scaling with query complexity. | - Query compilation to efficient SQL as primary performance strategy<br>- Simple DataLoader pattern for batching (but not advanced connection pooling)<br>- Acceptable to trade some performance for clarity in educational code |\n\n> **Architecture Decision: Quality Attribute Prioritization**\n> - **Context:** Building a GraphQL engine involves trade-offs between performance, correctness, maintainability, and educational value. Different production systems (Hasura, PostGraphile) prioritize performance and scalability.\n> - **Options Considered:**\n>     1. **Production-grade optimization:** Prioritize performance and scalability above all, using advanced compilation techniques, connection pooling, and caching.\n>     2. **Educational clarity first:** Prioritize readable, straightforward code that clearly demonstrates concepts, accepting performance trade-offs.\n>     3. **Balanced approach:** Attempt to achieve both good performance and good educational value through careful abstraction.\n> - **Decision:** Prioritize educational clarity first, with correctness as a close second.\n> - **Rationale:** This project's primary goal is learning, not deployment to production. Learners must be able to read and understand every component. Over-optimization often obscures fundamental algorithms with complex abstractions. However, correctness is non-negotiable for understanding GraphQL semantics properly.\n> - **Consequences:** The code will be more verbose and less performant than production systems, but each algorithm will be explicit and traceable. Performance pitfalls will be addressed pedagogically (e.g., demonstrating N+1 problem then fixing it) rather than preemptively hidden.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Production-grade optimization | - High performance<br>- Demonstrates real-world scaling techniques | - Complex code obscures fundamentals<br>- Requires advanced database/compiler knowledge | ❌ |\n| Educational clarity first | - Maximum learning value<br>- Easier debugging for learners<br>- Clear mapping to specification | - Suboptimal performance<br>- May require refactoring for extensions | ✅ |\n| Balanced approach | - Good trade-off for both goals<br>- More realistic architecture | - Harder to achieve both well<br>- Risk of being neither clear nor fast | ❌ |\n\n### Explicit Non-Goals\n\n> **Mental Model:** The **\"Not On the Menu\" List** — Every restaurant decides what it won't serve: perhaps no vegan options, no late-night service, no catering. These exclusions let the kitchen focus on perfecting its core offerings. Our non-goals are deliberate exclusions that keep the project scope manageable and focused on core educational objectives.\n\nThe following features are explicitly **out of scope** for the initial implementation. This prevents scope creep and ensures we deliver a complete, functional engine that teaches the fundamentals without being overwhelmed by advanced features.\n\n| Non-Goal | Reason for Exclusion | Potential Future Extension |\n|----------|----------------------|----------------------------|\n| **Authorization & Permissions** | Implementing row-level security, role-based access control, or field-level permissions adds significant complexity that distracts from core execution engine concepts. | Could be added as a middleware layer that filters ASTs or wraps resolvers, or via schema directives. |\n| **Subscriptions (Real-time)** | GraphQL subscriptions require WebSocket handling, pub/sub infrastructure, and stateful connections—a substantial separate system from query execution. | Could be implemented as a separate transport layer using the same parsing/validation but with event-driven resolvers. |\n| **Federation & Schema Stitching** | Combining multiple GraphQL schemas involves complex query planning and delegation logic that builds upon (rather than teaches) core execution. | Once the base engine is built, federation could be added as a separate query planning layer. |\n| **Advanced SQL Features** | Window functions, Common Table Expressions (CTEs), stored procedure calls, or database-specific optimizations like materialized views. | These could be exposed via custom directives or special field types after the core compilation works. |\n| **Mutation Execution Beyond CRUD** | Complex transactional logic, conditional updates, or operations spanning multiple tables in a single mutation. | The basic CRUD mutation generation from reflected schemas provides a foundation; custom resolvers can handle complex logic. |\n| **Query Caching** | Persistent query caching, response caching with invalidation, or database query result caching. | Simple in-memory caching could be added at the DataLoader or SQL compilation level. |\n| **Multiple Database Dialects** | Full support for SQLite, MySQL, SQL Server, etc., with their type system differences and SQL variations. | The architecture includes adapter interfaces; we'll focus on PostgreSQL as the reference implementation. |\n| **GraphQL Schema Directives** | Custom schema directives for code generation, validation, or metadata (e.g., `@deprecated` is built-in, but not custom ones). | Directive visitors could be added to the schema building and query compilation phases. |\n| **File Uploads** | Multipart form handling or streaming file uploads via GraphQL mutations. | This is typically handled outside GraphQL execution or via custom scalar types. |\n| **Performance Monitoring & Tracing** | Query complexity analysis, Apollo Tracing, or OpenTelemetry integration. | Could be added as execution context extensions that collect timing data. |\n\n> **Key Insight:** The most important non-goal is **production readiness**. This engine is designed for learning, not for deploying to production environments. We deliberately choose simpler implementations that reveal the underlying mechanisms over optimized, black-box solutions. This means our engine will be slower, handle fewer concurrent requests, and lack many features needed for production use—but it will teach you exactly how GraphQL engines work at their core.\n\n**Boundary Enforcement:** Each component design will reference these non-goals to ensure we don't inadvertently expand scope. For example, the SQL compiler will generate straightforward JOINs rather than attempting to optimize for specific database index structures. The execution engine will use simple concurrent futures rather than sophisticated work-stealing thread pools.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n| Component | Simple Option (Educational Focus) | Advanced Option (If Extending) |\n|-----------|-----------------------------------|--------------------------------|\n| Language & Runtime | **Python 3.10+** (standard library, clear syntax, rapid iteration) | Go or Rust (performance, concurrency model) |\n| HTTP Server (for testing) | `http.server` (built-in) or `Flask` (minimal dependencies) | `FastAPI` (async, automatic OpenAPI) or `aiohttp` |\n| Database Adapter | `psycopg2` (PostgreSQL, synchronous, straightforward) | `asyncpg` (async, faster) or SQLAlchemy (abstraction) |\n| Testing Framework | `pytest` with `pytest-asyncio` for async tests | Same, plus `hypothesis` for property-based testing |\n| Type Hints | Extensive use of `typing` module (`Dict`, `List`, `Optional`, etc.) | `pydantic` for data validation or `mypy` strict checking |\n\n**B. Recommended File/Module Structure:**\n```\ngraphql-engine/\n├── README.md\n├── pyproject.toml\n├── src/\n│   └── graphql_engine/\n│       ├── __init__.py\n│       ├── exceptions.py          # Custom exception types\n│       │\n│       ├── parsing/               # Milestone 1\n│       │   ├── __init__.py\n│       │   ├── lexer.py           # Tokenizer\n│       │   ├── parser.py          # Recursive descent parser\n│       │   ├── ast.py             # AST node classes\n│       │   └── errors.py          # Parse error with location\n│       │\n│       ├── type_system/           # Milestone 2\n│       │   ├── __init__.py\n│       │   ├── types.py           # Base GraphQLType, ScalarType, ObjectType, etc.\n│       │   ├── schema.py          # Schema class and validation\n│       │   ├── introspection.py   # __schema, __type resolvers\n│       │   └── values.py          # Value coercion utilities\n│       │\n│       ├── execution/             # Milestone 3\n│       │   ├── __init__.py\n│       │   ├── executor.py        # Main execute_query function\n│       │   ├── resolver.py        # Resolver registry and calling\n│       │   ├── errors.py          # GraphQLError collection\n│       │   ├── dataloader.py      # Simple DataLoader implementation\n│       │   └── context.py         # ExecutionContext class\n│       │\n│       ├── reflection/            # Milestone 4\n│       │   ├── __init__.py\n│       │   ├── adapter.py         # DatabaseAdapter base class\n│       │   ├── postgres_adapter.py # PostgreSQL implementation\n│       │   ├── mapper.py          # Table→Type, Column→Field mapping\n│       │   ├── relationship.py    # Foreign key detection\n│       │   └── naming.py          # Name conversion utilities\n│       │\n│       ├── compilation/           # Milestone 5\n│       │   ├── __init__.py\n│       │   ├── compiler.py        # AST-to-SQL compiler\n│       │   ├── sql_builder.py     # SQL string builder with parameterization\n│       │   ├── joins.py           # JOIN generation logic\n│       │   ├── filters.py         # WHERE clause generation\n│       │   └── pagination.py      # LIMIT/OFFSET handling\n│       │\n│       └── utils/\n│           ├── __init__.py\n│           ├── visitation.py      # AST visitor pattern\n│           └── introspection.py   # Helper for schema inspection\n│\n└── tests/                         # Comprehensive test suite\n    ├── __init__.py\n    ├── test_parsing.py\n    ├── test_type_system.py\n    ├── test_execution.py\n    ├── test_reflection.py\n    ├── test_compilation.py\n    └── integration/               # End-to-end tests\n```\n\n**C. Infrastructure Starter Code:**\n\nSince the educational focus is on the GraphQL engine itself, here's complete starter code for a simple HTTP server and database adapter that learners can use immediately:\n\n**`src/graphql_engine/server/http_server.py`:**\n```python\n\"\"\"\nSimple HTTP server for testing GraphQL engine.\nEducational purpose only - not production ready.\n\"\"\"\nimport json\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom typing import Dict, Any, Optional\nfrom graphql_engine.parsing import parse_query\nfrom graphql_engine.execution import execute_query\nfrom graphql_engine.type_system import Schema\n\n\nclass GraphQLRequestHandler(BaseHTTPRequestHandler):\n    \"\"\"Handles POST requests with GraphQL queries in JSON body.\"\"\"\n    \n    def __init__(self, schema: Schema, *args, **kwargs):\n        self.schema = schema\n        super().__init__(*args, **kwargs)\n    \n    def do_POST(self):\n        \"\"\"Handle GraphQL query POST request.\"\"\"\n        content_length = int(self.headers.get('Content-Length', 0))\n        body = self.rfile.read(content_length).decode('utf-8')\n        \n        try:\n            request_data = json.loads(body)\n            query = request_data.get('query', '')\n            variables = request_data.get('variables', {})\n            operation_name = request_data.get('operationName')\n            \n            # Parse and execute\n            document_ast = parse_query(query)\n            result = execute_query(\n                schema=self.schema,\n                document_ast=document_ast,\n                variable_values=variables,\n                operation_name=operation_name\n            )\n            \n            response_data = json.dumps(result, indent=2).encode('utf-8')\n            \n            self.send_response(200)\n            self.send_header('Content-Type', 'application/json')\n            self.send_header('Content-Length', str(len(response_data)))\n            self.end_headers()\n            self.wfile.write(response_data)\n            \n        except Exception as e:\n            error_response = {\n                'errors': [{'message': str(e)}]\n            }\n            response_data = json.dumps(error_response).encode('utf-8')\n            \n            self.send_response(400)\n            self.send_header('Content-Type', 'application/json')\n            self.send_header('Content-Length', str(len(response_data)))\n            self.end_headers()\n            self.wfile.write(response_data)\n\n\ndef start_test_server(schema: Schema, host: str = 'localhost', port: int = 8000):\n    \"\"\"Start a simple HTTP server for testing GraphQL queries.\"\"\"\n    def handler(*args, **kwargs):\n        return GraphQLRequestHandler(schema, *args, **kwargs)\n    \n    server = HTTPServer((host, port), handler)\n    print(f\"GraphQL test server running at http://{host}:{port}\")\n    print(\"Send POST requests with JSON body: {{'query': '{{ ... }}', 'variables': {{...}}}}\")\n    server.serve_forever()\n```\n\n**D. Core Logic Skeleton Code:**\n\nFor the main execution function that learners will implement in Milestone 3:\n\n**`src/graphql_engine/execution/executor.py`:**\n```python\n\"\"\"\nCore query execution engine.\nImplements GraphQL execution algorithm per specification.\n\"\"\"\nfrom typing import Dict, Any, Optional, List\nfrom graphql_engine.type_system import Schema, ObjectType\nfrom graphql_engine.parsing import Document, OperationDefinition\nfrom graphql_engine.execution.context import ExecutionContext\nfrom graphql_engine.execution.errors import GraphQLError\n\n\ndef execute_query(\n    schema: Schema,\n    document_ast: Document,\n    variable_values: Optional[Dict[str, Any]] = None,\n    operation_name: Optional[str] = None,\n    context_value: Any = None\n) -> Dict[str, Any]:\n    \"\"\"\n    Execute a GraphQL query against a schema.\n    \n    Args:\n        schema: The GraphQL schema to execute against\n        document_ast: Parsed AST of the GraphQL query document\n        variable_values: Dictionary of variable values provided with the request\n        operation_name: Name of operation to execute if document contains multiple\n        context_value: Shared context passed to all resolvers\n    \n    Returns:\n        Dictionary containing 'data' and/or 'errors' keys per GraphQL spec\n        \n    TODO Implementation Steps (Milestone 3):\n    1. Validate that document_ast contains at least one operation definition\n    2. If operation_name is provided, find the named operation; otherwise use the only operation\n    3. Coerce variable values to types defined in operation's variable definitions\n    4. Create ExecutionContext with schema, variable values, and context_value\n    5. Get root type (Query, Mutation, or Subscription) from schema based on operation type\n    6. Execute selection set starting with root type and empty parent value\n    7. Collect any errors that occurred during execution\n    8. Return {'data': result} if no errors, or {'data': result, 'errors': [...]} if errors\n    9. Ensure null propagation: if a non-null field resolves to null, bubble up appropriately\n    10. Handle lists: if field type is List, execute for each item in parent value\n    \"\"\"\n    # TODO 1: Validate document_ast has definitions\n    # TODO 2: Select operation based on operation_name\n    # TODO 3: Coerce variable values\n    # TODO 4: Create ExecutionContext\n    # TODO 5: Get root type from schema\n    # TODO 6: Execute selection set (call execute_selection_set)\n    # TODO 7: Collect errors from context\n    # TODO 8: Format response according to GraphQL spec\n    pass\n\n\ndef execute_selection_set(\n    selection_set,\n    parent_type: ObjectType,\n    parent_value: Any,\n    context: ExecutionContext\n) -> Dict[str, Any]:\n    \"\"\"\n    Execute a selection set for a given parent type and value.\n    \n    TODO Implementation Steps:\n    1. Initialize result dict to hold field results\n    2. For each selection in selection_set:\n        a. If it's a Field: execute_field and add to result dict\n        b. If it's a FragmentSpread: resolve fragment and execute its selection set\n        c. If it's an InlineFragment: check type condition and execute if matches\n    3. Return result dict\n    4. Handle parallelism: sibling fields without dependencies can execute concurrently\n    \"\"\"\n    pass\n\n\ndef execute_field(\n    field,\n    parent_type: ObjectType,\n    parent_value: Any,\n    context: ExecutionContext\n) -> Any:\n    \"\"\"\n    Execute a single field resolution.\n    \n    TODO Implementation Steps:\n    1. Get field definition from parent_type\n    2. Coerce field arguments using variable values from context\n    3. Get resolver function for field (default: parent_value[field_name])\n    4. Call resolver with (parent_value, args, context, info)\n    5. If resolver returns None and field type is Non-Null: throw error\n    6. If resolver returns a value and field has a selection set: recursively execute\n    7. Return coerced value (apply List/NonNull wrappers as needed)\n    \"\"\"\n    pass\n```\n\n**E. Language-Specific Hints:**\n- **Python Type Hints:** Use `from typing import List, Dict, Optional, Any, Union` extensively. Define `TypedDict` for complex return structures.\n- **Async/Await:** Consider using `asyncio` for concurrent field execution. Use `asyncio.gather()` for parallel sibling field resolution.\n- **Error Handling:** Raise custom exceptions like `GraphQLError` with message and optional locations. Catch exceptions at field boundaries to allow partial results.\n- **DataLoader Pattern:** Implement a simple `DataLoader` class that batches `load()` calls and caches results per request.\n\n**F. Milestone Checkpoint:**\nAfter implementing the core execution engine (Milestone 3), run:\n```bash\npython -m pytest tests/test_execution.py -xvs\n```\nExpected output: All tests pass, demonstrating:\n1. Simple field resolution returns correct data\n2. Nested fields resolve recursively\n3. Null propagation works correctly (non-null field resolving to null bubbles up)\n4. List fields work with lists of objects\n5. Field errors are collected without crashing execution\n\n**G. Debugging Tips:**\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Cannot read property 'x' of undefined\" in resolver | Parent value not passed correctly to nested resolver | Print parent_value in execute_field | Ensure each field resolver receives the correct parent (object from previous level) |\n| All fields return null | Resolver functions not registered or default resolver fails | Check field definition has resolver; add print to default resolver | Implement proper resolver lookup or ensure parent objects have matching attribute names |\n| Non-null error bubbles to root incorrectly | Null propagation logic missing type checking | Add debug prints to see when null is encountered and what field type is | Implement spec rule: if field is NonNull and returns null, bubble null to parent; if parent is nullable, set to null |\n| Sibling fields execute sequentially | Missing parallel execution | Add timing logs to see fields execute one after another | Use `asyncio.gather()` or `concurrent.futures` for independent fields |\n\n---\n\n\n## High-Level Architecture\n\n> **Milestone(s):** This section provides the architectural blueprint for all five milestones, showing how components fit together and how data flows through the system. It establishes the overall structure before diving into individual component details.\n\nThe GraphQL engine architecture bridges two fundamentally different worlds: GraphQL's hierarchical, client-centric query model and relational databases' tabular, set-oriented structure. This **impedance mismatch** is the central architectural challenge we must solve. Rather than a monolithic blob, we decompose the system into five focused components, each with a clear responsibility and interface, connected by well-defined data transformations.\n\n### System Component Diagram\n\n> **Mental Model: The Restaurant Kitchen Analogy**\n> \n> Think of the GraphQL engine as a high-end restaurant kitchen. The **Parser** is the order-taker who listens to the customer's complex request and writes it down in the kitchen's internal shorthand (the AST). The **Type System** is the recipe book that defines what ingredients are available and how they can be combined. The **Execution Engine** is the head chef who coordinates the preparation, calling on various station chefs (resolvers) to prepare each component of the meal. The **Schema Reflection** is the inventory system that automatically catalogs what's in the pantry (database) and creates recipes for it. Finally, the **SQL Compiler** is the sous-chef who optimizes the cooking process—instead of making each component separately (N+1 problem), they plan an efficient sequence that uses shared ingredients and parallel cooking stations to prepare everything in minimal time.\n\n![GraphQL Engine System Components](./diagrams/system-component-diagram.svg)\n\n![Query Parsing Sequence Diagram](./diagrams/parsing-sequence.svg)\n\n![Ast Class Diagram](./diagrams/ast-class-diagram.svg)\n\nThe system comprises five core components that transform a GraphQL query string into database results:\n\n| Component | Responsibility | Input | Output | Analogy |\n|-----------|----------------|-------|--------|---------|\n| **GraphQL Parser** | Converts GraphQL query strings into Abstract Syntax Trees (ASTs) | GraphQL query string (`String`) | Validated AST (`Document`) | Order-taker translating customer request to kitchen ticket |\n| **Schema & Type System** | Defines and validates GraphQL types, provides introspection | Type definitions, database metadata | Complete `GraphQLSchema` with all types | Recipe book defining available dishes and ingredients |\n| **Query Execution Engine** | Executes queries by calling resolver functions | `GraphQLSchema`, query AST, variables, context | Structured JSON response | Head chef coordinating station chefs to prepare meal |\n| **Database Schema Reflection** | Auto-generates GraphQL types from database schema | Database connection, configuration options | Generated GraphQL types and resolvers | Inventory system cataloging pantry contents |\n| **Query to SQL Compiler** | Compiles GraphQL queries to optimized SQL | Query AST, schema metadata, variable values | Parameterized SQL query + execution plan | Sous-chef optimizing cooking process to minimize steps |\n\n#### Component Interactions and Data Flow\n\nThe components interact through well-defined interfaces, creating a pipeline that transforms data at each stage:\n\n1. **Schema Building Path**: The Database Schema Reflection component reads database metadata and generates GraphQL types, which feed into the Schema & Type System component to build a complete schema.\n\n2. **Query Execution Path**: A GraphQL query string flows through the Parser → Type System (for validation) → Execution Engine → SQL Compiler (for database queries) → Database → Back through the chain as results.\n\n3. **Introspection Path**: Special GraphQL introspection queries follow the same execution path but are handled by built-in resolvers in the Type System component.\n\n> **Architecture Decision: Separation of Concerns via Pipeline**\n>\n> **Context**: We need to transform GraphQL queries into database results while maintaining clarity, testability, and the ability to evolve components independently. The system must handle both hand-written schemas and auto-generated ones from databases.\n>\n> **Options Considered**:\n> 1. **Monolithic Engine**: Single component that handles parsing, validation, execution, and SQL generation in one intertwined codebase.\n> 2. **Pipeline Architecture**: Clear separation with each component focusing on one transformation, passing data through well-defined interfaces.\n> 3. **Plugin Architecture**: Core engine with extensible plugins for parsing, execution, SQL generation, etc.\n>\n> **Decision**: Pipeline Architecture with clear interfaces between components.\n>\n> **Rationale**:\n> - **Testability**: Each component can be tested in isolation with mock inputs/outputs.\n> - **Educational Value**: Clear boundaries help learners understand each transformation step.\n> - **Evolution**: Components can be swapped or upgraded independently (e.g., different SQL dialects).\n> - **Debugging**: Failures can be pinpointed to specific transformation stages.\n>\n> **Consequences**:\n> - **Positive**: Clear mental model, easier to understand and debug, enables incremental development.\n> - **Negative**: Some overhead in data marshaling between components, requires careful interface design.\n> - **Mitigation**: Use immutable data structures that can be passed efficiently by reference.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Monolithic Engine | Fewer interface boundaries, potentially faster | Hard to test, difficult to understand, tightly coupled | ❌ |\n| Pipeline Architecture | Clear separation, testable, educational, modular | Data marshaling overhead, interface design complexity | ✅ |\n| Plugin Architecture | Extremely flexible, ecosystem potential | Complex plugin API, harder for learners, over-engineering | ❌ |\n\n### Recommended File/Module Structure\n\n> **Mental Model: The Workshop Organization**\n>\n> Imagine each component as a specialized workshop station. The **Parser Workshop** has lexing tools and grammar charts. The **Type System Workshop** has blueprint diagrams and validation checklists. The **Execution Workshop** has assembly lines and quality control stations. The **Reflection Workshop** has database connection tools and mapping tables. The **SQL Compiler Workshop** has query planning boards and optimization tools. Each workshop has its own tools, organized in labeled drawers (modules), with clear paths between workshops for moving work-in-progress.\n\nA clean directory structure is critical for managing complexity and maintaining separation of concerns. Below is the recommended organization for a Python implementation:\n\n```\ngraphql-engine/\n├── pyproject.toml              # Project configuration and dependencies\n├── README.md\n├── examples/                   # Example schemas and queries\n│   ├── blog/\n│   └── ecommerce/\n├── src/\n│   └── graphql_engine/         # Main package\n│       ├── __init__.py\n│       ├── exceptions.py       # Custom exception types\n│       ├── constants.py        # Constants (type names, directives, etc.)\n│       ├── parser/             # Component 1: GraphQL Parser\n│       │   ├── __init__.py\n│       │   ├── lexer.py        # Tokenizer/Lexer\n│       │   ├── parser.py       # Recursive descent parser\n│       │   ├── ast.py          # AST node class definitions\n│       │   └── errors.py       # Parse error types\n│       ├── type_system/        # Component 2: Schema & Type System\n│       │   ├── __init__.py\n│       │   ├── types.py        # Base GraphQLType and all type classes\n│       │   ├── schema.py       # GraphQLSchema class and validation\n│       │   ├── introspection.py # Introspection resolver implementations\n│       │   └── validation.py   # Schema validation rules\n│       ├── execution/          # Component 3: Query Execution Engine\n│       │   ├── __init__.py\n│       │   ├── executor.py     # Main Executor class\n│       │   ├── resolvers.py    # Default resolver implementations\n│       │   ├── dataloader.py   # DataLoader pattern implementation\n│       │   ├── errors.py       # Execution error handling\n│       │   └── context.py      # ExecutionContext class\n│       ├── reflection/         # Component 4: Database Schema Reflection\n│       │   ├── __init__.py\n│       │   ├── reflector.py    # Main SchemaReflector class\n│       │   ├── adapters/       # Database-specific adapters\n│       │   │   ├── __init__.py\n│       │   │   ├── postgres.py\n│       │   │   ├── mysql.py\n│       │   │   └── sqlite.py\n│       │   ├── type_mapping.py # SQL-to-GraphQL type mapping\n│       │   └── naming.py       # Naming convention utilities\n│       ├── sql_compiler/       # Component 5: Query to SQL Compilation\n│       │   ├── __init__.py\n│       │   ├── compiler.py     # Main SQLCompiler class\n│       │   ├── ir.py           # Intermediate Representation structures\n│       │   ├── builders.py     # SQL query builder utilities\n│       │   ├── joins.py        # JOIN generation logic\n│       │   └── parameters.py   # Query parameterization\n│       └── server/             # Optional HTTP server wrapper\n│           ├── __init__.py\n│           ├── http_handler.py # HTTP request/response handling\n│           └── graphiql.py     # GraphiQL IDE endpoint\n└── tests/                      # Comprehensive test suite\n    ├── __init__.py\n    ├── test_parser/\n    ├── test_type_system/\n    ├── test_execution/\n    ├── test_reflection/\n    └── test_sql_compiler/\n```\n\n#### Module Responsibilities and Public Interfaces\n\nEach module exposes a clean public API while hiding implementation details:\n\n| Module | Public Classes/Functions | Purpose | Dependencies |\n|--------|--------------------------|---------|--------------|\n| `parser` | `parse_query(query_str)`, `parse_schema(sdl_str)`, `Document`, `Location` | Convert strings to ASTs | None (pure text processing) |\n| `type_system` | `GraphQLSchema`, `GraphQLObjectType`, `GraphQLScalarType`, `build_schema()` | Define and validate types | `parser` for SDL parsing |\n| `execution` | `execute_query(schema, document, ...)`, `ExecutionContext`, `DataLoader` | Execute queries against schema | `parser`, `type_system` |\n| `reflection` | `SchemaReflector`, `reflect_schema(connection)`, database adapters | Generate schema from database | `type_system` for type building |\n| `sql_compiler` | `SQLCompiler`, `compile_to_sql(query_ast, schema)`, `CompiledQuery` | Convert GraphQL to SQL | `parser`, `type_system`, `reflection` |\n\n> **Architecture Decision: Layered Dependencies**\n>\n> **Context**: Components have natural dependencies (e.g., Execution needs Parser and Type System, SQL Compiler needs all previous components). We must manage these dependencies to avoid circular references and ensure clean separation.\n>\n> **Options Considered**:\n> 1. **Flat Structure**: All components in same module level with bidirectional imports.\n> 2. **Layered Architecture**: Lower layers don't know about higher layers (Parser → Type System → Execution → Reflection/SQL Compiler).\n> 3. **Dependency Injection**: All components receive dependencies via constructor injection.\n>\n> **Decision**: Layered Architecture with unidirectional dependencies.\n>\n> **Rationale**:\n> - **Clear Dependency Flow**: Natural progression from parsing → typing → execution → compilation.\n> - **No Circular Dependencies**: Prevents import loops and spaghetti code.\n> - **Progressive Learning**: Learners can build and test components in dependency order.\n> - **Simplified Testing**: Lower layers can be tested without higher layers.\n>\n> **Consequences**:\n> - **Positive**: Clean mental model, predictable dependencies, easier to reason about.\n> - **Negative**: Higher layers can't easily call back to lower layers (though rarely needed).\n> - **Mitigation**: Use callback interfaces when upward communication is genuinely needed.\n\n### End-to-End Data Flow\n\n> **Mental Model: The Manufacturing Assembly Line**\n>\n> Picture a car manufacturing plant where raw materials (GraphQL query strings) enter at one end and finished cars (JSON responses) exit at the other. At Station 1 (Parser), the query sheet metal is cut and shaped into standardized parts (AST nodes). At Station 2 (Type System), each part is inspected against blueprints to ensure it fits specifications. At Station 3 (Execution), the assembly line coordinates workers (resolvers) to assemble components. For database-backed fields, instead of hand-crafting each part, Station 4 (SQL Compiler) designs efficient machine tools (SQL queries) that mass-produce precisely the needed components. Station 5 (Database) is the raw materials warehouse that feeds these machines. Finally, quality control assembles everything into the final product.\n\n![End-to-End Data Flow Diagram](./diagrams/data-flow-end-to-end.svg)\n\nThe complete transformation pipeline for a typical query involves eight distinct data format transformations:\n\n#### Step-by-Step Data Transformation Pipeline\n\n1. **Input Reception**:\n   - **Format**: HTTP POST request with JSON body\n   - **Content**: `{\"query\": \"query { user(id: 1) { name email } }\", \"variables\": {...}, \"operationName\": \"...\"}`\n   - **Source**: Client application (e.g., React frontend, mobile app)\n\n2. **GraphQL Query String Extraction**:\n   - **Action**: Extract the `query` field from the JSON payload\n   - **Format**: Raw GraphQL query string\n   - **Example**: `\"query GetUser($id: ID!) { user(id: $id) { name email posts { title } } }\"`\n   - **Note**: Variables are kept separate for later substitution\n\n3. **Lexical Analysis (Tokenizer)**:\n   - **Action**: Break string into tokens with type and position\n   - **Input**: `\"query { user(id: 1) { name } }\"`\n   - **Output**: List of `Token` objects:\n     \n     | Token Type | Value | Location (line:column) |\n     |------------|-------|------------------------|\n     | NAME | \"query\" | 1:1 |\n     | BRACE_L | \"{\" | 1:7 |\n     | NAME | \"user\" | 1:9 |\n     | PAREN_L | \"(\" | 1:13 |\n     | NAME | \"id\" | 1:14 |\n     | COLON | \":\" | 1:16 |\n     | INT | \"1\" | 1:18 |\n     | PAREN_R | \")\" | 1:19 |\n     | BRACE_L | \"{\" | 1:21 |\n     | NAME | \"name\" | 1:23 |\n     | BRACE_R | \"}\" | 1:27 |\n     | BRACE_R | \"}\" | 1:29 |\n\n4. **Syntactic Analysis (Parser)**:\n   - **Action**: Build AST from token stream using recursive descent\n   - **Output**: `Document` AST with `OperationDefinition`, `SelectionSet`, `Field`, `Argument` nodes\n   - **Structure**:\n     ```\n     Document\n     └── OperationDefinition (type: \"query\", name: None)\n         └── SelectionSet\n             └── Field (name: \"user\")\n                 ├── Argument (name: \"id\", value: IntValue(1))\n                 └── SelectionSet\n                     └── Field (name: \"name\")\n     ```\n\n5. **Schema Validation**:\n   - **Action**: Check AST against schema type definitions\n   - **Checks**: Field existence, argument type compatibility, required arguments provided\n   - **Output**: Validated query AST or detailed validation errors\n   - **Critical Validation Rules**:\n     1. All selected fields must exist on the parent type\n     2. All required arguments must be provided\n     3. Variable types must match parameter types\n     4. Fragments must be used on compatible types\n\n6. **Execution Planning**:\n   - **Action**: Analyze query to determine resolution strategy\n   - **For Database Fields**: Pass to SQL Compiler\n   - **For Custom Resolvers**: Schedule resolver execution\n   - **Output**: Execution plan with parallelizable units\n\n7. **SQL Compilation** (for database-backed fields):\n   - **Action**: Convert GraphQL field selections to SQL query\n   - **Input**: `Field` AST nodes, schema type information, variable values\n   - **Process**:\n     1. Analyze selection tree to determine required tables and columns\n     2. Generate JOINs based on foreign key relationships\n     3. Apply WHERE clauses from arguments\n     4. Add ORDER BY/LIMIT for pagination\n   - **Output**: Parameterized SQL query + bind parameters\n     ```sql\n     SELECT \"user\".\"id\", \"user\".\"name\", \"user\".\"email\"\n     FROM \"users\" AS \"user\"\n     WHERE \"user\".\"id\" = $1  -- $1 = 1\n     ```\n\n8. **Database Query Execution**:\n   - **Action**: Execute compiled SQL with parameters\n   - **Format**: Database-specific query + parameter binding\n   - **Output**: Raw database rows (list of dictionaries/records)\n\n9. **Result Shaping**:\n   - **Action**: Transform database rows to GraphQL response shape\n   - **Process**: Map column values to field names, nest related objects\n   - **Output**: Nested dictionaries matching query structure\n     ```json\n     {\n       \"user\": {\n         \"name\": \"Alice\",\n         \"email\": \"alice@example.com\"\n       }\n     }\n     ```\n\n10. **Error Collection & Final Response Assembly**:\n    - **Action**: Gather any field errors, apply error masking if needed\n    - **Output**: Final GraphQL response JSON:\n      ```json\n      {\n        \"data\": { ... },\n        \"errors\": [ ... ]  // Only if errors occurred\n      }\n      ```\n\n#### Concrete Walk-Through Example\n\nLet's trace a complete example query through the pipeline:\n\n**Initial HTTP Request**:\n```http\nPOST /graphql HTTP/1.1\nContent-Type: application/json\n\n{\n  \"query\": \"query GetUserWithPosts($userId: ID!) { user(id: $userId) { name email posts(limit: 5) { title publishedAt } } }\",\n  \"variables\": { \"userId\": \"42\" },\n  \"operationName\": \"GetUserWithPosts\"\n}\n```\n\n**Step 1-2**: Extract query string and variables:\n- Query: `\"query GetUserWithPosts($userId: ID!) { user(id: $userId) { name email posts(limit: 5) { title publishedAt } } }\"`\n- Variables: `{\"userId\": \"42\"}`\n\n**Step 3-4**: Parser produces AST:\n```\nDocument\n├── OperationDefinition\n│   ├── operation_type: \"query\"\n│   ├── name: \"GetUserWithPosts\"\n│   ├── variable_definitions:\n│   │   └── VariableDefinition\n│   │       ├── name: \"userId\"\n│   │       └── type: NonNullType(of: NamedType(name: \"ID\"))\n│   └── selection_set: SelectionSet\n│       └── Field\n│           ├── name: \"user\"\n│           ├── arguments:\n│           │   └── Argument\n│           │       ├── name: \"id\"\n│           │       └── value: Variable(name: \"userId\")\n│           └── selection_set: SelectionSet\n│               ├── Field(name: \"name\")\n│               ├── Field(name: \"email\")\n│               └── Field(name: \"posts\")\n│                   ├── arguments:\n│                   │   └── Argument\n│                   │       ├── name: \"limit\"\n│                   │       └── value: IntValue(value: 5)\n│                   └── selection_set: SelectionSet\n│                       ├── Field(name: \"title\")\n│                       └── Field(name: \"publishedAt\")\n```\n\n**Step 5**: Type System validates:\n- `User` type has fields `name`, `email`, `posts`\n- `posts` field returns `[Post]` type\n- `Post` type has fields `title`, `publishedAt`\n- `user` argument `id` expects `ID!` → variable `userId` is `ID!` ✓\n- `posts` argument `limit` expects `Int` → value `5` is `Int` ✓\n\n**Step 6-7**: SQL Compiler analyzes and generates:\n- Need `users` table columns: `id`, `name`, `email`\n- Need `posts` table columns: `id`, `title`, `published_at`, `author_id`\n- Relationship: `posts.author_id` → `users.id`\n- Generate SQL with JOIN:\n\n```sql\nSELECT \n  \"user\".\"id\" AS \"user__id\",\n  \"user\".\"name\" AS \"user__name\", \n  \"user\".\"email\" AS \"user__email\",\n  \"posts\".\"id\" AS \"posts__id\",\n  \"posts\".\"title\" AS \"posts__title\",\n  \"posts\".\"published_at\" AS \"posts__published_at\"\nFROM \"users\" AS \"user\"\nLEFT JOIN LATERAL (\n  SELECT \"posts\".*\n  FROM \"posts\" \n  WHERE \"posts\".\"author_id\" = \"user\".\"id\"\n  ORDER BY \"posts\".\"published_at\" DESC\n  LIMIT 5\n) AS \"posts\" ON TRUE\nWHERE \"user\".\"id\" = $1  -- $1 = 42\n```\n\n**Step 8**: Database returns rows:\n```\n[\n  {\n    \"user__id\": 42,\n    \"user__name\": \"Alice\",\n    \"user__email\": \"alice@example.com\",\n    \"posts__id\": 101,\n    \"posts__title\": \"GraphQL Tutorial\",\n    \"posts__published_at\": \"2023-10-01 14:30:00\"\n  },\n  {\n    \"user__id\": 42,\n    \"user__name\": \"Alice\",\n    \"user__email\": \"alice@example.com\",\n    \"posts__id\": 102,\n    \"posts__title\": \"Database Design\",\n    \"posts__published_at\": \"2023-10-05 09:15:00\"\n  }\n]\n```\n\n**Step 9**: Result shaping transforms to nested structure:\n```json\n{\n  \"user\": {\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"posts\": [\n      {\n        \"title\": \"GraphQL Tutorial\",\n        \"publishedAt\": \"2023-10-01T14:30:00Z\"\n      },\n      {\n        \"title\": \"Database Design\",\n        \"publishedAt\": \"2023-10-05T09:15:00Z\"\n      }\n    ]\n  }\n}\n```\n\n**Step 10**: Final response assembly (no errors):\n```json\n{\n  \"data\": {\n    \"user\": { ... }  // as above\n  }\n}\n```\n\n#### Data Formats at Each Stage\n\n| Stage | Data Format | Key Properties | Example |\n|-------|-------------|----------------|---------|\n| 1. Client Request | HTTP + JSON | Contains query string, variables, operation name | `{\"query\": \"{ user { name } }\", \"variables\": {}}` |\n| 2. Extracted Query | GraphQL String | Raw query text with possible variables | `\"query { user(id: 1) { name } }\"` |\n| 3. Token Stream | List of `Token` | Linear sequence with type, value, location | `[Token(NAME, \"query\", 1:1), Token(BRACE_L, \"{\", 1:7), ...]` |\n| 4. AST | `Document` object | Tree structure with nodes preserving source locations | `Document(definitions=[OperationDefinition(...)])` |\n| 5. Validated AST | `Document` + type info | AST annotated with resolved types | Field node knows it resolves to `User` type |\n| 6. Execution Plan | `ExecutionPlan` | Graph of resolvers with dependencies | `[SQLResolver(table=\"users\"), CustomResolver(field=\"bio\")]` |\n| 7. Compiled SQL | `CompiledQuery` | SQL string + parameter bindings | `(\"SELECT ... WHERE id = $1\", [42])` |\n| 8. Database Results | List of rows | Tabular data, possibly with aliased columns | `[{\"user__name\": \"Alice\", \"posts__title\": \"...\"}]` |\n| 9. Shaped Results | Nested dict | Hierarchical structure matching query | `{\"user\": {\"name\": \"Alice\", \"posts\": [...]}}` |\n| 10. Final Response | GraphQL Response JSON | Standard GraphQL response format | `{\"data\": ..., \"errors\": [...]}` |\n\n> **Key Insight**: Each transformation makes the data more specialized for the next stage's needs. The AST is optimized for tree traversal, the SQL is optimized for database execution, and the final JSON is optimized for client consumption. This separation allows each component to use the most appropriate data structure for its task.\n\n#### Common Pitfalls in Data Flow Design\n\n⚠️ **Pitfall: Premature SQL Generation**\n- **Description**: Generating SQL immediately after parsing, before understanding the full query structure.\n- **Why Wrong**: Cannot optimize across nested relationships, leads to N+1 queries.\n- **Fix**: First build complete execution plan analyzing all nested selections, then generate optimized SQL with JOINs.\n\n⚠️ **Pitfall: Losing Location Information**\n- **Description**: Not preserving source locations through the pipeline.\n- **Why Wrong**: Error messages cannot point to the exact location in the original query.\n- **Fix**: Every AST node should store its `Location` (line, column) and propagate it through transformations.\n\n⚠️ **Pitfall: Mixing Validation and Execution**\n- **Description**: Performing validation during execution (e.g., checking field existence when resolving).\n- **Why Wrong**: Errors surface late, performance overhead on every execution.\n- **Fix**: Complete all validation before execution begins in a dedicated validation phase.\n\n⚠️ **Pitfall: Inefficient Result Shaping**\n- **Description**: Transforming database rows to JSON by iterating over the AST for each row.\n- **Why Wrong**: O(n × m) complexity for n rows and m fields.\n- **Fix**: Pre-compute transformation mapping from column aliases to response paths, apply once per row.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Learning Focus) | Advanced Option (Production Ready) |\n|-----------|--------------------------------|------------------------------------|\n| **HTTP Server** | Python `http.server` module | FastAPI or Starlette with async support |\n| **Parser Implementation** | Hand-written recursive descent parser | Generated parser using ANTLR or Lark |\n| **Type Representation** | Python classes with dict-based fields | Immutable data classes with slots |\n| **Database Access** | SQLite with `sqlite3` module | PostgreSQL with `asyncpg` or SQLAlchemy |\n| **SQL Building** | String concatenation with f-strings | SQLAlchemy Core or custom query builder |\n| **Async Execution** | Synchronous execution (simpler) | Asyncio with concurrent resolvers |\n| **Testing** | `unittest` with mock databases | `pytest` with test containers |\n\n#### B. Recommended Starter Project Structure\n\nFor learners starting the implementation, begin with this minimal structure:\n\n```\nmy-graphql-engine/\n├── src/\n│   └── graphql_engine/\n│       ├── __init__.py\n│       ├── parser.py        # Start with parser (Milestone 1)\n│       ├── types.py         # Add for Milestone 2\n│       ├── execution.py     # Add for Milestone 3\n│       ├── reflection.py    # Add for Milestone 4\n│       └── sql_compiler.py  # Add for Milestone 5\n└── tests/\n    ├── test_parser.py\n    ├── test_types.py\n    └── ...\n```\n\n#### C. Infrastructure Starter Code\n\nHere's complete starter code for the HTTP server layer (not the core learning goal but needed to run the engine):\n\n```python\n# src/graphql_engine/server/http_handler.py\n\"\"\"\nHTTP handler for GraphQL requests. This is infrastructure code that learners\ncan use as-is without implementing the HTTP layer themselves.\n\"\"\"\nimport json\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom typing import Dict, Any, Optional\nimport traceback\n\n\nclass GraphQLHTTPHandler(BaseHTTPRequestHandler):\n    \"\"\"Handles HTTP POST requests with GraphQL queries.\"\"\"\n    \n    def __init__(self, graphql_executor, *args, **kwargs):\n        \"\"\"Initialize with a GraphQL executor function.\"\"\"\n        self.graphql_executor = graphql_executor\n        super().__init__(*args, **kwargs)\n    \n    def do_POST(self):\n        \"\"\"Handle POST requests to /graphql endpoint.\"\"\"\n        if self.path != '/graphql':\n            self.send_response(404)\n            self.end_headers()\n            return\n        \n        content_length = int(self.headers.get('Content-Length', 0))\n        if content_length == 0:\n            self.send_response(400)\n            self.end_headers()\n            self.wfile.write(b'{\"error\": \"Empty request body\"}')\n            return\n        \n        try:\n            # Read and parse JSON request\n            body = self.rfile.read(content_length)\n            request_data = json.loads(body)\n            \n            # Extract GraphQL query components\n            query = request_data.get('query')\n            variables = request_data.get('variables') or {}\n            operation_name = request_data.get('operationName')\n            \n            if not query:\n                raise ValueError(\"Missing 'query' field in request\")\n            \n            # Execute GraphQL query\n            result = self.graphql_executor(\n                query=query,\n                variables=variables,\n                operation_name=operation_name\n            )\n            \n            # Send successful response\n            self.send_response(200)\n            self.send_header('Content-Type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(result).encode('utf-8'))\n            \n        except json.JSONDecodeError:\n            self.send_response(400)\n            self.send_header('Content-Type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps({\n                \"error\": \"Invalid JSON in request body\"\n            }).encode('utf-8'))\n            \n        except Exception as e:\n            # Internal server error\n            self.send_response(500)\n            self.send_header('Content-Type', 'application/json')\n            self.end_headers()\n            error_response = {\n                \"error\": str(e),\n                \"traceback\": traceback.format_exc() if self.debug else None\n            }\n            self.wfile.write(json.dumps(error_response).encode('utf-8'))\n    \n    def do_GET(self):\n        \"\"\"Serve GraphiQL interface at root path.\"\"\"\n        if self.path == '/' or self.path == '/graphiql':\n            self.send_response(200)\n            self.send_header('Content-Type', 'text/html')\n            self.end_headers()\n            self.wfile.write(self._graphiql_html().encode('utf-8'))\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def _graphiql_html(self) -> str:\n        \"\"\"Return HTML for GraphiQL interface.\"\"\"\n        return \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>GraphiQL</title>\n            <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/graphiql/0.17.5/graphiql.min.css\">\n        </head>\n        <body>\n            <div id=\"graphiql\" style=\"height: 100vh;\"></div>\n            <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/16.8.0/umd/react.production.min.js\"></script>\n            <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.8.0/umd/react-dom.production.min.js\"></script>\n            <script src=\"https://cdnjs.cloudflare.com/ajax/libs/graphiql/0.17.5/graphiql.min.js\"></script>\n            <script>\n                function graphQLFetcher(params) {\n                    return fetch('/graphql', {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                        body: JSON.stringify(params),\n                    }).then(response => response.json());\n                }\n                ReactDOM.render(\n                    React.createElement(GraphiQL, { fetcher: graphQLFetcher }),\n                    document.getElementById('graphiql')\n                );\n            </script>\n        </body>\n        </html>\n        \"\"\"\n    \n    def log_message(self, format, *args):\n        \"\"\"Override to control logging output.\"\"\"\n        # Optional: Implement logging to file or stdout\n        print(f\"{self.address_string()} - {format % args}\")\n\n\ndef start_server(executor, host='localhost', port=8000, debug=False):\n    \"\"\"\n    Start HTTP server with GraphQL endpoint.\n    \n    Args:\n        executor: Function that accepts (query, variables, operation_name) \n                  and returns GraphQL response\n        host: Server hostname\n        port: Server port\n        debug: Enable debug mode with tracebacks in errors\n    \"\"\"\n    def handler(*args, **kwargs):\n        return GraphQLHTTPHandler(executor, *args, **kwargs)\n    \n    handler.debug = debug\n    \n    server = HTTPServer((host, port), handler)\n    print(f\"GraphQL server running at http://{host}:{port}/\")\n    print(f\"GraphiQL interface at http://{host}:{port}/graphiql\")\n    \n    try:\n        server.serve_forever()\n    except KeyboardInterrupt:\n        print(\"\\nShutting down server...\")\n        server.server_close()\n```\n\n#### D. Core Pipeline Skeleton Code\n\nHere's the main execution pipeline that learners will implement component by component:\n\n```python\n# src/graphql_engine/__init__.py\n\"\"\"\nMain GraphQL engine entry point. This orchestrates all components.\n\"\"\"\nfrom typing import Dict, Any, Optional\nfrom .parser import parse_query\nfrom .type_system import GraphQLSchema, validate_query\nfrom .execution import execute_query as execute_query_internal\nfrom .reflection import reflect_schema_from_db\nfrom .sql_compiler import SQLCompiler\n\n\nclass GraphQLEngine:\n    \"\"\"Main GraphQL engine coordinating all components.\"\"\"\n    \n    def __init__(self, schema: Optional[GraphQLSchema] = None):\n        \"\"\"\n        Initialize engine with optional schema.\n        \n        Args:\n            schema: Pre-built GraphQL schema. If None, can be built from DB.\n        \"\"\"\n        self.schema = schema\n        self.sql_compiler = SQLCompiler() if schema else None\n    \n    def execute(\n        self,\n        query: str,\n        variables: Optional[Dict[str, Any]] = None,\n        operation_name: Optional[str] = None,\n        context: Optional[Dict[str, Any]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute a GraphQL query through the complete pipeline.\n        \n        Args:\n            query: GraphQL query string\n            variables: Dictionary of variable values\n            operation_name: Name of operation to execute (if multiple in query)\n            context: Execution context (auth, dataloaders, etc.)\n            \n        Returns:\n            GraphQL response dictionary with 'data' and/or 'errors' keys\n            \n        Raises:\n            GraphQLError: For parsing, validation, or execution errors\n        \"\"\"\n        # TODO 1: Parse query string into AST\n        #   Call parse_query() to get Document AST\n        #   Handle parse errors with proper error formatting\n        \n        # TODO 2: Validate query against schema\n        #   Call validate_query() with schema and parsed AST\n        #   Collect all validation errors (don't stop on first error)\n        \n        # TODO 3: If validation passes, execute query\n        #   Call execute_query_internal() with schema, AST, variables, context\n        #   This will internally use SQL compiler for database fields\n        \n        # TODO 4: Format response according to GraphQL spec\n        #   Ensure response has 'data' key (even if null)\n        #   Include 'errors' key only if errors occurred\n        #   Preserve error paths and locations\n        \n        pass\n    \n    def reflect_schema_from_database(\n        self,\n        connection_string: str,\n        dialect: str = \"postgresql\"\n    ) -> None:\n        \"\"\"\n        Generate GraphQL schema from database metadata.\n        \n        Args:\n            connection_string: Database connection string\n            dialect: Database dialect ('postgresql', 'mysql', 'sqlite')\n        \"\"\"\n        # TODO 1: Connect to database using appropriate adapter\n        #   Use connection_string to establish database connection\n        \n        # TODO 2: Introspect database metadata\n        #   Query information_schema for tables, columns, foreign keys\n        #   Detect relationships and primary keys\n        \n        # TODO 3: Generate GraphQL types\n        #   Create GraphQLObjectType for each table\n        #   Map SQL types to GraphQL scalar types\n        #   Create fields for relationships\n        \n        # TODO 4: Build complete schema\n        #   Create Query type with root fields for each table\n        #   Add mutations for create/update/delete operations\n        #   Register custom resolvers for relationship fields\n        \n        # TODO 5: Initialize SQL compiler with schema\n        #   Create SQLCompiler instance\n        #   Pass table/relationship metadata for query planning\n        \n        pass\n```\n\n#### E. Language-Specific Hints for Python\n\n- **Use Python's `enum.Enum`** for token types and AST node types for type safety\n- **Use `@dataclass` decorator** for AST nodes to automatically get `__init__`, `__repr__`, and equality methods\n- **Use `typing` module extensively** for type hints—helps catch errors early and serves as documentation\n- **For recursive structures** (like ASTs), use forward references with string literals: `'Node'` instead of `Node`\n- **Use Python's `contextvars`** for execution context that propagates through async calls\n- **For SQL parameterization**, always use query parameters (`?` or `%s`) never string formatting to prevent injection\n- **Use `asyncio.gather()`** for parallel resolver execution when implementing async version\n\n#### F. Milestone Checkpoint for High-Level Architecture\n\nAfter setting up the project structure (before implementing any components):\n\n1. **Verify Structure**: Run `tree my-graphql-engine/` (or equivalent) to confirm directory structure matches recommendations.\n\n2. **Test HTTP Starter**: Create a simple test file to verify the HTTP server works:\n   ```python\n   # test_server.py\n   from src.graphql_engine.server.http_handler import start_server\n   \n   def dummy_executor(query, variables, operation_name):\n       return {\"data\": {\"test\": \"Hello GraphQL\"}}\n   \n   if __name__ == \"__main__\":\n       # Should start server on localhost:8000\n       start_server(dummy_executor, debug=True)\n   ```\n   - Expected: Server starts, visit `http://localhost:8000/graphiql` shows GraphiQL interface\n   - Send test query `{ test }` should return `{\"data\": {\"test\": \"Hello GraphQL\"}}`\n\n3. **Import Check**: Create `src/graphql_engine/__init__.py` with the skeleton `GraphQLEngine` class above. Verify no syntax errors:\n   ```bash\n   python -m py_compile src/graphql_engine/__init__.py\n   ```\n\n**Signs of Problems**:\n- ❌ \"ModuleNotFoundError: No module named 'graphql_engine'\" → Check PYTHONPATH or install package in development mode (`pip install -e .`)\n- ❌ HTTP server fails to start → Port 8000 might be in use, try `port=8001`\n- ❌ GraphiQL interface doesn't load → Check internet connection (CDN resources) or use local GraphiQL build\n\n#### G. Debugging Tips for Architecture Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Circular import error | Components importing each other | Check import statements in each module | Reorganize to follow layered dependencies (Parser → Type System → Execution) |\n| Memory usage grows with queries | AST nodes not being garbage collected | Use `tracemalloc` to track allocations | Ensure AST nodes don't hold references to execution state |\n| Response missing nested data | Result shaping not handling joins properly | Log raw database rows and compare to expected structure | Check SQL compiler column aliasing and result mapping logic |\n| Queries slow with depth | Generating separate SQL per level instead of joins | Enable SQL logging and count queries | Implement join detection in SQL compiler for nested fields |\n| Can't find database tables | Reflection querying wrong schema | Log the exact SQL used for introspection | Check database permissions and schema name in connection |\n\n\n## Data Model\n\n> **Milestone(s):** This section establishes the foundational data structures that underpin all five milestones. The AST node types (Milestone 1) capture the parsed query, the type system types (Milestone 2) define the schema, the execution context (Milestone 3) manages runtime state, and the SQL intermediate representation (Milestone 5) bridges the GraphQL and SQL worlds.\n\nThe data model is the backbone of our GraphQL engine—it defines how we represent GraphQL queries, schemas, execution state, and database operations in memory. Think of it as the **blueprint language** that all components use to communicate. If the components were departments in a company (parsing, execution, compilation), the data model would be the standard forms and documents they exchange.\n\nThis section details four core families of data structures:\n1. **AST Node Types**: The parsed, in-memory tree representation of a GraphQL query string.\n2. **Type System Types**: The definitions of allowed data shapes (scalars, objects, etc.) that constitute a GraphQL schema.\n3. **Execution Context and State**: The runtime workspace that tracks progress, errors, and shared data during query resolution.\n4. **SQL Intermediate Representation (IR)**: A bridge structure that captures the intent of a GraphQL query in SQL terms before generating the final SQL string.\n\n### AST Node Types\n\n**Mental Model: The Family Tree**\nThink of a GraphQL query as a family tree. The `Document` is the entire family (the query document). `OperationDefinition` nodes are the main branches (query, mutation, subscription). Each branch has smaller twigs (`SelectionSet`), which hold leaves (`Field`). Some leaves have their own mini-branches (nested `SelectionSet`). Fragments are like sub-trees that can be grafted onto multiple branches. The AST is this entire family tree drawn on paper, with every member's name, location, and relationships explicitly recorded.\n\nThe Abstract Syntax Tree (AST) is the primary output of the parser (Milestone 1). It is a lossless, structured representation of the GraphQL query string that preserves every syntactic detail—field names, arguments, directives, fragment spreads, and their exact locations in the source text. This tree is what the execution engine and SQL compiler will later traverse.\n\nAll AST nodes inherit from a base `Node` type, which provides source location tracking. This is crucial for meaningful error messages (e.g., \"Argument 'id' expected type 'ID!' at line 5, column 12\").\n\n#### Core AST Node Hierarchy and Data Structures\n\nThe following table details the complete hierarchy and fields of each AST node type. The inheritance relationship is: `Document` → `Definition` → `OperationDefinition` → `SelectionSet` → `Selection` → `Field`. Parallel branches exist for fragments and other definitions.\n\n| Type Name | Parent Type | Fields | Field Type | Description |\n|-----------|-------------|--------|------------|-------------|\n| `Location` | (none) | `line` | `int` | 1-indexed line number in the source text. |\n| | | `column` | `int` | 1-indexed column number in the source text. |\n| `Node` | (none) | `loc` | `Optional[Location]` | Source location of this node. Present if the parser was configured to include it. |\n| `Document` | `Node` | `definitions` | `List[Definition]` | List of operation and fragment definitions in this document. |\n| `Definition` | `Node` | (none, base class) | | Abstract base for definitions in a document. |\n| `OperationDefinition` | `Definition` | `operation_type` | `str` | One of: \"query\", \"mutation\", \"subscription\". |\n| | | `name` | `Optional[str]` | Optional name of the operation (e.g., \"GetUser\"). |\n| | | `variable_definitions` | `List[VariableDefinition]` | Variable declarations (`($id: ID!)`). |\n| | | `directives` | `List[Directive]` | Operation-level directives (e.g., `@deprecated`). |\n| | | `selection_set` | `SelectionSet` | The root selection set of fields to fetch. |\n| `FragmentDefinition` | `Definition` | `name` | `str` | Name of the fragment (e.g., \"UserFields\"). |\n| | | `type_condition` | `NamedType` | The type this fragment applies to (e.g., `User`). |\n| | | `directives` | `List[Directive]` | Fragment-level directives. |\n| | | `selection_set` | `SelectionSet` | The selection set of fields to include when this fragment is spread. |\n| `SelectionSet` | `Node` | `selections` | `List[Selection]` | List of fields, fragment spreads, or inline fragments. |\n| `Selection` | `Node` | (none, base class) | | Abstract base for items in a selection set. |\n| `Field` | `Selection` | `name` | `str` | The name of the field as defined in the schema (e.g., \"email\"). |\n| | | `alias` | `Optional[str]` | Optional alias for the field (e.g., \"userEmail: email\"). |\n| | | `arguments` | `List[Argument]` | List of arguments provided to this field. |\n| | | `directives` | `List[Directive]` | Field-level directives (e.g., `@include(if: $show)`). |\n| | | `selection_set` | `Optional[SelectionSet]` | Nested selection set for object-type fields. `None` for scalar fields. |\n| `FragmentSpread` | `Selection` | `name` | `str` | Name of the fragment to spread (e.g., \"UserFields\"). |\n| | | `directives` | `List[Directive]` | Directives applied to this spread. |\n| `InlineFragment` | `Selection` | `type_condition` | `Optional[NamedType]` | Optional type condition (e.g., `... on User`). If `None`, it's an unconditional inline fragment. |\n| | | `directives` | `List[Directive]` | Directives applied to this inline fragment. |\n| | | `selection_set` | `SelectionSet` | The selection set for this fragment. |\n| `Argument` | `Node` | `name` | `str` | Name of the argument (e.g., \"id\"). |\n| | | `value` | `Value` | The value provided, which can be a literal, variable, list, or object. |\n| `Directive` | `Node` | `name` | `str` | Name of the directive (e.g., \"include\"). |\n| | | `arguments` | `List[Argument]` | Arguments passed to the directive. |\n| `VariableDefinition` | `Node` | `variable` | `Variable` | The variable being defined (e.g., `$id`). |\n| | | `type` | `Type` | The expected GraphQL type (e.g., `ID!`). |\n| | | `default_value` | `Optional[Value]` | Optional default value if the variable is not provided. |\n| `Variable` | `Value` | `name` | `str` | Name of the variable without the `$` prefix (e.g., \"id\"). |\n| `NamedType` | `Type` | `name` | `str` | Name of the referenced type (e.g., \"User\", \"ID\"). |\n| `ListType` | `Type` | `type` | `Type` | The type of items in the list (e.g., `[String]`). |\n| `NonNullType` | `Type` | `type` | `Type` | The wrapped type that is made non-null (e.g., `String!`). |\n| `Value` | `Node` | (none, base class) | | Abstract base for all value literals and variables. |\n| `IntValue` | `Value` | `value` | `int` | Integer literal (e.g., `42`). |\n| `FloatValue` | `Value` | `value` | `float` | Floating-point literal (e.g., `3.14`). |\n| `StringValue` | `Value` | `value` | `str` | String literal (e.g., `\"hello\"`). |\n| `BooleanValue` | `Value` | `value` | `bool` | Boolean literal (`true` or `false`). |\n| `EnumValue` | `Value` | `value` | `str` | Enum literal (e.g., `PUBLISHED`). |\n| `NullValue` | `Value` | (none) | | Represents the literal `null`. |\n| `ListValue` | `Value` | `values` | `List[Value]` | List of values (e.g., `[\"a\", \"b\"]`). |\n| `ObjectValue` | `Value` | `fields` | `List[ObjectField]` | Key-value pairs (e.g., `{x: 1, y: 2}`). |\n| `ObjectField` | `Node` | `name` | `str` | Field name in the object literal. |\n| | | `value` | `Value` | The value for this field. |\n\n> **Architecture Decision: Immutable AST**\n> - **Context**: The AST is produced by the parser and then read by multiple downstream components (validator, executor, compiler). These components may traverse the tree concurrently or in multiple passes.\n> - **Options Considered**:\n>   1. **Mutable AST with parent pointers**: Nodes contain references to their parent, allowing easy upward traversal. Nodes can be modified in-place (e.g., fragment expansion).\n>   2. **Immutable AST without parent pointers**: Nodes are frozen after creation; traversal is only downward via children. Modifications require creating new trees.\n> - **Decision**: Immutable AST without parent pointers.\n> - **Rationale**:\n>   - **Thread Safety**: Immutability guarantees safe concurrent traversal, which is useful for parallel field execution and static analysis.\n>   - **Predictability**: The AST reflects exactly what was parsed, making debugging easier. Fragment expansion can be done as a separate transformation pass that produces a new tree.\n>   - **Simpler Memory Management**: No circular references (parent-child) ease garbage collection in some languages and prevent accidental leaks.\n> - **Consequences**:\n>   - Fragment expansion and other transformations must copy the affected subtree, which has a memory/performance cost.\n>   - Traversing upward (e.g., from a field to its enclosing operation) requires external context tracking or a separate visitor pattern that maintains a stack.\n\n**Common Pitfalls in AST Design:**\n- ⚠️ **Pitfall: Forgetting Location Tracking**\n  - **Description**: Omitting the `loc` field or not populating it during parsing.\n  - **Why it's wrong**: Error messages become useless (\"Error in query\" without line/column). Debugging complex queries becomes a guessing game.\n  - **Fix**: Ensure every node created by the parser receives a `Location` object. The tokenizer must track line/column numbers for each token.\n- ⚠️ **Pitfall: Mixing Value and Type Hierarchies**\n  - **Description**: Representing `IntValue` and `IntType` with the same class because both contain an integer.\n  - **Why it's wrong**: They are fundamentally different concepts. A value is a runtime literal; a type is a schema definition. Merging them causes confusion in later stages (e.g., type checking).\n  - **Fix**: Maintain separate class hierarchies for `Value` and `Type` nodes, even if they look similar.\n- ⚠️ **Pitfall: Overlooking Directive Locations**\n  - **Description**: Not storing directives on all applicable AST nodes (operations, fields, fragments, etc.).\n  - **Why it's wrong**: Directives like `@include`, `@skip`, or custom directives are part of the query semantics and must be available to the executor.\n  - **Fix**: Include a `directives: List[Directive]` field on every node type that can have directives per the GraphQL spec.\n\n### Type System Types\n\n**Mental Model: The Building Code**\nIf the GraphQL schema were a city, the type system would be its building code. It defines what structures are allowed (`ObjectType` = houses, `ScalarType` = bricks), how they connect (`InterfaceType` = blueprints for neighborhoods), and the rules they must follow (`NonNull` = required safety features). Just as a building inspector ensures constructions follow the code, the type system validates that queries and data conform to the schema.\n\nThe type system represents the GraphQL schema defined by the user or reflected from the database (Milestone 2, Milestone 4). It is a runtime model used to validate queries, guide execution, and generate introspection responses. Each GraphQL type kind has a corresponding class, with a common base `GraphQLType`.\n\n#### Type System Class Hierarchy and Data Structures\n\nThe following table details all type system classes, their fields, and purposes. The hierarchy is: `GraphQLType` → `ScalarType`, `ObjectType`, `InterfaceType`, `UnionType`, `EnumType`, `InputObjectType`, with wrapper types `ListType` and `NonNullType` also extending `GraphQLType`.\n\n| Type Name | Parent Type | Fields | Field Type | Description |\n|-----------|-------------|--------|------------|-------------|\n| `GraphQLType` | (none) | `name` | `str` | The name of the type (e.g., \"User\", \"ID\"). For wrapper types, this is often derived (e.g., \"[User]\"). |\n| | | `description` | `Optional[str]` | Optional description for documentation/introspection. |\n| `ScalarType` | `GraphQLType` | `serialize` | `Callable[[Any], Any]` | Function to convert a Python value to a suitable output format (e.g., datetime to ISO string). |\n| | | `parse_value` | `Callable[[Any], Any]` | Function to convert a variable value (JSON) to the internal representation. |\n| | | `parse_literal` | `Callable[[Value], Any]` | Function to convert an AST literal node to the internal representation. |\n| `ObjectType` | `GraphQLType` | `fields` | `Dict[str, GraphQLField]` | Map of field name to field definition. |\n| | | `interfaces` | `List[InterfaceType]` | List of interfaces this object implements. |\n| `GraphQLField` | (none) | `type` | `GraphQLType` | The return type of this field. |\n| | | `args` | `Dict[str, GraphQLArgument]` | Map of argument name to argument definition. |\n| | | `resolve` | `Optional[Callable]` | Optional resolver function. If `None`, a default property resolver is used. |\n| | | `description` | `Optional[str]` | Field description. |\n| | | `deprecation_reason` | `Optional[str]` | If set, the field is deprecated with this reason. |\n| `GraphQLArgument` | (none) | `type` | `GraphQLType` | The expected type of the argument. |\n| | | `default_value` | `Any` | Default value if the argument is not provided. |\n| | | `description` | `Optional[str]` | Argument description. |\n| `InterfaceType` | `GraphQLType` | `fields` | `Dict[str, GraphQLField]` | Map of field name to field definition (abstract). |\n| | | `resolve_type` | `Optional[Callable[[Any], ObjectType]]` | Optional function to determine the concrete object type for a given value. |\n| `UnionType` | `GraphQLType` | `types` | `List[ObjectType]` | List of possible object types that this union can represent. |\n| | | `resolve_type` | `Optional[Callable[[Any], ObjectType]]` | Optional function to determine the concrete object type for a given value. |\n| `EnumType` | `GraphQLType` | `values` | `Dict[str, EnumValue]` | Map of enum value name to its definition. |\n| `EnumValue` | (none) | `value` | `Any` | The underlying value (often a string matching the name). |\n| | | `description` | `Optional[str]` | Description of this enum value. |\n| | | `deprecation_reason` | `Optional[str]` | Deprecation reason, if applicable. |\n| `InputObjectType` | `GraphQLType` | `fields` | `Dict[str, GraphQLInputField]` | Map of field name to input field definition. |\n| `GraphQLInputField` | (none) | `type` | `GraphQLType` | The expected type of the input field. |\n| | | `default_value` | `Any` | Default value if not provided. |\n| | | `description` | `Optional[str]` | Field description. |\n| `ListType` | `GraphQLType` | `of_type` | `GraphQLType` | The type of items in the list. |\n| `NonNullType` | `GraphQLType` | `of_type` | `GraphQLType` | The wrapped type that is made non-null. |\n| `Schema` | (none) | `query_type` | `ObjectType` | The root query object type. |\n| | | `mutation_type` | `Optional[ObjectType]` | Optional root mutation object type. |\n| | | `subscription_type` | `Optional[ObjectType]` | Optional root subscription object type. |\n| | | `types` | `Dict[str, GraphQLType]` | Map of all named types in the schema, keyed by name. |\n| | | `directives` | `Dict[str, GraphQLDirective]` | Map of all directives supported by the schema. |\n| `GraphQLDirective` | (none) | `name` | `str` | Name of the directive (e.g., \"include\"). |\n| | | `locations` | `List[str]` | Where this directive can be used (e.g., [\"FIELD\", \"FRAGMENT_SPREAD\"]). |\n| | | `args` | `Dict[str, GraphQLArgument]` | Arguments the directive accepts. |\n| | | `description` | `Optional[str]` | Directive description. |\n\n> **Architecture Decision: Dual-Type Representation for Wrappers**\n> - **Context**: GraphQL has type modifiers: `List` and `NonNull`. These can be nested (e.g., `[String!]!`). We need to represent these in memory for type validation and introspection.\n> - **Options Considered**:\n>   1. **Inline flags**: Add `is_list` and `is_non_null` boolean fields to `GraphQLType`, with an `inner_type` field for the wrapped type. Nesting is represented by chaining `inner_type`.\n>   2. **Wrapper objects**: Create separate `ListType` and `NonNullType` classes that wrap another `GraphQLType`. Nesting is represented by a chain of wrapper objects.\n> - **Decision**: Wrapper objects (`ListType`, `NonNullType`).\n> - **Rationale**:\n>   - **Spec Compliance**: The GraphQL introspection system returns wrapper types as separate objects with `kind` fields. The wrapper object approach maps directly to this.\n>   - **Type Safety**: The type system can use isinstance checks (`isinstance(t, ListType)`) which is clearer than checking boolean flags.\n>   - **Recursive Simplicity**: Algorithms for unwrapping (e.g., getting the underlying named type) become simple loops (`while isinstance(t, WrapperType): t = t.of_type`).\n> - **Consequences**:\n>   - Slightly more memory overhead due to many small objects.\n>   - Equality checks require recursive traversal (e.g., two `[String!]` types are equal only if their inner types are equal).\n\n**Common Pitfalls in Type System Design:**\n- ⚠️ **Pitfall: Confusing Input and Output Types**\n  - **Description**: Using the same class for `ObjectType` and `InputObjectType`, or allowing input types to be used as output field types.\n  - **Why it's wrong**: GraphQL strictly separates input and output types. Input types cannot have arguments or interfaces; output types cannot be used as argument types. Mixing them leads to validation errors and runtime confusion.\n  - **Fix**: Maintain separate class hierarchies for input and output types, with validation during schema building that ensures correct usage.\n- ⚠️ **Pitfall: Missing Circular Reference Detection**\n  - **Description**: Allowing a type to reference itself indefinitely (e.g., `type User { friends: [User] }` is valid, but `type Circular { field: Circular }` as an input type is not).\n  - **Why it's wrong**: GraphQL forbids circular references in input types. Infinite recursion during validation or serialization can crash the engine.\n  - **Fix**: During schema building, perform a depth-first search to detect cycles in input type references, and raise a validation error.\n- ⚠️ **Pitfall: Forgetting Introspection Types**\n  - **Description**: Not including the built-in introspection types (`__Schema`, `__Type`, `__Field`, etc.) in the schema's type map.\n  - **Why it's wrong**: GraphQL introspection queries (used by tools like GraphiQL) will fail, breaking developer experience.\n  - **Fix**: Always add the introspection types to the schema's `types` dictionary. They can be generated statically.\n\n### Execution Context and State\n\n**Mental Model: The Restaurant Ticket**\nImagine a GraphQL query as a customer's order at a restaurant. The **execution context** is the kitchen ticket attached to that order. It tracks the order's progress through different stations (resolvers), any special instructions (context variables like allergy info), errors (\"86 salmon\"), and the final assembled dishes (data). As the ticket moves through the kitchen, each station adds its output and notes.\n\nThe execution context holds all runtime information needed to resolve a GraphQL query (Milestone 3). It is passed to every resolver function, providing access to shared resources, the current field's information, and a place to collect errors. It also manages the **DataLoader** instances that batch and cache database requests to solve the N+1 problem.\n\n#### Execution State Data Structures\n\n| Type Name | Fields | Field Type | Description |\n|-----------|--------|------------|-------------|\n| `ExecutionContext` | `schema` | `Schema` | The GraphQL schema being executed against. |\n| | `document_ast` | `Document` | The parsed AST of the operation to execute. |\n| | `operation_name` | `Optional[str]` | Name of the operation to execute (if multiple in document). |\n| | `variable_values` | `Dict[str, Any]` | Map of variable name to coerced value. |\n| | `context_value` | `Any` | The user-provided context object (often includes database connection, auth info). |\n| | `root_value` | `Any` | The initial value for the root type (often `None`). |\n| | `fragments` | `Dict[str, FragmentDefinition]` | Map of fragment name to AST definition, for quick lookup. |\n| | `errors` | `List[GraphQLError]` | Errors collected during execution. |\n| | `data_loaders` | `Dict[str, DataLoader]` | Map of loader name to DataLoader instance for batching. |\n| | `path` | `List[PathSegment]` | Current execution path as a stack (e.g., `[\"user\", \"friends\", 0, \"name\"]`). |\n| | `field_resolver` | `Callable` | The default field resolver function (falls back to property access). |\n| | `type_resolver` | `Callable` | The default type resolver for abstract types. |\n| `GraphQLError` | `message` | `str` | Human-readable error message. |\n| | `locations` | `List[Location]` | Source locations where the error occurred (from AST nodes). |\n| | `path` | `List[PathSegment]` | Execution path to the field where the error originated. |\n| | `original_error` | `Optional[Exception]` | The underlying exception that caused this error, if any. |\n| | `extensions` | `Dict[str, Any]` | Optional map for custom error metadata. |\n| `PathSegment` | (union type) | `str \\| int` | Either a field name (for object fields) or an index (for list items). |\n| `DataLoader` | `batch_load_fn` | `Callable[[List[Any]], List[Any]]` | Function that receives a list of keys and returns a list of values or promises. |\n| | `cache` | `Dict[Any, Any]` | Map of key to resolved value (or promise). |\n| | `queue` | `List[Any]` | Keys pending batch resolution. |\n| | `max_batch_size` | `int` | Maximum number of keys to batch in one call. |\n| `ExecutionResult` | `data` | `Optional[Dict[str, Any]]` | The result data if execution succeeded (partial data may be present even with errors). |\n| | `errors` | `List[GraphQLError]` | Errors encountered during execution. |\n| | `extensions` | `Dict[str, Any]` | Optional extension metadata for the response. |\n\n> **Architecture Decision: Mutable Execution Context vs. Immutable Per-Resolve Context**\n> - **Context**: Resolver functions need access to execution state (path, variables, context value). This state changes as execution traverses the query tree.\n> - **Options Considered**:\n>   1. **Mutable shared context**: A single `ExecutionContext` object passed to all resolvers, with mutable fields like `path` updated in-place as execution depth changes.\n>   2. **Immutable per-resolve context**: Create a new context object for each field resolution, copying or deriving state (e.g., appending to path).\n> - **Decision**: Mutable shared context with careful stack management.\n> - **Rationale**:\n>   - **Performance**: Creating new context objects for every field (potentially thousands) adds overhead. Mutation is cheaper.\n>   - **Simplicity**: The path can be managed as an explicit stack: push before resolving a field, pop after. This mirrors the natural recursion of execution.\n>   - **Predictability**: The context is single-threaded per request, so mutability is safe. Concurrency is handled at the field level via async, not threads.\n> - **Consequences**:\n>   - Resolvers must not modify context fields they shouldn't (e.g., they shouldn't mutate `path` directly). Provide helper methods (`context.push_path(), context.pop_path()`).\n>   - Special care needed for parallel execution of sibling fields—each parallel branch needs a snapshot of the path or must coordinate to avoid corrupting the shared path.\n\n**Algorithm for Field Execution with Context:**\n1. **Initialize context**: Create `ExecutionContext` with schema, document, variables, root value, and empty error list.\n2. **Select operation**: If `operation_name` is provided, find the matching `OperationDefinition` in the document; otherwise, if there's exactly one operation, use it.\n3. **Coerce variables**: For each `VariableDefinition` in the operation, coerce the input `variable_values` using the variable's type. Add errors to context for invalid values.\n4. **Execute operation**: Call `execute_operation(context, root_type, root_value)`:\n   1. Determine the root object type (`query_type`, `mutation_type`, or `subscription_type`).\n   2. Create a `SelectionSet` from the operation's `selection_set`.\n   3. Call `execute_fields(context, root_type, root_value, selection_set)`.\n5. **Execute fields** (recursive):\n   1. Create an empty `result_dict`.\n   2. For each `selection` in the `selection_set`:\n      - If selection is a `Field`:\n        1. **Push path**: Append field's alias or name to `context.path`.\n        2. **Resolve field**: Call `resolve_field(context, parent_type, parent_value, field)`.\n        3. **Pop path**: Remove the last element from `context.path`.\n        4. Store the resolved value in `result_dict` under the output key (alias or name).\n      - If selection is a `FragmentSpread` or `InlineFragment`:\n        1. Check type condition against `parent_type`. If it doesn't apply, skip.\n        2. Recursively `execute_fields` with the fragment's `selection_set`.\n        3. Merge results into `result_dict`.\n   3. Return `result_dict`.\n6. **Resolve field**:\n   1. **Coerce arguments**: For each argument in the field's AST, coerce the value using the argument's type from the schema.\n   2. **Get resolver**: Look up the resolver function for this field on the parent type. If none, use `context.field_resolver`.\n   3. **Call resolver**: Invoke resolver with `(parent_value, arguments, context, info)`, where `info` is a `ResolveInfo` object containing field details.\n   4. **Handle result**:\n      - If resolver returns an exception, add a `GraphQLError` to context.\n      - If resolver returns a value, coerce it to the field's declared type (handling nullability, lists, etc.).\n      - If the coerced value is an object type and the field has a `selection_set`, recursively `execute_fields`.\n\n**Common Pitfalls in Execution State Design:**\n- ⚠️ **Pitfall: Not Propagating Null Correctly**\n  - **Description**: When a non-null field resolves to `null`, the engine fails to bubble that null up to the nearest nullable parent, causing the entire query to fail incorrectly.\n  - **Why it's wrong**: GraphQL spec requires that if a non-null field returns null, that null propagates, making the parent field null (or if the parent is also non-null, continuing up). This allows partial data to be returned with errors.\n  - **Fix**: In `resolve_field`, after coercing the value, if the result is `null` and the field's type is `NonNullType`, add an error to context and return `null`. The caller (`execute_fields`) must detect this and propagate it.\n- ⚠️ **Pitfall: Forgetting to Clone Path for Parallel Execution**\n  - **Description**: When resolving sibling fields in parallel (e.g., `{ user { name email } }`), using a mutable shared `path` leads to race conditions where one field's path overwrites another's.\n  - **Why it's wrong**: Errors will have incorrect paths, making debugging impossible. Execution may become non-deterministic.\n  - **Fix**: Before dispatching parallel field resolution, take a snapshot of the current path (or create a new context copy) for each branch. Alternatively, make `path` immutable and pass it as an argument to `resolve_field`.\n- ⚠️ **Pitfall: DataLoader Cache Pollution Across Requests**\n  - **Description**: Using a single `DataLoader` instance across multiple GraphQL requests, causing cached data from one user to leak to another.\n  - **Why it's wrong**: Security and data isolation violation. User A might see User B's data if IDs happen to match.\n  - **Fix**: Create a new `DataLoader` instance per request, attached to `ExecutionContext.data_loaders`. The cache is then request-scoped and garbage-collected after the request.\n\n### SQL Intermediate Representation\n\n**Mental Model: The Construction Plan**\nTranslating a GraphQL query to SQL is like turning an architect's sketch (GraphQL) into a builder's detailed plan (SQL). The **SQL IR** is that plan—a step-by-step breakdown that says: \"We need to query the `users` table, join with `posts` on `user_id`, filter where `status = 'active'`, and return columns `id`, `name`, and `posts.title`.\" It's an intermediate representation that's closer to SQL than GraphQL but not yet a specific SQL dialect string, allowing for optimizations and parameter binding.\n\nThe SQL IR bridges the GraphQL AST and the final SQL query (Milestone 5). It is a tree or pipeline structure that captures the relational operations needed to fulfill the GraphQL query: which tables to select from, how to join them, what filters to apply, and what columns to return. This IR can be optimized (e.g., reorder joins, push down filters) before being rendered to a specific SQL dialect.\n\n#### SQL IR Data Structures\n\n| Type Name | Fields | Field Type | Description |\n|-----------|--------|------------|-------------|\n| `SQLQuery` | `root_select` | `SQLSelect` | The top-level SELECT statement (often corresponds to the GraphQL query root). |\n| | `variables` | `Dict[str, Any]` | Map of parameter names to values for safe SQL parameterization. |\n| | `result_mapper` | `Callable[[Dict], Dict]` | Function to transform flat SQL row results into nested GraphQL response shape. |\n| `SQLSelect` | `from_table` | `SQLTable` | Primary table or subquery being selected from. |\n| | `joins` | `List[SQLJoin]` | List of joins to other tables. |\n| | `where` | `Optional[SQLExpression]` | WHERE clause condition expression. |\n| | `order_by` | `List[SQLOrderBy]` | ORDER BY clauses. |\n| | `limit` | `Optional[int]` | LIMIT clause. |\n| | `offset` | `Optional[int]` | OFFSET clause. |\n| | `columns` | `List[SQLColumn]` | Columns to select (can be from primary table or joined tables). |\n| | `distinct` | `bool` | Whether to add DISTINCT. |\n| | `group_by` | `List[SQLColumn]` | GROUP BY columns (for aggregations). |\n| `SQLTable` | `name` | `str` | Database table name (or alias). |\n| | `schema` | `Optional[str]` | Database schema (e.g., \"public\"). |\n| | `alias` | `Optional[str]` | Alias for this table in the query (e.g., \"u\" for \"users AS u\"). |\n| `SQLJoin` | `type` | `str` | Join type: \"INNER\", \"LEFT\", \"RIGHT\", \"FULL\". |\n| | `table` | `SQLTable` | The table being joined. |\n| | `on` | `SQLExpression` | ON clause condition (e.g., \"users.id = posts.user_id\"). |\n| `SQLColumn` | `table` | `SQLTable` | Table this column belongs to. |\n| | `name` | `str` | Column name. |\n| | `alias` | `Optional[str]` | Output alias (e.g., \"userName\" for \"name AS userName\"). |\n| | `expression` | `Optional[str]` | Optional raw SQL expression (e.g., \"COUNT(*)\" instead of a simple column). |\n| `SQLExpression` | `kind` | `str` | Node type: \"binary\", \"unary\", \"literal\", \"column\", \"parameter\". |\n| | `operator` | `Optional[str]` | For binary/unary: \"=\", \">\", \"AND\", \"NOT\", etc. |\n| | `left` | `Optional[SQLExpression]` | Left operand. |\n| | `right` | `Optional[SQLExpression]` | Right operand. |\n| | `value` | `Any` | For literal/parameter: the value. |\n| | `column` | `Optional[SQLColumn]` | For column reference: the column. |\n| `SQLOrderBy` | `column` | `SQLColumn` | Column to order by. |\n| | `direction` | `str` | \"ASC\" or \"DESC\". |\n| `SQLParameter` | `name` | `str` | Parameter placeholder name (e.g., \"$1\", \":id\"). |\n| | `value` | `Any` | The value to bind. |\n| | `type` | `str` | SQL type hint (e.g., \"int\", \"text\"). |\n\n> **Architecture Decision: SQL IR as a Tree vs. Pipeline**\n> - **Context**: We need to represent relational operations that can be nested (subqueries, joins of joins). The structure should support both simple flat queries and complex nested ones.\n> - **Options Considered**:\n>   1. **Pipeline model**: A linear sequence of operations (Scan → Filter → Join → Project) similar to relational algebra. Each stage transforms a result set.\n>   2. **Tree model**: A hierarchical SELECT tree where each SELECT can have JOIN children, and JOINs can have their own SELECT subtrees. This mirrors SQL's nested nature.\n> - **Decision**: Tree model centered on `SQLSelect`.\n> - **Rationale**:\n>   - **Natural Mapping**: GraphQL's nested selections map directly to nested `SQLSelect` nodes (via joins). A field `user { posts { comments } }` becomes a main SELECT for users, a JOIN to posts, and a sub-SELECT for comments.\n>   - **SQL Generation Simplicity**: Walking the tree and emitting SQL is straightforward—each `SQLSelect` renders to a SELECT clause, with joins rendered as JOIN clauses in the same SELECT.\n>   - **Optimization Opportunities**: The tree can be rearranged (join reordering, filter push-down) by rewriting subtrees without changing the overall pipeline abstraction.\n> - **Consequences**:\n>   - Some operations that are naturally pipeline (e.g., LIMIT after ORDER BY) must be represented as fields within the same `SQLSelect` node, not as separate stages.\n>   - Handling correlated subqueries (where a subquery references columns from outer query) requires careful design of column references across tree levels.\n\n**Algorithm for Generating SQL IR from GraphQL AST:**\n1. **Analyze selection set**: Traverse the GraphQL AST starting at the root field (e.g., `query { users { ... } }`). Identify the primary table mapping from the root field name (`users` → `users` table).\n2. **Create root SQLSelect**: Instantiate `SQLSelect` with `from_table` set to the primary table.\n3. **Process selections recursively**:\n   - For each field in the selection set:\n     - If field is a scalar (maps to a column):\n       1. Add a `SQLColumn` to `columns` list, mapping GraphQL field name to table column name.\n     - If field is an object (maps to a relationship):\n       1. Determine relationship type (one-to-one, one-to-many) via foreign key metadata.\n       2. For one-to-one: Add a `SQLJoin` to the related table, and recursively process the nested selection set, adding columns from the joined table.\n       3. For one-to-many: This becomes either a **lateral join** (for nested array) or a separate batch query. For simplicity, initially implement as a separate batch query (DataLoader pattern).\n4. **Apply filters**: Convert GraphQL field arguments (e.g., `where: { status: \"active\" }`) into `SQLExpression` trees attached to `where`.\n5. **Apply pagination**: Convert `first`, `after`, `offset` arguments into `limit`/`offset` or cursor-based conditions.\n6. **Apply ordering**: Convert `orderBy` argument into `SQLOrderBy` list.\n7. **Collect parameters**: Extract all literal values from GraphQL arguments and replace them with `SQLParameter` placeholders in the SQL IR, storing the actual values in `SQLQuery.variables`.\n\n**Common Pitfalls in SQL IR Design:**\n- ⚠️ **Pitfall: Generating Cartesian Products**\n  - **Description**: When joining multiple one-to-many relationships in the same query level (e.g., `user { posts, comments }`), a naive JOIN leads to a Cartesian product between posts and comments for each user.\n  - **Why it's wrong**: Results explode in size (user with 10 posts and 10 comments yields 100 rows), causing performance issues and incorrect data aggregation.\n  - **Fix**: For multiple one-to-many relationships, use **separate queries** (DataLoader batches) or **lateral joins** that keep the relationships separate. The SQL IR should mark such relationships as requiring separate batch execution.\n- ⚠️ **Pitfall: Not Parameterizing Values**\n  - **Description**: Embedding literal values directly into SQL expressions as strings, leading to SQL injection vulnerabilities.\n  - **Why it's wrong**: Unsafe. A GraphQL argument `where: { name: \"'; DROP TABLE users; --\" }` could cause disaster.\n  - **Fix**: Always use `SQLParameter` nodes for values. The SQL renderer should replace these with placeholders (`$1`, `%s`) and pass values separately to the database driver.\n- ⚠️ **Pitfall: Ignoring Column Aliasing Conflicts**\n  - **Description**: When joining tables with same column names (e.g., `users.id` and `posts.id`), selecting both without aliases leads to duplicate column names in result set, causing mapping errors.\n  - **Why it's wrong**: Database drivers may overwrite one column with another, or the result mapper cannot distinguish which `id` belongs to which table.\n  - **Fix**: Automatically alias columns in `SQLColumn` using a naming scheme (e.g., `users__id`, `posts__id`). The `result_mapper` must use these aliases to reconstruct nested objects.\n\n### Implementation Guidance\n\n#### Technology Recommendations Table\n\n| Component | Simple Option (for learning) | Advanced Option (for production) |\n|-----------|-----------------------------|----------------------------------|\n| **AST & Type System** | Pure Python classes with `dataclasses` or `attrs` for immutable nodes. | Use a library like `graphql-core` for reference implementation, or `pydantic` with validation. |\n| **Execution Context** | Plain Python dict for context, manual path stack management. | Use `contextvars` for async context, `asyncio` for parallel resolution. |\n| **SQL IR** | Simple namedtuple-like classes, string templating for SQL generation. | Use SQLAlchemy Core as a SQL abstraction layer, or a dedicated SQL builder like `pypika`. |\n| **DataLoader** | Manual batching with dictionary caches per request. | Use `aiodataloader` library for async batching and caching. |\n\n#### Recommended File/Module Structure\n\n```\ngraphql_engine/\n├── ast/\n│   ├── __init__.py\n│   ├── nodes.py          # All AST node classes (Location, Document, Field, etc.)\n│   └── parser.py         # Lexer and recursive descent parser (parse_query)\n├── type_system/\n│   ├── __init__.py\n│   ├── types.py          # GraphQLType, ScalarType, ObjectType, etc.\n│   ├── schema.py         # Schema class and validation logic\n│   └── introspection.py  # Introspection type definitions and resolver\n├── execution/\n│   ├── __init__.py\n│   ├── context.py        # ExecutionContext, GraphQLError\n│   ├── executor.py       # execute_query, field resolution algorithms\n│   ├── resolver.py       # Default field resolver, type resolver\n│   └── dataloader.py     # DataLoader class\n├── sql/\n│   ├── __init__.py\n│   ├── ir.py             # SQL IR classes (SQLQuery, SQLSelect, etc.)\n│   ├── compiler.py       # AST-to-SQL IR compilation logic\n│   └── renderer.py       # SQL IR to parameterized SQL string (for PostgreSQL, SQLite)\n├── reflection/\n│   ├── __init__.py\n│   ├── introspector.py   # Database metadata queries\n│   └── mapper.py         # Maps tables to GraphQL types, columns to fields\n└── server.py             # HTTP server (optional, for testing)\n```\n\n#### Infrastructure Starter Code\n\nHere is a complete, ready-to-use implementation of the `Location` and base `Node` classes, which are prerequisites for the AST:\n\n```python\n# ast/nodes.py\nfrom typing import Optional, List, Union, Any\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Location:\n    \"\"\"Source location in a GraphQL document.\"\"\"\n    line: int      # 1-indexed\n    column: int    # 1-indexed\n\n    def __str__(self) -> str:\n        return f\"{self.line}:{self.column}\"\n\nclass Node:\n    \"\"\"Base class for all AST nodes.\"\"\"\n    __slots__ = ('loc',)  # Saves memory, ensures immutability\n\n    def __init__(self, loc: Optional[Location] = None):\n        self.loc = loc\n\n    def __repr__(self) -> str:\n        cls_name = self.__class__.__name__\n        fields = \", \".join(f\"{k}={v!r}\" for k, v in self.__dict__.items() if k != 'loc')\n        if self.loc:\n            return f\"{cls_name}({fields}, loc={self.loc})\"\n        return f\"{cls_name}({fields})\"\n```\n\n#### Core Logic Skeleton Code\n\n**AST Node Skeleton (to be completed by learner):**\n\n```python\n# ast/nodes.py (continued)\n@dataclass(frozen=True)\nclass Document(Node):\n    \"\"\"Complete GraphQL document with definitions.\"\"\"\n    definitions: List['Definition']\n\n    # TODO: Add method to get operation by name\n    # TODO: Add method to get fragment by name\n\nclass Definition(Node):\n    \"\"\"Base for OperationDefinition and FragmentDefinition.\"\"\"\n    pass\n\n@dataclass(frozen=True)\nclass OperationDefinition(Definition):\n    \"\"\"A query, mutation, or subscription operation.\"\"\"\n    operation_type: str  # 'query', 'mutation', 'subscription'\n    name: Optional[str]\n    variable_definitions: List['VariableDefinition']\n    directives: List['Directive']\n    selection_set: 'SelectionSet'\n\n    # TODO: Add method to validate variable usage\n    # TODO: Add method to collect referenced fragment names\n\n@dataclass(frozen=True)\nclass SelectionSet(Node):\n    \"\"\"A set of fields/fragments selected on an object.\"\"\"\n    selections: List['Selection']\n\n    # TODO: Add method to flatten fragments (expand FragmentSpread)\n    # TODO: Add method to get all field names\n\n# TODO: Define remaining AST classes: Field, FragmentDefinition, FragmentSpread,\n#       InlineFragment, Argument, Directive, VariableDefinition, Variable,\n#       NamedType, ListType, NonNullType, and all Value subclasses (IntValue, etc.)\n#       Follow the table structure exactly.\n```\n\n**Type System Skeleton:**\n\n```python\n# type_system/types.py\nfrom typing import Dict, List, Optional, Callable, Any\n\nclass GraphQLType:\n    \"\"\"Base class for all GraphQL types.\"\"\"\n    def __init__(self, name: str, description: Optional[str] = None):\n        self.name = name\n        self.description = description\n\n    # TODO: Add method to get introspection representation (__Type)\n    # TODO: Add method to check type equality (handling wrappers)\n\nclass ScalarType(GraphQLType):\n    \"\"\"GraphQL scalar type.\"\"\"\n    def __init__(self, name: str, serialize: Callable, parse_value: Callable,\n                 parse_literal: Callable, description: Optional[str] = None):\n        super().__init__(name, description)\n        self.serialize = serialize\n        self.parse_value = parse_value\n        self.parse_literal = parse_literal\n\n    # TODO: Add built-in scalars (Int, Float, String, Boolean, ID) as class constants\n\nclass ObjectType(GraphQLType):\n    \"\"\"GraphQL object type.\"\"\"\n    def __init__(self, name: str, fields: Dict[str, 'GraphQLField'],\n                 interfaces: Optional[List['InterfaceType']] = None,\n                 description: Optional[str] = None):\n        super().__init__(name, description)\n        self.fields = fields\n        self.interfaces = interfaces or []\n\n    # TODO: Add method to get field by name (including from interfaces)\n    # TODO: Add method to validate interface implementations\n\n# TODO: Define GraphQLField, GraphQLArgument, InterfaceType, UnionType,\n#       EnumType, EnumValue, InputObjectType, GraphQLInputField,\n#       ListType, NonNullType, Schema, GraphQLDirective.\n#       Follow the table structure exactly.\n```\n\n**ExecutionContext Skeleton:**\n\n```python\n# execution/context.py\nfrom typing import Dict, List, Optional, Any, Union\nfrom dataclasses import dataclass, field\nfrom ..ast.nodes import Document, Location\nfrom ..type_system.schema import Schema\n\nPathSegment = Union[str, int]\n\n@dataclass\nclass ExecutionContext:\n    \"\"\"Runtime context for executing a GraphQL query.\"\"\"\n    schema: Schema\n    document_ast: Document\n    operation_name: Optional[str] = None\n    variable_values: Dict[str, Any] = field(default_factory=dict)\n    context_value: Any = None\n    root_value: Any = None\n    fragments: Dict[str, Any] = field(default_factory=dict)  # Maps name to FragmentDefinition\n    errors: List['GraphQLError'] = field(default_factory=list)\n    data_loaders: Dict[str, 'DataLoader'] = field(default_factory=dict)\n    path: List[PathSegment] = field(default_factory=list)\n    field_resolver: Callable = None\n    type_resolver: Callable = None\n\n    # TODO: Add method push_path(segment) -> context manager (for `with context.push_path(...):`)\n    # TODO: Add method get_data_loader(key, batch_load_fn) -> returns existing or creates new DataLoader\n    # TODO: Add method to coerce variable values based on operation's variable definitions\n\n@dataclass\nclass GraphQLError(Exception):\n    \"\"\"GraphQL execution error with location and path.\"\"\"\n    message: str\n    locations: List[Location] = field(default_factory=list)\n    path: List[PathSegment] = field(default_factory=list)\n    original_error: Optional[Exception] = None\n    extensions: Dict[str, Any] = field(default_factory=dict)\n\n    # TODO: Add method to format error for JSON response (per GraphQL spec)\n    # TODO: Add class method from_exception to wrap Python exceptions\n\n# TODO: Implement DataLoader class with batch scheduling and caching.\n```\n\n**SQL IR Skeleton:**\n\n```python\n# sql/ir.py\nfrom typing import List, Optional, Dict, Any, Callable\nfrom dataclasses import dataclass\n\n@dataclass\nclass SQLQuery:\n    \"\"\"Complete SQL query representation.\"\"\"\n    root_select: 'SQLSelect'\n    variables: Dict[str, Any] = field(default_factory=dict)\n    result_mapper: Optional[Callable[[Dict], Dict]] = None\n\n    # TODO: Add method to render to SQL string with placeholders\n    # TODO: Add method to execute via database adapter\n\n@dataclass\nclass SQLSelect:\n    \"\"\"A SELECT statement.\"\"\"\n    from_table: 'SQLTable'\n    joins: List['SQLJoin'] = field(default_factory=list)\n    where: Optional['SQLExpression'] = None\n    order_by: List['SQLOrderBy'] = field(default_factory=list)\n    limit: Optional[int] = None\n    offset: Optional[int] = None\n    columns: List['SQLColumn'] = field(default_factory=list)\n    distinct: bool = False\n    group_by: List['SQLColumn'] = field(default_factory=list)\n\n    # TODO: Add method to add column with auto-alias\n    # TODO: Add method to find join by table name\n\n# TODO: Define SQLTable, SQLJoin, SQLColumn, SQLExpression, SQLOrderBy, SQLParameter.\n#       Follow the table structure exactly.\n```\n\n#### Language-Specific Hints (Python)\n\n- Use `@dataclass(frozen=True)` for immutable AST nodes to ensure hashability and prevent accidental mutation.\n- For type checking, use `typing` module extensively. Consider `Protocol` for resolver interfaces.\n- Use `contextvars.ContextVar` for async context if you implement async resolvers.\n- For SQL parameterization, use `%s` placeholders with PostgreSQL's `psycopg2` or SQLite's `sqlite3`. Never use string formatting.\n- Use `asyncio.gather` for parallel field resolution in async executors.\n- Consider `functools.lru_cache` for memoizing schema introspection results.\n\n#### Milestone Checkpoint for Data Model\n\nAfter implementing the data structures above (but before implementing parsers or executors), you should be able to run:\n\n```bash\npython -m pytest graphql_engine/ast/nodes.py -v\n```\n\nExpected: Tests for AST node creation and equality should pass. Example test:\n\n```python\ndef test_field_node():\n    loc = Location(line=1, column=2)\n    field = Field(name=\"id\", alias=None, arguments=[], directives=[], selection_set=None, loc=loc)\n    assert field.name == \"id\"\n    assert field.loc == loc\n    assert isinstance(field, Node)\n```\n\nSigns something is wrong:\n- **Error**: `TypeError: cannot set attribute` on a frozen dataclass. → You tried to modify an immutable node. Ensure you're not mutating after creation.\n- **Error**: `RecursionError` when printing a node. → Likely circular reference in `__repr__`. Check that you're not following relationships indefinitely (e.g., `Field` referencing its parent `SelectionSet`).\n- **Warning**: Mypy reports missing fields. → Check that you've implemented all fields from the tables above.\n\n\n## Component 1: GraphQL Parser\n\n> **Milestone(s):** This section corresponds to Milestone 1: GraphQL Parser, which focuses on converting GraphQL query strings into Abstract Syntax Trees (ASTs).\n\n### Responsibility and Scope\n\nThe GraphQL Parser is the system's **front door**—it takes raw GraphQL query strings from clients and transforms them into structured, machine-readable representations. Think of it as the **optical character recognition** system for a document scanner: it doesn't understand the content's meaning (that's for validators and executors), but it must perfectly recognize and digitize every character, word, and sentence structure.\n\n| Responsibility | In Scope | Out of Scope |\n|----------------|----------|--------------|\n| **Lexical Analysis** | Break query string into tokens (keywords, identifiers, punctuation) | Validate token semantics (e.g., \"query\" vs. \"mutation\" meaning) |\n| **Syntactic Analysis** | Build AST following GraphQL grammar rules | Validate AST against schema (type checking, field existence) |\n| **Source Location Tracking** | Record line/column for every AST node | Error recovery and intelligent suggestions |\n| **Document Structure** | Parse operations, fragments, variables, directives | Execute operations or resolve field values |\n| **Literal Value Parsing** | Convert string/number/boolean literals to Python values | Validate literal ranges (e.g., Int within 32-bit range) |\n| **Query Document Assembly** | Build complete `Document` AST with all definitions | Optimize or normalize the query structure |\n\nThe parser's output is a **syntactically correct but semantically unvalidated** AST. It ensures the query is well-formed according to GraphQL's grammar, but doesn't verify that referenced types exist, fields are valid, or variables match their declared types. This separation follows the **compiler principle** of separating syntax (form) from semantics (meaning).\n\n### Mental Model: Language Translator\n\nImagine you're **translating a restaurant order from a customer's scribbled note into a structured kitchen ticket**. The customer writes:\n\n```\nLarge pepperoni pizza, extra cheese\nNo mushrooms\nAdd: 2 garlic bread\nDiet Coke\n```\n\nA human translator would:\n1. **Tokenize**: Recognize \"Large\" as size, \"pepperoni\" as topping, \"2\" as quantity\n2. **Structure**: Group items into categories (pizza, sides, drinks)\n3. **Resolve references**: Link \"extra cheese\" to the pizza, not the garlic bread\n4. **Handle modifiers**: Apply \"No mushrooms\" as an exclusion, not an addition\n\nThe GraphQL parser does exactly this translation:\n- **Tokens** = individual words and punctuation (`{`, `query`, `user`, `name`)\n- **Structure** = nested selection sets with fields and arguments\n- **References** = fragment spreads pointing to their definitions\n- **Modifiers** = directives (`@include`, `@skip`) and variable definitions\n\nThe key insight is that the parser **doesn't check if pepperoni is on the menu** (schema validation) or **whether the kitchen has garlic bread** (execution)—it only ensures the order is written in valid restaurant-language syntax.\n\n### Parser Interface\n\nThe parser exposes a minimal public API with two primary methods, following the principle of **single responsibility**—each method handles one specific input format.\n\n| Method | Parameters | Returns | Description | Side Effects |\n|--------|------------|---------|-------------|--------------|\n| `parse_query` | `query_str: str` | `Document` | Parse GraphQL query/mutation/subscription | None (pure function) |\n| `parse_schema` | `schema_str: str` | `List[TypeDefinition]` | Parse GraphQL Schema Definition Language | None (pure function) |\n\n**Error Contract**: Both methods raise `GraphQLSyntaxError` (a subclass of `GraphQLError`) for malformed input. The error includes:\n- `message`: Human-readable description\n- `locations`: List of `Location` objects (line, column)\n- `original_error`: The underlying parsing exception if applicable\n\n**Input Examples**:\n```graphql\n# parse_query input\nquery GetUser($id: ID!) {\n  user(id: $id) {\n    name\n    email\n  }\n}\n\n# parse_schema input  \ntype User {\n  id: ID!\n  name: String\n  email: String\n}\n```\n\n**Output Structure**: The `parse_query` method returns a `Document` containing:\n- `definitions`: List of operation and fragment definitions\n- Source location information on every node\n- Complete tree structure mirroring the query's nesting\n\n### Parsing Algorithm\n\nThe parser implements **recursive descent parsing with single-token lookahead**, which naturally matches GraphQL's nested but not overly complex grammar. The algorithm proceeds in two phases: **lexical analysis** (tokenization) followed by **syntactic analysis** (AST construction).\n\n#### Phase 1: Lexical Analysis (Tokenizer)\n\nThe tokenizer scans the query string left-to-right, grouping characters into tokens while discarding meaningless whitespace and comments.\n\n**Token Types Table**:\n| Token Type | Examples | Description | Special Handling |\n|------------|----------|-------------|------------------|\n| `NAME` | `query`, `user`, `_id` | GraphQL names (letters, digits, underscores) | Case-sensitive, cannot start with digit |\n| `INT` | `42`, `0`, `-10` | Integer values | No decimal point, supports negative |\n| `FLOAT` | `3.14`, `-2.5e-3` | Floating-point values | Scientific notation support |\n| `STRING` | `\"hello\"`, `\"line\\nbreak\"` | String literals | Escapes: `\\\\`, `\\\"`, `\\/`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\uXXXX` |\n| `PUNCTUATION` | `{`, `}`, `(`, `)`, `:`, `@`, `$`, `!` | Syntax punctuation | Single characters |\n| `SPREAD` | `...` | Fragment spread operator | Three consecutive periods |\n| `BLOCK_STRING` | `\"\"\"multiline string\"\"\"` | Triple-quoted strings | Handles leading/trailing whitespace specially |\n\n**Tokenizer Algorithm**:\n1. **Initialize**: Set `position = 0`, `line = 1`, `column = 1`\n2. **Skip ignorables**: Advance past whitespace (` `, `\\t`, `,`) and comments (`# comment`)\n3. **Identify token**:\n   - If `char == '\"'`: Check for `\"\"\"` (block string) else parse regular string\n   - If `char.isalpha() or char == '_'`: Parse NAME token\n   - If `char.isdigit() or (char == '-' and next_char.isdigit())`: Parse INT/FLOAT\n   - If `char == '.'`: Check for `...` (SPREAD) else error\n   - Otherwise: Match single-character PUNCTUATION\n4. **Emit token**: Create token with value, line, column, and advance position\n5. **Repeat** until end of input\n\n**Location Tracking**: Each token records its starting `(line, column)` position, enabling precise error reporting. The tokenizer increments:\n- `line` on `\\n` or `\\r\\n`\n- `column` resets to 1 after newline, increments by 1 otherwise\n\n#### Phase 2: Syntactic Analysis (Parser)\n\nThe parser consumes tokens using **predictive parsing**—at each step, it examines the next token to decide which grammar rule applies. GraphQL's grammar is LL(1), meaning one token lookahead is sufficient.\n\n**Grammar Rules Simplified**:\n```\nDocument → Definition+\nDefinition → OperationDefinition | FragmentDefinition\nOperationDefinition → OperationType Name? VariableDefinitions? Directives? SelectionSet\nSelectionSet → '{' Selection+ '}'\nSelection → Field | FragmentSpread | InlineFragment\nField → Alias? Name Arguments? Directives? SelectionSet?\n```\n\n**Parsing Algorithm Steps**:\n1. **Parse Document**:\n   - While tokens remain, parse a Definition\n   - Add to `definitions` list\n   - Return `Document(definitions)`\n\n2. **Parse Definition**:\n   - Peek at next token:\n     - `NAME` = could be operation or fragment\n     - `{` = anonymous operation\n     - Otherwise error\n   - If token is `fragment`: Parse `FragmentDefinition`\n   - Else: Parse `OperationDefinition`\n\n3. **Parse OperationDefinition**:\n   - Parse operation type (`query`, `mutation`, `subscription`)\n   - Optional: Parse name (if `NAME` token)\n   - Optional: Parse variable definitions (if `(` token)\n   - Optional: Parse directives\n   - Parse `SelectionSet`\n\n4. **Parse SelectionSet** (recursive core):\n   - Expect `{` token\n   - While next token ≠ `}`: Parse Selection\n   - Expect `}` token\n   - Return `SelectionSet(selections)`\n\n5. **Parse Selection**:\n   - Peek at tokens:\n     - `...` → `FragmentSpread` or `InlineFragment`\n     - `NAME` → `Field`\n   - For `Field`: Parse optional alias, name, arguments, directives, optional nested `SelectionSet`\n\n6. **Parse Fragments**:\n   - `FragmentSpread`: Parse `...` followed by name and optional directives\n   - `InlineFragment`: Parse `...` optional type condition, directives, and `SelectionSet`\n   - `FragmentDefinition`: Parse `fragment` keyword, name, type condition, directives, `SelectionSet`\n\n7. **Parse Value Literals** (used in arguments, defaults):\n   - Dispatch based on token type:\n     - `$` → `Variable`\n     - `NAME` → `EnumValue` or `BooleanValue` or `NullValue`\n     - `[` → `ListValue`\n     - `{` → `ObjectValue`\n     - Number/string tokens → corresponding scalar values\n\n**Recursive Nature**: Notice how `parseSelectionSet` calls `parseSelection`, which for `Field` may call `parseSelectionSet` again—this **recursive descent** naturally handles GraphQL's arbitrarily nested structure.\n\n**Example Walkthrough**: Parsing `query { user { name } }`\n1. Token stream: [`NAME(query)`, `{`, `NAME(user)`, `{`, `NAME(name)`, `}`, `}`]\n2. `parseDocument`: Parse Definition\n3. `parseDefinition`: Anonymous operation (starts with `{`)\n4. `parseOperationDefinition`: Default operation type = \"query\", parse `SelectionSet`\n5. `parseSelectionSet`: Expect `{`, parse Selection(s)\n6. `parseSelection`: `Field` with name \"user\", parse nested `SelectionSet`\n7. `parseSelectionSet`: Expect `{`, parse Selection(s)\n8. `parseSelection`: `Field` with name \"name\", no nested selection set\n9. Backtrack, building nested AST: `Field(name=\"name\")` → `SelectionSet([field])` → `Field(name=\"user\", selection_set=SelectionSet)` → `SelectionSet([field])` → `OperationDefinition` → `Document`\n\n### Architecture Decision: Parser Approach\n\n> **Decision: Recursive Descent Parser Over Parser Generator**\n> \n> **Context**: GraphQL has a well-specified, moderately complex grammar with nested structures (selection sets within fields), optional elements (aliases, directives), and context-sensitive rules (fragments must be defined before use in single document). We need a parser that is educational, debuggable, and maintainable for learners.\n> \n> **Options Considered**:\n> 1. **Parser Generator (ANTLR, Lark)**: Define grammar in BNF/EBNF, generate parser code\n> 2. **Parsing Expression Grammar (PEG)**: Use PEG library with grammar rules\n> 3. **Manual Recursive Descent**: Hand-written parser with explicit parsing methods\n> \n> **Decision**: Implement manual recursive descent parser in pure Python.\n> \n> **Rationale**:\n> - **Educational Value**: Recursive descent makes the parsing process transparent—learners can trace execution step-by-step, seeing exactly how tokens become AST nodes. Parser generators are \"magic boxes\" that hide the transformation.\n> - **Error Reporting Quality**: Hand-written parsers can produce precise, context-aware error messages (\"Expected '}' after selection set\" vs. generic \"syntax error\").\n> - **Incremental Development**: We can implement and test one grammar rule at a time (parseField, parseArgument, etc.).\n> - **No External Dependencies**: Keeps the project self-contained and avoids version compatibility issues.\n> - **GraphQL-Specific Optimizations**: We can add memoization for repeated fragments or optimize based on GraphQL's specific patterns.\n> \n> **Consequences**:\n> - **More Initial Code**: ~500-800 lines vs. ~50 lines of grammar definition\n> - **Maintenance Burden**: Grammar changes require manual code updates\n> - **Potential for Bugs**: More opportunities for off-by-one errors in lookahead logic\n> - **Excellent Debuggability**: Stack traces show exactly which parsing method failed\n\n**Comparison Table**:\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| **Parser Generator** | Concise grammar definition, automatic error recovery, proven correctness | Opaque transformation, steep learning curve, external dependency | Hides the learning value—students wouldn't understand how parsing works |\n| **PEG Library** | Natural grammar expression, good error messages, Python integration | Still hides implementation details, performance overhead | Less educational than seeing the recursive calls explicitly |\n| **Recursive Descent** | Transparent, excellent error messages, no dependencies, debuggable | More code to write, manual maintenance | **CHOSEN**: Maximizes learning, aligns with compiler education tradition |\n\n**Implementation Note**: We use **single-token lookahead** rather than backtracking because GraphQL's grammar is LL(1). The parser examines the next token (`peek()`) to decide which path to take, without needing to rewind. This keeps the implementation simple and efficient.\n\n### Common Parser Pitfalls\n\n⚠️ **Pitfall: Incorrect String Escaping**\n- **Description**: Treating `\\\"` as two characters (backslash + quote) rather than an escaped quote\n- **Why Wrong**: Results in malformed string values, breaks JSON serialization\n- **Fix**: Implement proper escape sequence handling: `\\\\`, `\\\"`, `\\/`, `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\uXXXX` (4 hex digits)\n- **Test Case**: `\"Quote: \\\", Newline: \\n, Unicode: \\u00A9\"` → Should parse as `Quote: \", Newline: (newline), Unicode: ©`\n\n⚠️ **Pitfall: Missing Block String Handling**\n- **Description**: Treating `\"\"\"multiline\\nstring\"\"\"` as three separate string tokens\n- **Why Wrong**: Block strings have different escaping rules and handle whitespace specially per GraphQL spec\n- **Fix**: Detect `\"\"\"` sequence, parse until closing `\"\"\"`, apply \"trim indentation\" algorithm\n- **Test Case**: `\"\"\"Hello\\n  World\"\"\"` → Should parse as `Hello\\n  World` (no trimming since consistent indent)\n\n⚠️ **Pitfall: Location Tracking Offsets**\n- **Description**: Line/column counters get misaligned after multi-character tokens or newlines\n- **Why Wrong**: Error messages point to wrong location, confusing debugging\n- **Fix**: Update position counters **before** emitting token (token gets starting position), handle `\\r\\n` as single newline\n- **Diagnostic**: Parse `{\\n  user\\n}` → Field \"user\" should be at line 2, column 3, not line 1, column 5\n\n⚠️ **Pitfall: Fragment Spread vs. Inline Fragment Confusion**\n- **Description**: Misparsing `... on User` as a fragment spread named \"on\" followed by \"User\"\n- **Why Wrong**: `on` is a keyword in type conditions, not a valid fragment name\n- **Fix**: After `...`, check if next token is `NAME` and **not** `on` → fragment spread; if `on` → inline fragment\n- **Edge Case**: `... on` (no type condition) is invalid but should be caught in validation, not parsing\n\n⚠️ **Pitfall: Variable vs. Argument Ambiguity**\n- **Description**: Confusing `field(arg: $value)` (argument with variable value) vs. `$value` alone (variable definition)\n- **Why Wrong**: Parser tries to parse `$value` as an argument name (missing colon)\n- **Fix**: `$` is only valid starting variable tokens; in argument context, `:` must follow argument name before value\n- **Rule**: In `parseArguments`, after parsing name, expect `:`, then parse value (which may be a `Variable`)\n\n⚠️ **Pitfall: Unicode in Names**\n- **Description**: Rejecting valid Unicode characters in GraphQL names like `user_123` or `_valid`\n- **Why Wrong**: GraphQL names support `[_A-Za-z][_0-9A-Za-z]*` with Unicode letters allowed\n- **Fix**: Use Unicode-aware character classification: `char.isalpha()` or `char == '_'` for first char\n- **Test**: `query_αβγ { field }` should parse correctly (Greek letters in name)\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option | Recommendation |\n|-----------|---------------|-----------------|----------------|\n| **Tokenizer** | Manual character-by-character scanning | Regex-based with `re.Scanner` | **Manual scanning** (educational, precise control) |\n| **Token Representation** | `NamedTuple` with type/value/location | Dataclass with methods | **`NamedTuple`** (immutable, lightweight, clear) |\n| **Parser State** | Instance variables on Parser class | Functional style with returned state tuples | **Instance variables** (simpler to debug) |\n| **Error Handling** | Exception-based with custom `GraphQLSyntaxError` | Result type (`Ok`/`Err`) monadic style | **Exceptions** (Pythonic, easy control flow) |\n| **AST Nodes** | Dataclasses with inheritance | `NamedTuple` with manual dispatch | **Dataclasses** (clean, mutable during building) |\n\n#### B. Recommended File/Module Structure\n\n```\ngraphql-engine/\n├── pyproject.toml              # Project configuration\n├── README.md\n├── src/\n│   └── graphql_engine/\n│       ├── __init__.py\n│       ├── error.py            # GraphQLError, GraphQLSyntaxError\n│       ├── ast/                # AST node definitions\n│       │   ├── __init__.py\n│       │   ├── nodes.py        # All AST node classes\n│       │   └── location.py     # Location class\n│       ├── parser/\n│       │   ├── __init__.py     # Public API: parse_query, parse_schema\n│       │   ├── lexer.py        # Token, Tokenizer, TokenType enum\n│       │   ├── parser.py       # Parser class with recursive methods\n│       │   └── grammar.py      # Grammar constants (keywords, punctuation)\n│       └── utils/\n│           └── helpers.py      # String helpers, position tracking\n└── tests/\n    ├── __init__.py\n    ├── test_lexer.py\n    ├── test_parser.py\n    └── fixtures/\n        └── example_queries.graphql\n```\n\n#### C. Infrastructure Starter Code\n\n**`src/graphql_engine/error.py`** (Complete implementation):\n```python\n\"\"\"GraphQL error definitions.\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Any, Union\n\n\n@dataclass\nclass Location:\n    \"\"\"Source location for error reporting.\"\"\"\n    line: int\n    column: int\n    \n    def __str__(self) -> str:\n        return f\"{self.line}:{self.column}\"\n\n\n@dataclass\nclass GraphQLError(Exception):\n    \"\"\"Base class for all GraphQL errors.\"\"\"\n    message: str\n    locations: List[Location] = field(default_factory=list)\n    path: List[Union[str, int]] = field(default_factory=list)\n    original_error: Optional[Exception] = None\n    extensions: dict[str, Any] = field(default_factory=dict)\n    \n    def __str__(self) -> str:\n        if self.locations:\n            locs = \", \".join(str(loc) for loc in self.locations)\n            return f\"{self.message} (locations: {locs})\"\n        return self.message\n\n\n@dataclass\nclass GraphQLSyntaxError(GraphQLError):\n    \"\"\"Syntax error during parsing.\"\"\"\n    \n    @classmethod\n    def from_lexer(cls, message: str, line: int, column: int) -> \"GraphQLSyntaxError\":\n        \"\"\"Create syntax error from lexer position.\"\"\"\n        return cls(\n            message=f\"Syntax error: {message}\",\n            locations=[Location(line=line, column=column)]\n        )\n    \n    @classmethod\n    def from_parser(cls, message: str, token) -> \"GraphQLSyntaxError\":\n        \"\"\"Create syntax error from parser token.\"\"\"\n        return cls(\n            message=f\"Syntax error: {message} at '{token.value}'\",\n            locations=[Location(line=token.line, column=token.column)]\n        )\n```\n\n**`src/graphql_engine/ast/location.py`** (Complete implementation):\n```python\n\"\"\"AST location tracking.\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\nclass Location:\n    \"\"\"Source location for AST nodes.\"\"\"\n    line: int\n    column: int\n    \n    @classmethod\n    def from_token(cls, token) -> Optional[\"Location\"]:\n        \"\"\"Create Location from token if token has location info.\"\"\"\n        if hasattr(token, 'line') and hasattr(token, 'column'):\n            return cls(line=token.line, column=token.column)\n        return None\n```\n\n**`src/graphql_engine/utils/helpers.py`** (Complete implementation):\n```python\n\"\"\"String and position utilities.\"\"\"\n\nimport re\nfrom typing import Tuple\n\n\ndef is_name_start(char: str) -> bool:\n    \"\"\"Check if character can start a GraphQL name.\"\"\"\n    return char.isalpha() or char == '_'\n\n\ndef is_name_continuation(char: str) -> bool:\n    \"\"\"Check if character can continue a GraphQL name.\"\"\"\n    return char.isalnum() or char == '_'\n\n\ndef decode_unicode_escape(match: re.Match) -> str:\n    \"\"\"Decode \\uXXXX escape sequence.\"\"\"\n    hex_str = match.group(1)\n    try:\n        return chr(int(hex_str, 16))\n    except ValueError:\n        # Invalid Unicode, return replacement character\n        return '\\ufffd'\n\n\ndef parse_string_value(string_literal: str) -> str:\n    \"\"\"Parse GraphQL string literal with escape sequences.\"\"\"\n    # Remove surrounding quotes\n    content = string_literal[1:-1]\n    \n    # Replace escape sequences\n    replacements = [\n        (r'\\\\\"', '\"'),\n        (r'\\\\\\\\', '\\\\'),\n        (r'\\\\/', '/'),\n        (r'\\\\b', '\\b'),\n        (r'\\\\f', '\\f'),\n        (r'\\\\n', '\\n'),\n        (r'\\\\r', '\\r'),\n        (r'\\\\t', '\\t'),\n    ]\n    \n    for pattern, replacement in replacements:\n        content = re.sub(pattern, replacement, content)\n    \n    # Replace Unicode escapes\n    content = re.sub(r'\\\\u([0-9a-fA-F]{4})', decode_unicode_escape, content)\n    \n    return content\n\n\ndef calculate_line_column(source: str, position: int) -> Tuple[int, int]:\n    \"\"\"Calculate line and column for a position in source string.\"\"\"\n    if position >= len(source):\n        position = len(source) - 1\n    \n    # Count lines from start to position\n    line = 1\n    column = 1\n    \n    for i, char in enumerate(source):\n        if i >= position:\n            break\n        if char == '\\n':\n            line += 1\n            column = 1\n        elif char == '\\r':\n            # Handle \\r\\n as single newline\n            if i + 1 < len(source) and source[i + 1] == '\\n':\n                continue\n            line += 1\n            column = 1\n        else:\n            column += 1\n    \n    return line, column\n```\n\n#### D. Core Logic Skeleton Code\n\n**`src/graphql_engine/ast/nodes.py`** (Partial skeleton):\n```python\n\"\"\"AST node definitions using dataclasses.\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Any, Union\nfrom .location import Location\n\n\n@dataclass\nclass Node:\n    \"\"\"Base class for all AST nodes.\"\"\"\n    loc: Optional[Location] = None\n\n\n@dataclass\nclass Document(Node):\n    \"\"\"Root node representing a complete GraphQL document.\"\"\"\n    definitions: List['Definition'] = field(default_factory=list)\n    \n    # TODO: Add method to get operation by name\n    # TODO: Add method to get fragment by name\n\n\n@dataclass\nclass Definition(Node):\n    \"\"\"Base class for definitions (operations, fragments).\"\"\"\n    pass\n\n\n@dataclass\nclass OperationDefinition(Definition):\n    \"\"\"Operation definition (query, mutation, subscription).\"\"\"\n    operation_type: str = \"query\"  # \"query\", \"mutation\", \"subscription\"\n    name: Optional[str] = None\n    variable_definitions: List['VariableDefinition'] = field(default_factory=list)\n    directives: List['Directive'] = field(default_factory=list)\n    selection_set: 'SelectionSet' = field(default_factory=lambda: SelectionSet())\n    \n    # TODO: Add method to validate operation type is valid\n    # TODO: Add method to get all variable names used\n\n\n@dataclass\nclass SelectionSet(Node):\n    \"\"\"Collection of fields/fragments within {...}.\"\"\"\n    selections: List['Selection'] = field(default_factory=list)\n    \n    # TODO: Add method to check if selection set is empty\n    # TODO: Add method to get all field names in selection set\n\n\n@dataclass  \nclass Selection(Node):\n    \"\"\"Base class for selections (fields, fragment spreads, inline fragments).\"\"\"\n    pass\n\n\n@dataclass\nclass Field(Selection):\n    \"\"\"Field selection with optional alias, arguments, directives.\"\"\"\n    name: str = \"\"\n    alias: Optional[str] = None\n    arguments: List['Argument'] = field(default_factory=list)\n    directives: List['Directive'] = field(default_factory=list)\n    selection_set: Optional[SelectionSet] = None\n    \n    # TODO: Add property to get actual field name (alias or name)\n    # TODO: Add method to get argument value by name\n\n\n# TODO: Continue implementing all AST nodes from NAMING CONVENTIONS:\n# - FragmentDefinition, FragmentSpread, InlineFragment\n# - Argument, Directive, VariableDefinition, Variable\n# - NamedType, ListType, NonNullType\n# - All Value subclasses (IntValue, StringValue, ListValue, etc.)\n# Use the exact field names from the naming conventions table\n\n# Note: Use forward references as strings for types not defined yet\n# Example: selection_set: Optional['SelectionSet'] = None\n```\n\n**`src/graphql_engine/parser/lexer.py`** (Partial skeleton):\n```python\n\"\"\"GraphQL lexer/tokenizer.\"\"\"\n\nfrom enum import Enum, auto\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom ..error import GraphQLSyntaxError\n\n\nclass TokenType(Enum):\n    \"\"\"Types of GraphQL tokens.\"\"\"\n    EOF = auto()\n    NAME = auto()\n    INT = auto()\n    FLOAT = auto()\n    STRING = auto()\n    BLOCK_STRING = auto()\n    PUNCTUATION = auto()\n    SPREAD = auto()\n    # TODO: Add all token types from the Token Types Table\n\n\n@dataclass\nclass Token:\n    \"\"\"A GraphQL token with value and location.\"\"\"\n    type: TokenType\n    value: str\n    line: int\n    column: int\n    \n    def __repr__(self) -> str:\n        return f\"Token({self.type.name}, '{self.value}', {self.line}:{self.column})\"\n\n\nclass Tokenizer:\n    \"\"\"Converts GraphQL source string into tokens.\"\"\"\n    \n    def __init__(self, source: str):\n        self.source = source\n        self.position = 0\n        self.line = 1\n        self.column = 1\n        self.current_char: Optional[str] = None\n        self._advance()  # Initialize current_char\n        \n    def _advance(self) -> None:\n        \"\"\"Advance to next character in source.\"\"\"\n        # TODO: Implement character advancement\n        # - Update position, line, column\n        # - Handle \\r\\n as single newline\n        # - Set current_char or None if EOF\n        pass\n    \n    def _peek(self) -> Optional[str]:\n        \"\"\"Look at next character without consuming it.\"\"\"\n        # TODO: Return next character without advancing position\n        pass\n    \n    def _skip_whitespace_and_comments(self) -> None:\n        \"\"\"Skip over whitespace and comments.\"\"\"\n        # TODO: Advance past spaces, tabs, commas, and #-comments\n        # Comments run from # to end of line\n        pass\n    \n    def _read_name(self) -> str:\n        \"\"\"Read a GraphQL name token.\"\"\"\n        # TODO: Starting from current_char (already validated as name start)\n        # - Collect characters while is_name_continuation\n        # - Return collected string\n        pass\n    \n    def _read_number(self) -> Tuple[str, TokenType]:\n        \"\"\"Read integer or float literal.\"\"\"\n        # TODO: Handle:\n        # - Optional leading minus sign\n        # - Integer part\n        # - Optional decimal point and fractional part  \n        # - Optional exponent (e/E with optional +/- and digits)\n        # Return (value_string, TokenType.INT or TokenType.FLOAT)\n        pass\n    \n    def _read_string(self) -> str:\n        \"\"\"Read regular string literal with escapes.\"\"\"\n        # TODO: Handle:\n        # - Starting quote\n        # - Characters with escape sequences\n        # - Closing quote\n        # - Use parse_string_value helper for escape processing\n        pass\n    \n    def _read_block_string(self) -> str:\n        \"\"\"Read triple-quoted block string.\"\"\"\n        # TODO: Handle:\n        # - Starting \"\"\"\n        # - Content with special whitespace handling\n        # - Closing \"\"\"\n        # - Implement \"trim indentation\" algorithm from GraphQL spec\n        pass\n    \n    def next_token(self) -> Token:\n        \"\"\"Return next token from source.\"\"\"\n        self._skip_whitespace_and_comments()\n        \n        if self.current_char is None:\n            return Token(TokenType.EOF, \"\", self.line, self.column)\n        \n        start_line = self.line\n        start_column = self.column\n        \n        # TODO: Implement token detection logic:\n        # - Check for spread (...)\n        # - Check for name start\n        # - Check for number start (digit or - followed by digit)\n        # - Check for string (\")\n        # - Check for block string (\"\"\")\n        # - Otherwise single-character punctuation\n        # Call appropriate _read_* method and return Token\n        \n        # TODO: For unknown character, raise GraphQLSyntaxError.from_lexer\n        pass\n    \n    def tokenize(self) -> List[Token]:\n        \"\"\"Return all tokens from source.\"\"\"\n        tokens = []\n        while True:\n            token = self.next_token()\n            tokens.append(token)\n            if token.type == TokenType.EOF:\n                break\n        return tokens\n```\n\n**`src/graphql_engine/parser/parser.py`** (Partial skeleton):\n```python\n\"\"\"Recursive descent parser for GraphQL.\"\"\"\n\nfrom typing import List, Optional\nfrom ..error import GraphQLSyntaxError\nfrom ..ast.nodes import *\nfrom .lexer import Tokenizer, Token, TokenType\n\n\nclass Parser:\n    \"\"\"Parses GraphQL documents from tokens.\"\"\"\n    \n    def __init__(self, source: str):\n        self.tokenizer = Tokenizer(source)\n        self.tokens: List[Token] = []\n        self.position = 0\n        self._fill_tokens()\n    \n    def _fill_tokens(self) -> None:\n        \"\"\"Pre-load all tokens.\"\"\"\n        self.tokens = self.tokenizer.tokenize()\n    \n    def _peek(self) -> Token:\n        \"\"\"Look at current token without consuming it.\"\"\"\n        # TODO: Return token at current position or EOF if at end\n        pass\n    \n    def _advance(self) -> Token:\n        \"\"\"Consume and return current token.\"\"\"\n        # TODO: Return current token and advance position\n        pass\n    \n    def _expect(self, token_type: TokenType, value: Optional[str] = None) -> Token:\n        \"\"\"Expect and consume a specific token type.\"\"\"\n        # TODO: Check if current token matches expected type/value\n        # If match: advance and return token\n        # If no match: raise GraphQLSyntaxError.from_parser\n        pass\n    \n    def parse_document(self) -> Document:\n        \"\"\"Parse a complete GraphQL document.\"\"\"\n        # TODO: Implement according to parsing algorithm steps:\n        # 1. Create empty definitions list\n        # 2. While not at EOF: parse_definition and add to list\n        # 3. Return Document(definitions)\n        pass\n    \n    def parse_definition(self) -> Definition:\n        \"\"\"Parse a single definition (operation or fragment).\"\"\"\n        # TODO: Check current token:\n        # - If NAME and value is \"fragment\": return parse_fragment_definition\n        # - If NAME and value is operation type: return parse_operation_definition\n        # - If { (anonymous operation): return parse_operation_definition with default type\n        # Otherwise: raise syntax error\n        pass\n    \n    def parse_operation_definition(self, operation_type: str = \"query\") -> OperationDefinition:\n        \"\"\"Parse operation definition.\"\"\"\n        # TODO: Implement according to grammar:\n        # 1. Parse optional name (if NAME token)\n        # 2. Parse optional variable definitions (if '(')\n        # 3. Parse optional directives\n        # 4. Parse selection_set\n        # 5. Return OperationDefinition\n        pass\n    \n    def parse_selection_set(self) -> SelectionSet:\n        \"\"\"Parse {...} selection set.\"\"\"\n        # TODO: Implement recursive parsing:\n        # 1. Expect '{'\n        # 2. Create empty selections list\n        # 3. While token ≠ '}': parse_selection and add to list\n        # 4. Expect '}'\n        # 5. Return SelectionSet(selections)\n        pass\n    \n    def parse_selection(self) -> Selection:\n        \"\"\"Parse field, fragment spread, or inline fragment.\"\"\"\n        # TODO: Check tokens:\n        # - If ...: return parse_fragment (spread or inline)\n        # - Otherwise: return parse_field\n        pass\n    \n    def parse_field(self) -> Field:\n        \"\"\"Parse field selection.\"\"\"\n        # TODO: Implement field parsing:\n        # 1. Parse optional alias (NAME followed by ':')\n        # 2. Parse field name\n        # 3. Parse optional arguments\n        # 4. Parse optional directives\n        # 5. Parse optional selection_set\n        # 6. Return Field with all components\n        pass\n    \n    # TODO: Implement remaining parsing methods:\n    # - parse_fragment_definition, parse_fragment_spread, parse_inline_fragment\n    # - parse_arguments, parse_directives, parse_variable_definitions\n    # - parse_value, parse_variable, parse_type\n    # - All value literal parsers (int, float, string, list, object, etc.)\n    \n    def parse_query(self) -> Document:\n        \"\"\"Public API: Parse GraphQL query string.\"\"\"\n        try:\n            return self.parse_document()\n        except GraphQLSyntaxError:\n            raise\n        except Exception as e:\n            # Wrap any unexpected error\n            raise GraphQLSyntaxError(\n                message=f\"Unexpected parsing error: {str(e)}\",\n                locations=[]\n            ) from e\n```\n\n**`src/graphql_engine/parser/__init__.py`** (Complete implementation):\n```python\n\"\"\"Public parser API.\"\"\"\n\nfrom .parser import Parser\nfrom ..error import GraphQLSyntaxError\n\n\ndef parse_query(query_str: str) -> Document:\n    \"\"\"Parse GraphQL query string into AST Document.\n    \n    Args:\n        query_str: GraphQL query/mutation/subscription string\n        \n    Returns:\n        Document AST node\n        \n    Raises:\n        GraphQLSyntaxError: If query has syntax errors\n    \"\"\"\n    parser = Parser(query_str)\n    return parser.parse_query()\n\n\ndef parse_schema(schema_str: str) -> List['TypeDefinition']:\n    \"\"\"Parse GraphQL Schema Definition Language.\n    \n    Args:\n        schema_str: GraphQL SDL string\n        \n    Returns:\n        List of type definitions\n        \n    Raises:\n        GraphQLSyntaxError: If schema has syntax errors\n    \"\"\"\n    # TODO: Implement in Milestone 2\n    raise NotImplementedError(\"Schema parsing will be implemented in Milestone 2\")\n```\n\n#### E. Language-Specific Hints\n\n**Python-Specific Implementation Tips**:\n\n1. **String Handling**: Use `str.isdigit()`, `str.isalpha()`, `str.isalnum()` for character classification. For Unicode names, Python's methods already handle Unicode correctly.\n\n2. **Escape Sequences**: Use `re.sub()` with a dictionary of replacements for efficient escape sequence processing.\n\n3. **Block Strings**: Implement the GraphQL spec's \"trim indentation\" algorithm:\n   - Split into lines\n   - Find common leading whitespace (excluding first/last lines)\n   - Remove that whitespace from all lines\n   - Join with `\\n`\n\n4. **Error Messages**: Include both the expected and actual token in error messages: `f\"Expected '{expected}', got '{actual.value}'\"`.\n\n5. **Testing**: Use `pytest` with `@pytest.mark.parametrize` to test multiple query variations.\n\n6. **Performance**: For educational code, clarity beats optimization. Use lists for token storage, simple loops for scanning.\n\n#### F. Milestone Checkpoint\n\n**What to Test After Implementing Parser**:\n\n1. **Basic Queries**:\n   ```bash\n   python -m pytest tests/test_parser.py::test_parse_simple_query -v\n   ```\n   **Expected**: Test passes, AST contains correct operation type and field names.\n\n2. **Error Detection**:\n   ```bash\n   python -m pytest tests/test_parser.py::test_syntax_errors -v\n   ```\n   **Expected**: Tests verify that malformed queries raise `GraphQLSyntaxError` with correct line/column.\n\n3. **Fragment Handling**:\n   ```bash\n   python -m pytest tests/test_parser.py::test_fragments -v\n   ```\n   **Expected**: Named fragments and inline fragments parse correctly with type conditions.\n\n4. **Manual Verification**:\n   ```python\n   from graphql_engine.parser import parse_query\n   \n   query = \"\"\"\n   query GetUser($id: ID!) {\n     user(id: $id) {\n       name\n       email @include(if: $showEmail)\n     }\n   }\n   \"\"\"\n   \n   ast = parse_query(query)\n   print(f\"Operations: {len(ast.definitions)}\")\n   print(f\"Variables: {ast.definitions[0].variable_definitions}\")\n   ```\n   **Expected Output**: Shows 1 operation with 1 variable definition and 2 fields.\n\n**Signs Something Is Wrong**:\n- **Error messages point to wrong line/column**: Check location tracking in tokenizer\n- **Fragments not being recognized**: Verify `...` token detection and `on` keyword handling\n- **Nested fields cause infinite recursion**: Check `parse_selection_set` termination condition\n- **String values have backslashes in them**: Escape sequence processing incomplete\n\n**Diagnostic Tools**:\n- Add `__repr__` methods to AST nodes for readable debugging\n- Create a simple AST visualizer: `print_ast(ast, indent=0)`\n- Log tokens during parsing: `print(f\"Parsing {self._peek()}\")`\n\n---\n\n\n## Component 2: Schema & Type System\n> **Milestone(s):** This section corresponds directly to Milestone 2: Schema & Type System, which focuses on building the foundational type system that defines what data can be queried and how it's structured. This component validates that the building plans (type definitions) are consistent and safe before any execution occurs.\n\n### Responsibility and Scope\n\nThe **Schema & Type System** component serves as the structural blueprint and validation engine for our GraphQL engine. Think of it as the city planning department that reviews architectural blueprints before construction begins—it ensures all buildings (types) follow zoning laws (GraphQL specification), connect properly via roads (relationships), and can safely accommodate residents (data).\n\n**Primary responsibilities include:**\n- **Type Definition Storage:** Representing all GraphQL type kinds (Object, Scalar, Enum, Interface, Union, InputObject, List, NonNull) in memory as structured data\n- **Schema Construction:** Assembling individual type definitions into a coherent, validated `Schema` that serves as the single source of truth for what queries are valid\n- **Type Validation:** Performing comprehensive consistency checks to detect issues like circular references, missing interface implementations, and type name conflicts\n- **Introspection Implementation:** Providing the built-in `__schema`, `__type`, and `__typename` meta-fields that allow clients to query the schema structure itself\n- **Type Resolution:** Mapping type names (like `\"User\"`) to their corresponding type definitions during query parsing and execution\n\n**Key boundaries and what this component does NOT do:**\n- Does NOT execute queries or call resolver functions (that's Component 3's responsibility)\n- Does NOT generate types from databases (that's Component 4's responsibility)\n- Does NOT validate query structure against schema (that's a separate validation phase)\n- Does NOT handle runtime type coercions during execution (though it defines the rules for them)\n\nThe schema acts as a contract between the GraphQL service and its clients. Once built and validated, it becomes immutable for the duration of execution, ensuring consistent behavior.\n\n### Mental Model: Building Inspector\n\nImagine you're constructing a complex building with many rooms, hallways, and connections. The **type system** is like the complete set of architectural blueprints that define:\n\n| Blueprint Element | GraphQL Equivalent | Purpose |\n|-------------------|-------------------|---------|\n| Room specifications | `ObjectType` | Defines what \"furniture\" (fields) exists in each room and how to access them |\n| Room connections | `InterfaceType`/`UnionType` | Defines common hallways (interfaces) that connect similar rooms, or elevator banks (unions) that group different room types |\n| Furniture inventory | `ScalarType` | Defines the basic building blocks (strings, numbers) that make up the furniture |\n| Delivery instructions | `InputObjectType` | Defines how to deliver new furniture (input data) to the building |\n| Building codes | Validation rules | Ensures blueprints don't create fire hazards (circular references) or illegal structures |\n\nThe **schema building process** is the building inspector's review. They check that:\n1. Every room has proper exits (interface implementations are complete)\n2. No room leads to infinite hallways (no circular type references in input types)\n3. All furniture fits through the doors (field argument types are compatible)\n4. The building has a main entrance (`Query` type) and possibly service entrances (`Mutation` and `Subscription` types)\n\nWhen introspection queries arrive, it's like giving visitors a self-guided tour map—the building inspector provides a simplified version of the blueprints that shows what's publicly accessible without revealing construction secrets.\n\n### Type System Interface\n\nThe type system exposes a clean API for defining types, building schemas, and querying type information. Here are the key interfaces:\n\n| Method/Function | Parameters | Returns | Description |\n|-----------------|------------|---------|-------------|\n| `create_schema()` | `query_type: ObjectType`, `mutation_type: Optional[ObjectType]`, `subscription_type: Optional[ObjectType]`, `types: Optional[List[GraphQLType]]`, `directives: Optional[List[GraphQLDirective]]` | `Schema` | Constructs a validated schema from type definitions. Automatically includes introspection types and validates all type references. |\n| `get_type(schema, name)` | `schema: Schema`, `name: str` | `Optional[GraphQLType]` | Looks up a type by name in the schema's type registry. Used internally during query validation and execution. |\n| `is_input_type(type)` | `type: GraphQLType` | `bool` | Returns `True` if the type can be used as an input (scalar, enum, input object, or lists/non-nulls thereof). Critical for validating field arguments. |\n| `is_output_type(type)` | `type: GraphQLType` | `bool` | Returns `True` if the type can be used as output (object, interface, union, scalar, enum, or lists/non-nulls thereof). |\n| `assert_valid_schema(schema)` | `schema: Schema` | `None` (raises `GraphQLError` on failure) | Performs comprehensive validation of schema consistency. Called automatically by `create_schema()`. |\n| `introspection_schema()` | (none) | `Schema` | Returns the built-in introspection schema that powers `__schema` and `__type` queries. This is merged with user-defined schemas. |\n\nThe core data structures follow the naming conventions exactly. Here's the complete set of type definitions with all fields:\n\n| Type Name | Fields | Description |\n|-----------|--------|-------------|\n| `GraphQLType` | `name: str`, `description: Optional[str]` | Base class for all GraphQL types. The `description` field supports documentation that appears in tools like GraphiQL. |\n| `ScalarType` | Inherits from `GraphQLType` plus: `serialize: Callable`, `parse_value: Callable`, `parse_literal: Callable` | Represents leaf values like strings, numbers, or custom types. The three functions handle conversion between Python values, JSON values, and AST literals. |\n| `ObjectType` | Inherits from `GraphQLType` plus: `fields: Dict[str, GraphQLField]`, `interfaces: List[InterfaceType]` | Represents a concrete object with fields. Each field has its own type and arguments. Objects can implement multiple interfaces. |\n| `GraphQLField` | `type: GraphQLType`, `args: Dict[str, GraphQLArgument]`, `resolve: Optional[Callable]`, `description: Optional[str]`, `deprecation_reason: Optional[str]` | A field on an object type. The `resolve` function is stored here but only invoked by the execution engine. |\n| `GraphQLArgument` | `type: GraphQLType`, `default_value: Any`, `description: Optional[str]` | An argument to a field. Default values are used when the argument isn't provided in the query. |\n| `InterfaceType` | Inherits from `GraphQLType` plus: `fields: Dict[str, GraphQLField]`, `resolve_type: Optional[Callable]` | Abstract type defining a set of fields that implementing objects must include. `resolve_type` determines which concrete object type to use at runtime. |\n| `UnionType` | Inherits from `GraphQLType` plus: `types: List[ObjectType]`, `resolve_type: Optional[Callable]` | Represents a type that could be one of several object types. Like interfaces but without shared fields definition. |\n| `EnumType` | Inherits from `GraphQLType` plus: `values: Dict[str, EnumValue]` | Fixed set of allowed string values. The `EnumValue` includes `value: Any`, `description: Optional[str]`, and `deprecation_reason: Optional[str]`. |\n| `InputObjectType` | Inherits from `GraphQLType` plus: `fields: Dict[str, GraphQLInputField]` | Used for complex inputs, like in mutations. Similar to objects but for input values only. |\n| `GraphQLInputField` | `type: GraphQLType`, `default_value: Any`, `description: Optional[str]` | A field on an input object. Simpler than `GraphQLField` as it has no arguments or resolver. |\n| `Schema` | `query_type: ObjectType`, `mutation_type: Optional[ObjectType]`, `subscription_type: Optional[ObjectType]`, `types: Dict[str, GraphQLType]`, `directives: Dict[str, GraphQLDirective]` | The complete schema containing all types. The `types` dictionary includes all types referenced in the schema (including built-in scalars and introspection types). |\n\n> **Key Insight:** The separation between `ObjectType` (for output) and `InputObjectType` (for input) is fundamental to GraphQL's design. Output types can have resolvers and support interfaces/unions, while input types must be serializable and cannot have those features. This distinction prevents confusing and potentially insecure patterns.\n\n### Schema Building Algorithm\n\nBuilding a valid schema involves multiple validation passes to ensure internal consistency. Here's the step-by-step algorithm:\n\n1. **Collect All Types**: Starting from the root operation types (`query_type`, `mutation_type`, `subscription_type`), recursively traverse all referenced types:\n   - For each `ObjectType`, collect its fields' return types and argument types\n   - For each `InterfaceType`, collect its fields' return types and argument types  \n   - For each `UnionType`, collect its member types\n   - For each field's arguments, collect the argument types\n   - For `ListType` and `NonNullType`, collect their wrapped types\n\n2. **Validate Type Uniqueness**: Ensure no two types share the same name (case-sensitive). Built-in types (`Int`, `Float`, `String`, `Boolean`, `ID`, introspection types) are included and cannot be redefined.\n\n3. **Validate Root Operation Types**: \n   - The `query_type` must be an `ObjectType` and is required\n   - If provided, `mutation_type` and `subscription_type` must be `ObjectType`\n   - These types must exist in the collected types\n\n4. **Validate Object Types** (for each `ObjectType`):\n   - Validate each field's name is unique within the object\n   - Validate field argument names are unique within each field\n   - Validate field argument types are input types (`is_input_type` returns true)\n   - Validate interfaces: for each interface the object claims to implement:\n     - The interface must be an `InterfaceType`\n     - The object must include all fields from the interface (name, type, and arguments must match exactly)\n     - Interface field arguments must be identical (same name, type, and default value)\n\n5. **Validate Interface Types** (for each `InterfaceType`):\n   - Validate each field's name is unique within the interface\n   - Validate field argument names are unique within each field\n   - Validate field argument types are input types\n   - Check for circular interface implementations (interface A cannot implement interface B if B implements A, directly or indirectly)\n\n6. **Validate Union Types** (for each `UnionType`):\n   - Must have at least one member type\n   - All member types must be `ObjectType` (not interfaces, scalars, etc.)\n   - Member type names must be unique within the union\n\n7. **Validate Enum Types** (for each `EnumType`):\n   - Must have at least one value\n   - Enum value names must be unique within the enum\n   - Values must follow GraphQL name rules (only letters, numbers, and underscore)\n\n8. **Validate Input Object Types** (for each `InputObjectType`):\n   - Validate each field's name is unique within the input object\n   - Validate field types are input types\n   - **Crucially, detect circular references**: No input object field can eventually reference itself through nested input objects. Use depth-first search with a visited set.\n\n9. **Validate Scalar Types**: Built-in scalars are pre-defined. Custom scalars must provide all three conversion functions (`serialize`, `parse_value`, `parse_literal`).\n\n10. **Validate Directives**: For each directive defined in the schema:\n    - Validate directive name follows naming conventions\n    - Validate directive locations are valid (QUERY, MUTATION, FIELD, etc.)\n    - Validate directive arguments follow the same rules as field arguments\n\n11. **Build Type Map**: Create a dictionary mapping type names to type instances, including all built-in types and introspection types. This map becomes the source of truth for type lookups.\n\n12. **Mark Schema as Validated**: Once all validation passes, the schema is considered valid and immutable. Any attempt to modify types after validation should raise an error.\n\n> **Design Principle:** Schema validation is idempotent. Calling `assert_valid_schema()` on an already-validated schema should return immediately. This allows the validation to be lazy but also eagerly checked during development.\n\n### Architecture Decision: Type Representation\n\n> **Decision: Object-Oriented Type Hierarchy with Immutable Schemas**\n> - **Context:** We need to represent all GraphQL type kinds in Python while maintaining type safety, enabling easy validation, and supporting introspection. The representation must be both human-friendly for schema builders and efficient for the execution engine.\n> - **Options Considered:**\n>   1. **Functional/Data-Centric Approach:** Types as plain dictionaries with `kind` fields, using functional validators\n>   2. **Object-Oriented with Mutable Types:** Classes with inheritance, allowing types to be modified after creation\n>   3. **Object-Oriented with Immutable Types:** Classes with inheritance where types are frozen after schema creation\n> - **Decision:** Object-oriented hierarchy with immutable schemas (Option 3). Each type kind gets its own class inheriting from `GraphQLType`, and once a schema is built, its types cannot be modified.\n> - **Rationale:** \n>   - **Type Safety:** Python's class hierarchy provides natural \"is-a\" relationships that match GraphQL's type system (an `ObjectType` *is a* `GraphQLType`)\n>   - **Performance:** Method dispatch via `isinstance()` checks is faster than dictionary `kind` checks\n>   - **Immutability:** Prevents subtle bugs where types change during execution. Once validated, the schema is a reliable contract\n>   - **Introspection:** Natural place to attach behavior (like validation methods) to type classes\n> - **Consequences:**\n>   - Slightly more boilerplate than dictionary approach\n>   - Requires careful design of base classes to avoid deep inheritance\n>   - Schema building becomes a two-phase process: create mutable type definitions, then freeze into immutable schema\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| Functional/Data-Centric | Simple serialization, minimal boilerplate | Type checking requires manual `kind` checks, harder to attach behavior | Lacks type safety and makes validation code more complex |\n| OO with Mutable Types | Flexible for dynamic schema modifications | Risk of runtime errors if types change during execution | Mutability introduces race conditions and validation caching issues |\n| **OO with Immutable Types** | **Type-safe, performant, reliable execution contract** | **Two-phase build process, slightly more code** | **Chosen for safety and performance** |\n\n### Common Type System Pitfalls\n\nBuilding a type system involves subtle traps that can lead to confusing errors or security issues. Here are the most common pitfalls and how to avoid them:\n\n⚠️ **Pitfall 1: Circular References in Input Types**\n- **Description:** Allowing input object fields that eventually reference themselves, like `type Input { self: Input }`. This creates infinite recursion during query validation and execution.\n- **Why It's Wrong:** GraphQL explicitly forbids circular input references because they can't be serialized or validated. The specification states input types must be finite.\n- **Fix:** During input object validation, perform a depth-first search from each input object, tracking visited types. If you encounter the same type again, raise a validation error with the circular path.\n\n⚠️ **Pitfall 2: Incomplete Interface Implementation**\n- **Description:** An object type claims to implement an interface but misses fields, has field type mismatches, or argument differences.\n- **Why It's Wrong:** Breaks the Liskov Substitution Principle—clients expecting interface fields can't rely on them being present. Causes runtime errors when queries request interface fields on objects that don't implement them.\n- **Fix:** When validating interface implementation, compare each interface field with the object's corresponding field:\n  - Field names must match exactly\n  - Field types must be identical (use deep equality, not just name comparison)\n  - Arguments must match in name, type, and default value\n  - Object can have additional fields not in the interface (that's allowed)\n\n⚠️ **Pitfall 3: Confusing Input and Output Types**\n- **Description:** Using output types (objects, interfaces, unions) as field arguments or input object fields, or using input types as field return types.\n- **Why It's Wrong:** GraphQL's type system strictly separates input and output types for good reason. Input types must be serializable (no resolvers, no async), while output types can have behaviors.\n- **Fix:** Implement `is_input_type()` and `is_output_type()` helpers that understand type wrappers (`ListType`, `NonNullType`). During validation:\n  - Field argument types must be input types\n  - Input object field types must be input types  \n  - Field return types must be output types\n\n⚠️ **Pitfall 4: Missing Nullable Wrapping Validation**\n- **Description:** Not validating that certain type positions (like list elements) can be nullable when they should be, or vice versa.\n- **Why It's Wrong:** GraphQL has specific rules: lists can contain null values unless wrapped in NonNull, but fields can be made non-null. Getting this wrong causes unexpected null errors or missing data.\n- **Fix:** Follow GraphQL's type modifier rules: `NonNullType` can wrap any type except another `NonNullType`. `ListType` can wrap any type. Validate these constraints when building types.\n\n⚠️ **Pitfall 5: Forgetting Built-in Introspection Types**\n- **Description:** Not including `__Schema`, `__Type`, `__Field`, `__InputValue`, `__EnumValue`, and `__Directive` in the type map, or not adding `__schema`, `__type`, and `__typename` fields.\n- **Why It's Wrong:** Introspection is a required part of the GraphQL specification. Clients like GraphiQL rely on it to provide autocomplete and documentation.\n- **Fix:** Always merge the built-in introspection schema with user-defined types. The `__typename` meta-field should be automatically added to every object and interface type.\n\n### Implementation Guidance\n\n> **Technology Note:** For the type system component, we'll use Python's class system with `dataclasses` for clean representation and `typing` module for type hints. Since schemas are built once and read many times, we'll use immutable patterns after validation.\n\n#### A. Recommended File Structure\n\n```\ngraphql_engine/\n├── __init__.py\n├── type_system/           # Component 2: Schema & Type System\n│   ├── __init__.py\n│   ├── types.py          # All type class definitions\n│   ├── schema.py         # Schema class and validation logic\n│   ├── introspection.py  # Built-in introspection types and resolvers\n│   ├── scalars.py        # Built-in scalar definitions\n│   └── validation/       # Schema validation rules\n│       ├── __init__.py\n│       ├── rules.py      # Individual validation rules\n│       └── validator.py  # Validation orchestration\n└── parser/               # Component 1 (already built)\n    └── ...\n```\n\n#### B. Infrastructure Starter Code\n\nHere's complete, working code for the foundational type classes. Learners should place this in `type_system/types.py`:\n\n```python\nfrom __future__ import annotations\nfrom typing import Any, Callable, Dict, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\n# Base type that all GraphQL types inherit from\n@dataclass(frozen=True)\nclass GraphQLType:\n    \"\"\"Base class for all GraphQL types.\"\"\"\n    name: str\n    description: Optional[str] = None\n\n# Built-in scalar types\n@dataclass(frozen=True)\nclass ScalarType(GraphQLType):\n    \"\"\"GraphQL scalar type definition.\"\"\"\n    serialize: Callable[[Any], Any] = field(repr=False)\n    parse_value: Callable[[Any], Any] = field(repr=False)\n    parse_literal: Callable[[Any], Any] = field(repr=False)\n\n# Field definition for object and interface types\n@dataclass(frozen=True)\nclass GraphQLField:\n    \"\"\"A field on a GraphQL object or interface type.\"\"\"\n    type: GraphQLType\n    args: Dict[str, GraphQLArgument] = field(default_factory=dict)\n    resolve: Optional[Callable[[Any, Any, Any, Any], Any]] = field(default=None, repr=False)\n    description: Optional[str] = None\n    deprecation_reason: Optional[str] = None\n\n# Argument definition for fields and directives\n@dataclass(frozen=True)\nclass GraphQLArgument:\n    \"\"\"An argument to a field or directive.\"\"\"\n    type: GraphQLType\n    default_value: Optional[Any] = None\n    description: Optional[str] = None\n\n# Object type with fields and interfaces\n@dataclass(frozen=True)\nclass ObjectType(GraphQLType):\n    \"\"\"GraphQL object type definition.\"\"\"\n    fields: Dict[str, GraphQLField] = field(default_factory=dict)\n    interfaces: List[InterfaceType] = field(default_factory=list)\n\n# Interface type definition\n@dataclass(frozen=True)\nclass InterfaceType(GraphQLType):\n    \"\"\"GraphQL interface type definition.\"\"\"\n    fields: Dict[str, GraphQLField] = field(default_factory=dict)\n    resolve_type: Optional[Callable[[Any, Any], str]] = field(default=None, repr=False)\n\n# Union type definition\n@dataclass(frozen=True)\nclass UnionType(GraphQLType):\n    \"\"\"GraphQL union type definition.\"\"\"\n    types: List[ObjectType] = field(default_factory=list)\n    resolve_type: Optional[Callable[[Any, Any], str]] = field(default=None, repr=False)\n\n# Enum value definition\n@dataclass(frozen=True)\nclass EnumValue:\n    \"\"\"A value in a GraphQL enum type.\"\"\"\n    value: Any\n    description: Optional[str] = None\n    deprecation_reason: Optional[str] = None\n\n# Enum type definition\n@dataclass(frozen=True)\nclass EnumType(GraphQLType):\n    \"\"\"GraphQL enum type definition.\"\"\"\n    values: Dict[str, EnumValue] = field(default_factory=dict)\n\n# Input field definition\n@dataclass(frozen=True)\nclass GraphQLInputField:\n    \"\"\"A field on a GraphQL input object type.\"\"\"\n    type: GraphQLType\n    default_value: Optional[Any] = None\n    description: Optional[str] = None\n\n# Input object type definition\n@dataclass(frozen=True)\nclass InputObjectType(GraphQLType):\n    \"\"\"GraphQL input object type definition.\"\"\"\n    fields: Dict[str, GraphQLInputField] = field(default_factory=dict)\n\n# Type modifiers (List and NonNull)\n@dataclass(frozen=True)\nclass ListType(GraphQLType):\n    \"\"\"GraphQL list type wrapper.\"\"\"\n    of_type: GraphQLType = field(repr=True)\n    # Override name to be derived from of_type\n    def __post_init__(self):\n        object.__setattr__(self, 'name', f'[{self.of_type.name}]')\n\n@dataclass(frozen=True)\nclass NonNullType(GraphQLType):\n    \"\"\"GraphQL non-null type wrapper.\"\"\"\n    of_type: GraphQLType = field(repr=True)\n    # Override name to be derived from of_type\n    def __post_init__(self):\n        object.__setattr__(self, 'name', f'{self.of_type.name}!')\n\n# Schema definition\n@dataclass(frozen=True)\nclass Schema:\n    \"\"\"Root GraphQL schema containing all types.\"\"\"\n    query_type: ObjectType\n    mutation_type: Optional[ObjectType] = None\n    subscription_type: Optional[ObjectType] = None\n    types: Dict[str, GraphQLType] = field(default_factory=dict, repr=False)\n    directives: Dict[str, GraphQLDirective] = field(default_factory=dict, repr=False)\n\n# Directive definition\n@dataclass(frozen=True)\nclass GraphQLDirective:\n    \"\"\"GraphQL directive definition.\"\"\"\n    name: str\n    locations: List[str]\n    args: Dict[str, GraphQLArgument] = field(default_factory=dict)\n    description: Optional[str] = None\n```\n\n#### C. Core Logic Skeleton\n\nLearners should implement the schema validation logic in `type_system/schema.py`:\n\n```python\nfrom typing import Dict, List, Optional, Set\nfrom .types import *\n\ndef create_schema(\n    query_type: ObjectType,\n    mutation_type: Optional[ObjectType] = None,\n    subscription_type: Optional[ObjectType] = None,\n    additional_types: Optional[List[GraphQLType]] = None,\n    directives: Optional[List[GraphQLDirective]] = None\n) -> Schema:\n    \"\"\"\n    Create and validate a complete GraphQL schema.\n    \n    Args:\n        query_type: The root query type (required)\n        mutation_type: Optional root mutation type\n        subscription_type: Optional root subscription type\n        additional_types: Extra types to include in the schema\n        directives: Custom directives supported by the schema\n        \n    Returns:\n        A validated, immutable Schema object\n        \n    Raises:\n        GraphQLError: If the schema is invalid\n    \"\"\"\n    # TODO 1: Collect all types starting from root operation types\n    #   - Start with query_type, mutation_type, subscription_type\n    #   - Recursively collect referenced types (field types, argument types, etc.)\n    #   - Include built-in scalar types (Int, Float, String, Boolean, ID)\n    #   - Include introspection types (from get_introspection_types())\n    #   - Add any additional_types provided\n    \n    # TODO 2: Build type map: Dict[str, GraphQLType] mapping names to instances\n    #   - Check for duplicate type names (case-sensitive)\n    #   - Built-in types cannot be redefined\n    \n    # TODO 3: Validate all types according to GraphQL specification\n    #   - Call validate_schema() with the complete type map\n    #   - This should check: object types, interfaces, unions, enums, input objects\n    \n    # TODO 4: Create directives dictionary if directives provided\n    \n    # TODO 5: Return frozen Schema object with all validated components\n    pass\n\ndef validate_schema(schema: Schema) -> None:\n    \"\"\"\n    Validate a complete schema for consistency.\n    \n    This implements the validation rules from the GraphQL specification.\n    Should be called automatically by create_schema().\n    \n    Raises:\n        GraphQLError: With descriptive message about the first violation found\n    \"\"\"\n    # TODO 1: Validate root operation types exist and are ObjectType\n    \n    # TODO 2: Validate all objects\n    #   - Check field uniqueness\n    #   - Check argument uniqueness and valid types\n    #   - Verify interface implementations are complete\n    \n    # TODO 3: Validate all interfaces\n    #   - Check field uniqueness\n    #   - Check for circular interface implementations\n    \n    # TODO 4: Validate all unions\n    #   - Must have at least one member type\n    #   - Members must be ObjectType\n    \n    # TODO 5: Validate all enums\n    #   - Must have at least one value\n    #   - Value names must be unique\n    \n    # TODO 6: Validate all input objects\n    #   - Check field uniqueness\n    #   - Verify no circular references (use depth-first search)\n    \n    # TODO 7: Validate directives\n    #   - Check valid locations\n    #   - Validate directive arguments\n    \n    pass\n\ndef is_input_type(type_: GraphQLType) -> bool:\n    \"\"\"\n    Return True if the type can be used as an input type.\n    \n    Input types are: scalars, enums, input objects, and lists/non-nulls thereof.\n    Output types (objects, interfaces, unions) cannot be used as inputs.\n    \"\"\"\n    # TODO 1: Handle type modifiers (ListType, NonNullType)\n    #   - Unwrap to the inner type and check recursively\n    \n    # TODO 2: Check the base type kind\n    #   - Return True for: ScalarType, EnumType, InputObjectType\n    #   - Return False for: ObjectType, InterfaceType, UnionType\n    \n    pass\n\ndef is_output_type(type_: GraphQLType) -> bool:\n    \"\"\"\n    Return True if the type can be used as an output type.\n    \n    Output types are: objects, interfaces, unions, scalars, enums, and lists/non-nulls thereof.\n    Input objects cannot be used as outputs.\n    \"\"\"\n    # TODO 1: Handle type modifiers (ListType, NonNullType)\n    \n    # TODO 2: Check the base type kind\n    #   - Return True for: ObjectType, InterfaceType, UnionType, ScalarType, EnumType\n    #   - Return False for: InputObjectType\n    \n    pass\n```\n\n#### D. Language-Specific Hints\n\n- **Use `@dataclass(frozen=True)`** for immutability. This prevents accidental modifications after schema creation.\n- **Implement `__post_init__`** for computed fields like `ListType.name` that depends on `of_type.name`.\n- **For circular reference detection**, use a depth-first search with a `visited` set. Python's recursion limit may be hit for very deep chains, so consider iterative approach or `sys.setrecursionlimit()`.\n- **Use `typing.get_type_hints()`** for better introspection of your own types during development.\n- **Consider `functools.lru_cache`** for expensive validation results that are called repeatedly.\n\n#### E. Milestone Checkpoint\n\nAfter implementing Component 2, learners should test their type system:\n\n1. **Run the validation tests:**\n   ```bash\n   python -m pytest graphql_engine/type_system/tests/ -v\n   ```\n\n2. **Expected output should show:**\n   - All built-in scalar types are defined and have conversion functions\n   - Simple schema creation succeeds with valid types\n   - Invalid schemas raise descriptive `GraphQLError` messages\n   - Introspection types are present in every schema\n\n3. **Manual verification steps:**\n   ```python\n   # Create a simple valid schema\n   from graphql_engine.type_system import create_schema, ObjectType, GraphQLField, ScalarType\n   \n   # Define a simple object type\n   user_type = ObjectType(\n       name=\"User\",\n       fields={\n           \"id\": GraphQLField(type=ScalarType(name=\"ID\")),\n           \"name\": GraphQLField(type=ScalarType(name=\"String\"))\n       }\n   )\n   \n   # Create schema\n   schema = create_schema(query_type=user_type)\n   \n   # Verify introspection types exist\n   assert \"__Schema\" in schema.types\n   assert \"__Type\" in schema.types\n   assert \"__typename\" in user_type.fields  # Auto-added field\n   \n   print(\"✓ Schema created successfully!\")\n   ```\n\n4. **Signs something is wrong:**\n   - **Error:** \"Type 'String' not found\" → Forgot to include built-in scalar types\n   - **Error:** \"Can't add field to frozen dataclass\" → Trying to modify types after schema creation\n   - **Error:** Maximum recursion depth exceeded → Circular reference detection not working\n   - **Missing:** No `__typename` field on objects → Introspection field addition not implemented\n\n5. **Debugging tips:**\n   - Visualize the type hierarchy using the class diagram: ![Type System Class Diagram](./diagrams/type-system-class-diagram.svg)\n   - Print the schema's type map to see all registered types\n   - Use `graphql_engine.parser.parse_schema()` to parse SDL and test against your type builder\n\n---\n\n\n## Component 3: Query Execution Engine\n\n> **Milestone(s):** This section corresponds to Milestone 3: Query Execution, which focuses on executing GraphQL queries against a schema, resolving fields, handling errors, and managing data fetching efficiently.\n\n### Responsibility and Scope\n\nThe **Query Execution Engine** is the core runtime that transforms parsed GraphQL queries into actual data. It's responsible for coordinating the entire resolution process from the root of the query down to every leaf field. The engine doesn't fetch data itself but orchestrates a network of **resolver functions** that do the actual work.\n\n| Responsibility | In Scope | Out of Scope |\n|----------------|----------|--------------|\n| **Resolver Invocation** | Calling the appropriate resolver function for each field with correct arguments, parent value, and context. | Implementing business logic within resolvers (provided by user). |\n| **Error Propagation** | Collecting field errors, maintaining partial results, and following GraphQL error spec for null propagation. | Retry logic or external error reporting (e.g., to monitoring services). |\n| **Parallel Execution** | Executing independent sibling fields concurrently when possible to improve performance. | Distributed execution across multiple machines or microservices. |\n| **Null Handling** | Enforcing GraphQL's nullability rules: non-null field errors bubble up to nearest nullable parent. | Database NULL value interpretation (handled by SQL compiler). |\n| **Argument Coercion** | Converting raw variable/argument values (strings, numbers) to the expected GraphQL type (Int, Float, etc.). | Complex input validation beyond type correctness (e.g., business rules). |\n| **DataLoader Integration** | Providing infrastructure for batching and caching to solve N+1 query problems. | Implementing specific batch loading logic for every data source. |\n| **Context Management** | Passing a shared `ExecutionContext` object through all resolvers for request-scoped state. | Authentication/authorization logic (though context may hold user info). |\n\nThe execution engine is purely synchronous in its core algorithm, but it can be extended to support asynchronous resolvers (returning promises/futures). Its primary output is an `ExecutionResult` containing the final data and any errors encountered.\n\n### Mental Model: Assembly Line\n\nThink of query execution as an **automobile assembly line**. The raw materials (the query AST and root value) enter at the start. The assembly line has multiple stations (resolvers), each responsible for adding a specific part (field data) to the growing vehicle (result object). The conveyor belt moves the partially assembled vehicle from station to station.\n\n**Key parallels:**\n- **Work Order (Query AST):** The blueprint specifying exactly which parts to install and in what order.\n- **Assembly Stations (Resolvers):** Specialized workers that know how to fetch or compute specific parts (field values).\n- **Conveyor Belt (Execution Path):** The sequential flow from root fields down to nested selections.\n- **Quality Control (Error Handling):** If a station fails to install a required part (non-null field error), the entire vehicle might be scrapped (null propagated upward), but optional parts can be missing without halting production.\n- **Parallel Workstations (Sibling Fields):** Some stations can work simultaneously on different parts of the same vehicle (parallel field execution).\n\nThis mental model emphasizes that execution is a **coordinated, sequential process** where each step builds upon previous results, with strict rules about what happens when things go wrong.\n\n### Execution Interface\n\nThe public API of the execution engine is intentionally minimal. The primary entry point is a single function that accepts all necessary inputs and returns a complete result.\n\n| Method Signature | Returns | Description |\n|------------------|---------|-------------|\n| `execute_query(schema, document_ast, variable_values=None, operation_name=None, context_value=None, root_value=None)` | `ExecutionResult` | Executes a GraphQL query/mutation against the provided schema. This is the main public interface. |\n| `execute_query` Parameters | | |\n| `schema` | `Schema` | The GraphQL schema defining types and resolvers. |\n| `document_ast` | `Document` | The parsed AST from `parse_query`. |\n| `variable_values` | `Dict[str, Any]` | Values for variables defined in the operation. |\n| `operation_name` | `Optional[str]` | Name of operation to execute if document contains multiple. |\n| `context_value` | `Any` | Arbitrary value passed to all resolvers (e.g., database connection, user info). |\n| `root_value` | `Any` | Initial parent value for root-level resolvers (often `None` or a special root object). |\n\nThe `ExecutionContext` type is created internally and contains all the runtime state:\n\n| `ExecutionContext` Field | Type | Description |\n|--------------------------|------|-------------|\n| `schema` | `Schema` | Reference to the schema being executed against. |\n| `document_ast` | `Document` | The parsed query document. |\n| `operation_name` | `Optional[str]` | Name of the operation being executed. |\n| `variable_values` | `Dict[str, Any]` | Values for variables after coercion. |\n| `context_value` | `Any` | The context value passed from user (immutable during execution). |\n| `root_value` | `Any` | The root value passed from user. |\n| `fragments` | `Dict[str, FragmentDefinition]` | Map of fragment name to definition for quick lookup. |\n| `errors` | `List[GraphQLError]` | Accumulated errors during execution. |\n| `data_loaders` | `Dict[str, DataLoader]` | Map of DataLoader instances for batching. |\n| `path` | `List[PathSegment]` | Current field path (list of field names/array indices) for error tracking. |\n| `field_resolver` | `Callable` | Default function to resolve fields when no resolver is defined. |\n| `type_resolver` | `Callable` | Default function to resolve concrete type for abstract types. |\n\nThe `ExecutionResult` is the final output:\n\n| `ExecutionResult` Field | Type | Description |\n|-------------------------|------|-------------|\n| `data` | `Optional[Dict]` | The result data if execution succeeded (may be partial with errors). |\n| `errors` | `List[GraphQLError]` | List of errors encountered during execution. |\n| `extensions` | `Dict[str, Any]` | Optional extension metadata for profiling, tracing, etc. |\n\n### Execution Algorithm\n\nThe execution follows a **depth-first, recursive resolution** pattern with special handling for null propagation and parallel execution. Below is the step-by-step algorithm for the main `execute_query` function:\n\n1.  **Operation Selection:**\n    1.  Extract all operation definitions from `document_ast.definitions`.\n    2.  If `operation_name` is provided, find the operation with that name. If not found, raise an error.\n    3.  If `operation_name` is `None` and there's exactly one operation, select it. If there are multiple operations, raise an error (must specify name).\n    4.  The selected operation must be either `query` or `mutation` (subscriptions are out of scope).\n\n2.  **Variable Coercion:**\n    1.  For each `VariableDefinition` in the operation's `variable_definitions`:\n        - Get the provided value from `variable_values` dict.\n        - If no value provided, check for `default_value`. If present, use it.\n        - If no value and no default, and the variable type is non-null, raise an error.\n        - **Coerce** the value to match the variable's GraphQL type using the type system's `parse_value` functions (for scalars) or recursive validation (for input objects/lists).\n        - Store coerced value in the execution context's `variable_values`.\n\n3.  **Fragment Collection:**\n    1.  Gather all `FragmentDefinition` nodes from the document into a dictionary keyed by name for O(1) lookup during execution.\n\n4.  **Root Field Execution:**\n    1.  Determine the root `ObjectType` based on operation type: `schema.query_type` for queries, `schema.mutation_type` for mutations.\n    2.  Create initial `ExecutionContext` with all the prepared state.\n    3.  Call `execute_operation(execution_context, operation, root_object_type, root_value)`.\n        - **`execute_operation` algorithm:**\n            1.  Initialize an empty result map `{}`.\n            2.  Call `execute_selection_set(execution_context, operation.selection_set, root_object_type, root_value, result_map)`.\n            3.  Return `result_map`.\n\n5.  **Selection Set Execution (`execute_selection_set`):**\n    1.  For each `selection` in the selection set:\n        - If selection is a `Field`:\n            - Call `execute_field(execution_context, parent_type, parent_value, field)`.\n        - If selection is a `FragmentSpread`:\n            - Look up the fragment definition by name.\n            - Check if the fragment's `type_condition` matches `parent_type` (using `does_fragment_condition_match`).\n            - If it matches, recursively execute the fragment's `selection_set` via `execute_selection_set`.\n        - If selection is an `InlineFragment`:\n            - Check if the fragment's `type_condition` matches `parent_type` (or if no condition, it always matches).\n            - If it matches, recursively execute the fragment's `selection_set`.\n\n6.  **Field Execution (`execute_field`):**\n    1.  **Field Definition Lookup:** Get the `GraphQLField` definition from `parent_type.fields[field.name]`.\n    2.  **Argument Coercion:** For each argument in the field definition's `args`, compute its value:\n        - If the field AST has an `Argument` with matching name, use its value (coercing literals/variables).\n        - Otherwise, use the argument's `default_value` if defined.\n        - If no value and argument is non-null, raise an error.\n    3.  **Path Tracking:** Push the field's name (or alias) onto `execution_context.path`.\n    4.  **Resolver Selection:**\n        - Use the field definition's `resolve` function if provided.\n        - Otherwise, use the default `execution_context.field_resolver` (which typically returns a property from the parent object).\n    5.  **Resolver Invocation:** Call the resolver with arguments: `(parent_value, args, execution_context.context_value, info)` where `info` is an object containing field metadata, schema, and path.\n    6.  **Result Processing:**\n        - If resolver raises an exception, catch it, add a `GraphQLError` to `execution_context.errors`, and set `result = None`.\n        - If resolver returns a value, call `complete_value(execution_context, field.type, result)`.\n    7.  **Path Popping:** Pop from `execution_context.path`.\n    8.  Return the completed value.\n\n7.  **Value Completion (`complete_value`):**\n    1.  If `value` is `None`:\n        - If the expected type is non-null (`NonNullType`), add an error and return `None` (error will bubble).\n        - Otherwise, return `None`.\n    2.  If expected type is a `ListType`:\n        - Ensure `value` is iterable. For each item, recursively call `complete_value` with the list's inner type.\n        - Return a new list with completed items. If any item completion results in `None` (due to non-null error), the entire list becomes `None`.\n    3.  If expected type is a `ScalarType` or `EnumType`:\n        - Call the type's `serialize` function to ensure the value is in the correct output format.\n    4.  If expected type is an `ObjectType`, `InterfaceType`, or `UnionType`:\n        - Determine the concrete `ObjectType` (for interfaces/unions, use `resolve_type` callback).\n        - Call `execute_selection_set` with this concrete type and the `value` as the new parent.\n        - Return the resulting map.\n\n8.  **Parallel Execution:** Sibling fields (fields at the same nesting level in a selection set) have no implicit dependencies. The engine can execute them concurrently. In practice, this is implemented by:\n    - Gathering all field promises/futures at a given level.\n    - Waiting for all to complete before proceeding to nested selections.\n    - This is especially powerful when combined with `DataLoader` batching.\n\n9.  **Result Assembly:** After the root operation completes, package the final `result_map` and collected `errors` into an `ExecutionResult` and return it.\n\n> **Key Insight:** The algorithm's recursive structure mirrors the GraphQL query's hierarchical shape. Each level of recursion corresponds to a level of nesting in the query, with the `complete_value` function handling type-specific behavior at each step.\n\n### Architecture Decision: Execution Strategy\n\n> **Decision: Synchronous Core with Async/Await Integration**\n>\n> - **Context:** GraphQL resolvers often need to fetch data from asynchronous sources (databases, APIs). The execution engine must support this without blocking. We must choose between a purely synchronous design, a callback-based async design, or leveraging modern async/await patterns.\n> - **Options Considered:**\n>     1.  **Purely Synchronous:** All resolvers return plain values. Simple to implement but cannot handle I/O efficiently.\n>     2.  **Callback/Promise-based:** Resolvers return promises/tasks; engine manages a promise chain. Matches JavaScript's GraphQL.js but adds complexity.\n>     3.  **Async/Await Core:** Engine uses `async`/`await` throughout; resolvers can be sync or async. Leverages Python's `asyncio` natively.\n> - **Decision:** Implement a **synchronous core** with clear extension points for async execution. The base algorithm assumes synchronous resolvers, but we provide an alternative `execute_query_async` entry point that uses `asyncio` for async resolvers. This keeps the learning curve gentle while allowing real-world use.\n> - **Rationale:**\n>     - **Educational Value:** Understanding the synchronous algorithm is foundational; async adds complexity that can be layered on later.\n>     - **Language Support:** Python's `asyncio` is not trivial for beginners; offering both modes caters to different skill levels.\n>     - **Performance:** For many use cases (especially with DataLoader batching), synchronous execution with threaded pools is sufficient.\n> - **Consequences:**\n>     - Learners must implement two execution paths if they want full async support.\n>     - The synchronous engine cannot natively await async resolvers; they must be wrapped.\n>     - The design allows incremental adoption: start with sync, then add async later.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Purely Synchronous** | Simple implementation, easy to debug, no event loop complexity. | Cannot efficiently handle I/O-bound resolvers, poor real-world performance. | No |\n| **Callback/Promise-based** | Matches GraphQL.js pattern, enables non-blocking I/O. | Complex control flow, callback hell, difficult error handling. | No |\n| **Async/Await Core** | Native Python support, clean syntax, excellent for I/O. | Requires `asyncio` understanding, all resolvers must be async, harder to debug. | No |\n| **Sync Core + Async Extension** | Gentle learning curve, incremental adoption, supports both models. | Two execution paths to maintain, sync-to-async bridging required. | **Yes** |\n\n### Common Execution Pitfalls\n\n⚠️ **Pitfall: Missing Null Propagation**\n- **Description:** When a non-null field resolver returns `None` or raises an error, the engine must \"bubble up\" the null to the nearest nullable parent field per the GraphQL spec. Forgetting this rule leads to incorrect partial results or type errors.\n- **Why It's Wrong:** The spec is explicit: if a non-null field errors, its parent becomes `null` (if nullable), or continues bubbling. Violating this breaks client expectations and causes invalid response shapes.\n- **Fix:** In `complete_value`, when encountering a `None` value for a `NonNullType`, add an error and return `None`. The caller (`execute_field`) must then propagate this `None` upward appropriately.\n\n⚠️ **Pitfall: Naive N+1 Query Problem**\n- **Description:** Resolving a list of objects, then resolving a related field on each object triggers separate database queries (N+1). This cripples performance.\n- **Why It's Wrong:** Executing hundreds of queries for a single GraphQL request is inefficient and can overload the database.\n- **Fix:** Implement the **DataLoader pattern**. Create a `DataLoader` per request that batches individual loader calls into a single batched query. The execution engine should provide a `data_loaders` dict in the context for resolvers to use.\n\n⚠️ **Pitfall: Improper Error Handling Swallowing Exceptions**\n- **Description:** If a resolver raises an exception and the engine doesn't catch it, the entire query fails with a generic 500 error, losing the specific error details.\n- **Why It's Wrong:** GraphQL requires errors to be captured per-field and included in the `errors` array of the response, allowing partial data with errors.\n- **Fix:** Wrap every resolver invocation in a try-catch. Convert caught exceptions to `GraphQLError` with appropriate `path` and `locations`. Add to `execution_context.errors` but continue executing other fields.\n\n⚠️ **Pitfall: Executing Resolvers in Wrong Order (Depth-First vs. Breadth-First)**\n- **Description:** The execution order matters for side effects and optimal batching. A naive depth-first approach might serialize independent sibling fields unnecessarily.\n- **Why It's Wrong:** Missing opportunities for parallel execution reduces performance. For mutations, the spec requires sequential execution in the order they appear.\n- **Fix:** Separate query and mutation execution. For queries, use a **breadth-first approach** for sibling fields to enable batching and parallelism. For mutations, enforce strict depth-first, left-to-right execution as per spec.\n\n⚠️ **Pitfall: Forgetting to Coerce Argument Values**\n- **Description:** Passing raw string/int values from variables directly to resolvers without converting them to the correct GraphQL type (e.g., string `\"5\"` to integer `5`).\n- **Why It's Wrong:** Resolvers expect correctly typed arguments; mismatches cause runtime errors or incorrect behavior.\n- **Fix:** In `execute_field`, for each defined argument, call `value_from_ast` (using the type system's `parse_literal`/`parse_value`) to convert AST values/variables to the appropriate Python type.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Concurrency** | `threading.ThreadPoolExecutor` for parallel field execution. | `asyncio` with `async`/`await` for true async I/O. |\n| **DataLoader** | Custom batching cache using dictionaries and a simple batch function. | Full `DataLoader` implementation with request-scoped caching, prime caching, and clear methods. |\n| **Error Tracking** | Simple list of error dictionaries with message and path. | Full `GraphQLError` objects with extensions, original exception wrapping, and location formatting. |\n| **Resolver Info** | Pass a simple dictionary with field name, args, etc. | Formal `ResolveInfo` class with schema, root value, operation, and field nodes. |\n\n#### B. Recommended File/Module Structure\n\n```\ngraphql_engine/\n│\n├── execution/\n│   ├── __init__.py\n│   ├── executor.py           # Main synchronous Executor class\n│   ├── executor_async.py     # Optional async Executor class\n│   ├── values.py             # complete_value and type-specific completion\n│   ├── errors.py             # GraphQLError class and error formatting\n│   ├── dataloader.py         # DataLoader implementation\n│   └── middleware.py         # Execution middleware (future extension)\n│\n├── schema/                   # From Component 2\n├── parser/                   # From Component 1\n└── utils/\n    └── helpers.py\n```\n\n#### C. Infrastructure Starter Code\n\n**`errors.py` - Complete GraphQLError Implementation:**\n\n```python\nfrom typing import Optional, List, Any, Dict\nfrom dataclasses import dataclass\n\n@dataclass\nclass Location:\n    line: int\n    column: int\n\n@dataclass\nclass GraphQLError(Exception):\n    message: str\n    locations: Optional[List[Location]] = None\n    path: Optional[List[str | int]] = None\n    original_error: Optional[Exception] = None\n    extensions: Optional[Dict[str, Any]] = None\n    \n    def __str__(self) -> str:\n        return self.message\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert error to GraphQL spec response format.\"\"\"\n        error_dict: Dict[str, Any] = {\"message\": self.message}\n        if self.locations:\n            error_dict[\"locations\"] = [{\"line\": loc.line, \"column\": loc.column} for loc in self.locations]\n        if self.path:\n            error_dict[\"path\"] = self.path\n        if self.extensions:\n            error_dict[\"extensions\"] = self.extensions\n        return error_dict\n```\n\n**`dataloader.py` - Basic DataLoader Skeleton:**\n\n```python\nfrom typing import Callable, List, Any, Dict, Optional\nfrom collections import defaultdict\n\nclass DataLoader:\n    def __init__(self, batch_load_fn: Callable[[List[Any]], List[Any]], \n                 max_batch_size: Optional[int] = None):\n        self.batch_load_fn = batch_load_fn\n        self.max_batch_size = max_batch_size\n        self.cache: Dict[Any, Any] = {}\n        self.queue: List[Any] = []\n        \n    def load(self, key: Any) -> Any:\n        \"\"\"Schedule key for batch loading, return a future/promise.\"\"\"\n        # TODO 1: Check cache - if key exists, return cached value (could be promise)\n        # TODO 2: Add key to queue for next batch\n        # TODO 3: If queue length reaches max_batch_size, dispatch batch immediately\n        # TODO 4: Return a promise that will resolve when the batch completes\n        pass\n    \n    def dispatch(self) -> None:\n        \"\"\"Process all queued keys in a single batch.\"\"\"\n        # TODO 1: If queue is empty, return\n        # TODO 2: Get unique keys from queue\n        # TODO 3: Call batch_load_fn with list of keys\n        # TODO 4: Match results to keys and resolve/reject each promise\n        # TODO 5: Clear queue\n        pass\n    \n    def clear(self, key: Any) -> None:\n        \"\"\"Remove key from cache.\"\"\"\n        if key in self.cache:\n            del self.cache[key]\n    \n    def clear_all(self) -> None:\n        \"\"\"Clear entire cache.\"\"\"\n        self.cache.clear()\n        self.queue.clear()\n```\n\n#### D. Core Logic Skeleton Code\n\n**`executor.py` - Main Executor Class:**\n\n```python\nfrom typing import Dict, List, Any, Optional, Callable\nfrom ..schema import Schema, ObjectType, GraphQLField, NonNullType, ListType\nfrom ..parser import Document, OperationDefinition, Field, FragmentSpread, InlineFragment\nfrom .errors import GraphQLError\nfrom .dataloader import DataLoader\n\nclass ExecutionContext:\n    # TODO: Define all fields from the Data Model table above\n    # Hint: Use dataclass or simple class with __init__\n    pass\n\nclass Executor:\n    def execute_query(\n        self,\n        schema: Schema,\n        document_ast: Document,\n        variable_values: Optional[Dict[str, Any]] = None,\n        operation_name: Optional[str] = None,\n        context_value: Any = None,\n        root_value: Any = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute a GraphQL query synchronously.\n        Returns a dict with 'data' and 'errors' keys per GraphQL spec.\n        \"\"\"\n        # TODO 1: Validate schema is properly constructed (schema.types populated)\n        # TODO 2: Select operation (query/mutation) based on operation_name\n        # TODO 3: Coerce variable values to their declared types\n        # TODO 4: Collect fragments into a dictionary by name\n        # TODO 5: Create ExecutionContext with all parameters\n        # TODO 6: Determine root operation type (query_type/mutation_type from schema)\n        # TODO 7: Call execute_operation with root type and root_value\n        # TODO 8: Package result and errors into ExecutionResult format\n        # TODO 9: Return {'data': result, 'errors': formatted_errors}\n        pass\n    \n    def execute_operation(\n        self,\n        context: ExecutionContext,\n        operation: OperationDefinition,\n        root_type: ObjectType,\n        root_value: Any\n    ) -> Any:\n        \"\"\"Execute a single operation (query or mutation).\"\"\"\n        # TODO 1: Initialize empty result dict\n        # TODO 2: Get selection set from operation\n        # TODO 3: Call execute_selection_set with root_type and root_value\n        # TODO 4: Return result dict\n        pass\n    \n    def execute_selection_set(\n        self,\n        context: ExecutionContext,\n        selection_set: List[Any],  # List of Selection nodes\n        object_type: ObjectType,\n        parent_value: Any,\n        result_map: Dict[str, Any]\n    ) -> None:\n        \"\"\"Execute all selections in a set, storing results in result_map.\"\"\"\n        # TODO 1: For each selection in selection_set:\n        # TODO 2:   If selection is Field: call execute_field, store result at field's alias or name\n        # TODO 3:   If selection is FragmentSpread: resolve fragment and execute its selection set\n        # TODO 4:   If selection is InlineFragment: check type condition and execute its selection set\n        # TODO 5: For query operations: execute sibling fields in parallel (use ThreadPoolExecutor)\n        # TODO 6: For mutation operations: execute fields strictly sequentially\n        pass\n    \n    def execute_field(\n        self,\n        context: ExecutionContext,\n        parent_type: ObjectType,\n        parent_value: Any,\n        field_ast: Field\n    ) -> Any:\n        \"\"\"Resolve a single field.\"\"\"\n        # TODO 1: Get field definition from parent_type.fields[field_ast.name]\n        # TODO 2: Coerce field arguments using value_from_ast\n        # TODO 3: Build resolve info object with field metadata, schema, etc.\n        # TODO 4: Get resolver function (field.resolve or default_field_resolver)\n        # TODO 5: Push field name onto context.path\n        # TODO 6: Try: call resolver with (parent_value, args, context.context_value, resolve_info)\n        # TODO 7: Catch Exception: convert to GraphQLError, add to context.errors, set result = None\n        # TODO 8: Call complete_value with field.type and the result\n        # TODO 9: Pop from context.path\n        # TODO 10: Return completed value\n        pass\n    \n    def complete_value(\n        self,\n        context: ExecutionContext,\n        field_type: Any,  # GraphQLType\n        result: Any\n    ) -> Any:\n        \"\"\"Convert raw resolver result to proper GraphQL type output.\"\"\"\n        # TODO 1: If result is None: handle NonNullType error propagation\n        # TODO 2: If field_type is ListType: iterate and complete each item\n        # TODO 3: If field_type is ScalarType or EnumType: call serialize\n        # TODO 4: If field_type is ObjectType: execute_selection_set on result\n        # TODO 5: If field_type is InterfaceType or UnionType: resolve concrete type first\n        # TODO 6: Return completed value\n        pass\n```\n\n#### E. Language-Specific Hints\n\n- **Default Field Resolver:** Implement a simple default that gets attributes from parent objects:\n  ```python\n  def default_field_resolver(parent_value, args, context_value, info):\n      # If parent_value is a dict, return parent_value.get(info.field_name)\n      # If parent_value is an object, return getattr(parent_value, info.field_name, None)\n      # Otherwise return None\n  ```\n- **Parallel Execution:** Use `concurrent.futures.ThreadPoolExecutor` for synchronous parallel field execution. Remember that mutations must NOT run in parallel.\n- **Value Coercion:** Leverage the `parse_value` methods on scalar types you built in Component 2. For input objects, recursively coerce each field.\n- **Path Tracking:** Use a simple list for `context.path`. When entering a list item, append the index; when leaving, pop it.\n- **Error Locations:** Extract `line` and `column` from the AST nodes' `loc` field to populate error locations.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the execution engine, verify it works:\n\n1. **Run Basic Tests:**\n   ```bash\n   python -m pytest tests/execution/test_basic_resolution.py -v\n   ```\n   Expected output: All tests pass, showing successful field resolution.\n\n2. **Manual Test with a Simple Schema:**\n   Create a test script:\n   ```python\n   from graphql_engine import build_schema, execute_query\n   \n   schema = build_schema(\"\"\"\n     type Query {\n       hello: String\n       user(id: ID!): User\n     }\n     type User {\n       name: String\n       age: Int\n     }\n   \"\"\")\n   \n   # Add resolver functions\n   schema.query_type.fields[\"hello\"].resolve = lambda *_: \"World\"\n   \n   result = execute_query(schema, \"{ hello }\")\n   print(result)  # Should show: {'data': {'hello': 'World'}, 'errors': []}\n   ```\n\n3. **Check for Common Issues:**\n   - **Symptom:** Resolver exceptions crash the entire program.\n     - **Diagnosis:** Missing try-catch in `execute_field`.\n     - **Fix:** Wrap resolver call and convert exceptions to `GraphQLError`.\n   - **Symptom:** Nested fields don't resolve (always return `null`).\n     - **Diagnosis:** `complete_value` not calling `execute_selection_set` for object types.\n     - **Fix:** Ensure object type completion triggers further execution.\n   - **Symptom:** Non-null field errors don't bubble up.\n     - **Diagnosis:** Missing null propagation logic in `complete_value`.\n     - **Fix:** When a non-null field gets `None`, add error and return `None`.\n\n4. **Verify Error Handling:**\n   - Intentionally throw an exception in a resolver. The response should include `errors` array with details, but `data` may still have partial results.\n   - Test non-null field: if it returns `None`, the parent field should become `null` (if nullable).\n\n5. **Performance Check:**\n   - Execute a query with 10 sibling fields. They should resolve concurrently (check timing).\n   - For mutations, ensure fields execute sequentially even if they don't depend on each other.\n\n---\n\n\n## Component 4: Database Schema Reflection\n\n> **Milestone(s):** This section corresponds to Milestone 4: Database Schema Reflection, which focuses on auto-generating GraphQL schemas from database metadata by introspecting tables, columns, and relationships.\n\n### Responsibility and Scope\n\nThe **Database Schema Reflection** component acts as a bridge between the relational database world and the GraphQL type system. It transforms the flat, tabular structure of SQL databases into the hierarchical, strongly-typed GraphQL schema that Component 2 (Type System) can understand and Component 3 (Execution Engine) can query.\n\n**What this component DOES:**\n1. **Database Connection**: Establishes connections to target databases using appropriate drivers/adapters\n2. **Metadata Introspection**: Queries database system catalogs (like `information_schema` or `pg_catalog`) to discover tables, columns, constraints, and relationships\n3. **Type Mapping**: Converts SQL data types (INTEGER, VARCHAR, TIMESTAMP, etc.) to appropriate GraphQL scalar types (`Int`, `String`, `DateTime`, etc.)\n4. **Relationship Detection**: Identifies foreign key constraints and translates them into GraphQL field relationships (one-to-one, one-to-many)\n5. **Schema Generation**: Builds complete `ObjectType`, `InputObjectType`, and `EnumType` instances representing the database structure\n6. **Query/Mutation Generation**: Creates root query fields for CRUD operations (find by ID, list with filtering/pagination) and mutation fields for create/update/delete operations\n7. **Configuration Application**: Applies naming conventions, pluralization rules, and filtering based on configuration options\n\n**What this component does NOT do:**\n- Execute SQL queries (that's Component 5: Query to SQL Compilation)\n- Validate GraphQL queries (that's the type system's responsibility)\n- Handle authentication/authorization (explicit non-goal)\n- Support real-time schema changes (uses static reflection at startup)\n\n**Key Data Structures This Component Owns:**\n| Structure | Purpose | Relationship to Existing Types |\n|-----------|---------|--------------------------------|\n| `DatabaseMetadata` | Container for all introspected database information | New type specific to this component |\n| `TableMetadata` | Information about a single database table | Used to generate `ObjectType` |\n| `ColumnMetadata` | Information about a single column | Used to generate `GraphQLField` |\n| `ForeignKeyMetadata` | Information about foreign key relationships | Used to generate relationship fields |\n| `TypeMapping` | Mapping rules between SQL types and GraphQL types | Configuration-driven |\n| `NamingConfig` | Rules for naming GraphQL types/fields from database names | Configuration-driven |\n\n**Component Boundaries and Dependencies:**\n- **Input**: Database connection parameters (URL, credentials, schema name)\n- **Output**: A complete `Schema` object ready for Component 3 to execute queries against\n- **Depends On**: Component 2 (Type System) for creating type instances\n- **Used By**: The main application to bootstrap the GraphQL server with auto-generated schema\n\n### Mental Model: Mirror\n\nThink of database schema reflection as holding up a **mirror** to your database. The mirror doesn't create anything new—it simply reflects what's already there, but in a different format that GraphQL can understand. Just as a mirror shows your reflection but in reverse, schema reflection shows your database structure but transformed from tables/columns to types/fields.\n\n**Key Aspects of the Mirror Analogy:**\n\n1. **Faithful Representation**: A good mirror doesn't distort reality. Similarly, the reflection should accurately represent the database structure without hiding columns or changing data semantics.\n\n2. **Perspective Shift**: When you look in a mirror, you see yourself from a different perspective. Similarly, reflection transforms the database from a relational perspective (tables with foreign keys) to a GraphQL perspective (types with nested fields).\n\n3. **Selective Reflection**: Some mirrors are one-way or filtered. Our reflection can be configured to include/exclude certain tables, apply naming conventions, or hide sensitive columns.\n\n4. **Static vs. Dynamic**: A traditional mirror shows a static reflection at a moment in time. Our reflection can be either static (captured once at startup) or dynamic (refreshed periodically), with important trade-offs.\n\n**Visualizing the Transformation:**\n```\nDatabase Structure (Relational)      →      GraphQL Schema (Hierarchical)\n─────────────────────────────────────       ──────────────────────────────\nTable: users                           →      type User {\n  id: INTEGER (PK)                           →    id: ID!\n  name: VARCHAR(255)                         →    name: String\n  email: VARCHAR(255)                        →    email: String\n}                                            →    posts: [Post!]!   ← derived from FK\n                                            \nTable: posts                           →      type Post {\n  id: INTEGER (PK)                           →    id: ID!\n  user_id: INTEGER (FK → users.id)           →    title: String\n  title: VARCHAR(255)                        →    content: String\n  content: TEXT                              →    author: User!     ← derived from FK\n}                                            → }\n```\n\nThis mental model helps understand that we're not inventing a new schema—we're faithfully representing the existing database structure in GraphQL terms, with some opinionated transformations (like converting foreign keys to nested fields).\n\n### Reflection Interface\n\nThe reflection component exposes a clean, configuration-driven API that abstracts away database-specific details. Here's the complete public interface:\n\n**Primary Methods:**\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `reflect_schema` | `connection_config: Dict[str, Any]`<br>`options: ReflectionOptions` | `Schema` | Main entry point: connects to database, introspects metadata, builds and returns GraphQL schema |\n| `get_database_metadata` | `connection_config: Dict[str, Any]`<br>`filter: Optional[TableFilter]` | `DatabaseMetadata` | Low-level method that returns raw database metadata without building GraphQL types |\n| `generate_types_from_metadata` | `metadata: DatabaseMetadata`<br>`options: ReflectionOptions` | `Dict[str, GraphQLType]` | Converts database metadata to GraphQL types (can be used independently) |\n| `build_schema_from_types` | `types: Dict[str, GraphQLType]`<br>`options: ReflectionOptions` | `Schema` | Assembles types into a complete schema with query/mutation root types |\n\n**Configuration Structure (`ReflectionOptions`):**\n| Field | Type | Default | Description |\n|-------|------|---------|-------------|\n| `include_tables` | `List[str]` | `[]` (all) | Only reflect tables matching these patterns (supports SQL LIKE wildcards) |\n| `exclude_tables` | `List[str]` | `[]` | Exclude tables matching these patterns (takes precedence over include) |\n| `table_prefix` | `str` | `\"\"` | Prefix to add to all table names when generating GraphQL type names |\n| `table_suffix` | `str` | `\"\"` | Suffix to add to all table names when generating GraphQL type names |\n| `field_naming_convention` | `NamingConvention` | `CAMEL_CASE` | How to convert snake_case column names to GraphQL field names |\n| `type_naming_convention` | `NamingConvention` | `PASCAL_CASE` | How to convert snake_case table names to GraphQL type names |\n| `pluralization_rules` | `Dict[str, str]` | `{\"y\": \"ies\", ...}` | Rules for pluralizing type names in list fields |\n| `type_mappings` | `Dict[str, ScalarType]` | Built-in defaults | Override default SQL-to-GraphQL type mappings |\n| `include_relationships` | `bool` | `True` | Whether to generate fields for foreign key relationships |\n| `max_relationship_depth` | `int` | `3` | Maximum depth for recursive relationship traversal (prevents cycles) |\n| `include_comments` | `bool` | `True` | Use database column/table comments as GraphQL descriptions |\n| `readonly` | `bool` | `False` | If true, only generate query fields (no mutations) |\n\n**Connection Configuration Structure:**\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `database_type` | `str` | Yes | `\"postgresql\"`, `\"mysql\"`, `\"sqlite\"`, etc. |\n| `host` | `str` | Depends | Database server hostname |\n| `port` | `int` | Depends | Database server port |\n| `database` | `str` | Yes | Database name |\n| `schema` | `str` | No | Schema name (for databases with multiple schemas like PostgreSQL) |\n| `username` | `str` | Depends | Authentication username |\n| `password` | `str` | Depends | Authentication password |\n| `connection_string` | `str` | Alternative | Raw connection string (alternative to individual parameters) |\n| `ssl_mode` | `str` | No | `\"disable\"`, `\"require\"`, `\"verify-ca\"`, etc. |\n| `connection_timeout` | `int` | No | Connection timeout in seconds |\n\n**Usage Example in Prose:**\nA developer wants to reflect a PostgreSQL database containing e-commerce tables. They would call:\n```python\nschema = reflect_schema(\n    connection_config={\n        \"database_type\": \"postgresql\",\n        \"host\": \"localhost\",\n        \"port\": 5432,\n        \"database\": \"ecommerce\",\n        \"username\": \"app_user\",\n        \"password\": \"secure_password\"\n    },\n    options=ReflectionOptions(\n        exclude_tables=[\"audit_%\", \"temp_%\"],\n        field_naming_convention=NamingConvention.CAMEL_CASE,\n        type_naming_convention=NamingConvention.PASCAL_CASE,\n        include_comments=True\n    )\n)\n```\nThis would connect to the PostgreSQL database, introspect all tables except those starting with `audit_` or `temp_`, convert snake_case column names to camelCase field names, convert snake_case table names to PascalCase type names, and use database comments as GraphQL descriptions.\n\n### Reflection Algorithm\n\nThe reflection process follows a deterministic, multi-stage pipeline. Each stage transforms the data further toward a complete GraphQL schema. The state machine for this process is visualized in: ![Schema Reflection State Machine](./diagrams/reflection-state-machine.svg)\n\n**Algorithm Steps:**\n\n1. **Connection Establishment**\n   ```\n   1.1. Validate connection configuration parameters\n   1.2. Load appropriate database adapter based on `database_type`\n   1.3. Establish connection using driver-specific method\n   1.4. Verify connection with a simple test query (e.g., `SELECT 1`)\n   1.5. If connection fails, raise `ConnectionError` with diagnostic information\n   ```\n\n2. **Metadata Collection**\n   ```\n   2.1. Query `information_schema.tables` (or equivalent) for table list\n   2.2. Apply table filters (`include_tables`/`exclude_tables`)\n   2.3. For each table:\n       2.3.1. Query `information_schema.columns` for column definitions\n       2.3.2. Query `information_schema.key_column_usage` for primary/foreign keys\n       2.3.3. Query `information_schema.table_constraints` for constraint types\n       2.3.4. Query `pg_description`/equivalent for column/table comments (if `include_comments`)\n   2.4. Build `TableMetadata` objects with:\n       - Table name, schema, comment\n       - List of `ColumnMetadata` with name, type, nullable, default, comment\n       - Primary key column names\n       - List of `ForeignKeyMetadata` with target table/columns\n   ```\n\n3. **Type Mapping**\n   ```\n   3.1. For each column in each table:\n       3.1.1. Identify base SQL type (strip precision/length modifiers)\n       3.1.2. Look up in type mapping table (default + custom overrides)\n       3.1.3. Apply GraphQL type modifiers:\n           - If column is nullable → plain type\n           - If column is NOT NULL → wrap in `NonNullType`\n           - If column is array type → wrap in `ListType`\n       3.1.4. Store mapped GraphQL type in column metadata\n   3.2. Handle special cases:\n       - Columns named `id` or ending in `_id` → map to GraphQL `ID` type\n       - Timestamp/datetime columns → map to custom `DateTime` scalar\n       - JSON/JSONB columns → map to custom `JSON` scalar\n   ```\n\n4. **Relationship Analysis**\n   ```\n   4.1. For each foreign key constraint:\n       4.1.1. Identify source table/columns and target table/columns\n       4.1.2. Determine relationship cardinality:\n           - If target columns include primary key → one-to-one or many-to-one\n           - If source columns include primary key → one-to-one or one-to-many\n       4.1.3. Check for self-referential relationships (table references itself)\n       4.1.4. Detect join tables for many-to-many relationships\n       4.1.5. Build relationship graph with cycle detection\n       4.1.6. Stop traversing at `max_relationship_depth` to prevent infinite cycles\n   4.2. Build bidirectional field definitions:\n       - For one-to-many: parent → children as `[ChildType!]!`\n       - For many-to-one: child → parent as `ParentType!`\n       - For one-to-one: bidirectional singular references\n   ```\n\n5. **GraphQL Type Generation**\n   ```\n   5.1. For each table:\n       5.1.1. Apply naming conventions to generate type name\n       5.1.2. Create `ObjectType` with:\n           - Name: transformed table name\n           - Description: table comment (if available)\n           - Fields: column fields + relationship fields\n       5.1.3. Create `InputObjectType` for mutations:\n           - Name: `Create[TypeName]Input` / `Update[TypeName]Input`\n           - Fields: same as object type but with appropriate nullability\n   5.2. Generate enum types for:\n       - Columns with CHECK constraints limiting to specific values\n       - Columns with foreign keys to small reference/lookup tables\n   5.3. Register all types in type registry with proper dependency ordering\n   ```\n\n6. **Root Query/Mutation Generation**\n   ```\n   6.1. Build root `Query` type with:\n       6.1.1. For each table: `[typeName](id: ID!): TypeName` (single fetch)\n       6.1.2. For each table: `all[pluralTypeName](filter: FilterInput, ...): [TypeName!]!` (list)\n       6.1.3. Pagination arguments: `first`, `last`, `after`, `before`, `offset`, `limit`\n       6.1.4. Filter arguments: per-column filter inputs with operators (eq, ne, lt, gt, etc.)\n       6.1.5. Sort arguments: `orderBy: [TypeNameOrderBy!]`\n   6.2. If not `readonly`, build root `Mutation` type with:\n       6.2.1. `create[TypeName](input: CreateInput!): TypeName!`\n       6.2.2. `update[TypeName](id: ID!, input: UpdateInput!): TypeName!`\n       6.2.3. `delete[TypeName](id: ID!): TypeName!`\n   6.3. Add aggregate fields: `count[TypeName](filter: FilterInput): Int!`\n   ```\n\n7. **Schema Assembly**\n   ```\n   7.1. Create `Schema` object with:\n       7.1.1. `query_type`: Generated Query type\n       7.1.2. `mutation_type`: Generated Mutation type (if not readonly)\n       7.1.3. `types`: All generated GraphQL types\n       7.1.4. `directives`: Standard GraphQL directives\n   7.2. Run schema validation (using Component 2's `validate_schema`)\n   7.3. Return complete schema\n   ```\n\n**Concrete Walk-Through Example:**\n\nConsider a simple blog database with `users` and `posts` tables. The algorithm would:\n\n1. Connect to database and find tables: `users`, `posts`\n2. Introspect columns:\n   - `users`: `id` (INTEGER PK), `name` (VARCHAR), `email` (VARCHAR)\n   - `posts`: `id` (INTEGER PK), `user_id` (INTEGER FK), `title` (VARCHAR), `content` (TEXT)\n3. Detect foreign key: `posts.user_id` → `users.id` (many-to-one)\n4. Map types: INTEGER → `Int`, VARCHAR → `String`, TEXT → `String`\n5. Generate GraphQL types:\n   - `User` with fields: `id: ID!`, `name: String`, `email: String`, `posts: [Post!]!`\n   - `Post` with fields: `id: ID!`, `title: String`, `content: String`, `author: User!`\n6. Generate root fields:\n   - Query: `user(id: ID!): User`, `allUsers(...): [User!]!`, `post(id: ID!): Post`, `allPosts(...): [Post!]!`\n   - Mutation: `createUser(...): User!`, `createPost(...): Post!`, etc.\n7. Assemble and validate schema\n\n### Architecture Decision: Reflection Strategy\n\n> **Decision: Static Reflection with Configuration-Driven Transformations**\n>\n> **Context**: We need to generate a GraphQL schema from a database schema, but databases and GraphQL have different structural paradigms (tables vs. types, foreign keys vs. nested fields). We must decide how aggressively to transform the database structure and whether to reflect dynamically (on each query) or statically (once at startup).\n>\n> **Options Considered**:\n> 1. **Pure 1:1 Reflection**: Map each table to a type, each column to a field, foreign keys remain as scalar ID fields\n> 2. **Aggressive Transformation**: Automatically create nested fields for relationships, generate pagination/filtering, apply naming conventions\n> 3. **Dynamic Reflection**: Re-introspect database on each query or schema request\n>\n> **Decision**: We chose **Static Reflection with Configuration-Driven Transformations** (a balanced approach between options 1 and 2, with static rather than dynamic reflection).\n>\n> **Rationale**:\n> - **Performance**: Static reflection happens once at startup, not on every query\n> - **Predictability**: The schema is stable during server runtime\n> - **Customizability**: Configuration options let users choose transformation aggressiveness\n> - **Simplicity**: Static schemas are easier to debug and document\n> - **Compatibility**: Works with GraphQL client tools that expect stable schemas\n>\n> **Consequences**:\n> - ✅ Schema changes require server restart\n> - ✅ Consistent performance regardless of database size\n> - ✅ Can pre-compute optimized data structures\n> - ❌ Doesn't automatically pick up database schema changes\n> - ❌ Startup time increases with large databases\n> - ❌ Memory usage for storing the complete reflected schema\n\n**Options Comparison Table:**\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| **Pure 1:1 Reflection** | Simple implementation, no surprises | Poor GraphQL ergonomics (manual joins in queries), doesn't leverage GraphQL's strengths | Too simplistic—defeats purpose of GraphQL's nested queries |\n| **Aggressive Transformation** | Best developer experience, automatic relationships | May create unexpected fields, harder to customize | Chosen as default but with configuration to dial back |\n| **Dynamic Reflection** | Always up-to-date with database, no restarts needed | Performance overhead, caching complexity, unpredictable schema | Performance and stability concerns outweigh benefits |\n| **Static with Config** (CHOSEN) | Balanced, configurable, performant, predictable | Requires restart for schema changes, memory overhead | Best trade-off for most use cases |\n\n**Supporting Decisions:**\n\n> **Decision: Use Database System Catalogs Over ORM Models**\n>\n> **Context**: We need to introspect database structure. We could either query database system tables (`information_schema`) or use an ORM's model introspection.\n>\n> **Decision**: Query database system catalogs directly.\n>\n> **Rationale**:\n> - Works with any database without ORM model definitions\n> - Always reflects actual database state (not potentially stale model code)\n> - Consistent across different database backends (standardized `information_schema`)\n> - No dependency on specific ORM libraries\n>\n> **Consequences**: Must handle database-specific quirks in system catalog queries.\n\n> **Decision: Configuration-Driven Naming Conventions**\n>\n> **Context**: Database naming conventions (snake_case) differ from GraphQL conventions (camelCase). We must decide how to transform names.\n>\n> **Decision**: Make naming conventions configurable with sensible defaults.\n>\n> **Rationale**:\n> - Different teams have different preferences\n> - Legacy databases may have non-standard naming\n> - Can adapt to organizational standards\n> - Default (snake_case → camelCase) follows common GraphQL practice\n>\n> **Consequences**: Configuration complexity increases but accommodates more use cases.\n\n**State Machine Transitions:**\nThe reflection process follows a defined state machine (referenced earlier). Here are the detailed transitions:\n\n| Current State | Event | Next State | Action Taken |\n|---------------|-------|------------|--------------|\n| `DISCONNECTED` | `connect_requested` | `CONNECTING` | Validate connection parameters, load database adapter |\n| `CONNECTING` | `connection_succeeded` | `INTROSPECTING` | Establish connection, verify with test query |\n| `CONNECTING` | `connection_failed` | `ERROR` | Log error details, clean up connection resources |\n| `INTROSPECTING` | `metadata_collected` | `ANALYZING` | Query system catalogs, build metadata structures |\n| `INTROSPECTING` | `introspection_failed` | `ERROR` | Handle permission errors, missing tables, etc. |\n| `ANALYZING` | `analysis_complete` | `GENERATING` | Map types, detect relationships, build graph |\n| `ANALYZING` | `circular_reference` | `ANALYZING` | Log warning, apply max depth limit, continue |\n| `GENERATING` | `types_generated` | `ASSEMBLING` | Create GraphQL types from analyzed metadata |\n| `ASSEMBLING` | `schema_built` | `READY` | Assemble complete schema, run validation |\n| `ASSEMBLING` | `validation_failed` | `ERROR` | Log validation errors, suggest fixes |\n| `READY` | `reset_requested` | `DISCONNECTED` | Close connections, clear cached metadata |\n| Any state | `timeout` | `ERROR` | Operation took too long, abort and clean up |\n\n### Common Reflection Pitfalls\n\n⚠️ **Pitfall: Incorrect Type Mapping**\n- **Description**: Mapping a SQL `DECIMAL(10,2)` to GraphQL `Float` loses precision, or mapping `TIMESTAMP WITH TIME ZONE` to `String` loses type safety.\n- **Why It's Wrong**: Data loss, incorrect validation, poor client experience. GraphQL clients expect appropriate scalar types with proper coercion behavior.\n- **How to Fix**: Create custom scalar types for database-specific types (e.g., `Decimal`, `DateTime`, `JSON`). Use database metadata about precision/scale to choose appropriate mappings.\n\n⚠️ **Pitfall: Missing Circular Relationship Detection**\n- **Description**: Database has self-referential foreign keys (e.g., `employee.manager_id → employee.id`) or circular chains (A → B → C → A), causing infinite recursion during type generation.\n- **Why It's Wrong**: Infinite loops crash the reflection process or generate infinitely nested GraphQL types.\n- **How to Fix**: Implement cycle detection in relationship graph traversal. Use `max_relationship_depth` configuration to limit traversal. For self-references, generate a nullable field to break the cycle.\n\n⚠️ **Pitfall: Naming Conflicts**\n- **Description**: Database has tables named `user` and `User` (case-insensitive in some databases but distinct in GraphQL), or a column name conflicts with a reserved GraphQL field name like `__typename`.\n- **Why It's Wrong**: GraphQL schema validation fails with duplicate type/field names or reserved word conflicts.\n- **How to Fix**: Apply name normalization (consistent casing), add prefixes/suffixes to conflicting names, rename reserved words (e.g., `type` → `type_`). Log warnings when conflicts are detected and automatically resolved.\n\n⚠️ **Pitfall: Permission Issues**\n- **Description**: Database user lacks permissions to query `information_schema` or specific tables, causing incomplete or empty reflection.\n- **Why It's Wrong**: Generated schema is incomplete, missing tables or columns the application actually needs to access.\n- **How to Fix**: Validate permissions during connection test. Provide clear error messages suggesting needed privileges. Offer `partial_reflection` mode that continues with accessible tables and logs warnings for inaccessible ones.\n\n⚠️ **Pitfall: Handling Database-Specific Quirks**\n- **Description**: PostgreSQL arrays, MySQL enum columns, SQLite type affinity, SQL Server schemas—each database has unique features not present in others.\n- **Why It's Wrong**: Reflection fails or produces incorrect schemas when encountering unsupported features.\n- **How to Fix**: Implement database adapters with specialized queries for each database type. Provide extension points for custom type handlers. Default to safe fallbacks (e.g., map unknown types to `String`).\n\n⚠️ **Pitfall: Ignoring Database Comments**\n- **Description**: Not using column/table comments from the database as GraphQL descriptions.\n- **Why It's Wrong**: Misses opportunity for self-documenting API. GraphQL tools like GraphiQL show descriptions, improving developer experience.\n- **How to Fix**: Always query for comments when available. Use empty string as default when comments are absent. Make this configurable (`include_comments` option).\n\n⚠️ **Pitfall: Generating Too Many Types**\n- **Description**: Reflecting every table including system tables, audit logs, temporary tables, or migration history tables.\n- **Why It's Wrong**: Schema becomes bloated, confusing, and potentially exposes sensitive system information.\n- **How to Fix**: Provide filtering options (`include_tables`, `exclude_tables`). Default to excluding common system table patterns. Allow regex or glob pattern matching.\n\n**Error Recovery Strategies:**\n| Failure Mode | Detection | Recovery Action |\n|--------------|-----------|-----------------|\n| Connection failure | Connection timeout or authentication error | Retry with exponential backoff (max 3 attempts), then raise clear error |\n| Missing information_schema | Query returns empty or permission error | Fall back to database-specific system tables, log warning |\n| Circular reference detected | Graph traversal depth exceeds limit | Stop traversing, make field nullable to break cycle, log warning |\n| Type mapping not found | SQL type not in mapping table | Map to `String` scalar, log warning with suggestion for custom mapping |\n| Name conflict | Duplicate normalized name detected | Add numeric suffix (`_2`, `_3`), log warning with both original names |\n| Memory exhaustion | Memory usage exceeds threshold during large DB reflection | Process in batches, free intermediate data, log progress |\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option | Rationale |\n|-----------|---------------|-----------------|-----------|\n| Database Adapter | Single database support (PostgreSQL) | Pluggable adapters (PostgreSQL, MySQL, SQLite) | Start with one to learn pattern, extend later |\n| Connection Pooling | No pooling (create per reflection) | Connection pooling with `aiopg`/`asyncpg` | Reflection happens rarely, pooling adds complexity |\n| Metadata Caching | None (re-introspect each time) | File cache of serialized metadata | Speeds up development, reduces database load |\n| Configuration | Python dictionary | Pydantic models with validation | Type-safe configuration with better error messages |\n| Naming Utilities | Simple string replacement | inflection library (pluralize, camelize) | More robust handling of edge cases |\n\n#### B. Recommended File/Module Structure\n\n```\ngraphql-engine/\n├── reflection/                    # This component\n│   ├── __init__.py\n│   ├── core.py                    # Main reflection entry points\n│   ├── metadata.py                # DatabaseMetadata, TableMetadata, etc.\n│   ├── introspection/             # Database-specific adapters\n│   │   ├── __init__.py\n│   │   ├── base.py                # BaseIntrospector abstract class\n│   │   ├── postgres.py            # PostgreSQL implementation\n│   │   ├── mysql.py               # MySQL implementation\n│   │   └── sqlite.py              # SQLite implementation\n│   ├── mapping/                   # Type mapping logic\n│   │   ├── __init__.py\n│   │   ├── type_mapper.py         # SQL-to-GraphQL type mapping\n│   │   ├── naming.py              # Naming convention utilities\n│   │   └── defaults.py            # Default type mappings per database\n│   ├── generators/                # GraphQL type generators\n│   │   ├── __init__.py\n│   │   ├── object_type.py         # Generate ObjectType from table\n│   │   ├── input_type.py          # Generate InputObjectType\n│   │   ├── query.py               # Generate root Query fields\n│   │   └── mutation.py            # Generate root Mutation fields\n│   ├── analysis/                  # Relationship analysis\n│   │   ├── __init__.py\n│   │   ├── relationship.py        # Detect and analyze relationships\n│   │   ├── graph.py               # Graph traversal for cycles\n│   │   └── cardinality.py         # Determine 1:1, 1:many, many:many\n│   └── config.py                  # Configuration models\n├── types/                         # Component 2 (Type System)\n└── execution/                     # Component 3 (Execution Engine)\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete Database Adapter Base Class:**\n```python\n# reflection/introspection/base.py\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass ColumnMetadata:\n    \"\"\"Metadata for a database column.\"\"\"\n    name: str\n    table_name: str\n    table_schema: str\n    data_type: str\n    is_nullable: bool\n    is_primary_key: bool\n    default_value: Optional[str]\n    character_maximum_length: Optional[int]\n    numeric_precision: Optional[int]\n    numeric_scale: Optional[int]\n    comment: Optional[str]\n\n@dataclass\nclass TableMetadata:\n    \"\"\"Metadata for a database table.\"\"\"\n    name: str\n    schema: str\n    comment: Optional[str]\n    columns: List[ColumnMetadata]\n    primary_key_columns: List[str]\n    foreign_keys: List[Dict[str, Any]]\n\n@dataclass\nclass DatabaseMetadata:\n    \"\"\"Complete database metadata.\"\"\"\n    tables: Dict[str, TableMetadata]  # key: f\"{schema}.{name}\"\n    enums: Dict[str, List[str]]       # enum name → list of values\n    version: str                      # database version\n\nclass BaseIntrospector(ABC):\n    \"\"\"Abstract base class for database introspectors.\"\"\"\n    \n    def __init__(self, connection_config: Dict[str, Any]):\n        self.connection_config = connection_config\n        self.connection = None\n    \n    @abstractmethod\n    async def connect(self) -> None:\n        \"\"\"Establish database connection.\"\"\"\n        pass\n    \n    @abstractmethod\n    async def introspect_tables(self, \n                               schema: Optional[str] = None,\n                               include_tables: Optional[List[str]] = None,\n                               exclude_tables: Optional[List[str]] = None) -> DatabaseMetadata:\n        \"\"\"Introspect all tables in the database.\"\"\"\n        pass\n    \n    @abstractmethod\n    async def get_table_comment(self, table_name: str, schema: str) -> Optional[str]:\n        \"\"\"Get comment/description for a table.\"\"\"\n        pass\n    \n    @abstractmethod\n    async def get_column_comments(self, table_name: str, schema: str) -> Dict[str, str]:\n        \"\"\"Get comments for all columns in a table.\"\"\"\n        pass\n    \n    async def close(self) -> None:\n        \"\"\"Close database connection.\"\"\"\n        if self.connection:\n            await self.connection.close()\n    \n    def __enter__(self):\n        raise TypeError(\"Use async context manager\")\n    \n    def __exit__(self, *args):\n        pass\n    \n    async def __aenter__(self):\n        await self.connect()\n        return self\n    \n    async def __aexit__(self, *args):\n        await self.close()\n```\n\n**Complete Configuration Models with Validation:**\n```python\n# reflection/config.py\nfrom enum import Enum\nfrom typing import Dict, List, Optional, Any\nfrom pydantic import BaseModel, Field, validator\n\nclass NamingConvention(str, Enum):\n    \"\"\"Naming convention options.\"\"\"\n    CAMEL_CASE = \"camel_case\"       # column_name → columnName\n    PASCAL_CASE = \"pascal_case\"     # column_name → ColumnName\n    SNAKE_CASE = \"snake_case\"       # column_name → column_name (unchanged)\n    KEBAB_CASE = \"kebab_case\"       # column_name → column-name\n\nclass ReflectionOptions(BaseModel):\n    \"\"\"Configuration options for schema reflection.\"\"\"\n    \n    # Table filtering\n    include_tables: List[str] = Field(default_factory=list)\n    exclude_tables: List[str] = Field(default_factory=list)\n    \n    # Naming conventions\n    table_prefix: str = \"\"\n    table_suffix: str = \"\"\n    field_naming_convention: NamingConvention = NamingConvention.CAMEL_CASE\n    type_naming_convention: NamingConvention = NamingConvention.PASCAL_CASE\n    \n    # Type mapping\n    type_mappings: Dict[str, Any] = Field(default_factory=dict)\n    \n    # Relationships\n    include_relationships: bool = True\n    max_relationship_depth: int = Field(default=3, ge=1, le=10)\n    \n    # Features\n    include_comments: bool = True\n    readonly: bool = False\n    include_aggregates: bool = True\n    include_filters: bool = True\n    include_pagination: bool = True\n    \n    @validator('exclude_tables')\n    def validate_filters(cls, v, values):\n        \"\"\"Ensure include/exclude don't conflict in confusing ways.\"\"\"\n        if values.get('include_tables') and v:\n            # Warn if a table is both included and excluded\n            conflicts = set(values['include_tables']) & set(v)\n            if conflicts:\n                import warnings\n                warnings.warn(\n                    f\"Tables {conflicts} are both included and excluded. \"\n                    \"Exclude takes precedence.\"\n                )\n        return v\n```\n\n#### D. Core Logic Skeleton Code\n\n**Main Reflection Entry Point:**\n```python\n# reflection/core.py\nfrom typing import Dict, Any, Optional\nfrom .config import ReflectionOptions\nfrom .metadata import DatabaseMetadata\nfrom .introspection import get_introspector\nfrom .mapping.type_mapper import TypeMapper\nfrom .generators.object_type import generate_object_types\nfrom .generators.query import generate_root_query\nfrom .generators.mutation import generate_root_mutation\nfrom types import Schema, ObjectType\n\nasync def reflect_schema(\n    connection_config: Dict[str, Any],\n    options: Optional[ReflectionOptions] = None\n) -> Schema:\n    \"\"\"\n    Main entry point: reflect database schema to GraphQL schema.\n    \n    Args:\n        connection_config: Database connection parameters\n        options: Configuration options for reflection\n    \n    Returns:\n        Complete GraphQL Schema object\n    \n    Raises:\n        ConnectionError: If database connection fails\n        ReflectionError: If schema reflection fails\n    \n    Steps:\n        1. Connect to database using appropriate introspector\n        2. Collect metadata (tables, columns, constraints)\n        3. Analyze relationships and build graph\n        4. Map SQL types to GraphQL types\n        5. Generate GraphQL types from metadata\n        6. Generate root Query and Mutation types\n        7. Assemble and validate complete schema\n    \"\"\"\n    # TODO 1: Validate connection_config has required fields\n    # TODO 2: Set default options if not provided\n    # TODO 3: Get appropriate introspector for database type\n    # TODO 4: Connect to database and collect metadata\n    # TODO 5: Apply table filtering (include_tables/exclude_tables)\n    # TODO 6: Detect and analyze relationships between tables\n    # TODO 7: Map SQL types to GraphQL types using TypeMapper\n    # TODO 8: Generate GraphQL ObjectType for each table\n    # TODO 9: Generate root Query type with query fields\n    # TODO 10: If not readonly, generate root Mutation type\n    # TODO 11: Assemble Schema object with all types\n    # TODO 12: Validate schema using Component 2's validate_schema\n    # TODO 13: Return complete schema\n    pass\n\nasync def get_database_metadata(\n    connection_config: Dict[str, Any],\n    schema: Optional[str] = None,\n    include_tables: Optional[List[str]] = None,\n    exclude_tables: Optional[List[str]] = None\n) -> DatabaseMetadata:\n    \"\"\"\n    Low-level method to get raw database metadata without building GraphQL types.\n    \n    Useful for debugging or custom schema generation pipelines.\n    \"\"\"\n    # TODO 1: Get introspector for database type\n    # TODO 2: Connect to database\n    # TODO 3: Introspect tables with given filters\n    # TODO 4: Return DatabaseMetadata object\n    pass\n```\n\n**Type Mapper with Default Mappings:**\n```python\n# reflection/mapping/type_mapper.py\nfrom typing import Dict, Any, Optional\nfrom ..metadata import ColumnMetadata\nfrom types import GraphQLType, ScalarType, ListType, NonNullType\n\nclass TypeMapper:\n    \"\"\"Maps SQL data types to GraphQL types.\"\"\"\n    \n    # Default type mappings for PostgreSQL\n    POSTGRES_MAPPINGS = {\n        \"integer\": \"Int\",\n        \"bigint\": \"Int\",\n        \"smallint\": \"Int\",\n        \"numeric\": \"Decimal\",  # Custom scalar\n        \"decimal\": \"Decimal\",\n        \"real\": \"Float\",\n        \"double precision\": \"Float\",\n        \"text\": \"String\",\n        \"varchar\": \"String\",\n        \"char\": \"String\",\n        \"boolean\": \"Boolean\",\n        \"timestamp\": \"DateTime\",\n        \"timestamptz\": \"DateTime\",\n        \"date\": \"Date\",\n        \"time\": \"Time\",\n        \"json\": \"JSON\",\n        \"jsonb\": \"JSON\",\n        \"uuid\": \"ID\",\n        \"bytea\": \"String\",  # Base64 encoded\n    }\n    \n    def __init__(self, custom_mappings: Optional[Dict[str, Any]] = None):\n        self.mappings = self.POSTGRES_MAPPINGS.copy()\n        if custom_mappings:\n            self.mappings.update(custom_mappings)\n    \n    def map_column_type(self, column: ColumnMetadata) -> GraphQLType:\n        \"\"\"\n        Map a database column to a GraphQL type.\n        \n        Args:\n            column: Column metadata including data_type, is_nullable, etc.\n        \n        Returns:\n            GraphQL type with appropriate modifiers (List, NonNull)\n        \n        Steps:\n            1. Get base SQL type (strip length/precision modifiers)\n            2. Look up in mappings table\n            3. Apply NonNull wrapper if column is NOT NULL\n            4. Apply List wrapper if column is array type\n            5. Special handling for ID columns (name ends with _id or is primary key)\n        \"\"\"\n        # TODO 1: Normalize SQL type (e.g., \"varchar(255)\" → \"varchar\")\n        # TODO 2: Look up in self.mappings, fall back to \"String\" if not found\n        # TODO 3: Get GraphQL scalar type from registry or create custom scalar\n        # TODO 4: Check if column is array type (ends with [] in PostgreSQL)\n        # TODO 5: If array, wrap in ListType\n        # TODO 6: Check if column is nullable (is_nullable flag)\n        # TODO 7: If NOT nullable, wrap in NonNullType\n        # TODO 8: Special case: columns named 'id' or ending in '_id' → ID type\n        # TODO 9: Return complete type with all modifiers\n        pass\n    \n    def register_custom_mapping(self, sql_type: str, graphql_type: GraphQLType) -> None:\n        \"\"\"Register a custom SQL-to-GraphQL type mapping.\"\"\"\n        # TODO 1: Validate graphql_type is a scalar type\n        # TODO 2: Add to mappings dictionary\n        # TODO 3: Log warning if overwriting existing mapping\n        pass\n```\n\n**Relationship Detector:**\n```python\n# reflection/analysis/relationship.py\nfrom typing import Dict, List, Set, Tuple, Optional\nfrom ..metadata import TableMetadata, DatabaseMetadata\nfrom dataclasses import dataclass\n\n@dataclass\nclass Relationship:\n    \"\"\"Represents a relationship between two tables.\"\"\"\n    source_table: str  # f\"{schema}.{name}\"\n    source_columns: List[str]\n    target_table: str\n    target_columns: List[str]\n    relationship_type: str  # \"one_to_one\", \"one_to_many\", \"many_to_one\", \"many_to_many\"\n    foreign_key_name: Optional[str]\n    is_self_referential: bool\n\nclass RelationshipAnalyzer:\n    \"\"\"Analyzes foreign keys to detect relationships between tables.\"\"\"\n    \n    def __init__(self, max_depth: int = 3):\n        self.max_depth = max_depth\n        self.relationships: Dict[str, List[Relationship]] = {}\n        self.reverse_relationships: Dict[str, List[Relationship]] = {}\n    \n    def analyze(self, metadata: DatabaseMetadata) -> Dict[str, List[Relationship]]:\n        \"\"\"\n        Analyze all foreign keys to build relationship graph.\n        \n        Args:\n            metadata: Database metadata with tables and foreign keys\n        \n        Returns:\n            Dictionary mapping table name to list of relationships\n        \n        Steps:\n            1. For each table, extract foreign key constraints\n            2. Determine relationship cardinality\n            3. Detect self-referential relationships\n            4. Build adjacency lists for forward and reverse relationships\n            5. Detect cycles and apply depth limiting\n            6. Return complete relationship graph\n        \"\"\"\n        # TODO 1: Initialize empty relationships dictionaries\n        # TODO 2: For each table in metadata.tables\n        # TODO 3: For each foreign key in table.foreign_keys\n        # TODO 4: Determine source and target tables/columns\n        # TODO 5: Check if self-referential (source == target)\n        # TODO 6: Determine cardinality (check primary key involvement)\n        # TODO 7: Create Relationship object\n        # TODO 8: Add to relationships[source_table] and reverse_relationships[target_table]\n        # TODO 9: After all FKs processed, detect many-to-many via join tables\n        # TODO 10: Detect cycles using DFS with max_depth limit\n        # TODO 11: Log warnings for circular references\n        # TODO 12: Return relationships dictionary\n        pass\n    \n    def _detect_cardinality(self, \n                           source_table: TableMetadata,\n                           target_table: TableMetadata,\n                           source_columns: List[str],\n                           target_columns: List[str]) -> str:\n        \"\"\"\n        Determine relationship cardinality.\n        \n        Rules:\n        - If target columns are primary key → many-to-one or one-to-one\n        - If source columns are primary key → one-to-many or one-to-one\n        - If both → one-to-one\n        - If neither → many-to-many (requires join table detection)\n        \"\"\"\n        # TODO 1: Check if target_columns ⊆ target_table.primary_key_columns\n        # TODO 2: Check if source_columns ⊆ source_table.primary_key_columns\n        # TODO 3: Return appropriate relationship_type string\n        pass\n```\n\n#### E. Language-Specific Hints\n\n**Python-Specific Recommendations:**\n- **Async/Await**: Use `async`/`await` for database operations to avoid blocking the event loop. Most database drivers support async (e.g., `asyncpg` for PostgreSQL, `aiomysql` for MySQL).\n- **Connection Management**: Use async context managers (`async with`) to ensure proper connection cleanup even on errors.\n- **Type Hints**: Use Python's type hints extensively. This component has complex data structures that benefit from static type checking with mypy.\n- **Pydantic**: Use Pydantic models for configuration validation—it provides excellent error messages and type coercion.\n- **Caching**: Use `functools.lru_cache` for expensive operations like type mapping lookups.\n- **Logging**: Use structured logging (`structlog` or `logging` with JSON formatter) to track reflection progress and issues.\n\n**Database-Specific Considerations:**\n- **PostgreSQL**: Use `asyncpg` for best performance. Query `pg_catalog` instead of `information_schema` for better performance with large schemas.\n- **MySQL**: `information_schema` can be slow on large databases. Consider caching results.\n- **SQLite**: No `information_schema`—use `PRAGMA table_info()` and `PRAGMA foreign_key_list()`.\n- **SQL Injection**: Never concatenate table/column names into SQL queries. Use parameterized queries for values, but for identifiers, validate against a whitelist or use database-specific quoting functions.\n\n**Performance Optimizations:**\n- **Batch Queries**: Instead of querying each table's columns individually, batch queries using `UNION` or query all columns at once with appropriate filters.\n- **Parallel Introspection**: Use `asyncio.gather()` to introspect multiple tables concurrently when safe to do so.\n- **Metadata Caching**: Serialize `DatabaseMetadata` to JSON file after first reflection. On subsequent starts, check if database schema has changed (via `SELECT schema_version()` or similar) before using cache.\n\n#### F. Milestone Checkpoint\n\n**After implementing Database Schema Reflection, you should be able to:**\n\n1. **Connect and Introspect**: Run a test that connects to your database and lists all tables:\n   ```python\n   python -m pytest tests/test_reflection.py::test_connect_and_list_tables -v\n   ```\n   Expected output: Lists tables in your test database with column counts.\n\n2. **Generate GraphQL Schema**: Run the reflection and output the generated GraphQL SDL:\n   ```python\n   from reflection import reflect_schema\n   import asyncio\n   \n   async def test_reflection():\n       schema = await reflect_schema({\n           \"database_type\": \"postgresql\",\n           \"database\": \"test_db\"\n       })\n       print(schema.to_sdl())\n   \n   asyncio.run(test_reflection())\n   ```\n   Expected: Valid GraphQL Schema Definition Language showing types for your tables.\n\n3. **Verify Relationships**: Check that foreign keys generate proper GraphQL fields:\n   ```python\n   # After reflection, verify that User type has posts: [Post!]! field\n   # and Post type has author: User! field\n   ```\n\n4. **Test Configuration Options**: Apply different naming conventions and verify:\n   ```python\n   # With camelCase: user_name → userName\n   # With PascalCase: user_name → UserName\n   ```\n\n**Signs Something is Wrong:**\n- **No tables found**: Check database permissions, schema name, connection parameters\n- **Missing relationships**: Check if foreign key constraints exist in database\n- **Type mapping errors**: Unknown SQL types need custom mappings\n- **Performance issues**: Large databases may timeout—increase timeout or implement paginated introspection\n\n**Verification Commands:**\n```bash\n# Run unit tests for reflection component\npytest reflection/ -v\n\n# Run integration test with actual database\npytest tests/integration/test_reflection_integration.py -v --db-url postgresql://user:pass@localhost/test_db\n\n# Generate and validate schema\npython scripts/generate_schema.py --validate\n\n# Check for circular references\npython scripts/analyze_relationships.py --max-depth 5\n```\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Reflection returns empty schema | Database user lacks permissions | Check introspection queries manually: `SELECT * FROM information_schema.tables` | Grant SELECT on `information_schema` or specific tables |\n| Missing foreign key relationships | Foreign keys not defined or introspector missing them | Query `information_schema.key_column_usage` directly | Ensure FKs exist in DB; check introspector SQL |\n| GraphQL type name conflicts | Tables with same name in different schemas | Log normalized type names during generation | Use schema prefix: `SchemaName_TableName` |\n| Memory usage spikes | Large database with many tables/columns | Monitor memory during reflection; use batch processing | Process tables in batches; free intermediate data |\n| Reflection times out | Very large schema or slow database connection | Add timeout logging at each stage | Increase timeout; implement progress reporting |\n| Custom type mapping not working | Mapping registered after introspection | Check order of operations in `reflect_schema` | Register custom mappings before calling `map_column_type` |\n| Circular reference crashes | Self-referential FK without depth limit | Check logs for \"max depth exceeded\" warnings | Implement cycle detection; use `max_relationship_depth` |\n| Generated schema invalid | Type validation fails | Run `validate_schema` on output; check error details | Fix type generation logic; ensure all types are registered |\n\n**Diagnostic Tools:**\n1. **Metadata Inspector**: Write a simple script that dumps raw database metadata to JSON for inspection:\n   ```python\n   metadata = await get_database_metadata(connection_config)\n   import json\n   print(json.dumps(metadata, default=str, indent=2))\n   ```\n2. **Relationship Visualizer**: Generate a DOT file of table relationships:\n   ```python\n   analyzer = RelationshipAnalyzer()\n   relationships = analyzer.analyze(metadata)\n   # Output DOT format for Graphviz\n   ```\n3. **SQL Query Logger**: Enable query logging in your database adapter to see what introspection queries are being executed.\n\n**Common Configuration Issues:**\n- **Case sensitivity**: PostgreSQL is case-sensitive for quoted identifiers. If your tables were created with quotes (`CREATE TABLE \"User\"`), you must reference them as `\"User\"` not `user`.\n- **Schema vs Database**: In PostgreSQL, `database.schema.table` vs MySQL's `database.table`. Ensure you're introspecting the correct schema.\n- **Connection pools**: If using connection pooling, ensure connections have the right search path or default schema set.\n\n---\n\n\n## Component 5: Query to SQL Compilation\n> **Milestone(s):** This section corresponds to Milestone 5: Query to SQL Compilation, which focuses on translating GraphQL queries into optimized SQL statements that efficiently retrieve data from relational databases while avoiding common performance pitfalls.\n\n### Responsibility and Scope\n\nThe **Query to SQL Compilation** component bridges the conceptual gap between GraphQL's hierarchical, nested query model and relational databases' tabular structure. This component transforms a validated GraphQL query AST into one or more SQL statements that can be executed against a database, returning exactly the data requested by the client in the optimal format.\n\n**Core responsibilities:**\n- **AST-to-SQL translation:** Convert GraphQL field selections into SQL `SELECT` column lists\n- **JOIN generation:** Translate nested object fields into appropriate SQL `JOIN` clauses based on foreign key relationships detected during schema reflection\n- **Parameterization:** Convert GraphQL arguments and variables into SQL parameters to prevent injection vulnerabilities\n- **Batching:** Combine multiple related data fetches into single SQL statements to avoid the N+1 query problem\n- **Filtering and pagination:** Translate GraphQL filter arguments and pagination directives (`first`, `after`, `where`) into SQL `WHERE`, `LIMIT`, `OFFSET`, and `ORDER BY` clauses\n- **Type coercion:** Ensure database column values are properly cast to GraphQL scalar types\n\n**Boundaries and limitations:**\n- Does **not** handle GraphQL subscriptions or real-time queries\n- Does **not** implement database write operations (mutations) — only query compilation\n- Does **not** handle database-specific optimizations like index hints or query plan analysis\n- Relies on the **Database Schema Reflection** component for table/column metadata and relationship information\n- Assumes the GraphQL schema has been validated and all types are properly defined\n\n**Data ownership:** This component owns the transformation pipeline from GraphQL AST to parameterized SQL statements, including intermediate representations like `SQLSelect` and `SQLExpression` that capture the query structure before string generation.\n\n### Mental Model: Travel Planner\n\n> Think of the SQL compiler as a **travel planner** for your data. When you want to visit multiple cities (tables) and see specific attractions (columns), a good travel planner doesn't book separate flights between each city (N+1 queries). Instead, they design an **efficient itinerary** (JOINs) that visits all desired locations in the optimal order, carrying only the luggage you need (selected columns), and following your specific preferences (filters and sorting).\n\n**Core analogy mappings:**\n\n| Travel Planning Concept | SQL Compilation Concept |\n|-------------------------|-------------------------|\n| **Destinations to visit** | Tables referenced in the query |\n| **Attractions at each destination** | Columns selected from each table |\n| **Travel routes between cities** | Foreign key relationships enabling JOINs |\n| **Packing list (what to bring)** | SELECT clause column list |\n| **Preferences (dates, budget)** | WHERE clause filter conditions |\n| **Itinerary order** | ORDER BY clause sorting |\n| **Trip duration limits** | LIMIT/OFFSET pagination |\n| **Group tour vs. individual travel** | Batched query vs. separate queries |\n\nThe compiler's job is to analyze the complete \"travel plan\" (GraphQL query), identify all required destinations and their relationships, then generate the most efficient route that minimizes \"travel time\" (database roundtrips) while respecting all \"traveler preferences\" (query arguments).\n\n### Compiler Interface\n\nThe SQL compiler exposes a clean, focused API that accepts validated GraphQL queries and returns executable SQL statements with their parameters. The interface centers around the `compile_to_sql` method, which serves as the main entry point.\n\n**Public API Methods:**\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `compile_to_sql` | `schema: Schema`, `document_ast: Document`, `operation_name: Optional[str] = None`, `variable_values: Dict[str, Any] = None`, `context: Dict[str, Any] = None` | `SQLQuery` | Main compilation entry point: converts a GraphQL query into an executable SQL statement with parameters |\n| `analyze_selections` | `selection_set: SelectionSet`, `parent_type: GraphQLType`, `path: List[PathSegment]`, `table_alias: str` | `Tuple[List[SQLColumn], List[SQLJoin], List[RelationshipPath]]` | Internal helper: analyzes field selections and builds SQL column and join structures |\n| `build_where_clause` | `arguments: List[Argument]`, `field_type: GraphQLType`, `table_metadata: TableMetadata`, `variable_values: Dict[str, Any]` | `Optional[SQLExpression]` | Constructs SQL WHERE conditions from GraphQL filter arguments |\n| `apply_pagination` | `sql_select: SQLSelect`, `arguments: List[Argument]`, `variable_values: Dict[str, Any]`, `primary_key_columns: List[str]` | `SQLSelect` | Applies LIMIT, OFFSET, and ORDER BY clauses based on pagination arguments |\n\n**The `SQLQuery` Data Structure:**\nThe compilation result encapsulates everything needed to execute the query against a database:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `root_select` | `SQLSelect` | The main SELECT statement representing the root query operation |\n| `nested_selects` | `List[SQLSelect]` | Additional SELECT statements for relationships that cannot be joined in a single query (e.g., many-to-many with additional filtering) |\n| `parameters` | `List[SQLParameter]` | Positional or named parameters to be bound to the SQL statement |\n| `result_mapper` | `Optional[Callable[[List[Dict]], Dict]]` | Function to transform flat SQL results into nested GraphQL response shape |\n| `query_plan` | `Dict[str, Any]` | Execution plan metadata for debugging and optimization |\n\n**Usage Pattern:**\n```python\n# High-level usage example (conceptual, not code)\nsql_query = compile_to_sql(\n    schema=reflected_schema,\n    document_ast=parsed_query,\n    variable_values={\"userId\": 123},\n    operation_name=\"GetUserWithPosts\"\n)\n\n# Execute against database\nresults = db.execute(sql_query.root_select.sql, sql_query.parameters)\n# Transform results using the mapper\nnested_data = sql_query.result_mapper(results)\n```\n\n### Compilation Algorithm\n\nThe compilation process follows a systematic, multi-phase approach that transforms GraphQL AST through several intermediate representations before producing executable SQL. The algorithm ensures correctness (returning exactly requested data) while optimizing for performance (minimizing database roundtrips).\n\n**Phase 1: Query Analysis and Normalization**\n\n1. **Operation Selection:** Identify the target operation from the `Document` AST based on `operation_name` or select the single operation if only one exists\n2. **Variable Substitution:** Replace all GraphQL variables in the query with their actual values from `variable_values`, performing type coercion as needed\n3. **Fragment Expansion:** Expand all fragment spreads (`...FragmentName`) and inline fragments (`... on Type`) into their full selection sets, filtered by type conditions\n4. **Field Flattening:** Recursively traverse the selection set, building a flat list of field paths with their complete context (parent types, arguments, directives)\n\n**Phase 2: Join Planning and Relationship Analysis**\n\n5. **Root Table Identification:** Determine the primary database table corresponding to the GraphQL query root type (from schema reflection metadata)\n6. **Relationship Graph Construction:** For each nested field in the selection set, identify the foreign key relationship between parent and child tables using the `Relationship` metadata from schema reflection\n7. **Join Path Optimization:** Analyze all required joins and reorder them to:\n   - Minimize the size of intermediate result sets (filter early)\n   - Avoid cartesian products (ensure proper join conditions)\n   - Respect database join limitations (some databases limit JOIN count)\n8. **Join Type Selection:** Choose appropriate JOIN types:\n   - `INNER JOIN` for non-nullable relationships\n   - `LEFT JOIN` for nullable relationships or when the parent field might be null\n   - `LATERAL JOIN` for one-to-many relationships with per-row subqueries (PostgreSQL)\n\n**Phase 3: SQL Generation**\n\n9. **Column Selection:** For each requested GraphQL field, map to the corresponding database column, applying any necessary type casts or transformations\n10. **WHERE Clause Construction:** Convert GraphQL filter arguments into SQL conditions:\n    - Equality checks (`{ where: { id: { eq: 123 } } }`) → `WHERE id = $1`\n    - Complex operators (`{ status: { in: [\"ACTIVE\", \"PENDING\"] } }`) → `WHERE status IN ($1, $2)`\n    - Nested object filters (`{ author: { name: { like: \"%John%\" } } }`) → `JOIN` with condition\n11. **Sorting and Pagination:**\n    - Convert `orderBy` arguments to `ORDER BY` clauses\n    - Implement cursor-based pagination using `LIMIT` and `OFFSET` or `WHERE id > cursor` patterns\n    - Apply `first`/`last` arguments as `LIMIT` with appropriate ordering\n12. **Parameter Binding:** Replace all literal values with parameter placeholders (`$1`, `$2`, `?`) to prevent SQL injection, collecting values in the `parameters` list\n\n**Phase 4: Result Mapping Preparation**\n\n13. **Row-to-Object Mapping:** Generate a `result_mapper` function that knows how to transform the flat SQL result set (with columns from multiple joined tables) into the nested object structure expected by GraphQL\n14. **Alias Handling:** Respect field aliases in the GraphQL query when constructing both the SQL column aliases and the result mapping\n15. **Type Coercion Planning:** Plan any necessary type conversions from SQL result types to GraphQL scalar types (e.g., database `TIMESTAMP` → GraphQL `String` ISO format)\n\n**Concrete Walk-Through Example:**\n\nConsider a GraphQL query fetching a user and their posts:\n```graphql\nquery GetUser($userId: ID!) {\n  user(id: $userId) {\n    id\n    name\n    email\n    posts(first: 10, orderBy: CREATED_AT_DESC) {\n      id\n      title\n      createdAt\n    }\n  }\n}\n```\n\nThe compilation algorithm processes this as:\n\n1. **Operation Selection:** Identifies `GetUser` as the target operation\n2. **Variable Substitution:** Replaces `$userId` with actual value (e.g., `123`)\n3. **Fragment Expansion:** (No fragments in this query)\n4. **Field Flattening:** Creates field paths: `user` (root), `user.id`, `user.name`, `user.email`, `user.posts`, `user.posts.id`, `user.posts.title`, `user.posts.createdAt`\n5. **Root Table Identification:** Maps `User` GraphQL type to `users` database table\n6. **Relationship Analysis:** Identifies `users.id` → `posts.user_id` foreign key relationship\n7. **Join Planning:** Creates plan: `users` LEFT JOIN `posts` (since user might have no posts)\n8. **Column Selection:** Maps fields to columns: `id`→`users.id`, `name`→`users.name`, etc.\n9. **WHERE Clause:** Adds `WHERE users.id = $1`\n10. **Pagination:** Adds `ORDER BY posts.created_at DESC LIMIT 10`\n11. **Parameter Binding:** Binds `$1 = 123`\n12. **Result Mapping:** Creates mapper that groups posts by user ID to nest them under each user\n\nThe final SQL might resemble:\n```sql\nSELECT users.id, users.name, users.email, \n       posts.id AS posts__id, posts.title AS posts__title, \n       posts.created_at AS posts__created_at\nFROM users\nLEFT JOIN posts ON users.id = posts.user_id\nWHERE users.id = $1\nORDER BY posts.created_at DESC\nLIMIT 10\n```\n\n### Architecture Decision: Compilation Approach\n\n> **Decision: Single-Query JOINs with Lateral Subqueries for Complex Cases**\n> - **Context:** We must translate nested GraphQL queries to SQL while balancing performance (minimizing roundtrips) with correctness (handling complex filtering/pagination at each relationship level). Deeply nested queries with filtering at multiple levels present particular challenges.\n> - **Options Considered:**\n>   1. **Pure Single-Query JOINs:** Generate one massive SQL statement with all tables JOINed together\n>   2. **Separate Queries with Batching:** Issue separate SQL queries per relationship level but batch them using IN clauses\n>   3. **Hybrid with Lateral Joins:** Use single-query JOINs for simple cases, LATERAL JOINs for filtered one-to-many relationships\n>   4. **ORM-style N+1 then Optimize:** Start with naive N+1 queries, then optimize common patterns\n> - **Decision:** Option 3 (Hybrid with Lateral Joins) for PostgreSQL, with fallback to Option 2 (Batched Separate Queries) for databases without LATERAL JOIN support\n> - **Rationale:** \n>   - **Performance:** Single-query JOINs minimize database roundtrips (most important for network latency)\n>   - **Correctness:** LATERAL JOINs allow applying filters/limits to nested collections per parent row (unachievable with simple JOINs)\n>   - **Database Compatibility:** Fallback strategy ensures support across different SQL dialects\n>   - **Complexity Management:** Separating simple vs. complex cases keeps the common path simple\n> - **Consequences:**\n>   - **Positive:** Excellent performance for common query patterns, correct handling of nested filters/limits\n>   - **Negative:** More complex SQL generation logic, database-specific code paths, potential for very large SQL statements\n>   - **Mitigation:** Implement query size limits, provide EXPLAIN plan analysis for optimization hints\n\n**Comparison of Compilation Strategies:**\n\n| Approach | Pros | Cons | Best For |\n|----------|------|------|----------|\n| **Single-Query JOINs** | - Single database roundtrip<br>- Database optimizes entire query plan<br>- Consistent ordering guarantees | - Cartesian product risk with many-to-many<br>- Can't limit nested collections per parent<br>- Large result sets with duplicates | Shallow queries without nested filters/limits |\n| **Batched Separate Queries** | - Clean separation of concerns<br>- Easy to apply per-level filters<br>- Avoids duplicate data in results | - Multiple roundtrips (network overhead)<br>- Connection pool pressure<br>- Consistency timing issues | Deeply nested queries with complex per-level logic |\n| **LATERAL JOINs** | - Single roundtrip<br>- Correct per-parent filtering<br>- Database optimizes across joins | - PostgreSQL-specific (not all DBs)<br>- Complex SQL generation<br>- Query planner may struggle | One-to-many relationships with filters/limits |\n| **GraphQL-to-SQL Middleware** | - Reuse existing libraries<br>- Community support<br>- Battle-tested | - Less educational value<br>- Hidden complexity<br>- May not match our exact needs | Production systems (not learning projects) |\n\n**Supporting Decision: Raw SQL Generation over ORM**\n- **Context:** We need to generate database queries that are both efficient and debuggable. Using an ORM provides abstraction but hides SQL details and limits optimization.\n- **Decision:** Generate raw, parameterized SQL statements rather than using an ORM query builder\n- **Rationale:** \n  - **Transparency:** Learners can see exactly what SQL is generated and debug it\n  - **Performance:** Direct control over SQL allows specific optimizations\n  - **Flexibility:** Can use database-specific features and syntax\n  - **Educational Value:** Teaches SQL generation patterns directly\n- **Consequences:** Must handle SQL dialect differences, injection protection manually, and query string construction logic\n\n### Common Compilation Pitfalls\n\n⚠️ **Pitfall: Cartesian Products from Missing Join Conditions**\n- **Description:** Generating SQL with multiple JOINs but forgetting the ON conditions, causing every row from one table to match with every row from another (N×M results)\n- **Why It's Wrong:** Explodes result set size exponentially, crashes database with memory exhaustion, returns incorrect data relationships\n- **How to Fix:** Always verify every JOIN has an ON clause, use foreign key relationships from schema reflection, add validation that checks for Cartesian products in generated SQL\n\n⚠️ **Pitfall: N+1 Query Problem**\n- **Description:** For a list of N parent items, issuing N additional queries to fetch related child items instead of using a single JOIN or batched query\n- **Why It's Wrong:** Horrible performance (N+1 roundtrips), database connection exhaustion, poor scalability\n- **How to Fix:** Implement the DataLoader pattern for separate queries, or use JOINs/LATERAL joins for single-query approach. Always analyze the selection set to batch sibling field resolutions.\n\n⚠️ **Pitfall: SQL Injection Vulnerabilities**\n- **Description:** Concatenating user-provided values directly into SQL strings instead of using parameterized queries\n- **Why It's Wrong:** Critical security vulnerability allowing attackers to execute arbitrary SQL, steal data, or destroy database\n- **How to Fix:** Always use parameter binding (`$1`, `?`), never interpolate values. For dynamic column/table names (rarely needed), use an allowlist or strict validation.\n\n⚠️ **Pitfall: Missing Null Propagation Handling**\n- **Description:** When a LEFT JOIN returns NULL for child records, incorrectly treating the entire parent record as null rather than just the nested field\n- **Why It's Wrong:** Violates GraphQL specification where nulls propagate to nearest nullable parent, returns incorrect empty results instead of partial data\n- **How to Fix:** Implement proper null handling in the result mapper, distinguish between \"parent not found\" and \"child relationship null\". Use GraphQL's nullability rules from the schema.\n\n⚠️ **Pitfall: Incorrect Type Mapping**\n- **Description:** Database `DECIMAL(10,2)` values returned as strings instead of GraphQL Float, or database `TIMESTAMP` not converted to ISO string format\n- **Why It's Wrong:** GraphQL clients receive data in wrong format, breaking type contracts and causing client-side errors\n- **How to Fix:** Use the type mapping rules established during schema reflection consistently. Apply SQL CAST operations or post-processing transformations as needed.\n\n⚠️ **Pitfall: Unbounded Result Sets**\n- **Description:** Forgetting to add `LIMIT` clauses to queries that could return millions of rows, especially on list fields without `first`/`last` arguments\n- **Why It's Wrong:** Database and application memory exhaustion, denial of service, poor performance\n- **How to Fix:** Implement default limits (e.g., max 1000 rows), require pagination arguments for list fields, or implement query cost analysis to reject expensive queries.\n\n⚠️ **Pitfall: Ignoring Database Indexes**\n- **Description:** Generating WHERE clauses that don't align with database indexes, like applying functions to indexed columns (`WHERE LOWER(name) = 'john'`)\n- **Why It's Wrong:** Forces full table scans instead of index seeks, terrible performance on large tables\n- **How to Fix:** Analyze common filter patterns during schema reflection, generate WHERE clauses that preserve index usability, provide hints to create appropriate indexes.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **SQL Builder** | String concatenation with careful escaping | SQLAlchemy Core or similar query builder library |\n| **Parameter Binding** | `?` positional placeholders with list of values | Named parameters with dictionary binding |\n| **Database Adapter** | DB-API 2.0 (Python's `sqlite3`, `psycopg2`) | Async database driver (`asyncpg`, `aiosqlite`) |\n| **Result Mapping** | Manual dictionary transformation | Custom row-to-object mapper with metadata |\n| **Query Optimization** | Basic join ordering heuristics | EXPLAIN plan analysis and cost-based optimization |\n\n**B. Recommended File/Module Structure:**\n\n```\ngraphql_engine/\n├── compiler/                           # SQL Compilation component\n│   ├── __init__.py\n│   ├── sql_builder.py                  # SQL string construction utilities\n│   ├── join_planner.py                 # JOIN analysis and optimization\n│   ├── where_builder.py                # WHERE clause generation from filters\n│   ├── pagination.py                   # Cursor-based pagination logic\n│   ├── result_mapper.py                # Flat SQL → nested GraphQL transformation\n│   ├── dialects/                       # Database-specific SQL generation\n│   │   ├── __init__.py\n│   │   ├── postgresql.py\n│   │   ├── sqlite.py\n│   │   └── mysql.py\n│   └── tests/\n│       ├── test_sql_builder.py\n│       ├── test_join_planner.py\n│       └── test_integration.py\n├── execution/                          # Execution engine (from Component 3)\n│   └── data_loader.py                  # DataLoader implementation for batching\n└── reflection/                         # Schema reflection (from Component 4)\n    └── metadata.py                     # Table/column metadata structures\n```\n\n**C. Infrastructure Starter Code:**\n\nComplete SQL builder utilities for safe SQL generation:\n\n```python\n# graphql_engine/compiler/sql_builder.py\n\"\"\"Safe SQL generation with parameter binding.\"\"\"\n\nfrom typing import List, Dict, Any, Optional, Union\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass SQLDialect(Enum):\n    POSTGRESQL = \"postgresql\"\n    SQLITE = \"sqlite\"\n    MYSQL = \"mysql\"\n\n@dataclass\nclass SQLParameter:\n    name: str\n    value: Any\n    type: str  # Optional type hint for the database\n\nclass SQLBuilder:\n    \"\"\"Builds parameterized SQL statements safely.\"\"\"\n    \n    def __init__(self, dialect: SQLDialect = SQLDialect.POSTGRESQL):\n        self.dialect = dialect\n        self._parameters: List[SQLParameter] = []\n        self._sql_parts: List[str] = []\n        self._param_counter = 0\n        \n    def add_parameter(self, value: Any, type_hint: Optional[str] = None) -> str:\n        \"\"\"Add a value as a parameter and return its placeholder.\"\"\"\n        param_name = f\"p{self._param_counter}\"\n        self._param_counter += 1\n        self._parameters.append(SQLParameter(name=param_name, value=value, type=type_hint or \"unknown\"))\n        \n        if self.dialect == SQLDialect.POSTGRESQL:\n            return f\"${len(self._parameters)}\"\n        elif self.dialect == SQLDialect.SQLITE:\n            return \"?\"\n        elif self.dialect == SQLDialect.MYSQL:\n            return \"%s\"\n        else:\n            return \"?\"\n    \n    def add_literal(self, sql_fragment: str) -> None:\n        \"\"\"Add a raw SQL fragment (for keywords, column names, etc.).\"\"\"\n        self._sql_parts.append(sql_fragment)\n    \n    def add_identifier(self, identifier: str) -> None:\n        \"\"\"Add a properly quoted identifier (table/column name).\"\"\"\n        if self.dialect == SQLDialect.POSTGRESQL:\n            self._sql_parts.append(f'\"{identifier}\"')\n        elif self.dialect == SQLDialect.MYSQL:\n            self._sql_parts.append(f'`{identifier}`')\n        else:\n            self._sql_parts.append(f'\"{identifier}\"')\n    \n    def build(self) -> tuple[str, List[Any]]:\n        \"\"\"Return the SQL string and parameter values in correct order.\"\"\"\n        sql = \" \".join(self._sql_parts)\n        param_values = [p.value for p in self._parameters]\n        return sql, param_values\n    \n    def clear(self) -> None:\n        \"\"\"Reset the builder for reuse.\"\"\"\n        self._parameters.clear()\n        self._sql_parts.clear()\n        self._param_counter = 0\n```\n\n**D. Core Logic Skeleton Code:**\n\nMain compilation entry point with detailed TODOs:\n\n```python\n# graphql_engine/compiler/__init__.py\n\"\"\"GraphQL to SQL compiler main entry points.\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nfrom ..ast import Document, OperationDefinition, Field, SelectionSet\nfrom ..types import Schema, GraphQLType, ObjectType\nfrom ..reflection.metadata import TableMetadata, Relationship\nfrom .sql_builder import SQLBuilder, SQLDialect\n\ndef compile_to_sql(\n    schema: Schema,\n    document_ast: Document,\n    operation_name: Optional[str] = None,\n    variable_values: Optional[Dict[str, Any]] = None,\n    context: Optional[Dict[str, Any]] = None\n) -> Dict[str, Any]:\n    \"\"\"\n    Compile a GraphQL query to executable SQL.\n    \n    Args:\n        schema: Validated GraphQL schema with database metadata\n        document_ast: Parsed GraphQL query AST\n        operation_name: Name of operation to execute (if multiple in document)\n        variable_values: Values for GraphQL variables in the query\n        context: Execution context (database connection, etc.)\n    \n    Returns:\n        Dictionary with keys:\n        - sql: The parameterized SQL string\n        - parameters: List of parameter values to bind\n        - result_mapper: Function to map SQL results to GraphQL shape\n        - metadata: Compilation metadata for debugging\n    \"\"\"\n    # TODO 1: Select the target operation from document_ast.definitions\n    #   - If operation_name is None and there's exactly one operation, use it\n    #   - If operation_name is specified, find the matching operation\n    #   - Raise error if ambiguous or not found\n    \n    # TODO 2: Extract and validate variable values\n    #   - Merge provided variable_values with operation's variable defaults\n    #   - Validate types match variable definitions\n    #   - Create a dict of resolved variable values for substitution\n    \n    # TODO 3: Expand fragments in the selection set\n    #   - Gather all fragment definitions from the document\n    #   - Recursively replace fragment spreads with their actual selections\n    #   - Apply type conditions for inline fragments\n    \n    # TODO 4: Analyze the root field and identify the target database table\n    #   - Get the GraphQL root type from schema (query_type)\n    #   - Look up the table metadata associated with this GraphQL type\n    #   - Determine the primary key columns for ordering/pagination\n    \n    # TODO 5: Recursively analyze nested selections and build relationship paths\n    #   - For each field in the selection set, check if it's a relationship field\n    #   - Use schema reflection metadata to find foreign key relationships\n    #   - Build a tree of relationship paths from root to leaf fields\n    \n    # TODO 6: Generate JOIN clauses for relationship paths\n    #   - Determine optimal join order (filter early, minimize intermediate size)\n    #   - Choose JOIN type (INNER vs LEFT) based on field nullability\n    #   - Generate ON conditions using foreign key relationships\n    \n    # TODO 7: Build SELECT column list\n    #   - Map each GraphQL field to its database column\n    #   - Generate unique aliases for columns from joined tables\n    #   - Include any necessary type casts (timestamp → string, etc.)\n    \n    # TODO 8: Build WHERE clause from arguments\n    #   - Extract filter arguments from the root field\n    #   - Convert GraphQL filter operators to SQL conditions\n    #   - Handle nested object filters (author: { name: { like: ... } })\n    #   - Use parameter binding for all values\n    \n    # TODO 9: Apply sorting and pagination\n    #   - Parse orderBy arguments to ORDER BY clauses\n    #   - Handle cursor-based pagination (after/before arguments)\n    #   - Apply LIMIT based on first/last arguments with defaults\n    \n    # TODO 10: Generate the complete SQL statement\n    #   - Use SQLBuilder to safely construct the SQL\n    #   - Assemble: SELECT ... FROM ... JOIN ... WHERE ... ORDER BY ... LIMIT\n    #   - Get final SQL string and parameter list\n    \n    # TODO 11: Create result mapper function\n    #   - Analyze the selection tree structure\n    #   - Generate a function that transforms flat SQL rows to nested objects\n    #   - Handle field aliases and type coercion\n    \n    # TODO 12: Return compilation result\n    #   - Include SQL, parameters, mapper function, and metadata\n    #   - Add query plan information for debugging\n    \n    pass\n```\n\nJoin planning algorithm skeleton:\n\n```python\n# graphql_engine/compiler/join_planner.py\n\"\"\"Analyze relationships and plan optimal JOIN strategy.\"\"\"\n\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom dataclasses import dataclass\nfrom ..reflection.metadata import Relationship, TableMetadata\n\n@dataclass\nclass JoinPlan:\n    \"\"\"Represents a planned SQL JOIN.\"\"\"\n    left_table: str\n    right_table: str\n    join_type: str  # \"INNER\", \"LEFT\", \"LATERAL\"\n    on_conditions: List[Tuple[str, str]]  # [(left_column, right_column), ...]\n    relationship: Relationship\n    alias: Optional[str] = None\n\ndef plan_joins(\n    root_table: TableMetadata,\n    relationships: Dict[str, List[Relationship]],\n    selection_paths: List[List[str]]\n) -> List[JoinPlan]:\n    \"\"\"\n    Plan optimal JOIN order for accessing all tables in selection_paths.\n    \n    Args:\n        root_table: The starting table (GraphQL query root)\n        relationships: Dict mapping table names to their outgoing relationships\n        selection_paths: List of field paths like [\"user\", \"posts\", \"comments\"]\n    \n    Returns:\n        Ordered list of JoinPlan objects representing JOINs to execute\n    \"\"\"\n    # TODO 1: Identify all tables needed based on selection_paths\n    #   - Parse each path to determine which tables are accessed\n    #   - Build set of required tables beyond the root\n    \n    # TODO 2: Find relationship paths from root to each required table\n    #   - Use breadth-first search through relationship graph\n    #   - Record the shortest path to each table\n    #   - Handle multiple possible paths (choose based on cardinality)\n    \n    # TODO 3: Determine optimal join order\n    #   - Start with root table\n    #   - Add tables in order of increasing estimated row count (if metadata available)\n    #   - Apply filters early: tables with WHERE conditions join earlier\n    #   - Avoid cartesian products: ensure each JOIN has a condition\n    \n    # TODO 4: Determine JOIN type for each relationship\n    #   - Use INNER JOIN for non-nullable relationships (GraphQL field is NonNull)\n    #   - Use LEFT JOIN for nullable relationships\n    #   - Consider LATERAL JOIN for one-to-many with per-row limits/filters\n    \n    # TODO 5: Generate ON conditions for each JOIN\n    #   - Use foreign key column mappings from Relationship objects\n    #   - For composite keys, multiple equality conditions\n    #   - For self-referential relationships, use table aliases\n    \n    # TODO 6: Return ordered list of JoinPlan objects\n    pass\n```\n\n**E. Language-Specific Hints (Python):**\n\n- **Parameter Binding:** Use `%s` placeholders for MySQL, `?` for SQLite, `$1`, `$2` for PostgreSQL. Python's DB-API handles the differences.\n- **Type Conversion:** For database-specific types, use SQL CAST: `CAST(column AS TEXT)` or Python-side conversion in the result mapper.\n- **Connection Management:** Use connection pooling for production. For learning, simple connection-per-query is fine.\n- **Async Support:** Consider `asyncpg` for PostgreSQL with async/await pattern if implementing async GraphQL execution.\n- **SQL Injection Prevention:** Never use f-strings or `%` formatting with user input. Always use parameter binding.\n\n**F. Milestone Checkpoint:**\n\n**What to Test:**\n1. **Basic Field Selection:** `{ users { id name } }` → `SELECT id, name FROM users`\n2. **Nested Relationship:** `{ users { posts { title } } }` → SQL with JOIN between users and posts\n3. **Filter Arguments:** `{ users(where: { status: { eq: \"ACTIVE\" } }) { id } }` → `WHERE status = $1`\n4. **Pagination:** `{ users(first: 10, after: \"cursor\") { id } }` → `LIMIT 10 OFFSET ...`\n5. **Parameter Binding:** Verify no raw values in SQL, all use placeholders\n\n**Expected Output:**\n```python\n# Example test case\nresult = compile_to_sql(schema, parse_query(\"{ users { id name } }\"))\nprint(result[\"sql\"])\n# Expected: SELECT id, name FROM users\nprint(result[\"parameters\"])\n# Expected: [] (empty list for simple query)\n\n# With filter\nresult = compile_to_sql(schema, parse_query(\n    '{ users(where: { id: { eq: 123 } }) { name } }'\n))\nprint(result[\"sql\"])\n# Expected: SELECT name FROM users WHERE id = $1\nprint(result[\"parameters\"])\n# Expected: [123]\n```\n\n**Verification Steps:**\n1. Run unit tests: `python -m pytest graphql_engine/compiler/tests/ -v`\n2. Test with actual database: Execute generated SQL against test database, verify results match GraphQL expectation\n3. Check for N+1: Use query logging to ensure nested fields don't cause additional queries\n4. Security check: Attempt SQL injection through GraphQL variables, verify it's blocked\n\n**Signs Something is Wrong:**\n- ❌ SQL contains literal values instead of placeholders\n- ❌ JOINs without ON clauses (cartesian product risk)\n- ❌ Missing LIMIT on list fields (unbounded queries)\n- ❌ Incorrect null handling (LEFT JOIN needed but using INNER)\n- ❌ Type errors: database numbers returned as strings to GraphQL\n\n**Debugging Approach:**\n1. **Log generated SQL:** Add debug logging to see exactly what SQL is produced\n2. **EXPLAIN plans:** Run `EXPLAIN ANALYZE` on generated SQL to check performance\n3. **AST visualization:** Print the GraphQL AST to understand the selection structure\n4. **Step-by-step compilation:** Test each compilation phase independently\n\n---\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** This section spans all five milestones, showing how the individual components connect to form a complete system. It illustrates the data transformations from GraphQL string to database query and back, and how schema reflection integrates with the type system.\n\nUnderstanding how components interact is crucial for seeing the system as more than isolated parts. This section maps the journey of a GraphQL query through the engine, reveals how the database schema becomes a GraphQL type system, and details the precise data structures exchanged between components. Think of it as following a package through a logistics network: we trace its path, document its transformations at each hub, and understand the routing decisions that determine its final delivery.\n\n### Happy Path: Query Execution Flow\n\nThe happy path represents a successful GraphQL query execution from HTTP request to JSON response. This flow integrates components from Milestones 1, 2, 3, and 5, demonstrating how parsed queries become execution plans and finally database results.\n\n> **Mental Model: Assembly Line with Quality Control**  \n> Imagine an automotive assembly line. A raw query (sheet metal) enters the factory. The parser (stamping press) shapes it into a structured AST (car frame). The type system (quality inspection) validates the frame against blueprints. The SQL compiler (robot arm) welds on the engine and wheels (SQL generation). The execution engine (final assembly) installs the interior (resolves fields) and the database (engine) provides power. At each station, defects are caught and flagged, but the line continues for other cars (fields).\n\nThe end-to-end flow follows this sequence, which you can visualize in ![End-to-End Data Flow Diagram](./diagrams/data-flow-end-to-end.svg):\n\n**Step 1: HTTP Request Ingestion**\nThe process begins when an HTTP server (not part of our core engine) receives a POST request containing a GraphQL query string, optional variables, and an operation name. The server extracts these components and passes them to the engine's main entry point.\n\n**Step 2: Query Parsing (Milestone 1)**\nThe `parse_query` function is invoked with the query string. Internally, this triggers:\n1. **Lexical Analysis**: The `Tokenizer.tokenize()` method scans the string, producing a list of `Token` objects (names, punctuation, literals) with `Location` data.\n2. **Syntax Parsing**: The `Parser.parse_document()` method consumes the token stream using recursive descent, building a complete `Document` AST. This `Document` contains one or more `Definition` nodes (typically an `OperationDefinition`).\n\n| Transformation | Input Format | Output Format | Key Operation |\n|----------------|--------------|---------------|---------------|\n| Raw string | `\"query { user(id:1) { name } }\"` | `Document` with `OperationDefinition` | Tokenization and recursive descent parsing |\n\n**Step 3: Schema Preparation**\nThe engine obtains a `Schema` object. This can come from:\n- **Static definition**: Built programmatically using `create_schema()` with hand-defined types.\n- **Dynamic reflection**: Generated via `reflect_schema()` from a database (integration with Milestone 4).\nThe schema is already validated and ready for execution.\n\n**Step 4: Query Validation (Integrated with Execution)**\nBefore execution, the engine performs validation using the type system (Milestone 2). This happens implicitly during the execution preparation phase:\n1. The operation name (if provided) is used to select the correct `OperationDefinition` from the `Document`.\n2. Variable values are coerced to their defined types using `VariableDefinition` type references.\n3. The selection set is validated against the schema: fields must exist, arguments must be of correct type, fragments must be applicable.\nValidation failures produce `GraphQLError` objects and abort execution.\n\n**Step 5: SQL Compilation (Milestone 5)**\nFor queries against a reflected database schema, the `compile_to_sql` function transforms the validated operation into executable SQL:\n1. **Analysis**: The compiler analyzes the `Document` AST, identifying the root table from the query type and tracing nested selections through relationships.\n2. **Join Planning**: The `plan_joins` function determines the optimal JOIN order and type based on foreign key relationships in the `DatabaseMetadata`.\n3. **SQL Generation**: The compiler builds a `SQLQuery` object containing `SQLSelect` structures with JOINs, WHERE conditions from arguments, and ORDER BY/LIMIT from pagination arguments.\n4. **Parameter Binding**: All GraphQL arguments are converted to `SQLParameter` objects to prevent SQL injection.\n\nThis step produces a complete, parameterized SQL query ready for execution. You can see the detailed sequence in ![GraphQL to SQL Compilation Sequence](./diagrams/sql-compilation-sequence.svg).\n\n**Step 6: Database Execution**\nThe engine executes the generated SQL against the database connection:\n1. Parameter values are bound to the SQL placeholders.\n2. The query is sent to the database.\n3. Raw rows are returned as a list of dictionaries (or similar record format).\n\n**Step 7: Result Transformation and Field Resolution**\nThe execution engine (Milestone 3) processes the results:\n1. **Root Resolution**: For reflected queries, the root resolver uses a `result_mapper` function from the `SQLQuery` to transform flat SQL rows into nested structures matching the GraphQL selection shape.\n2. **Nested Field Resolution**: For fields not satisfied by the SQL JOINs (or for custom resolvers), the engine invokes resolver functions from the `GraphQLField` definitions.\n3. **Parallel Execution**: Sibling fields at the same level are resolved concurrently when independent.\n4. **Error Handling**: Field-level errors are captured as `GraphQLError` objects without aborting the entire query.\n5. **Null Propagation**: If a non-null field resolves to null or raises an error, the engine propagates null to the nearest nullable parent per GraphQL specification.\n\n**Step 8: Response Assembly**\nThe execution engine assembles the final `ExecutionResult`:\n1. The `data` field contains the fully resolved response tree.\n2. The `errors` field contains any `GraphQLError` objects collected during execution.\n3. The result is serialized to JSON by the HTTP layer and returned to the client.\n\nThe entire execution flow, showing resolver traversal and parallel branches, is depicted in ![Query Execution Flowchart](./diagrams/execution-flowchart.svg).\n\n> **Architecture Decision: Integrated vs. Separate Validation Phase**\n> - **Context**: GraphQL execution requires validation against the schema, but we must decide when this happens relative to parsing and execution.\n> - **Options Considered**:\n>   1. **Separate validation phase**: Parse → Validate → Execute (clear separation, catches errors early)\n>   2. **Integrated validation**: Parse → Execute with validation as first step (simpler control flow)\n>   3. **Lazy validation**: Validate only the parts of the query as they're executed (optimistic, complex error handling)\n> - **Decision**: Integrated validation (option 2)\n> - **Rationale**: The GraphQL spec defines validation as occurring before execution begins, not interleaved. A separate phase would require an additional traversal of the AST. By integrating validation as the first step of execution, we maintain clear separation conceptually while avoiding duplicate AST traversal. This aligns with reference implementations like graphql-js.\n> - **Consequences**: Validation errors prevent any resolver execution, which is correct spec behavior. The execution engine must handle validation errors as a special case before beginning resolver dispatch.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Separate validation phase | Clear separation of concerns, easier to test validation independently | Extra AST traversal overhead, more complex control flow | |\n| **Integrated validation** | **Single AST traversal, simpler control flow, matches reference implementations** | **Validation and execution logic coupled in same component** | **✓** |\n| Lazy validation | Could avoid validating unused fragments, potential performance gain | Complex error handling, violates spec requirement that validation occurs before execution | |\n\n### Schema Building and Reflection Flow\n\nSchema building can occur through two primary paths: static programmatic definition or dynamic reflection from a database. The reflection flow (Milestone 4) integrates deeply with the type system (Milestone 2) to auto-generate a complete GraphQL schema.\n\n> **Mental Model: Archaeological Excavation**  \n> Imagine discovering an ancient city buried underground. The reflection process is like the archaeological dig: you first survey the site (connect to database), then carefully uncover each structure (introspect tables), map the pathways between buildings (detect relationships), and finally produce a detailed model of the city (GraphQL schema) that people can explore without digging themselves.\n\nThe reflection process follows a structured algorithm:\n\n**Step 1: Connection and Metadata Extraction**\nThe `reflect_schema` function is called with database connection configuration and `ReflectionOptions`. It:\n1. Establishes a connection to the database using a `BaseIntrospector` adapter.\n2. Calls `get_database_metadata()` to retrieve `DatabaseMetadata` containing `TableMetadata` for each table and `ColumnMetadata` for each column.\n3. Optionally filters tables based on `include_tables`/`exclude_tables` patterns.\n\n**Step 2: Type Mapping**\nFor each table, the reflection engine:\n1. Creates an `ObjectType` with a name derived from the table name using the configured `NamingConvention`.\n2. For each column in `TableMetadata.columns`, uses `TypeMapper.map_column_type()` to convert the SQL data type to a `GraphQLType` (wrapped with `NonNullType` if `is_nullable` is false).\n3. Adds a `GraphQLField` for each column to the object type's fields dictionary.\n\n**Step 3: Relationship Detection**\nThe `RelationshipAnalyzer.analyze()` method processes foreign key constraints from the metadata:\n1. Identifies all foreign keys between tables.\n2. Determines cardinality (one-to-one, one-to-many) by checking uniqueness constraints.\n3. Creates `Relationship` objects linking source and target tables.\n4. For each relationship, adds appropriate fields to the GraphQL types:\n   - For one-to-many: adds a plural field (e.g., `posts`) to the \"one\" side returning a list of the \"many\" type\n   - For many-to-one: adds a singular field (e.g., `author`) to the \"many\" side returning the \"one\" type\n\n**Step 4: Root Query Type Construction**\nThe reflection engine builds the root `Query` type:\n1. For each table, adds a field to fetch a single record by primary key (e.g., `user(id: ID!)`).\n2. For each table, adds a plural field to fetch all records with optional filtering, pagination, and ordering (e.g., `users(where: UserFilter, limit: Int)`).\n3. Adds connection fields for Relay-style cursor pagination if configured.\n\n**Step 5: Mutation Type Construction (Optional)**\nIf `readonly` option is false, the engine builds a `Mutation` type:\n1. For each table, adds `create`, `update`, and `delete` mutations with appropriate input types.\n2. Input types (`InputObjectType`) are created from table columns, excluding computed or read-only columns.\n\n**Step 6: Schema Assembly and Validation**\nThe final step uses `create_schema()` to assemble the reflected types into a complete `Schema`:\n1. All generated types are collected in the `types` dictionary.\n2. The root `Query` and `Mutation` types are set.\n3. `validate_schema()` is called to ensure consistency (no circular references, valid interface implementations, etc.).\n\n**Step 7: Integration with Execution Engine**\nThe generated `Schema` is now indistinguishable from a manually defined one and can be used directly by the query execution engine. The reflection state transitions are shown in ![Schema Reflection State Machine](./diagrams/reflection-state-machine.svg).\n\n| Reflection Stage | Input | Output | Key Methods |\n|------------------|-------|--------|-------------|\n| Connection | Connection string, `ReflectionOptions` | Database connection | `BaseIntrospector.connect()` |\n| Metadata extraction | Database connection | `DatabaseMetadata` | `get_database_metadata()` |\n| Type mapping | `TableMetadata`, `ColumnMetadata` | `ObjectType` with field mappings | `TypeMapper.map_column_type()` |\n| Relationship detection | `DatabaseMetadata` | `Dict[str, List[Relationship]]` | `RelationshipAnalyzer.analyze()` |\n| Root type construction | All generated object types | `ObjectType` for Query and Mutation | Custom generation logic |\n| Schema assembly | All generated types | `Schema` | `create_schema()`, `validate_schema()` |\n\n> **Architecture Decision: Static vs. Dynamic Reflection**\n> - **Context**: We must decide when schema reflection occurs: at startup (static) or on-demand per request (dynamic).\n> - **Options Considered**:\n>   1. **Static reflection**: Reflect once at server startup, cache the schema\n>   2. **Dynamic reflection**: Reflect on every request or schema change\n>   3. **Hybrid approach**: Reflect at startup but watch for schema changes via database event notifications\n> - **Decision**: Static reflection with optional reload triggers\n> - **Rationale**: Database schemas change infrequently in production, and reflection requires expensive queries to information_schema. Static reflection provides predictable performance and allows schema validation at startup. We include a manual reload trigger for schema updates. This balances performance with flexibility.\n> - **Consequences**: Schema changes require server restart or manual reload. The server must handle connection pooling separately from reflection. This approach is used by both Hasura and PostGraphile in their default configurations.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Static reflection | **Fast query execution, startup validation catches errors early** | **Schema changes require restart/reload** | **✓** |\n| Dynamic reflection | Always current with database, no restart needed | Performance overhead on every request, complex caching needed | |\n| Hybrid approach | Best of both worlds when database supports events | Complex to implement, database-specific event systems | |\n\n### Message and Data Formats\n\nComponents communicate through well-defined data structures. These structures flow through the system, transforming at each stage. Understanding their exact shape is crucial for implementing the interfaces correctly.\n\n#### AST Nodes (Parser to Type System/Executor)\n\nThe parser produces a `Document` containing `Definition` nodes. These are read-only data structures passed to subsequent components.\n\n| Structure | Contained In | Purpose | Key Fields |\n|-----------|--------------|---------|------------|\n| `Document` | Output of `parse_query()` | Root container for all definitions in a GraphQL document | `definitions: List[Definition]` |\n| `OperationDefinition` | `Document.definitions` | A query, mutation, or subscription operation | `operation_type: str`, `selection_set: SelectionSet`, `variable_definitions: List[VariableDefinition]` |\n| `SelectionSet` | `OperationDefinition`, `Field` | A set of fields/fragments to be selected | `selections: List[Selection]` |\n| `Field` | `SelectionSet.selections` | A single field selection with arguments and sub-selections | `name: str`, `arguments: List[Argument]`, `selection_set: Optional[SelectionSet]` |\n| `FragmentDefinition` | `Document.definitions` | A reusable fragment definition | `name: str`, `type_condition: NamedType`, `selection_set: SelectionSet` |\n| `FragmentSpread` | `SelectionSet.selections` | A reference to a named fragment | `name: str`, `directives: List[Directive]` |\n| `VariableDefinition` | `OperationDefinition.variable_definitions` | Definition of a variable used in the operation | `variable: Variable`, `type: Type`, `default_value: Optional[Value]` |\n\n#### Type System Structures (Schema Building)\n\nThe type system components create and use these structures to represent the GraphQL schema:\n\n| Structure | Used By | Purpose | Key Fields |\n|-----------|---------|---------|------------|\n| `Schema` | All components | Complete GraphQL schema definition | `query_type: ObjectType`, `types: Dict[str, GraphQLType]`, `directives: Dict[str, GraphQLDirective]` |\n| `ObjectType` | Schema, Reflection | GraphQL object type with fields | `fields: Dict[str, GraphQLField]`, `interfaces: List[InterfaceType]` |\n| `GraphQLField` | `ObjectType.fields` | Definition of a single field on a type | `type: GraphQLType`, `args: Dict[str, GraphQLArgument]`, `resolve: Optional[Callable]` |\n| `InterfaceType` | Schema | GraphQL interface type | `fields: Dict[str, GraphQLField]`, `resolve_type: Optional[Callable]` |\n| `UnionType` | Schema | GraphQL union type | `types: List[ObjectType]`, `resolve_type: Optional[Callable]` |\n| `InputObjectType` | Schema | Input object type for arguments | `fields: Dict[str, GraphQLInputField]` |\n\n#### Execution State (Executor Internal)\n\nThe execution engine maintains state throughout query resolution:\n\n| Structure | Lifetime | Purpose | Key Fields |\n|-----------|----------|---------|------------|\n| `ExecutionContext` | Per query execution | Tracks all state during execution | `schema: Schema`, `document_ast: Document`, `variable_values: Dict[str, Any]`, `errors: List[GraphQLError]`, `data_loaders: Dict[str, DataLoader]`, `path: List[PathSegment]` |\n| `GraphQLError` | Error occurrence to response | Represents an error in query execution | `message: str`, `locations: List[Location]`, `path: List[PathSegment]`, `extensions: Dict[str, Any]` |\n| `DataLoader` | Per request or context | Batches and caches data fetching calls | `batch_load_fn: Callable`, `cache: Dict`, `queue: List`, `max_batch_size: int` |\n| `ExecutionResult` | End of execution | Final result returned to caller | `data: Optional[Dict]`, `errors: List[GraphQLError]`, `extensions: Dict[str, Any]` |\n\n#### SQL Intermediate Representation (Compiler to Database)\n\nThe SQL compiler produces intermediate structures that bridge GraphQL and SQL:\n\n| Structure | Produced By | Consumed By | Purpose |\n|-----------|-------------|-------------|---------|\n| `SQLQuery` | `compile_to_sql()` | Database executor | Complete executable SQL query with metadata | `root_select: SQLSelect`, `nested_selects: List[SQLSelect]`, `parameters: List[SQLParameter]`, `result_mapper: Optional[Callable]` |\n| `SQLSelect` | SQL generation | `SQLQuery` | A single SELECT statement component | `from_table: SQLTable`, `joins: List[SQLJoin]`, `where: Optional[SQLExpression]`, `columns: List[SQLColumn]` |\n| `SQLJoin` | Join planning | `SQLSelect.joins` | A JOIN between two tables | `type: str`, `table: SQLTable`, `on: SQLExpression` |\n| `SQLExpression` | WHERE/ON clause generation | `SQLSelect.where`, `SQLJoin.on` | A condition expression | `kind: str`, `operator: Optional[str]`, `left: Optional[SQLExpression]`, `right: Optional[SQLExpression]`, `value: Any` |\n| `SQLParameter` | Parameter binding | Database execution | A bound parameter value | `name: str`, `value: Any`, `type: str` |\n\n#### Database Metadata (Reflection Internal)\n\nThe reflection engine uses these structures to represent database schema information:\n\n| Structure | Source | Purpose | Key Fields |\n|-----------|--------|---------|------------|\n| `DatabaseMetadata` | `get_database_metadata()` | Complete database schema snapshot | `tables: Dict[str, TableMetadata]`, `enums: Dict[str, List[str]]`, `version: str` |\n| `TableMetadata` | Database introspection | Metadata for a single table | `name: str`, `schema: str`, `columns: List[ColumnMetadata]`, `primary_key_columns: List[str]`, `foreign_keys: List[Dict[str, Any]]` |\n| `ColumnMetadata` | Database introspection | Metadata for a single column | `name: str`, `data_type: str`, `is_nullable: bool`, `is_primary_key: bool`, `default_value: Optional[str]` |\n| `Relationship` | `RelationshipAnalyzer.analyze()` | A relationship between two tables | `source_table: str`, `target_table: str`, `relationship_type: str`, `source_columns: List[str]`, `target_columns: List[str]` |\n\n> **Key Insight: The SQL IR as a Bridge**  \n> The `SQLQuery` structure is the critical bridge between the GraphQL and SQL worlds. It contains both the executable SQL (as strings and parameters) and the metadata needed to transform flat SQL rows back into nested GraphQL responses. The `result_mapper` function is generated during compilation and understands how to reconstruct the hierarchical response from the denormalized JOIN results.\n\n#### Data Transformation Pipeline\n\nThe complete transformation pipeline shows how data evolves through the system:\n\n| Stage | Input | Output | Transformation |\n|-------|-------|--------|----------------|\n| 1. Lexing | GraphQL query string | `List[Token]` | Character grouping into lexical tokens |\n| 2. Parsing | `List[Token]` | `Document` AST | Recursive descent parsing builds tree structure |\n| 3. Validation | `Document` + `Schema` | Validated `Document` | Type checking, field existence, argument validation |\n| 4. SQL Compilation | `Document` + `Schema` + `DatabaseMetadata` | `SQLQuery` | AST analysis, join planning, SQL generation |\n| 5. Database Execution | `SQLQuery` | `List[Dict]` (rows) | Parameter binding, SQL execution, row fetching |\n| 6. Result Mapping | `List[Dict]` + `SQLQuery.result_mapper` | Nested data dict | Row denormalization, nesting reconstruction |\n| 7. Field Resolution | Nested data dict + `Schema` | Complete response tree | Resolver invocation, error collection, null propagation |\n| 8. Response Assembly | Response tree + errors | `ExecutionResult` | Formatting, error inclusion, extension addition |\n\n#### Component Interface Summary\n\nThe primary interfaces between components are defined by these key methods:\n\n| Method | From Component | To Component | Purpose |\n|--------|---------------|--------------|---------|\n| `parse_query(query_str)` | HTTP layer/executor | Parser | Convert query string to AST |\n| `create_schema(...)` | Application/reflection | Type system | Build validated schema from type definitions |\n| `reflect_schema(connection_config, options)` | Application | Reflection engine | Generate schema from database |\n| `execute_query(schema, document_ast, ...)` | HTTP layer | Execution engine | Execute query and return result |\n| `compile_to_sql(schema, document_ast, ...)` | Execution engine | SQL compiler | Generate SQL from GraphQL query |\n| `get_database_metadata(...)` | Reflection engine | Database introspector | Extract raw database schema information |\n\nThe component interactions are visualized in ![System Component Diagram](./diagrams/system-component-diagram.svg), showing how data flows between these interfaces.\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing the data flows and interactions described above. We'll focus on wiring the components together and creating the necessary integration points.\n\n#### Technology Recommendations\n\n| Integration Point | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| HTTP Server | Flask (Python) with synchronous execution | FastAPI (Python) with async/await support |\n| Database Connection Pooling | `psycopg2.pool.SimpleConnectionPool` (PostgreSQL) | `asyncpg` with built-in connection pool |\n| SQL Building | String concatenation with parameter placeholders | SQLAlchemy Core for dialect-aware SQL generation |\n| Result Caching | `functools.lru_cache` for schema reflection | Redis for distributed query result caching |\n\n#### Recommended File/Module Structure\n\nTo organize the interactions between components, create this directory structure:\n\n```\ngraphql_engine/\n├── __init__.py\n├── server.py                      # HTTP server integration\n├── parser/                        # Milestone 1\n│   ├── __init__.py\n│   ├── lexer.py                   # Tokenizer\n│   ├── parser.py                  # Parser, parse_query()\n│   └── ast.py                     # AST node classes\n├── type_system/                   # Milestone 2\n│   ├── __init__.py\n│   ├── schema.py                  # Schema, create_schema()\n│   ├── types.py                   # GraphQLType hierarchy\n│   ├── validation.py              # validate_schema()\n│   └── introspection.py           # Introspection query handling\n├── execution/                     # Milestone 3\n│   ├── __init__.py\n│   ├── executor.py                # execute_query(), ExecutionContext\n│   ├── resolvers.py               # Default resolvers\n│   ├── errors.py                  # GraphQLError\n│   └── dataloaders.py             # DataLoader implementation\n├── reflection/                    # Milestone 4\n│   ├── __init__.py\n│   ├── reflector.py               # reflect_schema()\n│   ├── introspectors.py           # BaseIntrospector implementations\n│   ├── type_mapper.py             # TypeMapper\n│   ├── relationship_analyzer.py   # RelationshipAnalyzer\n│   └── naming.py                  # NamingConvention utilities\n├── compilation/                   # Milestone 5\n│   ├── __init__.py\n│   ├── compiler.py                # compile_to_sql()\n│   ├── sql_builder.py             # SQLBuilder\n│   ├── join_planner.py            # plan_joins()\n│   └── ir.py                      # SQL IR classes\n└── integration.py                 # Main integration point combining all components\n```\n\n#### Infrastructure Starter Code\n\nHere's a complete HTTP server integration that wires the components together:\n\n```python\n# graphql_engine/server.py\nfrom flask import Flask, request, jsonify\nfrom graphql_engine.integration import GraphQLEngine\nimport logging\n\napp = Flask(__name__)\nengine = None\n\ndef create_app(database_url=None, schema=None):\n    \"\"\"Create and configure the Flask application with GraphQL engine.\"\"\"\n    global engine\n    \n    # Initialize the GraphQL engine\n    engine = GraphQLEngine()\n    \n    if database_url:\n        # Use database reflection for schema\n        engine.reflect_schema_from_database(database_url)\n    elif schema:\n        # Use provided schema\n        engine.set_schema(schema)\n    else:\n        # Use a minimal default schema for testing\n        engine.set_default_schema()\n    \n    return app\n\n@app.route('/graphql', methods=['POST'])\ndef graphql_endpoint():\n    \"\"\"Main GraphQL endpoint.\"\"\"\n    if engine is None:\n        return jsonify({'errors': [{'message': 'Engine not initialized'}]}), 500\n    \n    try:\n        # Extract GraphQL request from JSON body\n        data = request.get_json()\n        query = data.get('query')\n        variables = data.get('variables') or {}\n        operation_name = data.get('operationName')\n        \n        if not query:\n            return jsonify({'errors': [{'message': 'No query provided'}]}), 400\n        \n        # Execute the query\n        result = engine.execute(query, variables, operation_name)\n        \n        # Return the result as JSON\n        return jsonify(result)\n    \n    except Exception as e:\n        logging.exception(\"GraphQL execution error\")\n        return jsonify({\n            'errors': [{'message': str(e)}]\n        }), 500\n\n@app.route('/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return jsonify({'status': 'healthy'}), 200\n\nif __name__ == '__main__':\n    # For development: create app with database connection\n    import os\n    database_url = os.environ.get('DATABASE_URL', 'postgresql://localhost/test')\n    app = create_app(database_url)\n    app.run(debug=True)\n```\n\nAnd the main integration class that orchestrates component interactions:\n\n```python\n# graphql_engine/integration.py\nfrom typing import Optional, Dict, Any\nfrom graphql_engine.parser import parse_query\nfrom graphql_engine.type_system.schema import Schema, create_schema\nfrom graphql_engine.execution.executor import execute_query\nfrom graphql_engine.reflection.reflector import reflect_schema\nfrom graphql_engine.compilation.compiler import compile_to_sql\n\nclass GraphQLEngine:\n    \"\"\"Main integration point for all GraphQL engine components.\"\"\"\n    \n    def __init__(self):\n        self.schema: Optional[Schema] = None\n        self.database_connection = None\n        self.compilation_enabled = False\n        \n    def reflect_schema_from_database(self, connection_string: str, \n                                     options: Optional[Dict] = None):\n        \"\"\"Reflect schema from database and enable SQL compilation.\"\"\"\n        from graphql_engine.reflection.reflector import reflect_schema\n        \n        # Store connection for later use by compiler\n        self.database_connection = self._create_connection(connection_string)\n        \n        # Reflect schema from database\n        reflection_options = options or {}\n        self.schema = reflect_schema(self.database_connection, reflection_options)\n        \n        # Enable SQL compilation for this schema\n        self.compilation_enabled = True\n        \n        return self.schema\n    \n    def set_schema(self, schema: Schema):\n        \"\"\"Use a pre-defined schema (disables SQL compilation).\"\"\"\n        self.schema = schema\n        self.compilation_enabled = False\n    \n    def set_default_schema(self):\n        \"\"\"Create a minimal default schema for testing.\"\"\"\n        # Implementation creates a simple schema with a hello field\n        pass\n    \n    def execute(self, query: str, variables: Optional[Dict] = None, \n                operation_name: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Execute a GraphQL query end-to-end.\"\"\"\n        if not self.schema:\n            raise ValueError(\"No schema configured\")\n        \n        # Step 1: Parse the query\n        document_ast = parse_query(query)\n        \n        # Step 2: Compile to SQL if enabled\n        sql_query = None\n        if self.compilation_enabled and self.database_connection:\n            sql_query = compile_to_sql(\n                self.schema, \n                document_ast, \n                operation_name, \n                variables or {},\n                {'connection': self.database_connection}\n            )\n        \n        # Step 3: Execute the query\n        result = execute_query(\n            schema=self.schema,\n            document_ast=document_ast,\n            variable_values=variables,\n            operation_name=operation_name,\n            # Pass SQL query to execution context for use by resolvers\n            context_value={'sql_query': sql_query} if sql_query else None\n        )\n        \n        return {\n            'data': result.data,\n            'errors': [self._format_error(e) for e in result.errors] if result.errors else None\n        }\n    \n    def _create_connection(self, connection_string: str):\n        \"\"\"Create a database connection based on the connection string.\"\"\"\n        # Simplified implementation - in reality, use proper connection pooling\n        import psycopg2\n        return psycopg2.connect(connection_string)\n    \n    def _format_error(self, error):\n        \"\"\"Format a GraphQLError for JSON response.\"\"\"\n        return {\n            'message': error.message,\n            'locations': [{'line': loc.line, 'column': loc.column} \n                         for loc in error.locations] if error.locations else None,\n            'path': error.path\n        }\n```\n\n#### Core Logic Skeleton Code\n\nHere's the skeleton for the main execution flow integration:\n\n```python\n# graphql_engine/execution/executor.py\nfrom typing import Optional, Dict, Any\nfrom graphql_engine.parser.ast import Document\nfrom graphql_engine.type_system.schema import Schema\nfrom .errors import GraphQLError\nfrom .execution_context import ExecutionContext\n\nclass ExecutionResult:\n    \"\"\"Result of executing a GraphQL query.\"\"\"\n    def __init__(self, data: Optional[Dict] = None, errors: Optional[List[GraphQLError]] = None):\n        self.data = data\n        self.errors = errors or []\n\ndef execute_query(\n    schema: Schema,\n    document_ast: Document,\n    variable_values: Optional[Dict[str, Any]] = None,\n    operation_name: Optional[str] = None,\n    context_value: Any = None,\n    root_value: Any = None\n) -> ExecutionResult:\n    \"\"\"\n    Execute a GraphQL query against a schema.\n    \n    This is the main entry point for query execution, integrating parsing,\n    validation, and field resolution.\n    \n    Args:\n        schema: The GraphQL schema to execute against\n        document_ast: Parsed AST of the GraphQL query\n        variable_values: Values for variables defined in the query\n        operation_name: Name of the operation to execute if document contains multiple\n        context_value: Context object passed to all resolvers\n        root_value: Value passed to the root resolver\n    \n    Returns:\n        ExecutionResult containing data and/or errors\n    \"\"\"\n    # TODO 1: Validate that schema is properly configured (query_type exists)\n    # TODO 2: Extract the operation to execute from document_ast\n    #   - If operation_name is provided, find the operation with that name\n    #   - If only one operation exists and no name provided, use that one\n    #   - Otherwise, raise an error about ambiguous operation\n    # TODO 3: Validate variable values against variable definitions\n    #   - Coerce values to the defined types\n    #   - Apply default values where variables are not provided\n    # TODO 4: Create ExecutionContext\n    #   - Store schema, document_ast, variable_values, context_value, root_value\n    #   - Initialize empty errors list and data_loaders dict\n    # TODO 5: Validate the operation against the schema\n    #   - Check that all selected fields exist on their respective types\n    #   - Validate argument types match field definitions\n    #   - Verify fragments are used on compatible types\n    #   - If validation fails, collect errors and return early\n    # TODO 6: Execute the operation based on its type (query/mutation/subscription)\n    #   - For queries: execute selection set starting from root_value\n    #   - For mutations: execute serially (not in parallel)\n    # TODO 7: Build and return ExecutionResult with data and errors\n    \n    # For now, return a placeholder\n    return ExecutionResult(data=None, errors=[])\n```\n\nAnd for the SQL compilation integration:\n\n```python\n# graphql_engine/compilation/compiler.py\nfrom typing import Dict, Any, Optional\nfrom graphql_engine.parser.ast import Document\nfrom graphql_engine.type_system.schema import Schema\nfrom .ir import SQLQuery\n\ndef compile_to_sql(\n    schema: Schema,\n    document_ast: Document,\n    operation_name: Optional[str],\n    variable_values: Dict[str, Any],\n    context: Dict[str, Any]\n) -> SQLQuery:\n    \"\"\"\n    Compile a GraphQL query to an optimized SQL query.\n    \n    This is the main entry point for SQL compilation, integrating AST analysis,\n    join planning, and SQL generation.\n    \n    Args:\n        schema: The GraphQL schema (must be a reflected schema)\n        document_ast: Parsed AST of the GraphQL query\n        operation_name: Name of the operation to compile\n        variable_values: Values for variables used in the query\n        context: Execution context containing database connection and metadata\n    \n    Returns:\n        SQLQuery object containing executable SQL and parameters\n    \"\"\"\n    # TODO 1: Verify the schema is a reflected schema (has database metadata)\n    # TODO 2: Extract the operation to compile (similar to execute_query)\n    # TODO 3: Analyze the selection set to identify accessed tables and relationships\n    #   - Start from the root query type field (e.g., 'users', 'posts')\n    #   - Recursively traverse nested selections, mapping them to table relationships\n    #   - Build a list of selection paths: e.g., ['users', 'users.posts', 'users.posts.comments']\n    # TODO 4: Plan JOINs using plan_joins() function\n    #   - Determine optimal join order to avoid cartesian products\n    #   - Choose join types (INNER, LEFT) based on nullability\n    #   - Generate table aliases for self-joins or multiple joins to same table\n    # TODO 5: Generate SELECT clause for each table\n    #   - Include only columns corresponding to selected fields\n    #   - Generate column aliases that map back to field names\n    # TODO 6: Generate WHERE clause from GraphQL arguments\n    #   - Convert filter arguments to SQL conditions\n    #   - Handle comparison operators (eq, lt, gt, in, etc.)\n    #   - Bind parameters to prevent SQL injection\n    # TODO 7: Generate ORDER BY and LIMIT/OFFSET from pagination arguments\n    # TODO 8: Build SQLQuery object with all components\n    #   - Set root_select with main SELECT statement\n    #   - Add nested_selects for complex cases requiring subqueries\n    #   - Collect all parameters for binding\n    #   - Generate result_mapper function that transforms flat rows to nested structure\n    # TODO 9: Return the complete SQLQuery object\n    \n    # For now, return a placeholder\n    return SQLQuery(root_select=None, nested_selects=[], parameters=[])\n```\n\n#### Language-Specific Hints\n\n**Python-Specific Implementation Notes:**\n\n1. **Type Hints**: Use Python's type hints extensively for the data structures. This provides documentation and helps catch errors early:\n   ```python\n   from typing import List, Optional, Dict, Any, Union\n   \n   class Field(Node):\n       name: str\n       alias: Optional[str]\n       arguments: List[Argument]\n       directives: List[Directive]\n       selection_set: Optional[SelectionSet]\n   ```\n\n2. **Dataclasses**: Use `@dataclass` decorator for immutable data structures like AST nodes and metadata objects:\n   ```python\n   from dataclasses import dataclass\n   \n   @dataclass(frozen=True)\n   class Location:\n       line: int\n       column: int\n   ```\n\n3. **Async/Await**: For parallel field execution, use `asyncio.gather()` to resolve sibling fields concurrently:\n   ```python\n   import asyncio\n   \n   async def resolve_fields_concurrently(fields):\n       tasks = [resolve_field(field) for field in fields]\n       return await asyncio.gather(*tasks, return_exceptions=True)\n   ```\n\n4. **Connection Pooling**: Use context managers for database connections to ensure proper cleanup:\n   ```python\n   from contextlib import contextmanager\n   \n   @contextmanager\n   def get_connection():\n       conn = pool.getconn()\n       try:\n           yield conn\n       finally:\n           pool.putconn(conn)\n   ```\n\n#### Milestone Checkpoint\n\nAfter implementing the integration layer, verify the complete flow works:\n\n1. **Start the server**: Run `python -m graphql_engine.server` and ensure it starts without errors.\n\n2. **Test with a simple query**: Use curl or a GraphQL client to send a query:\n   ```bash\n   curl -X POST http://localhost:5000/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\": \"query { __schema { types { name } } }\"}'\n   ```\n   \n   Expected output should include introspection data with no errors.\n\n3. **Test database reflection**: Set a `DATABASE_URL` environment variable and restart. Send a query for a table that exists:\n   ```bash\n   curl -X POST http://localhost:5000/graphql \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"query\": \"query { users { id, name } }\"}'\n   ```\n   \n   Expected: Returns actual user data from the database or an empty array if table is empty.\n\n4. **Verify SQL generation**: Enable debug logging and check that SQL queries are being generated correctly. Look for log messages showing the generated SQL with parameter placeholders.\n\n**Signs of Problems:**\n- \"No schema configured\" error: The engine wasn't initialized properly\n- Parse errors in valid queries: Parser implementation issues\n- \"Field X doesn't exist\" when it does in database: Reflection naming issues\n- SQL syntax errors: SQL generation bugs, especially with JOINs\n- Missing nested data: Result mapper not reconstructing hierarchy correctly\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Query returns empty data but no error | SQL query returning no rows | Log the generated SQL and execute it manually against the database | Check table names, WHERE conditions, JOIN conditions |\n| Nested fields are null | Result mapper not reconstructing hierarchy | Print the raw SQL rows and the result mapper logic | Ensure result mapper groups child records under parent keys |\n| \"Cannot query field X on type Y\" | Reflection didn't create the field | Check if table/column was excluded by filters, or naming convention mismatch | Adjust reflection options, check naming conventions |\n| Database connection errors | Connection pool exhausted or credentials wrong | Check connection string, database permissions | Ensure connection pool size adequate, credentials correct |\n| Cartesian product (too many rows) | Missing JOIN conditions | Examine generated SQL JOIN clauses | Ensure every JOIN has an ON condition from foreign key |\n| Memory usage high with large queries | No LIMIT clause on root query | Check if pagination arguments are being applied | Add default limit for collection fields, implement cursor pagination |\n| \"Variable $var not defined\" | Variable parsing/validation issue | Check variable definitions in operation header | Ensure variable definitions are parsed and variables are passed |\n\nTo debug effectively:\n1. Enable detailed logging for all components\n2. Use the GraphiQL interface (if implemented) to see query validation\n3. Test SQL queries directly against the database\n4. Add `print()` statements in the result mapper to see transformation steps\n5. Use a visualizer for AST structure to understand query shape\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** This section spans all five milestones, addressing failure modes and special cases that arise throughout the entire GraphQL execution pipeline. Error handling is a critical cross-cutting concern that must be addressed consistently across parsing (Milestone 1), type validation (Milestone 2), execution (Milestone 3), database reflection (Milestone 4), and SQL compilation (Milestone 5).\n\n### Error Categories and Handling\n\nThink of error handling in a GraphQL engine as a **multi-layered safety net**—each layer catches different types of failures while allowing the system to continue operating when possible. Unlike traditional REST APIs where a single error often terminates the entire request, GraphQL's partial results model requires careful error propagation that preserves valid data while clearly indicating what went wrong.\n\nThe GraphQL specification defines specific error behaviors, but our implementation must also handle infrastructure failures (database connections, network issues) and implementation bugs. Each error category requires distinct detection strategies and recovery approaches.\n\n#### Error Classification and Handling Strategies\n\n| Error Category | Detection Strategy | Recovery Approach | User Visibility |\n|----------------|-------------------|------------------|-----------------|\n| **Parse Errors** (Milestone 1) | Lexer/parser token validation, grammar rule violations | Immediate termination with precise location info | Full error details (line, column, expected tokens) |\n| **Validation Errors** (Milestone 2) | Schema validation passes, query validation against schema | Early rejection before execution | Detailed error messages about schema violations |\n| **Execution Errors** (Milestone 3) | Resolver exceptions, type coercion failures, null violations | Partial execution with error propagation | Errors attached to specific fields in response |\n| **Database Errors** (Milestone 4, 5) | SQL execution failures, connection issues, constraint violations | Transaction rollback (if applicable), error categorization | Sanitized error messages (hide DB internals) |\n| **Resource Errors** (All) | Timeouts, memory limits, connection limits | Graceful degradation, circuit breaking | Generic service unavailable messages |\n\n#### Parse Error Handling\n\nParse errors occur when the GraphQL query string violates the language syntax. The parser must provide **actionable feedback** by pinpointing exactly where the syntax diverges from expectations.\n\n> **Decision: Parser Error Reporting**\n> - **Context**: Learners need detailed feedback to debug malformed queries, but overly technical error messages can be confusing.\n> - **Options Considered**:\n>   1. Simple \"syntax error\" messages with line numbers only\n>   2. Full parser state dumps (current token, expected tokens, parser stack)\n>   3. Human-readable messages with exact location and suggestions\n> - **Decision**: Option 3 with precise location tracking and clear expectations\n> - **Rationale**: Follows GraphQL spec requirements for error locations while being learner-friendly. The `Location` type in our data model provides the necessary tracking.\n> - **Consequences**: Requires maintaining accurate line/column tracking throughout lexing and parsing, but gives users exactly what they need to fix queries.\n\n| Parse Error Type | Detection Point | Error Message Format | Example |\n|------------------|-----------------|---------------------|---------|\n| **Unexpected Token** | Parser expecting specific token (e.g., `{` after field name) | `Syntax error at line X, column Y: Expected \"{\", found \"}\"` | `query { user(id: 1 }` (missing closing `)`) |\n| **Unterminated String** | Lexer reaches end of input without closing quote | `Syntax error at line X, column Y: Unterminated string` | `query { name: \"unclosed` |\n| **Invalid Number** | Lexer fails to convert character sequence to number | `Syntax error at line X, column Y: Invalid number \"12.3.4\"` | `query { value: 12.3.4 }` |\n| **Unknown Character** | Lexer encounters character outside valid token set | `Syntax error at line X, column Y: Unknown character \"@\"` | `query { field @unknown }` |\n\nThe parser must maintain a **parse stack** to provide context-aware error messages. For example, when encountering a syntax error inside a nested selection set, the error should indicate \"while parsing selection set of field 'user'\" to give context beyond just line/column numbers.\n\n#### Validation Error Handling\n\nValidation errors occur when a syntactically correct query violates schema rules. These are caught before execution to prevent runtime failures. The validation phase performs dozens of checks defined in the GraphQL specification.\n\n> **Decision: Validation Strictness**\n> - **Context**: Some validation rules are essential for correctness (like type compatibility), while others are warnings (like deprecated field usage).\n> - **Options Considered**:\n>   1. Fail fast on first validation error\n>   2. Collect all validation errors before reporting\n>   3. Separate errors from warnings, continue execution with warnings\n> - **Decision**: Option 2 with all validation errors collected\n> - **Rationale**: GraphQL spec requires returning all validation errors. This gives users complete information to fix their query without multiple round trips.\n> - **Consequences**: More complex validation implementation that must continue after encountering errors, but provides better developer experience.\n\n| Validation Rule Category | Example Checks | Error Message Pattern |\n|-------------------------|----------------|----------------------|\n| **Type Compatibility** | Field type matches argument type, return type matches selection | `Field \"age\" of type \"String\" cannot represent non-string value: 42` |\n| **Field Existence** | Requested field exists on type, arguments exist | `Cannot query field \"email\" on type \"User\". Did you mean \"name\"?` |\n| **Fragment Validation** | Fragment type conditions are valid, spreads are possible | `Fragment \"UserFields\" cannot be spread here as object of type \"Post\" can never be of type \"User\"` |\n| **Variable Validation** | Variables match defined types, required variables provided | `Variable \"$id\" of type \"Int!\" is required but not provided` |\n| **Operation Validation** | Single operation when unnamed, operation names unique | `This operation is named \"GetUser\" but no operation name was provided` |\n\nValidation should implement the **visitor pattern** to traverse the AST once while running multiple validation rules. Each rule is a separate function that can add errors to a shared collection without stopping the traversal.\n\n#### Execution Error Handling\n\nExecution errors occur during resolver execution and represent the most complex error handling scenario. GraphQL's **partial results** model means fields can fail independently, and the engine must decide how to propagate these failures.\n\n**Mental Model: The Fault-Tolerant Assembly Line**\nImagine an assembly line where each station (resolver) processes parts of a product (data). If one station fails, we don't throw away the entire product—we mark that specific part as defective and continue assembling the rest. The final product has some missing parts, but we clearly label which ones failed and why.\n\n| Execution Error Type | Detection Mechanism | Null Propagation Rule | Error Collection |\n|---------------------|-------------------|----------------------|-----------------|\n| **Resolver Exception** | Try/catch around resolver invocation | If field is non-null (`Type!`), propagate to parent | Add to `GraphQLError` list with path |\n| **Type Coercion Error** | Value validation during argument/result conversion | Follows same rules as resolver errors | Add to `GraphQLError` list with path |\n| **Authorization Error** | Context validation in resolvers | Typically treat as resolver exception | May include extensions with auth details |\n| **Resource Limit Error** | Timeout detection, memory monitoring | Terminate entire execution | Single error at root level |\n\nThe key challenge is **null propagation**: when a non-null field (`String!`) resolves to null or throws an error, the entire parent field becomes null (if nullable) or continues bubbling up. This follows the GraphQL spec's \"fail fast\" rule for non-null fields.\n\n**Execution error handling algorithm:**\n1. When a resolver throws an exception, catch it immediately\n2. Create a `GraphQLError` with the exception message, current field path (`[\"users\", 0, \"email\"]`), and location from AST\n3. If the field's return type is non-null (`Type!`):\n   - Set the field's resolved value to `None` (null)\n   - Mark the parent field as \"contains null from non-null child\"\n4. If the parent field is also non-null, repeat step 3 recursively\n5. If the field is nullable (`Type` or `[Type]`):\n   - Set the field's resolved value to `None`\n   - Continue executing sibling fields\n6. Add the error to `ExecutionContext.errors` list for inclusion in final response\n\n#### Database Error Handling\n\nDatabase errors bridge Milestone 4 (reflection) and Milestone 5 (SQL compilation). These errors come from the underlying database system and must be sanitized before exposing to users.\n\n> **Decision: Database Error Sanitization**\n> - **Context**: Raw database errors expose internal details (table names, constraint names, SQL snippets) that are security risks and confusing to GraphQL API consumers.\n> - **Options Considered**:\n>   1. Pass through raw database errors (maximum debugging info, maximum risk)\n>   2. Completely generic errors (\"Database error occurred\")\n>   3. Categorized errors with sanitized messages\n> - **Decision**: Option 3 with error categorization and safe messaging\n> - **Rationale**: Balances debuggability (developers need to know what went wrong) with security (don't leak schema details). Different error categories suggest different fixes.\n> - **Consequences**: Requires parsing database error messages (which vary by database vendor) and mapping to safe categories.\n\n| Database Error Category | Detection Pattern | Sanitized Message | Internal Logging |\n|------------------------|------------------|-------------------|------------------|\n| **Connection Errors** | Network timeout, authentication failure | \"Unable to connect to database\" | Full connection string (without password), network details |\n| **Constraint Violations** | Unique constraint, foreign key violation | \"Data validation failed\" | Constraint name, table name, violating values |\n| **Syntax/Planning Errors** | Invalid SQL, missing columns | \"Query compilation error\" | Generated SQL, compilation context |\n| **Permission Errors** | Insufficient privileges on table/column | \"Access denied to requested resource\" | User/role, attempted operation |\n| **Resource Errors** | Too many connections, disk full | \"Database resource limit reached\" | Resource type, current usage |\n\nThe reflection component (Milestone 4) has its own state machine with explicit error states, as shown in the diagram:\n\n![Schema Reflection State Machine](./diagrams/reflection-state-machine.svg)\n\n**Reflection error recovery states:**\n| Current State | Error Event | Next State | Recovery Action |\n|--------------|-------------|------------|-----------------|\n| `connecting` | Connection timeout | `error` | Retry with exponential backoff (max 3 attempts) |\n| `introspecting_tables` | Permission denied on information_schema | `partial` | Continue with accessible tables only, log warning |\n| `detecting_relationships` | Circular reference detected | `ready` | Mark relationship as circular, generate appropriate GraphQL types |\n| `building_types` | Type mapping failure | `error` | Fall back to `String` type for problematic column, continue |\n\n#### Error Response Format\n\nAll errors eventually serialize to the standard GraphQL error response format:\n\n```json\n{\n  \"data\": {\n    \"user\": null,\n    \"posts\": [...]\n  },\n  \"errors\": [\n    {\n      \"message\": \"Cannot return null for non-nullable field User.email\",\n      \"path\": [\"user\", \"email\"],\n      \"locations\": [{\"line\": 5, \"column\": 7}],\n      \"extensions\": {\n        \"code\": \"NON_NULL_VIOLATION\",\n        \"timestamp\": \"2023-10-01T12:34:56Z\"\n      }\n    }\n  ]\n}\n```\n\nThe `extensions` field is where implementation-specific details can be added (error codes, timestamps, debug IDs for correlating with server logs).\n\n### Null and Optional Value Handling\n\nNull handling in GraphQL is **propagative rather than terminating**—a null value can \"bubble up\" through the response tree according to specific rules. This behavior fundamentally differs from most programming languages and requires careful implementation.\n\n**Mental Model: The Domino Chain**\nImagine a chain of dominoes where each domino represents a field in your GraphQL response. Non-null fields (`Type!`) are dominoes glued to their neighbors—if one falls (becomes null), it forces the next one to fall too. Nullable fields (`Type`) are unglued dominoes—they can fall independently without affecting others. List fields (`[Type]`) are racks holding multiple domino chains—one chain can fail without toppling the entire rack.\n\n#### Null Propagation Rules\n\n| Type Wrapper | Null Source | Propagation Behavior | Example |\n|-------------|-------------|---------------------|---------|\n| **Nullable field** (`User`) | Field resolver returns `None` | Field becomes `null` in response, siblings execute normally | `{ user(id: 999) { name } }` → `{\"data\": {\"user\": null}}` |\n| **Non-null field** (`User!`) | Field resolver returns `None` | Parent field becomes `null` (if nullable), continues upward | `{ user: user(id: 999) { name } }` → `{\"data\": {\"user\": null}}` |\n| **List of nullable** (`[User]`) | One element resolves to `None` | `null` appears in list at that position | `{ users: [{name: \"A\"}, null, {name: \"C\"}] }` |\n| **List of non-null** (`[User!]`) | One element resolves to `None` | Entire list becomes `null` | `{ users: null }` (if any user is null) |\n| **List of non-null in non-null** (`[User!]!`) | One element resolves to `None` | Parent field becomes `null` | `{ users: null }` (bubbles up) |\n\nThe implementation must track **null propagation chains** during execution. When a resolver returns `None`, check its return type:\n- If `NonNullType`: find the nearest nullable parent by walking up the type tree\n- If nullable: stop propagation, set value to `null`\n- If inside a `ListType`: check if list elements are non-null\n\n#### Database NULL to GraphQL Null Mapping\n\nDatabase NULL values present special challenges because different database types have different semantics for NULL:\n\n| Database NULL Context | GraphQL Representation | Default Behavior | Override Option |\n|----------------------|----------------------|------------------|----------------|\n| **Nullable column with NULL** | Field returns `null` | Direct mapping | Custom scalar with different null handling |\n| **Non-nullable column** (NOT NULL constraint) | Field is non-null (`Type!`) | Schema generation marks as non-null | Can be overridden in reflection options |\n| **LEFT JOIN missing row** | Nested object field returns `null` | Entire related object is `null` | Configuration to return empty object |\n| **Aggregate function on empty set** | `COUNT` returns 0, `AVG` returns `null` | Follow SQL semantics | Custom resolvers to normalize |\n\nThe reflection component (Milestone 4) must read `ColumnMetadata.is_nullable` to determine whether to generate nullable (`String`) or non-null (`String!`) GraphQL fields. However, there's a subtlety: a database column might be technically nullable but semantically required (like a `deleted_at` timestamp that's NULL for active records). The `ReflectionOptions` should allow overriding nullability decisions.\n\n#### Optional Arguments and Default Values\n\nGraphQL arguments can be optional with default values, which creates three possible states for each argument:\n\n| Argument State | GraphQL Syntax | Internal Representation | Behavior |\n|---------------|----------------|------------------------|----------|\n| **Provided with value** | `user(id: 5)` | `Argument.value = IntValue(5)` | Use provided value |\n| **Provided with null** | `user(id: null)` | `Argument.value = NullValue()` | Use explicit null (overrides default) |\n| **Not provided** | `user` | No argument in argument list | Use default value from schema |\n\nThe execution engine must distinguish between \"argument not provided\" and \"argument provided as null\" because they have different semantics. During argument coercion:\n1. Check if argument exists in the query's `arguments` list\n2. If missing: use `GraphQLArgument.default_value` from schema\n3. If present: coerce the provided value to expected type\n4. If value is `NullValue()`: pass `None` to resolver (even if default exists)\n\nThis behavior is critical for mutations where `null` might mean \"clear this field\" while absence means \"don't change this field.\"\n\n### Edge Case Scenarios\n\nEdge cases test the robustness of the GraphQL engine and often reveal bugs in less-traveled code paths. These scenarios require special handling beyond the normal execution flow.\n\n#### Empty Selections and Minimal Queries\n\nAn empty selection set might seem pointless, but it's valid GraphQL and must be handled gracefully. This often occurs in automated query generation or as a placeholder.\n\n**Empty selection handling algorithm:**\n1. During query validation: empty selection sets are allowed on object types (returns empty object)\n2. During execution: when encountering an empty selection set:\n   - Return empty dictionary `{}` for the field\n   - Still execute field-level directives if present\n   - Still validate field arguments\n3. For interfaces/unions: empty selection sets are invalid unless `__typename` is implicitly added\n\nThe minimal valid query `{ __typename }` (just the meta-field) should execute successfully and return `{\"data\": {\"__typename\": \"Query\"}}`.\n\n#### Circular References\n\nCircular references occur in two domains: GraphQL type definitions and database foreign key relationships. Each requires different handling strategies.\n\n**GraphQL type circularity:**\n```graphql\ntype User {\n  friends: [User!]!\n}\n\ntype Query {\n  user: User!\n}\n```\nThis is valid and requires the type system to handle recursive type references during:\n- Schema validation: must allow recursive types but detect infinite loops in input types\n- Query execution: must have depth limits to prevent infinite recursion\n- Introspection: must not get stuck in infinite loops when generating type descriptions\n\n**Database relationship circularity:**\n```sql\n-- Employee table with manager hierarchy\nCREATE TABLE employees (\n  id INT PRIMARY KEY,\n  name VARCHAR(100),\n  manager_id INT REFERENCES employees(id)\n);\n```\nThe reflection component must detect self-referential foreign keys and generate appropriate GraphQL types without infinite recursion. The generated schema should include:\n- `Employee` type with `manager: Employee` field (nullable)\n- Query field with argument to control traversal depth\n- Automatic depth limiting in generated resolvers\n\n**Circular reference detection algorithm (reflection):**\n1. Build directed graph of table relationships from foreign keys\n2. Run cycle detection (DFS with back edges)\n3. For each cycle found:\n   - Mark relationships in cycle with `is_self_referential = True`\n   - Generate GraphQL types with nullable back-references to break infinite traversal\n   - Add `max_depth` argument to collection fields with default limit (e.g., 10)\n4. During SQL compilation: apply `JOIN` limits based on query arguments\n\n#### Deeply Nested Queries\n\nDeeply nested queries can cause performance problems (exponential JOIN explosion) and even stack overflows in recursive execution. The engine must implement **reasonable limits**.\n\n| Limit Type | Default Value | Configuration | Enforcement Point |\n|------------|---------------|--------------|------------------|\n| **Query Depth** | 20 levels | `max_query_depth` in execution context | Query validation phase |\n| **Selection Width** | 50 fields per level | `max_fields_per_level` | Execution planning |\n| **List Size** | 1000 items | `max_list_size` in DataLoader | SQL LIMIT clause |\n| **JOIN Count** | 15 tables | `max_joins` in SQL compiler | JOIN planning |\n\nWhen limits are exceeded:\n1. During validation: reject query with clear error \"Query too deep (max 20 levels)\"\n2. During execution: truncate results (e.g., only return first 1000 list items)\n3. During SQL compilation: fail with suggestion to add more filters\n\nThe limits should be configurable per-request via `ExecutionContext` for different use cases (internal API vs. public API).\n\n#### Large Results and Pagination Edge Cases\n\nGraphQL doesn't have built-in pagination, but our auto-generated schemas include pagination arguments (`first`, `after`, `last`, `before`). These create several edge cases:\n\n| Pagination Edge Case | Behavior | Implementation Consideration |\n|---------------------|----------|----------------------------|\n| **Negative `first`/`last`** | Validation error | Must validate arguments before SQL generation |\n| **Both `first` and `last`** | Use `first` (GraphQL best practice) | Document precedence in generated schema comments |\n| **`after` cursor for deleted item** | Start from next available item | Cursors must be resilient to data deletion |\n| **Empty cursor string** | Treat as \"start from beginning\" | Validate cursor format before decoding |\n| **`before` without `last`** | Ignore `before` or error | Consistent policy needed |\n\nCursor-based pagination implementation must handle:\n- **Cursor encoding/decoding**: Base64-encoded JSON with table name, primary key values, sort values\n- **Cursor validation**: Ensure cursor is for the correct table and query\n- **Cursor stability**: Cursors must remain valid across data updates (use immutable columns or timestamps)\n\n#### Type System Edge Cases\n\nThe GraphQL type system has subtle edge cases that trip up implementations:\n\n| Edge Case | GraphQL Spec Rule | Implementation Strategy |\n|-----------|-------------------|------------------------|\n| **Interface field nullability** | Implementing field can be more strict (non-null) but not more loose | Validation must check interface implementation contravariantly |\n| **Union with overlapping types** | Types in union must be distinct object types | Schema validation ensures no type appears twice |\n| **Empty enum values** | Enum must have at least one value | Schema validation rejects empty enums |\n| **Input object default values** | Default values must be coercible to field type | Validate defaults during schema building |\n| **List of lists** (`[[Int]]`) | Valid type, must handle nested list coercion | Recursive type handling in execution |\n\n**Interface implementation validation algorithm:**\n1. For each interface field, find corresponding object field\n2. Check field type compatibility:\n   - If interface field is nullable (`T`), object field can be `T` or `T!`\n   - If interface field is non-null (`T!`), object field must be `T!`\n   - Covariant for object types: `Dog` can implement `Pet` if `Dog` is subtype\n3. Check argument compatibility (contravariant):\n   - Object field can omit optional interface arguments\n   - Object field arguments must have compatible types (more general)\n\n#### SQL Compilation Edge Cases\n\nThe GraphQL-to-SQL compiler faces unique edge cases when bridging the hierarchical and relational models:\n\n| Compilation Edge Case | Problem | Solution |\n|----------------------|---------|----------|\n| **Cartesian product from multiple one-to-many** | `{ users { posts tags } }` creates `users × posts × tags` | Use `LATERAL JOIN` or separate queries with batching |\n| **Diamond relationships** | `{ user { posts author } }` where `posts.author` is same as `user` | Deduplicate JOINs, use table aliases |\n| **Polymorphic relationships** | Interface/union types with different backing tables | Generate `CASE` statements or multiple queries |\n| **Missing JOIN condition** | Relationship exists in GraphQL schema but not in database (view) | Fall back to separate query or error |\n| **SQL dialect differences** | `LIMIT/OFFSET` vs `FETCH NEXT` vs `TOP` | Abstract behind `SQLDialect` enum |\n\n**Diamond relationship handling algorithm:**\n1. Detect when same table appears multiple times in join tree\n2. Generate unique table aliases (`posts`, `posts_2`)\n3. Ensure JOIN conditions use correct aliases\n4. In result mapper: map aliased columns back to correct object paths\n\n**Polymorphic relationship compilation:**\n```graphql\nquery {\n  search(query: \"graphql\") {\n    ... on Book { title author }\n    ... on Article { title url }\n  }\n}\n```\nCompiles to:\n```sql\n(SELECT 'Book' AS __typename, title, author FROM books WHERE title LIKE ?)\nUNION ALL\n(SELECT 'Article' AS __typename, title, url FROM articles WHERE title LIKE ?)\n```\nWith the result mapper using `__typename` to route to correct GraphQL types.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|--------------|-----------------|\n| **Error Tracking** | List of error dictionaries in execution context | Structured error tree with severity levels |\n| **Null Propagation** | Simple recursion with type checking | Memoization of nullability decisions |\n| **Database Error Parsing** | String matching on error messages | Database-specific error code mapping |\n| **Query Limits** | Hard-coded constants | Dynamic limits based on query complexity scoring |\n| **Cursor Pagination** | Offset-based pagination (simple) | Cursor-based with Base64 encoding (spec-compliant) |\n\n#### B. Recommended File/Module Structure\n\n```\ngraphql-engine/\n  errors/\n    __init__.py              # Error base classes and utilities\n    parse_errors.py          # Parse error definitions (Milestone 1)\n    validation_errors.py     # Validation error definitions (Milestone 2)\n    execution_errors.py      # Execution error definitions (Milestone 3)\n    database_errors.py       # Database error handling (Milestones 4-5)\n    null_handling.py         # Null propagation logic (Milestone 3)\n    limits.py                # Query depth/width/size limits\n  execution/\n    context.py               # ExecutionContext with errors list\n    executor.py              # Error-aware executor\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete Error Base Class:**\n```python\n# errors/__init__.py\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Dict, Any, Union\nfrom .types import Location, PathSegment\n\n@dataclass\nclass GraphQLError(Exception):\n    \"\"\"Base class for all GraphQL errors.\"\"\"\n    message: str\n    locations: List[Location] = field(default_factory=list)\n    path: List[PathSegment] = field(default_factory=list)\n    original_error: Optional[Exception] = None\n    extensions: Dict[str, Any] = field(default_factory=dict)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert error to GraphQL response format.\"\"\"\n        result = {\n            \"message\": self.message,\n            \"locations\": [{\"line\": loc.line, \"column\": loc.column} \n                         for loc in self.locations],\n        }\n        if self.path:\n            result[\"path\"] = self.path\n        if self.extensions:\n            result[\"extensions\"] = self.extensions\n        return result\n\nclass GraphQLSyntaxError(GraphQLError):\n    \"\"\"Syntax error during parsing.\"\"\"\n    pass\n\nclass GraphQLValidationError(GraphQLError):\n    \"\"\"Validation error against schema.\"\"\"\n    pass\n\nclass GraphQLExecutionError(GraphQLError):\n    \"\"\"Error during query execution.\"\"\"\n    pass\n\nclass GraphQLNonNullError(GraphQLExecutionError):\n    \"\"\"Special error for non-null field violations.\"\"\"\n    def __init__(self, field_name: str, path: List[PathSegment]):\n        super().__init__(\n            message=f\"Cannot return null for non-nullable field {field_name}\",\n            path=path,\n            extensions={\"code\": \"NON_NULL_VIOLATION\"}\n        )\n```\n\n**Complete Null Propagation Helper:**\n```python\n# errors/null_handling.py\nfrom typing import Any, Optional, Tuple\nfrom ..types import GraphQLType, NonNullType, ListType\n\ndef should_propagate_null(value: Any, field_type: GraphQLType) -> Tuple[bool, Optional[GraphQLType]]:\n    \"\"\"\n    Determine if null should propagate upward.\n    Returns (should_propagate, nullable_parent_type).\n    \"\"\"\n    if value is not None:\n        return (False, None)\n    \n    # Check type wrapper chain\n    current_type = field_type\n    type_stack = []\n    \n    # Unwrap type modifiers\n    while isinstance(current_type, (NonNullType, ListType)):\n        type_stack.append(current_type)\n        if isinstance(current_type, NonNullType):\n            # Found non-null wrapper\n            # If this is the outermost non-null, propagate\n            if not type_stack or all(not isinstance(t, NonNullType) for t in type_stack[:-1]):\n                return (True, None)\n        current_type = current_type.of_type\n    \n    return (False, None)\n\ndef apply_null_propagation(result: Dict[str, Any], error: GraphQLError) -> Dict[str, Any]:\n    \"\"\"\n    Apply null propagation rules to result dictionary.\n    \"\"\"\n    if not error.path:\n        return result\n    \n    # Navigate to the error location in the result\n    current = result\n    for i, segment in enumerate(error.path[:-1]):\n        if isinstance(segment, str):\n            current = current.get(segment, {})\n        elif isinstance(segment, int) and isinstance(current, list):\n            if segment < len(current):\n                current = current[segment]\n            else:\n                break\n    \n    # Set the field to None\n    last_segment = error.path[-1]\n    if isinstance(last_segment, str):\n        current[last_segment] = None\n    elif isinstance(last_segment, int) and isinstance(current, list):\n        if last_segment < len(current):\n            current[last_segment] = None\n    \n    return result\n```\n\n#### D. Core Logic Skeleton Code\n\n**Parse Error Collection:**\n```python\n# parser/parser.py\nclass Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.position = 0\n        self.errors: List[GraphQLSyntaxError] = []\n    \n    def parse_document(self) -> Document:\n        \"\"\"Parse complete GraphQL document with error collection.\"\"\"\n        # TODO 1: Initialize definitions list\n        # TODO 2: While not at EOF, parse definition\n        # TODO 3: If parse_definition returns None due to error, \n        #         skip to next definition using error recovery\n        # TODO 4: Implement error recovery: skip tokens until safe point\n        #         (next '{', '}', or top-level keyword)\n        # TODO 5: After parsing, if errors list not empty, raise first error\n        #         or collect all for validation phase\n        pass\n    \n    def expect(self, token_type: TokenType, value: Optional[str] = None) -> Token:\n        \"\"\"Expect specific token, record error if not found.\"\"\"\n        # TODO 1: Check if current token matches expected type/value\n        # TODO 2: If match, consume token and return it\n        # TODO 3: If no match, create GraphQLSyntaxError with:\n        #         - Current token's location\n        #         - Message: f\"Expected {token_type}, found {actual_token.value}\"\n        #         - Add to self.errors list\n        # TODO 4: Implement error recovery: return synthetic token\n        pass\n```\n\n**Execution Error Handling:**\n```python\n# execution/executor.py\nclass Executor:\n    def execute_field(self, parent_type: GraphQLType, field: Field, \n                     parent_value: Any, path: List[PathSegment]) -> Any:\n        \"\"\"Execute single field with error handling.\"\"\"\n        # TODO 1: Get field definition from schema\n        # TODO 2: Coerce arguments with try/except for coercion errors\n        # TODO 3: Get resolver function\n        # TODO 4: Try to execute resolver with try/except\n        # TODO 5: If resolver raises exception:\n        #         - Catch it and create GraphQLExecutionError\n        #         - Add error to context.errors list\n        #         - Check if field type is non-null using should_propagate_null\n        #         - If non-null, return None to trigger propagation\n        #         - If nullable, return None (field is null, error recorded)\n        # TODO 6: If resolver returns value, validate it matches field type\n        # TODO 7: Return resolved value\n        pass\n```\n\n**Database Error Sanitization:**\n```python\n# errors/database_errors.py\ndef sanitize_database_error(error: Exception, sql: Optional[str] = None) -> GraphQLError:\n    \"\"\"Convert database exception to safe GraphQL error.\"\"\"\n    # TODO 1: Check error type (psycopg2.Error, sqlite3.Error, etc.)\n    # TODO 2: Extract error message\n    # TODO 3: Categorize based on patterns:\n    #         - \"duplicate key\" -> constraint violation\n    #         - \"foreign key\" -> relationship error  \n    #         - \"syntax error\" -> SQL compilation error\n    #         - \"connection\" -> database unavailable\n    # TODO 4: Create sanitized message per category\n    # TODO 5: Include safe details in extensions (not in message)\n    # TODO 6: Return GraphQLExecutionError\n    pass\n```\n\n#### E. Python-Specific Hints\n\n1. **Use context managers for database connections**:\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef database_connection(config):\n    conn = None\n    try:\n        conn = create_connection(config)\n        yield conn\n    except DatabaseError as e:\n        raise sanitize_database_error(e)\n    finally:\n        if conn:\n            conn.close()\n```\n\n2. **Leverage Python's exception chaining**:\n```python\ntry:\n    result = resolver(parent, args, context)\nexcept Exception as e:\n    raise GraphQLExecutionError(\n        message=f\"Resolver failed: {str(e)}\",\n        original_error=e  # Preserve original for logging\n    ) from e\n```\n\n3. **Use `functools.lru_cache` for nullability checking**:\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef is_non_null_type(graphql_type: GraphQLType) -> bool:\n    \"\"\"Memoized check for non-null types.\"\"\"\n    if isinstance(graphql_type, NonNullType):\n        return True\n    if isinstance(graphql_type, ListType):\n        return is_non_null_type(graphql_type.of_type)\n    return False\n```\n\n#### F. Milestone Checkpoint\n\nAfter implementing error handling, verify with these test queries:\n\n1. **Parse error checkpoint**:\n   ```bash\n   python -m pytest tests/test_parser.py::test_syntax_errors -v\n   ```\n   Expected: All 10 syntax error test cases pass with precise location information.\n\n2. **Null propagation checkpoint**:\n   ```bash\n   python -c \"\n   from engine import execute_query, create_schema\n   schema = create_schema(...)\n   result = execute_query(schema, '{ user(id: 999) { name email } }')\n   print('Has errors:', bool(result.get('errors')))\n   print('User is null:', result.get('data', {}).get('user') is None)\n   \"\n   ```\n   Expected: When user 999 doesn't exist, `data.user` is `null` (not missing), and errors list contains appropriate error.\n\n3. **Database error checkpoint**:\n   ```bash\n   python -c \"\n   from engine import reflect_schema\n   # Use invalid connection string\n   try:\n       schema = reflect_schema('postgresql://invalid:invalid@localhost:9999/db')\n   except Exception as e:\n       print('Error type:', type(e).__name__)\n       print('Message contains password?', 'invalid' in str(e))\n   \"\n   ```\n   Expected: Error is raised, but error message doesn't contain password.\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Query returns `{\"data\": null}` with no errors** | Non-null field at root resolved to null | Check execution logs for which resolver returned null | Make resolver return value or change field to nullable |\n| **Error missing location information** | Location not passed when creating error | Add `locations=[field.loc]` to error creation | Ensure AST nodes have location data |\n| **Multiple identical errors** | Error propagating through list fields | Check if error is being added for each list element | Add error once at list level, not per element |\n| **Database error exposes table names** | Insufficient error sanitization | Test with malformed query that causes SQL error | Implement error categorization in `sanitize_database_error` |\n| **Deep recursion crashes** | No query depth limiting | Add depth counter to execution context | Implement `max_depth` validation |\n| **Cartesian product in results** | Missing JOIN conditions in SQL compilation | Log generated SQL and examine JOIN clauses | Ensure every JOIN has ON condition |\n\n\n## Debugging Guide\n\n> **Milestone(s):** This section spans all five milestones, providing practical troubleshooting guidance for the most common issues learners encounter while building their GraphQL execution engine. Effective debugging requires understanding how errors manifest across the entire pipeline from query parsing to SQL execution.\n\nDebugging a GraphQL engine involves tracing data through multiple transformation layers. When a query fails or returns unexpected results, the issue could originate in any component: a malformed AST from the parser, an inconsistent type definition, a resolver returning incorrect data, a mis-mapped database column, or an inefficient SQL query. This guide provides systematic approaches to isolate and fix the most common problems.\n\n### Common Bugs Table\n\nWhen building a GraphQL engine, certain patterns of mistakes appear repeatedly across implementations. The following table categorizes symptoms by component, helping you quickly identify where to look based on what you're observing.\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| **Parser throws \"Unexpected token\" error on valid GraphQL** | Tokenizer failing to recognize block strings, escaped strings, or unicode characters | 1. Check tokenizer output for the query fragment around the error location<br>2. Verify string literal handling for escape sequences (`\\n`, `\\u0041`)<br>3. Test with simplified query removing complex string values | Implement proper string tokenization with full escape sequence support per GraphQL spec section 2.9 |\n| **Query returns `null` for fields that should have data** | 1. Missing or misconfigured resolver function<br>2. Null propagation from non-null field error<br>3. Database column mismatch in SQL compilation | 1. Check execution logs for resolver calls<br>2. Examine error list in `ExecutionResult` for hidden null propagation errors<br>3. Verify SQL query actually returns data for the field | 1. Ensure resolvers are registered for all fields<br>2. Check non-null field resolvers don't return `None`<br>3. Verify column aliases in SQL match field names in result mapper |\n| **Nested relationship fields cause N+1 database queries** | SQL compiler generating separate queries per parent instead of JOINs | 1. Enable SQL logging and count queries for nested data<br>2. Check if `compile_to_sql` produces a single query with JOINs<br>3. Verify relationship detection found foreign keys | 1. Implement proper join planning in `plan_joins`<br>2. Use `LATERAL JOIN` or batched IN queries for one-to-many relationships<br>3. Ensure `RelationshipAnalyzer` detects all foreign key constraints |\n| **Introspection query fails or returns incomplete schema** | Missing or incorrect implementation of `__schema`, `__type` meta-fields | 1. Test introspection query against a known working GraphQL server<br>2. Verify `Schema` type includes introspection types in `types` dictionary<br>3. Check that meta-field resolvers return properly formatted data | 1. Implement `__Schema`, `__Type`, `__Field`, `__InputValue` types per GraphQL spec<br>2. Ensure introspection types are added to schema during `create_schema`<br>3. Verify meta-field resolvers handle all type kinds correctly |\n| **Mutation with variables receives \"Variable '$var' is not defined\"** | Parser not extracting variable definitions from operation header | 1. Inspect `OperationDefinition.variable_definitions` in parsed AST<br>2. Check variable definitions are being passed to execution context<br>3. Verify variable names match between definition and usage | 1. Ensure `parse_operation_definition` extracts `VariableDefinition` nodes<br>2. Pass `variable_values` from request to `execute_query`<br>3. Validate variable usage against definitions before execution |\n| **Database reflection creates types with wrong scalar mappings** | `TypeMapper.map_column_type` using incorrect type mappings for database dialect | 1. Check raw `ColumnMetadata.data_type` from database introspection<br>2. Verify `POSTGRES_MAPPINGS` (or dialect equivalent) contains the type<br>3. Test with explicit type mappings in `ReflectionOptions` | 1. Add missing type mappings to `TypeMapper`<br>2. Handle database-specific types (PostgreSQL `jsonb`, MySQL `TINYINT`)<br>3. Implement custom mapping registration for user-defined types |\n| **Fragment spreads cause \"Unknown fragment\" error** | Fragment definitions not being collected into `fragments` dictionary | 1. Check `Document.definitions` includes `FragmentDefinition` nodes<br>2. Verify fragment dictionary passed to `ExecutionContext`<br>3. Test with inline fragment (should work if named fragments fail) | 1. Ensure `parse_document` collects fragments into separate dictionary<br>2. Pass fragments to execution context: `ExecutionContext.fragments`<br>3. Validate fragment spreads reference defined fragments before execution |\n| **Query with nested lists returns incorrect nesting structure** | Result mapper flattening nested structures incorrectly | 1. Examine raw SQL result rows vs expected GraphQL response shape<br>2. Check `result_mapper` in `SQLQuery` properly reconstructs hierarchy<br>3. Verify join aliases preserve parent-child relationships | 1. Implement result mapper that uses join aliases to reconstruct tree<br>2. Test with simple one-to-many relationship first<br>3. Use temporary table aliases that encode the selection path |\n| **Directives are ignored during execution** | Directive parsing working but not applied during field resolution | 1. Check `Directive` nodes appear in AST for fields/fragments<br>2. Verify directive information reaches resolver via `ExecutionContext`<br>3. Test with `@skip` or `@include` directives first | 1. Implement directive evaluation before field resolution<br>2. Apply `@skip`/`@include` during selection set reduction<br>3. Pass directive arguments to resolver functions when needed |\n| **Non-null field error causes entire query to return `null`** | Incorrect null propagation - null bubbling too far up | 1. Check if error is in `ExecutionResult.errors` with path<br>2. Verify `should_propagate_null` correctly checks field type nullability<br>3. Test with nullable parent field (should return partial data) | 1. Implement null propagation per GraphQL spec: only bubble to nearest nullable parent<br>2. Use `apply_null_propagation` to set nulls in result selectively<br>3. Ensure non-null errors are recorded but don't abort entire execution |\n| **SQL query vulnerable to injection via GraphQL arguments** | Compiler using string concatenation instead of parameter binding | 1. Check generated SQL for raw values in WHERE clause instead of `$1`, `?`<br>2. Verify `SQLParameter` list is populated with argument values<br>3. Test with malicious string argument containing SQL metacharacters | 1. Use `SQLBuilder` with parameter placeholders for all user input<br>2. Ensure `compile_to_sql` returns both SQL string and parameters dictionary<br>3. Pass parameters separately to database driver's execute method |\n| **Self-referential relationship causes infinite recursion** | Relationship detection creating circular reference without depth limit | 1. Check `Relationship.is_self_referential` flag<br>2. Verify recursion depth limited in relationship traversal<br>3. Test with employee → manager → employee hierarchy | 1. Implement cycle detection in `RelationshipAnalyzer`<br>2. Add `max_relationship_depth` to `ReflectionOptions`<br>3. Use iterative rather than recursive traversal for relationship chains |\n| **Interface/union types return \"Abstract type must resolve to Object type\"** | Missing or incorrect `resolve_type` function | 1. Check `InterfaceType.resolve_type` or `UnionType.resolve_type` is set<br>2. Verify resolver returns actual `ObjectType` not type name string<br>3. Test with concrete type query first, then through interface | 1. Implement `resolve_type` that examines value and returns appropriate ObjectType<br>2. Ensure interface implementations properly registered in schema<br>3. Use `__typename` field in query to debug runtime type resolution |\n| **Pagination with cursors returns inconsistent results when data changes** | Using OFFSET/LIMIT instead of cursor-based pagination | 1. Check generated SQL for `OFFSET` clause<br>2. Verify cursor decoding/encoding uses stable row identifiers<br>3. Test with data insertion during pagination | 1. Implement cursor pagination with unique, stable sort keys<br>2. Use `ORDER BY` with unique columns and WHERE clause for cursors<br>3. Encode cursor as base64 of sort column values |\n\n### Debugging Techniques\n\nEffective debugging requires more than just reading error messages—it involves instrumenting the system to observe internal state transitions. These techniques help you visualize what's happening at each stage of the GraphQL execution pipeline.\n\n#### AST Visualization\n\n> **Mental Model:** **Family Tree Diagram** - Think of the AST as a family tree where the query document is the ancestor, operations are the main branches, selection sets are sub-branches, and individual fields are leaves. Visualizing this tree helps you verify the parser correctly understood the query structure.\n\nWhen the parser seems to be misinterpreting a query, the first step is to examine the AST it produced. A well-structured visualization reveals whether:\n- Selection sets are properly nested\n- Fragments are expanded correctly\n- Directives are attached to the right nodes\n- Variable definitions are captured\n\n**Diagnostic Approach:**\n1. **Print AST with Indentation:** Create a recursive function that prints each node type with increasing indentation for depth\n2. **Highlight Key Attributes:** For each `Field` node, display `name`, `alias`, and argument count\n3. **Track Locations:** Include `Location.line` and `Location.column` to correlate nodes with source text\n4. **Compare with Reference:** Use a known working GraphQL implementation (like GraphQL.js) to parse the same query and compare structures\n\n**What to Look For:**\n- Are all expected fields present in the selection set?\n- Do fragment spreads point to existing fragment definitions?\n- Are argument values of the correct type (e.g., `IntValue` vs `StringValue`)?\n- Do directives appear on the expected nodes with proper arguments?\n\n#### SQL Logging\n\n> **Mental Model:** **Kitchen Ticket System** - Imagine each GraphQL query generates a \"ticket\" that gets translated into cooking instructions (SQL). Logging the SQL shows you exactly what \"cooking instructions\" the kitchen is following, revealing whether the translation was correct.\n\nSQL logging is critical for debugging the query compilation and N+1 problems. By intercepting and examining the actual SQL sent to the database, you can identify:\n\n**Implementation Strategy:**\n1. **Interceptor Pattern:** Wrap database connection execute methods to log SQL with timestamps\n2. **Query Tagging:** Add a comment with GraphQL operation name to correlate SQL with GraphQL\n3. **Parameter Substitution:** Log the actual parameter values (not placeholders) for complete queries\n4. **Execution Metrics:** Capture query duration, row count, and explain plan results\n\n**Key Questions SQL Logging Answers:**\n- Is the compiler generating a single query with JOINs or multiple sequential queries?\n- Are WHERE conditions correctly parameterized to prevent injection?\n- Do pagination clauses (LIMIT/OFFSET) match GraphQL arguments?\n- Are unnecessary columns being selected (SELECT * vs specific columns)?\n\n**Sample Log Format:**\n```\n[GRAPHQL→SQL] Operation: GetUserWithPosts\nSQL: SELECT u.id, u.name, p.id, p.title FROM users u \n     LEFT JOIN posts p ON u.id = p.user_id WHERE u.id = $1\nParameters: [123]\nDuration: 4.2ms, Rows: 5\n```\n\n#### Resolver Tracing\n\n> **Mental Model:** **Function Call Stack Recording** - Imagine each resolver as a function call in a program. Tracing logs each call entry and exit with arguments and return values, creating a call graph that shows how data flows through resolvers.\n\nResolver tracing illuminates the execution phase, showing which resolvers are called, in what order, with what arguments, and what they return. This is particularly valuable for:\n\n**Tracing Implementation:**\n1. **Wrapper Functions:** Create a decorator/wrapper that logs resolver invocation\n2. **Context Propagation:** Include unique request ID in `ExecutionContext` to correlate logs\n3. **Timing Information:** Record start/end times to identify slow resolvers\n4. **Error Capture:** Log exceptions before they're converted to GraphQL errors\n\n**Trace Data to Capture:**\n- Resolver function name or field path\n- Parent value type and ID (if applicable)\n- Argument values received\n- Return value or exception\n- Duration of resolution\n- Whether resolution was batched via DataLoader\n\n**Diagnostic Patterns:**\n- **Missing Resolver Calls:** If a field returns null and its resolver never logged, the resolver wasn't registered\n- **Wrong Argument Values:** If arguments in trace don't match expected types, check variable coercion\n- **Multiple Calls for Same Data:** Indicates missing DataLoader batching\n- **Long Resolver Chains:** Deeply nested synchronous resolvers causing performance issues\n\n#### Type Inspection\n\n> **Mental Model:** **Building Blueprint Examination** - Imagine the type system as architectural blueprints for a building. Type inspection lets you examine each blueprint's details: room dimensions (field types), connections (interfaces), and structural rules (nullability constraints).\n\nWhen type-related errors occur (\"Expected type String, found Int\"), you need to examine the actual type definitions in the schema. Type inspection helps verify:\n\n**Inspection Tools:**\n1. **Schema Introspection Queries:** Use GraphQL's built-in introspection to query type definitions\n2. **Programmatic Type Dumping:** Write a function that prints all types with their fields and relationships\n3. **Validation Reports:** Run schema validation and examine all warnings/errors\n4. **Comparison with Source:** Compare runtime type definitions with source schema definitions\n\n**Critical Type Details to Verify:**\n- Field nullability (`String` vs `String!` vs `[String]!`)\n- Interface implementation completeness (all interface fields present)\n- Union type membership (all possible types registered)\n- Custom scalar serialization/parsing functions\n- Default values for input fields and arguments\n\n**Common Type Inspection Findings:**\n- **Circular Input Types:** Input object fields that reference their containing type\n- **Missing Interface Fields:** Object types claiming to implement interfaces but missing fields\n- **Type Name Collisions:** Two types with same name but different definitions\n- **Incorrect Type Modifiers:** List wrapped in NonNull instead of NonNull wrapped in List\n\n### Tools and Diagnostic Approaches\n\nBeyond manual inspection, several systematic approaches and tools can accelerate debugging. These approaches provide different perspectives on the system's behavior.\n\n#### Debug Logging with Context Correlation\n\n> **Mental Model:** **Forensic Timeline Reconstruction** - Imagine each request as a crime scene. Debug logging creates a detailed timeline of events with evidence tags (request IDs) that let you reconstruct exactly what happened during each stage of processing.\n\nStructured debug logging provides a comprehensive view of request processing across all components. The key is correlation: every log entry should include a request identifier that connects parser logs with executor logs with SQL logs.\n\n**Logging Strategy Components:**\n\n| Log Level | Purpose | Example Output |\n|-----------|---------|----------------|\n| DEBUG | Detailed internal state | `[DEBUG] Parser: Entering parse_selection_set at line 5, token: {` |\n| INFO | Major component transitions | `[INFO] Executor: Starting execution of operation 'GetUser'` |\n| WARN | Non-breaking issues | `[WARN] TypeMapper: Unknown database type 'jsonb', falling back to String` |\n| ERROR | Failures requiring attention | `[ERROR] SQLCompiler: Cartesian product detected in join plan` |\n\n**Context Correlation Implementation:**\n1. **Request ID Generation:** Create a unique ID at HTTP entry point\n2. **Context Passing:** Include request ID in `ExecutionContext.context_value`\n3. **Structured Logging:** Use JSON format with consistent fields: `timestamp`, `level`, `request_id`, `component`, `message`, `extra_data`\n4. **Log Aggregation:** Collect logs from all components into a single stream\n\n**Diagnostic Queries You Can Answer:**\n- How long did each phase (parse, validate, execute, compile SQL) take for a specific request?\n- Which component first encountered an error in a failing request?\n- What was the exact SQL generated for a query that returned unexpected data?\n- Which resolvers were called multiple times for the same data (N+1 pattern)?\n\n#### GraphiQL Integration for Interactive Testing\n\n> **Mental Model:** **Query Playground with X-Ray Vision** - GraphiQL is like a playground where you can try queries while wearing X-ray glasses that let you see not just the response, but also the execution path, timing, and internal state.\n\nGraphiQL (or GraphQL Playground) provides an interactive environment to test queries with built-in diagnostics. Integrating your engine with GraphiQL gives you:\n\n**Enhanced GraphiQL Features:**\n1. **Query Validation:** Real-time schema validation and error highlighting\n2. **Query History:** Compare current query with previous working queries\n3. **Variable Input:** Test with different variable values without modifying query text\n4. **Documentation Explorer:** Browse schema types and fields to verify introspection\n\n**Custom Extensions for Debugging:**\n1. **Execution Timing Extension:** Add query duration breakdown to response extensions\n2. **SQL Preview Extension:** Show generated SQL alongside GraphQL query\n3. **Resolver Trace Extension:** Include resolver call trace in response metadata\n4. **AST Viewer Extension:** Display parsed AST tree structure\n\n**Integration Steps:**\n1. **Add GraphiQL HTML Endpoint:** Serve GraphiQL interface at `/graphiql` or `/playground`\n2. **Implement Introspection:** Ensure `__schema` query works for documentation display\n3. **Add Custom Extensions:** Extend `ExecutionResult.extensions` with debug information\n4. **Enable Request Logging:** Log all GraphiQL queries for later analysis\n\n**Diagnostic Workflow with GraphiQL:**\n1. Start with a simple query that works in a known GraphQL server\n2. Gradually add complexity (nested fields, fragments, variables)\n3. Use query variables to test edge cases without modifying query structure\n4. Examine response extensions for timing, SQL, and trace data\n5. Compare with expected results from direct database queries\n\n#### Database Explain Plans for Query Optimization\n\n> **Mental Model:** **Car Engine Diagnostic Computer** - An EXPLAIN plan is like plugging a diagnostic computer into a car engine. It shows you exactly how the database plans to execute the query: which indexes it will use, join order, estimated costs, and potential bottlenecks.\n\nWhen SQL queries are slow or inefficient, database EXPLAIN plans provide visibility into the database's execution strategy. This is particularly important for the SQL compiler component to verify it's generating optimal queries.\n\n**EXPLAIN Plan Analysis Workflow:**\n\n1. **Capture Generated SQL:** Use SQL logging to get the exact query with parameters\n2. **Run EXPLAIN:** Execute `EXPLAIN (FORMAT JSON, ANALYZE) ...` on the query\n3. **Interpret Results:** Look for:\n   - **Seq Scans vs Index Scans:** Sequential table scans are expensive for large tables\n   - **Join Types:** Nested loops vs hash joins vs merge joins\n   - **Filter Estimates:** Whether row estimates match actual row counts\n   - **Sort Operations:** In-memory sorts vs disk spills\n   - **Total Cost:** Estimated execution cost in arbitrary units\n\n**Common SQL Compiler Issues Revealed by EXPLAIN:**\n- **Missing JOIN Conditions:** Causing Cartesian products (explode in row count)\n- **Inefficient WHERE Clauses:** Not using indexes due to function wrapping or type mismatches\n- **Unnecessary Columns:** Selecting columns not needed for response\n- **Suboptimal Join Order:** Joining large tables before filtering them\n\n**Integration with GraphQL Engine:**\n1. **Explain Endpoint:** Add `/explain` endpoint that runs EXPLAIN on generated SQL\n2. **Query Plan Caching:** Cache explain results for frequently generated query patterns\n3. **Performance Regression Detection:** Compare explain plans between engine versions\n4. **Index Recommendation:** Suggest database indexes based on frequent query patterns\n\n**Sample Diagnostic Process:**\n1. GraphQL query for users with their posts runs slowly\n2. SQL logging shows query with 3 LEFT JOINs\n3. EXPLAIN reveals nested loop join on large `posts` table\n4. Diagnosis: Missing index on `posts.user_id`\n5. Fix: Add index and verify new EXPLAIN plan uses index scan\n\n### Implementation Guidance\n\nWhile the previous sections focused on conceptual debugging approaches, this section provides concrete implementation strategies for building the diagnostic tools themselves.\n\n**Technology Recommendations:**\n\n| Diagnostic Need | Simple Option | Advanced Option |\n|-----------------|---------------|-----------------|\n| Logging | Python `logging` module with JSON formatter | Structured logging with `structlog` or `loguru` |\n| AST Visualization | Recursive print functions with indentation | Graphviz DOT generation for visual graphs |\n| SQL Interception | Database driver wrapper that logs before execute | SQL comment injection with query tagging |\n| Request Tracing | Manual request ID generation and passing | OpenTelemetry integration with distributed tracing |\n| Performance Profiling | `time.time()` manual instrumentation | `cProfile` for function-level profiling |\n\n**Recommended File Structure for Diagnostics:**\n\n```\ngraphql-engine/\n├── server.py                      # HTTP server with request ID middleware\n├── engine/\n│   ├── __init__.py\n│   ├── parser.py                  # Parser with debug logging\n│   ├── types.py                   # Type system with validation\n│   ├── executor.py                # Executor with resolver tracing\n│   ├── compiler.py                # SQL compiler with explain capability\n│   └── diagnostics/               # Diagnostic utilities\n│       ├── __init__.py\n│       ├── logger.py              # Structured logging setup\n│       ├── ast_printer.py         # AST visualization\n│       ├── sql_explainer.py       # EXPLAIN plan runner\n│       ├── tracer.py              # Request tracing\n│       └── profiler.py            # Performance profiling\n└── examples/\n    └── debug_queries.graphql      # Test queries for debugging\n```\n\n**Diagnostic Logger Implementation:**\n\n```python\n# engine/diagnostics/logger.py\nimport json\nimport logging\nimport uuid\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional\n\nclass DiagnosticLogger:\n    \"\"\"Structured logger for GraphQL engine diagnostics.\"\"\"\n    \n    def __init__(self, name: str, level: str = \"INFO\"):\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(getattr(logging, level))\n        \n        # JSON formatter for structured logs\n        class JSONFormatter(logging.Formatter):\n            def format(self, record: logging.LogRecord) -> str:\n                log_entry = {\n                    \"timestamp\": datetime.utcnow().isoformat() + \"Z\",\n                    \"level\": record.levelname,\n                    \"logger\": record.name,\n                    \"message\": record.getMessage(),\n                    \"request_id\": getattr(record, 'request_id', None),\n                    \"component\": getattr(record, 'component', None),\n                    \"path\": getattr(record, 'path', None),\n                    **getattr(record, 'extra', {})\n                }\n                return json.dumps(log_entry)\n        \n        handler = logging.StreamHandler()\n        handler.setFormatter(JSONFormatter())\n        self.logger.addHandler(handler)\n    \n    def log(self, level: str, message: str, \n            request_id: Optional[str] = None,\n            component: Optional[str] = None,\n            path: Optional[str] = None,\n            **extra: Any) -> None:\n        \"\"\"Log with structured context.\"\"\"\n        extra_record = {\n            'request_id': request_id,\n            'component': component,\n            'path': path,\n            'extra': extra\n        }\n        self.logger.log(getattr(logging, level), message, extra=extra_record)\n\n# Global diagnostic logger instance\ndiag_log = DiagnosticLogger(\"graphql-engine\")\n\n# Usage in components:\n# diag_log.log(\"INFO\", \"Parsing query\", \n#              request_id=ctx.request_id,\n#              component=\"parser\",\n#              query=query_str[:100])\n```\n\n**AST Printer Implementation:**\n\n```python\n# engine/diagnostics/ast_printer.py\nfrom typing import Any, List\nfrom ..parser import Document, Field, SelectionSet, Node\n\nclass ASTPrinter:\n    \"\"\"Prints AST in human-readable indented format.\"\"\"\n    \n    def print_document(self, doc: Document, indent: int = 0) -> str:\n        \"\"\"TODO 1: Iterate through doc.definitions and print each\"\"\"\n        # TODO 2: For OperationDefinition, print operation_type and name\n        # TODO 3: For FragmentDefinition, print fragment name and type_condition\n        # TODO 4: Call print_selection_set for each definition's selection_set\n        # TODO 5: Include Location.line and Location.column for error correlation\n        pass\n    \n    def print_selection_set(self, sel_set: SelectionSet, indent: int = 0) -> str:\n        \"\"\"TODO 1: Iterate through sel_set.selections\"\"\"\n        # TODO 2: For Field nodes, print name, alias, and argument count\n        # TODO 3: For FragmentSpread nodes, print ...name\n        # TODO 4: For InlineFragment nodes, print ... on TypeCondition\n        # TODO 5: Recursively print nested selection_sets with increased indent\n        pass\n    \n    def print_field(self, field: Field, indent: int = 0) -> str:\n        \"\"\"TODO 1: Print field name with optional alias (alias: name)\"\"\"\n        # TODO 2: Print arguments in parentheses if present\n        # TODO 3: Print directives starting with @ if present\n        # TODO 4: Recursively print selection_set if field has nested selections\n        pass\n```\n\n**SQL Explainer Implementation:**\n\n```python\n# engine/diagnostics/sql_explainer.py\nfrom typing import Dict, Any, Optional\nfrom ..compiler import SQLQuery\nimport psycopg2  # or appropriate database driver\n\nclass SQLExplainer:\n    \"\"\"Runs EXPLAIN on generated SQL queries.\"\"\"\n    \n    def __init__(self, db_connection):\n        self.db_connection = db_connection\n    \n    def explain(self, sql_query: SQLQuery, analyze: bool = False) -> Dict[str, Any]:\n        \"\"\"TODO 1: Generate EXPLAIN query from SQLQuery\"\"\"\n        # TODO 2: If analyze=True, add ANALYZE option (caution: executes query)\n        # TODO 3: Execute EXPLAIN using database connection\n        # TODO 4: Parse EXPLAIN output (JSON format if supported)\n        # TODO 5: Extract key metrics: total cost, seq scans, index scans\n        # TODO 6: Return structured explanation with warnings for inefficiencies\n        pass\n    \n    def find_inefficiencies(self, plan: Dict[str, Any]) -> List[str]:\n        \"\"\"TODO 1: Check for sequential scans on large tables\"\"\"\n        # TODO 2: Look for nested loop joins without indexes\n        # TODO 3: Detect sorts that spill to disk\n        # TODO 4: Identify underestimated row counts\n        # TODO 5: Return list of specific inefficiency descriptions\n        pass\n```\n\n**Milestone Debugging Checkpoints:**\n\nAfter completing each milestone, run these specific tests to verify correctness:\n\n**Milestone 1 (Parser):**\n- Run: `python -m pytest tests/test_parser.py -v`\n- Expected: All tests pass, including edge cases for strings with escapes\n- Manual test: Parse complex query with fragments, variables, directives\n- Diagnostic: Use `ASTPrinter` to visualize and compare with GraphQL.js output\n\n**Milestone 2 (Type System):**\n- Run: `python -m pytest tests/test_types.py -v`\n- Expected: Schema validation passes for valid schemas, fails for invalid ones\n- Manual test: Execute introspection query `{ __schema { types { name } } }`\n- Diagnostic: Verify all built-in types appear in introspection\n\n**Milestone 3 (Execution):**\n- Run: `python -m pytest tests/test_executor.py -v`\n- Expected: Queries return correct data, errors handled gracefully\n- Manual test: Execute query with null propagation and partial results\n- Diagnostic: Enable resolver tracing to verify call order and batching\n\n**Milestone 4 (Schema Reflection):**\n- Run: `python -m pytest tests/test_reflection.py -v`\n- Expected: Generated schema matches database structure\n- Manual test: Reflect a sample database with relationships\n- Diagnostic: Compare reflected GraphQL types with database metadata\n\n**Milestone 5 (SQL Compilation):**\n- Run: `python -m pytest tests/test_compiler.py -v`\n- Expected: Generated SQL is efficient and correct\n- Manual test: Compile nested query and run EXPLAIN to verify joins\n- Diagnostic: SQL logging shows single query with proper parameterization\n\n**Debugging Tips for Common Scenarios:**\n\n| Symptom | Quick Diagnosis | Immediate Action |\n|---------|-----------------|------------------|\n| All queries return \"Internal server error\" | Check application logs for uncaught exceptions | Add try-except around `execute_query` and log exception details |\n| Introspection works but queries fail | Likely resolver not registered for fields | Verify field resolvers attached during schema construction |\n| Query slow with deep nesting | Enable SQL logging, check for N+1 queries | Implement DataLoader batching for relationship fields |\n| Mutation arguments not received | Check variable definitions parsing | Debug `parse_operation_definition` for variable extraction |\n| Database type maps incorrectly | Examine `ColumnMetadata.data_type` raw value | Add custom mapping to `TypeMapper.register_custom_mapping` |\n\nRemember that debugging is iterative: make one change at a time, test thoroughly, and use the diagnostic tools to verify the fix actually addresses the root cause. The layered architecture means issues can cascade, so always trace problems back to their origin component.\n\n\n## Future Extensions\n\n> **Milestone(s):** This section spans all five milestones, looking beyond the core implementation to consider how the architecture accommodates evolution. While these features are explicitly out of scope for the initial implementation, the system has been designed with clear extension points for future development.\n\nThe current GraphQL engine provides a solid foundation for executing queries against relational databases, but its architecture deliberately leaves room for expansion. Designing for extensibility from the beginning ensures that future features can be added with minimal disruption to the core system. This section explores four high-value extension points—schema stitching, subscriptions, custom directives, and query caching—and explains how the current architecture accommodates them through careful abstraction boundaries, pluggable components, and thoughtful data model design.\n\n### Planned Extension Points\n\nFour major extension areas represent natural evolutions of the GraphQL engine that align with real-world GraphQL deployment patterns. Each builds upon the existing architecture while introducing new capabilities.\n\n#### Schema Stitching: Federating Multiple Data Sources\n\n**Mental Model: Mosaic Artist**\nThink of schema stitching as a mosaic artist who creates a unified picture from distinct pieces of colored glass. Each piece (individual GraphQL schema) has its own shape and color, but when arranged together with careful planning, they form a cohesive whole that appears as a single image to the viewer.\n\nSchema stitching allows the GraphQL engine to combine multiple GraphQL schemas—potentially from different databases, REST APIs, or other GraphQL services—into a single unified schema. This transforms the engine from a single-database query layer into a federated gateway that can aggregate data from multiple sources.\n\n**Extension Requirements:**\n- Schema composition mechanism that merges type definitions and resolves naming conflicts\n- Query planning that routes sub-queries to appropriate underlying services\n- Field resolver delegation that forwards requests to remote services with appropriate arguments\n- Error aggregation from multiple sources with proper source attribution\n\n**Implementation Approach:**\nThe system would extend the current `Schema` type with composition metadata and introduce a `SchemaComposer` component that:\n1. Validates schema compatibility (no type conflicts, consistent interface implementations)\n2. Creates merged type definitions with source service annotations\n3. Generates delegation resolvers that forward field requests to appropriate services\n4. Implements query planning to minimize remote calls and batch where possible\n\n**Architecture Decision Record: Schema Composition Strategy**\n> **Decision: Preserve Individual Schemas with Gateway Layer**\n> - **Context**: When combining multiple GraphQL schemas, we need to decide whether to merge them at the type definition level or keep them separate with a routing layer.\n> - **Options Considered**:\n>   1. **Deep Merge**: Combine all type definitions into a single monolithic schema, resolving conflicts through renaming or namespacing.\n>   2. **Gateway with Delegation**: Maintain separate schemas with a gateway layer that routes field resolutions to appropriate services.\n>   3. **Schema Extensions**: Use GraphQL schema extensions to add cross-service fields while keeping core schemas independent.\n> - **Decision**: Gateway with delegation, implemented as a separate `SchemaStitchingGateway` component.\n> - **Rationale**: This approach preserves service autonomy, allows independent schema evolution, and matches the microservices architecture pattern where each service owns its domain. The delegation model also enables progressive migration from single-database to federated queries.\n> - **Consequences**: Requires additional query planning complexity, introduces network latency for cross-service calls, but provides clear service boundaries and incremental adoption path.\n\n| Option | Pros | Cons | Selected? |\n|--------|------|------|-----------|\n| Deep Merge | Simple query execution, single schema validation | Breaks service autonomy, complex conflict resolution | No |\n| Gateway with Delegation | Service independence, incremental adoption | Query planning complexity, network overhead | **Yes** |\n| Schema Extensions | GraphQL-spec compliant, clean separation | Limited tooling support, complex implementation | No |\n\n#### Subscriptions: Real-Time Data Updates\n\n**Mental Model: Radio Broadcasting**\nThink of subscriptions as a radio broadcasting system where listeners tune into specific channels. The broadcaster (GraphQL engine) transmits updates only to those subscribed to particular data changes, without requiring continuous polling from listeners. Each subscription establishes a persistent connection over which data updates flow as they occur.\n\nSubscriptions extend the GraphQL engine beyond request-response to support real-time data updates through WebSocket or Server-Sent Events connections. This enables applications to receive live updates when database data changes, such as new chat messages, stock price changes, or collaborative editing events.\n\n**Extension Requirements:**\n- WebSocket or SSE transport layer for persistent bidirectional connections\n- Subscription operation parsing and validation in the parser\n- Pub/sub mechanism for broadcasting data changes to interested subscribers\n- Database change detection through triggers, polling, or database notifications\n- Subscription execution context distinct from query/mutation contexts\n\n**Implementation Approach:**\nThe system would extend the current architecture with:\n1. **Transport Layer**: WebSocket server that manages connection lifecycle and maps messages to subscription operations\n2. **Subscription Resolver Type**: New resolver signature that returns an async iterator/generator instead of a value\n3. **Event System**: Pub/sub system where database change events trigger subscription updates\n4. **Subscription Manager**: Tracks active subscriptions, manages cleanup, and handles fan-out to multiple clients\n\n| Subscription Component | Integration Point | Data Flow |\n|------------------------|-------------------|-----------|\n| WebSocketTransport | Extends HTTP server layer | Handles connection upgrade, message framing, and protocol negotiation |\n| SubscriptionParser | Extends GraphQL Parser (Component 1) | Adds subscription operation type validation and subscription-specific syntax |\n| SubscriptionExecutor | Extends Query Execution Engine (Component 3) | Executes subscription resolvers, returns async iterators, manages event mapping |\n| DatabaseChangeDetector | Integrates with Database Schema Reflection (Component 4) | Listens to database changes via triggers, LISTEN/NOTIFY, or change data capture |\n| SubscriptionRegistry | New standalone component | Maps database changes to active subscriptions, manages fan-out and cleanup |\n\n#### Custom Directives: Schema-Level Behavior Modification\n\n**Mental Model: Circuit Breaker Panel**\nThink of custom directives as circuit breakers in an electrical panel that can be flipped to modify how power flows through specific circuits. Each directive intercepts the normal execution flow at a specific point (field resolution, argument coercion, etc.) and can modify behavior—adding authentication checks, transforming output, logging, or implementing rate limiting—without changing the underlying resolver logic.\n\nCustom directives extend the GraphQL engine's ability to modify execution behavior at the schema level through declarative annotations. This enables cross-cutting concerns like authentication, authorization, caching, logging, and data transformation to be expressed directly in the schema definition language.\n\n**Extension Requirements:**\n- Directive definition and validation in the type system\n- Directive execution hooks at various points in the query lifecycle\n- Directive composition and ordering semantics\n- Directive argument processing and validation\n\n**Implementation Approach:**\nThe system would extend the current architecture with:\n1. **Directive Definition Language**: Extend `GraphQLDirective` type to support execution hooks\n2. **Directive Execution Pipeline**: Interceptors at parse, validate, and execute phases\n3. **Directive Registry**: Central registry of available directives with their implementation\n4. **Schema Transformation**: Apply directive semantics during schema building\n\n**Directive Execution Hook Points:**\n| Hook Point | Description | Use Cases |\n|------------|-------------|-----------|\n| `onSchema` | Applied to entire schema | Schema-level metadata, global rate limiting |\n| `onObjectType` | Applied to object type definitions | Type-level permissions, data masking rules |\n| `onFieldDefinition` | Applied to field definitions | Field-level authorization, cost calculation |\n| `onArgumentDefinition` | Applied to argument definitions | Input validation, sanitization |\n| `onFieldExecution` | Wraps field resolver execution | Caching, logging, timing, error handling |\n| `onQueryExecution` | Wraps entire query execution | Request logging, tracing, overall timeout |\n\n#### Query Caching: Performance Optimization Layer\n\n**Mental Model: Library Index System**\nThink of query caching as a library's card catalog system that remembers where to find frequently requested books. Instead of walking through the entire library (executing the full query) each time someone asks for popular books, the system maintains a quick-reference index (cache) that dramatically reduces lookup time for repeated requests with identical parameters.\n\nQuery caching adds a performance optimization layer that stores and reuses query results to reduce database load and improve response times. This includes both query result caching (storing complete GraphQL responses) and field-level caching (storing individual field values for reuse across queries).\n\n**Extension Requirements:**\n- Cache key generation from query AST, variables, and context\n- Cache storage backend abstraction (in-memory, Redis, memcached)\n- Cache invalidation strategies based on database mutations\n- Cache TTL management and stale-while-revalidate patterns\n- Partial query caching and result composition\n\n**Implementation Approach:**\nThe system would extend the current architecture with:\n1. **Cache Key Generator**: Creates deterministic cache keys from queries\n2. **Cache Layer Interface**: Abstract interface supporting multiple storage backends\n3. **Cache Interceptor**: Wraps execution engine to check cache before execution\n4. **Invalidation System**: Listens to mutations and invalidates affected cache entries\n\n**Cache Strategy Comparison:**\n| Strategy | Implementation Complexity | Cache Hit Rate | Invalidation Complexity | Best For |\n|----------|--------------------------|----------------|-------------------------|----------|\n| Full Query Caching | Low | Medium | High | Read-heavy workloads with limited query variation |\n| Field-Level Caching | High | High | Medium | Complex queries with overlapping field selections |\n| Compiled SQL Caching | Medium | High | Low | Database-heavy workloads with repeated query patterns |\n| Hybrid Approach | Very High | Very High | High | Production systems with mixed access patterns |\n\n> **Design Insight**: The choice between these caching strategies depends heavily on the access pattern. For GraphQL APIs with high query diversity, field-level caching often provides the best balance, while for APIs with repetitive query patterns (like dashboard applications), full query caching may be more effective.\n\n### Design Accommodations\n\nThe current architecture has been intentionally designed with specific patterns and abstractions that enable these future extensions without requiring fundamental redesign. These accommodations manifest as extension points, pluggable interfaces, and carefully isolated concerns.\n\n#### Extension Point Inventory\n\nThe following table catalogs the explicit extension points built into the current system design:\n\n| Extension Point | Location | Purpose | Enables Feature |\n|-----------------|----------|---------|-----------------|\n| `GraphQLDirective.execution_hooks` | `GraphQLDirective` type | Directive implementation hooks | Custom directives |\n| `Schema.builders` | `Schema` type | Schema transformation pipeline | Schema stitching, custom directives |\n| `Executor.middleware` | `ExecutionContext` | Execution interception | Custom directives, caching, logging |\n| `SQLCompiler.plugins` | `SQLBuilder` | SQL generation customization | Database-specific optimizations |\n| `TypeMapper.registry` | `TypeMapper` class | Custom type mappings | Extended database type support |\n| `Transport.protocols` | HTTP server layer | Alternative transport protocols | Subscriptions (WebSocket/SSE) |\n| `DataLoader.factory` | `ExecutionContext` | Custom batching strategies | Advanced N+1 optimization |\n| `ReflectionOptions.hooks` | `ReflectionOptions` | Schema generation customization | Complex relationship modeling |\n\n#### Abstract Interface Design\n\nEach major component exposes abstract interfaces that allow behavior extension through polymorphism rather than modification:\n\n**1. Transport Layer Abstraction:**\n```python\n# Current implementation supports only HTTP POST\n# Extended to support WebSocket and Server-Sent Events\nclass TransportProtocol(ABC):\n    @abstractmethod\n    async def handle_request(self, request) -> Response:\n        pass\n    \n    @abstractmethod\n    def supports_subscriptions(self) -> bool:\n        return False\n```\n\n**2. Cache Backend Abstraction:**\n```python\n# Prepared for caching layer addition\nclass CacheBackend(ABC):\n    @abstractmethod\n    async def get(self, key: str) -> Optional[Any]:\n        pass\n    \n    @abstractmethod\n    async def set(self, key: str, value: Any, ttl: Optional[int] = None):\n        pass\n    \n    @abstractmethod\n    async def invalidate_pattern(self, pattern: str):\n        pass\n```\n\n**3. Directive Execution Abstraction:**\n```python\n# Ready for directive system extension\nclass DirectiveVisitor(ABC):\n    @abstractmethod\n    def visit_field_definition(self, field: GraphQLField, directive: GraphQLDirective):\n        pass\n    \n    @abstractmethod  \n    def visit_argument_definition(self, arg: GraphQLArgument, directive: GraphQLDirective):\n        pass\n```\n\n#### Schema Evolution Support\n\nThe type system design supports schema evolution through several key mechanisms:\n\n**1. Schema Versioning Metadata:**\nThe `Schema` type includes extension fields that can store version information and compatibility metadata:\n\n| Field | Type | Description | Evolution Support |\n|-------|------|-------------|-------------------|\n| `extensions` | `Dict[str, Any]` | Arbitrary metadata | Stores schema version, deprecation info |\n| `source_services` | `List[Dict]` | Source service info | Enables schema stitching tracking |\n| `directive_locations` | `Dict[str, List[str]]` | Custom directive bindings | Supports directive registration |\n\n**2. Backward-Compatible Changes:**\nThe architecture supports common GraphQL schema evolution patterns:\n- **Additive Changes**: New types, fields, and arguments can be added without breaking existing clients\n- **Deprecation Flow**: Fields can be marked deprecated while maintaining functionality\n- **Default Values**: New arguments can be added with default values for backward compatibility\n- **Interface Implementation**: New types can implement existing interfaces\n\n**3. Breaking Change Detection:**\nThe `validate_schema` function includes hooks for schema comparison that can detect breaking changes:\n```python\n# Extension point for schema comparison\ndef detect_breaking_changes(\n    old_schema: Schema, \n    new_schema: Schema\n) -> List[BreakingChange]:\n    # Compares schemas and returns list of breaking changes\n    # Ready for extension to support custom breaking change policies\n    pass\n```\n\n#### Execution Pipeline Extensibility\n\nThe query execution pipeline is designed as a series of interceptable stages:\n\n**Execution Stage Pipeline:**\n1. **Parse** → `parse_query()` with directive awareness\n2. **Validate** → `validate_with_rules()` with custom validation rules\n3. **Plan** → `create_execution_plan()` with caching/sharding decisions  \n4. **Execute** → `execute_operation()` with middleware wrapping\n5. **Format** → `format_response()` with error transformation\n\nEach stage can be intercepted or replaced through the `ExecutionContext` configuration:\n\n```python\n# Execution context includes extension points\nExecutionContext(\n    # ... existing fields ...\n    validation_rules: List[ValidationRule] = None,  # Custom validation\n    field_middleware: List[FieldMiddleware] = None,  # Field execution hooks\n    query_transformers: List[QueryTransformer] = None,  # AST transformations\n    error_formatters: Dict[Type[Exception], ErrorFormatter] = None,  # Custom errors\n)\n```\n\n#### Database Abstraction Layer\n\nThe current database reflection and SQL compilation components are designed with dialect abstraction that enables future database support:\n\n**Database Dialect Interface:**\n```python\nclass SQLDialect(ABC):\n    @abstractmethod\n    def get_type_mappings(self) -> Dict[str, GraphQLType]:\n        \"\"\"Return database-specific type mappings\"\"\"\n        pass\n    \n    @abstractmethod\n    def supports_feature(self, feature: str) -> bool:\n        \"\"\"Check if dialect supports specific feature (e.g., JSON, arrays)\"\"\"\n        pass\n    \n    @abstractmethod\n    def generate_pagination_sql(self, limit: int, offset: int) -> str:\n        \"\"\"Generate dialect-specific pagination SQL\"\"\"\n        pass\n```\n\n**Current dialect implementations can be extended for:**\n- **Additional Databases**: MongoDB, Cassandra, Elasticsearch\n- **Advanced Features**: Full-text search, geospatial queries, window functions\n- **Optimization Hints**: Database-specific query optimizations\n\n#### Plugin System Architecture\n\nThe overall architecture follows a plugin system pattern where new capabilities can be registered without modifying core components:\n\n**Plugin Registration Flow:**\n1. **Discovery**: Plugins are discovered via entry points or explicit registration\n2. **Initialization**: Each plugin receives configuration and context\n3. **Integration**: Plugins register themselves with appropriate extension points\n4. **Execution**: Plugins participate in the normal execution flow\n\n**Example Plugin Contract:**\n```python\nclass GraphQLEnginePlugin(ABC):\n    @abstractmethod\n    def configure_schema(self, schema: Schema) -> Schema:\n        \"\"\"Transform schema during construction\"\"\"\n        pass\n    \n    @abstractmethod\n    def configure_execution(self, context: ExecutionContext) -> ExecutionContext:\n        \"\"\"Add middleware or transformers to execution context\"\"\"\n        pass\n    \n    @abstractmethod\n    def teardown(self):\n        \"\"\"Clean up plugin resources\"\"\"\n        pass\n```\n\n#### Performance Monitoring Hooks\n\nThe architecture includes performance monitoring hooks that enable future observability features:\n\n**Instrumentation Points:**\n| Instrumentation Point | Data Collected | Enables Feature |\n|----------------------|----------------|-----------------|\n| `query_parse_start/end` | Parse duration, query size | Performance monitoring |\n| `field_resolve_start/end` | Resolver timing, parent type | Resolver profiling |\n| `sql_generation_start/end` | SQL generation time, complexity | Query optimization |\n| `database_query_start/end` | Database latency, row count | Database performance analysis |\n| `cache_hit_miss` | Cache effectiveness metrics | Cache tuning |\n\nThese hooks are implemented as no-op stubs in the current system but provide the foundation for comprehensive APM (Application Performance Monitoring) integration.\n\n#### Security Extension Foundation\n\nThe current design includes several security-conscious patterns that enable future security extensions:\n\n**1. Input Validation Pipeline:**\nArgument coercion and input validation occur in isolated, interceptable stages that can be extended for:\n- Additional input sanitization\n- Business rule validation\n- Compliance checking (PCI, HIPAA, etc.)\n\n**2. Error Sanitization Layers:**\nDatabase errors are sanitized before exposure, but this pipeline can be extended for:\n- PII (Personally Identifiable Information) filtering\n- Security policy enforcement\n- Audit logging of sensitive errors\n\n**3. Query Complexity Analysis:**\nThe query execution plan includes complexity metrics that can be extended for:\n- Query depth limiting\n- Field cost calculation\n- Rate limiting based on query complexity\n\n**Common Pitfalls in Extensibility Design:**\n⚠️ **Pitfall: Over-Engineering Extension Points**\n- **Description**: Creating abstract interfaces and extension hooks for every possible future need, resulting in unnecessary complexity.\n- **Why It's Wrong**: Increases initial implementation complexity, makes the system harder to understand, and may never use most extension points.\n- **Fix**: Apply the YAGNI (You Ain't Gonna Need It) principle. Only add extension points where there's clear evidence of future need or where the cost is minimal.\n\n⚠️ **Pitfall: Tight Coupling Between Extension and Core**\n- **Description**: Extension implementations directly modify core data structures or rely on internal implementation details.\n- **Why It's Wrong**: Core changes break extensions, making evolution difficult and creating maintenance burden.\n- **Fix**: Use the Dependency Inversion Principle. Core depends on abstractions, extensions implement those abstractions without knowing core internals.\n\n⚠️ **Pitfall: Inconsistent Extension Patterns**\n- **Description**: Different components use different patterns for extensibility (callbacks, inheritance, plugins, etc.).\n- **Why It's Wrong**: Makes the system harder to learn and extend consistently.\n- **Fix**: Establish and document consistent extension patterns across the codebase, such as a unified plugin system or consistent use of strategy pattern.\n\n⚠️ **Pitfall: Neglecting Extension Performance**\n- **Description**: Extension points add overhead even when not used, or poorly designed extensions degrade performance.\n- **Why It's Wrong**: Impacts performance of core functionality, making extensions impractical for production use.\n- **Fix**: Design extension points with zero-cost abstractions where possible, use lazy initialization, and provide performance guidance for extension developers.\n\n> **Design Insight**: The most successful extensible systems follow the \"Open-Closed Principle\"—open for extension but closed for modification. This is achieved not by predicting every future need, but by identifying stable abstractions that encapsulate variation points. In this GraphQL engine, the key stable abstractions are: `GraphQLType` for schema definition, `ExecutionContext` for execution behavior, and `SQLDialect` for database variations.\n\n### Implementation Guidance\n\nWhile the future extensions themselves are out of scope for the initial implementation, the architecture includes specific patterns and structures that make these extensions feasible. This section provides concrete guidance on how to implement the extension infrastructure.\n\n#### Technology Recommendations\n\n| Extension | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Schema Stitching | Manual schema merging with delegated resolvers | Apollo Federation with query planning service |\n| Subscriptions | Polling-based subscriptions with database polling | WebSocket with PostgreSQL LISTEN/NOTIFY or change data capture |\n| Custom Directives | Directive visitors that modify execution context | AST-transforming directives with full query rewriting |\n| Query Caching | In-memory LRU cache with TTL | Redis cluster with cache invalidation streams |\n| Plugin System | Explicit registration in application code | Dynamic discovery via entry_points with dependency injection |\n\n#### Recommended Plugin Directory Structure\n\n```\ngraphql-engine/\n  core/                    # Core engine (existing)\n    parser/               # Component 1\n    type_system/          # Component 2  \n    execution/            # Component 3\n    reflection/           # Component 4\n    compilation/          # Component 5\n    \n  extensions/             # Future extensions (new)\n    stitching/            # Schema stitching implementation\n      __init__.py\n      gateway.py          # Schema stitching gateway\n      delegator.py        # Field delegation logic\n      planner.py          # Cross-service query planning\n      \n    subscriptions/        # Real-time subscriptions\n      __init__.py\n      transport/          # WebSocket/SSE transport\n        websocket.py\n        sse.py\n      pubsub/             # Publish/subscribe backend\n        memory.py\n        redis.py\n      triggers/           # Database change detection\n        poller.py\n        cdc.py\n        \n    directives/           # Custom directives\n      __init__.py\n      registry.py         # Directive registry\n      builtins/           # Built-in directives\n        auth.py           # @auth directive\n        cache.py          # @cache directive\n        log.py            # @log directive\n      middleware.py       # Directive execution middleware\n      \n    caching/              # Query caching\n      __init__.py\n      backends/           # Cache storage backends\n        memory.py\n        redis.py\n      key_generation.py   # Cache key generation\n      invalidation.py     # Cache invalidation logic\n      \n    plugins/              # Plugin infrastructure\n      __init__.py\n      registry.py         # Plugin registry\n      lifecycle.py        # Plugin lifecycle management\n```\n\n#### Extension Infrastructure Starter Code\n\n**Plugin Registry (Complete Implementation):**\n```python\n# extensions/plugins/registry.py\n\"\"\"Plugin registry for dynamic extension loading\"\"\"\nimport importlib\nimport logging\nfrom typing import Dict, List, Type, Optional, Any\n\nlogger = logging.getLogger(__name__)\n\nclass GraphQLEnginePlugin:\n    \"\"\"Base class for all GraphQL engine plugins\"\"\"\n    \n    def __init__(self, name: str, version: str = \"1.0.0\"):\n        self.name = name\n        self.version = version\n        self.enabled = True\n        \n    def configure_schema(self, schema: 'Schema') -> 'Schema':\n        \"\"\"Transform schema during construction. Override in subclasses.\"\"\"\n        return schema\n    \n    def configure_execution(self, context: 'ExecutionContext') -> 'ExecutionContext':\n        \"\"\"Add middleware or transformers to execution context.\"\"\"\n        return context\n    \n    def teardown(self):\n        \"\"\"Clean up plugin resources.\"\"\"\n        pass\n    \n    def __repr__(self) -> str:\n        return f\"<Plugin {self.name} v{self.version}>\"\n\n\nclass PluginRegistry:\n    \"\"\"Central registry for managing plugins\"\"\"\n    \n    def __init__(self):\n        self._plugins: Dict[str, GraphQLEnginePlugin] = {}\n        self._initialized = False\n        \n    def register(self, plugin: GraphQLEnginePlugin) -> None:\n        \"\"\"Register a plugin instance\"\"\"\n        if plugin.name in self._plugins:\n            logger.warning(f\"Plugin {plugin.name} already registered, overwriting\")\n        self._plugins[plugin.name] = plugin\n        \n    def load_from_entrypoint(self, entrypoint_name: str = \"graphql_engine.plugins\") -> None:\n        \"\"\"Load plugins from package entrypoints\"\"\"\n        try:\n            import pkg_resources\n            for entrypoint in pkg_resources.iter_entry_points(entrypoint_name):\n                try:\n                    plugin_class = entrypoint.load()\n                    plugin = plugin_class()\n                    self.register(plugin)\n                    logger.info(f\"Loaded plugin {plugin.name} from {entrypoint.module_name}\")\n                except Exception as e:\n                    logger.error(f\"Failed to load plugin from {entrypoint}: {e}\")\n        except ImportError:\n            logger.warning(\"pkg_resources not available, skipping entrypoint loading\")\n            \n    def initialize_all(self, schema: 'Schema', context: Optional['ExecutionContext'] = None) -> None:\n        \"\"\"Initialize all registered plugins\"\"\"\n        if self._initialized:\n            return\n            \n        for name, plugin in self._plugins.items():\n            if plugin.enabled:\n                try:\n                    logger.debug(f\"Initializing plugin {name}\")\n                    # Apply schema transformations\n                    schema = plugin.configure_schema(schema)\n                    \n                    # Apply execution context transformations\n                    if context:\n                        context = plugin.configure_execution(context)\n                        \n                except Exception as e:\n                    logger.error(f\"Plugin {name} failed to initialize: {e}\")\n                    plugin.enabled = False\n                    \n        self._initialized = True\n        \n    def teardown_all(self) -> None:\n        \"\"\"Clean up all plugin resources\"\"\"\n        for name, plugin in self._plugins.items():\n            if plugin.enabled:\n                try:\n                    plugin.teardown()\n                except Exception as e:\n                    logger.error(f\"Plugin {name} failed to teardown: {e}\")\n                    \n    def get_plugin(self, name: str) -> Optional[GraphQLEnginePlugin]:\n        \"\"\"Get a plugin by name\"\"\"\n        return self._plugins.get(name)\n        \n    def list_plugins(self) -> List[GraphQLEnginePlugin]:\n        \"\"\"List all registered plugins\"\"\"\n        return list(self._plugins.values())\n        \n    def enable_plugin(self, name: str) -> bool:\n        \"\"\"Enable a disabled plugin\"\"\"\n        if name in self._plugins:\n            self._plugins[name].enabled = True\n            return True\n        return False\n        \n    def disable_plugin(self, name: str) -> bool:\n        \"\"\"Disable an enabled plugin\"\"\"\n        if name in self._plugins:\n            self._plugins[name].enabled = False\n            return True\n        return False\n\n\n# Global plugin registry instance\nplugin_registry = PluginRegistry()\n```\n\n**Directive Middleware Skeleton (Core Logic TODOs):**\n```python\n# extensions/directives/middleware.py\n\"\"\"Directive execution middleware for field resolution\"\"\"\nfrom typing import Callable, Any, Dict, List, Optional\nfrom ..core.type_system import GraphQLDirective, GraphQLField, ExecutionContext\n\nclass DirectiveMiddleware:\n    \"\"\"Middleware that executes directives during field resolution\"\"\"\n    \n    def __init__(self):\n        self._directive_handlers: Dict[str, Callable] = {}\n        \n    def register_directive_handler(self, directive_name: str, handler: Callable) -> None:\n        \"\"\"Register a handler function for a specific directive\"\"\"\n        # TODO 1: Validate handler signature matches expected directive interface\n        # TODO 2: Check for naming conflicts with existing handlers\n        # TODO 3: Store handler in _directive_handlers dictionary\n        pass\n    \n    async def execute_field_with_directives(\n        self,\n        field: GraphQLField,\n        parent_value: Any,\n        args: Dict[str, Any],\n        context: ExecutionContext,\n        next_resolver: Callable\n    ) -> Any:\n        \"\"\"Execute a field with directive middleware wrapping\"\"\"\n        # TODO 1: Collect all directives attached to this field definition\n        # TODO 2: Sort directives by their declared execution order\n        # TODO 3: Create execution chain: directive1 → directive2 → ... → resolver\n        # TODO 4: Execute the chain and return result\n        # TODO 5: Handle errors from directive execution with proper error propagation\n        pass\n    \n    def _create_directive_wrapper(\n        self,\n        directive: GraphQLDirective,\n        handler: Callable,\n        next_fn: Callable\n    ) -> Callable:\n        \"\"\"Create a wrapper function that executes a directive\"\"\"\n        # TODO 1: Extract directive arguments from directive definition\n        # TODO 2: Create closure that captures directive context\n        # TODO 3: Return function that: \n        #   - Calls handler with appropriate parameters\n        #   - Passes result to next_fn in chain\n        #   - Handles exceptions according to directive configuration\n        pass\n```\n\n**Subscription Transport Skeleton (Core Logic TODOs):**\n```python\n# extensions/subscriptions/transport/websocket.py\n\"\"\"WebSocket transport for GraphQL subscriptions\"\"\"\nimport asyncio\nimport json\nfrom typing import Dict, Any, Optional\nfrom websockets.server import WebSocketServerProtocol\n\nclass WebSocketTransport:\n    \"\"\"WebSocket-based transport for GraphQL subscriptions\"\"\"\n    \n    def __init__(self, execution_context_factory: Callable):\n        # TODO 1: Store execution context factory for creating per-connection contexts\n        # TODO 2: Initialize connection tracking dictionary\n        # TODO 3: Set up message handlers for different GraphQL over WebSocket protocols\n        pass\n    \n    async def handle_connection(self, websocket: WebSocketServerProtocol) -> None:\n        \"\"\"Handle a new WebSocket connection\"\"\"\n        # TODO 1: Generate unique connection ID\n        # TODO 2: Store connection in active connections registry\n        # TODO 3: Send connection_init acknowledgement\n        # TODO 4: Enter message handling loop\n        # TODO 5: On connection_close message or disconnect, clean up resources\n        pass\n    \n    async def handle_message(\n        self, \n        connection_id: str, \n        message: Dict[str, Any]\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Handle incoming WebSocket message\"\"\"\n        # TODO 1: Parse message type (connection_init, start, stop, connection_terminate)\n        # TODO 2: For \"start\" messages: parse GraphQL operation, validate for subscriptions\n        # TODO 3: Create subscription execution, store subscription ID\n        # TODO 4: Return appropriate response based on protocol specification\n        # TODO 5: Handle errors with proper error response format\n        pass\n    \n    async def send_data(\n        self, \n        connection_id: str, \n        subscription_id: str, \n        data: Dict[str, Any]\n    ) -> None:\n        \"\"\"Send subscription data to client\"\"\"\n        # TODO 1: Look up WebSocket connection by connection_id\n        # TODO 2: Format data according to GraphQL over WebSocket specification\n        # TODO 3: Send data message with subscription_id and payload\n        # TODO 4: Handle send errors (connection closed, etc.)\n        pass\n```\n\n#### Language-Specific Hints for Python\n\n1. **Use `__init_subclass__` for Plugin Registration**: Python 3.6+ supports `__init_subclass__` which can automatically register plugin classes without explicit registration calls.\n\n2. **Leverage `contextvars` for Request-Scoped Data**: For directive middleware that needs request-scoped context, use `contextvars` instead of thread locals for proper async support.\n\n3. **Use `dataclasses` for Configuration Objects**: Future extension configurations should use `@dataclass` for type safety and clean initialization.\n\n4. **Implement `__slots__` for Performance-Critical Types**: Extension data structures that are instantiated frequently should use `__slots__` to reduce memory overhead.\n\n5. **Use `asyncio.Queue` for Subscription Events**: For subscription implementations, `asyncio.Queue` provides a clean pattern for buffering events between database change detection and client delivery.\n\n#### Extension Milestone Checkpoint\n\nAfter implementing the extension infrastructure (not the full extensions), verify the system still functions correctly:\n\n1. **Run Existing Tests**: Execute the full test suite to ensure no regression:\n   ```\n   python -m pytest tests/ -v\n   ```\n\n2. **Verify Plugin Loading**: Test that plugins can be registered and initialized:\n   ```python\n   # test_plugin_loading.py\n   from extensions.plugins.registry import plugin_registry, GraphQLEnginePlugin\n   \n   class TestPlugin(GraphQLEnginePlugin):\n       def __init__(self):\n           super().__init__(\"test-plugin\")\n           \n       def configure_schema(self, schema):\n           print(f\"TestPlugin configuring schema: {schema}\")\n           return schema\n   \n   # Register and test\n   plugin_registry.register(TestPlugin())\n   print(f\"Registered plugins: {plugin_registry.list_plugins()}\")\n   ```\n\n3. **Check Directive Hook Integration**: Verify directives can be attached to schema types:\n   ```python\n   # test_directive_hooks.py\n   schema = create_schema(...)\n   # Should be able to attach directives without errors\n   ```\n\n4. **Monitor Performance Impact**: Run performance benchmarks to ensure extension infrastructure doesn't degrade performance:\n   ```\n   python benchmarks/query_performance.py --baseline\n   ```\n\n**Expected Behavior**:\n- All existing tests pass without modification\n- Plugin registration and initialization logs appropriate messages\n- Schema creation with directive annotations succeeds\n- Performance impact is <5% for non-extension use cases\n\n**Signs of Problems**:\n- Existing tests fail after adding extension infrastructure → Likely caused by side effects in plugin initialization\n- Schema building fails with directive annotations → Directive integration not properly isolated\n- Significant performance degradation → Extension hooks adding overhead in hot paths\n\n#### Debugging Extension Implementation\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Plugins not loading | Entrypoint name mismatch or missing dependency | Check plugin registry logs, verify `setup.py` entrypoints | Correct entrypoint name, ensure package is installed |\n| Directive not executing | Directive not registered or middleware not connected | Add debug logging to directive middleware, check execution context | Register directive handler, ensure middleware is in execution chain |\n| Subscription connections dropping | WebSocket protocol violation or timeout | Monitor WebSocket frames, check for keepalive messages | Implement proper ping/pong, adjust timeout settings |\n| Cache returning stale data | Cache invalidation not triggered by mutations | Log cache operations, check invalidation triggers | Connect mutation execution to cache invalidation system |\n| Schema stitching type conflicts | Type merging logic too restrictive | Log type merging decisions, examine conflict details | Implement type namespacing or field renaming strategies |\n| Performance degradation with extensions | Extension hooks in hot paths | Profile execution with and without extensions, identify bottlenecks | Optimize extension hooks, add conditional execution |\n| Memory leak with plugins | Plugin resources not cleaned up | Monitor memory usage, check plugin teardown methods | Ensure all plugins implement proper teardown, use weak references |\n\n> **Key Insight**: The most successful extension systems evolve from actual needs rather than hypothetical ones. Implement the minimal extension infrastructure needed for known requirements, then extend as real use cases emerge. The architecture should make common extensions easy and complex extensions possible, without making the simple case complex.\n\n\n## Glossary\n\n> **Milestone(s):** This glossary section spans all five milestones, providing definitions for key terms used throughout the design document. Understanding this vocabulary is essential for navigating the technical concepts, data structures, and implementation patterns across all components.\n\nThis glossary defines the specialized terminology, acronyms, and domain vocabulary used throughout the GraphQL engine design document. Terms are organized by conceptual domain (GraphQL, database, compiler) to help you quickly locate definitions when encountering unfamiliar concepts in the implementation guidance or design discussions.\n\n### GraphQL Terminology\n\nGraphQL-specific terms that describe the query language, type system, and execution model.\n\n| Term | Definition |\n|------|------------|\n| **Abstract Syntax Tree (AST)** | A hierarchical, tree-shaped data structure that represents the grammatical structure of a GraphQL query after parsing. Each node in the tree corresponds to a construct in the query language (operation, field, argument, fragment). The AST serves as the intermediate representation between the raw query string and the execution engine. |\n| **Resolver** | A function responsible for fetching or computing the data for a specific GraphQL field. When the execution engine encounters a field in the selection set, it calls the resolver function with four arguments: parent object, arguments, context, and execution info. Resolvers can be synchronous or asynchronous and may fetch data from databases, APIs, or other sources. |\n| **Introspection** | In GraphQL, this refers to the built-in capability to query the schema itself. Clients can send introspection queries (using fields like `__schema`, `__type`) to discover what types, fields, and operations are available. In the database context, introspection refers to querying the database's system catalog (like `information_schema`) to discover tables, columns, and relationships. |\n| **Selection Set** | The set of fields requested within a GraphQL operation or fragment. Represented as curly braces `{}` containing field selections, it defines the shape of the response data. Selection sets can be nested: each field that returns an object type may have its own selection set. The execution engine recursively processes selection sets to build the response tree. |\n| **Fragment** | A reusable unit of GraphQL selection sets. **Named fragments** (`fragment UserFields on User { ... }`) are defined once and can be spread multiple times using `...UserFields`. **Inline fragments** (`... on User { ... }`) are anonymous and include a type condition. Fragments allow clients to avoid repeating complex selections and enable polymorphic queries on interfaces and unions. |\n| **Directive** | An annotation in GraphQL queries or schemas that modifies execution behavior. Directives are prefixed with `@` and can have arguments. **Query directives** (like `@include`, `@skip`) control field inclusion at runtime. **Schema directives** (like `@deprecated`) provide metadata about schema elements. Custom directives can implement authorization, formatting, or other custom logic. |\n| **Operation** | A single, named unit of work in a GraphQL document. There are three types: **query** (read operation), **mutation** (write operation), and **subscription** (real-time updates). Each document can contain multiple operations, but only one is executed per request (identified by the `operationName`). |\n| **Variable** | A named placeholder in a GraphQL operation that gets replaced with values at execution time. Variables are defined in the operation header (`query($id: ID!)`) and referenced within the query body (`user(id: $id)`). This allows clients to parameterize queries without string concatenation. |\n| **Type Condition** | The `on Type` part of a fragment that specifies which object type the fragment applies to. Inline fragments and fragment definitions must include a type condition. During execution, the fragment's selection set is only included if the runtime object type matches the type condition (for interfaces/unions) or is assignable to it. |\n| **Type System** | The complete collection of GraphQL type definitions (`ObjectType`, `ScalarType`, `InterfaceType`, etc.) and the rules that govern their relationships and validity. The type system defines what queries are valid, what shape responses take, and how values are coerced. It serves as a contract between client and server. |\n| **Interface Implementation** | The relationship where an `ObjectType` provides all the fields defined by an `InterfaceType`. An object type can implement multiple interfaces. The type system validates that implementing objects define all interface fields with compatible types. At runtime, interface fields are resolved by the concrete object's resolvers. |\n| **Type Modifier** | A wrapper type that modifies another type's behavior. **`ListType`** indicates a list/array of values of the wrapped type. **`NonNullType`** indicates the wrapped type cannot be `null`. Modifiers can be nested (e.g., `[String!]!` means a non-null list of non-null strings). |\n| **Input Type** | GraphQL types that can be used as arguments to fields or directives. Includes `ScalarType`, `EnumType`, `InputObjectType`, and modifiers thereof. Distinguished from output types because input types cannot have fields with arguments and cannot form cycles. The `is_input_type()` function checks this property. |\n| **Output Type** | GraphQL types that can be returned by fields. Includes `ObjectType`, `InterfaceType`, `UnionType`, `ScalarType`, `EnumType`, and modifiers thereof. Output types can have fields with complex selection sets. The `is_output_type()` function checks this property. |\n| **Null Propagation** | The GraphQL specification rule where if a non-null field (`String!`) resolves to `null`, that `null` propagates upward to the nearest nullable parent field, which becomes `null` in the response. This ensures type guarantees while allowing partial results. The `should_propagate_null()` function implements this logic. |\n| **Parallel Execution** | The execution engine optimization where independent sibling fields (fields at the same depth under the same parent) are resolved concurrently when possible. This improves performance for resolvers that fetch from different data sources. The engine uses async/await or threads to coordinate parallel execution. |\n| **Partial Results** | GraphQL's approach to error handling where fields that resolve successfully are included in the response alongside errors from failed fields. Unlike REST, where an error typically aborts the entire response, GraphQL can return partial data with errors appended. The `ExecutionResult` contains both `data` and `errors` fields. |\n| **Schema Stitching** | The technique of combining multiple GraphQL schemas (potentially from different services) into a single unified schema. The gateway pattern uses schema stitching to create a single entry point for clients while delegating to underlying services. This is a future extension point in our architecture. |\n| **Subscription** | A GraphQL operation that establishes a long-lived connection (typically WebSocket) to receive real-time updates when events occur. Unlike queries/mutations that are request-response, subscriptions push data to clients. Our design includes `WebSocketTransport` as a future extension for subscriptions. |\n| **Custom Directives** | User-defined schema directives that extend GraphQL execution with custom logic. Directives can be attached to schema elements (types, fields, arguments) and can modify runtime behavior through execution hooks. Our architecture includes `DirectiveMiddleware` for implementing custom directives. |\n| **Query Caching** | Storing and reusing the results of GraphQL queries to improve performance. Can be implemented at multiple levels: HTTP response caching, parsed AST caching, compiled SQL caching, or database result caching. The `CacheBackend` abstract class provides an extension point for caching strategies. |\n\n### Database Terminology\n\nRelational database concepts essential for schema reflection and SQL compilation.\n\n| Term | Definition |\n|------|------------|\n| **Foreign Key** | A database constraint that links a column or set of columns in one table (`child`) to the primary key columns of another table (`parent`). Foreign keys enforce referential integrity and define relationships between tables. During schema reflection, foreign keys are detected to generate GraphQL field relationships between types. |\n| **JOIN** | A SQL operation that combines rows from two or more tables based on a related column between them. **INNER JOIN** returns rows with matching values in both tables. **LEFT JOIN** returns all rows from the left table with matching rows from the right (or NULLs if no match). The SQL compiler translates nested GraphQL fields into appropriate JOIN clauses. |\n| **Parameterization** | The practice of using placeholders (`$1`, `?`, `%s`) in SQL statements instead of directly embedding values. Parameters are bound separately, preventing SQL injection attacks and allowing query plan reuse. Our `SQLBuilder` class automatically parameterizes values from GraphQL arguments in the `SQLParameter` structures. |\n| **N+1 Problem** | A performance anti-pattern where an initial query fetches N parent records, then N additional queries (one per parent) fetch related child records. GraphQL naive execution often causes N+1 queries. Our engine prevents this through SQL JOIN compilation (single query) or DataLoader batching (batched queries). |\n| **Cartesian Product** | The result of joining two or more tables without a join condition, producing all possible combinations of rows. Cartesian products explode result sizes (m × n rows) and indicate missing JOIN conditions. The SQL compiler must ensure every JOIN has an appropriate `ON` clause based on foreign keys. |\n| **LATERAL JOIN** | A specialized SQL join (available in PostgreSQL, MySQL 8+) that allows a subquery in the JOIN to reference columns from preceding tables. Useful for efficiently resolving one-to-many relationships with limits/ordering per parent. The compiler may use LATERAL JOINs for nested collections with pagination. |\n| **Cursor Pagination** | A pagination technique using opaque cursors (typically encoded row values) instead of numeric offsets. Cursors provide stable pagination across data changes (insertions/deletions). Our engine generates cursor-based pagination with `before`/`after` arguments that translate to SQL comparisons on indexed columns. |\n| **Result Mapper** | A function that transforms flat SQL result rows (with joined columns from multiple tables) into the nested hierarchical structure expected by GraphQL. After executing a JOIN query, the result mapper walks the selection tree to reconstruct nested objects. It's part of the `SQLQuery` data structure. |\n| **Join Planning** | The process of determining the optimal order and type of SQL JOINs to execute a GraphQL query. The planner analyzes relationship paths, estimates cardinalities, and avoids cartesian products. The `plan_joins()` function generates `JoinPlan` structures defining the join strategy. |\n| **System Catalog** | Database-internal tables that store metadata about the database structure. In PostgreSQL: `pg_catalog`; in SQL-standard databases: `information_schema`. Schema reflection queries these catalogs to discover tables, columns, constraints, and relationships. |\n| **Foreign Key Constraint** | The formal database object that enforces a foreign key relationship. Contains source table/columns, target table/columns, and referential actions (`ON DELETE CASCADE`). The `RelationshipAnalyzer` examines these constraints to build `Relationship` metadata. |\n| **Cardinality** | The numerical relationship between tables in a database. **One-to-one**: Each parent row relates to at most one child row. **One-to-many**: Each parent relates to many children. **Many-to-many**: Requires a junction table. The analyzer detects cardinality via unique constraints and foreign key directions. |\n| **Diamond Relationship** | A query pattern where the same table is accessed via multiple paths in a single GraphQL query (e.g., `{ user { friends { posts }, posts } }` where `posts` appears through two paths). The SQL compiler must use table aliases to avoid column name conflicts when joining the same table multiple times. |\n| **Polymorphic Relationship** | A database pattern where different rows in a table may reference different target tables (similar to GraphQL interfaces/unions). Implemented with a type discriminator column and multiple foreign key columns (only one populated per row). This maps naturally to GraphQL interface/union types. |\n| **Composite Primary Key** | A primary key consisting of multiple columns rather than a single column. Common in junction tables and certain domain models. Schema reflection must handle composite keys when generating ID arguments and JOIN conditions (matching multiple columns). |\n| **Impedance Mismatch** | The structural differences between GraphQL's hierarchical, graph-like data model and relational databases' tabular, set-based model. Our engine bridges this mismatch by translating nested selections to JOINs and hierarchical results to nested JSON. |\n| **EXPLAIN Plan** | Database command (`EXPLAIN SELECT ...`) that shows the query execution plan—how the database will execute the SQL, including index usage, join algorithms, and cost estimates. Our `SQLExplainer` class runs EXPLAIN on generated queries to diagnose performance issues. |\n| **Index Hint** | A directive to the database optimizer suggesting which index to use for a query. Some databases support syntax like `USE INDEX (index_name)`. The compiler could add index hints based on GraphQL filter arguments to improve performance (future extension). |\n| **Stored Procedure** | A precompiled collection of SQL statements stored in the database. Could be used as an alternative to dynamic SQL generation for common query patterns. Our architecture could extend to call stored procedures for certain GraphQL operations. |\n| **Transaction Isolation** | Database property defining how concurrent transactions see each other's changes. Levels include READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE. The execution engine could wrap GraphQL mutations in transactions with appropriate isolation levels. |\n| **Connection Pool** | A cache of database connections maintained so they can be reused, reducing connection establishment overhead. The execution engine would typically use a connection pool rather than creating new connections for each GraphQL request. |\n\n### Compiler Terminology\n\nCompiler concepts used in parsing, AST transformation, and query optimization.\n\n| Term | Definition |\n|------|------------|\n| **Lexer** | Also called a **tokenizer**, this component breaks a source string (GraphQL query) into a sequence of **tokens**—the smallest meaningful units (keywords, identifiers, punctuation, literals). The `Tokenizer.tokenize()` method implements the lexer, producing `Token` objects with type, value, and location. |\n| **Parser** | The component that analyzes the token sequence according to GraphQL grammar rules and builds an **Abstract Syntax Tree (AST)**. Our implementation uses **recursive descent parsing**, where each grammar rule corresponds to a function that may call itself recursively. The `Parser.parse_document()` method is the entry point. |\n| **Token** | A single lexical unit from the source text, classified by `TokenType` (NAME, INT, STRING, PUNCTUATION, etc.). Each token has a `value` (the actual text) and `line`/`column` location for error reporting. The parser consumes tokens sequentially to construct the AST. |\n| **Intermediate Representation (IR)** | A data structure that serves as an intermediate form between the source (GraphQL) and target (SQL). Our engine has multiple IRs: the AST (`Document`), execution plan, and `SQLQuery` structures. IRs are optimized and transformed before final code generation. |\n| **Optimization** | The process of improving the efficiency of compiled code (SQL) without changing its semantics. Our SQL compiler performs optimizations like: eliminating unnecessary JOINs, pushing filters down, merging similar selections, and choosing optimal JOIN orders. |\n| **Traversal** | The systematic visiting of nodes in a tree (AST) or graph. **Depth-first traversal** visits child nodes before siblings; **breadth-first** visits siblings before children. Our engine uses recursive traversal for: validating schemas, executing selection sets, and compiling selections to SQL. |\n| **Recursive Descent** | A parsing technique where each non-terminal in the grammar corresponds to a function that may recursively call other non-terminal functions. Our parser uses recursive descent for its simplicity, error recovery, and good error messages—ideal for GraphQL's LL(1) grammar. |\n| **Lookahead** | Examining upcoming tokens without consuming them, used to decide which parsing path to take. A **lookahead of k** means peeking at the next k tokens. GraphQL's grammar requires at most 1 token of lookahead (LL(1)), simplifying the parser implementation. |\n| **Syntax Error** | An error in the query structure that violates GraphQL grammar rules (e.g., missing closing brace, unexpected token). The parser detects syntax errors and reports them with `GraphQLSyntaxError`, including `line` and `column` location from the `Token`. |\n| **Escape Sequence** | In string literals, a backslash (`\\`) followed by characters with special meaning: `\\n` (newline), `\\t` (tab), `\\uXXXX` (Unicode code point). The lexer must recognize and properly decode escape sequences in `StringValue` tokens. |\n| **Block String** | A triple-quoted string (`\"\"\"content\"\"\"`) in GraphQL that preserves newlines and allows unescaped quotes. Block strings have special whitespace handling: common leading indentation is removed. The lexer has a separate `TokenType.BLOCK_STRING` for these. |\n| **Fragment Spread** | The syntax `...FragmentName` that references a previously defined named fragment. The parser must verify the fragment is defined and expand its selection set into the current location. Represented by the `FragmentSpread` AST node. |\n| **Inline Fragment** | The syntax `... on Type { selection }` that defines an anonymous fragment with a type condition. Unlike fragment spreads, inline fragments don't have separate definitions. Represented by the `InlineFragment` AST node. |\n| **Backtracking** | A parsing technique where the parser tentatively follows one production, and if it fails, rolls back to try an alternative. GraphQL's grammar is designed to avoid backtracking through careful token lookahead, making the parser more efficient and predictable. |\n| **Grammar Production** | A rule in the formal grammar defining how symbols can be replaced. Example: `SelectionSet → { Selection* }`. Our parser implements each production as a method (`parse_selection_set()`) that consumes tokens according to the rule. |\n| **Left Recursion** | A grammar pattern where a non-terminal appears as the first symbol of its own production (e.g., `Expression → Expression + Term`). Left recursion causes infinite loops in naive recursive descent parsers; GraphQL's grammar avoids left recursion. |\n| **Parse Tree** | A detailed tree representation of how the grammar productions derive the input string. More detailed than AST, containing every syntactic detail. Our parser builds an AST (abstract) rather than a full parse tree, omitting irrelevant syntactic details. |\n| **Visitor Pattern** | A design pattern for traversing complex structures (like ASTs) where operations are separated from structure traversal. A visitor interface has `visit_*` methods for each node type. Useful for validation, transformation, and code generation phases. |\n| **Symbol Table** | A data structure used by compilers to track information about identifiers (types, fields, variables). In our engine, the schema acts as a symbol table mapping type names to `GraphQLType` objects. Variable definitions are tracked during parsing/validation. |\n| **Static Single Assignment (SSA)** | A compiler intermediate representation where each variable is assigned exactly once. Not used directly in our GraphQL compiler, but similar principles apply to ensuring field aliases and JOIN aliases are unique in generated SQL. |\n| **Code Generation** | The final compiler phase that produces target code (SQL) from the optimized intermediate representation. Our `SQLBuilder` class handles code generation, producing parameterized SQL strings from `SQLQuery` structures. |\n| **Peephole Optimization** | Local optimizations that examine small sequences of instructions (or SQL fragments) and replace them with more efficient sequences. Could be applied to generated SQL (e.g., simplifying `WHERE 1=1` or removing redundant conditions). |\n| **Constant Folding** | Evaluating constant expressions at compile time rather than runtime. In GraphQL, this could involve evaluating literal arguments during compilation rather than passing them as SQL parameters (but must respect security boundaries). |\n| **Dead Code Elimination** | Removing code that cannot be reached or whose results are never used. In our context, this could involve removing unused fields from selections (though GraphQL explicitly requests fields, so this is less applicable). |\n| **Inlining** | Replacing a function call (or fragment spread) with the body of the function/fragment. Our parser performs fragment inlining early, expanding `FragmentSpread` nodes into their constituent selections during query preparation. |\n| **Abstract Syntax Tree (AST) Visualization** | A human-readable display of the AST structure, useful for debugging. Our `ASTPrinter` class provides `print_document()`, `print_field()`, etc., methods that output indented text representations of the AST. |\n| **Resolving** | In compilers, the process of mapping names to their definitions. In our engine: **type resolving** maps type names in the AST to `GraphQLType` objects; **field resolving** maps field names to `GraphQLField` definitions; **fragment resolving** maps fragment names to `FragmentDefinition` nodes. |\n\n### Implementation Guidance\n\n> **Implementation Note:** This glossary section doesn't require implementation code, but understanding these terms is critical for reading and implementing the other components. The tables above serve as a reference you can consult while working through the milestones.\n\n#### Language-Specific Terminology Notes\n\n- **Python-specific**: When implementing in Python, note that our type definitions use Python's `typing` module for type hints. The `@dataclass` decorator is commonly used for AST nodes and data structures. Async/await is used for asynchronous resolvers and parallel execution.\n- **Go-specific** (if implementing in Go): Go's strong typing and interfaces align well with GraphQL's type system. Use structs for AST nodes with embedded types for inheritance-like behavior. Channels and goroutines enable parallel execution.\n- **Rust-specific** (if implementing in Rust): Rust's enum types with associated data are ideal for representing AST nodes and GraphQL types. The ownership model ensures safe concurrent execution. Traits can define interfaces for resolvers and data loaders.\n\n#### Terminology Usage Checklist\n\nBefore starting implementation, ensure you understand these key concept clusters:\n\n1. **AST Construction**: Token → Lexer → Parser → Recursive Descent → Abstract Syntax Tree\n2. **Type System**: Scalar/Object/Interface/Union/Enum → Input/Output Types → Type Modifiers (List/NonNull)\n3. **Execution**: Resolver → Selection Set → Parallel Execution → Null Propagation → Partial Results\n4. **Database Reflection**: System Catalog → Foreign Key → Cardinality → Type Mapping → Naming Convention\n5. **SQL Compilation**: JOIN → Parameterization → N+1 Problem → Cartesian Product → Result Mapper\n\n#### Quick Reference Table\n\nFor easy lookup during implementation, here's a condensed table of the most frequently used terms:\n\n| Category | Key Terms |\n|----------|-----------|\n| **AST Nodes** | `Document`, `OperationDefinition`, `SelectionSet`, `Field`, `FragmentSpread`, `Argument`, `Directive` |\n| **Type System** | `GraphQLType`, `ObjectType`, `ScalarType`, `InterfaceType`, `UnionType`, `EnumType`, `InputObjectType` |\n| **Execution** | `Resolver`, `ExecutionContext`, `DataLoader`, `ExecutionResult`, `GraphQLError`, `PathSegment` |\n| **SQL Compilation** | `SQLQuery`, `SQLSelect`, `SQLJoin`, `SQLParameter`, `JoinPlan`, `ResultMapper` |\n| **Database** | `DatabaseMetadata`, `TableMetadata`, `ColumnMetadata`, `Relationship`, `ForeignKey`, `Cardinality` |\n\nRemember that all these terms map to concrete Python classes and functions defined in the Naming Conventions section. When you encounter an unfamiliar term in the codebase, refer back to this glossary for its definition and context.\n"}