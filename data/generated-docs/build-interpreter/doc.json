{"html":"<h1 id=\"building-a-tree-walking-interpreter-for-lox-design-document\">Building a Tree-Walking Interpreter for Lox: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This document outlines the architecture for a complete interpreter for the Lox programming language, implementing a tree-walking evaluation strategy. The key architectural challenge is designing a clean separation between the static structure of the code (lexing, parsing) and its dynamic execution (environment-based evaluation), while managing state, scope, and first-class functions in a way that is both correct and educational for the implementer.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational context)</p>\n</blockquote>\n<h2 id=\"1-context-and-problem-statement\">1. Context and Problem Statement</h2>\n<p>Interpreting a programming language is the art of imbuing inert text with life. The fundamental problem is transforming a linear sequence of characters—a program—into a dynamic, stateful computation that produces effects (like printing to a screen, modifying a file, or controlling a robot). This transformation is not direct; it requires bridging a profound conceptual gap between the <strong>static syntax</strong> of the language (its grammar and keywords) and the <strong>dynamic runtime</strong> (the execution of operations on data in memory). This section establishes the core architectural philosophy for our Lox interpreter: the tree-walking strategy, a deliberate design that prioritizes clarity and pedagogical value while solving this fundamental problem.</p>\n<h3 id=\"mental-model-the-tour-guide\">Mental Model: The Tour Guide</h3>\n<p>Imagine you are handed a detailed, hierarchical map of a complex city (<strong>the Abstract Syntax Tree, or AST</strong>). The map doesn&#39;t <em>do</em> anything; it&#39;s just a static representation of the city&#39;s layout—streets (expressions), landmarks (literals), and districts (statements). A <strong>tree-walking interpreter</strong> acts as your personal tour guide. The guide walks you through this map step-by-step, starting at the main entrance (the program entry point). At each landmark on the map, the guide consults a comprehensive rulebook (<strong>the language semantics</strong>) that dictates what action to perform at that specific type of location.</p>\n<p>For example, upon reaching a <code>+</code> intersection (a Binary expression node), the rulebook states: &quot;First, walk down the left street and report back what you find. Then, walk down the right street and report back. Finally, if both reports are numbers, add them; if both are strings, join them.&quot; The guide faithfully executes these instructions, carrying a notebook (<strong>the Environment</strong>) to remember variable values assigned at different addresses. This direct, recursive walk through the map&#39;s structure is intuitive—the execution flow mirrors the code&#39;s syntactic structure. However, it can be inefficient, as the guide might re-walk the same paths (like in a loop) without remembering the terrain.</p>\n<h3 id=\"the-core-challenge-bridging-syntax-and-runtime\">The Core Challenge: Bridging Syntax and Runtime</h3>\n<p>Source code is a one-dimensional string. Runtime behavior is multidimensional, involving control flow jumps, mutable state, and nested function calls. The core architectural challenge is designing a pipeline that systematically translates the former into the latter. A single-step translation is impossible for all but the most trivial languages due to complexities like nested expressions, scoped variables, and forward references.</p>\n<p>Our solution is a <strong>multi-phase design</strong>, decomposing the problem into three sequential transformations, each building on the output of the previous phase. This separation of concerns is a classic pattern in language implementation:</p>\n<ol>\n<li><strong>Lexical Analysis (Scanner):</strong> The first transformation converts the raw character stream into a stream of meaningful <strong>tokens</strong>. This phase strips away whitespace and comments, and recognizes the basic vocabulary of the language: keywords (<code>if</code>, <code>while</code>), identifiers (<code>count</code>), literals (<code>42</code>, <code>&quot;hello&quot;</code>), and operators (<code>+</code>, <code>==</code>). It&#39;s akin to breaking a sentence into individual words and punctuation.</li>\n<li><strong>Syntactic Analysis (Parser):</strong> The second transformation organizes the flat token stream into a hierarchical <strong>Abstract Syntax Tree (AST)</strong>. This phase enforces the grammar rules of the language, ensuring tokens appear in a valid order and establishing the nesting relationships dictated by parentheses and operator precedence. It&#39;s like diagramming a sentence to identify subject, verb, object, and subordinate clauses.</li>\n<li><strong>Semantic Analysis &amp; Execution (Interpreter):</strong> The final transformation walks the AST and performs the actual computations and side effects. This phase resolves the <em>meaning</em> of the syntactic constructs: evaluating expressions, executing statements, managing variable storage in <strong>Environments</strong>, and directing control flow. It&#39;s the tour guide bringing the map to life.</li>\n</ol>\n<p>The data flows linearly through this pipeline: <code>Source Code (String)</code> → <code>Scanner</code> → <code>List&lt;Token&gt;</code> → <code>Parser</code> → <code>List&lt;Stmt&gt;</code> → <code>Interpreter</code> → <code>Runtime Effects/Output</code>.</p>\n<p><img src=\"/api/project/build-interpreter/architecture-doc/asset?path=diagrams%2Fdiagram-system.svg\" alt=\"High-Level System Component Diagram\"></p>\n<p><strong>Why is this separation necessary?</strong> Each phase operates at a different level of abstraction and has a distinct, testable responsibility. The scanner worries about character-level patterns but not grammar. The parser worries about grammar but not what <code>+</code> <em>does</em>. The interpreter worries about semantics and state but not about where parentheses go. This modularity makes the system easier to understand, debug, and extend. For instance, adding a new operator like <code>**</code> requires: 1) teaching the scanner to recognize <code>**</code> as a token, 2) teaching the parser its precedence level, and 3) teaching the interpreter its mathematical meaning—all in isolated components.</p>\n<h3 id=\"existing-interpreter-architectures\">Existing Interpreter Architectures</h3>\n<p>The tree-walking interpreter is one of several architectures for implementing a programming language. The choice among them represents a classic engineering trade-off between simplicity, performance, and flexibility.</p>\n<blockquote>\n<p><strong>Decision: Choosing a Tree-Walking Interpreter Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: We are building an interpreter for Lox primarily as an educational project. The primary goal is to understand language implementation concepts from the ground up, not to achieve peak execution speed. We need an architecture that maps clearly to the language&#39;s syntax and semantics, making the connection between source code and runtime behavior as transparent as possible.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Tree-Walking Interpreter</strong>: Directly traverses the AST, executing operations at each node.</li>\n<li><strong>Bytecode Virtual Machine (VM)</strong>: Compiles the AST to a compact, linear bytecode instruction set, which is then executed by a virtual stack- or register-based machine.</li>\n<li><strong>Ahead-of-Time (AOT) or Just-in-Time (JIT) Compiler</strong>: Translates source code directly to native machine code for the host CPU (e.g., x86, ARM).</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We will implement a <strong>Tree-Walking Interpreter</strong>.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Conceptual Clarity</strong>: The execution path of a tree-walker directly mirrors the syntactic structure of the source code. A <code>while</code> loop node in the AST leads directly to a loop in the interpreter&#39;s execution. This 1:1 mapping is invaluable for learning.</li>\n<li><strong>Implementation Simplicity</strong>: It requires fewer moving parts. There is no need to design a bytecode instruction set, a compiler from AST to bytecode, or a virtual machine with its own instruction dispatch loop. The interpreter is essentially a large recursive function over the AST.</li>\n<li><strong>Incremental Development</strong>: Features can be added by extending the AST and adding a corresponding <code>visit</code> method in the interpreter. This aligns perfectly with the milestone-based learning approach.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Performance</strong>: Tree-walking is slower than a bytecode VM. Each AST node involves a virtual method dispatch (via the Visitor pattern), and complex expressions require traversing a deep tree for every evaluation (e.g., in a tight loop).</li>\n<li><strong>No Intermediate Representation</strong>: The lack of a bytecode intermediate representation (IR) makes some optimizations (like constant folding or basic block analysis) more awkward to implement, though they are less of a priority for this project.</li>\n<li><strong>Direct Semantics</strong>: The interpreter&#39;s logic is the &quot;specification&quot; of the language. This can be both a pro (easy to reason about) and a con (runtime errors are deeply embedded in the traversal logic).</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The following table compares the key architectural approaches:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Architecture</th>\n<th align=\"left\">How it Works</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Tree-Walking Interpreter</strong></td>\n<td align=\"left\">Recursively evaluates nodes in the Abstract Syntax Tree (AST).</td>\n<td align=\"left\"><strong>Simple to implement and understand.</strong> Direct mapping from syntax to execution. Easy to add new language features.</td>\n<td align=\"left\"><strong>Slow.</strong> High overhead per operation due to tree traversal and visitor pattern dispatch. No easy path to optimization.</td>\n<td align=\"left\"><strong>Educational projects, prototyping, scripting languages</strong> where simplicity and clarity are paramount over raw speed.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Bytecode Virtual Machine</strong></td>\n<td align=\"left\">Compiles AST to a dense, linear bytecode. A virtual CPU (stack-based or register-based) executes the bytecode.</td>\n<td align=\"left\"><strong>Much faster than tree-walking.</strong> Bytecode is compact, and the dispatch loop is efficient. Enables optimizations at the bytecode level. Foundation for JIT compilation.</td>\n<td align=\"left\"><strong>More complex.</strong> Requires designing a bytecode ISA, a compiler, and a VM. The mapping from source to execution is less direct.</td>\n<td align=\"left\"><strong>Production interpreters</strong> (e.g., CPython, Lua, the Java JVM). Balances performance with portability.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Ahead-of-Time (AOT) Compiler</strong></td>\n<td align=\"left\">Translates source code directly to native machine code for a specific CPU architecture.</td>\n<td align=\"left\"><strong>Maximum runtime performance.</strong> Executes directly on hardware, no interpreter loop overhead.</td>\n<td align=\"left\"><strong>Extremely complex.</strong> Must handle low-level details of the target CPU (registers, instruction selection). Loss of portability; output is platform-specific. Long compilation time.</td>\n<td align=\"left\"><strong>Systems programming languages</strong> (C, C++, Rust) and performance-critical applications.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Just-in-Time (JIT) Compiler</strong></td>\n<td align=\"left\">Starts as an interpreter or bytecode VM, but profiles &quot;hot&quot; code paths and dynamically compiles them to native code during execution.</td>\n<td align=\"left\"><strong>Can approach AOT performance</strong> for hot code while maintaining the flexibility of an interpreter for cold code. Adaptive optimization based on runtime profiling.</td>\n<td align=\"left\"><strong>Extreme complexity.</strong> Combines challenges of VM and compiler design. High memory usage for storing both bytecode and native code.</td>\n<td align=\"left\"><strong>High-performance managed runtimes</strong> (JavaScript V8, Java HotSpot, .NET CLR).</td>\n</tr>\n</tbody></table>\n<p>Our chosen path, the tree-walking interpreter, is the <strong>simplest gateway</strong> into the world of language implementation. It allows us to focus on the core concepts—lexing, parsing, environments, closures, and classes—without the additional cognitive load of designing a bytecode format and a virtual machine. The performance trade-off is acceptable for an educational interpreter; Lox programs will be plenty fast for learning and scripting purposes. Furthermore, the skills and patterns learned here (especially the Visitor pattern for AST traversal and environment management for scope) are directly transferable to building more advanced bytecode VMs or compilers in the future.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section is foundational and does not involve writing code. However, establishing a solid project structure from the outset is critical. Below is the recommended Java package and directory layout that aligns with the high-level architecture. We will flesh out these directories in subsequent component design sections.</p>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/\n├── src/main/java/com/craftinginterpreters/lox/\n│   ├── Lox.java                          # Main entry point, coordinates scanning, parsing, interpreting\n│   │\n│   ├── scanner/                          # Milestone 1: Scanner (Lexer)\n│   │   ├── Scanner.java\n│   │   ├── Token.java\n│   │   └── TokenType.java\n│   │\n│   ├── parser/                           # Milestones 2 &amp; 3: Parser &amp; AST\n│   │   ├── Parser.java\n│   │   └── ParseError.java\n│   │\n│   ├── ast/                              # Milestone 2: Abstract Syntax Tree nodes\n│   │   ├── Expr.java                     # Base expression class\n│   │   ├── Stmt.java                     # Base statement class\n│   │   ├── expr/                         # Concrete expression subclasses\n│   │   │   ├── Assign.java\n│   │   │   ├── Binary.java\n│   │   │   ├── Call.java\n│   │   │   ├── Get.java\n│   │   │   ├── Grouping.java\n│   │   │   ├── Literal.java\n│   │   │   ├── Logical.java\n│   │   │   ├── Set.java\n│   │   │   ├── Super.java\n│   │   │   ├── This.java\n│   │   │   ├── Unary.java\n│   │   │   └── Variable.java\n│   │   └── stmt/                         # Concrete statement subclasses\n│   │       ├── Block.java\n│   │       ├── Class.java\n│   │       ├── Expression.java\n│   │       ├── Function.java\n│   │       ├── If.java\n│   │       ├── Print.java\n│   │       ├── Return.java\n│   │       ├── Var.java\n│   │       └── While.java\n│   │\n│   ├── interpreter/                      # Milestones 4-10: Interpreter &amp; Runtime\n│   │   ├── Interpreter.java              # Main tree-walking visitor\n│   │   ├── RuntimeError.java\n│   │   ├── environment/                  # Milestone 5: Environments\n│   │   │   └── Environment.java\n│   │   └── runtime/                      # Runtime value representations\n│   │       ├── LoxCallable.java          # Interface for functions/classes\n│   │       ├── LoxClass.java\n│   │       ├── LoxFunction.java\n│   │       ├── LoxInstance.java\n│   │       └── Return.java               # Control flow for return statements\n│   │\n│   └── tools/                            # Utilities\n│       └── AstPrinter.java               # Milestone 2: Pretty-printer for debugging\n│\n└── src/test/java/com/craftinginterpreters/lox/   # Unit tests for each component\n    ├── scanner/\n    ├── parser/\n    └── interpreter/</code></pre></div>\n\n<p><strong>Language-Specific Hints (Java):</strong></p>\n<ul>\n<li>Use <code>enum</code> for <code>TokenType</code> to represent the finite set of token categories (keywords, operators, etc.).</li>\n<li>The Visitor pattern for AST traversal is a natural fit in Java using abstract classes and accept/visit methods. While it involves some boilerplate, it provides type safety and clean separation between the AST structure and operations on it.</li>\n<li>For representing runtime values, consider using <code>Object</code> as the base type in the interpreter, with explicit casting and <code>instanceof</code> checks. Alternatively, you can define a base <code>LoxValue</code> interface. We will explore this decision in the Data Model section.</li>\n<li>Use <code>java.util.HashMap&lt;String, Object&gt;</code> for the core storage within an <code>Environment</code>.</li>\n<li><strong>Milestone Checkpoint</strong>: After setting up this structure, you should be able to compile the project. A simple test is to create a <code>Lox.java</code> file with a <code>main</code> method that prints a message. Run <code>javac</code> on the source directory and execute the main class to verify your build environment is configured.</li>\n</ul>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational goals)</p>\n</blockquote>\n<h2 id=\"2-goals-and-non-goals\">2. Goals and Non-Goals</h2>\n<p>This section defines the precise boundaries of the interpreter project, establishing what constitutes a successful implementation. By explicitly stating functional requirements, non-functional priorities, and out-of-scope features, we create a clear target for development and prevent scope creep in this educational endeavor. The goals are structured to align with the 10 milestones, which incrementally build from lexical analysis to inheritance.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>The interpreter must fully implement the Lox programming language as defined in <em>Crafting Interpreters</em>. Lox is a dynamically-typed, object-oriented scripting language designed to be small enough for a single implementer yet complete enough to illustrate core language implementation concepts. The functional requirements are broken down by language feature category, each corresponding to a specific milestone.</p>\n<blockquote>\n<p><strong>Mental Model: The Language Specification Checklist</strong>\nThink of the Lox language specification as a checklist of features that a &quot;complete&quot; Lox interpreter must support. Our implementation is a faithful translation of that checklist into executable code, feature by feature, milestone by milestone. Each checked item moves us closer to a fully functional language.</p>\n</blockquote>\n<p>The following table enumerates the mandatory language features, their corresponding implementation milestones, and a precise description of what &quot;support&quot; entails:</p>\n<table>\n<thead>\n<tr>\n<th>Feature Category</th>\n<th>Milestone</th>\n<th>Implementation Requirement Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Lexical Structure</strong></td>\n<td>1 (Scanner)</td>\n<td>The scanner must tokenize all Lox lexical elements: keywords (<code>var</code>, <code>fun</code>, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>return</code>, <code>class</code>, <code>super</code>, <code>this</code>, <code>and</code>, <code>or</code>, <code>print</code>, <code>nil</code>, <code>true</code>, <code>false</code>), identifiers, literals (strings with escape sequences, numbers with decimal points), operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>!</code>, <code>=</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>), and punctuation (<code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>,</code>, <code>.</code>, <code>;</code>). Whitespace and comments (both <code>//</code> line and <code>/* */</code> block) must be ignored.</td>\n</tr>\n<tr>\n<td><strong>Expressions &amp; Precedence</strong></td>\n<td>3 (Parsing Expressions)</td>\n<td>The parser must correctly parse all expression types with proper operator precedence and associativity. Precedence levels (from lowest to highest) are: assignment (<code>=</code>), logical (<code>or</code>, <code>and</code>), equality (<code>==</code>, <code>!=</code>), comparison (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>), term (<code>+</code>, <code>-</code>), factor (<code>*</code>, <code>/</code>), and unary (<code>!</code>, <code>-</code>). Parentheses must override precedence.</td>\n</tr>\n<tr>\n<td><strong>Basic Evaluation</strong></td>\n<td>4 (Evaluating Expressions)</td>\n<td>The interpreter must evaluate expressions to produce runtime values: arithmetic operations on numbers, string concatenation with <code>+</code>, unary negation and logical NOT, truthiness rules (<code>nil</code> and <code>false</code> are falsy, everything else truthy), and comparison/equality operations with appropriate type checking.</td>\n</tr>\n<tr>\n<td><strong>Variables &amp; State</strong></td>\n<td>5 (Statements and State)</td>\n<td>Support variable declaration (<code>var x = value;</code>), assignment (<code>x = value;</code>), and scoping via nested environments. The <code>print</code> statement must output values to standard output. Expression statements must evaluate expressions for side effects.</td>\n</tr>\n<tr>\n<td><strong>Control Flow</strong></td>\n<td>6 (Control Flow)</td>\n<td>Implement <code>if</code>/<code>else</code> conditional execution, <code>while</code> loops, <code>for</code> loops (desugared to <code>while</code>), and logical operators <code>and</code>/<code>or</code> with short-circuit evaluation.</td>\n</tr>\n<tr>\n<td><strong>First-Class Functions</strong></td>\n<td>7 (Functions)</td>\n<td>Support function declaration (<code>fun name(parameters) { body }</code>), function calls, <code>return</code> statements, and treating functions as first-class values (assignable to variables, passable as arguments, returnable from functions). Recursion must work.</td>\n</tr>\n<tr>\n<td><strong>Lexical Closures</strong></td>\n<td>8 (Closures)</td>\n<td>Functions must capture their <strong>lexical environment</strong> at definition time, creating closures that retain access to variables from outer scopes even after those scopes have exited. Nested functions must be supported.</td>\n</tr>\n<tr>\n<td><strong>Classes &amp; Instances</strong></td>\n<td>9 (Classes)</td>\n<td>Support class declarations (<code>class Name { methods }</code>), instance creation (<code>ClassName()</code>), property access (<code>instance.field</code>), method calls (<code>instance.method()</code>), and the <code>this</code> keyword bound to the instance within methods. An <code>init()</code> method serves as the constructor.</td>\n</tr>\n<tr>\n<td><strong>Single Inheritance</strong></td>\n<td>10 (Inheritance)</td>\n<td>Support subclassing via <code>class Derived &lt; Base</code>. Derived classes inherit methods from their superclass. The <code>super</code> keyword must invoke superclass methods from within overridden methods. <code>super.init()</code> must be callable within a derived class&#39;s <code>init</code>.</td>\n</tr>\n</tbody></table>\n<p>These nine categories represent the complete syntactic and semantic feature set of the Lox language. A successful interpreter must correctly execute Lox programs utilizing any combination of these features.</p>\n<h3 id=\"non-functional-goals-amp-non-goals\">Non-Functional Goals &amp; Non-Goals</h3>\n<p>While functional goals define <em>what</em> the interpreter does, non-functional goals define <em>how well</em> it does them and what qualities we prioritize. For an educational project, clarity, simplicity, and learning value take precedence over performance, robustness, or production readiness.</p>\n<h4 id=\"non-functional-goals-priorities\">Non-Functional Goals (Priorities)</h4>\n<ol>\n<li><p><strong>Clarity and Readability of Implementation:</strong> The code should be structured to be understandable by a developer learning interpreter construction. This means favoring explicit, well-named functions over clever optimizations, using consistent patterns (like the Visitor pattern for AST traversal), and adding explanatory comments for non-obvious algorithms.</p>\n</li>\n<li><p><strong>Educational Value:</strong> Each component should illustrate a fundamental concept of language implementation (lexical analysis, recursive descent parsing, environment-based evaluation, closure capture, etc.). The architecture should make these concepts visible and decoupled.</p>\n</li>\n<li><p><strong>Incremental Buildability:</strong> The design must support implementation in the order of the 10 milestones, where each milestone yields a testable, functional subset of the interpreter. Earlier milestones should not require knowledge or infrastructure from later ones.</p>\n</li>\n<li><p><strong>Helpful Error Reporting:</strong> When the interpreter encounters an error (lexical, syntactic, or runtime), it should report the error with a clear message and the precise source location (line number, ideally column). This aids debugging for both the interpreter user and the implementer.</p>\n</li>\n<li><p><strong>Correctness for the Lox Specification:</strong> The interpreter&#39;s behavior must match the semantics described in <em>Crafting Interpreters</em>. Edge cases (e.g., truthiness, string concatenation with non-strings, inheritance chains) should be handled as specified.</p>\n</li>\n</ol>\n<h4 id=\"non-goals-explicitly-out-of-scope\">Non-Goals (Explicitly Out of Scope)</h4>\n<p>The following are explicitly <strong>not</strong> goals for this project. Including them would expand scope beyond the core educational objectives, add significant complexity, and distract from understanding the foundational concepts.</p>\n<table>\n<thead>\n<tr>\n<th>Non-Goal Category</th>\n<th>Specific Exclusions</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Performance</strong></td>\n<td>No performance optimization (e.g., bytecode compilation, JIT, AST caching, hash table optimization), no benchmarking against other interpreters.</td>\n<td>The primary aim is education, not speed. A tree-walking interpreter is inherently slower than a bytecode VM; optimizing it would add complexity without illuminating new core concepts.</td>\n</tr>\n<tr>\n<td><strong>Tooling &amp; Ergonomics</strong></td>\n<td>No REPL (Read-Eval-Print Loop), no debugger, no syntax highlighting, no language server protocol support.</td>\n<td>These are valuable tools but are separate projects that build <em>upon</em> a working interpreter. They would significantly increase scope.</td>\n</tr>\n<tr>\n<td><strong>Standard Library</strong></td>\n<td>No built-in functions (e.g., <code>clock()</code>, <code>input()</code>, <code>type()</code>), no data structures beyond classes, no I/O beyond <code>print</code>.</td>\n<td>Lox as defined in the book has a minimal runtime. Adding a standard library involves designing APIs and implementing native functions, which is a separate topic (native interop).</td>\n</tr>\n<tr>\n<td><strong>Memory Management</strong></td>\n<td>No garbage collection implementation. We rely on the host language&#39;s (e.g., Java) garbage collector to reclaim unused <code>LoxInstance</code>, <code>LoxFunction</code>, and <code>Environment</code> objects.</td>\n<td>Implementing a garbage collector is a major project unto itself. For simplicity, we assume automatic memory management by the host platform.</td>\n</tr>\n<tr>\n<td><strong>Native Extensions</strong></td>\n<td>No ability to call functions written in the host language (Java/C/Rust) from Lox, nor to embed the interpreter in a larger application.</td>\n<td>Interoperability introduces complex binding and type conversion logic. The project focuses on implementing a self-contained language.</td>\n</tr>\n<tr>\n<td><strong>Language Extensions</strong></td>\n<td>No additional syntax or features beyond standard Lox (e.g., no <code>+=</code> operators, no <code>switch</code> statements, no <code>try</code>/<code>catch</code>, no modules).</td>\n<td>Staying true to the book&#39;s specification ensures the project remains focused and comparable to reference implementations.</td>\n</tr>\n<tr>\n<td><strong>Concurrency</strong></td>\n<td>No threads, no async/await, no parallelism.</td>\n<td>Concurrency introduces immense complexity in state management and is orthogonal to the core interpreter pipeline.</td>\n</tr>\n<tr>\n<td><strong>Robust Production Deployment</strong></td>\n<td>No sandboxing, no security model, no support for multi-file programs/imports, no detailed logging or monitoring.</td>\n<td>This is a learning project, not a production engine.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>ADR: Tree-Walking Interpreter vs. Bytecode Virtual Machine</strong></p>\n<ul>\n<li><strong>Context:</strong> We must choose the core execution strategy for our Lox interpreter. The two primary patterns presented in <em>Crafting Interpreters</em> are the tree-walking interpreter (Part I) and the bytecode virtual machine (Part II).</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Tree-Walking Interpreter:</strong> Directly traverses the AST, executing nodes by recursively evaluating their children and combining results.</li>\n<li><strong>Bytecode Virtual Machine:</strong> Compiles the AST to a dense bytecode instruction stream, then executes it using a stack-based virtual machine.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Implement a <strong>tree-walking interpreter</strong>.</li>\n<li><strong>Rationale:</strong> The tree-walking approach has a more direct correspondence between the source code structure (AST) and execution logic, making it easier to understand, debug, and incrementally build. It requires less upfront infrastructure (no compiler, no bytecode definition, no VM loop). It perfectly serves the educational goal of understanding semantic evaluation without the added complexity of an intermediate representation and virtual machine.</li>\n<li><strong>Consequences:</strong> The interpreter will be simpler to implement and understand but will be slower (often 5-10x) than a bytecode VM. This is an acceptable trade-off for learning. The design cleanly separates scanning, parsing, and interpreting phases.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Tree-Walking Interpreter</strong></td>\n<td>Direct mapping from AST to execution; simpler to implement and debug; less code; ideal for incremental milestones.</td>\n<td>Slower execution speed; repeated traversal of AST nodes; less illustrative of production interpreter techniques.</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td><strong>Bytecode Virtual Machine</strong></td>\n<td>Faster execution; introduces important concepts of compilation and VM design; more realistic for production languages.</td>\n<td>Significantly more complex; requires designing bytecode, compiler, and VM; harder to debug; larger upfront investment.</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>By adhering to these goals and non-goals, the project remains a focused, educational journey through the essential components of a dynamic language interpreter, providing maximum learning value within a manageable scope.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Recommended)</th>\n<th>Advanced Option (If Curious)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Project Structure</strong></td>\n<td>Single-language monolithic project (Java).</td>\n<td>Multi-language comparison (implement scanner in C, parser in Java, interpreter in Rust).</td>\n</tr>\n<tr>\n<td><strong>Build System</strong></td>\n<td>Maven or Gradle for Java; simple <code>Makefile</code> for C; Cargo for Rust.</td>\n<td>Custom build scripts integrating multiple languages.</td>\n</tr>\n<tr>\n<td><strong>Testing Framework</strong></td>\n<td>JUnit (Java), Catch2 (C), <code>cargo test</code> (Rust). Use simple assertion libraries.</td>\n<td>Property-based testing (e.g., jqwik for Java) for generative tests.</td>\n</tr>\n<tr>\n<td><strong>Error Reporting</strong></td>\n<td>Print errors with line numbers to <code>stderr</code>.</td>\n<td>Fancy error formatting with source code snippets and underlines.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong>\nOrganize your code by the logical phases of the interpreter. This separation of concerns makes the codebase navigable and mirrors the architectural diagram.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox-interpreter/                    # Project root\n├── src/main/java/com/craftinginterpreters/lox/\n│   ├── Lox.java                    # Main entry point: reads file, drives pipeline\n│   ├── Token.java                  # Token data class (type, lexeme, literal, line)\n│   ├── TokenType.java              # Enum of all token types (IF, PLUS, IDENTIFIER, etc.)\n│   │\n│   ├── scanner/                    # Milestone 1\n│   │   └── Scanner.java            # Converts source string to List&lt;Token&gt;\n│   │\n│   ├── ast/                        # Milestone 2\n│   │   ├── Expr.java               # Abstract base class for expressions\n│   │   ├── Stmt.java               # Abstract base class for statements\n│   │   ├── *.java                  # Concrete subclasses: Binary, Unary, Literal, Var, etc.\n│   │   └── AstPrinter.java         # Visitor that prints AST as S-expressions\n│   │\n│   ├── parser/                     # Milestone 3\n│   │   └── Parser.java             # Recursive descent parser: List&lt;Token&gt; -&gt; List&lt;Stmt&gt;\n│   │\n│   ├── interpreter/                # Milestones 4-10\n│   │   ├── Interpreter.java        # Main tree-walking interpreter, implements Expr.Visitor&lt;Void&gt;, Stmt.Visitor&lt;Void&gt;\n│   │   ├── Environment.java        # Chain of scopes for variable storage\n│   │   ├── RuntimeError.java       # Exception for runtime errors (e.g., type mismatch)\n│   │   ├── LoxCallable.java        # Interface for functions/classes\n│   │   ├── LoxFunction.java        # Represents a user-defined function (closure)\n│   │   ├── LoxClass.java           # Represents a class\n│   │   └── LoxInstance.java        # Represents an instance of a class\n│   │\n│   └── utils/                      # Utilities\n│       └── ErrorReporter.java      # Centralized error reporting (optional)\n├── lib/                            # Dependencies (if any)\n└── test/                           # Unit tests (parallel to src structure)</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code (COMPLETE, ready to use):</strong>\nHere is a complete, minimal <code>Token</code> class and <code>TokenType</code> enum as they are foundational and not the core learning challenge of any milestone.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TokenType.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Single-character tokens.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LEFT_PAREN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RIGHT_PAREN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LEFT_BRACE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RIGHT_BRACE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMMA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">DOT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">MINUS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">PLUS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SEMICOLON</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SLASH</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">STAR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // One or two character tokens.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BANG</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">BANG_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EQUAL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">EQUAL_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GREATER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">GREATER_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LESS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LESS_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Literals.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IDENTIFIER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">STRING</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NUMBER</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Keywords.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AND</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">CLASS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ELSE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FALSE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FUN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FOR</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">IF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NIL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">OR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRINT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RETURN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SUPER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">THIS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TRUE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">VAR</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">WHILE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EOF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Token.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> TokenType type;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> String lexeme;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Object literal;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">lexeme</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">literal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.lexeme </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lexeme;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.literal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> literal;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> type </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> literal;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code (for the main driver):</strong>\nThe <code>Lox</code> class is the entry point. It demonstrates the high-level pipeline.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Lox.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.BufferedReader;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.IOException;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.InputStreamReader;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.nio.charset.Charset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.nio.file.Files;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.nio.file.Paths;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Lox</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Add a static errorReporter field or use a global flag to track if an error occurred.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadRuntimeError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">[] </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (args.length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Usage: jlox [script]\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (args.length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            runFile</span><span style=\"color:#E1E4E8\">(args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            runPrompt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runFile</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        byte</span><span style=\"color:#E1E4E8\">[] bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Files.</span><span style=\"color:#B392F0\">readAllBytes</span><span style=\"color:#E1E4E8\">(Paths.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(path));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> String</span><span style=\"color:#E1E4E8\">(bytes, Charset.</span><span style=\"color:#B392F0\">defaultCharset</span><span style=\"color:#E1E4E8\">()));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If there was a scan or parse error, exit with code 65 (data error).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (hadError) System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">65</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If there was a runtime error, exit with code 70 (software error).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (hadRuntimeError) System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">70</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runPrompt</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        InputStreamReader input </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> InputStreamReader</span><span style=\"color:#E1E4E8\">(System.in);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BufferedReader reader </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> BufferedReader</span><span style=\"color:#E1E4E8\">(input);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (;;) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"> \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            String line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reader.</span><span style=\"color:#B392F0\">readLine</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (line </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            run</span><span style=\"color:#E1E4E8\">(line);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Reset error flag for interactive session so errors don't kill the REPL.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Instantiate the Scanner with the source string.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Scanner scanner = new Scanner(source);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Call scanner.scanTokens() to get a List&#x3C;Token>.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // List&#x3C;Token> tokens = scanner.scanTokens();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Instantiate the Parser with the tokens.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Parser parser = new Parser(tokens);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 8: Call parser.parse() to get a List&#x3C;Stmt>.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // List&#x3C;Stmt> statements = parser.parse();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 9: Stop if there was a parse error (indicated by hadError).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // if (hadError) return;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 10: Instantiate the Interpreter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Interpreter interpreter = new Interpreter();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 11: Call interpreter.interpret(statements) to execute the program.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // interpreter.interpret(statements);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 12: Implement error reporting methods (static) that print to stderr and set hadError.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // public static void error(int line, String message) { ... }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // public static void error(Token token, String message) { ... }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // public static void runtimeError(RuntimeError error) { ... }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Java):</strong></p>\n<ul>\n<li>Use <code>java.util.HashMap</code> for <code>Environment</code> values map and <code>LoxInstance</code> fields.</li>\n<li>Use <code>java.util.List</code> for sequences (tokens, statements, parameters).</li>\n<li>For the Visitor pattern, define interfaces <code>Expr.Visitor&lt;R&gt;</code> and <code>Stmt.Visitor&lt;R&gt;</code> with visit methods for each node type. Have <code>Interpreter</code> implement these interfaces.</li>\n<li>Use <code>Double</code> for Lox number values. Be careful with equality comparisons (<code>==</code> on <code>Double</code> objects); consider checking for <code>double</code> values within an epsilon for numeric equality, but for simplicity, you can use <code>equals</code> for Lox&#39;s <code>==</code> operator (but note <code>Double.NaN</code>).</li>\n<li>Represent Lox <code>nil</code> as Java <code>null</code>. Represent Lox booleans as Java <code>Boolean</code>.</li>\n<li>For runtime errors, define a custom <code>RuntimeError</code> exception class that extends <code>RuntimeException</code> and holds a <code>Token</code> for location.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint (Verification for Section 2):</strong>\nAfter setting up the project structure and the basic <code>Lox</code> driver with the skeleton above, you can verify your environment works:</p>\n<ul>\n<li><strong>Command:</strong> <code>javac -d out src/main/java/com/craftinginterpreters/lox/*.java src/main/java/com/craftinginterpreters/lox/scanner/*.java ...</code> (or use your build tool)</li>\n<li><strong>Expected:</strong> Successful compilation with no errors (just warnings about unused imports/todos).</li>\n<li><strong>Manual Test:</strong> Create a simple Lox file <code>test.lox</code> with <code>print &quot;Hello, world!&quot;;</code>. Run your interpreter (once you implement the pipeline). You should see <code>&quot;Hello, world!&quot;</code> printed.</li>\n<li><strong>Signs of Trouble:</strong> If you encounter <code>ClassNotFoundException</code> or <code>NoClassDefFoundError</code>, check your classpath and package declarations.</li>\n</ul>\n<p><strong>G. Debugging Tips for Goals Alignment:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Interpreter supports <code>+=</code> operator.</td>\n<td>Implemented language extension beyond Lox spec.</td>\n<td>Review scanner and parser for non-standard tokens/grammar rules.</td>\n<td>Remove support for <code>+=</code> to stay true to the book&#39;s Lox language.</td>\n</tr>\n<tr>\n<td>Function does not capture outer variables (closure broken).</td>\n<td>Environment capture strategy is incorrect (copy vs. reference).</td>\n<td>Print environment chain during function call; check if parent environment is the defining one.</td>\n<td>Ensure <code>LoxFunction</code> stores a reference to the <em>defining</em> environment, not a copy or the current one.</td>\n</tr>\n<tr>\n<td>Interpreter is extremely slow on loops.</td>\n<td>Tree-walking interpreter overhead.</td>\n<td>Profile to confirm; this is expected.</td>\n<td>Acceptable for learning. If performance is critical, consider later moving to a bytecode VM (non-goal for this project).</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational architecture)</p>\n</blockquote>\n<h2 id=\"3-high-level-architecture\">3. High-Level Architecture</h2>\n<p>This section outlines the macro-architecture of the Lox interpreter, providing a mental map of how source code transforms into executable behavior. The system follows a classic <strong>compiler pipeline</strong> pattern, though it culminates in interpretation rather than code generation. The primary architectural challenge is managing the distinct responsibilities of <strong>static structure analysis</strong> (lexing and parsing) and <strong>dynamic execution</strong> (evaluation), while ensuring state is properly scoped and managed across the lifetime of a program.</p>\n<h3 id=\"component-overview-and-data-flow\">Component Overview and Data Flow</h3>\n<p>At its heart, the interpreter is a linear, <strong>unidirectional pipeline</strong> composed of three core transformational components. Imagine a manufacturing assembly line: raw material (source code) enters at one end, is shaped and assembled through successive stations, and a finished product (program output) emerges at the other. Each station is stateless with respect to the others, consuming the output of the previous station and producing input for the next.</p>\n<p>The following diagram illustrates this pipeline and the key data structures that flow between components:</p>\n<p><img src=\"/api/project/build-interpreter/architecture-doc/asset?path=diagrams%2Fdiagram-system.svg\" alt=\"High-Level System Component Diagram\"></p>\n<p><strong>The Pipeline Stages:</strong></p>\n<ol>\n<li><p><strong>Scanner (Lexer) → Tokens:</strong> The Scanner acts as the pipeline&#39;s initial quality inspector and disassembler. It consumes a raw string of Lox source code and breaks it down into its smallest meaningful parts, called <strong>Tokens</strong>. This process, known as <strong>lexical analysis</strong>, strips away whitespace and comments, recognizes keywords and operators, and extracts literals (strings and numbers). Its output is a flat, sequential list of <code>Token</code> objects, each tagged with a type, the original text (lexeme), the literal value (if any), and its source location.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> The Scanner&#39;s job is purely syntactic recognition—it doesn&#39;t understand that <code>var</code> starts a declaration or that <code>(</code> groups an expression. It only knows that the characters <code>v</code>,<code>a</code>,<code>r</code> in sequence form the <code>VAR</code> token.</p>\n</blockquote>\n</li>\n<li><p><strong>Parser → Abstract Syntax Tree (AST):</strong> The Parser is the assembly line&#39;s robotic arm that organizes parts into a structured form. It consumes the linear list of <code>Token</code>s and, following Lox&#39;s <strong>grammar rules</strong>, builds a hierarchical <strong>Abstract Syntax Tree (AST)</strong>. This tree captures the grammatical nesting and operator precedence inherent in the source code. For example, the expression <code>1 + 2 * 3</code> is parsed into a tree where the multiplication node is a child of the addition node, correctly representing that <code>*</code> has higher precedence. The parser&#39;s output is a <code>List&lt;Stmt&gt;</code>, representing the sequence of top-level statements in the program.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> The AST is a <em>static</em> representation of the program&#39;s <em>syntax</em>. It is completely agnostic to runtime values, state, or execution order. It answers &quot;what is the structure of this code?&quot; not &quot;what does this code do when run?&quot;</p>\n</blockquote>\n</li>\n<li><p><strong>Interpreter → Program Output/Side Effects:</strong> The Interpreter is the final station where the assembled product is activated. It performs a <strong>tree-walk</strong> over the AST, recursively evaluating each node according to the <strong>semantic rules</strong> of Lox. This is where static syntax meets dynamic behavior: expressions compute values, statements execute commands, and control flow directives direct the walk&#39;s path. The interpreter&#39;s primary output is side effects: printed text to the console, changes to variable state, or, in a more advanced system, network calls or file I/O.</p>\n</li>\n</ol>\n<p><strong>The Persistent Runtime State: The Environment</strong></p>\n<p>While the three core components form a pipeline, the <strong>Interpreter</strong> requires a persistent, dynamic data structure to track program state: the <strong>Environment</strong>. An <code>Environment</code> is a scoped mapping from variable names to their current runtime values. It is not a stage in the pipeline but rather a <strong>supporting actor</strong> that the Interpreter consults and modifies during execution.</p>\n<ul>\n<li><strong>Structure:</strong> Environments form a <strong>chain</strong> via parent (<code>enclosing</code>) references. The global scope is the root of this chain. Each new block or function call creates a new child environment. Variable resolution proceeds from the current environment outward toward the global scope.</li>\n<li><strong>Lifetime:</strong> The Environment chain is built and torn down dynamically at runtime, mirroring the call stack and block structure of the program. This is a key distinction from the AST, which is built once statically.</li>\n</ul>\n<p><strong>End-to-End Data Transformation Flow:</strong></p>\n<p>The following table traces the complete data transformation for a simple Lox program, <code>print &quot;Hello, &quot; + &quot;world!&quot;;</code>.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Pipeline Stage</th>\n<th align=\"left\">Input</th>\n<th align=\"left\">Core Action</th>\n<th align=\"left\">Output</th>\n<th align=\"left\">Key Data Structure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Scanner</strong></td>\n<td align=\"left\"><code>String</code>: <code>&#39;print &quot;Hello, &quot; + &quot;world!&quot;;&#39;</code></td>\n<td align=\"left\">Scan characters, categorize lexemes, ignore whitespace.</td>\n<td align=\"left\"><code>List&lt;Token&gt;</code>: <code>[PRINT, STRING(&quot;Hello, &quot;), PLUS, STRING(&quot;world!&quot;), SEMICOLON, EOF]</code></td>\n<td align=\"left\"><code>Token</code> (type, lexeme, literal, line)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Parser</strong></td>\n<td align=\"left\"><code>List&lt;Token&gt;</code> (from Scanner)</td>\n<td align=\"left\">Recursively group tokens according to grammar rules (e.g., <code>STRING + STRING</code> → a <code>Binary</code> expression).</td>\n<td align=\"left\"><code>List&lt;Stmt&gt;</code>: <code>[PrintStmt(BinaryExpr(Literal(&quot;Hello, &quot;), PLUS, Literal(&quot;world!&quot;)))]</code></td>\n<td align=\"left\"><code>Expr</code> and <code>Stmt</code> node hierarchy</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Interpreter</strong></td>\n<td align=\"left\"><code>List&lt;Stmt&gt;</code> (from Parser)</td>\n<td align=\"left\">Walk AST: Evaluate <code>BinaryExpr</code> (string concatenation) → <code>&quot;Hello, world!&quot;</code>, pass to <code>PrintStmt</code>.</td>\n<td align=\"left\"><strong>Side Effect</strong>: <code>&quot;Hello, world!&quot;</code> printed to stdout.</td>\n<td align=\"left\">Runtime values (<code>LoxString</code>, <code>LoxNumber</code>, etc.), <code>Environment</code> chain</td>\n</tr>\n</tbody></table>\n<p><strong>Key Architectural Decisions:</strong></p>\n<blockquote>\n<p><strong>Decision: Tree-Walking Interpreter vs. Bytecode Virtual Machine</strong></p>\n<ul>\n<li><strong>Context:</strong> We must choose a strategy for executing Lox programs. The core choice is between directly traversing the AST (tree-walking) or compiling to an intermediate bytecode and executing that on a virtual stack machine.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Tree-Walking Interpreter:</strong> The interpreter recursively traverses the AST, executing operations at each node.</li>\n<li><strong>Bytecode Virtual Machine (VM):</strong> A separate compiler phase transforms the AST into a linear sequence of bytecode instructions. A separate VM with a stack and instruction pointer executes this bytecode.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Implement a <strong>Tree-Walking Interpreter</strong>.</li>\n<li><strong>Rationale:</strong> This is an educational project where clarity and direct mapping from language semantics to implementation are paramount. A tree-walker&#39;s control flow mirrors the recursive structure of the language grammar, making it easier to understand and debug. The performance penalty of tree-walking is acceptable for our learning goals.</li>\n<li><strong>Consequences:</strong> The interpreter logic is interwoven with the AST traversal (via the Visitor pattern). This simplifies the initial architecture but makes certain optimizations (like direct jumps for loops) more awkward. It also means runtime errors must be propagated via exception handling up the recursive call stack.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Tree-Walking Interpreter</strong></td>\n<td align=\"left\">Simple, direct mapping from syntax to execution. Easier to implement and debug. No separate compiler/VM phase.</td>\n<td align=\"left\">Slower (many pointer indirections). Harder to optimize control flow. Traversal logic can become complex.</td>\n<td align=\"left\"><strong>Yes</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Bytecode VM</strong></td>\n<td align=\"left\">Faster execution (dense bytecode, tight interpreter loop). Clear separation of compile/run phases. Better foundation for optimizations (JIT).</td>\n<td align=\"left\">More complex architecture. Additional concepts (bytecode, stack, IP). Harder to debug execution flow.</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Visitor Pattern for AST Operations</strong></p>\n<ul>\n<li><strong>Context:</strong> We need a clean way to define operations (like evaluation, pretty-printing, static analysis) over our heterogeneous AST node types without resorting to verbose type-checking (<code>instanceof</code>) and casting.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Visitor Pattern:</strong> Define an interface with a <code>visit</code> method for each AST node type. Each node type has an <code>accept(Visitor)</code> method that calls the appropriate <code>visit</code> method.</li>\n<li><strong>Procedural Switch/<code>instanceof</code>:</strong> Write functions that take a base <code>Expr</code> or <code>Stmt</code> and use a switch or if-else chain to handle each concrete type.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Use the <strong>Visitor Pattern</strong>.</li>\n<li><strong>Rationale:</strong> The Visitor pattern cleanly separates the <em>structure</em> of the AST (the node classes) from the <em>operations</em> performed on it. This allows us to add new operations (e.g., a static type checker, a code formatter) without modifying the AST node classes themselves (adhering to the Open/Closed Principle). It also makes the type-dispatching logic explicit and compiler-checked.</li>\n<li><strong>Consequences:</strong> Requires defining two visitor interfaces (<code>ExprVisitor&lt;V&gt;</code>, <code>StmtVisitor&lt;V&gt;</code>) and adding an <code>accept</code> method to every AST node class. This introduces some boilerplate but pays off in maintainability and clarity for the core interpreter operations.</li>\n</ul>\n</blockquote>\n<h3 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h3>\n<p>A well-organized codebase is critical for managing the complexity of an interpreter. The following package structure mirrors the pipeline architecture, grouping related components and isolating concerns. This structure is recommended for the primary implementation language, Java.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/                             # Project root\n├── Lox.java                     # Main entry point (orchestrates pipeline)\n│\n├── scan/                        # Milestone 1: Lexical Analysis\n│   ├── Scanner.java             # Converts source string to tokens\n│   ├── Token.java               # Token data class\n│   └── TokenType.java           # Enumeration of all token types\n│\n├── parse/                       # Milestones 2 &amp; 3: Syntactic Analysis\n│   ├── Parser.java              # Recursive descent parser\n│   ├── ParseError.java          # Checked exception for syntax errors\n│   │\n│   └── ast/                     # Abstract Syntax Tree node definitions\n│       ├── Expr.java            # Abstract base class for expressions\n│       ├── Stmt.java            # Abstract base class for statements\n│       ├── expr/                # Concrete expression nodes\n│       │   ├── Binary.java      # left, operator, right\n│       │   ├── Unary.java       # operator, right\n│       │   ├── Literal.java     # value\n│       │   └── ...              # (Grouping, Variable, Assign, etc.)\n│       └── stmt/                # Concrete statement nodes\n│           ├── Print.java       # expression\n│           ├── Var.java         # name, initializer\n│           └── ...              # (ExpressionStmt, Block, If, While, etc.)\n│\n└── interpret/                   # Milestones 4-10: Execution\n    ├── Interpreter.java         # Tree-walking evaluator (implements ExprVisitor&lt;Object&gt;, StmtVisitor&lt;Void&gt;)\n    ├── RuntimeError.java        # Unchecked exception for runtime errors\n    │\n    ├── environment/             # Runtime state management\n    │   └── Environment.java     # Scoped variable storage (values map, enclosing reference)\n    │\n    └── runtime/                 # Representations of Lox values at runtime\n        ├── LoxCallable.java     # Interface for callable objects (functions, classes)\n        ├── LoxFunction.java     # Represents a Lox function/closure\n        ├── LoxClass.java        # Represents a Lox class\n        ├── LoxInstance.java     # Represents an instance of a class\n        ├── LoxNumber.java       # (Optional) Wrapper for Double\n        ├── LoxString.java       # (Optional) Wrapper for String\n        ├── LoxBoolean.java      # (Optional) Wrapper for Boolean\n        └── LoxNil.java          # Singleton representing nil</code></pre></div>\n\n<p><strong>Package Responsibilities:</strong></p>\n<ul>\n<li><strong><code>lox</code> (Root):</strong> Contains the driver class <code>Lox</code> which coordinates the entire process: reading source (from file or prompt), invoking the scanner, parser, and interpreter, and catching/reporting errors.</li>\n<li><strong><code>scan</code>:</strong> Isolated lexer module. <code>Token</code> and <code>TokenType</code> are simple data/enum types used by both the parser and for error reporting.</li>\n<li><strong><code>parse</code>:</strong> Contains all parsing logic and the immutable AST definition. The <code>ast</code> subpackage is a <strong>closed hierarchy</strong>; once defined, new node types should not be added lightly as they require updates to the parser and all visitors.</li>\n<li><strong><code>interpret</code>:</strong> The heart of runtime execution. It depends on the <code>parse.ast</code> package for the tree structure and contains:<ul>\n<li><code>Interpreter</code>: The main engine.</li>\n<li><code>environment</code>: Manages dynamic scoping.</li>\n<li><code>runtime</code>: Defines the object model for Lox values. These classes encapsulate Lox semantics (e.g., how <code>+</code> works on <code>LoxString</code> vs. <code>LoxNumber</code>).</li>\n</ul>\n</li>\n</ul>\n<p><strong>Data Flow Between Packages:</strong></p>\n<p>The dependencies flow strictly left-to-right, enforcing the pipeline architecture and preventing circular dependencies.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Lox.java\n    │   (Source String)\n    ▼\nscan.Scanner ──── List&lt;Token&gt; ────▶ parse.Parser\n    │                                    │\n    │                                    ▼\n    └──────────── Token ───────────▶ parse.ast.*\n                                          │\n                                          │ (List&lt;Stmt&gt;)\n                                          ▼\n                               interpret.Interpreter\n                                          │\n                                          ├─────▶ interpret.environment.Environment\n                                          │\n                                          └─────▶ interpret.runtime.* (LoxFunction, etc.)</code></pre></div>\n\n<p>This structure provides a clear roadmap for implementation, allowing you to focus on one logical component at a time, from scanning through to advanced runtime features like classes and inheritance.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Recommended)</th>\n<th align=\"left\">Advanced Option (Consider Later)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Project Build</strong></td>\n<td align=\"left\">Plain Java files, compile with <code>javac</code></td>\n<td align=\"left\">Use a build system (Maven, Gradle) for dependency and test management</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>AST Generation</strong></td>\n<td align=\"left\">Hand-written visitor pattern classes</td>\n<td align=\"left\">Use an annotation processor (e.g., Java Poet) or parser generator (ANTLR) to generate boilerplate</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Runtime Value Representation</strong></td>\n<td align=\"left\">Use plain Java types (<code>Double</code>, <code>String</code>, <code>Boolean</code>) with <code>null</code> for nil</td>\n<td align=\"left\">Wrap in dedicated classes (e.g., <code>LoxNumber</code>) for explicit type tagging and custom behavior</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Error Reporting</strong></td>\n<td align=\"left\">Print formatted messages to <code>System.err</code></td>\n<td align=\"left\">Use a structured logging library (SLF4J) or collect errors for IDE integration</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure (Starter)</strong></p>\n<p>Create the following directory and empty Java files to establish the project skeleton. This enforces the architectural separation from the start.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>mkdir -p lox/scan lox/parse/ast/expr lox/parse/ast/stmt lox/interpret/environment lox/interpret/runtime</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>The following are complete, foundational classes that you can use as-is. They define the core data structures that flow between components.</p>\n<p><strong>File: <code>lox/scan/TokenType.java</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> scan;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Exhaustive enum of all token types in Lox.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Based on Chapter 4 of Crafting Interpreters.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Single-character tokens.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LEFT_PAREN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RIGHT_PAREN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LEFT_BRACE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RIGHT_BRACE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMMA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">DOT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">MINUS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">PLUS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SEMICOLON</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SLASH</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">STAR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // One or two character tokens.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BANG</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">BANG_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EQUAL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">EQUAL_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GREATER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">GREATER_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LESS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LESS_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Literals.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IDENTIFIER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">STRING</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NUMBER</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Keywords.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AND</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">CLASS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ELSE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FALSE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FUN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FOR</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">IF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NIL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">OR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRINT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RETURN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SUPER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">THIS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TRUE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">VAR</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">WHILE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EOF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>lox/scan/Token.java</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> scan;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Represents a single lexical token from the source code.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> TokenType type;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> String lexeme;    </span><span style=\"color:#6A737D\">// The raw text of the token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Object literal;   </span><span style=\"color:#6A737D\">// The interpreted value for literals (String, Double, null)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> line;         </span><span style=\"color:#6A737D\">// Source line number (1-indexed) for error reporting</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">lexeme</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">literal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.lexeme </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lexeme;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.literal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> literal;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> type </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> literal;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>lox/interpret/environment/Environment.java</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> interpret.environment;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.HashMap;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Map;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// A chain of scopes mapping variable names to values.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is a core runtime data structure for state management.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The immediately enclosing scope. `null` for the global environment.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Environment enclosing;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Storage for variables defined in this specific scope.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Map&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> values </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> HashMap&#x3C;>();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Constructor for the global scope (no enclosing environment).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.enclosing </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Constructor for a new nested scope.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">(Environment </span><span style=\"color:#FFAB70\">enclosing</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.enclosing </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enclosing;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Defines a new variable in the current scope.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Used for 'var' declarations.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(name, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Gets the value of a variable, searching outward through enclosing scopes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Throws a runtime error if the variable is not found.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (values.</span><span style=\"color:#B392F0\">containsKey</span><span style=\"color:#E1E4E8\">(name.lexeme)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> values.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(name.lexeme);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Look up in the parent scope.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (enclosing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> enclosing.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(name);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#E1E4E8\">(name, </span><span style=\"color:#9ECBFF\">\"Undefined variable '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> name.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Assigns a new value to an existing variable.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Searches outward through enclosing scopes. Throws if variable not found.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> assign</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (values.</span><span style=\"color:#B392F0\">containsKey</span><span style=\"color:#E1E4E8\">(name.lexeme)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            values.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(name.lexeme, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Try to assign in the parent scope.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (enclosing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            enclosing.</span><span style=\"color:#B392F0\">assign</span><span style=\"color:#E1E4E8\">(name, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#E1E4E8\">(name, </span><span style=\"color:#9ECBFF\">\"Undefined variable '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> name.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong>File: <code>lox/Lox.java</code> (Main Driver)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> scan.Scanner;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> scan.Token;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse.Parser;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse.ast.Stmt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> interpret.Interpreter;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.BufferedReader;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.IOException;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.InputStreamReader;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.nio.file.Files;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.nio.file.Paths;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The main entry point. Can run files or a REPL.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Lox</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Static interpreter instance shared across runs in REPL mode.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Interpreter interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Flag to indicate if a parsing or runtime error occurred.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadRuntimeError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">[] </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (args.length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Usage: jlox [script]\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// EX_USAGE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (args.length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            runFile</span><span style=\"color:#E1E4E8\">(args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            runPrompt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read and execute a Lox source file.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runFile</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        byte</span><span style=\"color:#E1E4E8\">[] bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Files.</span><span style=\"color:#B392F0\">readAllBytes</span><span style=\"color:#E1E4E8\">(Paths.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(path));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> String</span><span style=\"color:#E1E4E8\">(bytes, </span><span style=\"color:#9ECBFF\">\"UTF-8\"</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Indicate an error in the exit code.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (hadError) System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">65</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// EX_DATAERR</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (hadRuntimeError) System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">70</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// EX_SOFTWARE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start an interactive Read-Eval-Print Loop (REPL).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runPrompt</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        InputStreamReader input </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> InputStreamReader</span><span style=\"color:#E1E4E8\">(System.in);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BufferedReader reader </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> BufferedReader</span><span style=\"color:#E1E4E8\">(input);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (;;) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"> \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            String line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reader.</span><span style=\"color:#B392F0\">readLine</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (line </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Ctrl-D</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            run</span><span style=\"color:#E1E4E8\">(line);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Reset error flags for the next line in the REPL.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            hadRuntimeError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Core run routine: scan, parse, interpret.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Instantiate the Scanner with the source string.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Call scanner.scanTokens() to get the token list.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Instantiate the Parser with the token list.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Call parser.parse() to get the statement list.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: If there were no syntax errors (hadError is false), call interpreter.interpret(statements).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Catch ParseError and RuntimeError exceptions and report them using the error() and runtimeError() methods below.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Error reporting helpers (to be called from Scanner, Parser, Interpreter).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        report</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (token.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TokenType.EOF) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            report</span><span style=\"color:#E1E4E8\">(token.line, </span><span style=\"color:#9ECBFF\">\" at end\"</span><span style=\"color:#E1E4E8\">, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            report</span><span style=\"color:#E1E4E8\">(token.line, </span><span style=\"color:#9ECBFF\">\" at '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> token.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'\"</span><span style=\"color:#E1E4E8\">, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> report</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.err.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[line \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"] Error\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> where </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \": \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runtimeError</span><span style=\"color:#E1E4E8\">(RuntimeError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.err.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(error.</span><span style=\"color:#B392F0\">getMessage</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">[line \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> error.token.line </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"]\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hadRuntimeError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Java)</strong></p>\n<ul>\n<li><strong>Visitor Pattern Implementation:</strong> Use generic interfaces <code>ExprVisitor&lt;R&gt;</code> and <code>StmtVisitor&lt;R&gt;</code> with a generic return type <code>R</code>. This allows the interpreter to return <code>Object</code> (values) and <code>Void</code> (for statements).</li>\n<li><strong>Runtime Value Representation:</strong> Java&#39;s <code>Double</code>, <code>String</code>, and <code>Boolean</code> can be used directly, with <code>null</code> representing Lox&#39;s <code>nil</code>. For type checking, use <code>instanceof</code> (e.g., <code>if (leftOperand instanceof Double)</code>).</li>\n<li><strong>Immutability:</strong> Make AST node fields <code>final</code> to ensure they are immutable after construction. This prevents accidental modification and simplifies reasoning.</li>\n<li><strong>Error Handling:</strong> Use a custom <code>ParseError</code> (extends <code>RuntimeException</code>) for syntax errors to enable panic-mode recovery in the parser. Use a custom <code>RuntimeError</code> (also extends <code>RuntimeException</code>) for runtime errors like type mismatches.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint (Architecture Verification)</strong></p>\n<p>After setting up the skeleton structure and the <code>Lox</code> driver class, you can verify the pipeline is plumbed correctly with a simple test:</p>\n<ol>\n<li><strong>Create a test file:</strong> <code>test.lox</code> containing a single line: <code>print &quot;Hello, world!&quot;;</code></li>\n<li><strong>Run the driver:</strong> <code>java lox.Lox test.lox</code></li>\n<li><strong>Expected Output at this stage:</strong> The program should compile without errors. When run, it may do nothing (if the scanner/parser/interpreter are stubs) or throw a <code>NullPointerException</code>. The key is that the project structure is in place and the main class runs without compilation errors.</li>\n<li><strong>Next Step:</strong> The first real output will come after implementing the <strong>Scanner (Milestone 1)</strong>, when you can print the list of tokens to verify lexing works.</li>\n</ol>\n<h2 id=\"4-data-model\">4. Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational data structures)</p>\n</blockquote>\n<p>This section defines the core immutable data structures that form the backbone of our interpreter. Think of these as the <strong>permanent artifacts</strong> produced and consumed as source code moves through the interpretation pipeline. Unlike the procedural logic of scanning, parsing, or evaluating, these data structures are the <strong>static definitions</strong> that represent the program at each phase of its lifecycle. Properly designing these structures is crucial because they determine how information flows between components and what capabilities our interpreter can support.</p>\n<p>The data model has four interrelated layers:</p>\n<ol>\n<li><strong>Tokens</strong> – The atomic units of meaning from the source text</li>\n<li><strong>AST Nodes</strong> – The hierarchical tree structure representing program syntax  </li>\n<li><strong>Runtime Values</strong> – The living data that exists during program execution</li>\n<li><strong>Environments</strong> – The scoped namespace that maps variable names to runtime values</li>\n</ol>\n<p>Each layer builds upon the previous one, creating a clear separation between static structure and dynamic execution. This separation is fundamental to the interpreter&#39;s architecture—it allows us to reason about the program&#39;s syntax independently from its runtime behavior.</p>\n<h3 id=\"tokens-the-lexical-atoms\">Tokens: The Lexical Atoms</h3>\n<p><strong>Mental Model: The Scrabble Tiles</strong></p>\n<blockquote>\n<p>Think of tokens as Scrabble tiles formed from the continuous stream of source code letters. The scanner&#39;s job is to break the text into these discrete, categorized tiles—some represent numbers (<code>5.2</code>), others operators (<code>+</code>), keywords (<code>var</code>), or punctuation (<code>;</code>). Each tile carries not just its face value (the actual text) but also its classification (is this tile an addition operator or a string concatenator?). These tiles are then passed to the parser, which assembles them into meaningful structures according to grammatical rules.</p>\n</blockquote>\n<p>Tokens are the smallest meaningful units produced by the <strong>Scanner</strong> (Milestone 1). They represent the categorized lexical elements of the Lox language, stripping away insignificant whitespace and comments while preserving the essential structure of the source code.</p>\n<p><strong>Token Structure</strong>\nEvery token contains four pieces of information that collectively identify what it represents and where it came from:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>type</code></td>\n<td><code>TokenType</code></td>\n<td>The category of token (e.g., <code>PLUS</code>, <code>IDENTIFIER</code>, <code>NUMBER</code>). Determines how the parser will interpret this token.</td>\n</tr>\n<tr>\n<td><code>lexeme</code></td>\n<td><code>String</code></td>\n<td>The actual text from the source code that generated this token. For the source <code>123.45</code>, the lexeme would be <code>&quot;123.45&quot;</code>.</td>\n</tr>\n<tr>\n<td><code>literal</code></td>\n<td><code>Object</code></td>\n<td>The runtime value associated with the token, if any. For a number token, this would be a <code>Double</code>; for a string token, a <code>String</code>; for identifiers and keywords, <code>null</code>.</td>\n</tr>\n<tr>\n<td><code>line</code></td>\n<td><code>int</code></td>\n<td>The line number in the source file where this token begins (1-indexed). Critical for error reporting.</td>\n</tr>\n</tbody></table>\n<p><strong>TokenType Enumeration</strong>\nThe <code>TokenType</code> enumeration defines all possible token categories in Lox. Each token type corresponds to a specific lexical pattern in the language grammar. The complete set includes:</p>\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Examples</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Single-character tokens</strong></td>\n<td><code>LEFT_PAREN</code>, <code>RIGHT_PAREN</code>, <code>LEFT_BRACE</code>, <code>RIGHT_BRACE</code>, <code>COMMA</code>, <code>DOT</code>, <code>MINUS</code>, <code>PLUS</code>, <code>SEMICOLON</code>, <code>SLASH</code>, <code>STAR</code></td>\n<td>These map directly to individual characters in source code.</td>\n</tr>\n<tr>\n<td><strong>One-or-two character tokens</strong></td>\n<td><code>BANG</code>, <code>BANG_EQUAL</code>, <code>EQUAL</code>, <code>EQUAL_EQUAL</code>, <code>GREATER</code>, <code>GREATER_EQUAL</code>, <code>LESS</code>, <code>LESS_EQUAL</code></td>\n<td>The scanner must look ahead to distinguish <code>!</code> from <code>!=</code>.</td>\n</tr>\n<tr>\n<td><strong>Literals</strong></td>\n<td><code>IDENTIFIER</code>, <code>STRING</code>, <code>NUMBER</code></td>\n<td>These tokens carry additional value in their <code>literal</code> field.</td>\n</tr>\n<tr>\n<td><strong>Keywords</strong></td>\n<td><code>AND</code>, <code>CLASS</code>, <code>ELSE</code>, <code>FALSE</code>, <code>FUN</code>, <code>FOR</code>, <code>IF</code>, <code>NIL</code>, <code>OR</code>, <code>PRINT</code>, <code>RETURN</code>, <code>SUPER</code>, <code>THIS</code>, <code>TRUE</code>, <code>VAR</code>, <code>WHILE</code></td>\n<td>Reserved words that cannot be used as identifiers.</td>\n</tr>\n<tr>\n<td><strong>End-of-file</strong></td>\n<td><code>EOF</code></td>\n<td>A special sentinel token indicating the end of the input stream.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The <code>literal</code> field uses Java&#39;s <code>Object</code> type (which can be <code>null</code>) rather than a dedicated union type because it simplifies the implementation while maintaining type safety through careful programming. For number literals, we store <code>Double</code>; for string literals, <code>String</code>; for <code>true</code>/<code>false</code>/<code>nil</code> keywords, we use the corresponding runtime value objects (which we&#39;ll define later). This design allows the scanner to produce values that can flow directly into the interpreter without conversion.</p>\n</blockquote>\n<p><strong>Token Lifecycle</strong></p>\n<ol>\n<li><strong>Creation</strong>: The scanner creates tokens as it recognizes lexical patterns in the source text. For example, when it encounters the sequence <code>&quot;hello&quot;</code>, it creates a <code>Token</code> with <code>type=STRING</code>, <code>lexeme=&quot;\\&quot;hello\\&quot;&quot;</code>, <code>literal=&quot;hello&quot;</code> (without quotes), and <code>line</code> set to the current line.</li>\n<li><strong>Consumption</strong>: The parser receives the stream of tokens and uses their <code>type</code> fields to guide parsing decisions. The <code>literal</code> field may be used to embed constant values directly into the AST.</li>\n<li><strong>Error Reporting</strong>: When a parse or runtime error occurs, the associated token&#39;s <code>line</code> (and potentially <code>lexeme</code>) is used to generate a user-friendly error message like <code>&quot;Error at line 5: Unexpected token &#39;}&#39;&quot;</code>.</li>\n</ol>\n<p><strong>ADR: Token Representation Strategy</strong></p>\n<blockquote>\n<p><strong>Decision: Unified Token Class with Optional Literal Field</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to represent categorized lexical elements with associated metadata (source location, actual text, and sometimes a computed value).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Separate token classes for each type</strong>: Create distinct <code>IdentifierToken</code>, <code>NumberToken</code>, <code>OperatorToken</code> etc., each with type-specific fields.</li>\n<li><strong>Tagged union/discriminated record</strong>: Use a single <code>Token</code> type with an enum tag and type-specific data in a union (not natively supported in Java).</li>\n<li><strong>Unified class with optional fields</strong>: One <code>Token</code> class with fields for all possible metadata, some of which may be <code>null</code>.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use a single <code>Token</code> class with all four fields, where <code>literal</code> may be <code>null</code> for tokens without associated values.</li>\n<li><strong>Rationale</strong>: This approach is simple to implement in Java, minimizes class explosion, and matches the typical Java pattern for token representation. The occasional <code>null</code> checks are acceptable given the small number of token types that carry literals. It also keeps the scanner and parser logic straightforward.</li>\n<li><strong>Consequences</strong>: We get a clean, immutable token representation. However, we must be careful to handle <code>null</code> literals appropriately in the parser and interpreter. Type safety is maintained through discipline rather than the type system.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Separate token classes</td>\n<td>Type-safe, no null checks</td>\n<td>Class explosion, harder to handle generically</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Tagged union</td>\n<td>Type-safe, memory efficient</td>\n<td>Not natively supported in Java, requires pattern matching</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Unified class</td>\n<td>Simple, fewer classes, easy to pass around</td>\n<td>Some fields null for certain tokens, less type-safe</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"ast-nodes-the-program39s-skeleton\">AST Nodes: The Program&#39;s Skeleton</h3>\n<p><strong>Mental Model: The Russian Nesting Dolls</strong></p>\n<blockquote>\n<p>The Abstract Syntax Tree (AST) is like a set of Russian nesting dolls, where each doll contains smaller dolls inside it. A <code>Binary</code> expression doll contains two smaller expression dolls (left and right operands) plus an operator token. A <code>Block</code> statement doll contains a list of statement dolls inside it. The parser&#39;s job is to assemble these nested structures by matching grammatical patterns in the token stream, creating a complete hierarchical representation that mirrors the program&#39;s syntactic structure.</p>\n</blockquote>\n<p>AST nodes form the <strong>canonical representation</strong> of a Lox program&#39;s syntax after parsing (Milestones 2-3). Unlike concrete syntax trees (which include every detail like parentheses and semicolons), the AST abstracts away syntactic noise, leaving only the essential structure needed for execution.</p>\n<p><strong>Node Hierarchy</strong>\nThe AST is composed of two parallel class hierarchies: <code>Expr</code> for expressions (which produce values) and <code>Stmt</code> for statements (which perform actions). Both are abstract base classes that define the Visitor pattern interface.</p>\n<p><strong>Expression Node Types</strong>\nEach expression node type represents a distinct syntactic construct that evaluates to a value:</p>\n<table>\n<thead>\n<tr>\n<th>Node Type</th>\n<th>Key Fields</th>\n<th>Description</th>\n<th>Example Lox Code</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Binary</code></td>\n<td><code>Expr left</code>, <code>Token operator</code>, <code>Expr right</code></td>\n<td>Binary operation with two operands and an operator token.</td>\n<td><code>1 + 2</code></td>\n</tr>\n<tr>\n<td><code>Unary</code></td>\n<td><code>Token operator</code>, <code>Expr right</code></td>\n<td>Unary operation with one operand and an operator token.</td>\n<td><code>-5</code> or <code>!true</code></td>\n</tr>\n<tr>\n<td><code>Grouping</code></td>\n<td><code>Expr expression</code></td>\n<td>Parenthesized expression (for explicit precedence).</td>\n<td><code>(1 + 2) * 3</code></td>\n</tr>\n<tr>\n<td><code>Literal</code></td>\n<td><code>Object value</code></td>\n<td>Constant literal value (number, string, boolean, nil).</td>\n<td><code>42</code>, <code>&quot;hello&quot;</code>, <code>true</code>, <code>nil</code></td>\n</tr>\n<tr>\n<td><code>Variable</code></td>\n<td><code>Token name</code></td>\n<td>Reference to a variable by its name token.</td>\n<td><code>x</code></td>\n</tr>\n<tr>\n<td><code>Assign</code></td>\n<td><code>Token name</code>, <code>Expr value</code></td>\n<td>Assignment to a previously declared variable.</td>\n<td><code>x = 10</code></td>\n</tr>\n<tr>\n<td><code>Logical</code></td>\n<td><code>Expr left</code>, <code>Token operator</code>, <code>Expr right</code></td>\n<td>Logical <code>and</code> or <code>or</code> with short-circuit evaluation.</td>\n<td><code>a and b</code></td>\n</tr>\n<tr>\n<td><code>Call</code></td>\n<td><code>Expr callee</code>, <code>Token paren</code>, <code>List&lt;Expr&gt; arguments</code></td>\n<td>Function or method call with argument list.</td>\n<td><code>foo(1, 2)</code></td>\n</tr>\n<tr>\n<td><code>Get</code></td>\n<td><code>Expr object</code>, <code>Token name</code></td>\n<td>Property access on an instance using dot notation.</td>\n<td><code>obj.property</code></td>\n</tr>\n<tr>\n<td><code>Set</code></td>\n<td><code>Expr object</code>, <code>Token name</code>, <code>Expr value</code></td>\n<td>Property assignment on an instance.</td>\n<td><code>obj.property = 5</code></td>\n</tr>\n<tr>\n<td><code>This</code></td>\n<td><code>Token keyword</code></td>\n<td>Reference to the current instance within a method.</td>\n<td><code>this</code></td>\n</tr>\n<tr>\n<td><code>Super</code></td>\n<td><code>Token keyword</code>, <code>Token method</code></td>\n<td>Reference to a superclass method.</td>\n<td><code>super.method()</code></td>\n</tr>\n</tbody></table>\n<p><strong>Statement Node Types</strong>\nStatement nodes represent syntactic constructs that perform actions but don&#39;t produce values (except for expression statements, which evaluate an expression for side effects):</p>\n<table>\n<thead>\n<tr>\n<th>Node Type</th>\n<th>Key Fields</th>\n<th>Description</th>\n<th>Example Lox Code</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Expression</code></td>\n<td><code>Expr expression</code></td>\n<td>Expression evaluated for side effects.</td>\n<td><code>x + 1;</code></td>\n</tr>\n<tr>\n<td><code>Print</code></td>\n<td><code>Expr expression</code></td>\n<td>Evaluates expression and prints result.</td>\n<td><code>print &quot;hello&quot;;</code></td>\n</tr>\n<tr>\n<td><code>Var</code></td>\n<td><code>Token name</code>, <code>Expr initializer</code></td>\n<td>Variable declaration with optional initializer.</td>\n<td><code>var x = 5;</code></td>\n</tr>\n<tr>\n<td><code>Block</code></td>\n<td><code>List&lt;Stmt&gt; statements</code></td>\n<td>Block of statements creating a new scope.</td>\n<td><code>{ var x = 1; print x; }</code></td>\n</tr>\n<tr>\n<td><code>If</code></td>\n<td><code>Expr condition</code>, <code>Stmt thenBranch</code>, <code>Stmt elseBranch</code></td>\n<td>Conditional execution (else branch may be null).</td>\n<td><code>if (x) print &quot;yes&quot;; else print &quot;no&quot;;</code></td>\n</tr>\n<tr>\n<td><code>While</code></td>\n<td><code>Expr condition</code>, <code>Stmt body</code></td>\n<td>Loop with precondition.</td>\n<td><code>while (x &lt; 10) x = x + 1;</code></td>\n</tr>\n<tr>\n<td><code>Function</code></td>\n<td><code>Token name</code>, <code>List&lt;Token&gt; params</code>, <code>List&lt;Stmt&gt; body</code></td>\n<td>Function declaration (name, parameters, body).</td>\n<td><code>fun add(a, b) { return a + b; }</code></td>\n</tr>\n<tr>\n<td><code>Return</code></td>\n<td><code>Token keyword</code>, <code>Expr value</code></td>\n<td>Return statement from function (value may be null).</td>\n<td><code>return 42;</code></td>\n</tr>\n<tr>\n<td><code>Class</code></td>\n<td><code>Token name</code>, <code>Expr.Variable superclass</code>, <code>List&lt;Stmt.Function&gt; methods</code></td>\n<td>Class declaration with optional superclass.</td>\n<td><code>class Point { init(x, y) { this.x = x; this.y = y; } }</code></td>\n</tr>\n</tbody></table>\n<p><strong>Visitor Pattern Architecture</strong>\nThe Visitor pattern enables <strong>open recursion</strong>—allowing new operations on the AST without modifying the node classes themselves. This is essential because our interpreter will define multiple operations: pretty-printing, static analysis (in advanced implementations), and interpretation.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> The Visitor pattern creates a double dispatch mechanism. When we call <code>accept(visitor)</code> on an AST node, the node calls the appropriate <code>visitXxx</code> method on the visitor, passing itself as an argument. This gives the visitor type-safe access to the node&#39;s specific fields without requiring instanceof checks.</p>\n</blockquote>\n<p><strong>AST Immutability</strong>\nAll AST nodes are <strong>immutable</strong>—their fields are set at construction and never modified. This has several benefits:</p>\n<ol>\n<li><strong>Thread safety</strong>: Though our interpreter is single-threaded, immutability prevents accidental modification.</li>\n<li><strong>Predictable behavior</strong>: An AST can be traversed multiple times without fear of side effects.</li>\n<li><strong>Simpler reasoning</strong>: Once parsed, the program structure doesn&#39;t change during execution.</li>\n</ol>\n<p><img src=\"/api/project/build-interpreter/architecture-doc/asset?path=diagrams%2Fdiagram-ast-hierarchy.svg\" alt=\"AST Node Class Hierarchy\"></p>\n<p><strong>ADR: Visitor Pattern vs. Instanceof Checks</strong></p>\n<blockquote>\n<p><strong>Decision: Visitor Pattern for AST Operations</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to define operations (like evaluation, pretty-printing) that work across the heterogeneous AST node types.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Instanceof checks with casting</strong>: Use a switch on node type with explicit casts in each operation.</li>\n<li><strong>Interpreter method in each node</strong>: Put an <code>interpret()</code> method directly in each AST node class.</li>\n<li><strong>Visitor pattern</strong>: Separate the operations from the node structure using double dispatch.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use the Visitor pattern with separate <code>Expr.Visitor&lt;R&gt;</code> and <code>Stmt.Visitor&lt;V&gt;</code> interfaces.</li>\n<li><strong>Rationale</strong>: The Visitor pattern cleanly separates concerns—node definitions are purely structural, while operations are defined elsewhere. This makes it easy to add new operations (like a static analyzer or code generator) without modifying the AST classes. It&#39;s also the pattern used in the reference &quot;Crafting Interpreters&quot; book, providing consistency for learners.</li>\n<li><strong>Consequences</strong>: We incur some boilerplate (the <code>accept()</code> method in each node), but gain flexibility and organization. The pattern also naturally supports return values from visits (unlike the interpreter-in-each-node approach).</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Instanceof checks</td>\n<td>Simple, no boilerplate</td>\n<td>Type-unsafe, spreads logic across type checks</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Interpreter in each node</td>\n<td>Encapsulated, no casting</td>\n<td>Mixes structure and behavior, hard to add operations</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Visitor pattern</td>\n<td>Separates concerns, extensible, type-safe</td>\n<td>Boilerplate accept methods, more complex</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"runtime-values-the-interpreter39s-currency\">Runtime Values: The Interpreter&#39;s Currency</h3>\n<p><strong>Mental Model: The Theater Props</strong></p>\n<blockquote>\n<p>Runtime values are like props in a theater production. When the interpreter &quot;performs&quot; the program (walks the AST), it needs tangible objects to work with: numbers to calculate, strings to concatenate, function objects to call, and instances to manipulate. Each value type has specific capabilities (a function can be called, a class can be instantiated) just as each prop has a specific purpose (a sword can be swung, a book can be opened). These props are created, passed around, and transformed during the performance.</p>\n</blockquote>\n<p>Runtime values are the <strong>living data</strong> that exist during program execution (Milestones 4-10). They flow through the interpreter as expressions evaluate, get stored in variables, and are passed between functions. The interpreter&#39;s entire purpose is to produce and manipulate these values according to the semantics defined by the AST structure.</p>\n<p><strong>Value Type Hierarchy</strong>\nLox is dynamically typed, meaning values carry their type at runtime. We represent this in Java using a hierarchy of classes, all ultimately extending <code>Object</code>. However, for clarity and to avoid confusion with Java&#39;s <code>Object</code>, we&#39;ll refer to these as <strong>Lox values</strong>.</p>\n<table>\n<thead>\n<tr>\n<th>Value Type</th>\n<th>Java Representation</th>\n<th>Description</th>\n<th>Example Literals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>LoxNumber</strong></td>\n<td><code>Double</code></td>\n<td>64-bit floating-point number (IEEE 754).</td>\n<td><code>123</code>, <code>4.56</code>, <code>-7.89</code></td>\n</tr>\n<tr>\n<td><strong>LoxString</strong></td>\n<td><code>String</code></td>\n<td>Immutable sequence of Unicode characters.</td>\n<td><code>&quot;hello&quot;</code>, <code>&quot;multi\\nline&quot;</code></td>\n</tr>\n<tr>\n<td><strong>LoxBoolean</strong></td>\n<td><code>Boolean</code></td>\n<td>Logical truth value.</td>\n<td><code>true</code>, <code>false</code></td>\n</tr>\n<tr>\n<td><strong>LoxNil</strong></td>\n<td><code>null</code> sentinel</td>\n<td>Represents absence of a value.</td>\n<td><code>nil</code></td>\n</tr>\n<tr>\n<td><strong>LoxFunction</strong></td>\n<td><code>LoxFunction</code> class</td>\n<td>Callable function object with parameters, body, and closure environment.</td>\n<td>Created by <code>fun</code> declarations</td>\n</tr>\n<tr>\n<td><strong>LoxClass</strong></td>\n<td><code>LoxClass</code> class</td>\n<td>Callable class object that creates instances and holds methods.</td>\n<td>Created by <code>class</code> declarations</td>\n</tr>\n<tr>\n<td><strong>LoxInstance</strong></td>\n<td><code>LoxInstance</code> class</td>\n<td>Instance of a class with its own field storage.</td>\n<td>Created by class constructor calls</td>\n</tr>\n</tbody></table>\n<p><strong>Truthiness Rules</strong>\nLox defines <strong>truthiness</strong> (whether a value is considered &quot;true&quot; in boolean contexts) as:</p>\n<ul>\n<li><code>false</code> and <code>nil</code> are <strong>falsy</strong></li>\n<li><strong>Everything else</strong> is <strong>truthy</strong> (including <code>0</code>, empty strings, and even <code>0.0</code>)</li>\n</ul>\n<p>This differs from some languages but matches Lox&#39;s semantics: only explicit falsehoods are falsy.</p>\n<p><strong>Value Operations</strong>\nEach value type supports specific operations:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Supported Types</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Arithmetic</strong> (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)</td>\n<td><code>LoxNumber</code></td>\n<td>Standard math. <code>+</code> also works for string concatenation.</td>\n</tr>\n<tr>\n<td><strong>Comparison</strong> (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)</td>\n<td><code>LoxNumber</code></td>\n<td>Numeric ordering.</td>\n</tr>\n<tr>\n<td><strong>Equality</strong> (<code>==</code>, <code>!=</code>)</td>\n<td>All types</td>\n<td>Value equality (structural for objects, reference for functions/classes/instances).</td>\n</tr>\n<tr>\n<td><strong>Negation</strong> (<code>-</code>)</td>\n<td><code>LoxNumber</code></td>\n<td>Unary minus.</td>\n</tr>\n<tr>\n<td><strong>Logical NOT</strong> (<code>!</code>)</td>\n<td>Any</td>\n<td>Returns <code>true</code> if operand is falsy, <code>false</code> otherwise.</td>\n</tr>\n<tr>\n<td><strong>Call</strong> (<code>(...)</code>)</td>\n<td><code>LoxFunction</code>, <code>LoxClass</code></td>\n<td>Invokes with arguments.</td>\n</tr>\n<tr>\n<td><strong>Property access</strong> (<code>.</code>)</td>\n<td><code>LoxInstance</code></td>\n<td>Gets/sets field values or calls methods.</td>\n</tr>\n</tbody></table>\n<p><strong>ADR: Unified vs. Tagged Value Representation</strong></p>\n<blockquote>\n<p><strong>Decision: Polymorphic Value Classes with Common Supertype</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to represent Lox values in Java, which is statically typed, while Lox is dynamically typed.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Single <code>Object</code> with instanceof checks</strong>: Store all values as Java <code>Object</code> and check types at runtime.</li>\n<li><strong>Tagged union/enum wrapper</strong>: Create a <code>Value</code> class with an enum tag and type-specific storage.</li>\n<li><strong>Polymorphic hierarchy</strong>: Create specific classes for each Lox type, all implementing a common <code>LoxValue</code> interface.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use specific classes (<code>LoxFunction</code>, <code>LoxClass</code>, <code>LoxInstance</code>) for complex types, and Java built-in types (<code>Double</code>, <code>String</code>, <code>Boolean</code>) for simple ones, with <code>null</code> for nil.</li>\n<li><strong>Rationale</strong>: This approach minimizes boilerplate while leveraging Java&#39;s type system where possible. Built-in types give us arithmetic and comparison operators for free. For user-defined types (functions, classes, instances), we need custom behavior (calling, instantiating, property access), so classes are natural. Using <code>null</code> for nil is idiomatic in Java.</li>\n<li><strong>Consequences</strong>: We must be careful with <code>null</code> checks (nil is a valid Lox value, not an error). Some operations require explicit type checking (e.g., <code>+</code> for numbers vs. strings). The interpreter&#39;s <code>evaluate()</code> method returns <code>Object</code>, which we must cast appropriately.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single <code>Object</code></td>\n<td>Simple, uniform</td>\n<td>Lots of instanceof, no type safety</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Tagged union</td>\n<td>Explicit type tags, can add new types easily</td>\n<td>Manual tag checking, memory overhead</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Polymorphic hierarchy</td>\n<td>Natural for OOP, leverages Java types</td>\n<td>Mixed representation (built-ins + custom classes)</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"environments-the-scoped-namespace\">Environments: The Scoped Namespace</h3>\n<p><strong>Mental Model: The Russian Doll Scopes</strong></p>\n<blockquote>\n<p>Environments are like a set of nested Russian dolls, where each doll represents a scope. The innermost doll (current scope) can see its own contents and everything in the dolls enclosing it, but outer dolls cannot see inside inner ones. When you enter a function or block, you open a new doll inside the current one; when you exit, you close it and return to the outer doll. Variables are stored in the smallest doll that contains their declaration.</p>\n</blockquote>\n<p>Environments implement <strong>lexical scoping</strong> (Milestones 5, 8) by maintaining a chain of variable bindings. Each environment corresponds to a scope in the program: global scope, function scope, block scope, or class method scope. The environment chain forms a tree structure that the interpreter traverses when resolving variable names.</p>\n<p><strong>Environment Structure</strong>\nEach environment is essentially a dictionary (name → value) with a reference to its parent (enclosing) environment:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>enclosing</code></td>\n<td><code>Environment</code></td>\n<td>The parent environment (null for the global scope).</td>\n</tr>\n<tr>\n<td><code>values</code></td>\n<td><code>Map&lt;String, Object&gt;</code></td>\n<td>The variable bindings in this scope (name → runtime value).</td>\n</tr>\n</tbody></table>\n<p><strong>Core Operations</strong>\nEnvironments support three fundamental operations:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>define</code></td>\n<td><code>String name</code>, <code>Object value</code></td>\n<td><code>void</code></td>\n<td>Creates a new variable in the current environment. Used for <code>var</code> declarations.</td>\n</tr>\n<tr>\n<td><code>get</code></td>\n<td><code>Token name</code></td>\n<td><code>Object</code></td>\n<td>Looks up a variable by its name token, searching outward through enclosing environments. Throws if not found.</td>\n</tr>\n<tr>\n<td><code>assign</code></td>\n<td><code>Token name</code>, <code>Object value</code></td>\n<td><code>void</code></td>\n<td>Updates an existing variable&#39;s value, searching outward. Throws if variable wasn&#39;t previously defined.</td>\n</tr>\n</tbody></table>\n<p><strong>Environment Chains in Practice</strong>\nConsider this Lox program:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lox</span><pre class=\"arch-pre shiki-highlighted\"><code>var global = &quot;outside&quot;;\n{\n  var inner = &quot;inside&quot;;\n  print global; // Looks in inner scope, then outer (global) scope\n}</code></pre></div>\n\n<p>This creates the following environment structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Global Environment {global: &quot;outside&quot;}\n    ↑\nBlock Environment {inner: &quot;inside&quot;}</code></pre></div>\n\n<p>When the interpreter evaluates <code>print global;</code> inside the block:</p>\n<ol>\n<li>It looks for <code>&quot;global&quot;</code> in the block environment → not found</li>\n<li>It follows the <code>enclosing</code> link to the global environment</li>\n<li>It finds <code>&quot;global&quot;</code> there and returns its value <code>&quot;outside&quot;</code></li>\n</ol>\n<p><strong>Closure Environment Capture</strong>\nFor closures (Milestone 8), the key insight is that a function <strong>captures its defining environment</strong> (the environment active when the function was created, not when it&#39;s called). This captured environment becomes the parent of the function&#39;s call environment:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Global {x: 10}\n    ↑ (captured)\nmakeCounter's defining environment\n    ↑\ncall environment (when makeCounter() is called)</code></pre></div>\n\n<p>This allows the inner function to access <code>x</code> even after <code>makeCounter</code> has returned.</p>\n<p><strong>ADR: Environment Chain vs. Static Distance</strong></p>\n<blockquote>\n<p><strong>Decision: Simple Parent-Chain Lookup</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to resolve variable names to their values at runtime, respecting lexical scoping rules.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Parent-chain lookup</strong>: Each environment stores a reference to its parent; lookups walk the chain.</li>\n<li><strong>Static distance/indices</strong>: At compile time, compute the &quot;distance&quot; (number of hops) to the defining environment; at runtime, navigate directly.</li>\n<li><strong>Flat closure representation</strong>: Copy all captured variables into the closure at creation time.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use parent-chain lookup for simplicity and clarity.</li>\n<li><strong>Rationale</strong>: Parent-chain lookup is straightforward to implement and understand—it directly models the mental model of nested scopes. While less efficient than static distance (which requires a separate compilation phase), it&#39;s sufficient for an educational interpreter. It also makes closures simple: a function just stores a reference to its defining environment.</li>\n<li><strong>Consequences</strong>: Variable lookup is O(depth) where depth is the nesting level. For deeply nested code, this could be slow, but Lox programs in practice are shallow. The design also naturally supports dynamic additions to outer scopes (though Lox doesn&#39;t allow this).</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parent-chain lookup</td>\n<td>Simple, intuitive, easy closures</td>\n<td>O(depth) lookup time</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Static distance</td>\n<td>O(1) lookup, efficient</td>\n<td>Requires compile-time analysis, more complex</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Flat closures</td>\n<td>Fast access to captured variables</td>\n<td>Complex copy semantics, doesn&#39;t support mutation of outer variables</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p><strong>Common Pitfalls with Environments</strong></p>\n<p>⚠️ <strong>Pitfall: Forgetting to Create New Environment for Each Function Call</strong></p>\n<ul>\n<li><strong>Description</strong>: Reusing the same environment for multiple calls to the same function.</li>\n<li><strong>Why it&#39;s wrong</strong>: Function parameters and local variables from previous calls would persist, breaking recursion and causing incorrect behavior.</li>\n<li><strong>Fix</strong>: Every function call must create a <strong>fresh</strong> environment with the function&#39;s closure environment as its parent.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect Parent Link in Block Environments</strong></p>\n<ul>\n<li><strong>Description</strong>: Setting a block environment&#39;s parent to the global environment instead of the current environment.</li>\n<li><strong>Why it&#39;s wrong</strong>: The block wouldn&#39;t have access to variables in enclosing functions or outer blocks.</li>\n<li><strong>Fix</strong>: When creating a block environment, pass the <strong>current</strong> environment as the parent.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Checking for Undefined Variables in assign()</strong></p>\n<ul>\n<li><strong>Description</strong>: Allowing assignment to create new variables implicitly (like Python) instead of requiring explicit declaration.</li>\n<li><strong>Why it&#39;s wrong</strong>: Lox requires <code>var</code> declarations; assignment to undefined variables should be a runtime error.</li>\n<li><strong>Fix</strong>: In <code>Environment.assign()</code>, search through the chain and throw if the name isn&#39;t found.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Data Structures</strong></td>\n<td>Java Collections (<code>HashMap</code>, <code>ArrayList</code>)</td>\n<td>Custom persistent/immutable collections</td>\n</tr>\n<tr>\n<td><strong>Value Representation</strong></td>\n<td>Java built-in types + custom classes</td>\n<td>Tagged union with explicit type hierarchy</td>\n</tr>\n<tr>\n<td><strong>Environment Lookup</strong></td>\n<td>Linear chain search</td>\n<td>Compile-time static distance resolution</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/\n├── Token.java              # Token class definition\n├── TokenType.java          # TokenType enum\n├── ast/\n│   ├── Expr.java           # Expression base class and visitor\n│   ├── Stmt.java           # Statement base class and visitor\n│   └── (concrete AST node classes can be inner classes or separate files)\n├── runtime/\n│   ├── LoxFunction.java    # Function value\n│   ├── LoxClass.java       # Class value  \n│   ├── LoxInstance.java    # Instance value\n│   └── Environment.java    # Environment chain\n└── Interpreter.java        # Main interpreter (evaluates AST)</code></pre></div>\n\n<p><strong>Infrastructure Starter Code</strong></p>\n<p>Complete, ready-to-use code for foundational data structures:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Token.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Objects;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> TokenType type;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> String lexeme;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Object literal;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">lexeme</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">literal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.lexeme </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lexeme;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.literal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> literal;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> type </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> literal;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> equals</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">o</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#E1E4E8\"> o) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (o </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#B392F0\"> getClass</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> o.</span><span style=\"color:#B392F0\">getClass</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Token token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (Token) o;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> token.line </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> token.type </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               Objects.</span><span style=\"color:#B392F0\">equals</span><span style=\"color:#E1E4E8\">(lexeme, token.lexeme) </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               Objects.</span><span style=\"color:#B392F0\">equals</span><span style=\"color:#E1E4E8\">(literal, token.literal);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> hashCode</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Objects.</span><span style=\"color:#B392F0\">hash</span><span style=\"color:#E1E4E8\">(type, lexeme, literal, line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TokenType.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Single-character tokens</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LEFT_PAREN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RIGHT_PAREN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LEFT_BRACE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RIGHT_BRACE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMMA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">DOT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">MINUS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">PLUS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SEMICOLON</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SLASH</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">STAR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // One or two character tokens</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BANG</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">BANG_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EQUAL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">EQUAL_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GREATER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">GREATER_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LESS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LESS_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Literals</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IDENTIFIER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">STRING</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NUMBER</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Keywords</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AND</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">CLASS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ELSE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FALSE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FUN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FOR</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">IF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NIL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">OR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRINT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RETURN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SUPER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">THIS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TRUE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">VAR</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">WHILE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EOF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Environment.java (starter version - will be extended)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox.runtime;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.HashMap;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Map;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.Token;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.Lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    final</span><span style=\"color:#E1E4E8\"> Environment enclosing;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Map&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> values </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> HashMap&#x3C;>();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.enclosing </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">(Environment </span><span style=\"color:#FFAB70\">enclosing</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.enclosing </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enclosing;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(name, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (values.</span><span style=\"color:#B392F0\">containsKey</span><span style=\"color:#E1E4E8\">(name.lexeme)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> values.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(name.lexeme);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (enclosing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> enclosing.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(name);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#E1E4E8\">(name, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Undefined variable '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> name.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> assign</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (values.</span><span style=\"color:#B392F0\">containsKey</span><span style=\"color:#E1E4E8\">(name.lexeme)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            values.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(name.lexeme, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (enclosing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            enclosing.</span><span style=\"color:#B392F0\">assign</span><span style=\"color:#E1E4E8\">(name, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#E1E4E8\">(name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Undefined variable '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> name.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code</strong></p>\n<p>AST node base classes with Visitor pattern:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ast/Expr.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox.ast;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.Token;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> abstract</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(Binary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitUnaryExpr</span><span style=\"color:#E1E4E8\">(Unary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitGroupingExpr</span><span style=\"color:#E1E4E8\">(Grouping </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitLiteralExpr</span><span style=\"color:#E1E4E8\">(Literal </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitVariableExpr</span><span style=\"color:#E1E4E8\">(Variable </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitAssignExpr</span><span style=\"color:#E1E4E8\">(Assign </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitLogicalExpr</span><span style=\"color:#E1E4E8\">(Logical </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitCallExpr</span><span style=\"color:#E1E4E8\">(Call </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitGetExpr</span><span style=\"color:#E1E4E8\">(Get </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitSetExpr</span><span style=\"color:#E1E4E8\">(Set </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitThisExpr</span><span style=\"color:#E1E4E8\">(This </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        R </span><span style=\"color:#B392F0\">visitSuperExpr</span><span style=\"color:#E1E4E8\">(Super </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> abstract</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Binary</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr left;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token operator;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr right;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#B392F0\"> Binary</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, Token </span><span style=\"color:#FFAB70\">operator</span><span style=\"color:#E1E4E8\">, Expr </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.left </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> left;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operator;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.right </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> right;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add other expression node classes (Unary, Grouping, Literal, </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Variable, Assign, Logical, Call, Get, Set, This, Super) following</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // the same pattern as Binary above.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Each should have:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Public final fields for its data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. A constructor initializing those fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. An accept() method calling the appropriate visitor method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ast/Stmt.java  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox.ast;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.Token;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> abstract</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitExpressionStmt</span><span style=\"color:#E1E4E8\">(Expression </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitPrintStmt</span><span style=\"color:#E1E4E8\">(Print </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitVarStmt</span><span style=\"color:#E1E4E8\">(Var </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitBlockStmt</span><span style=\"color:#E1E4E8\">(Block </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitIfStmt</span><span style=\"color:#E1E4E8\">(If </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitWhileStmt</span><span style=\"color:#E1E4E8\">(While </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitFunctionStmt</span><span style=\"color:#E1E4E8\">(Function </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitReturnStmt</span><span style=\"color:#E1E4E8\">(Return </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        V </span><span style=\"color:#B392F0\">visitClassStmt</span><span style=\"color:#E1E4E8\">(Class </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> abstract</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr expression;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">expression</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.expression </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expression;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitExpressionStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add other statement node classes (Print, Var, Block, If,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // While, Function, Return, Class) following the same pattern.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remember: FunctionStmt should store name (Token), params (List&#x3C;Token>),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // and body (List&#x3C;Stmt>).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints</strong></p>\n<ol>\n<li><strong>Use <code>final</code> fields</strong> in all data classes (Token, AST nodes) to ensure immutability.</li>\n<li><strong>Override <code>toString()</code></strong> in Token and AST nodes for debugging.</li>\n<li><strong>Use <code>HashMap</code> for environments</strong> - it&#39;s simple and fast enough for our needs.</li>\n<li><strong>Be careful with <code>null</code></strong> - Lox&#39;s <code>nil</code> is represented by Java <code>null</code>, but not all <code>null</code> values are Lox nil (could be uninitialized Java references).</li>\n<li><strong>Use <code>Double</code> for numbers</strong> - Lox uses double-precision floats. Remember that <code>1 + 2</code> produces <code>3.0</code> (a Double), not <code>3</code> (an Integer).</li>\n</ol>\n<p><strong>Milestone Checkpoint: Data Structures</strong></p>\n<p>After implementing the data model, you should be able to:</p>\n<ul>\n<li>Compile all Java files without errors</li>\n<li>Create Token objects manually in a test and verify their fields</li>\n<li>Construct a simple AST manually (e.g., <code>new Expr.Binary(new Expr.Literal(1), new Token(TokenType.PLUS, &quot;+&quot;, null, 1), new Expr.Literal(2))</code>)</li>\n<li>Create nested environments and verify variable lookup follows the chain</li>\n</ul>\n<p>Run a simple test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Test</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">[] </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Test Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Token plus </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType.PLUS, </span><span style=\"color:#9ECBFF\">\"+\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Token: \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> plus);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Test Environment chain</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Environment global </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        global.</span><span style=\"color:#B392F0\">define</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"x\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Environment local </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">(global);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        local.</span><span style=\"color:#B392F0\">define</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"y\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Token xToken </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType.IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"x\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Token yToken </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType.IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"y\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"x in local: \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> local.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(xToken)); </span><span style=\"color:#6A737D\">// Should print 10.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"y in local: \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> local.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(yToken)); </span><span style=\"color:#6A737D\">// Should print 20.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Expected output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Token: PLUS + null\nx in local: 10.0\ny in local: 20.0</code></pre></div>\n\n<p>If you get <code>NullPointerException</code> or incorrect values, check:</p>\n<ol>\n<li>Environment chain links (parent references)</li>\n<li>HashMap key matching (names are case-sensitive)</li>\n<li>That you&#39;re using <code>Double</code> values, not <code>Integer</code></li>\n</ol>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 - Scanner (Lexer)</p>\n</blockquote>\n<h2 id=\"51-component-design-scanner-lexer-milestone-1\">5.1 Component Design: Scanner (Lexer) [Milestone 1]</h2>\n<p>The <strong>Scanner</strong>, also called the <strong>lexer</strong> (lexical analyzer), is the gateway through which raw Lox source code enters the interpreter pipeline. Its singular responsibility is to transform a linear sequence of characters into a structured sequence of <strong>tokens</strong>—meaningful atomic units that represent the basic vocabulary of the language. Without this component, the interpreter would see only an undifferentiated stream of characters, unable to distinguish keywords from identifiers or numbers from operators.</p>\n<h3 id=\"mental-model-the-tokenizer\">Mental Model: The Tokenizer</h3>\n<p>Think of the scanner as a <strong>language translator breaking down a sentence into labeled dictionary entries</strong>. Given the sentence &quot;The quick brown fox jumps over 42.5 lazy dogs,&quot; a translator would identify each word (&quot;The&quot; → article, &quot;quick&quot; → adjective, &quot;brown&quot; → adjective, &quot;fox&quot; → noun, &quot;jumps&quot; → verb, etc.), recognize &quot;42.5&quot; as a number, and note the period as punctuation. The scanner performs exactly this role for Lox source code: it reads character by character, recognizes patterns that constitute valid language elements, categorizes them (is &quot;while&quot; a keyword or an identifier?), and outputs a structured list where each entry knows its type, exact text, literal value (for numbers and strings), and position in the source. This tokenized form provides the parser with manageable, semantically meaningful units instead of raw characters.</p>\n<h3 id=\"interface-and-state\">Interface and State</h3>\n<p>The Scanner is a stateful component that processes source code in a single, linear pass. Its interface is deliberately minimal: a constructor accepting the source string and a single public method that drives the scanning process.</p>\n<h4 id=\"scanner-public-interface\">Scanner Public Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Scanner</code> constructor</td>\n<td><code>source: String</code></td>\n<td><code>Scanner</code> instance</td>\n<td>Creates a new scanner for the given source code string. Stores the source and initializes scanning state.</td>\n</tr>\n<tr>\n<td><code>scanTokens</code></td>\n<td>None</td>\n<td><code>List&lt;Token&gt;</code></td>\n<td>The main entry point. Scans the entire source, returning a complete list of tokens. This method orchestrates the scanning loop until the end of the source is reached.</td>\n</tr>\n</tbody></table>\n<h4 id=\"scanner-internal-state\">Scanner Internal State</h4>\n<p>The scanner maintains four essential pieces of state during its operation, each tracked by an integer index or counter:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>source</code></td>\n<td><code>String</code></td>\n<td>The complete source code text to be scanned. This is the input character stream.</td>\n</tr>\n<tr>\n<td><code>tokens</code></td>\n<td><code>List&lt;Token&gt;</code></td>\n<td>The accumulating list of successfully scanned tokens. This is the output of the scanning process.</td>\n</tr>\n<tr>\n<td><code>start</code></td>\n<td><code>int</code></td>\n<td>Index in <code>source</code> pointing to the first character of the <em>current</em> token being scanned.</td>\n</tr>\n<tr>\n<td><code>current</code></td>\n<td><code>int</code></td>\n<td>Index in <code>source</code> pointing to the <em>next</em> character to be examined (the &quot;lookahead&quot; position).</td>\n</tr>\n<tr>\n<td><code>line</code></td>\n<td><code>int</code></td>\n<td>Current line number in the source (1-indexed). Incremented when newline characters are encountered. Essential for accurate error reporting.</td>\n</tr>\n</tbody></table>\n<p>The relationship between <code>start</code> and <code>current</code> is fundamental: <code>start</code> marks where the current token began, while <code>current</code> marches forward through the source as characters are examined. When a complete token is recognized, the substring from <code>start</code> to <code>current-1</code> becomes the token&#39;s <code>lexeme</code>, and both positions are captured in a new <code>Token</code> object added to the <code>tokens</code> list. Then <code>start</code> is reset to <code>current</code> to begin the next token.</p>\n<h3 id=\"scanning-algorithm\">Scanning Algorithm</h3>\n<p>The scanner operates via a central loop that repeatedly examines characters, identifies token boundaries, and emits tokens until the source is exhausted. The algorithm follows a deterministic, procedural flow with clear branching based on the character at the current position.</p>\n<h4 id=\"step-by-step-scanning-procedure\">Step-by-Step Scanning Procedure</h4>\n<ol>\n<li><p><strong>Initialization</strong>: Create empty token list. Set <code>start = 0</code>, <code>current = 0</code>, <code>line = 1</code>.</p>\n</li>\n<li><p><strong>Main Scanning Loop</strong>: While not at end of source (<code>current &lt; source.length()</code>):\na. <strong>Reset token start</strong>: Set <code>start = current</code>.\nb. <strong>Examine next character</strong>: Call <code>peek()</code> to look at character at <code>current</code> without consuming it.\nc. <strong>Branch on character type</strong>:</p>\n<ul>\n<li><strong>Single-character tokens</strong> (<code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>,</code>, <code>.</code>, <code>-</code>, <code>+</code>, <code>;</code>, <code>*</code>, <code>/</code>): Directly create corresponding token.</li>\n<li><strong>One-or-two-character tokens</strong> (<code>!</code>, <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>): Check next character for <code>=</code> to decide between single or double operator.</li>\n<li><strong>String literals</strong> (<code>&quot;</code>): Enter string scanning mode, consuming until closing <code>&quot;</code> (handling escapes).</li>\n<li><strong>Number literals</strong> (<code>0</code>-<code>9</code>): Enter number scanning mode, consuming digits and optional decimal point followed by more digits.</li>\n<li><strong>Identifiers and keywords</strong> (<code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>, <code>_</code>): Enter identifier scanning mode, consuming alphanumeric/underscore characters, then check if lexeme matches a reserved keyword.</li>\n<li><strong>Whitespace</strong> (<code> </code>, <code>\\t</code>, <code>\\r</code>, <code>\\n</code>): Skip (update line count for newlines).</li>\n<li><strong>Comments</strong> (<code>//</code> or <code>/*</code>): Skip until end of line or closing <code>*/</code>.</li>\n<li><strong>Unrecognized character</strong>: Report lexical error with line number.\nd. <strong>Advance position</strong>: Increment <code>current</code> as characters are consumed.\ne. <strong>Emit token</strong>: For recognized tokens (excluding whitespace/comments), create <code>Token</code> with type, lexeme, literal value (if any), and current line, then add to <code>tokens</code>.</li>\n</ul>\n</li>\n<li><p><strong>Finalization</strong>: After loop, add an <code>EOF</code> (end-of-file) token to mark the end of the token stream.</p>\n</li>\n</ol>\n<h4 id=\"detailed-scanning-logic-for-key-token-types\">Detailed Scanning Logic for Key Token Types</h4>\n<p><strong>String Literals</strong>:</p>\n<ol>\n<li>Advance past opening <code>&quot;</code>.</li>\n<li>While next character is not <code>&quot;</code>:<ul>\n<li>If end of file, report error: &quot;Unterminated string.&quot;</li>\n<li>If newline, increment <code>line</code> (Lox supports multiline strings).</li>\n<li>If <code>\\</code> (backslash), process escape sequence: <code>\\&quot;</code>, <code>\\\\</code>, <code>\\n</code>, <code>\\t</code>, etc.</li>\n<li>Otherwise, add character to string value.</li>\n</ul>\n</li>\n<li>Advance past closing <code>&quot;</code>.</li>\n<li>Create token with literal value as the accumulated string (without quotes).</li>\n</ol>\n<p><strong>Number Literals</strong>:</p>\n<ol>\n<li>Consume consecutive digits (<code>0</code>-<code>9</code>).</li>\n<li>If next character is <code>.</code> and character after that is a digit:<ul>\n<li>Consume <code>.</code>.</li>\n<li>Consume consecutive digits after decimal.</li>\n</ul>\n</li>\n<li>Convert lexeme to <code>double</code> value (Lox uses double-precision floating point).</li>\n</ol>\n<p><strong>Identifiers and Keywords</strong>:</p>\n<ol>\n<li>Consume consecutive alphanumeric characters and underscores (<code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>, <code>0</code>-<code>9</code>, <code>_</code>).</li>\n<li>Check if resulting lexeme matches a reserved keyword (e.g., &quot;and&quot;, &quot;class&quot;, &quot;if&quot;, &quot;while&quot;).<ul>\n<li>Use a hash map from string to <code>TokenType</code> for efficient lookup.</li>\n</ul>\n</li>\n<li>If match, emit keyword token; otherwise, emit identifier token.</li>\n</ol>\n<h3 id=\"adr-visitor-vs-procedural-scanning\">ADR: Visitor vs. Procedural Scanning</h3>\n<blockquote>\n<p><strong>Decision: Procedural Scanning Loop Over State Machine/Visitor Patterns</strong></p>\n<ul>\n<li><p><strong>Context</strong>: The scanner must reliably recognize a finite set of token patterns from a linear character stream. While lexical analysis can be implemented using various formalisms (state machines, table-driven scanners, or visitor patterns), we need a solution that is educational, straightforward to implement and debug, and maps clearly to the lexical grammar of Lox.</p>\n</li>\n<li><p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Procedural scanning loop</strong>: A manual loop with explicit character-by-character examination and branching via <code>switch</code>/<code>if</code> statements.</li>\n<li><strong>Finite-state machine (FSM)</strong>: Explicit state transitions driven by character classes, possibly implemented via state pattern or transition table.</li>\n<li><strong>Visitor pattern scanning</strong>: Separate visitor classes for each major token category that traverse the character stream.</li>\n</ol>\n</li>\n<li><p><strong>Decision</strong>: Implement a <strong>procedural scanning loop</strong>.</p>\n</li>\n<li><p><strong>Rationale</strong>:</p>\n<ol>\n<li><strong>Educational clarity</strong>: The procedural approach maps directly to the human mental model of &quot;look at character, decide what to do.&quot; Each token type&#39;s recognition logic is localized and explicit, making it easier for learners to trace execution and understand the scanning process.</li>\n<li><strong>Simplicity</strong>: No need to define state classes, transition tables, or visitor hierarchies. The scanner&#39;s logic is contained in one straightforward class with helper methods.</li>\n<li><strong>Direct control</strong>: Error reporting and recovery (like skipping invalid characters) can be inserted precisely where needed in the flow.</li>\n<li><strong>Performance</strong>: While not a primary goal, the direct character manipulation and explicit branching are efficient for the small-scale scanning needs of an educational interpreter.</li>\n</ol>\n</li>\n<li><p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: Implementation is straightforward to write, read, and debug. Changes to token recognition (e.g., adding a new operator) involve localized edits.</li>\n<li><strong>Negative</strong>: The scanner class becomes a &quot;god object&quot; containing all scanning logic, which could grow large. However, for Lox&#39;s limited token set, this is manageable.</li>\n<li><strong>Mitigation</strong>: Logic for different token categories can be separated into well-named private methods (e.g., <code>scanString()</code>, <code>scanNumber()</code>, <code>scanIdentifier()</code>).</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"options-comparison-table\">Options Comparison Table</h4>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Procedural scanning loop</strong></td>\n<td>Direct mapping to lexical grammar; Easy to understand and debug; Simple error handling; No abstraction overhead</td>\n<td>Can become monolithic; Manual character-by-character handling may be verbose</td>\n<td><strong>Chosen</strong> - Best aligns with educational goals and simplicity</td>\n</tr>\n<tr>\n<td><strong>Finite-state machine</strong></td>\n<td>Formal, clean separation of states; Potentially easier to extend for complex patterns</td>\n<td>Significant boilerplate for state classes; Obfuscates the straightforward logic; Harder to debug state transitions</td>\n<td>Adds unnecessary complexity for Lox&#39;s simple lexical patterns</td>\n</tr>\n<tr>\n<td><strong>Visitor pattern scanning</strong></td>\n<td>Separates token recognition logic into visitor classes; Follows OOP principles</td>\n<td>Heavy abstraction for a linear process; Visitors don&#39;t naturally fit scanning; Overkill for simple token patterns</td>\n<td>The visitor pattern is better suited for heterogeneous tree traversal (AST), not linear scanning</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Mishandling Multi-Character Operators</strong></p>\n<p><strong>Description</strong>: Failing to properly handle operators that could be one or two characters long (<code>=</code>, <code>==</code>, <code>!</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>). A naive implementation might emit a single <code>=</code> token when seeing <code>==</code>, leaving the second <code>=</code> to be scanned as a separate token or causing a parse error.</p>\n<p><strong>Why it&#39;s wrong</strong>: The parser expects a single <code>==</code> token for equality comparison. Receiving two separate <code>=</code> tokens would lead to a syntax error or incorrect parsing (e.g., interpreting <code>a == b</code> as assignment <code>a = = b</code>).</p>\n<p><strong>How to avoid</strong>: Implement a <code>match(expected)</code> helper that looks at the next character. If it matches <code>expected</code>, consume it and return <code>true</code>. Use this when scanning <code>=</code>, <code>!</code>, <code>&lt;</code>, <code>&gt;</code>: if <code>match(&#39;=&#39;)</code> returns <code>true</code>, emit the two-character operator; otherwise emit the single-character one.</p>\n<p>⚠️ <strong>Pitfall: Unterminated Strings Without Error Recovery</strong></p>\n<p><strong>Description</strong>: When scanning a string literal, if the closing double quote is missing (e.g., <code>&quot;hello</code>), the scanner may either crash (index out of bounds) or enter an infinite loop consuming the rest of the source.</p>\n<p><strong>Why it&#39;s wrong</strong>: Lexical errors should be reported gracefully with location information, not cause interpreter crashes. The scanner should detect the EOF before the closing quote and report a meaningful error.</p>\n<p><strong>How to avoid</strong>: In <code>scanString()</code>, check for EOF (<code>peek() == &#39;\\0&#39;</code>) at each iteration. If EOF is reached before the closing quote, call an error reporting function with the line number and message &quot;Unterminated string.&quot; Then break out of the loop to continue scanning the rest of the source (or halt, depending on error recovery strategy).</p>\n<p>⚠️ <strong>Pitfall: Incorrect Number Literal Scanning</strong></p>\n<p><strong>Description</strong>: Numbers with multiple decimal points (e.g., <code>123.45.67</code>) might be incorrectly tokenized as a single number, or numbers trailing with a dot (e.g., <code>123.</code>) might be mishandled.</p>\n<p><strong>Why it&#39;s wrong</strong>: These are invalid numeric literals in Lox. The scanner should emit a single token for valid numbers but should not silently accept invalid ones. A number with two decimal points is a syntax error that should be caught by the scanner.</p>\n<p><strong>How to avoid</strong>: After consuming the integer part and seeing a <code>.</code>, peek at the <em>next</em> character. If it&#39;s a digit, consume the dot and fractional digits. If it&#39;s not a digit, <strong>do not consume the dot</strong>—the number ends at the previous digit, and the dot will be scanned as a separate <code>.</code> token (likely leading to a parse error). This correctly handles both <code>123.</code> (two tokens: <code>123</code> and <code>.</code>) and <code>123.45</code> (one token).</p>\n<p>⚠️ <strong>Pitfall: Forgetting Line Number Tracking</strong></p>\n<p><strong>Description</strong>: Not updating the <code>line</code> counter when encountering newline characters (<code>\\n</code>), especially inside strings or when skipping comments.</p>\n<p><strong>Why it&#39;s wrong</strong>: Error messages (lexical, syntactic, runtime) rely on accurate line numbers to point developers to the problematic code. If line numbers are off by even one, debugging becomes significantly harder.</p>\n<p><strong>How to avoid</strong>: Increment <code>line</code> consistently in three places: 1) When advancing past a <code>\\n</code> character in the main scanning loop (for newlines in general code). 2) Inside <code>scanString()</code> when a <code>\\n</code> is encountered (Lox supports multiline strings). 3) Inside block comment skipping when <code>\\n</code> is encountered.</p>\n<p>⚠️ <strong>Pitfall: Keyword Matching Case-Sensitivity Issues</strong></p>\n<p><strong>Description</strong>: Using case-sensitive string comparison for keywords when Lox keywords are case-sensitive (<code>while</code> is a keyword, <code>While</code> is not).</p>\n<p><strong>Why it&#39;s wrong</strong>: If matching is case-insensitive, <code>While</code> would be incorrectly tokenized as a keyword rather than an identifier, preventing users from using that as a variable name (contrary to language spec).</p>\n<p><strong>How to avoid</strong>: Use exact string equality when checking the identifier lexeme against the keyword map. Lox&#39;s keywords are all lowercase, so the lexeme must match exactly in case.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Scanner Implementation</td>\n<td>Manual character-by-character scanning with <code>String.charAt()</code></td>\n<td>Using <code>java.io.Reader</code> with buffering for file I/O, or regex for token patterns (not recommended for learning)</td>\n</tr>\n<tr>\n<td>Token Storage</td>\n<td><code>ArrayList&lt;Token&gt;</code></td>\n<td><code>LinkedList&lt;Token&gt;</code> if frequent insertion at middle needed (not the case here)</td>\n</tr>\n<tr>\n<td>Keyword Lookup</td>\n<td><code>HashMap&lt;String, TokenType&gt;</code> with static initialization</td>\n<td>Trie data structure for efficient prefix matching (overkill for ~20 keywords)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/\n├── Lox.java                 # Main entry point, coordinates components\n├── Token.java              # Token class definition\n├── TokenType.java          # Enumeration of token types\n├── scanner/\n│   ├── Scanner.java        # Scanner implementation (this component)\n│   └── ScannerTest.java    # Unit tests for scanner\n├── parser/                 # (Milestone 2-3)\n├── ast/                    # (Milestone 2)\n└── interpreter/            # (Milestone 4+)</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>The <code>Token</code> class and <code>TokenType</code> enum are foundational data structures used throughout the interpreter. Here is their complete implementation:</p>\n<p><strong>TokenType.java</strong> (complete):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Each enum value represents a distinct category of lexical element in Lox.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Single-character tokens.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LEFT_PAREN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RIGHT_PAREN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LEFT_BRACE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RIGHT_BRACE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMMA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">DOT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">MINUS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">PLUS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SEMICOLON</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SLASH</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">STAR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // One or two character tokens.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BANG</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">BANG_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EQUAL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">EQUAL_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GREATER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">GREATER_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LESS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LESS_EQUAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Literals.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IDENTIFIER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">STRING</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NUMBER</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Keywords.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AND</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">CLASS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ELSE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FALSE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FUN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FOR</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">IF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NIL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">OR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRINT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RETURN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SUPER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">THIS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TRUE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">VAR</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">WHILE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // End-of-file marker.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EOF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Token.java</strong> (complete):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Represents a single lexical token with its metadata.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> TokenType type;    </span><span style=\"color:#6A737D\">// Category of token (e.g., NUMBER, WHILE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> String lexeme;     </span><span style=\"color:#6A737D\">// Raw text as it appeared in source</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Object literal;    </span><span style=\"color:#6A737D\">// Runtime value for literals (String, Double)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> line;          </span><span style=\"color:#6A737D\">// Line number where token starts (1-indexed)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">lexeme</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">literal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.lexeme </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lexeme;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.literal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> literal;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> type </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> literal;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Scanner.java</strong> (skeleton with TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.scanner;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Token;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.TokenType;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.ArrayList;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.HashMap;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Map;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Scanner</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> String source;          </span><span style=\"color:#6A737D\">// The raw source code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> ArrayList&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;                </span><span style=\"color:#6A737D\">// Start index of current token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;              </span><span style=\"color:#6A737D\">// Current character index being examined</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;                 </span><span style=\"color:#6A737D\">// Current line number</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Static map for keyword lookup: lexeme -> TokenType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Map&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">TokenType</span><span style=\"color:#E1E4E8\">> keywords;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> HashMap&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"and\"</span><span style=\"color:#E1E4E8\">,    TokenType.AND);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"class\"</span><span style=\"color:#E1E4E8\">,  TokenType.CLASS);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"else\"</span><span style=\"color:#E1E4E8\">,   TokenType.ELSE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"false\"</span><span style=\"color:#E1E4E8\">,  TokenType.FALSE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"for\"</span><span style=\"color:#E1E4E8\">,    TokenType.FOR);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fun\"</span><span style=\"color:#E1E4E8\">,    TokenType.FUN);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"if\"</span><span style=\"color:#E1E4E8\">,     TokenType.IF);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"nil\"</span><span style=\"color:#E1E4E8\">,    TokenType.NIL);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"or\"</span><span style=\"color:#E1E4E8\">,     TokenType.OR);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"print\"</span><span style=\"color:#E1E4E8\">,  TokenType.PRINT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"return\"</span><span style=\"color:#E1E4E8\">, TokenType.RETURN);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"super\"</span><span style=\"color:#E1E4E8\">,  TokenType.SUPER);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"this\"</span><span style=\"color:#E1E4E8\">,   TokenType.THIS);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"true\"</span><span style=\"color:#E1E4E8\">,   TokenType.TRUE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"var\"</span><span style=\"color:#E1E4E8\">,    TokenType.VAR);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keywords.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"while\"</span><span style=\"color:#E1E4E8\">,  TokenType.WHILE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Scanner</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.source </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main entry point: scan all tokens from source.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">scanTokens</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Loop while not at end of source</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // We are at the beginning of the next token.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            scanToken</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Add EOF token at the end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tokens.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType.EOF, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, line));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> tokens;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Examines the next character(s) and emits a token.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> scanToken</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Get the next character (consume it)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Branch based on character using switch statement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (c) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Single-character tokens</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '('</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.LEFT_PAREN); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> ')'</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.RIGHT_PAREN); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '{'</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.LEFT_BRACE); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '}'</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.RIGHT_BRACE); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> ','</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.COMMA); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.DOT); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '-'</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.MINUS); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '+'</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.PLUS); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> ';'</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.SEMICOLON); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '*'</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType.STAR); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // One-or-two-character tokens</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '!'</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 5: If next char is '=', emit BANG_EQUAL else BANG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                addToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> TokenType.BANG_EQUAL </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> TokenType.BANG);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '='</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 6: If next char is '=', emit EQUAL_EQUAL else EQUAL</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                addToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> TokenType.EQUAL_EQUAL </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> TokenType.EQUAL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '&#x3C;'</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 7: If next char is '=', emit LESS_EQUAL else LESS</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                addToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> TokenType.LESS_EQUAL </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> TokenType.LESS);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '>'</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 8: If next char is '=', emit GREATER_EQUAL else GREATER</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                addToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> TokenType.GREATER_EQUAL </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> TokenType.GREATER);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Division operator or comment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 9: If next char is '/', it's a single-line comment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Consume until end of line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 10: Optional - handle block comments /* ... */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // else if (match('*')) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                //     blockComment();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    addToken</span><span style=\"color:#E1E4E8\">(TokenType.SLASH);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Whitespace (ignore, but track newlines)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 11: Increment line counter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                line</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // String literals</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> '\"'</span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 12: Call string() method to handle string scanning</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                string</span><span style=\"color:#E1E4E8\">(); </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            default:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 13: Handle numbers (if c is digit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isDigit</span><span style=\"color:#E1E4E8\">(c)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    number</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 14: Handle identifiers/keywords (if c is letter or underscore)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isAlpha</span><span style=\"color:#E1E4E8\">(c)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    identifier</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // TODO 15: Report lexical error for unexpected character</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Lox.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"Unexpected character: '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scans a string literal: assumes opening \" has been consumed.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> string</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 16: Loop while next char is not '\"' and not at end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '\"'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 17: If newline, increment line counter (Lox supports multiline strings)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) line</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 18: Handle escape sequences if desired (optional milestone)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 19: Check for unterminated string (if at end)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Lox.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"Unterminated string.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 20: Consume the closing \"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 21: Extract string value (without quotes) and add token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        String value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">substring</span><span style=\"color:#E1E4E8\">(start </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, current </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        addToken</span><span style=\"color:#E1E4E8\">(TokenType.STRING, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scans a number literal: digits optionally followed by . and more digits.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> number</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 22: Consume consecutive digits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isDigit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">())) </span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 23: Look for fractional part (decimal point followed by digits)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> isDigit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peekNext</span><span style=\"color:#E1E4E8\">())) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Consume the decimal point</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Consume fractional digits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isDigit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">())) </span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 24: Convert lexeme to double and add NUMBER token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Double.</span><span style=\"color:#B392F0\">parseDouble</span><span style=\"color:#E1E4E8\">(source.</span><span style=\"color:#B392F0\">substring</span><span style=\"color:#E1E4E8\">(start, current));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        addToken</span><span style=\"color:#E1E4E8\">(TokenType.NUMBER, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scans an identifier or keyword: alphanumeric characters and underscores.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> identifier</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 25: Consume alphanumeric characters and underscores</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isAlphaNumeric</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">())) </span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 26: Check if lexeme is a keyword</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        String text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">substring</span><span style=\"color:#E1E4E8\">(start, current);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TokenType type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> keywords.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(text);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (type </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TokenType.IDENTIFIER;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 27: Add appropriate token (keyword or identifier)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        addToken</span><span style=\"color:#E1E4E8\">(type);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // =============== Helper Methods ===============</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns true if we've consumed all characters.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isAtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">length</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Consumes and returns the next character.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> char</span><span style=\"color:#B392F0\"> advance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">charAt</span><span style=\"color:#E1E4E8\">(current </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns the next character without consuming it (lookahead).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> char</span><span style=\"color:#B392F0\"> peek</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">charAt</span><span style=\"color:#E1E4E8\">(current);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns the character after the next (two-character lookahead).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> char</span><span style=\"color:#B392F0\"> peekNext</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> >=</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">length</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">charAt</span><span style=\"color:#E1E4E8\">(current </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Checks if the next character matches expected, consuming it only if true.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> match</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> expected</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 28: If at end, return false</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 29: If next character matches expected, consume it and return true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (source.</span><span style=\"color:#B392F0\">charAt</span><span style=\"color:#E1E4E8\">(current) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expected) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Adds a token with no literal value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        addToken</span><span style=\"color:#E1E4E8\">(type, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Adds a token with a literal value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> addToken</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">literal</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 30: Extract lexeme from source and create token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        String text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source.</span><span style=\"color:#B392F0\">substring</span><span style=\"color:#E1E4E8\">(start, current);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tokens.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(type, text, literal, line));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns true if c is a digit (0-9).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isDigit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> '0'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> '9'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns true if c is a letter (a-z, A-Z) or underscore.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isAlpha</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> 'a'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> 'z'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               (c </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> 'Z'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '_'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns true if c is alphanumeric or underscore.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isAlphaNumeric</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> isAlpha</span><span style=\"color:#E1E4E8\">(c) </span><span style=\"color:#F97583\">||</span><span style=\"color:#B392F0\"> isDigit</span><span style=\"color:#E1E4E8\">(c);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Note on Error Reporting</strong>: The skeleton references <code>Lox.error(line, message)</code>. You&#39;ll need to implement a simple error reporting mechanism in your main <code>Lox</code> class. For now, you can use:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Lox</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        report</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> report</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.err.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[line \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"] Error\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> where </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \": \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Character Access</strong>: Use <code>String.charAt()</code> for simple character access. For production code, consider converting the source to a <code>char[]</code> for performance, but for clarity, <code>charAt()</code> is fine.</li>\n<li><strong>String Substrings</strong>: <code>source.substring(start, current)</code> creates a new string each time. This is acceptable for scanning, but be aware of memory if scanning huge files.</li>\n<li><strong>Number Parsing</strong>: <code>Double.parseDouble()</code> handles both integer and decimal numbers. Lox uses double-precision floating point for all numbers.</li>\n<li><strong>HashMap Initialization</strong>: The static initializer for <code>keywords</code> runs once when the class is loaded. This is efficient and thread-safe for this use case.</li>\n<li><strong>Error Handling</strong>: For lexical errors, you might want to collect multiple errors rather than halting at the first. Consider adding an <code>errors</code> list to the scanner and reporting all at once.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the scanner, you should be able to test it with simple Lox code snippets:</p>\n<p><strong>Test Command</strong> (assuming you have a simple main method in <code>Lox.java</code> that creates a scanner and prints tokens):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> /path/to/lox</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">javac</span><span style=\"color:#9ECBFF\"> com/craftinginterpreters/lox/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.java</span><span style=\"color:#9ECBFF\"> com/craftinginterpreters/lox/scanner/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.java</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#9ECBFF\"> \"var x = 42;\"</span></span></code></pre></div>\n\n<p><strong>Expected Output</strong>: A list of tokens printed, something like:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>VAR var null\nIDENTIFIER x null\nEQUAL = null\nNUMBER 42 42.0\nSEMICOLON ; null\nEOF  null</code></pre></div>\n\n<p><strong>Verification Steps</strong>:</p>\n<ol>\n<li><strong>Single-character tokens</strong>: Test <code>( ) { } , . - + ; * /</code> all produce correct tokens.</li>\n<li><strong>Multi-character operators</strong>: Test <code>= == ! != &lt; &lt;= &gt; &gt;=</code> produce correct single or double tokens.</li>\n<li><strong>Strings</strong>: Test <code>&quot;hello&quot;</code> produces STRING token with literal &quot;hello&quot;. Test <code>&quot;multi\\nline&quot;</code> handles escape sequences (optional) and newline counting.</li>\n<li><strong>Numbers</strong>: Test <code>123</code>, <code>123.456</code>, <code>.456</code> (should be DOT then NUMBER 456), <code>123.</code> (should be NUMBER 123 then DOT).</li>\n<li><strong>Keywords and identifiers</strong>: Test <code>while</code> → WHILE keyword, <code>While</code> → IDENTIFIER.</li>\n<li><strong>Whitespace and comments</strong>: Test that spaces, tabs, and <code>// comments</code> are ignored and don&#39;t produce tokens.</li>\n<li><strong>Error reporting</strong>: Test <code>&quot;unterminated</code> produces &quot;Unterminated string&quot; error with line number. Test <code>@</code> produces &quot;Unexpected character&quot; error.</li>\n</ol>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>Infinite loop: Likely missing advance() calls or incorrect condition in scanning loop.</li>\n<li>Missing tokens: <code>start</code> and <code>current</code> not being reset properly after token emission.</li>\n<li>Incorrect line numbers: Not incrementing <code>line</code> on newlines inside strings or comments.</li>\n<li>Number parsing errors: <code>Double.parseDouble()</code> throwing exception for invalid numbers like <code>123.</code> (should be caught by your logic before parsing).</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Scanner goes into infinite loop</td>\n<td>Missing <code>advance()</code> call in a branch, or <code>isAtEnd()</code> always returns false</td>\n<td>Add debug prints showing <code>current</code> and character at each loop iteration.</td>\n<td>Ensure every path through <code>scanToken()</code> either advances <code>current</code> or breaks/returns.</td>\n</tr>\n<tr>\n<td>String literal includes quotes in value</td>\n<td>Using <code>start</code> to <code>current</code> without trimming quotes</td>\n<td>Print the extracted substring value before creating token.</td>\n<td>In <code>string()</code> method, use <code>start + 1</code> and <code>current - 1</code> as indices.</td>\n</tr>\n<tr>\n<td>Numbers with decimal point produce two tokens</td>\n<td>Not checking that character after <code>.</code> is a digit before consuming</td>\n<td>Print lexeme when scanning numbers. Check logic for fractional part.</td>\n<td>Use <code>peekNext()</code> to look ahead two characters when seeing <code>.</code>.</td>\n</tr>\n<tr>\n<td>Keywords not recognized</td>\n<td>Case mismatch or missing entry in keywords map</td>\n<td>Print the extracted identifier text and check map lookup.</td>\n<td>Ensure keyword map has all lowercase entries and identifier is converted to lowercase for lookup (if language is case-insensitive; Lox is case-sensitive).</td>\n</tr>\n<tr>\n<td>Line numbers off by one</td>\n<td>Not counting newlines in strings or block comments</td>\n<td>Add print statement showing line number for each token.</td>\n<td>Increment <code>line</code> counter when encountering <code>\\n</code> in <code>string()</code> and comment-skipping logic.</td>\n</tr>\n<tr>\n<td>&quot;Unterminated string&quot; error on valid strings</td>\n<td>Not consuming the closing quote character</td>\n<td>Check that <code>advance()</code> is called after the while loop in <code>string()</code>.</td>\n<td>Ensure the closing <code>&quot;</code> is consumed before creating the token.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 - Representing Code (AST), Milestone 3 - Parsing Expressions</p>\n</blockquote>\n<h2 id=\"52-component-design-parser-amp-ast-milestones-2-amp-3\">5.2 Component Design: Parser &amp; AST [Milestones 2 &amp; 3]</h2>\n<p>This section details the design of the <strong>Parser</strong>, the component that translates a linear sequence of tokens into a structured, hierarchical <strong>Abstract Syntax Tree (AST)</strong>, and the definition of the AST node classes themselves. If the scanner breaks a paragraph into words, the parser is the grammarian who diagrams the sentence, identifying the subject, verb, object, and how they relate through nesting and precedence rules. This transformation from <code>List&lt;Token&gt;</code> to <code>List&lt;Stmt&gt;</code> is the heart of syntactic analysis, bridging the gap between raw text and executable structure.</p>\n<h3 id=\"mental-model-the-sentence-diagrammer\">Mental Model: The Sentence Diagrammer</h3>\n<p>Imagine you are given a jumbled list of words and punctuation from a sentence: <code>[&quot;The&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;jumps&quot;, &quot;over&quot;, &quot;the&quot;, &quot;lazy&quot;, &quot;dog&quot;, &quot;.&quot;]</code>. Your task is to reconstruct the sentence&#39;s grammatical structure. You identify &quot;fox&quot; as the subject noun, &quot;jumps&quot; as the verb, and &quot;over the lazy dog&quot; as a prepositional phrase modifying the verb. You then arrange these into a tree showing that &quot;quick brown&quot; modifies &quot;fox&quot;, and &quot;lazy&quot; modifies &quot;dog&quot;.</p>\n<p>The <strong>Parser</strong> performs exactly this role for programming languages. It consumes the flat list of tokens produced by the scanner and applies the formal grammar rules of Lox to build a tree structure (the AST). This tree explicitly represents the nesting (parentheses, blocks), precedence (multiplication before addition), and associativity (left-to-right for most operators) that are only implicit in the linear token stream. Each node in the tree corresponds to a syntactic construct in the language—an expression, a statement, a declaration—and its children are the sub-components of that construct.</p>\n<h3 id=\"ast-definition-and-the-visitor-pattern\">AST Definition and the Visitor Pattern</h3>\n<p>The <strong>Abstract Syntax Tree (AST)</strong> is the canonical, in-memory representation of a Lox program&#39;s syntactic structure after parsing. It is &quot;abstract&quot; because it omits syntactic details that don&#39;t affect meaning, like the exact placement of parentheses (though their grouping effect is captured) and semicolons between statements. The AST serves as the immutable input to all subsequent phases: the <strong>Interpreter</strong> walks it to execute the program, and a <strong>PrettyPrinter</strong> can traverse it to regenerate formatted source code.</p>\n<p>The AST is defined as a hierarchy of node types, rooted in two abstract base classes: <code>Expr</code> for expressions (which produce a value) and <code>Stmt</code> for statements (which perform an action). Each concrete node type (e.g., <code>Binary</code>, <code>If</code>) is a subclass of one of these and holds fields referencing its child nodes and relevant tokens.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">AST Node Type (Class)</th>\n<th align=\"left\">Base Class</th>\n<th align=\"left\">Key Fields (Name → Type)</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Binary</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>left</code> → <code>Expr</code>, <code>operator</code> → <code>Token</code>, <code>right</code> → <code>Expr</code></td>\n<td align=\"left\">A binary operation like <code>1 + 2</code> or <code>x == y</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Unary</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>operator</code> → <code>Token</code>, <code>right</code> → <code>Expr</code></td>\n<td align=\"left\">A unary operation like <code>-5</code> or <code>!true</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Grouping</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>expression</code> → <code>Expr</code></td>\n<td align=\"left\">A parenthesized expression <code>(1 + 2)</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Literal</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>value</code> → <code>Object</code></td>\n<td align=\"left\">A literal value: number, string, boolean, <code>nil</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Variable</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>name</code> → <code>Token</code></td>\n<td align=\"left\">A reference to a variable by its name.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Assign</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>name</code> → <code>Token</code>, <code>value</code> → <code>Expr</code></td>\n<td align=\"left\">An assignment <code>x = 5</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Logical</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>left</code> → <code>Expr</code>, <code>operator</code> → <code>Token</code>, <code>right</code> → <code>Expr</code></td>\n<td align=\"left\">A logical <code>and</code> or <code>or</code> expression.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Call</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>callee</code> → <code>Expr</code>, <code>paren</code> → <code>Token</code>, <code>arguments</code> → <code>List&lt;Expr&gt;</code></td>\n<td align=\"left\">A function call <code>fn(1, 2)</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Get</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>object</code> → <code>Expr</code>, <code>name</code> → <code>Token</code></td>\n<td align=\"left\">Property access <code>obj.property</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Set</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>object</code> → <code>Expr</code>, <code>name</code> → <code>Token</code>, <code>value</code> → <code>Expr</code></td>\n<td align=\"left\">Property assignment <code>obj.property = 5</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>This</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>keyword</code> → <code>Token</code></td>\n<td align=\"left\">The <code>this</code> keyword.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Super</strong></td>\n<td align=\"left\"><code>Expr</code></td>\n<td align=\"left\"><code>keyword</code> → <code>Token</code>, <code>method</code> → <code>Token</code></td>\n<td align=\"left\">A superclass method call <code>super.method()</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Expression</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>expression</code> → <code>Expr</code></td>\n<td align=\"left\">A statement that wraps a single expression.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Print</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>expression</code> → <code>Expr</code></td>\n<td align=\"left\">A <code>print</code> statement.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Var</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>name</code> → <code>Token</code>, <code>initializer</code> → <code>Expr</code></td>\n<td align=\"left\">A <code>var</code> declaration.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Block</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>statements</code> → <code>List&lt;Stmt&gt;</code></td>\n<td align=\"left\">A block <code>{ ... }</code> of statements.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>If</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>condition</code> → <code>Expr</code>, <code>thenBranch</code> → <code>Stmt</code>, <code>elseBranch</code> → <code>Stmt</code></td>\n<td align=\"left\">An <code>if</code> statement with optional <code>else</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>While</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>condition</code> → <code>Expr</code>, <code>body</code> → <code>Stmt</code></td>\n<td align=\"left\">A <code>while</code> loop.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Function</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>name</code> → <code>Token</code>, <code>params</code> → <code>List&lt;Token&gt;</code>, <code>body</code> → <code>List&lt;Stmt&gt;</code></td>\n<td align=\"left\">A <code>fun</code> function declaration.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Return</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>keyword</code> → <code>Token</code>, <code>value</code> → <code>Expr</code></td>\n<td align=\"left\">A <code>return</code> statement.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Class</strong></td>\n<td align=\"left\"><code>Stmt</code></td>\n<td align=\"left\"><code>name</code> → <code>Token</code>, <code>superclass</code> → <code>Expr.Variable</code>, <code>methods</code> → <code>List&lt;Stmt.Function&gt;</code></td>\n<td align=\"left\">A <code>class</code> declaration.</td>\n</tr>\n</tbody></table>\n<p>To perform operations over this heterogeneous tree (like evaluation or printing), we need a way to dispatch to type-specific logic for each node. A naive approach uses a cascade of <code>instanceof</code> checks and casts, which is brittle and verbose. The <strong>Visitor Pattern</strong> provides an elegant, type-safe alternative. It leverages <strong>double dispatch</strong>: the AST node&#39;s <code>accept</code> method calls the appropriate <code>visit</code> method on the visitor object, passing itself as an argument. This allows the visitor to define behavior for each node type in a single class.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> The Visitor Pattern effectively adds a virtual method to each AST node type without modifying the node classes themselves. This keeps the AST data structures simple and immutable, while allowing arbitrary operations (interpretation, printing, static analysis) to be defined as separate, cohesive visitor classes.</p>\n</blockquote>\n<p>The pattern requires two visitor interfaces—one for expressions, one for statements—each declaring a <code>visit</code> method for every concrete node type.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Interface Method</th>\n<th align=\"left\">Parameters</th>\n<th align=\"left\">Returns</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Expr.Visitor&lt;R&gt;.visitBinaryExpr</code></td>\n<td align=\"left\"><code>Binary</code> expr</td>\n<td align=\"left\"><code>R</code></td>\n<td align=\"left\">Visit a <code>Binary</code> expression node.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Expr.Visitor&lt;R&gt;.visitUnaryExpr</code></td>\n<td align=\"left\"><code>Unary</code> expr</td>\n<td align=\"left\"><code>R</code></td>\n<td align=\"left\">Visit a <code>Unary</code> expression node.</td>\n</tr>\n<tr>\n<td align=\"left\">... (and so on for every <code>Expr</code> subclass)</td>\n<td align=\"left\">...</td>\n<td align=\"left\">...</td>\n<td align=\"left\">...</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Stmt.Visitor&lt;V&gt;.visitExpressionStmt</code></td>\n<td align=\"left\"><code>Expression</code> stmt</td>\n<td align=\"left\"><code>V</code></td>\n<td align=\"left\">Visit an <code>Expression</code> statement node.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Stmt.Visitor&lt;V&gt;.visitPrintStmt</code></td>\n<td align=\"left\"><code>Print</code> stmt</td>\n<td align=\"left\"><code>V</code></td>\n<td align=\"left\">Visit a <code>Print</code> statement node.</td>\n</tr>\n<tr>\n<td align=\"left\">... (and so on for every <code>Stmt</code> subclass)</td>\n<td align=\"left\">...</td>\n<td align=\"left\">...</td>\n<td align=\"left\">...</td>\n</tr>\n</tbody></table>\n<p>Every concrete <code>Expr</code> and <code>Stmt</code> node implements an <code>accept</code> method that calls the corresponding visitor method, passing <code>this</code>.</p>\n<h3 id=\"parsing-expression-grammar-peg-amp-recursive-descent\">Parsing Expression Grammar (PEG) &amp; Recursive Descent</h3>\n<p>The parser must implement the <strong>grammar rules</strong> that define valid Lox programs. We use a <strong>Parsing Expression Grammar (PEG)</strong> style, which is well-suited for <strong>recursive descent parsing</strong>. In recursive descent, each grammar rule becomes a function in the parser. The parser&#39;s internal state is simple: a list of tokens and an index pointing to the next token to consume (<code>current</code>).</p>\n<p>The core challenge is correctly parsing expressions with multiple levels of <strong>operator precedence</strong> and <strong>associativity</strong>. Lox has the following precedence levels (from lowest/binding loosest to highest/binding tightest):</p>\n<ol>\n<li><strong>Assignment</strong> (<code>=</code>), which is right-associative.</li>\n<li><strong>Logical <code>or</code></strong> (<code>or</code>), left-associative.</li>\n<li><strong>Logical <code>and</code></strong> (<code>and</code>), left-associative.</li>\n<li><strong>Equality</strong> (<code>==</code>, <code>!=</code>), left-associative.</li>\n<li><strong>Comparison</strong> (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>), left-associative.</li>\n<li><strong>Term</strong> (<code>+</code>, <code>-</code>), left-associative.</li>\n<li><strong>Factor</strong> (<code>*</code>, <code>/</code>), left-associative.</li>\n<li><strong>Unary</strong> (<code>!</code>, <code>-</code>), right-associative.</li>\n<li><strong>Primary</strong> (literals, variables, grouping, calls, etc.).</li>\n</ol>\n<p>The recursive descent parser encodes this precedence hierarchy directly into its call graph. The function for the lowest-precedence operator (<code>assignment</code>) calls the function for the next higher level (<code>logical_or</code>), which calls the next (<code>logical_and</code>), and so on, until reaching <code>primary()</code>, which handles atomic expressions. This creates a natural nesting where higher-precedence operators are parsed deeper in the recursive call stack, resulting in an AST where they are lower in the tree (closer to the leaves).</p>\n<p><img src=\"/api/project/build-interpreter/architecture-doc/asset?path=diagrams%2Fdiagram-parser-precedence.svg\" alt=\"Parser Expression Precedence Flowchart\"></p>\n<p>The parsing algorithm for a single expression follows this step-by-step procedure:</p>\n<ol>\n<li><strong>Start Parsing</strong>: The entry point <code>expression()</code> (or <code>assignment()</code> for Lox) is called.</li>\n<li><strong>Parse Lower Precedence First</strong>: The <code>assignment()</code> method first calls <code>logicalOr()</code> to parse the left-hand side. This begins the descent down the precedence chain.</li>\n<li><strong>Recursive Descent</strong>: Control flows down through <code>logicalOr()</code> → <code>logicalAnd()</code> → <code>equality()</code> → <code>comparison()</code> → <code>term()</code> → <code>factor()</code> → <code>unary()</code> → <code>primary()</code>. Each function is responsible for parsing its own level of operators and delegating sub-expressions to the function for the next higher precedence level.</li>\n<li><strong>Handle Operators at Current Level</strong>: When a function (e.g., <code>term()</code>) regains control after its delegate call (to <code>factor()</code>), it checks if the current token is an operator at its level (<code>+</code> or <code>-</code>). If so, it consumes the operator, recursively calls <code>factor()</code> again to parse the right operand, and builds a <code>Binary</code> AST node. It repeats in a loop to handle chains of same-precedence operators (e.g., <code>1 + 2 - 3</code>), ensuring left associativity.</li>\n<li><strong>Build AST</strong>: As the recursion unwinds, each function returns an <code>Expr</code> node representing the parsed sub-expression at its precedence level. The <code>Binary</code> and <code>Unary</code> nodes constructed become the children of nodes at lower precedence levels.</li>\n<li><strong>Final Result</strong>: The top-level <code>assignment()</code> function may perform additional logic (like checking for <code>=</code> for assignment) and finally returns the complete <code>Expr</code> AST for the entire expression.</li>\n</ol>\n<p>For statements, the parsing is more straightforward, as statements do not have complex precedence interactions. The <code>parse()</code> method of the parser repeatedly calls <code>statement()</code> until it runs out of tokens. The <code>statement()</code> function looks at the current token to decide which specific statement parsing function (<code>printStatement()</code>, <code>ifStatement()</code>, etc.) to invoke.</p>\n<blockquote>\n<p>The critical nuance is that parsing functions <em>predict</em> what they are about to parse based on the current token, then delegate to more specific functions. This is a top-down, predictive parsing strategy.</p>\n</blockquote>\n<h3 id=\"adr-recursive-descent-vs-pratt-parsing\">ADR: Recursive Descent vs. Pratt Parsing</h3>\n<blockquote>\n<p><strong>Decision: Use Classic Recursive Descent for Expression Parsing</strong></p>\n<ul>\n<li><strong>Context</strong>: We need a parsing algorithm for Lox expressions that correctly handles operator precedence and associativity, is understandable for learners, and maps clearly to the language grammar.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Classic Recursive Descent</strong>: One parsing function per precedence level, with explicit calls between them forming the precedence hierarchy.</li>\n<li><strong>Pratt Parsing (Top-Down Operator Precedence)</strong>: A more compact algorithm that uses a table of precedence values and generic <code>parseExpression</code> calls, with binding power driving recursion.</li>\n<li><strong>Parser Generator (e.g., ANTLR)</strong>: Use a tool to generate a parser from a formal grammar specification.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We choose <strong>Classic Recursive Descent</strong>.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Explicitness &amp; Educational Value</strong>: The call graph of functions (<code>expression</code> → <code>equality</code> → <code>comparison</code> → ...) provides a direct, visual mapping to the precedence table. A learner can read the code and immediately see how precedence is implemented. Pratt parsing, while elegant, condenses this logic into a less intuitive loop and table lookup.</li>\n<li><strong>Simplicity for Statements</strong>: Recursive descent handles the statement grammar (which has diverse starting keywords like <code>if</code>, <code>while</code>, <code>for</code>) very naturally with simple <code>if</code>/<code>else if</code> checks on the lookahead token. Pratt parsing is primarily designed for expressions.</li>\n<li><strong>Control and Error Reporting</strong>: Having a dedicated function for each grammar rule makes it easier to craft specific, helpful error messages when a parse error occurs at a particular point (e.g., &quot;Expect &#39;)&#39; after expression&quot; inside <code>grouping()</code>).</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>More Boilerplate</strong>: We will have ~8 functions for expression precedence levels, each with similar looping structures. This is more code than a Pratt parser.</li>\n<li><strong>Clear Structure</strong>: The resulting parser is longer but extremely easy to debug and extend. Adding a new operator precedence level is as simple as adding a new function and slotting it into the call chain.</li>\n<li><strong>Direct Implementation</strong>: It avoids the need to understand the somewhat subtle &quot;binding power&quot; concept of Pratt parsing, lowering the initial learning barrier.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Classic Recursive Descent</strong></td>\n<td align=\"left\">Direct mapping to grammar. Easy to understand and debug. Excellent for error reporting. Handles statements naturally.</td>\n<td align=\"left\">More verbose code. Requires careful ordering of function calls to get precedence right.</td>\n<td align=\"left\"><strong>Yes</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Pratt Parsing</strong></td>\n<td align=\"left\">Very concise for expressions. Elegant handling of precedence and associativity. Easy to add new operators.</td>\n<td align=\"left\">More abstract, harder to understand initially. Less straightforward for non-expression grammar rules.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Parser Generator</strong></td>\n<td align=\"left\">Automatically handles complex grammars. Can generate efficient code.</td>\n<td align=\"left\">Adds a build-time dependency. Hides the parsing logic, reducing educational value. Error messages can be cryptic.</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Left-Recursion Infinite Loop</strong></p>\n<ul>\n<li><strong>Description</strong>: Writing a grammar rule that directly or indirectly calls itself without consuming a token first, e.g., <code>expression() -&gt; expression() + term()</code>. In recursive descent, this leads to infinite recursion and a stack overflow.</li>\n<li><strong>Why it&#39;s wrong</strong>: The parser function immediately calls itself again, making no progress on the token stream.</li>\n<li><strong>Fix</strong>: Always structure grammar rules to consume at least one token (a <em>terminal</em>) before any recursive call. The standard pattern is to have a rule delegate to a higher-precedence rule first (e.g., <code>expression() -&gt; equality()</code>, and <code>equality() -&gt; comparison ( ( &quot;!=&quot; \\| &quot;==&quot; ) comparison )*</code>).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect Precedence or Associativity</strong></p>\n<ul>\n<li><strong>Description</strong>: Getting the order of operator parsing wrong. For example, parsing <code>+</code> before <code>*</code>, or making <code>=</code> left-associative. This results in an AST that evaluates to the wrong value.</li>\n<li><strong>Why it&#39;s wrong</strong>: The tree structure no longer reflects the intended meaning of the expression. <code>1 + 2 * 3</code> might be parsed as <code>(1 + 2) * 3</code>.</li>\n<li><strong>Fix</strong>: Meticulously follow the precedence table. Ensure the call chain in the parser respects the table order (lowest precedence calls next level). For associativity, use a loop for left-associative operators (parsing left-to-right) and recursion for right-associative ones (like <code>=</code>).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Poor Error Reporting and Recovery</strong></p>\n<ul>\n<li><strong>Description</strong>: The parser throws a generic &quot;syntax error&quot; without indicating location or what was expected, or it crashes completely on the first error, making it hard to find multiple issues.</li>\n<li><strong>Why it&#39;s wrong</strong>: A user cannot effectively debug their Lox code.</li>\n<li><strong>Fix</strong>: <strong>Synchronized panic-mode recovery</strong>. When a parse error is detected, report the line, the token, and a context-specific message. Then, discard tokens until reaching a known &quot;synchronization point&quot; (like a semicolon or a statement-starting keyword) before attempting to continue parsing. This allows reporting multiple independent errors in one run.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Visitor Pattern Boilerplate Overload</strong></p>\n<ul>\n<li><strong>Description</strong>: Manually writing the <code>accept</code> method in every AST node class and the visitor interface with a dozen <code>visit</code> methods is tedious and error-prone.</li>\n<li><strong>Why it&#39;s wrong</strong>: It distracts from the core logic and introduces risk of typos or missing methods.</li>\n<li><strong>Fix</strong>: Use your IDE&#39;s code generation features (if available) or write a small script to generate the skeleton. In the educational context, writing it once reinforces understanding of the pattern. The provided implementation guidance includes the complete boilerplate to copy.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to Handle the End-of-File (EOF) Token</strong></p>\n<ul>\n<li><strong>Description</strong>: The parser&#39;s loop or matching logic doesn&#39;t explicitly check for the <code>EOF</code> token, leading to infinite loops or <code>IndexOutOfBounds</code> exceptions when the token list is exhausted.</li>\n<li><strong>Why it&#39;s wrong</strong>: Every valid program ends with <code>EOF</code>. The parser must gracefully stop when it reaches it.</li>\n<li><strong>Fix</strong>: The helper method <code>isAtEnd()</code> should check if the current token is of type <code>EOF</code>. All parsing functions should use this before attempting to consume tokens.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option</th>\n<th align=\"left\">Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>AST Definition</strong></td>\n<td align=\"left\">Manual Java classes with fields and Visitor interfaces.</td>\n<td align=\"left\">Use an Annotation Processor or Kotlin data classes to reduce boilerplate (out of scope for learning).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Parsing Algorithm</strong></td>\n<td align=\"left\">Classic Recursive Descent as described.</td>\n<td align=\"left\">Pratt Parsing for a more compact, generalized expression parser.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Error Handling</strong></td>\n<td align=\"left\">Simple <code>throw new ParseError(...)</code> with line number.</td>\n<td align=\"left\">Collect multiple errors in a list before throwing, or implement more sophisticated recovery.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/\n├── Lox.java                 # Main CLI/REPL entry point\n├── Token.java              # Token data class\n├── TokenType.java          # TokenType enum\n│\n├── scanner/\n│   └── Scanner.java        # Milestone 1 component\n│\n├── ast/                    # Milestone 2: AST Definitions\n│   ├── Expr.java           # Abstract Expr base class and Visitor\n│   └── Stmt.java           # Abstract Stmt base class and Visitor\n│\n├── parser/                 # Milestone 3: Parser\n│   ├── Parser.java\n│   └── ParseError.java     # Checked exception for parse errors\n│\n└── interpreter/            # Future milestones\n    └── ... (Interpreter, Environment, etc.)</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>The following is the complete, ready-to-use boilerplate for the AST node classes and Visitor interfaces. This is foundational infrastructure; the learner should copy this exactly and then focus on implementing the parser logic.</p>\n<p><strong><code>ast/Expr.java</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.ast;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Token;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> abstract</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(Binary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitUnaryExpr</span><span style=\"color:#E1E4E8\">(Unary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitGroupingExpr</span><span style=\"color:#E1E4E8\">(Grouping </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitLiteralExpr</span><span style=\"color:#E1E4E8\">(Literal </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitVariableExpr</span><span style=\"color:#E1E4E8\">(Variable </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitAssignExpr</span><span style=\"color:#E1E4E8\">(Assign </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitLogicalExpr</span><span style=\"color:#E1E4E8\">(Logical </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitCallExpr</span><span style=\"color:#E1E4E8\">(Call </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitGetExpr</span><span style=\"color:#E1E4E8\">(Get </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitSetExpr</span><span style=\"color:#E1E4E8\">(Set </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitThisExpr</span><span style=\"color:#E1E4E8\">(This </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    R </span><span style=\"color:#B392F0\">visitSuperExpr</span><span style=\"color:#E1E4E8\">(Super </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> abstract</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Binary</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Binary</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, Token </span><span style=\"color:#FFAB70\">operator</span><span style=\"color:#E1E4E8\">, Expr </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.left </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> left;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operator;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.right </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> right;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr left;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token operator;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr right;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Unary</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Unary</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">operator</span><span style=\"color:#E1E4E8\">, Expr </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operator;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.right </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> right;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitUnaryExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token operator;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr right;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Grouping</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Grouping</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">expression</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.expression </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expression;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitGroupingExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr expression;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Literal</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Literal</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitLiteralExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Object value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Variable</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Variable</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitVariableExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Assign</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Assign</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Expr </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitAssignExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Logical</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Logical</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, Token </span><span style=\"color:#FFAB70\">operator</span><span style=\"color:#E1E4E8\">, Expr </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.left </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> left;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operator;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.right </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> right;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitLogicalExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr left;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token operator;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr right;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Call</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Call</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">callee</span><span style=\"color:#E1E4E8\">, Token </span><span style=\"color:#FFAB70\">paren</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Expr</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.callee </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> callee;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.paren </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> paren;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.arguments </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> arguments;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitCallExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr callee;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token paren;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Expr</span><span style=\"color:#E1E4E8\">> arguments;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Get</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Get</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">object</span><span style=\"color:#E1E4E8\">, Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.object </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> object;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitGetExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr object;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Set</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Set</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">object</span><span style=\"color:#E1E4E8\">, Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Expr </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.object </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> object;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitSetExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr object;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> This</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> This</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">keyword</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.keyword </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> keyword;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitThisExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token keyword;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Super</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Expr</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Super</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">keyword</span><span style=\"color:#E1E4E8\">, Token </span><span style=\"color:#FFAB70\">method</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.keyword </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> keyword;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.method </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> method;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> R </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">R</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitSuperExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token keyword;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token method;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong><code>ast/Stmt.java</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.ast;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Token;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> abstract</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitExpressionStmt</span><span style=\"color:#E1E4E8\">(Expression </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitPrintStmt</span><span style=\"color:#E1E4E8\">(Print </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitVarStmt</span><span style=\"color:#E1E4E8\">(Var </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitBlockStmt</span><span style=\"color:#E1E4E8\">(Block </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitIfStmt</span><span style=\"color:#E1E4E8\">(If </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitWhileStmt</span><span style=\"color:#E1E4E8\">(While </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitFunctionStmt</span><span style=\"color:#E1E4E8\">(Function </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitReturnStmt</span><span style=\"color:#E1E4E8\">(Return </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    V </span><span style=\"color:#B392F0\">visitClassStmt</span><span style=\"color:#E1E4E8\">(Class </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> abstract</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">expression</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.expression </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expression;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitExpressionStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr expression;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Print</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Print</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">expression</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.expression </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expression;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitPrintStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr expression;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Var</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Var</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Expr </span><span style=\"color:#FFAB70\">initializer</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.initializer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> initializer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitVarStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr initializer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Block</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Block</span><span style=\"color:#E1E4E8\">(List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">statements</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.statements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> statements;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitBlockStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> statements;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> If</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> If</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#E1E4E8\">, Stmt </span><span style=\"color:#FFAB70\">thenBranch</span><span style=\"color:#E1E4E8\">, Stmt </span><span style=\"color:#FFAB70\">elseBranch</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.condition </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> condition;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.thenBranch </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> thenBranch;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.elseBranch </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> elseBranch;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitIfStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr condition;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Stmt thenBranch;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Stmt elseBranch;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> While</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> While</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#E1E4E8\">, Stmt </span><span style=\"color:#FFAB70\">body</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.condition </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> condition;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitWhileStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr condition;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Stmt body;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Function</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Function</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">params</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">body</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.params </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitFunctionStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> params;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> body;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Return</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Return</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">keyword</span><span style=\"color:#E1E4E8\">, Expr </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.keyword </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> keyword;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitReturnStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token keyword;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Class</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Stmt</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Class</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Expr.Variable </span><span style=\"color:#FFAB70\">superclass</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#F97583\">Function</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">methods</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.superclass </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> superclass;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.methods </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> methods;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> V </span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(Visitor&#x3C;</span><span style=\"color:#F97583\">V</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">visitor</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> visitor.</span><span style=\"color:#B392F0\">visitClassStmt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Expr.Variable superclass;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#F97583\">Function</span><span style=\"color:#E1E4E8\">> methods;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong><code>parser/ParseError.java</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.parser;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is a checked exception to allow simple error recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// in the recursive descent parser.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> RuntimeException</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // No need to store extra state; the error message is sufficient.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong><code>parser/Parser.java</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.parser;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Token;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.TokenType;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.ast.Expr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.ast.Stmt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.ArrayList;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> static</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.TokenType.</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> tokens;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#E1E4E8\">(List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">tokens</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokens;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> statements </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> ArrayList&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 1: Parse a single statement and add it to the list.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Hint: Use declaration() which can parse any statement.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      statements.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">declaration</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> statements;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // declaration → varDecl | funDecl | classDecl | statement ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">declaration</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 2: Look at the current token to decide what kind of declaration this is.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // If it's VAR, call varDecl().</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // If it's FUN, call funDecl(\"function\").</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // If it's CLASS, call classDecl().</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Otherwise, it's a statement; call statement().</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(VAR)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> varDecl</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(FUN)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> funDecl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"function\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(CLASS)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> classDecl</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#B392F0\"> statement</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (ParseError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      synchronize</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Return null to allow parsing to continue after an error.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // varDecl → \"var\" IDENTIFIER ( \"=\" expression )? \";\" ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">varDecl</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Consume the identifier token (the variable name).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Token name </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> consume</span><span style=\"color:#E1E4E8\">(IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"Expect variable name.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check for an initializer (an '=' token).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr initializer </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(EQUAL)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      initializer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Expect a semicolon after the variable declaration.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(SEMICOLON, </span><span style=\"color:#9ECBFF\">\"Expect ';' after variable declaration.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Var</span><span style=\"color:#E1E4E8\">(name, initializer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // funDecl → \"fun\" function ;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // function → IDENTIFIER \"(\" parameters? \")\" block ;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // parameters → IDENTIFIER ( \",\" IDENTIFIER )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">funDecl</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">kind</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Consume the function name identifier.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Token name </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> consume</span><span style=\"color:#E1E4E8\">(IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"Expect \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> kind </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" name.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Expect a '(' for the parameter list.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(LEFT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect '(' after \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> kind </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" name.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Parse the parameter list.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> parameters </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> ArrayList&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      do</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (parameters.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 255</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">          error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"Cannot have more than 255 parameters.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parameters.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">consume</span><span style=\"color:#E1E4E8\">(IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"Expect parameter name.\"</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(COMMA));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect ')' after parameters.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Parse the function body as a block.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(LEFT_BRACE, </span><span style=\"color:#9ECBFF\">\"Expect '{' before \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> kind </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" body.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> body </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> block</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Function</span><span style=\"color:#E1E4E8\">(name, parameters, body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // classDecl → \"class\" IDENTIFIER ( \"&#x3C;\" IDENTIFIER )? \"{\" function* \"}\" ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">classDecl</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Consume the class name identifier.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Token name </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> consume</span><span style=\"color:#E1E4E8\">(IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"Expect class name.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 11: Check for a superclass inheritance clause.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr.Variable superclass </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(LESS)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      consume</span><span style=\"color:#E1E4E8\">(IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"Expect superclass name.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      superclass </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Variable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">previous</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 12: Expect a '{' before the class body.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(LEFT_BRACE, </span><span style=\"color:#9ECBFF\">\"Expect '{' before class body.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 13: Parse the list of method declarations inside the class.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#F97583\">Function</span><span style=\"color:#E1E4E8\">> methods </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> ArrayList&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(RIGHT_BRACE) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      methods.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">funDecl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"method\"</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(RIGHT_BRACE, </span><span style=\"color:#9ECBFF\">\"Expect '}' after class body.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Class</span><span style=\"color:#E1E4E8\">(name, superclass, methods);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // statement → exprStmt | printStmt | block | ifStmt | whileStmt | forStmt | returnStmt ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">statement</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 14: Check the current token to decide which statement type to parse.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(PRINT)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> printStmt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(LEFT_BRACE)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">block</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(IF)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> ifStmt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(WHILE)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> whileStmt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(FOR)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> forStmt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(RETURN)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> returnStmt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> expressionStmt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // exprStmt → expression \";\" ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">expressionStmt</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 15: Parse an expression, expect a semicolon, and wrap it in an Expression statement.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(SEMICOLON, </span><span style=\"color:#9ECBFF\">\"Expect ';' after expression.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">(expr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // printStmt → \"print\" expression \";\" ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">printStmt</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 16: Parse an expression, expect a semicolon, and wrap it in a Print statement.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(SEMICOLON, </span><span style=\"color:#9ECBFF\">\"Expect ';' after value.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Print</span><span style=\"color:#E1E4E8\">(value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // block → \"{\" declaration* \"}\" ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">block</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> statements </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> ArrayList&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(RIGHT_BRACE) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      statements.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">declaration</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(RIGHT_BRACE, </span><span style=\"color:#9ECBFF\">\"Expect '}' after block.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> statements;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // ifStmt → \"if\" \"(\" expression \")\" statement ( \"else\" statement )? ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">ifStmt</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 17: Expect '(' after 'if', parse the condition, expect ')'.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(LEFT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect '(' after 'if'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr condition </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect ')' after if condition.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 18: Parse the then branch statement.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Stmt thenBranch </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> statement</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 19: Check for an else token and parse the else branch if present.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Stmt elseBranch </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(ELSE)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      elseBranch </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> statement</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">If</span><span style=\"color:#E1E4E8\">(condition, thenBranch, elseBranch);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // whileStmt → \"while\" \"(\" expression \")\" statement ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">whileStmt</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 20: Expect '(' after 'while', parse the condition, expect ')'.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(LEFT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect '(' after 'while'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr condition </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect ')' after condition.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Stmt body </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> statement</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">While</span><span style=\"color:#E1E4E8\">(condition, body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // forStmt → \"for\" \"(\" ( varDecl | exprStmt | \";\" ) expression? \";\" expression? \")\" statement ;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // This is a \"desugaring\" parser: it transforms for-loop syntax into an equivalent while-loop AST.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">forStmt</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 21: Expect '(' after 'for'.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(LEFT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect '(' after 'for'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 22: Parse the initializer (could be a var declaration, an expression statement, or empty).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Stmt initializer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(SEMICOLON)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      initializer </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(VAR)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      initializer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> varDecl</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      initializer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expressionStmt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 23: Parse the loop condition. If missing, treat it as 'true'.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr condition </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(SEMICOLON)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      condition </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(SEMICOLON, </span><span style=\"color:#9ECBFF\">\"Expect ';' after loop condition.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 24: Parse the increment expression. If missing, treat it as empty.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr increment </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      increment </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect ')' after for clauses.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 25: Parse the body statement.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Stmt body </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> statement</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 26: Desugar: Build the AST for a block containing initializer, a while loop with condition and body,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // and the increment executed at the end of each loop iteration.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: If increment exists, the body becomes a block: { original_body; increment; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wrap that in a while loop with the condition (or true).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If initializer exists, the whole thing becomes a block: { initializer; while_loop; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (increment </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      body </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Block</span><span style=\"color:#E1E4E8\">(List.</span><span style=\"color:#B392F0\">of</span><span style=\"color:#E1E4E8\">(body, </span><span style=\"color:#F97583\">new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">(increment)));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (condition </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) condition </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">While</span><span style=\"color:#E1E4E8\">(condition, body);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (initializer </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      body </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Block</span><span style=\"color:#E1E4E8\">(List.</span><span style=\"color:#B392F0\">of</span><span style=\"color:#E1E4E8\">(initializer, body));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> body;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // returnStmt → \"return\" expression? \";\" ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Stmt </span><span style=\"color:#B392F0\">returnStmt</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Token keyword </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr value </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(SEMICOLON)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    consume</span><span style=\"color:#E1E4E8\">(SEMICOLON, </span><span style=\"color:#9ECBFF\">\"Expect ';' after return value.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Stmt.</span><span style=\"color:#B392F0\">Return</span><span style=\"color:#E1E4E8\">(keyword, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // expression → assignment ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">expression</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> assignment</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // assignment → ( call \".\" )? IDENTIFIER \"=\" assignment | logical_or ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">assignment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 27: Parse a logical_or expression (this will parse the left-hand side).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> logicalOr</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 28: Check if the next token is an '=' (assignment).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(EQUAL)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token equals </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 29: Recursively parse the right-hand side (the value being assigned).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> assignment</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 30: Check if the left-hand side (expr) is a valid assignment target.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Valid targets are: Variable, Get (property access).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (expr </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Expr.Variable) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Token name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((Expr.Variable)expr).name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Assign</span><span style=\"color:#E1E4E8\">(name, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (expr </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Expr.Get) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Expr.Get get </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (Expr.Get)expr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(get.object, get.name, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // If not, report an error (invalid assignment target).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      error</span><span style=\"color:#E1E4E8\">(equals, </span><span style=\"color:#9ECBFF\">\"Invalid assignment target.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // logical_or → logical_and ( \"or\" logical_and )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">logicalOr</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 31: Parse a logical_and expression.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> logicalAnd</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 32: While the next token is 'or', consume it and parse the right-hand logical_and.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(OR)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> logicalAnd</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Logical</span><span style=\"color:#E1E4E8\">(expr, operator, right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // logical_and → equality ( \"and\" equality )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">logicalAnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 33: Parse an equality expression.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> equality</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 34: While the next token is 'and', consume it and parse the right-hand equality.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(AND)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> equality</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Logical</span><span style=\"color:#E1E4E8\">(expr, operator, right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // equality → comparison ( ( \"!=\" | \"==\" ) comparison )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">equality</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 35: Parse a comparison expression.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> comparison</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 36: While the next token is '!=' or '==', consume it and parse the next comparison.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(BANG_EQUAL, EQUAL_EQUAL)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> comparison</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Binary</span><span style=\"color:#E1E4E8\">(expr, operator, right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // comparison → term ( ( \">\" | \">=\" | \"&#x3C;\" | \"&#x3C;=\" ) term )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">comparison</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 37: Parse a term expression.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> term</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 38: While the next token is '>', '>=', '&#x3C;', or '&#x3C;=', consume it and parse the next term.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> term</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Binary</span><span style=\"color:#E1E4E8\">(expr, operator, right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // term → factor ( ( \"-\" | \"+\" ) factor )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">term</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 39: Parse a factor expression.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> factor</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 40: While the next token is '-' or '+', consume it and parse the next factor.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(MINUS, PLUS)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> factor</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Binary</span><span style=\"color:#E1E4E8\">(expr, operator, right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // factor → unary ( ( \"/\" | \"*\" ) unary )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">factor</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 41: Parse a unary expression.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> unary</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 42: While the next token is '/' or '*', consume it and parse the next unary.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(SLASH, STAR)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> unary</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Binary</span><span style=\"color:#E1E4E8\">(expr, operator, right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // unary → ( \"!\" | \"-\" ) unary | call ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">unary</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 43: If the next token is '!' or '-', consume it, recursively parse a unary, and return a Unary node.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(BANG, MINUS)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token operator </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> unary</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Unary</span><span style=\"color:#E1E4E8\">(operator, right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 44: Otherwise, parse a call expression.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // call → primary ( \"(\" arguments? \")\" | \".\" IDENTIFIER )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 45: Start by parsing a primary expression (the leftmost part of the call chain).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> primary</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 46: If we see a '(', this is a function call.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(LEFT_PAREN)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> finishCall</span><span style=\"color:#E1E4E8\">(expr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(DOT)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 47: If we see a '.', this is a property access.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Token name </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> consume</span><span style=\"color:#E1E4E8\">(IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"Expect property name after '.'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(expr, name);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // arguments → expression ( \",\" expression )* ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">finishCall</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">callee</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    List&#x3C;</span><span style=\"color:#F97583\">Expr</span><span style=\"color:#E1E4E8\">> arguments </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> ArrayList&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      do</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (arguments.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 255</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">          error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"Cannot have more than 255 arguments.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        arguments.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">expression</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(COMMA));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Token paren </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> consume</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect ')' after arguments.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Call</span><span style=\"color:#E1E4E8\">(callee, paren, arguments);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // primary → NUMBER | STRING | \"true\" | \"false\" | \"nil\" | \"this\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  //         | \"(\" expression \")\" | IDENTIFIER | \"super\" \".\" IDENTIFIER ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">primary</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 48: Handle literal tokens: NUMBER, STRING, TRUE, FALSE, NIL.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(FALSE)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(TRUE)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(NIL)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(NUMBER, STRING)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">previous</span><span style=\"color:#E1E4E8\">().literal);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 49: Handle the 'this' keyword.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(THIS)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">This</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">previous</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 50: Handle the 'super' keyword for superclass method calls.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(SUPER)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token keyword </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      consume</span><span style=\"color:#E1E4E8\">(DOT, </span><span style=\"color:#9ECBFF\">\"Expect '.' after 'super'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Token method </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> consume</span><span style=\"color:#E1E4E8\">(IDENTIFIER, </span><span style=\"color:#9ECBFF\">\"Expect superclass method name.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Super</span><span style=\"color:#E1E4E8\">(keyword, method);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 51: Handle identifier (variable name).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(IDENTIFIER)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Variable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">previous</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 52: Handle grouping parentheses.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(LEFT_PAREN)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Expr expr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> expression</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      consume</span><span style=\"color:#E1E4E8\">(RIGHT_PAREN, </span><span style=\"color:#9ECBFF\">\"Expect ')' after expression.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Grouping</span><span style=\"color:#E1E4E8\">(expr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 53: If none of the above match, throw a parse error.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"Expect expression.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // ========== Parser Utility Methods ==========</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> match</span><span style=\"color:#E1E4E8\">(TokenType... </span><span style=\"color:#FFAB70\">types</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (TokenType type </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> types) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(type)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Token </span><span style=\"color:#B392F0\">consume</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(type)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">(), message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> check</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> peek</span><span style=\"color:#E1E4E8\">().type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Token </span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) current</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> previous</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isAtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> peek</span><span style=\"color:#E1E4E8\">().type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EOF;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Token </span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tokens.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(current);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Token </span><span style=\"color:#B392F0\">previous</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tokens.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(current </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> ParseError </span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Lox.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(token, message); </span><span style=\"color:#6A737D\">// Assume Lox.error reports the error to the user.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> synchronize</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">previous</span><span style=\"color:#E1E4E8\">().type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SEMICOLON) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      switch</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">().type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> CLASS</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> FUN</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> VAR</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> FOR</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> IF</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> WHILE</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> PRINT</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> RETURN</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">          return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li>Use <code>final</code> fields in AST node classes to enforce immutability.</li>\n<li>The <code>Object</code> type for <code>Literal.value</code> and <code>Token.literal</code> can hold <code>Double</code>, <code>String</code>, <code>Boolean</code>, or <code>null</code> (for <code>nil</code>). Be cautious with autoboxing.</li>\n<li>Use <code>List&lt;Stmt&gt;</code> and <code>List&lt;Expr&gt;</code> from <code>java.util</code>. For mutable lists during parsing, use <code>ArrayList</code>.</li>\n<li>The <code>ParseError</code> class extends <code>RuntimeException</code> but is used as a checked exception for control flow within the parser&#39;s error recovery. This is a slight abuse but keeps code simple.</li>\n<li>The <code>synchronize()</code> method uses a <code>switch</code> on <code>TokenType</code>; ensure your <code>TokenType</code> enum includes all statement-starting keywords.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong>\nAfter implementing the AST classes and the parser (Milestones 2 &amp; 3), you can verify your work with a simple test:</p>\n<ol>\n<li><strong>Create a test Lox program</strong>, <code>test.lox</code>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    var a = 1 + 2 * 3;\n    print a;\n    if (a &gt; 5) {\n      print &quot;greater&quot;;\n    } else {\n      print &quot;less or equal&quot;;\n    }</code></pre></div>\n<ol start=\"2\">\n<li><strong>Add a temporary main method or test</strong> that reads this file, runs the scanner to get tokens, passes them to the parser, and prints the resulting AST using a <code>PrettyPrinter</code> visitor (which you should implement as part of Milestone 2).</li>\n<li><strong>Run your test</strong>. The expected output should be a correctly parenthesized S-expression reflecting precedence and grouping:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    (block\n      (var a (= (group (+ 1 (* 2 3)))))\n      (print (variable a))\n      (if (&gt; (variable a) 5)\n        (block (print &quot;greater&quot;))\n        (block (print &quot;less or equal&quot;)))\n    )</code></pre></div>\n<ol start=\"4\">\n<li><strong>Signs of Success</strong>: The parser runs without throwing a <code>ParseError</code>. The AST structure matches the expected precedence (<code>*</code> before <code>+</code>). The <code>if</code> statement&#39;s condition and branches are correctly nested.</li>\n<li><strong>Common Failure Modes</strong>:<ul>\n<li><strong>Infinite loop/stack overflow</strong>: Likely due to left-recursion in a grammar rule. Review your <code>expression()</code>, <code>equality()</code>, etc., to ensure they always consume a token before any recursive call.</li>\n<li><strong>Incorrect AST (wrong precedence)</strong>: Verify the order of calls in your expression parsing cascade. The function for lower precedence (like <code>term</code>) must call the function for higher precedence (<code>factor</code>), not the other way around.</li>\n<li><strong>&quot;Expect expression&quot; error on valid code</strong>: Your <code>primary()</code> method might not handle all token types (like <code>IDENTIFIER</code> or <code>NUMBER</code>). Ensure all literal types and the grouping <code>(</code> are covered.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 - Evaluating Expressions, Milestone 5 - Statements and State, Milestone 6 - Control Flow</p>\n</blockquote>\n<h2 id=\"53-component-design-core-interpreter-milestones-4-5-6\">5.3 Component Design: Core Interpreter [Milestones 4, 5, 6]</h2>\n<p>This section details the design of the <strong>Interpreter</strong>, the component responsible for bringing Lox programs to life. It takes the static Abstract Syntax Tree produced by the parser and animates it by walking its structure, evaluating expressions and executing statements to produce observable side effects. This component introduces dynamic runtime behavior, state management through environments, and control flow—transforming a declarative program description into executable logic.</p>\n<h3 id=\"mental-model-the-tree-walking-executor\">Mental Model: The Tree-Walking Executor</h3>\n<p>Imagine the interpreter as a puppeteer, and the AST as a complex marionette. The puppeteer doesn&#39;t see the entire puppet at once but instead walks along its strings (the AST edges), visiting each joint (node) in a predetermined order. At each joint, the puppeteer performs a specific action based on the joint&#39;s type: for a <strong><code>Binary</code></strong> node, they calculate a mathematical result by combining the values from its two child strings; for an <strong><code>If</code></strong> node, they check a condition and decide which branch string to follow next. The puppeteer carries with them a notebook—the <strong><code>Environment</code></strong>—where they record and look up variable names and their current values as they move through different scopes (like changing rooms in a theater). This hands-on, step-by-step navigation of the tree structure is the essence of tree-walking interpretation—direct, intuitive, and a perfect match for educational implementation.</p>\n<h3 id=\"interface-the-evaluate-and-execute-methods\">Interface: The Evaluate and Execute Methods</h3>\n<p>The interpreter&#39;s public interface is minimal, centered on two core dispatch methods that serve as entry points for interpreting different types of AST nodes. Internally, it maintains the runtime state through an environment chain and handles control flow.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>interpret</code></td>\n<td><code>List&lt;Stmt&gt;</code> statements</td>\n<td><code>void</code></td>\n<td>The primary public method. Takes a list of statements (the top-level program) and executes them sequentially. Internally, it calls <code>execute</code> on each statement.</td>\n</tr>\n<tr>\n<td><code>evaluate</code></td>\n<td><code>Expr</code> expression</td>\n<td><code>Object</code> (runtime value)</td>\n<td>Dispatches to the appropriate <code>visit</code> method for an expression node, recursively evaluates its subexpressions, and returns the computed runtime value (e.g., a Java <code>Double</code> for numbers, <code>String</code> for strings).</td>\n</tr>\n<tr>\n<td><code>execute</code></td>\n<td><code>Stmt</code> statement</td>\n<td><code>void</code></td>\n<td>Dispatches to the appropriate <code>visit</code> method for a statement node, performing its side effects (e.g., printing, variable assignment, control flow).</td>\n</tr>\n<tr>\n<td><code>executeBlock</code></td>\n<td><code>List&lt;Stmt&gt;</code> statements, <code>Environment</code> environment</td>\n<td><code>void</code></td>\n<td>A specialized method for executing a block of statements within a new, nested environment. This is called from <code>visitBlockStmt</code> and is key to implementing lexical scoping.</td>\n</tr>\n</tbody></table>\n<p>The interpreter also maintains critical internal state:</p>\n<table>\n<thead>\n<tr>\n<th>State Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>globals</code></td>\n<td><code>Environment</code></td>\n<td>The outermost environment, shared across all interpretations. Contains built-in functions and global variable definitions. Persists for the lifetime of the interpreter.</td>\n</tr>\n<tr>\n<td><code>environment</code></td>\n<td><code>Environment</code></td>\n<td>A reference to the <em>current</em> active environment. This reference changes as the interpreter enters and exits blocks, functions, and other scopes. Initially points to <code>globals</code>.</td>\n</tr>\n<tr>\n<td><code>locals</code></td>\n<td><code>Map&lt;Expr, Integer&gt;</code></td>\n<td>An optional optimization mapping from expression nodes (particularly <code>Variable</code> and <code>Assign</code>) to the number of environment &quot;hops&quot; required to resolve them. Used for efficient variable lookup in the presence of closures (detailed in Section 5.4).</td>\n</tr>\n</tbody></table>\n<p>The interpreter implements the <strong><code>Expr.Visitor&lt;Object&gt;</code></strong> and <strong><code>Stmt.Visitor&lt;Void&gt;</code></strong> interfaces generated in Section 5.2. Each <code>visit</code> method (e.g., <code>visitBinaryExpr</code>, <code>visitPrintStmt</code>) contains the logic to evaluate or execute that specific node type. The <code>evaluate</code> and <code>execute</code> methods are thin wrappers that call <code>expression.accept(this)</code> or <code>statement.accept(this)</code>, leveraging the Visitor pattern&#39;s double dispatch.</p>\n<h3 id=\"evaluation-and-execution-algorithms\">Evaluation and Execution Algorithms</h3>\n<p>The interpreter&#39;s logic is defined by the collection of <code>visit</code> methods. Below are detailed, step-by-step algorithms for the core expression and statement types covered in Milestones 4-6. Each algorithm assumes it is operating within the context of the current <code>environment</code>.</p>\n<h4 id=\"expression-evaluation-algorithms\">Expression Evaluation Algorithms</h4>\n<ol>\n<li><p><strong><code>visitLiteralExpr</code> (for <code>Literal</code> nodes):</strong></p>\n<ol>\n<li>Return the <code>value</code> field stored in the node directly. This value is the Java object (e.g., <code>Double</code>, <code>String</code>, <code>Boolean</code>, <code>null</code> for nil) placed there by the parser after reading the token&#39;s literal.</li>\n</ol>\n</li>\n<li><p><strong><code>visitGroupingExpr</code> (for <code>Grouping</code> nodes):</strong></p>\n<ol>\n<li>Recursively <code>evaluate</code> the inner <code>expression</code> field.</li>\n<li>Return the resulting value. The grouping parentheses only affect parsing precedence; they have no runtime effect.</li>\n</ol>\n</li>\n<li><p><strong><code>visitUnaryExpr</code> (for <code>Unary</code> nodes):</strong></p>\n<ol>\n<li>Evaluate the <code>right</code> operand expression by calling <code>evaluate</code>.</li>\n<li>Inspect the <code>operator.type</code>:<ul>\n<li>If <code>BANG</code> (<code>!</code>): Apply Lox&#39;s <strong>truthiness</strong> rule. Determine if the operand value is &quot;falsy&quot; (only <code>false</code> or <code>nil</code>). Return the logical negation: <code>true</code> if the operand is falsy, <code>false</code> otherwise.</li>\n<li>If <code>MINUS</code> (<code>-</code>): Check that the operand is a number (Java <code>Double</code>). If not, throw a <code>RuntimeError</code>. If it is, negate its numeric value and return the new <code>Double</code>.</li>\n</ul>\n</li>\n<li>Return the computed result.</li>\n</ol>\n</li>\n<li><p><strong><code>visitBinaryExpr</code> (for <code>Binary</code> nodes):</strong></p>\n<ol>\n<li>Evaluate the <code>left</code> operand expression.</li>\n<li><strong>Short-circuit evaluation for <code>OR</code> and <code>AND</code> (logical operators):</strong><ul>\n<li>For <code>OR</code>: If the left operand is <em>truthy</em>, return it immediately without evaluating the right operand.</li>\n<li>For <code>AND</code>: If the left operand is <em>falsy</em>, return it immediately without evaluating the right operand.</li>\n</ul>\n</li>\n<li>If not short-circuited, evaluate the <code>right</code> operand.</li>\n<li>Based on the <code>operator.type</code>, perform the operation:<ul>\n<li><strong>Arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)</strong>: Ensure both operands are numbers (<code>Double</code>). For <code>+</code>, also allow the special case where <em>either</em> operand is a <code>String</code>, in which case perform string concatenation (converting the other operand to its string representation). Perform the arithmetic operation and return the numeric result.</li>\n<li><strong>Comparison (<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>)</strong>: Ensure both operands are numbers. Perform the numeric comparison and return a Java <code>Boolean</code>.</li>\n<li><strong>Equality (<code>==</code>, <code>!=</code>)</strong>: These operators work on operands of <em>any</em> type. Two values are equal if they are the same Java object (for references) or have the same primitive value. <code>nil</code> is only equal to <code>nil</code>.</li>\n</ul>\n</li>\n<li>If any type check fails, throw a <code>RuntimeError</code>.</li>\n</ol>\n</li>\n<li><p><strong><code>visitVariableExpr</code> (for <code>Variable</code> nodes):</strong></p>\n<ol>\n<li>Look up the variable&#39;s name (<code>name.lexeme</code>) in the environment chain. Use <code>environment.get(name)</code>.</li>\n<li>If the name is found, return its bound value.</li>\n<li>If the name is not found (i.e., the variable is undefined), throw a <code>RuntimeError</code>.</li>\n</ol>\n</li>\n<li><p><strong><code>visitAssignExpr</code> (for <code>Assign</code> nodes):</strong></p>\n<ol>\n<li>Evaluate the <code>value</code> expression to get the new value.</li>\n<li>Assign this value to the variable named <code>name.lexeme</code> in the appropriate environment. Use <code>environment.assign(name, value)</code>. This method searches outward through the environment chain for an existing binding and updates it.</li>\n<li>If the variable is not found (was never declared), <code>assign</code> throws a <code>RuntimeError</code>.</li>\n<li>Return the assigned value (assignment is an expression in Lox).</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"statement-execution-algorithms\">Statement Execution Algorithms</h4>\n<ol>\n<li><p><strong><code>visitExpressionStmt</code> (for <code>Expression</code> nodes):</strong></p>\n<ol>\n<li>Evaluate the contained <code>expression</code>.</li>\n<li>Discard the result. This statement exists solely for side effects (e.g., a function call or assignment).</li>\n</ol>\n</li>\n<li><p><strong><code>visitPrintStmt</code> (for <code>Print</code> nodes):</strong></p>\n<ol>\n<li>Evaluate the <code>expression</code>.</li>\n<li>Convert the resulting value to its string representation (using a helper <code>stringify</code> method that handles <code>nil</code> and numbers without trailing <code>.0</code>).</li>\n<li>Print the string to standard output, typically followed by a newline.</li>\n</ol>\n</li>\n<li><p><strong><code>visitVarStmt</code> (for <code>Var</code> nodes):</strong></p>\n<ol>\n<li>Initialize a value: if the <code>initializer</code> field is not <code>null</code>, evaluate it; otherwise, use <code>nil</code> (<code>null</code> in Java).</li>\n<li>Define a new variable in the <em>current</em> environment with <code>name.lexeme</code> bound to this value. Use <code>environment.define(name.lexeme, value)</code>.</li>\n</ol>\n</li>\n<li><p><strong><code>visitBlockStmt</code> (for <code>Block</code> nodes):</strong></p>\n<ol>\n<li>Create a new <code>Environment</code> object whose enclosing/parent environment is the <em>current</em> <code>environment</code>.</li>\n<li>Execute the list of <code>statements</code> within this newly created environment. This is done by calling the dedicated <code>executeBlock</code> method, which temporarily swaps the interpreter&#39;s <code>environment</code> reference, runs the statements, and then restores the previous environment.</li>\n<li>This nested environment is discarded when the block finishes, implementing block-level scoping.</li>\n</ol>\n</li>\n<li><p><strong><code>visitIfStmt</code> (for <code>If</code> nodes):</strong></p>\n<ol>\n<li>Evaluate the <code>condition</code> expression.</li>\n<li>Apply the truthiness rule: if the result is truthy (not <code>false</code> or <code>nil</code>), <code>execute</code> the <code>thenBranch</code> statement.</li>\n<li>Otherwise, if an <code>elseBranch</code> exists, <code>execute</code> it.</li>\n</ol>\n</li>\n<li><p><strong><code>visitWhileStmt</code> (for <code>While</code> nodes):</strong></p>\n<ol>\n<li>Evaluate the <code>condition</code>.</li>\n<li>If the condition is truthy:<ul>\n<li><code>Execute</code> the <code>body</code> statement.</li>\n<li>Jump back to step 1 (re-evaluate the condition).</li>\n</ul>\n</li>\n<li>If the condition is falsy, exit the loop and continue with the next statement.</li>\n</ol>\n</li>\n<li><p><strong><code>visitLogicalExpr</code> (for <code>Logical</code> nodes):</strong> (While an expression, its algorithm is closely tied to control flow via short-circuiting, as described in step 4.ii of the binary expression algorithm above).</p>\n</li>\n</ol>\n<h3 id=\"adr-dynamic-type-checking-strategy\">ADR: Dynamic Type Checking Strategy</h3>\n<blockquote>\n<p><strong>Decision: Perform Runtime Type Checks at Each Operation Site</strong></p>\n<ul>\n<li><strong>Context</strong>: Lox is a dynamically typed language. The type of an expression (number, string, boolean, etc.) is only known at runtime when the expression is evaluated. We must ensure operations like addition or comparison are only applied to compatible operand types to maintain language semantics and prevent undefined behavior.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Inline Type Guards</strong>: Within each <code>visit</code> method (e.g., <code>visitBinaryExpr</code>), check the types of the evaluated operands immediately before performing the operation. Throw a <code>RuntimeError</code> on mismatch.</li>\n<li><strong>Centralized Type Validation</strong>: Create a separate <code>TypeChecker</code> component that performs all type validation in a separate, pre-evaluation pass over the AST. This pass would annotate nodes with expected types or flag type errors statically.</li>\n<li><strong>Coercive Typing</strong>: Automatically convert operands to a common type (e.g., converting numbers to strings in <code>+</code> operations, or treating any non-number as <code>0</code> in arithmetic). This is common in languages like JavaScript but not Lox&#39;s specified semantics.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We chose <strong>Option 1: Inline Type Guards</strong>.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Simplicity and Direct Mapping</strong>: It is the most straightforward approach for a tree-walking interpreter. The logic for an operation (e.g., &quot;add two numbers&quot;) and the check for its preconditions (&quot;are both operands numbers?&quot;) are colocated, making the code easier to understand and debug for learners.</li>\n<li><strong>Faithfulness to Lox Semantics</strong>: Lox&#39;s specification calls for runtime type errors, not static type warnings. A separate type-checking pass (Option 2) adds significant complexity (a fourth phase to the interpreter) for a feature not required by the language.</li>\n<li><strong>Explicit Error Messages</strong>: Inline checks allow for very specific, context-rich error messages (e.g., &quot;Operands must be two numbers or two strings for addition.&quot;) at the exact point of failure.</li>\n<li><strong>Performance Adequacy</strong>: For an educational interpreter, the performance overhead of repeated type checks is negligible and does not justify the complexity of the other options.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: The implementation is clear, modular, and easy to extend. Adding a new operation only requires modifying one <code>visit</code> method.</li>\n<li><strong>Negative</strong>: Type errors are only caught when the erroneous code path is executed, not during a &quot;compile&quot; phase. A program with a latent type error in an unused function will run without complaint until that function is called.</li>\n<li><strong>Trade-off Accepted</strong>: We prioritize implementation clarity and alignment with Lox&#39;s dynamic nature over early error detection.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Inline Type Guards</td>\n<td>Simple, direct, clear error messages, faithful to dynamic typing.</td>\n<td>Errors are runtime-only, not static.</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Centralized Type Validation</td>\n<td>Catches errors before execution, can enable optimizations.</td>\n<td>High complexity, not required by Lox, conflates static and dynamic analysis.</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Coercive Typing</td>\n<td>More forgiving for programmers, can reduce runtime errors.</td>\n<td>Changes language semantics, can hide bugs, less predictable behavior.</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Confusing Java <code>null</code> with Lox <code>nil</code></strong></p>\n<ul>\n<li><strong>Description</strong>: Using Java&#39;s <code>null</code> reference directly to represent Lox&#39;s <code>nil</code> can lead to <code>NullPointerException</code>s if you forget to handle <code>null</code> before calling methods like <code>toString()</code> or before performing operations. Also, the truthiness rule must explicitly treat Java <code>null</code> as falsy.</li>\n<li><strong>Why it&#39;s wrong</strong>: It breaks the interpreter when <code>nil</code> values flow into operations or print statements. The interpreter must treat <code>nil</code> as a valid, first-class runtime value.</li>\n<li><strong>How to fix</strong>: Create a dedicated singleton object (e.g., <code>public static final Object NIL = new Object();</code>) to represent Lox&#39;s <code>nil</code>. Alternatively, consistently check for Java <code>null</code> before any operation and treat it according to Lox&#39;s rules. A <code>stringify()</code> helper method should explicitly return the string <code>&quot;nil&quot;</code> for <code>null</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Improper Scoping Leading to Shadowing Bugs</strong></p>\n<ul>\n<li><strong>Description</strong>: Incorrectly managing the <code>environment</code> reference when entering/exiting blocks can cause variables from an outer scope to become inaccessible (if the new environment doesn&#39;t link to the parent) or cause changes in an inner scope to incorrectly modify an outer variable (if you reuse the same environment object).</li>\n<li><strong>Why it&#39;s wrong</strong>: This violates lexical scoping rules. Variables should be correctly shadowed, and inner blocks should not pollute outer scopes unless using <code>var</code> at the outer level.</li>\n<li><strong>How to fix</strong>: Meticulously follow the <code>executeBlock</code> pattern: 1) Create a <em>new</em> <code>Environment</code> with the current one as its parent. 2) Use a temporary variable to save the old <code>environment</code> reference. 3) Set the interpreter&#39;s <code>environment</code> to the new one. 4) Execute the statements. 5) <strong>Restore</strong> the saved environment reference. This ensures a clean scope hierarchy.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting Short-Circuit Evaluation in Logical Operators</strong></p>\n<ul>\n<li><strong>Description</strong>: Implementing <code>visitLogicalExpr</code> by evaluating both the <code>left</code> and <code>right</code> operands unconditionally before checking the operator.</li>\n<li><strong>Why it&#39;s wrong</strong>: This breaks the defined semantics of <code>and</code> and <code>or</code>. For <code>false and someFunction()</code>, <code>someFunction()</code> should never be called. This is not just an optimization; it&#39;s a semantic requirement that affects programs with side effects.</li>\n<li><strong>How to fix</strong>: Implement the algorithm described in Step 4.ii of the Binary Expression algorithm. Evaluate the left operand first. For <code>or</code>, if truthy, return it. For <code>and</code>, if falsy, return it. Only evaluate the right operand if needed.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Infinite Loops Without a Safety Net</strong></p>\n<ul>\n<li><strong>Description</strong>: A simple <code>while (true) {}</code> loop will cause the interpreter to hang forever, as there&#39;s no mechanism to interrupt execution.</li>\n<li><strong>Why it&#39;s wrong</strong>: While this is semantically correct for Lox, it&#39;s a poor user experience in an educational environment, especially in a REPL.</li>\n<li><strong>How to fix</strong>: Consider adding an optional loop iteration limit or a timeout mechanism, particularly in the REPL mode. This can be implemented as a counter in the <code>visitWhileStmt</code> method that increments each iteration and throws a <code>RuntimeError</code> if a threshold (e.g., 10,000) is exceeded. Document this as a non-standard, educational extension.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Recommended for Learning)</th>\n<th>Advanced Option (For Further Exploration)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Value Representation</td>\n<td>Java <code>Object</code> (using <code>Double</code>, <code>String</code>, <code>Boolean</code>, and <code>null</code>/a sentinel for <code>nil</code>)</td>\n<td>Define a sealed hierarchy <code>LoxValue</code> with subclasses <code>LoxNumber</code>, <code>LoxString</code>, etc.</td>\n</tr>\n<tr>\n<td>Environment Lookup</td>\n<td>Linear chain search via <code>Map&lt;String, Object&gt;</code> and parent reference.</td>\n<td>Implement persistent hash maps or indexed environments for faster lookups in deep chains.</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td>Basic <code>RuntimeError</code> with message and token line number.</td>\n<td>Collect stack traces on error, showing the call chain.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>src/\n└── com/\n    └── craftinginterpreters/\n        └── lox/\n            ├── Lox.java                 # Main CLI/REPL launcher\n            ├── Token.java               # Token data class\n            ├── TokenType.java           # Token type enum\n            ├── Scanner.java             # Lexer (Milestone 1)\n            ├── Expr.java                # Expression AST nodes (Visitor pattern)\n            ├── Stmt.java                # Statement AST nodes (Visitor pattern)\n            ├── Parser.java              # Recursive descent parser (Milestones 2 &amp; 3)\n            ├── Interpreter.java         # **This component** (Milestones 4, 5, 6)\n            ├── Environment.java         # Runtime environment chain\n            ├── RuntimeError.java        # Exception for runtime errors\n            └── (Later: LoxFunction.java, LoxClass.java, etc.)</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code (COMPLETE)</strong></p>\n<p><em>RuntimeError.java</em> (Complete):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> RuntimeException</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    final</span><span style=\"color:#E1E4E8\"> Token token; </span><span style=\"color:#6A737D\">// The token where the error occurred (for line number)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">(message);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><em>Environment.java</em> (Complete - core logic):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.HashMap;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Map;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    final</span><span style=\"color:#E1E4E8\"> Environment enclosing;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Map&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> values </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> HashMap&#x3C;>();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Constructor for global scope</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        enclosing </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Constructor for local scope</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">(Environment </span><span style=\"color:#FFAB70\">enclosing</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.enclosing </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enclosing;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Define a new variable in the current scope</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(name, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get the value of a variable, searching outward</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (values.</span><span style=\"color:#B392F0\">containsKey</span><span style=\"color:#E1E4E8\">(name.lexeme)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> values.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(name.lexeme);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Look in parent scope</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (enclosing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> enclosing.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(name);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Not found anywhere</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#E1E4E8\">(name, </span><span style=\"color:#9ECBFF\">\"Undefined variable '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> name.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Assign to an existing variable, searching outward</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> assign</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (values.</span><span style=\"color:#B392F0\">containsKey</span><span style=\"color:#E1E4E8\">(name.lexeme)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            values.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(name.lexeme, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Look in parent scope</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (enclosing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            enclosing.</span><span style=\"color:#B392F0\">assign</span><span style=\"color:#E1E4E8\">(name, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#E1E4E8\">(name, </span><span style=\"color:#9ECBFF\">\"Undefined variable '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> name.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'.\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><em>Interpreter.java</em> (Skeleton with TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> Expr.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Stmt.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Void</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The global environment, shared across interpretations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    final</span><span style=\"color:#E1E4E8\"> Environment globals </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The current active environment (changes with scope)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#E1E4E8\"> Environment environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> globals;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1 (Optional): Add native functions to globals here later</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // e.g., define a \"clock()\" function.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main public API</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> interpret</span><span style=\"color:#E1E4E8\">(List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">statements</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (Stmt statement </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> statements) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                execute</span><span style=\"color:#E1E4E8\">(statement);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (RuntimeError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Lox.</span><span style=\"color:#B392F0\">runtimeError</span><span style=\"color:#E1E4E8\">(error);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Expression Visitor Methods ---</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitLiteralExpr</span><span style=\"color:#E1E4E8\">(Expr.Literal </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return the literal value stored in the node.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitGroupingExpr</span><span style=\"color:#E1E4E8\">(Expr.Grouping </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Evaluate the inner expression and return its value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitUnaryExpr</span><span style=\"color:#E1E4E8\">(Expr.Unary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(expr.right);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (expr.operator.type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> BANG</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 4: Return the logical negation of 'right'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Apply Lox truthiness: false and nil are false, everything else true.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> MINUS</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 5: Check that 'right' is a number (Double).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // If not, throw a RuntimeError with expr.operator.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // If it is, negate it and return the new Double.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Unreachable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(Expr.Binary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object left </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(expr.left);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(expr.right); </span><span style=\"color:#6A737D\">// **CAUTION**: See TODO 6 about short-circuit.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (expr.operator.type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> GREATER</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 7: Check both operands are numbers. Compare, return Boolean.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> GREATER_EQUAL</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 8: Check both operands are numbers. Compare, return Boolean.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> LESS</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 9: Check both operads are numbers. Compare, return Boolean.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> LESS_EQUAL</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 10: Check both operands are numbers. Compare, return Boolean.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> MINUS</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 11: Check both operands are numbers. Subtract, return Double.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> SLASH</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 12: Check both operands are numbers. Divide, return Double.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Bonus: Check for division by zero.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> STAR</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 13: Check both operands are numbers. Multiply, return Double.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> PLUS</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 14: Handle addition and string concatenation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // If both are Doubles, add.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // If both are Strings, concatenate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // If one is String and one is Number, convert Number to string and concatenate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Otherwise, throw RuntimeError.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> BANG_EQUAL</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 15: Return !isEqual(left, right)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> EQUAL_EQUAL</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 16: Return isEqual(left, right)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Logical operators (short-circuit handled separately in visitLogicalExpr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Unreachable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitVariableExpr</span><span style=\"color:#E1E4E8\">(Expr.Variable </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 17: Look up the variable name in the environment and return its value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitAssignExpr</span><span style=\"color:#E1E4E8\">(Expr.Assign </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(expr.value);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 18: Assign the value to the variable in the environment.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Use environment.assign(...). Then return the value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitLogicalExpr</span><span style=\"color:#E1E4E8\">(Expr.Logical </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object left </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(expr.left);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 19: Implement short-circuit logic.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If operator is OR and left is truthy, return left.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If operator is AND and left is falsy, return left.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Otherwise, evaluate the right operand and return it.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Statement Visitor Methods ---</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitExpressionStmt</span><span style=\"color:#E1E4E8\">(Stmt.Expression </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        evaluate</span><span style=\"color:#E1E4E8\">(stmt.expression);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 20: Evaluate the expression and discard the result.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitPrintStmt</span><span style=\"color:#E1E4E8\">(Stmt.Print </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(stmt.expression);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 21: Convert value to string using stringify() and print it.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(value));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitVarStmt</span><span style=\"color:#E1E4E8\">(Stmt.Var </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object value </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (stmt.initializer </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(stmt.initializer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 22: Define the variable in the current environment with this value.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        environment.</span><span style=\"color:#B392F0\">define</span><span style=\"color:#E1E4E8\">(stmt.name.lexeme, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitBlockStmt</span><span style=\"color:#E1E4E8\">(Stmt.Block </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 23: Execute the block of statements in a new nested environment.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. Create new Environment with current environment as parent.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. Call executeBlock(stmt.statements, newEnvironment).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        executeBlock</span><span style=\"color:#E1E4E8\">(stmt.statements, </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">(environment));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitIfStmt</span><span style=\"color:#E1E4E8\">(Stmt.If </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 24: Evaluate condition. If truthy, execute thenBranch.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If falsy and elseBranch exists, execute elseBranch.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isTruthy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">evaluate</span><span style=\"color:#E1E4E8\">(stmt.condition))) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            execute</span><span style=\"color:#E1E4E8\">(stmt.thenBranch);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (stmt.elseBranch </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            execute</span><span style=\"color:#E1E4E8\">(stmt.elseBranch);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitWhileStmt</span><span style=\"color:#E1E4E8\">(Stmt.While </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 25: While the condition evaluates to truthy, execute the body.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isTruthy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">evaluate</span><span style=\"color:#E1E4E8\">(stmt.condition))) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            execute</span><span style=\"color:#E1E4E8\">(stmt.body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Helper Methods ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> execute</span><span style=\"color:#E1E4E8\">(Stmt </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.</span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">evaluate</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> expr.</span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> executeBlock</span><span style=\"color:#E1E4E8\">(List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">statements</span><span style=\"color:#E1E4E8\">, Environment </span><span style=\"color:#FFAB70\">environment</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Environment previous </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.environment;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> environment;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (Stmt statement </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> statements) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                execute</span><span style=\"color:#E1E4E8\">(statement);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">finally</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 26: Restore the previous environment, even if an exception is thrown.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> previous;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper: Lox truthiness rule</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isTruthy</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">object</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 27: Return false if object is null (nil) or Boolean.FALSE.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Return true for everything else.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (object </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (object </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Boolean) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">boolean</span><span style=\"color:#E1E4E8\">) object;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper: Deep equality for Lox values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isEqual</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 28: Handle nil/null equality.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If both are null, return true.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If only one is null, return false.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Otherwise, use Java's equals().</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> a.</span><span style=\"color:#B392F0\">equals</span><span style=\"color:#E1E4E8\">(b);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper: Convert a Lox value to its string representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">object</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 29: Convert object to a readable string.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If null, return \"nil\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If it's a Double, remove trailing \".0\" if it's an integer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Otherwise, use Java's toString().</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (object </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"nil\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (object </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Double) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            String text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> object.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (text.</span><span style=\"color:#B392F0\">endsWith</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\".0\"</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text.</span><span style=\"color:#B392F0\">substring</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, text.</span><span style=\"color:#B392F0\">length</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> text;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> object.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li>Use <code>instanceof</code> for type checks (e.g., <code>right instanceof Double</code>).</li>\n<li>Cast carefully after <code>instanceof</code> checks (e.g., <code>double rightValue = (Double)right;</code>).</li>\n<li>Remember that Java&#39;s <code>==</code> for <code>Double</code> objects checks reference equality, not numeric equality. Use <code>.equals()</code> or compare the primitive <code>doubleValue()</code>.</li>\n<li>The <code>isTruthy</code> helper is critical and used frequently. Keep its logic simple and in one place.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong>\nAfter implementing this section, you should be able to run Lox programs with variables, arithmetic, print statements, and control flow.</p>\n<ol>\n<li><strong>Test Command</strong>: Create a test file <code>test.lox</code>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lox</span><pre class=\"arch-pre shiki-highlighted\"><code>    var a = 5;\n    var b = 10;\n    print a + b; // Should print 15\n\n    if (a &lt; b) {\n        print &quot;a is smaller&quot;;\n    } else {\n        print &quot;a is not smaller&quot;;\n    }\n\n    var counter = 0;\n    while (counter &lt; 3) {\n        print counter;\n        counter = counter + 1;\n    }</code></pre></div>\n<ol start=\"2\">\n<li><strong>Expected Output</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    15\n    a is smaller\n    0\n    1\n    2</code></pre></div>\n<ol start=\"3\">\n<li><strong>Verification</strong>: Run your interpreter (e.g., <code>java com.craftinginterpreters.lox.Lox test.lox</code>). The output should match exactly.</li>\n<li><strong>Signs of Trouble</strong>:<ul>\n<li><code>NullPointerException</code>: Likely missing null/nil handling in <code>stringify</code> or <code>isTruthy</code>.</li>\n<li><code>&quot;Undefined variable&quot;</code> error for a declared variable: Check that <code>environment.define</code> is being called and that scopes (<code>executeBlock</code>) are managing the environment chain correctly.</li>\n<li>Infinite loop: Verify the condition in <code>visitWhileStmt</code> is being re-evaluated each iteration.</li>\n</ul>\n</li>\n</ol>\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>All numbers print with &quot;.0&quot; (e.g., &quot;15.0&quot;)</td>\n<td>The <code>stringify</code> method isn&#39;t stripping the <code>.0</code> from integer-valued doubles.</td>\n<td>Check the <code>stringify</code> logic for <code>Double</code> objects.</td>\n<td>Implement the substring logic shown in TODO 29.</td>\n</tr>\n<tr>\n<td><code>if</code> statement never executes the <code>else</code> branch</td>\n<td>The truthiness condition (<code>isTruthy</code>) is incorrect, possibly treating <code>false</code> as truthy.</td>\n<td>Add a debug print in <code>isTruthy</code> or test with <code>if (false) print &quot;wrong&quot;; else print &quot;right&quot;;</code></td>\n<td>Ensure <code>isTruthy</code> returns <code>false</code> for <code>Boolean.FALSE</code>.</td>\n</tr>\n<tr>\n<td>Changing a variable inside a block affects an outer variable with the same name</td>\n<td>The block is not creating a new environment; you&#39;re using the same <code>Map</code>.</td>\n<td>Print the environment reference before/after entering a block.</td>\n<td>Ensure <code>new Environment(environment)</code> is called in <code>visitBlockStmt</code>.</td>\n</tr>\n<tr>\n<td><code>while</code> loop runs one extra time or not at all</td>\n<td>The condition is evaluated at the wrong time (e.g., only once before the loop).</td>\n<td>Trace the order of <code>evaluate(condition)</code> and <code>execute(body)</code> in <code>visitWhileStmt</code>.</td>\n<td>The condition must be evaluated <em>before each</em> iteration, including the first.</td>\n</tr>\n</tbody></table>\n<h2 id=\"54-component-design-functions-and-closures-milestones-7-amp-8\">5.4 Component Design: Functions and Closures [Milestones 7 &amp; 8]</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 7 - Functions, Milestone 8 - Closures</p>\n</blockquote>\n<p>This section extends the interpreter&#39;s capabilities from simple statements and expressions to <strong>first-class functions</strong>, <strong>function calls</strong>, <strong>return statements</strong>, and <strong>lexical scoping via closures</strong>. These features transform the interpreter from a calculator into a true programming language, enabling code organization, abstraction, and powerful functional patterns.</p>\n<h3 id=\"mental-model-the-function-as-a-recipe-with-a-kitchen\">Mental Model: The Function as a Recipe with a Kitchen</h3>\n<p>Before diving into technical details, let&#39;s build intuition with an analogy. Think of a function as a <strong>recipe</strong> with two essential parts:</p>\n<ol>\n<li><strong>The Recipe Card (Function Declaration):</strong> This contains the list of ingredients (parameters) and the step-by-step instructions (body statements).</li>\n<li><strong>The Kitchen (Environment):</strong> This is where the cooking happens, containing all the available ingredients (variables) at the time the recipe is written.</li>\n</ol>\n<p>When you define a function, you&#39;re creating a recipe card. When you call it, you:</p>\n<ul>\n<li>Gather the actual ingredients (evaluate arguments)</li>\n<li>Set up a clean work area (create a new environment)</li>\n<li>Place the measured ingredients on the counter (bind parameters)</li>\n<li>Follow the instructions step by step (execute the body)</li>\n</ul>\n<p>A <strong>closure</strong> is a recipe card that comes with a <strong>snapshot of the kitchen</strong> where it was written. Even if you later take the recipe to a different kitchen (call it from a different scope), it still has access to all the original kitchen&#39;s ingredients (variables from the defining environment). This allows inner functions to &quot;remember&quot; and access variables from outer functions, even after those outer functions have finished executing.</p>\n<blockquote>\n<p>The critical insight: <strong>Closures capture the environment, not just the values.</strong> This means if a closure modifies a captured variable, all closures sharing that environment see the change.</p>\n</blockquote>\n<h3 id=\"loxfunction-a-callable-wrapper\">LoxFunction: A Callable Wrapper</h3>\n<p>A function in Lox is a <strong>first-class value</strong> that can be stored in variables, passed as arguments, returned from other functions, and called. To represent this, we need a runtime value that wraps the static function definition with its dynamic execution context.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LoxFunction</code></td>\n<td>A runtime object representing a callable Lox function or closure</td>\n</tr>\n</tbody></table>\n<p><strong>Data Structure Details:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>declaration</code></td>\n<td><code>Stmt.Function</code></td>\n<td>The AST node representing the function definition (contains name, parameters, body)</td>\n</tr>\n<tr>\n<td><code>closure</code></td>\n<td><code>Environment</code></td>\n<td>A reference to the <strong>defining environment</strong>—the environment active when the function was declared</td>\n</tr>\n<tr>\n<td><code>isInitializer</code></td>\n<td><code>boolean</code></td>\n<td>Flag indicating whether this function is a class&#39;s <code>init</code> method (affects <code>this</code> and return value behavior)</td>\n</tr>\n</tbody></table>\n<p><strong>Interface Methods:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>call</code></td>\n<td><code>Interpreter interpreter, List&lt;Object&gt; arguments</code></td>\n<td><code>Object</code></td>\n<td>Executes the function body with the given arguments, returning the function&#39;s result</td>\n</tr>\n<tr>\n<td><code>arity</code></td>\n<td>(none)</td>\n<td><code>int</code></td>\n<td>Returns the number of parameters the function expects</td>\n</tr>\n<tr>\n<td><code>toString</code></td>\n<td>(none)</td>\n<td><code>String</code></td>\n<td>Returns a string representation like &quot;<fn functionName>&quot;</td>\n</tr>\n</tbody></table>\n<p>The <code>LoxFunction</code> object serves as a <strong>bridge</strong> between the static function definition (in the AST) and the dynamic execution context (the environment chain). When a function is declared, we create a <code>LoxFunction</code> object, capturing the <em>current</em> environment as its <code>closure</code> field. This captured environment becomes the <strong>parent</strong> of the new environment created each time the function is called.</p>\n<blockquote>\n<p><strong>Key Design Insight:</strong> The function&#39;s <code>closure</code> field is set once, when the function is <strong>defined</strong>, not when it&#39;s called. This is what enables lexical scoping—the function can access variables that existed when it was created, even if they&#39;re no longer in scope at the call site.</p>\n</blockquote>\n<h3 id=\"function-call-and-return-algorithm\">Function Call and Return Algorithm</h3>\n<p>Function execution involves several coordinated steps across the interpreter, the <code>LoxFunction</code> object, and the environment chain. Here&#39;s the complete algorithm:</p>\n<h4 id=\"1-function-declaration-evaluation\">1. Function Declaration Evaluation</h4>\n<p>When the interpreter encounters a function declaration statement (<code>Stmt.Function</code>):</p>\n<ol>\n<li><strong>Create closure:</strong> Capture a reference to the interpreter&#39;s <em>current</em> environment (the one active when the function is defined).</li>\n<li><strong>Wrap in LoxFunction:</strong> Instantiate a <code>LoxFunction</code> object with:<ul>\n<li>The function&#39;s AST node (<code>declaration</code>)</li>\n<li>The captured environment (<code>closure</code>)</li>\n<li><code>isInitializer</code> = <code>false</code> (for regular functions; class methods set this differently)</li>\n</ul>\n</li>\n<li><strong>Bind to name:</strong> Define the function&#39;s name in the current environment, mapping it to the <code>LoxFunction</code> object.</li>\n</ol>\n<h4 id=\"2-function-call-evaluation\">2. Function Call Evaluation</h4>\n<p>When evaluating a call expression (<code>Expr.Call</code>):</p>\n<ol>\n<li><strong>Evaluate callee:</strong> Evaluate the expression before the parentheses (could be a variable name, property access, or another call).</li>\n<li><strong>Validate callee:</strong> Ensure the callee is actually callable (an instance of <code>LoxFunction</code>, <code>LoxClass</code>, or a native function). If not, throw a runtime error.</li>\n<li><strong>Evaluate arguments:</strong> Evaluate each argument expression from left to right, collecting the resulting values.</li>\n<li><strong>Check arity:</strong> Verify the number of arguments matches the function&#39;s expected parameter count (<code>arity</code>). If not, throw a runtime error.</li>\n<li><strong>Create call environment:</strong> Instantiate a new <code>Environment</code> object with the function&#39;s <code>closure</code> as its parent.</li>\n<li><strong>Bind parameters:</strong> For each parameter name and corresponding argument value, define a binding in the new call environment.</li>\n<li><strong>Execute body:</strong> <ul>\n<li>Temporarily set the interpreter&#39;s current environment to the new call environment</li>\n<li>Execute each statement in the function&#39;s body using <code>executeBlock</code></li>\n<li>Catch any <code>Return</code> exception thrown by a return statement</li>\n<li>Restore the interpreter&#39;s previous environment</li>\n</ul>\n</li>\n<li><strong>Handle return:</strong><ul>\n<li>If a <code>Return</code> exception was caught, extract its value and return that as the call expression&#39;s result</li>\n<li>If no return statement was encountered (or the function completes without hitting one), return <code>nil</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-return-statement-execution\">3. Return Statement Execution</h4>\n<p>When executing a return statement (<code>Stmt.Return</code>):</p>\n<ol>\n<li><strong>Evaluate value:</strong> If the return statement has a value expression, evaluate it. Otherwise, use <code>nil</code>.</li>\n<li><strong>Throw Return exception:</strong> Create and throw a custom <code>Return</code> exception containing the value. This exception propagates up through the call stack until caught by the function call logic.</li>\n</ol>\n<blockquote>\n<p>The <code>Return</code> exception is a <strong>control flow mechanism</strong>, not an error. It provides a clean way to immediately exit nested statement execution and propagate a value back to the caller without unwinding the call stack manually.</p>\n</blockquote>\n<h3 id=\"adr-environment-capture-for-closures\">ADR: Environment Capture for Closures</h3>\n<blockquote>\n<p><strong>Decision: Capture Defining Environment by Reference</strong></p>\n<ul>\n<li><strong>Context:</strong> Functions in Lox use lexical scoping: an inner function can access variables from any outer scope where it&#39;s defined. We need to decide how to make these outer variables available when the function is called, possibly much later and from a different scope.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Capture defining environment by reference:</strong> Store a pointer to the actual environment object active at function definition.</li>\n<li><strong>Capture defining environment by copy:</strong> Create a snapshot copy of all variable bindings at definition time.</li>\n<li><strong>Use caller&#39;s environment:</strong> Ignore lexical scoping and use the environment at the call site (dynamic scoping).</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> We chose option 1—capture the defining environment by reference.</li>\n<li><strong>Rationale:</strong> <ul>\n<li><strong>Correct semantics:</strong> Capturing by reference allows closures to see <em>updates</em> to captured variables, which matches the behavior of most modern languages and is essential for implementing mutable state in functional patterns.</li>\n<li><strong>Memory efficiency:</strong> Copying the entire environment (which could be large) for every function definition would be wasteful, especially for deeply nested functions.</li>\n<li><strong>Implementation simplicity:</strong> A reference is trivial to store and creates the natural parent-child environment relationship needed for variable lookup.</li>\n<li><strong>Dynamic scoping rejection:</strong> Option 3 would violate Lox&#39;s specified lexical scoping rules and make programs much harder to reason about.</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li>Closures can modify captured variables, affecting other closures sharing the same environment.</li>\n<li>The captured environment must stay alive as long as any closure references it (no garbage collection in our simple interpreter).</li>\n<li>Variable lookup follows the natural parent chain: call environment → defining environment → its parent → ... → global.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Comparison of Environment Capture Strategies:</strong></p>\n<p><img src=\"/api/project/build-interpreter/architecture-doc/asset?path=diagrams%2Fdiagram-environment-chain.svg\" alt=\"Environment Chain\"></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Suitable For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Capture by reference</strong></td>\n<td>- Allows mutable captured variables<br>- Memory efficient<br>- Simple implementation</td>\n<td>- Can create unintentional sharing<br>- Requires environment lifetime management</td>\n<td>Lexical scoping with mutable state (Lox, JavaScript, Python)</td>\n</tr>\n<tr>\n<td><strong>Capture by copy</strong></td>\n<td>- Isolates closure from changes<br>- Easier reasoning about behavior</td>\n<td>- Inefficient for large environments<br>- Doesn&#39;t allow updates to outer variables</td>\n<td>Immutable functional languages</td>\n</tr>\n<tr>\n<td><strong>Use caller&#39;s environment</strong></td>\n<td>- Extremely simple to implement<br>- No capture needed</td>\n<td>- Violates lexical scoping<br>- Unpredictable variable resolution</td>\n<td>Dynamic scoping languages (some Lisps, early Perl)</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Not creating a new environment per function call</strong></p>\n<ul>\n<li><strong>Description:</strong> Reusing the same environment object for multiple calls to the same function.</li>\n<li><strong>Why it&#39;s wrong:</strong> Breaks recursion and reentrancy. Each call needs its own parameter bindings; otherwise, a recursive call would overwrite the previous call&#39;s parameters, and returns would leave the environment in an inconsistent state.</li>\n<li><strong>Fix:</strong> Always create a fresh <code>Environment</code> object inside <code>LoxFunction.call()</code>, with the closure as its parent.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrectly binding &#39;this&#39; in methods</strong></p>\n<ul>\n<li><strong>Description:</strong> Forgetting to bind the <code>this</code> keyword to the instance when a method is called.</li>\n<li><strong>Why it&#39;s wrong:</strong> Methods need access to their instance&#39;s fields via <code>this</code>. Without proper binding, <code>this</code> either resolves to nothing or resolves incorrectly.</li>\n<li><strong>Fix:</strong> When calling a method, create an environment for the call with an extra binding: <code>&quot;this&quot; → instance</code>. This happens in the method call logic, not in regular function calls.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to propagate return values through the call stack</strong></p>\n<ul>\n<li><strong>Description:</strong> Catching the <code>Return</code> exception but not properly extracting and returning its value to the caller.</li>\n<li><strong>Why it&#39;s wrong:</strong> Function calls would always return <code>nil</code> regardless of what the return statement specified.</li>\n<li><strong>Fix:</strong> Ensure <code>LoxFunction.call()</code> catches the <code>Return</code> exception, extracts its <code>value</code> field, and returns that value as the call result.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Memory leaks from captured environment chains</strong></p>\n<ul>\n<li><strong>Description:</strong> Environments captured by closures are never released, causing unbounded memory growth in long-running programs.</li>\n<li><strong>Why it&#39;s wrong:</strong> In a production interpreter, this would eventually exhaust available memory. Each closure keeps its entire defining environment chain alive.</li>\n<li><strong>Fix:</strong> In our educational interpreter, we accept this limitation. A production implementation would need a garbage collector to detect and reclaim unreachable environments.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Confusing Java&#39;s return with Lox&#39;s return</strong></p>\n<ul>\n<li><strong>Description:</strong> Using Java&#39;s <code>return</code> statement inside the interpreter&#39;s visitor methods to implement Lox&#39;s return statement.</li>\n<li><strong>Why it&#39;s wrong:</strong> A Java <code>return</code> only exits the current visitor method, not the entire Lox function body. The interpreter needs to unwind through potentially multiple nested statements.</li>\n<li><strong>Fix:</strong> Use the custom <code>Return</code> exception thrown by <code>visitReturnStmt</code> and caught in <code>LoxFunction.call()</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Function Representation</td>\n<td>Single <code>LoxFunction</code> class with all fields</td>\n<td>Separate interfaces for callables: <code>LoxCallable</code> with <code>call()</code> and <code>arity()</code></td>\n</tr>\n<tr>\n<td>Return Mechanism</td>\n<td>Custom <code>Return</code> exception class</td>\n<td>Special <code>ReturnValue</code> object with stack unwinding logic</td>\n</tr>\n<tr>\n<td>Environment Capture</td>\n<td>Direct reference to <code>Environment</code> object</td>\n<td>Environment identifier with indirect lookup table</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/\n  interpreter/\n    Interpreter.java           # Updated with function visit methods\n    Environment.java           # Already exists from Milestone 5\n    LoxFunction.java           # NEW: Function/closure runtime representation\n    Return.java                # NEW: Exception for return statements\n  parser/\n    # Existing files unchanged\n  ast/\n    # Existing files unchanged\n  lox/\n    Lox.java                   # Main entry point</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// File: interpreter/Return.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.interpreter;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Internal exception used to implement return statements.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is not an error but a control flow mechanism.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Return</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> RuntimeException</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Object value;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#B392F0\"> Return</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">);  </span><span style=\"color:#6A737D\">// Disable stack trace for performance</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// File: interpreter/LoxFunction.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.interpreter;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.ast.</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> LoxFunction</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> LoxCallable</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Stmt.Function declaration;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Environment closure;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> isInitializer;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#B392F0\"> LoxFunction</span><span style=\"color:#E1E4E8\">(Stmt.Function </span><span style=\"color:#FFAB70\">declaration</span><span style=\"color:#E1E4E8\">, Environment </span><span style=\"color:#FFAB70\">closure</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     boolean</span><span style=\"color:#FFAB70\"> isInitializer</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.declaration </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> declaration;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.closure </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> closure;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.isInitializer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> isInitializer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> arity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Return the number of parameters in the declaration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">(Interpreter </span><span style=\"color:#FFAB70\">interpreter</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create a new environment for this function call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         The parent should be the captured closure, not the current environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Bind each parameter name to its corresponding argument value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use environment.define(name.lexeme, value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 4: Execute the function body in the new environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      //         Use interpreter.executeBlock(declaration.body, callEnvironment)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (Return </span><span style=\"color:#FFAB70\">returnValue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 5: Handle return statement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      //         If this is an initializer, always return 'this' from closure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      //         Otherwise, return the value from the Return exception</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle normal completion (no return statement reached)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         If this is an initializer, return 'this' from closure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Otherwise, return nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"&#x3C;fn \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> declaration.name.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 7: Add a bind method for binding 'this' to instances (for methods)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  //         This will be used in the class implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// File: interpreter/Interpreter.java (additions only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> Expr.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Stmt.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Void</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // ... existing fields and methods ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitCallExpr</span><span style=\"color:#E1E4E8\">(Expr.Call </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Evaluate the callee expression (the part before parentheses)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Evaluate each argument expression, collecting values in a list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify the callee is callable (instanceof LoxCallable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         If not, throw RuntimeError with expr.paren token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check arity: arguments.size() must equal callee.arity()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         If not, throw RuntimeError with expr.paren token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Call the function: callee.call(this, arguments)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Return the result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitFunctionStmt</span><span style=\"color:#E1E4E8\">(Stmt.Function </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create a LoxFunction with:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - declaration = stmt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - closure = current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - isInitializer = false (for now)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Define the function name in the current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         environment.define(stmt.name.lexeme, function)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitReturnStmt</span><span style=\"color:#E1E4E8\">(Stmt.Return </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Object value </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If stmt.value is not null, evaluate it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Throw a Return exception with the value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         This will be caught in LoxFunction.call()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Return</span><span style=\"color:#E1E4E8\">(value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Helper method for executing blocks (already exists, but ensure it supports functions)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> executeBlock</span><span style=\"color:#E1E4E8\">(List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">statements</span><span style=\"color:#E1E4E8\">, Environment </span><span style=\"color:#FFAB70\">environment</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Environment previous </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.environment;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> environment;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      for</span><span style=\"color:#E1E4E8\"> (Stmt statement </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> statements) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execute</span><span style=\"color:#E1E4E8\">(statement);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">finally</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> previous;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints (Java):</strong></p>\n<ul>\n<li>Use <code>List&lt;Object&gt;</code> for argument lists; Java&#39;s type erasure means you&#39;ll need to cast returned values.</li>\n<li>The <code>Return</code> exception should extend <code>RuntimeException</code> but disable stack trace generation for better performance since it&#39;s used for normal control flow.</li>\n<li>Consider creating a <code>LoxCallable</code> interface with <code>call()</code> and <code>arity()</code> methods to unify functions, classes, and future native functions.</li>\n<li>When implementing <code>executeBlock</code>, use a try-finally block to ensure the environment is always restored, even if an exception is thrown.</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong>\nAfter implementing functions, verify with this test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lox</span><pre class=\"arch-pre shiki-highlighted\"><code>// test.lox\nfun makeCounter() {\n  var i = 0;\n  fun count() {\n    i = i + 1;\n    return i;\n  }\n  return count;\n}\n\nvar counter = makeCounter();\nprint counter();  // Should print: 1\nprint counter();  // Should print: 2</code></pre></div>\n\n<p>Expected output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1\n2</code></pre></div>\n\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Function always returns nil</td>\n<td>Return exception not caught or value not extracted</td>\n<td>Add debug prints in <code>LoxFunction.call()</code> to see if Return is caught</td>\n<td>Ensure <code>call()</code> catches <code>Return</code> and returns <code>returnValue.value</code></td>\n</tr>\n<tr>\n<td>Recursive function overwrites variables</td>\n<td>Same environment reused for recursive calls</td>\n<td>Check if you&#39;re creating new Environment in each <code>call()</code></td>\n<td>Create fresh <code>Environment</code> for each call with closure as parent</td>\n</tr>\n<tr>\n<td>Closure can&#39;t see outer variables</td>\n<td>Wrong environment captured as closure</td>\n<td>Print closure&#39;s parent chain during function definition</td>\n<td>Capture current environment when creating <code>LoxFunction</code>, not global</td>\n</tr>\n<tr>\n<td>&quot;Expected X arguments but got Y&quot; error on correct call</td>\n<td>Arity calculation wrong</td>\n<td>Print <code>declaration.params.size()</code> in <code>arity()</code></td>\n<td>Return the correct parameter count</td>\n</tr>\n<tr>\n<td>Function call evaluates arguments in wrong order</td>\n<td>List evaluation order not left-to-right</td>\n<td>Check order in <code>visitCallExpr</code> argument evaluation</td>\n<td>Evaluate arguments sequentially before calling function</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"55-component-design-classes-and-inheritance-milestones-9-amp-10\">5.5 Component Design: Classes and Inheritance [Milestones 9 &amp; 10]</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 9 - Classes, Milestone 10 - Inheritance</p>\n</blockquote>\n<p>This section extends the interpreter from a procedural language with functions to an object-oriented language with classes, instances, and inheritance. We&#39;ll design the runtime structures that represent classes and objects, implement method calls with implicit <code>this</code> binding, and add single inheritance with <code>super</code> calls. The key architectural challenge is modeling the relationship between classes, instances, and their environments while maintaining lexical scoping for closures and proper method resolution order.</p>\n<h3 id=\"mental-model-the-class-as-a-blueprint-and-factory\">Mental Model: The Class as a Blueprint and Factory</h3>\n<p>Think of a <strong>class</strong> as both a <strong>blueprint</strong> and a <strong>factory</strong>. The blueprint defines the structure—what methods the object will have—while the factory is a callable entity that produces new instances. An <strong>instance</strong> is a house built from the blueprint: it has its own storage rooms (fields) that can hold unique furnishings (values), but shares the architectural plans (methods) with every other house from the same blueprint. <strong>Inheritance</strong> is creating a modified copy of the blueprint: you start with the original blueprint, trace over it, and add or change some rooms while keeping the rest. When you build a house from this derived blueprint, it includes features from both the original and the modifications.</p>\n<p><img src=\"/api/project/build-interpreter/architecture-doc/asset?path=diagrams%2Fdiagram-class-inheritance.svg\" alt=\"Class and Instance Relationships\"></p>\n<p>The <code>this</code> keyword is like a labeled floor plan inside the house that says &quot;you are here&quot;—it allows methods running within an instance to refer to the instance itself. The <code>super</code> keyword is a special phone line installed in the house that connects directly to the original blueprint&#39;s architect, allowing you to ask how a room was originally designed even if you&#39;ve modified it in your copy.</p>\n<h3 id=\"loxclass-and-loxinstance-structures\">LoxClass and LoxInstance Structures</h3>\n<p>We need two new runtime value types to represent classes and instances. These extend the existing <code>Object</code> type hierarchy (which already includes <code>LoxFunction</code>, <code>LoxString</code>, <code>LoxNumber</code>, etc.).</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Fields</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LoxClass</code></td>\n<td><code>name</code> (String)</td>\n<td>The class&#39;s name as declared in source code</td>\n</tr>\n<tr>\n<td></td>\n<td><code>methods</code> (Map&lt;String, LoxFunction&gt;)</td>\n<td>A map from method names to their corresponding <code>LoxFunction</code> objects</td>\n</tr>\n<tr>\n<td></td>\n<td><code>superclass</code> (LoxClass or <code>null</code>)</td>\n<td>Reference to the superclass this class inherits from, if any</td>\n</tr>\n<tr>\n<td><code>LoxInstance</code></td>\n<td><code>klass</code> (LoxClass)</td>\n<td>Reference to the class this instance belongs to</td>\n</tr>\n<tr>\n<td></td>\n<td><code>fields</code> (Map&lt;String, Object&gt;)</td>\n<td>A mutable map storing the instance&#39;s field names and their current values</td>\n</tr>\n</tbody></table>\n<p>Both <code>LoxClass</code> and <code>LoxInstance</code> must implement a <code>call()</code> method to be callable (classes are called as constructors, instances are not callable unless they have a <code>call()</code> method, which Lox doesn&#39;t support). <code>LoxClass</code>&#39;s <code>call()</code> creates a new instance and invokes the initializer. <code>LoxInstance</code>&#39;s <code>call()</code> should throw a runtime error.</p>\n<p>Additionally, we need to extend the <code>LoxFunction</code> class from Milestone 8 with an <code>isInitializer</code> boolean flag to mark the special <code>init</code> method, which must return <code>this</code> instead of its explicit return value.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> Classes in Lox are first-class values—they can be stored in variables, passed as arguments, and returned from functions. This is why <code>LoxClass</code> is a runtime value type just like numbers and strings. The class declaration statement evaluates to a <code>LoxClass</code> object and stores it in the current environment.</p>\n</blockquote>\n<h3 id=\"instantiation-property-access-and-method-resolution\">Instantiation, Property Access, and Method Resolution</h3>\n<p>The lifecycle of a class involves declaration, instantiation, property access, and method invocation. The following numbered procedures describe each operation.</p>\n<h4 id=\"1-class-declaration-evaluation\">1. Class Declaration Evaluation</h4>\n<p>When the interpreter encounters a <code>Class</code> statement:</p>\n<ol>\n<li><strong>Evaluate superclass (if present):</strong> If the class has a superclass clause (<code>class Derived &lt; Base</code>), evaluate the superclass expression (which must be a variable referencing a class). This yields a <code>LoxClass</code> object or throws an error if not a class.</li>\n<li><strong>Create method map:</strong> For each method in the class body, create a <code>LoxFunction</code> object. The function&#39;s <strong>closure</strong> is set to the <em>current environment</em> (where the class is being defined), capturing the surrounding lexical scope. Mark the function as an initializer if its name is <code>&quot;init&quot;</code>.</li>\n<li><strong>Instantiate class object:</strong> Create a new <code>LoxClass</code> with the class name, method map, and superclass reference.</li>\n<li><strong>Bind to name:</strong> Store the <code>LoxClass</code> object in the current environment under the class&#39;s name.</li>\n</ol>\n<h4 id=\"2-instance-creation-calling-a-class\">2. Instance Creation (Calling a Class)</h4>\n<p>When a class is called as a function (e.g., <code>MyClass()</code>):</p>\n<ol>\n<li><strong>Create instance:</strong> Instantiate a new <code>LoxInstance</code> with its <code>klass</code> field pointing to the called <code>LoxClass</code> and an empty <code>fields</code> map.</li>\n<li><strong>Bind <code>this</code>:</strong> Create a new environment whose <em>enclosing</em> environment is the <strong>instance&#39;s class&#39;s method closure environment</strong> (the environment captured when the class was defined). In this new environment, define a special variable named <code>&quot;this&quot;</code> bound to the instance.</li>\n<li><strong>Invoke initializer:</strong> Look up the <code>&quot;init&quot;</code> method in the class&#39;s <code>methods</code> map. If found:<ul>\n<li>Create a new <code>LoxFunction</code> bound to the instance by setting its closure to the environment created in step 2 (which has <code>this</code> bound).</li>\n<li>Call this function with the provided arguments.</li>\n<li>If the initializer returns a value, discard it (unless it&#39;s a special early return). Instead, automatically return <code>this</code>.</li>\n</ul>\n</li>\n<li><strong>Return instance:</strong> The result of the class call is the new <code>LoxInstance</code>.</li>\n</ol>\n<h4 id=\"3-property-access-get-expression\">3. Property Access (Get Expression)</h4>\n<p>When evaluating <code>instance.property</code>:</p>\n<ol>\n<li><strong>Evaluate object:</strong> Evaluate the left-hand expression to obtain an <code>LoxInstance</code>. If it&#39;s not an instance, throw a runtime error.</li>\n<li><strong>Check fields:</strong> Look up the property name in the instance&#39;s <code>fields</code> map. If found, return the value.</li>\n<li><strong>Check methods:</strong> If not in fields, look up the method name in the instance&#39;s class&#39;s <code>methods</code> map (and superclass chain). If found, return that method <strong>bound to the instance</strong> (create a new <code>LoxFunction</code> with the same declaration but whose closure is an environment that has <code>this</code> bound to the current instance).</li>\n<li><strong>Error:</strong> If neither field nor method exists, throw a runtime error.</li>\n</ol>\n<h4 id=\"4-property-assignment-set-expression\">4. Property Assignment (Set Expression)</h4>\n<p>When evaluating <code>instance.property = value</code>:</p>\n<ol>\n<li><strong>Evaluate object:</strong> Evaluate the left-hand object expression to an <code>LoxInstance</code>.</li>\n<li><strong>Evaluate value:</strong> Evaluate the right-hand expression.</li>\n<li><strong>Store in fields:</strong> Insert or update the property name in the instance&#39;s <code>fields</code> map with the value.</li>\n<li><strong>Return value:</strong> The assignment expression returns the assigned value (consistent with Lox&#39;s assignment semantics).</li>\n</ol>\n<h4 id=\"5-method-resolution-with-inheritance\">5. Method Resolution with Inheritance</h4>\n<p>When a method is called on an instance:</p>\n<ol>\n<li><strong>Find method:</strong> Starting at the instance&#39;s class, look for the method name in its <code>methods</code> map. If not found, recursively search the superclass chain.</li>\n<li><strong>Bind <code>this</code>:</strong> When found, create a new environment whose parent is the method&#39;s original closure (captured at class definition time) and define <code>&quot;this&quot;</code> as the instance in this new environment. Return a new <code>LoxFunction</code> with this environment as its closure.</li>\n<li><strong>Super calls:</strong> For <code>super.method()</code>, the lookup starts in the <em>superclass</em> of the class where the surrounding method is defined (not the instance&#39;s class). This ensures calling the inherited version, not an override.</li>\n</ol>\n<h3 id=\"adr-storing-a-dedicated-39super39-environment\">ADR: Storing a Dedicated &#39;super&#39; Environment</h3>\n<blockquote>\n<p><strong>Decision: Store Superclass Reference in a Dedicated Environment for Method Execution</strong></p>\n<ul>\n<li><strong>Context:</strong> When a method uses <code>super.method()</code>, we need to resolve <code>method</code> in the superclass&#39;s scope, not the current class&#39;s. The simplest approach is to pass both the current instance and the superclass reference through the call chain, but this complicates the function call interface. Another approach is to create a special environment that links to the superclass.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Pass superclass explicitly:</strong> Add a <code>superclass</code> parameter to <code>LoxFunction.call()</code> and modify all call sites.</li>\n<li><strong>Store superclass in a dedicated environment:</strong> Create a special environment that sits between the method&#39;s closure and the instance-binding environment, containing a <code>&quot;super&quot;</code> variable pointing to the superclass.</li>\n<li><strong>Compute superclass at runtime:</strong> Walk the class hierarchy on every <code>super</code> call by starting from the instance&#39;s class and finding the surrounding method&#39;s class via lexical analysis.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Option 2—store a reference to the superclass in a dedicated environment that becomes part of the chain when methods are executed.</li>\n<li><strong>Rationale:</strong> This approach keeps the function call interface unchanged and leverages the existing environment chain mechanism. The <code>super</code> keyword behaves like a special variable that&#39;s accessible only within methods, similar to <code>this</code>. By storing it in an environment, we maintain lexical scoping consistency and avoid adding special cases to the function call protocol.</li>\n<li><strong>Consequences:</strong> <ul>\n<li>✅ <code>super</code> is naturally limited to method contexts (the environment only exists during method execution).</li>\n<li>✅ The method resolution for <code>super</code> is efficient (direct reference).</li>\n<li>✅ No changes to <code>LoxFunction.call()</code> signature.</li>\n<li>❄️ Adds complexity to the environment chain construction for method calls.</li>\n<li>❄️ Requires careful setup to ensure <code>super</code> points to the correct superclass when methods are inherited.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pass superclass explicitly</td>\n<td>Simple implementation; Clear data flow</td>\n<td>Pollutes call interface; Requires changes at all call sites</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Store superclass in dedicated environment</strong></td>\n<td><strong>Leverages existing environment mechanism; Clean separation of concerns</strong></td>\n<td><strong>Adds extra environment layer; More complex setup</strong></td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Compute superclass at runtime</td>\n<td>No extra state needed; Dynamic resolution</td>\n<td>Computationally expensive; Requires tracking lexical class context</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>The implementation creates a new environment (call it the &quot;super environment&quot;) whose <em>enclosing</em> environment is the method&#39;s original closure. This super environment contains a single binding: <code>&quot;super&quot;</code> → <code>LoxClass</code> (the superclass). Then, the instance-binding environment (with <code>this</code>) has this super environment as its parent. This creates a three-layer chain: instance environment (has <code>this</code>) → super environment (has <code>super</code>) → method closure (captured lexical scope).</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Forgetting to bind <code>this</code> in methods</strong><br><strong>Description:</strong> When a method is accessed (e.g., <code>instance.method</code>), returning the raw <code>LoxFunction</code> stored in the class without binding <code>this</code> to the specific instance.<br><strong>Why it&#39;s wrong:</strong> The method&#39;s body references <code>this</code> expecting it to be the instance the method was called on, but without binding, <code>this</code> resolves to whatever it was when the class was defined (likely <code>nil</code> or wrong object).<br><strong>Fix:</strong> When a method is retrieved from a class (via property access), return a <em>new</em> <code>LoxFunction</code> that wraps the original function but with a closure that has <code>this</code> bound to the current instance.</p>\n<p>⚠️ <strong>Pitfall: Improper initialization order (fields vs. init)</strong><br><strong>Description:</strong> Allowing field assignments in the <code>init</code> method to overwrite fields set before <code>init</code> runs, or vice versa.<br><strong>Why it&#39;s wrong:</strong> The instance should be fully initialized after the constructor runs, with fields set either in <code>init</code> or directly. If the instance&#39;s <code>fields</code> map is not created before <code>init</code> runs, assignments inside <code>init</code> fail.<br><strong>Fix:</strong> Create the instance&#39;s <code>fields</code> map <em>before</em> calling <code>init</code>. Inside <code>init</code>, assignments modify this existing map. This allows <code>init</code> to set default values or validate fields.</p>\n<p>⚠️ <strong>Pitfall: Incorrect method resolution order (instance → class → superclass)</strong><br><strong>Description:</strong> When looking up a method, checking the instance&#39;s fields first, then the class&#39;s methods, but forgetting to walk the superclass chain for inherited methods.<br><strong>Why it&#39;s wrong:</strong> Subclass instances cannot call inherited methods, breaking inheritance.<br><strong>Fix:</strong> Implement recursive method lookup: start at the instance&#39;s class, search its method map; if not found, recursively search its superclass.</p>\n<p>⚠️ <strong>Pitfall: Cycles in inheritance</strong><br><strong>Description:</strong> Allowing a class to inherit from itself directly (<code>class A &lt; A</code>) or indirectly (<code>class A &lt; B; class B &lt; A</code>).<br><strong>Why it&#39;s wrong:</strong> Infinite loops during method resolution or instance creation.<br><strong>Fix:</strong> During class declaration, validate that the superclass is not the class itself and that no cycle exists in the inheritance chain (simple cycle detection by walking the superclass chain).</p>\n<p>⚠️ <strong>Pitfall: Not handling <code>super</code> outside of a class context</strong><br><strong>Description:</strong> Allowing <code>super</code> keyword to be used outside of a method (e.g., in top-level code).<br><strong>Why it&#39;s wrong:</strong> <code>super</code> only makes sense within a method to call a superclass method. Using it elsewhere is a semantic error.<br><strong>Fix:</strong> During parsing, <code>super</code> is allowed anywhere (as it&#39;s an expression), but at runtime, throw a clear error if <code>super</code> is evaluated outside of a method context (i.e., when there&#39;s no <code>&quot;super&quot;</code> variable in the environment chain).</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Class representation</td>\n<td><code>LoxClass</code> and <code>LoxInstance</code> as plain Java classes with fields</td>\n<td>Use interfaces <code>LoxCallable</code> and <code>LoxObject</code> for uniformity</td>\n</tr>\n<tr>\n<td>Method binding</td>\n<td>Create new <code>LoxFunction</code> with modified closure on each property get</td>\n<td>Cache bound methods per instance to avoid recreation</td>\n</tr>\n<tr>\n<td>Inheritance chain</td>\n<td>Store <code>superclass</code> reference and walk recursively</td>\n<td>Precompute method table per class (vtable) for faster dispatch</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>src/\n└── com/\n    └── craftinginterpreters/\n        └── lox/\n            ├── AstPrinter.java          (existing)\n            ├── Environment.java         (existing)\n            ├── Interpreter.java         (extended)\n            ├── Lox.java                 (existing)\n            ├── Parser.java              (existing)\n            ├── Scanner.java             (existing)\n            ├── Token.java               (existing)\n            ├── TokenType.java           (existing)\n            ├── ast/                     (existing)\n            │   ├── Expr.java            (extended with Get, Set, This, Super)\n            │   └── Stmt.java            (extended with Class)\n            └── runtime/\n                ├── LoxCallable.java     (interface)\n                ├── LoxFunction.java     (extended with isInitializer)\n                ├── LoxClass.java        (new)\n                └── LoxInstance.java     (new)</code></pre></div>\n\n<p><strong>Infrastructure Starter Code:</strong></p>\n<p>First, extend the <code>LoxFunction</code> class to support initializers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.runtime;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Interpreter;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.ast.Stmt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Environment;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> LoxFunction</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> LoxCallable</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Stmt.Function declaration;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Environment closure;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> isInitializer;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> LoxFunction</span><span style=\"color:#E1E4E8\">(Stmt.Function </span><span style=\"color:#FFAB70\">declaration</span><span style=\"color:#E1E4E8\">, Environment </span><span style=\"color:#FFAB70\">closure</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       boolean</span><span style=\"color:#FFAB70\"> isInitializer</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.declaration </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> declaration;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.closure </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> closure;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.isInitializer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> isInitializer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> arity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> declaration.params.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">(Interpreter </span><span style=\"color:#FFAB70\">interpreter</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Environment environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">(closure);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> declaration.params.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            environment.</span><span style=\"color:#B392F0\">define</span><span style=\"color:#E1E4E8\">(declaration.params.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(i).lexeme, arguments.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(i));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            interpreter.</span><span style=\"color:#B392F0\">executeBlock</span><span style=\"color:#E1E4E8\">(declaration.body, environment);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (Return </span><span style=\"color:#FFAB70\">returnValue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Special case: init() always returns 'this'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (isInitializer) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> closure.</span><span style=\"color:#B392F0\">getAt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"this\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> returnValue.value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // If no return statement, init() returns 'this', others return nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (isInitializer) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> closure.</span><span style=\"color:#B392F0\">getAt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"this\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"&#x3C;fn \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> declaration.name.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bind this function to a specific instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> LoxFunction </span><span style=\"color:#B392F0\">bind</span><span style=\"color:#E1E4E8\">(LoxInstance </span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Environment environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">(closure);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        environment.</span><span style=\"color:#B392F0\">define</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"this\"</span><span style=\"color:#E1E4E8\">, instance);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> LoxFunction</span><span style=\"color:#E1E4E8\">(declaration, environment, isInitializer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<ol>\n<li><strong>LoxClass.java</strong> (complete starter):</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.runtime;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Interpreter;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Map;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> LoxClass</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> LoxCallable</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> String name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> LoxClass superclass;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Map&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">LoxFunction</span><span style=\"color:#E1E4E8\">> methods;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> LoxClass</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, LoxClass </span><span style=\"color:#FFAB70\">superclass</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Map&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">LoxFunction</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">methods</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.superclass </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> superclass;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.methods </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> methods;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">(Interpreter </span><span style=\"color:#FFAB70\">interpreter</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create a new instance of this class</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Find the init method in the class's methods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If init exists, bind it to the instance and call it with arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return the instance (init's return value is ignored, instance is returned)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> arity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Return the arity of the init method, or 0 if no init</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> LoxFunction </span><span style=\"color:#B392F0\">findMethod</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if method exists in this class's methods map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If not found and superclass exists, recursively search superclass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return the method or null if not found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>LoxInstance.java</strong> (complete starter):</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.runtime;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.HashMap;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Map;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> LoxInstance</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> LoxClass klass;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Map&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> fields </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> HashMap&#x3C;>();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> LoxInstance</span><span style=\"color:#E1E4E8\">(LoxClass </span><span style=\"color:#FFAB70\">klass</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.klass </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> klass;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> klass.name </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" instance\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if field exists in the fields map, return if found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If not a field, look up method in the class</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If method found, return it bound to this instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Throw a runtime error if neither field nor method exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> set</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Store the value in the fields map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Interpreter.java extensions</strong> (skeleton for new visitor methods):</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add to Interpreter class:</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#E1E4E8\"> Void </span><span style=\"color:#B392F0\">visitClassStmt</span><span style=\"color:#E1E4E8\">(Stmt.Class stmt) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Evaluate superclass expression (if present) and ensure it's a LoxClass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create a map of method names to LoxFunctions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For each method, create a LoxFunction with closure = current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Mark as initializer if method name is \"init\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create a new LoxClass with name, superclass, and methods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Define the class name in the current environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitGetExpr</span><span style=\"color:#E1E4E8\">(Expr.Get expr) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Evaluate the object expression (must be a LoxInstance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call instance.get(propertyName) to get field or bound method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitSetExpr</span><span style=\"color:#E1E4E8\">(Expr.Set expr) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Evaluate the object expression (must be a LoxInstance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Evaluate the value expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call instance.set(propertyName, value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitThisExpr</span><span style=\"color:#E1E4E8\">(Expr.This expr) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up \"this\" in the environment chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return the value (must be a LoxInstance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitSuperExpr</span><span style=\"color:#E1E4E8\">(Expr.Super expr) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Retrieve the \"super\" variable from the environment (should be a LoxClass)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Retrieve the \"this\" variable from the environment (should be a LoxInstance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Find the method in the superclass (not the current class)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the method bound to the current instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints (Java):</strong></p>\n<ul>\n<li>Use <code>HashMap&lt;String, Object&gt;</code> for the fields map in <code>LoxInstance</code> and methods map in <code>LoxClass</code>.</li>\n<li>The <code>bind</code> method in <code>LoxFunction</code> creates a shallow copy of the function with a new closure—this is efficient and maintains the original function&#39;s code.</li>\n<li>When throwing runtime errors for invalid property access, use the token&#39;s line number from the AST node for error reporting.</li>\n<li>For the <code>super</code> environment, create a new <code>Environment</code> with a single binding: <code>environment.define(&quot;super&quot;, superclass)</code>. This environment&#39;s parent should be the method&#39;s original closure.</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong>\nAfter implementing classes (Milestone 9), test with this Lox program:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lox</span><pre class=\"arch-pre shiki-highlighted\"><code>class Breakfast {\n  init(meat, bread) {\n    this.meat = meat;\n    this.bread = bread;\n  }\n  \n  serve(who) {\n    print &quot;Enjoy your &quot; + this.meat + &quot; and &quot; + this.bread + &quot;, &quot; + who + &quot;.&quot;;\n  }\n}\n\nvar baconAndToast = Breakfast(&quot;bacon&quot;, &quot;toast&quot;);\nbaconAndToast.serve(&quot;Dear Reader&quot;);</code></pre></div>\n<p>Expected output: <code>Enjoy your bacon and toast, Dear Reader.</code></p>\n<p>After implementing inheritance (Milestone 10), test with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lox</span><pre class=\"arch-pre shiki-highlighted\"><code>class A {\n  method() {\n    print &quot;A.method()&quot;;\n  }\n}\n\nclass B &lt; A {\n  method() {\n    print &quot;B.method()&quot;;\n  }\n  \n  test() {\n    super.method();\n  }\n}\n\nvar b = B();\nb.test();  // Should print &quot;A.method()&quot;</code></pre></div>\n<p>Expected output: <code>A.method()</code></p>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>this</code> is <code>nil</code> inside a method</td>\n<td>Method not bound to instance</td>\n<td>Check if <code>visitGetExpr</code> calls <code>bind()</code> on the retrieved method</td>\n<td>Ensure property get returns <code>method.bind(instance)</code></td>\n</tr>\n<tr>\n<td><code>super</code> call says &quot;superclass method not found&quot;</td>\n<td>Super environment not set up</td>\n<td>Print environment chain during method call to see if <code>&quot;super&quot;</code> exists</td>\n<td>Make sure the super environment is created and linked when a method is bound</td>\n</tr>\n<tr>\n<td>Instance fields disappear after init</td>\n<td>Fields map reinitialized</td>\n<td>Check if <code>init</code> creates a new map instead of using instance&#39;s map</td>\n<td>Ensure instance&#39;s fields map is created once and passed to init</td>\n</tr>\n<tr>\n<td>Inherited method calls subclass override</td>\n<td>Method lookup starts at wrong class</td>\n<td>Trace <code>findMethod</code> calls; should start at superclass for <code>super</code></td>\n<td>In <code>visitSuperExpr</code>, look up method in superclass, not instance&#39;s class</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"6-interactions-and-data-flow\">6. Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (Milestones 1-10) — This section demonstrates how the components defined in previous design sections collaborate to transform inert source code into executed behavior. Understanding these interactions is critical for debugging and for appreciating the architecture as a cohesive system.</p>\n</blockquote>\n<p>This section traces the complete journey of a Lox program from a string of characters to executed side effects and printed output. We&#39;ll follow the data as it flows through the pipeline of components—<strong>Scanner</strong>, <strong>Parser</strong>, and <strong>Interpreter</strong>—and examine the concrete data structures that carry meaning at each stage. Think of this as tracing a package through a sophisticated logistics network: the <strong>Scanner</strong> scans the shipping label (source code) and produces a detailed packing list (tokens), the <strong>Parser</strong> inspects that list and builds a precise loading plan (AST), and the <strong>Interpreter</strong> executes that plan by moving goods (runtime values) between warehouses (environments) to deliver the final outcome.</p>\n<h3 id=\"end-to-end-sequence-for-a-sample-program\">End-to-End Sequence for a Sample Program</h3>\n<p>Let&#39;s trace the complete execution of a simple Lox program: <code>var x = 1 + 2; print x;</code>. This program declares a variable, initializes it with the result of an arithmetic expression, and then prints the variable&#39;s value. The following numbered steps detail the transformation at each stage of the interpretation pipeline.</p>\n<ol>\n<li><p><strong>Source Code Input</strong>: The program begins as a plain Java <code>String</code>: <code>&quot;var x = 1 + 2; print x;&quot;</code>. This string is passed to the main entry point, typically <code>Lox.run()</code>.</p>\n</li>\n<li><p><strong>Lexical Analysis (Scanner)</strong>: The <code>Scanner</code> receives the source string and begins its character-by-character scan. Its internal state (<code>start</code>, <code>current</code>, <code>line</code>) advances, identifying lexical boundaries.</p>\n<ul>\n<li>It skips the initial whitespace, then recognizes <code>var</code> as a keyword, producing a <code>Token</code> with <code>type = VAR</code>, <code>lexeme = &quot;var&quot;</code>, <code>literal = null</code>, <code>line = 1</code>.</li>\n<li>It advances, recognizes <code>x</code> as an identifier, producing a token with <code>type = IDENTIFIER</code>, <code>lexeme = &quot;x&quot;</code>, <code>literal = null</code>, <code>line = 1</code>.</li>\n<li>It recognizes <code>=</code> as a single-character operator (<code>EQUAL</code>).</li>\n<li>It recognizes <code>1</code> as a number literal, converting the substring <code>&quot;1&quot;</code> to a Java <code>Double</code> value <code>1.0</code> stored in the token&#39;s <code>literal</code> field (<code>type = NUMBER</code>, <code>lexeme = &quot;1&quot;</code>, <code>literal = 1.0</code>).</li>\n<li>It recognizes <code>+</code> as an operator (<code>PLUS</code>).</li>\n<li>It recognizes <code>2</code> as another number literal (<code>NUMBER</code> with <code>literal = 2.0</code>).</li>\n<li>It recognizes <code>;</code> as a delimiter (<code>SEMICOLON</code>).</li>\n<li>It then processes the second statement similarly: <code>print</code> becomes a <code>PRINT</code> keyword token, <code>x</code> becomes another <code>IDENTIFIER</code> token, and the final <code>;</code> becomes a <code>SEMICOLON</code>.</li>\n<li>Finally, it appends an <code>EOF</code> token to signal the end of the token stream. The <code>Scanner</code> returns a <code>List&lt;Token&gt;</code> containing these 9 tokens (excluding whitespace).</li>\n</ul>\n</li>\n<li><p><strong>Syntactic Analysis (Parser)</strong>: The <code>Parser</code> receives the <code>List&lt;Token&gt;</code> and begins its recursive descent parse, starting with the <code>program()</code> rule which calls <code>declaration()</code> repeatedly.</p>\n<ul>\n<li>For the first statement, <code>declaration()</code> matches the <code>VAR</code> token and invokes <code>varDeclaration()</code>. This method consumes the <code>IDENTIFIER(&quot;x&quot;)</code> token, expects and consumes the <code>EQUAL</code> token, then calls <code>expression()</code> to parse the initializer.</li>\n<li>Parsing the expression <code>1 + 2</code> involves the precedence cascade: <code>expression()</code> → <code>equality()</code> → <code>comparison()</code> → <code>term()</code> → <code>factor()</code> → <code>unary()</code> → <code>primary()</code>. At the <code>primary()</code> level, the number literal <code>1</code> is recognized, creating a <code>Literal</code> expression node with <code>value = 1.0</code>. The parser backtracks: at the <code>term()</code> level, it sees the <code>PLUS</code> token. Since <code>+</code> is handled at the <code>term</code> precedence level, it continues parsing the right-hand side, resulting in another <code>Literal</code> for <code>2</code>. It then constructs a <code>Binary</code> expression node with <code>left = Literal(1.0)</code>, <code>operator = Token(PLUS, &quot;+&quot;)</code>, <code>right = Literal(2.0)</code>.</li>\n<li>The <code>varDeclaration()</code> method thus creates a <code>Var</code> statement node with <code>name = Token(IDENTIFIER, &quot;x&quot;)</code> and <code>initializer = Binary(Literal(1.0), PLUS, Literal(2.0))</code>.</li>\n<li>The parser then synchronizes at the <code>SEMICOLON</code>.</li>\n<li>For the second statement, <code>declaration()</code> sees <code>PRINT</code> and calls <code>printStatement()</code>. This method consumes the <code>PRINT</code> token, parses the following expression (which is just a <code>Variable</code> expression node referencing the token <code>IDENTIFIER(&quot;x&quot;)</code>), expects the <code>SEMICOLON</code>, and returns a <code>Print</code> statement node with <code>expression = Variable(Token(IDENTIFIER, &quot;x&quot;))</code>.</li>\n<li>The <code>Parser</code> returns a <code>List&lt;Stmt&gt;</code> containing two elements: first the <code>Var</code> statement, then the <code>Print</code> statement.</li>\n</ul>\n</li>\n<li><p><strong>Semantic Analysis and Execution (Interpreter)</strong>: The <code>Interpreter</code> receives the <code>List&lt;Stmt&gt;</code> via its <code>interpret()</code> method. It creates or reuses a global <code>Environment</code> (a chain of variable name-to-value maps). It then iterates through the statements, calling <code>execute()</code> on each.</p>\n<ul>\n<li><strong>Executing <code>Var x = 1 + 2;</code></strong>: The <code>visitVarStmt()</code> method is invoked with the <code>Var</code> node. It first evaluates the initializer expression by calling <code>evaluate()</code> on the <code>Binary</code> node.<ul>\n<li><code>evaluate()</code> on the <code>Binary</code> node recursively evaluates its left operand (<code>Literal(1.0)</code>) → returns <code>1.0</code>.</li>\n<li>It evaluates the right operand (<code>Literal(2.0)</code>) → returns <code>2.0</code>.</li>\n<li>It checks the operator (<code>PLUS</code>) and, since both operands are numbers, performs arithmetic addition, producing the runtime value <code>3.0</code> (a Java <code>Double</code>).</li>\n</ul>\n</li>\n<li>The interpreter then calls <code>environment.define(&quot;x&quot;, 3.0)</code>, which inserts the binding <code>&quot;x&quot; → 3.0</code> into the current environment&#39;s <code>values</code> map.</li>\n<li><strong>Executing <code>print x;</code></strong>: The <code>visitPrintStmt()</code> method is invoked. It evaluates its expression—a <code>Variable</code> node.<ul>\n<li><code>evaluate()</code> on the <code>Variable</code> node calls <code>environment.get(Token(IDENTIFIER, &quot;x&quot;))</code>. The environment looks up <code>&quot;x&quot;</code> in its map and returns the value <code>3.0</code>.</li>\n</ul>\n</li>\n<li>The interpreter passes this value to its <code>stringify()</code> helper, which converts the Double <code>3.0</code> to the string <code>&quot;3&quot;</code>. This string is then written to standard output (e.g., <code>System.out.println(&quot;3&quot;)</code>).</li>\n</ul>\n</li>\n<li><p><strong>Program Completion</strong>: The interpreter finishes executing the statement list. The <code>interpret()</code> method returns void. The program&#39;s side effect—printing <code>&quot;3&quot;</code>—has been achieved. The runtime values (<code>3.0</code> bound to <code>x</code>) may persist in the global environment if the interpreter continues (e.g., in a REPL), but for this script execution, they are discarded as the process ends.</p>\n</li>\n</ol>\n<p>For a more complex program involving functions and closures, the data flow extends further. Consider a brief excerpt: <code>fun makeCounter() { var i=0; return fun() { i = i + 1; return i; }; }</code>. <img src=\"/api/project/build-interpreter/architecture-doc/asset?path=diagrams%2Fdiagram-function-call-sequence.svg\" alt=\"Sequence Diagram: Function Call and Return\"> illustrates the interactions during a function call. The <strong>Parser</strong> produces a <code>Function</code> statement node for <code>makeCounter</code>. When the <strong>Interpreter</strong> executes this declaration, it creates a <code>LoxFunction</code> object that captures the <em>current</em> environment as its <code>closure</code>. Later, when <code>makeCounter()</code> is called, <code>LoxFunction.call()</code> creates a <em>new</em> environment whose <em>enclosing</em> link is that captured closure. The inner function&#39;s <code>LoxFunction</code> is created within this new environment, capturing a reference to it. When the inner function is later called, its execution environment chains back through that captured link, allowing it to access and modify the <code>i</code> variable that outlives the execution of <code>makeCounter</code>. This environment chain is the mechanism that enables lexical scoping and closures.</p>\n<h3 id=\"internal-data-handoffs\">Internal Data Handoffs</h3>\n<p>The transformation pipeline is defined by specific, immutable data structures passed between components. Each handoff point represents a complete shift in perspective on the program: from characters to words, from words to grammatical structure, from structure to executable meaning.</p>\n<p>The following table details the primary data structures at each stage of the pipeline, their role, and the component responsible for producing them.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Pipeline Stage</th>\n<th align=\"left\">Input Data Structure</th>\n<th align=\"left\">Output Data Structure</th>\n<th align=\"left\">Producing Component</th>\n<th align=\"left\">Description of Transformation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Lexical Analysis</strong></td>\n<td align=\"left\"><code>String</code> (source code)</td>\n<td align=\"left\"><code>List&lt;Token&gt;</code></td>\n<td align=\"left\"><code>Scanner</code></td>\n<td align=\"left\">Converts a linear sequence of characters into a linear sequence of categorized tokens. Whitespace and comments are filtered out. Each token carries its source location (<code>line</code>) and, for literals, a cooked value (<code>literal</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Syntactic Analysis</strong></td>\n<td align=\"left\"><code>List&lt;Token&gt;</code></td>\n<td align=\"left\"><code>List&lt;Stmt&gt;</code> (a program AST)</td>\n<td align=\"left\"><code>Parser</code></td>\n<td align=\"left\">Converts a flat sequence of tokens into a hierarchical tree of syntactic nodes (the AST). The tree structure implicitly encodes operator precedence, grouping, and the nesting of statements within blocks, functions, and control flow bodies.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Semantic Analysis &amp; Execution</strong></td>\n<td align=\"left\"><code>List&lt;Stmt&gt;</code> (AST)</td>\n<td align=\"left\">Side Effects &amp; Program Output</td>\n<td align=\"left\"><code>Interpreter</code> (with <code>Environment</code>)</td>\n<td align=\"left\">Recursively traverses the AST, evaluating expressions to produce runtime values (<code>Object</code>s) and executing statements to modify the environment (variable bindings) and produce side effects (e.g., printing to console). The <code>Environment</code> chain is the primary mutable runtime state.</td>\n</tr>\n</tbody></table>\n<p>The flow of control and data during interpretation is more intricate than a simple linear pipeline. The following numbered procedure outlines the key handoffs and decision points within the Interpreter&#39;s core execution loop.</p>\n<ol>\n<li><p><strong>Initialization</strong>: The <code>Interpreter</code> is initialized with a <code>globals</code> environment. At the start of <code>interpret(List&lt;Stmt&gt;)</code>, it sets <code>environment = globals</code>.</p>\n</li>\n<li><p><strong>Statement Iteration</strong>: For each <code>Stmt</code> in the list:</p>\n<ul>\n<li>The interpreter calls <code>stmt.accept(this)</code>. This invokes the appropriate <code>visit*Stmt</code> method via the Visitor pattern&#39;s double dispatch.</li>\n<li>Each <code>visit*Stmt</code> method may call <code>evaluate(Expr)</code> on embedded expression nodes, which in turn triggers <code>expr.accept(this)</code> and the corresponding <code>visit*Expr</code> methods.</li>\n<li>This creates a recursive descent through the AST that mirrors the syntactic structure but is driven by execution semantics.</li>\n</ul>\n</li>\n<li><p><strong>Expression Evaluation Handoff</strong>: When <code>evaluate(Expr)</code> is called on an expression node:</p>\n<ul>\n<li><strong>Literal</strong>: Returns the pre-computed <code>value</code> object (e.g., <code>Double</code>, <code>String</code>).</li>\n<li><strong>Variable</strong>: Handles off to <code>environment.get(nameToken)</code> to retrieve the current value bound to that name in the environment chain.</li>\n<li><strong>Assign</strong>: First <code>evaluate()</code>s the right-hand side value, then hands off to <code>environment.assign(nameToken, value)</code> to update the binding.</li>\n<li><strong>Binary</strong>: <code>evaluate()</code>s left and right operands, then performs type checking and the appropriate operation (e.g., arithmetic, comparison), returning a new runtime value.</li>\n</ul>\n</li>\n<li><p><strong>Environment Chain Traversal</strong>: The <code>Environment.get()</code> and <code>Environment.assign()</code> methods implement the <strong>handoff between scopes</strong>. They first check the current environment&#39;s <code>values</code> map. If the identifier is not found, they recursively delegate to the <code>enclosing</code> environment (if not <code>null</code>). This chain of handoffs continues until the variable is found (success) or the global scope is reached without success (runtime error).</p>\n</li>\n<li><p><strong>Function Call Handoff</strong>: A function call (<code>Expr.Call</code>) represents a major handoff:</p>\n<ul>\n<li>The <code>callee</code> expression is evaluated to a <code>LoxFunction</code> (or <code>LoxClass</code>).</li>\n<li>Argument expressions are evaluated to produce a <code>List&lt;Object&gt;</code> of runtime values.</li>\n<li>Control hands off to <code>LoxFunction.call(interpreter, arguments)</code>. This method:<ul>\n<li>Creates a new <code>Environment</code> whose <code>enclosing</code> link is the function&#39;s captured <code>closure</code>.</li>\n<li>Defines parameters in this new environment, mapping names to argument values.</li>\n<li>Pushes this environment onto the interpreter&#39;s scope stack (<code>executeBlock()</code> with the new environment).</li>\n<li>Executes the function&#39;s body statements. A <code>Return</code> statement throws a custom exception to unwind the call stack and hand the return value back to the caller.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Output Handoff</strong>: The <code>Print</code> statement&#39;s final handoff is to the host platform&#39;s standard output stream. The interpreter&#39;s <code>stringify()</code> method converts a Lox runtime <code>Object</code> to a Java <code>String</code>, which is then passed to <code>System.out.println()</code>.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> The data handoffs are not merely passing data forward; they also establish <strong>responsibility boundaries</strong>. The Scanner is responsible for <em>lexical correctness</em>, the Parser for <em>syntactic correctness</em>, and the Interpreter for <em>semantic (runtime) correctness</em>. Errors detected at each stage are reported using the most appropriate data available: the Scanner reports character and line numbers, the Parser reports unexpected tokens, and the Interpreter reports runtime values and operation types.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section bridges the architectural description to concrete Java code. It provides a skeleton for the main driver class that orchestrates the component interactions and shows how the data flows through method calls.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option</th>\n<th align=\"left\">Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Main Driver</strong></td>\n<td align=\"left\">Single <code>Lox</code> class with static methods</td>\n<td align=\"left\">Separate <code>Lox</code> (frontend), <code>Interpreter</code> (backend), and <code>Runner</code> (orchestrator) classes</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Error Reporting</strong></td>\n<td align=\"left\">Print errors to <code>System.err</code> with line numbers</td>\n<td align=\"left\">Collect errors in a list, allow for multiple error reporting, support IDE integration</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Output Stream</strong></td>\n<td align=\"left\">Direct <code>System.out</code> and <code>System.err</code></td>\n<td align=\"left\">Configurable <code>PrintStream</code> for output and error for easier testing</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Place the main orchestration logic in the root package, with components in their respective packages.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/\n├── Lox.java                    # Main driver class\n├── scanner/\n│   ├── Scanner.java\n│   └── Token.java\n├── parser/\n│   ├── Parser.java\n│   └── ParseError.java\n├── ast/\n│   ├── Expr.java\n│   ├── Stmt.java\n│   └── (Visitor interfaces)\n└── interpreter/\n    ├── Interpreter.java\n    ├── Environment.java\n    ├── RuntimeError.java\n    ├── LoxFunction.java\n    ├── LoxClass.java\n    └── LoxInstance.java</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>The <code>Lox</code> class serves as the entry point and orchestrator. Here is a complete, working version that handles file and REPL input, coordinates the components, and reports errors.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.BufferedReader;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.IOException;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.InputStreamReader;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.nio.charset.Charset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.nio.file.Files;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.nio.file.Paths;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Lox</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Interpreter interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadRuntimeError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">[] </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (args.length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Usage: jlox [script]\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (args.length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            runFile</span><span style=\"color:#E1E4E8\">(args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            runPrompt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runFile</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        byte</span><span style=\"color:#E1E4E8\">[] bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Files.</span><span style=\"color:#B392F0\">readAllBytes</span><span style=\"color:#E1E4E8\">(Paths.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(path));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> String</span><span style=\"color:#E1E4E8\">(bytes, Charset.</span><span style=\"color:#B392F0\">defaultCharset</span><span style=\"color:#E1E4E8\">()));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (hadError) System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">65</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (hadRuntimeError) System.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">70</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runPrompt</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">throws</span><span style=\"color:#E1E4E8\"> IOException {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        InputStreamReader input </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> InputStreamReader</span><span style=\"color:#E1E4E8\">(System.in);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BufferedReader reader </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> BufferedReader</span><span style=\"color:#E1E4E8\">(input);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (;;) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"> \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            String line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reader.</span><span style=\"color:#B392F0\">readLine</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (line </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            run</span><span style=\"color:#E1E4E8\">(line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Reset error flag for REPL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. LEXICAL ANALYSIS: Source String -> Tokens</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Scanner scanner </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Scanner</span><span style=\"color:#E1E4E8\">(source);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> scanner.</span><span style=\"color:#B392F0\">scanTokens</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. SYNTACTIC ANALYSIS: Tokens -> AST</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Parser parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#E1E4E8\">(tokens);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> statements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parser.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Stop if there was a parse error.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (hadError) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 3. SEMANTIC ANALYSIS &#x26; EXECUTION: AST -> Side Effects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        interpreter.</span><span style=\"color:#B392F0\">interpret</span><span style=\"color:#E1E4E8\">(statements);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Error reporting methods (used by Scanner, Parser, Interpreter)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        report</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> report</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.err.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[line \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"] Error\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> where </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \": \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (token.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TokenType.EOF) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            report</span><span style=\"color:#E1E4E8\">(token.line, </span><span style=\"color:#9ECBFF\">\" at end\"</span><span style=\"color:#E1E4E8\">, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            report</span><span style=\"color:#E1E4E8\">(token.line, </span><span style=\"color:#9ECBFF\">\" at '\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> token.lexeme </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"'\"</span><span style=\"color:#E1E4E8\">, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runtimeError</span><span style=\"color:#E1E4E8\">(RuntimeError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.err.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(error.</span><span style=\"color:#B392F0\">getMessage</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">[line \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> error.token.line </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"]\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hadRuntimeError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>The <code>Interpreter.interpret()</code> method is the heart of the execution phase. Below is its skeleton with TODOs that map to the steps described in the data flow.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> Expr.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Stmt.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Void</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    final</span><span style=\"color:#E1E4E8\"> Environment globals </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#E1E4E8\"> Environment environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> globals;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main entry point for execution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> interpret</span><span style=\"color:#E1E4E8\">(List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">statements</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Iterate through each statement in the provided list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: For each statement, call execute(stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (RuntimeError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Lox.</span><span style=\"color:#B392F0\">runtimeError</span><span style=\"color:#E1E4E8\">(error);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Execute a single statement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> execute</span><span style=\"color:#E1E4E8\">(Stmt </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Use the Visitor pattern: stmt.accept(this)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Evaluate an expression to a runtime value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Object </span><span style=\"color:#B392F0\">evaluate</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Use the Visitor pattern: expr.accept(this)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... visitor method implementations will go here ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Error Handling</strong>: Use custom exception classes (<code>ParseError</code>, <code>RuntimeError</code>) to separate error reporting from control flow. <code>ParseError</code> can be caught internally by the Parser for synchronization, while <code>RuntimeError</code> is caught at the top level in <code>interpret()</code>.</li>\n<li><strong>Visitor Pattern Boilerplate</strong>: Consider using an IDE or script to generate the visitor interface methods for the many <code>Expr</code> and <code>Stmt</code> subclasses.</li>\n<li><strong>REPL and File Execution</strong>: The <code>runPrompt()</code> method uses <code>readLine()</code> which provides line editing history on many systems. For file execution, read the entire file into a string for simplicity.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the core pipeline (through Milestone 5), you can verify the end-to-end flow with the sample program:</p>\n<ol>\n<li><strong>Create a test file</strong> <code>test.lox</code> with content: <code>var x = 1 + 2; print x;</code></li>\n<li><strong>Run your interpreter</strong>: <code>java com.craftinginterpreters.lox.Lox test.lox</code></li>\n<li><strong>Expected Output</strong>: The number <code>3</code> printed on a line by itself.</li>\n<li><strong>Signs of Trouble</strong>:<ul>\n<li>No output or an error: Check that your <code>Scanner</code> is producing the correct token list (use a debug print). Verify the <code>Parser</code> builds the expected AST (use an AST printer). Ensure the <code>Interpreter</code>&#39;s <code>visitVarStmt</code> and <code>visitPrintStmt</code> are being called.</li>\n<li>Incorrect output (e.g., <code>1</code>, <code>2</code>, <code>12</code>): Likely an issue in expression evaluation precedence or in the <code>Binary</code> expression evaluation logic (check operator handling).</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">How to Diagnose</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Program prints nothing</strong></td>\n<td align=\"left\">Parser failed silently due to error, <code>hadError</code> is true, <code>interpret()</code> not called.</td>\n<td align=\"left\">Add a debug print in <code>run()</code> after parsing to see if <code>statements</code> is null/empty. Check <code>hadError</code> flag.</td>\n<td align=\"left\">Ensure error reporting sets <code>hadError</code> and that <code>run()</code> returns early if <code>hadError</code> is true.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>&quot;Undefined variable &#39;x&#39;&quot; at runtime</strong></td>\n<td align=\"left\">Variable binding not stored or retrieved correctly from the environment.</td>\n<td align=\"left\">Print the environment&#39;s <code>values</code> map after <code>define()</code> and before <code>get()</code>. Check that the environment chain is correct.</td>\n<td align=\"left\">Verify <code>environment.define()</code> is called with the correct name string and value. Ensure <code>environment.get()</code> is searching the chain via the <code>enclosing</code> field.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Incorrect arithmetic result (e.g., 1+2=12)</strong></td>\n<td align=\"left\">Operands treated as strings, concatenated instead of added.</td>\n<td align=\"left\">Print the types (<code>instanceof</code>) of the left and right operands in <code>visitBinaryExpr</code>.</td>\n<td align=\"left\">Implement runtime type checking: ensure both operands are <code>Double</code> before performing arithmetic.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Parser goes into infinite loop</strong></td>\n<td align=\"left\">Grammar rule left-recursion or missing advance over tokens.</td>\n<td align=\"left\">Add a debug print at the start of each parsing method showing the current token.</td>\n<td align=\"left\">Ensure each parsing method that consumes a token calls <code>advance()</code> or <code>consume()</code>. Check for left-recursive grammar rules (not a problem in our recursive descent formulation if written correctly).</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-error-handling-and-edge-cases\">7. Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (Milestones 1-10) — Error handling is a cross-cutting concern that evolves through each phase of interpretation, from lexical analysis through runtime execution.</p>\n</blockquote>\n<p>Robust error handling is what separates a toy interpreter from a usable programming tool. In a tree-walking interpreter, errors can occur at three distinct phases: <strong>lexical</strong> (scanning), <strong>syntactic</strong> (parsing), and <strong>semantic</strong> (runtime). Each phase requires different detection, reporting, and recovery strategies. This section defines a comprehensive approach that provides clear, actionable feedback to Lox programmers while maintaining interpreter stability.</p>\n<h3 id=\"error-classification-and-reporting\">Error Classification and Reporting</h3>\n<p><strong>Mental Model: The Error Lifecycle</strong>\nThink of error handling as a quality control pipeline in a manufacturing plant. At the first station (Scanner), raw materials (characters) are inspected for obvious defects like unrecognized symbols or malformed parts. Defective items are rejected immediately with a detailed defect report. At the second station (Parser), the arrangement of approved parts is checked against assembly diagrams (grammar rules); misassemblies trigger a pause while the assembly line resets. Finally, at the third station (Interpreter), the assembled product is tested under real-world conditions; operational failures (like trying to use a hammer as a screwdriver) halt production entirely with a clear explanation of what went wrong.</p>\n<h4 id=\"error-categories-and-detection-points\">Error Categories and Detection Points</h4>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Detection Point</th>\n<th>Trigger Condition</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Lexical Error</strong></td>\n<td><code>Scanner.scanTokens()</code></td>\n<td>Unrecognized character, unterminated string, malformed number</td>\n<td><code>&quot;Hello, world!</code> (missing closing quote)</td>\n</tr>\n<tr>\n<td><strong>Syntactic Error</strong></td>\n<td><code>Parser.parse()</code></td>\n<td>Token sequence violates grammar rules</td>\n<td><code>var x = ;</code> (missing expression after <code>=</code>)</td>\n</tr>\n<tr>\n<td><strong>Runtime Error</strong></td>\n<td><code>Interpreter.evaluate()</code>/<code>execute()</code></td>\n<td>Semantic violation during execution</td>\n<td><code>&quot;text&quot; - 1</code> (invalid operands for <code>-</code>)</td>\n</tr>\n</tbody></table>\n<h4 id=\"error-reporting-standards\">Error Reporting Standards</h4>\n<p>All errors must include:</p>\n<ol>\n<li><strong>Location</strong>: The exact line number (and ideally column) in the source file</li>\n<li><strong>Phase</strong>: Clear indication of whether it&#39;s a scanning, parsing, or runtime error</li>\n<li><strong>Specific Message</strong>: A human-readable description of what went wrong</li>\n<li><strong>Context</strong>: The offending token or expression that triggered the error</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> Good error messages don&#39;t just say <em>what</em> went wrong; they help the programmer understand <em>why</em> and <em>how to fix it</em>. A message like &quot;Unexpected &#39;;&#39; at line 5, expected expression&quot; is far more actionable than simply &quot;Syntax error.&quot;</p>\n</blockquote>\n<h4 id=\"error-class-hierarchy\">Error Class Hierarchy</h4>\n<p>The interpreter uses a three-tiered exception hierarchy:</p>\n<table>\n<thead>\n<tr>\n<th>Exception Class</th>\n<th>Superclass</th>\n<th>When Thrown</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ScanError</code></td>\n<td><code>RuntimeException</code></td>\n<td>During lexical analysis when encountering invalid characters or unterminated strings</td>\n<td>Report and continue scanning (skip invalid token)</td>\n</tr>\n<tr>\n<td><code>ParseError</code></td>\n<td><code>RuntimeException</code></td>\n<td>During parsing when token sequence violates grammar</td>\n<td>Enter panic mode, synchronize, continue parsing</td>\n</tr>\n<tr>\n<td><code>RuntimeError</code></td>\n<td><code>RuntimeException</code></td>\n<td>During evaluation when semantic rules are violated</td>\n<td>Propagate up, halt current statement execution</td>\n</tr>\n</tbody></table>\n<p><strong>ADR: Unified vs. Phase-Specific Error Types</strong></p>\n<blockquote>\n<p><strong>Decision: Phase-Specific Error Types</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to handle errors differently based on which phase of interpretation encounters them. The scanner can often recover and continue, the parser uses panic-mode recovery, while runtime errors typically halt execution of the current statement.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Single <code>LoxError</code> class</strong>: One exception type for all phases, with an enum field for phase.</li>\n<li><strong>Phase-specific subclasses</strong>: Separate classes for <code>ScanError</code>, <code>ParseError</code>, and <code>RuntimeError</code>.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use phase-specific exception subclasses.</li>\n<li><strong>Rationale</strong>: <ul>\n<li><strong>Type Safety</strong>: The compiler ensures each phase only throws appropriate errors.</li>\n<li><strong>Clear Intent</strong>: Code that catches <code>ParseError</code> explicitly states it&#39;s handling parsing failures.</li>\n<li><strong>Recovery Separation</strong>: Each phase can implement recovery logic specific to its error type without complex conditional logic.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Slightly more class definitions.</li>\n<li>Clearer code organization and error handling flow.</li>\n<li>Enables phase-specific recovery strategies.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single <code>LoxError</code> class</td>\n<td>Simpler hierarchy, uniform handling</td>\n<td>Loses phase information, forces all handlers to check phase type</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Phase-specific subclasses</td>\n<td>Type-safe, clear intent, enables tailored recovery</td>\n<td>More classes, some duplication</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<h4 id=\"location-tracking-implementation\">Location Tracking Implementation</h4>\n<p>Both tokens and exceptions must carry precise location information:</p>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Location Fields</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Token</code></td>\n<td><code>line: int</code>, <code>column: int</code> (optional)</td>\n<td>Record where token appears in source</td>\n</tr>\n<tr>\n<td><code>ScanError</code></td>\n<td><code>line: int</code>, <code>message: String</code></td>\n<td>Report where scanning failed</td>\n</tr>\n<tr>\n<td><code>ParseError</code></td>\n<td><code>token: Token</code>, <code>message: String</code></td>\n<td>Report which token caused parse failure</td>\n</tr>\n<tr>\n<td><code>RuntimeError</code></td>\n<td><code>token: Token</code>, <code>message: String</code></td>\n<td>Report which expression caused runtime failure</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-recovery-strategies\">Error Recovery Strategies</h3>\n<p><strong>Mental Model: The Fault-Tolerant Assembly Line</strong>\nImagine an assembly line that can recover from different types of faults. For minor part defects (lexical errors), workers remove the bad part but keep the line moving. For assembly mistakes (syntax errors), the line pauses, discards the partially assembled unit back to the last known good checkpoint, then resumes. For operational failures (runtime errors), the entire unit is scrapped, but the factory can still produce subsequent units.</p>\n<h4 id=\"parser-panic-mode-recovery\">Parser: Panic-Mode Recovery</h4>\n<p>The parser implements <strong>panic-mode recovery</strong>, a technique where upon encountering a syntax error, it discards tokens until reaching a known synchronization point (typically a statement boundary), then continues parsing. This prevents a single syntax error from causing a cascade of spurious follow-up errors.</p>\n<p><strong>Panic-Mode Recovery Algorithm:</strong></p>\n<ol>\n<li><strong>Detection</strong>: When <code>Parser.error()</code> is called with the current token and an error message.</li>\n<li><strong>Panic Mode Entry</strong>: Set an internal <code>panicMode</code> flag to <code>true</code>.</li>\n<li><strong>Synchronization Point</strong>: Discard tokens until finding one that can reasonably continue parsing:<ul>\n<li>Statement boundaries: <code>SEMICOLON</code>, <code>PRINT</code>, <code>RETURN</code>, <code>IF</code>, <code>WHILE</code>, <code>FOR</code>, <code>CLASS</code>, <code>FUN</code>, <code>VAR</code></li>\n<li>Class/function boundaries: <code>RIGHT_BRACE</code></li>\n</ul>\n</li>\n<li><strong>Recovery</strong>: Clear <code>panicMode</code> flag and continue parsing from the synchronization point.</li>\n<li><strong>Error Reporting</strong>: Report the error immediately with token location and expected construct.</li>\n</ol>\n<blockquote>\n<p><strong>Design Principle:</strong> The parser should never crash or enter an infinite loop due to invalid syntax. It should report <em>all</em> syntax errors in a single pass when possible, giving programmers comprehensive feedback.</p>\n</blockquote>\n<p><strong>ADR: Synchronization Point Selection</strong></p>\n<blockquote>\n<p><strong>Decision: Synchronize at Statement Boundaries</strong></p>\n<ul>\n<li><strong>Context</strong>: After a syntax error, we need to discard tokens until we reach a point where parsing can reasonably resume without producing garbage.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Synchronize at statement boundaries</strong> (<code>;</code>, keywords starting statements).</li>\n<li><strong>Synchronize at expression boundaries</strong> (operators, parentheses).</li>\n<li><strong>Synchronize at any &quot;safe&quot; token</strong> (tokens that can&#39;t appear in the current context).</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Synchronize at statement boundaries.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Simplicity</strong>: Statement boundaries are easy to identify and match programmer intuition.</li>\n<li><strong>Effectiveness</strong>: Most syntax errors affect a single statement; discarding the rest of a malformed statement is safe.</li>\n<li><strong>Predictability</strong>: Programmers can understand why parsing resumed where it did.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>May discard multiple tokens for errors early in a statement.</li>\n<li>Provides good recovery for most common syntax errors.</li>\n<li>Simple to implement with a set of synchronization tokens.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Statement boundaries</td>\n<td>Simple, effective, predictable</td>\n<td>May discard many tokens</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Expression boundaries</td>\n<td>Finer-grained recovery</td>\n<td>Complex to implement, may produce confusing follow-up errors</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Contextual &quot;safe&quot; tokens</td>\n<td>Most precise recovery</td>\n<td>Very complex, requires full context tracking</td>\n<td>❌</td>\n</tr>\n</tbody></table>\n<h4 id=\"scanner-best-effort-recovery\">Scanner: Best-Effort Recovery</h4>\n<p>The scanner implements a simpler recovery strategy: when encountering an unrecognized character or unterminated string, it reports the error but continues scanning from the next character (for invalid characters) or line (for unterminated strings).</p>\n<p><strong>Scanner Recovery Rules:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Recovery Action</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unrecognized character (e.g., <code>@</code>)</td>\n<td>Report error, advance past character</td>\n<td>Single character likely a typo; rest of file may be valid</td>\n</tr>\n<tr>\n<td>Unterminated string</td>\n<td>Report error, consume until end of line</td>\n<td>Strings can&#39;t span lines; assume programmer forgot closing quote</td>\n</tr>\n<tr>\n<td>Malformed number (e.g., <code>123.</code>)</td>\n<td>Report error, tokenize as valid prefix</td>\n<td>Helps identify exact location while allowing continued parsing</td>\n</tr>\n</tbody></table>\n<h4 id=\"interpreter-fail-fast-runtime-errors\">Interpreter: Fail-Fast Runtime Errors</h4>\n<p>Runtime errors follow a <strong>fail-fast</strong> strategy: when a semantic violation occurs, execution of the current expression/statement halts immediately, the error propagates up the call stack, and the interpreter stops evaluating the current program (or statement in REPL mode).</p>\n<p><strong>Runtime Error Propagation:</strong></p>\n<ol>\n<li><strong>Detection</strong>: A runtime check fails in an evaluation method (e.g., type mismatch).</li>\n<li><strong>Throw</strong>: <code>RuntimeError</code> is thrown with the offending token and descriptive message.</li>\n<li><strong>Propagation</strong>: Exception bubbles up through <code>evaluate()</code> and <code>execute()</code> calls.</li>\n<li><strong>Top-Level Catch</strong>: <code>Interpreter.interpret()</code> catches <code>RuntimeError</code>, reports it, and stops execution of the current program (but keeps interpreter alive in REPL mode).</li>\n</ol>\n<blockquote>\n<p><strong>Important Distinction:</strong> Runtime errors halt <em>execution</em> but don&#39;t crash the <em>interpreter process</em>. In batch mode, the interpreter exits with an error code. In REPL mode, it prints the error and returns to the prompt.</p>\n</blockquote>\n<h3 id=\"specific-edge-cases-and-semantics\">Specific Edge Cases and Semantics</h3>\n<p><strong>Mental Model: The Law of Least Surprise</strong>\nProgramming language semantics should follow the &quot;principle of least surprise&quot;: edge cases should behave in ways that are intuitive to experienced programmers. When intuition fails, the behavior should be explicitly defined and documented rather than left to implementation chance.</p>\n<h4 id=\"type-system-edge-cases\">Type System Edge Cases</h4>\n<p>Lox uses dynamic typing with implicit conversions only where mathematically sensible. The following table defines the complete semantics:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Left Operand</th>\n<th>Right Operand</th>\n<th>Result</th>\n<th>Error Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Addition (<code>+</code>)</strong></td>\n<td>Number</td>\n<td>Number</td>\n<td>Numeric sum</td>\n<td>None</td>\n</tr>\n<tr>\n<td></td>\n<td>String</td>\n<td>Any</td>\n<td>Concatenation (right converted to string)</td>\n<td>None</td>\n</tr>\n<tr>\n<td></td>\n<td>Any</td>\n<td>String</td>\n<td>Concatenation (left converted to string)</td>\n<td>None</td>\n</tr>\n<tr>\n<td></td>\n<td>Non-string, Non-number</td>\n<td>Non-string</td>\n<td><code>RuntimeError</code>: &quot;Operands must be two numbers or at least one string.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Other Arithmetic (<code>-</code>, <code>*</code>, <code>/</code>)</strong></td>\n<td>Number</td>\n<td>Number</td>\n<td>Numeric operation</td>\n<td>Division by zero → <code>RuntimeError</code></td>\n</tr>\n<tr>\n<td></td>\n<td>Non-number</td>\n<td>Any</td>\n<td><code>RuntimeError</code>: &quot;Operand must be a number.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td></td>\n<td>Any</td>\n<td>Non-number</td>\n<td><code>RuntimeError</code>: &quot;Operand must be a number.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Comparison (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)</strong></td>\n<td>Number</td>\n<td>Number</td>\n<td>Boolean comparison</td>\n<td>None</td>\n</tr>\n<tr>\n<td></td>\n<td>Non-number</td>\n<td>Any</td>\n<td><code>RuntimeError</code>: &quot;Operands must be numbers.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td></td>\n<td>Any</td>\n<td>Non-number</td>\n<td><code>RuntimeError</code>: &quot;Operands must be numbers.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Equality (<code>==</code>, <code>!=</code>)</strong></td>\n<td>Any</td>\n<td>Any</td>\n<td>Deep equality comparison</td>\n<td>None (even different types can be compared)</td>\n</tr>\n<tr>\n<td><strong>Unary Negation (<code>-</code>)</strong></td>\n<td>Number</td>\n<td>-</td>\n<td>Negated number</td>\n<td>None</td>\n</tr>\n<tr>\n<td></td>\n<td>Non-number</td>\n<td>-</td>\n<td><code>RuntimeError</code>: &quot;Operand must be a number.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Unary Not (<code>!</code>)</strong></td>\n<td>Any</td>\n<td>-</td>\n<td>Logical negation (applies truthiness)</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<h4 id=\"truthiness-rules\">Truthiness Rules</h4>\n<p>Lox&#39;s truthiness rules are simple but must be implemented consistently:</p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>Truthiness</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>false</code></td>\n<td>Falsy</td>\n<td>Boolean false</td>\n</tr>\n<tr>\n<td><code>nil</code></td>\n<td>Falsy</td>\n<td>Represents &quot;no value&quot;</td>\n</tr>\n<tr>\n<td><code>true</code></td>\n<td>Truthy</td>\n<td>Boolean true</td>\n</tr>\n<tr>\n<td>Number (<code>0</code>, <code>0.0</code>, negative, positive)</td>\n<td>Truthy</td>\n<td>Common convention: only booleans control flow</td>\n</tr>\n<tr>\n<td>String (empty <code>&quot;&quot;</code>, non-empty)</td>\n<td>Truthy</td>\n<td>Empty string is still a valid value</td>\n</tr>\n<tr>\n<td>Function object</td>\n<td>Truthy</td>\n<td>Callable entity exists</td>\n</tr>\n<tr>\n<td>Class object</td>\n<td>Truthy</td>\n<td>Type definition exists</td>\n</tr>\n<tr>\n<td>Instance object</td>\n<td>Truthy</td>\n<td>Object exists</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> Unlike some languages, Lox does <em>not</em> treat <code>0</code>, <code>0.0</code>, or empty string <code>&quot;&quot;</code> as falsy. This simplifies the mental model: only <code>false</code> and <code>nil</code> are falsy.</p>\n</blockquote>\n<h4 id=\"object-model-edge-cases\">Object Model Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Error Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Accessing undefined property</strong></td>\n<td>Returns <code>nil</code></td>\n<td>None (dynamic languages often allow this)</td>\n</tr>\n<tr>\n<td><strong>Setting new property</strong></td>\n<td>Creates property on instance</td>\n<td>None (objects are open)</td>\n</tr>\n<tr>\n<td><strong>Calling non-function value</strong></td>\n<td><code>RuntimeError</code>: &quot;Can only call functions and classes.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Calling class as function</strong></td>\n<td>Creates new instance, calls <code>init</code> if defined</td>\n<td>Wrong arity for <code>init</code> → <code>RuntimeError</code></td>\n</tr>\n<tr>\n<td><strong><code>super</code> outside class</strong></td>\n<td><code>ParseError</code> at parse time</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong><code>this</code> outside method</strong></td>\n<td><code>RuntimeError</code>: &quot;Can&#39;t use &#39;this&#39; outside of a class.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Return at top level</strong></td>\n<td><code>RuntimeError</code>: &quot;Can&#39;t return from top-level code.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Inheritance cycle</strong></td>\n<td><code>RuntimeError</code>: &quot;Inheritance cycle detected.&quot;</td>\n<td>✅ (at class definition)</td>\n</tr>\n</tbody></table>\n<h4 id=\"special-numerical-semantics\">Special Numerical Semantics</h4>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Special Case</th>\n<th>Result</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Division (<code>/</code>)</td>\n<td><code>1 / 0</code></td>\n<td><code>RuntimeError</code>: &quot;Division by zero.&quot;</td>\n<td>Must be caught at runtime</td>\n</tr>\n<tr>\n<td>Negation (<code>-</code>)</td>\n<td><code>-0</code></td>\n<td><code>-0</code> (negative zero)</td>\n<td>IEEE 754 floating-point behavior</td>\n</tr>\n<tr>\n<td>String to number</td>\n<td><code>Number(&quot;123&quot;)</code> (hypothetical)</td>\n<td>N/A</td>\n<td>Lox has no explicit conversion functions</td>\n</tr>\n</tbody></table>\n<h4 id=\"string-concatenation-details\">String Concatenation Details</h4>\n<p>String concatenation follows these conversion rules:</p>\n<table>\n<thead>\n<tr>\n<th>Value Type</th>\n<th>String Representation</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>nil</code></td>\n<td><code>&quot;nil&quot;</code></td>\n<td><code>&quot;Value: &quot; + nil</code> → <code>&quot;Value: nil&quot;</code></td>\n</tr>\n<tr>\n<td><code>false</code></td>\n<td><code>&quot;false&quot;</code></td>\n<td><code>&quot;Status: &quot; + false</code> → <code>&quot;Status: false&quot;</code></td>\n</tr>\n<tr>\n<td><code>true</code></td>\n<td><code>&quot;true&quot;</code></td>\n<td><code>&quot;Status: &quot; + true</code> → <code>&quot;Status: true&quot;</code></td>\n</tr>\n<tr>\n<td>Number</td>\n<td>Decimal representation (no trailing <code>.0</code> for integers)</td>\n<td><code>&quot;Count: &quot; + 42</code> → <code>&quot;Count: 42&quot;</code></td>\n</tr>\n<tr>\n<td>String</td>\n<td>The string itself (no extra quotes)</td>\n<td><code>&quot;Hello, &quot; + &quot;world&quot;</code> → <code>&quot;Hello, world&quot;</code></td>\n</tr>\n<tr>\n<td>Function</td>\n<td>Implementation-defined (e.g., <code>&lt;fn foo&gt;</code>)</td>\n<td><code>&quot;Func: &quot; + foo</code> → <code>&quot;Func: &lt;fn foo&gt;&quot;</code></td>\n</tr>\n<tr>\n<td>Class</td>\n<td>Implementation-defined (e.g., <code>&lt;class Foo&gt;</code>)</td>\n<td><code>&quot;Class: &quot; + Foo</code> → <code>&quot;Class: &lt;class Foo&gt;&quot;</code></td>\n</tr>\n<tr>\n<td>Instance</td>\n<td>Implementation-defined (e.g., <code>&lt;Foo instance&gt;</code>)</td>\n<td><code>&quot;Obj: &quot; + Foo()</code> → <code>&quot;Obj: &lt;Foo instance&gt;&quot;</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"variable-resolution-edge-cases\">Variable Resolution Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Error Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Accessing undefined variable</strong></td>\n<td><code>RuntimeError</code>: &quot;Undefined variable &#39;x&#39;.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Assigning to undefined variable</strong></td>\n<td><code>RuntimeError</code>: &quot;Undefined variable &#39;x&#39;.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Redeclaring variable in same scope</strong></td>\n<td>Allowed (overwrites previous value)</td>\n<td>None (dynamic languages often allow)</td>\n</tr>\n<tr>\n<td><strong>Shadowing outer variable</strong></td>\n<td>Allowed (inner scope variable masks outer)</td>\n<td>None</td>\n</tr>\n<tr>\n<td><strong>Closure accessing mutable outer variable</strong></td>\n<td>Gets current value at execution time</td>\n<td>None (captures variable, not value)</td>\n</tr>\n</tbody></table>\n<h4 id=\"function-call-edge-cases\">Function Call Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Error Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Wrong number of arguments</strong></td>\n<td><code>RuntimeError</code>: &quot;Expected X arguments but got Y.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Recursive call depth exceeded</strong></td>\n<td>Stack overflow (JVM handles)</td>\n<td>None (system-dependent)</td>\n</tr>\n<tr>\n<td><strong>Return without value</strong></td>\n<td>Returns <code>nil</code></td>\n<td>None</td>\n</tr>\n<tr>\n<td><strong>Call on <code>nil</code></strong></td>\n<td><code>RuntimeError</code>: &quot;Can only call functions and classes.&quot;</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<h4 id=\"inheritance-edge-cases\">Inheritance Edge Cases</h4>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Behavior</th>\n<th>Error Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Inheriting from non-class</strong></td>\n<td><code>RuntimeError</code>: &quot;Superclass must be a class.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Accessing <code>super</code> in class with no superclass</strong></td>\n<td><code>RuntimeError</code>: &quot;Can&#39;t use &#39;super&#39; in a class with no superclass.&quot;</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>Calling <code>super.init()</code> multiple times</strong></td>\n<td>Allowed (but unusual)</td>\n<td>None</td>\n</tr>\n<tr>\n<td><strong>Overriding method with different arity</strong></td>\n<td>Allowed (Lox doesn&#39;t check)</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Confusing Java null with Lox nil</strong></p>\n<ul>\n<li><strong>Description</strong>: Using Java&#39;s <code>null</code> to represent Lox&#39;s <code>nil</code> without proper boxing.</li>\n<li><strong>Why it&#39;s wrong</strong>: Many operations that should work on <code>nil</code> (like concatenation with strings) will throw <code>NullPointerException</code> if using raw <code>null</code>.</li>\n<li><strong>Fix</strong>: Create a dedicated <code>LoxNil</code> singleton class or use a sentinel object to represent <code>nil</code> distinct from Java <code>null</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incomplete error location reporting</strong></p>\n<ul>\n<li><strong>Description</strong>: Reporting errors without line numbers or with incorrect line numbers.</li>\n<li><strong>Why it&#39;s wrong</strong>: Programmers can&#39;t find the error in their source code.</li>\n<li><strong>Fix</strong>: Ensure every <code>Token</code> carries accurate line (and ideally column) information, and every error includes the token&#39;s location.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to synchronize after parse error</strong></p>\n<ul>\n<li><strong>Description</strong>: Parser enters infinite loop or produces cascading errors after first syntax error.</li>\n<li><strong>Why it&#39;s wrong</strong>: Makes interpreter unusable for debugging multi-error programs.</li>\n<li><strong>Fix</strong>: Implement proper panic-mode recovery with synchronization at statement boundaries.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Allowing division by zero to propagate as Java exception</strong></p>\n<ul>\n<li><strong>Description</strong>: Letting Java&#39;s <code>ArithmeticException</code> bubble up instead of catching and converting to <code>RuntimeError</code>.</li>\n<li><strong>Why it&#39;s wrong</strong>: Gives Java-specific error messages instead of Lox-specific ones.</li>\n<li><strong>Fix</strong>: Explicitly check divisor before division operation and throw <code>RuntimeError</code> with Lox message.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not checking operand types before operations</strong></p>\n<ul>\n<li><strong>Description</strong>: Assuming operands are numbers without verification, leading to <code>ClassCastException</code>.</li>\n<li><strong>Why it&#39;s wrong</strong>: Breaks dynamic typing guarantees and produces Java-level errors.</li>\n<li><strong>Fix</strong>: Use <code>instanceof</code> checks or visitor pattern to verify operand types before operations.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Poor truthiness implementation</strong></p>\n<ul>\n<li><strong>Description</strong>: Treating <code>0</code>, <code>&quot;&quot;</code>, or other values as falsy contrary to Lox spec.</li>\n<li><strong>Why it&#39;s wrong</strong>: Programs behave differently than specified in language definition.</li>\n<li><strong>Fix</strong>: Implement <code>isTruthy()</code> method that returns <code>false</code> only for <code>false</code> and <code>nil</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Reporting</td>\n<td>Plain <code>System.err.println()</code> with formatting</td>\n<td>Structured logging framework (SLF4J)</td>\n</tr>\n<tr>\n<td>Exception Handling</td>\n<td>Java built-in exceptions</td>\n<td>Custom exception hierarchy with chained causes</td>\n</tr>\n<tr>\n<td>Location Tracking</td>\n<td>Line numbers only</td>\n<td>Line and column with source snippet display</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/\n  src/main/java/com/craftinginterpreters/lox/\n    Lox.java                 # Main entry point with error reporting\n    Token.java               # Token definition with location\n    TokenType.java           # Enum of token types\n    Scanner.java             # Lexical analysis with ScanError\n    Parser.java              # Syntactic analysis with ParseError\n    Interpreter.java         # Runtime evaluation with RuntimeError\n    RuntimeError.java        # Runtime exception class\n    ParseError.java          # Parse exception class  \n    environment/\n      Environment.java       # Variable storage\n    ast/\n      Expr.java              # Expression base class\n      Stmt.java              # Statement base class\n      ...                    # All AST node classes\n    runtime/\n      LoxCallable.java       # Callable interface\n      LoxFunction.java       # Function representation\n      LoxClass.java          # Class representation\n      LoxInstance.java       # Instance representation\n      LoxNil.java            # Nil singleton</code></pre></div>\n\n<h4 id=\"c-error-exception-classes-complete-starter-code\">C. Error Exception Classes (Complete Starter Code)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// RuntimeError.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Runtime errors occur during evaluation when semantic rules are violated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> RuntimeException</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Token token;  </span><span style=\"color:#6A737D\">// The token where the error occurred</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#B392F0\"> RuntimeError</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(message);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ParseError.java  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parse errors occur during parsing when syntax rules are violated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is a wrapper exception used for panic-mode recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> RuntimeException</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(message);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: We could store token for location, but ParseError is caught</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // internally by Parser for recovery, not reported to user directly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-error-reporting-in-main-class-core-logic-skeleton\">D. Error Reporting in Main Class (Core Logic Skeleton)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Lox.java (partial)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Lox</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Interpreter interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadRuntimeError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Main entry point for running a source file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runFile</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read the file contents into a string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call run() with the source string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Exit with appropriate code: 65 for syntax errors, 70 for runtime errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Main entry point for REPL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runPrompt</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create InputStreamReader for interactive input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each line: run(line), reset hadError flag (but not hadRuntimeError)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle Ctrl+D gracefully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Core execution engine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 1: Create Scanner and scan tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 2: Create Parser and parse statements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 3: If no parse error, interpret with Interpreter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (RuntimeError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">      runtimeError</span><span style=\"color:#E1E4E8\">(error);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Report a scanning or parsing error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    report</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Overload for token-based errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if token is EOF and report differently</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Otherwise report with line number and token lexeme</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> report</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Print to stderr: \"[line X] ErrorY: message\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set hadError = true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Report a runtime error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> runtimeError</span><span style=\"color:#E1E4E8\">(RuntimeError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Print to stderr: error.getMessage() + \"\\n[line \" + error.token.line + \"]\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set hadRuntimeError = true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-parser-error-recovery-core-logic-skeleton\">E. Parser Error Recovery (Core Logic Skeleton)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Parser.java (partial)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> panicMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Entry point for parsing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> statements </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> ArrayList&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">isAtEnd</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 1: Parse a declaration (which parses statements)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 2: Add to statements list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> statements;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Report a parse error and enter panic mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> ParseError </span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Call Lox.error(token, message) to report to user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set hadError = true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return new ParseError for synchronization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Consume tokens until reaching a synchronization point</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> synchronize</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Exit panic mode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Advance past bad token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Skip tokens until reaching a statement boundary:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - SEMICOLON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Keywords: CLASS, FUN, VAR, FOR, IF, WHILE, PRINT, RETURN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return to normal parsing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Helper method used in parsing methods</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> Token </span><span style=\"color:#B392F0\">consume</span><span style=\"color:#E1E4E8\">(TokenType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">check</span><span style=\"color:#E1E4E8\">(type)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#B392F0\"> advance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">(), message);  </span><span style=\"color:#6A737D\">// This triggers panic mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"f-runtime-type-checking-core-logic-skeleton\">F. Runtime Type Checking (Core Logic Skeleton)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Interpreter.java (partial)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> Expr.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Stmt.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Void</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Binary expression evaluation with type checking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(Expr.Binary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Evaluate left and right operands</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For arithmetic operations (-, *, /):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Check both operands are Double using checkNumberOperand()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - For division, check right != 0.0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For comparison (&#x3C;, &#x3C;=, >, >=):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Check both operands are Double using checkNumberOperands()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For equality (==, !=):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Use isEqual() helper (works for any types)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For addition (+):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - If either operand is String, convert both to strings and concatenate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Otherwise check both are Double</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Throw RuntimeError with token location for type mismatches</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Helper to check unary operand type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> checkNumberOperand</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">operator</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">operand</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: If operand is not Double, throw RuntimeError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Helper to check binary operand types  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> checkNumberOperands</span><span style=\"color:#E1E4E8\">(Token </span><span style=\"color:#FFAB70\">operator</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: If either operand is not Double, throw RuntimeError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // String conversion helper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">object</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Handle null (return \"nil\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle Double: remove trailing \".0\" for integers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle Boolean: return \"true\" or \"false\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For other objects, call toString()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"g-language-specific-hints-java\">G. Language-Specific Hints (Java)</h4>\n<ol>\n<li><p><strong>Use <code>Double</code> for numbers</strong>: Java&#39;s <code>double</code> primitive can&#39;t be <code>null</code>, so use <code>Double</code> object type to represent Lox numbers and allow <code>nil</code> distinction.</p>\n</li>\n<li><p><strong>Create a <code>LoxNil</code> singleton</strong>:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> LoxNil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> LoxNil INSTANCE </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> LoxNil</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     private</span><span style=\"color:#B392F0\"> LoxNil</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     @</span><span style=\"color:#F97583\">Override</span><span style=\"color:#F97583\"> public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"nil\"</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Careful with floating-point equality</strong>: Use epsilon comparison for <code>==</code> on numbers:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isEqual</span><span style=\"color:#E1E4E8\">(Object a, Object b) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     if</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     if</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     if</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Double </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Double) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> Math.</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">((Double)a </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (Double)b) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1e-12</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     return</span><span style=\"color:#E1E4E8\"> a.</span><span style=\"color:#B392F0\">equals</span><span style=\"color:#E1E4E8\">(b);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Throw, don&#39;t return errors</strong>: In visitor methods, throw <code>RuntimeError</code> immediately when semantic violation detected rather than returning error sentinel values.</li>\n</ol>\n<h4 id=\"h-milestone-checkpoint-error-handling-verification\">H. Milestone Checkpoint: Error Handling Verification</h4>\n<table>\n<thead>\n<tr>\n<th>Milestone</th>\n<th>Test Command</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1 (Scanner)</td>\n<td><code>java Lox test.lox</code> with <code>&quot;unterminated string</code></td>\n<td>Reports &quot;[line 1] Error: Unterminated string.&quot;</td>\n</tr>\n<tr>\n<td>2-3 (Parser)</td>\n<td><code>java Lox test.lox</code> with <code>var x = ;</code></td>\n<td>Reports &quot;[line 1] Error at &#39;;&#39;: Expect expression.&quot;</td>\n</tr>\n<tr>\n<td>4 (Interpreter)</td>\n<td><code>java Lox test.lox</code> with <code>print &quot;hello&quot; - 1;</code></td>\n<td>Reports &quot;RuntimeError: Operands must be numbers. [line 1]&quot;</td>\n</tr>\n<tr>\n<td>5-10 (All)</td>\n<td><code>java Lox test.lox</code> with multiple errors</td>\n<td>Reports all syntax errors, stops at first runtime error</td>\n</tr>\n</tbody></table>\n<p><strong>Debugging Tips Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NullPointerException</code> in string concatenation</td>\n<td>Using Java <code>null</code> for Lox <code>nil</code></td>\n<td>Check if operand is raw <code>null</code> instead of <code>LoxNil</code></td>\n<td>Use <code>LoxNil.INSTANCE</code> sentinel</td>\n</tr>\n<tr>\n<td>Parser goes into infinite loop on syntax error</td>\n<td>Missing panic-mode recovery</td>\n<td>Add print statements in <code>synchronize()</code></td>\n<td>Implement proper statement boundary synchronization</td>\n</tr>\n<tr>\n<td>Error reported at wrong line number</td>\n<td>Scanner not tracking lines correctly</td>\n<td>Test with multi-line string literals</td>\n<td>Update line counter when encountering <code>\\n</code></td>\n</tr>\n<tr>\n<td>Division by zero doesn&#39;t throw error</td>\n<td>Not checking divisor before operation</td>\n<td>Add debug print before division</td>\n<td>Explicitly check if divisor equals 0.0</td>\n</tr>\n<tr>\n<td><code>&quot;hello&quot; + 123</code> works but <code>123 + &quot;hello&quot;</code> doesn&#39;t</td>\n<td>Only checking left operand type in <code>+</code></td>\n<td>Test both operand orders</td>\n<td>Check if EITHER operand is string</td>\n</tr>\n<tr>\n<td>Closures see wrong variable values</td>\n<td>Capturing environment by reference vs value</td>\n<td>Print environment IDs during execution</td>\n<td>Ensure closures capture environment reference, not copy</td>\n</tr>\n</tbody></table>\n<h2 id=\"8-testing-strategy\">8. Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (Milestones 1-10) — Testing is a cross-cutting concern that evolves alongside the interpreter, from isolated component validation to integrated system verification.</p>\n</blockquote>\n<p>A robust testing strategy is essential for building a correct and reliable interpreter. The tree-walking interpreter&#39;s architecture naturally lends itself to <strong>component-wise testing</strong>—each major phase (scanning, parsing, interpretation) can be tested in isolation before integration. This section outlines a pragmatic testing methodology aligned with the project milestones, providing concrete verification checkpoints to ensure each component works correctly before proceeding to the next.</p>\n<h3 id=\"mental-model-the-construction-inspector\">Mental Model: The Construction Inspector</h3>\n<p>Think of testing as a <strong>construction inspector</strong> who examines each stage of a building project. First, they check the raw materials (tokens), then the structural framework (AST), then the plumbing and electrical systems (expressions and statements), and finally the complete building with all its features (functions, classes). At each milestone, the inspector has a specific checklist of what should work. This incremental verification prevents foundational defects from propagating upward, where they become exponentially harder to debug.</p>\n<h3 id=\"unit-and-integration-testing\">Unit and Integration Testing</h3>\n<p>The interpreter&#39;s pipeline architecture suggests a natural testing hierarchy: <strong>unit tests</strong> for individual components, <strong>integration tests</strong> for component boundaries, and <strong>end-to-end tests</strong> for complete programs. This layered approach mirrors the development progression through milestones.</p>\n<p><strong>Component Isolation Strategy:</strong>\nEach major component (Scanner, Parser, Interpreter) should be testable in isolation with minimal dependencies:</p>\n<ul>\n<li>The <strong>Scanner</strong> can be tested by providing source strings and verifying the output token sequence.</li>\n<li>The <strong>Parser</strong> can be tested by feeding it pre-generated tokens and checking the resulting AST structure.</li>\n<li>The <strong>Interpreter</strong> can be tested by constructing AST nodes directly and verifying evaluation results.</li>\n</ul>\n<p><strong>Test Infrastructure Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Level</th>\n<th>Purpose</th>\n<th>Input</th>\n<th>Verification Method</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Scanner Unit Tests</strong></td>\n<td>Verify tokenization rules</td>\n<td>Source code string</td>\n<td>Compare actual token list with expected token types, lexemes, literals, and line numbers</td>\n<td><code>&quot;var x = 42;&quot;</code> → <code>[VAR, IDENTIFIER(&quot;x&quot;), EQUAL, NUMBER(42), SEMICOLON]</code></td>\n</tr>\n<tr>\n<td><strong>Parser Unit Tests</strong></td>\n<td>Verify AST construction</td>\n<td>Token list</td>\n<td>Compare generated AST structure with expected AST (using pretty-printing or visitor)</td>\n<td><code>[NUMBER(1), PLUS, NUMBER(2)]</code> → <code>Binary(Literal(1), PLUS, Literal(2))</code></td>\n</tr>\n<tr>\n<td><strong>Interpreter Unit Tests</strong></td>\n<td>Verify expression evaluation</td>\n<td>AST nodes</td>\n<td>Compare evaluation result with expected runtime value</td>\n<td><code>Binary(Literal(1), PLUS, Literal(2))</code> → <code>3</code></td>\n</tr>\n<tr>\n<td><strong>Integration Tests</strong></td>\n<td>Verify component handoffs</td>\n<td>Source code string</td>\n<td>Compare program output with expected output (printed results)</td>\n<td><code>&quot;print 1 + 2;&quot;</code> → Console shows <code>&quot;3&quot;</code></td>\n</tr>\n<tr>\n<td><strong>End-to-End Tests</strong></td>\n<td>Verify complete language features</td>\n<td>Complete Lox programs</td>\n<td>Compare actual vs. expected output and runtime behavior</td>\n<td>Test files with <code>print</code> statements and expected output</td>\n</tr>\n</tbody></table>\n<p><strong>Testing Visitor Pattern Implementations:</strong>\nThe Visitor pattern presents a unique testing challenge because operations are distributed across many <code>visitXxx</code> methods. Two effective strategies are:</p>\n<ol>\n<li><p><strong>Pretty Printer Tests:</strong> Implement a <code>PrettyPrinter</code> visitor that converts AST nodes back to a canonical string representation (like S-expressions). This provides a language-independent way to verify parser output without requiring a working interpreter.</p>\n</li>\n<li><p><strong>Evaluation Assertion Tests:</strong> For the interpreter itself, write tests that construct AST nodes programmatically, evaluate them, and assert on the resulting runtime values.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight:</strong> Testing the parser with a pretty printer creates a <strong>self-verifying loop</strong>: source code → tokens → AST → pretty-printed string → compare with expected formatted output. This isolates parser correctness from interpreter implementation details.</p>\n</blockquote>\n<p><strong>Integration Testing Strategy:</strong>\nAs components become ready, write tests that exercise the full pipeline:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">plaintext</span><pre class=\"arch-pre shiki-highlighted\"><code>Source Code → Scanner → Parser → Interpreter → Output</code></pre></div>\n\n<p>These tests should verify not just successful execution but also proper error propagation (lexical errors from scanner, syntax errors from parser, runtime errors from interpreter).</p>\n<h3 id=\"milestone-checkpoints-verification-guide\">Milestone Checkpoints (Verification Guide)</h3>\n<p>The following table provides concrete verification steps for each milestone. These checkpoints serve as <strong>progress indicators</strong>—if you can successfully run these tests, your implementation is likely correct for that milestone&#39;s requirements.</p>\n<p><strong>Milestone Verification Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Milestone</th>\n<th>Test Focus</th>\n<th>Sample Test Command (Conceptual)</th>\n<th>Expected Output/Behavior</th>\n<th>What It Verifies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>1. Scanner</strong></td>\n<td>Tokenization</td>\n<td>Provide <code>&quot;var x = 42;&quot;</code> to Scanner</td>\n<td>Token sequence: <code>VAR, IDENTIFIER(&quot;x&quot;), EQUAL, NUMBER(42), SEMICOLON</code></td>\n<td>Keywords, identifiers, numbers, operators, line tracking</td>\n</tr>\n<tr>\n<td></td>\n<td>String literals</td>\n<td><code>&quot;\\&quot;hello\\&quot;&quot;</code></td>\n<td><code>STRING(&quot;hello&quot;)</code> with correct literal value</td>\n<td>String scanning with quotes, escape sequence handling</td>\n</tr>\n<tr>\n<td></td>\n<td>Error reporting</td>\n<td><code>&quot;@\\nvar&quot;</code></td>\n<td>Scanner reports error at line 1: &quot;Unexpected character &#39;@&#39;&quot;</td>\n<td>Lexical error detection with line numbers</td>\n</tr>\n<tr>\n<td><strong>2. AST &amp; 3. Parser</strong></td>\n<td>Expression parsing</td>\n<td>Parse <code>&quot;1 + 2 * 3&quot;</code></td>\n<td>AST: <code>Binary(Literal(1), PLUS, Binary(Literal(2), STAR, Literal(3)))</code></td>\n<td>Operator precedence (* before +)</td>\n</tr>\n<tr>\n<td></td>\n<td>Parentheses</td>\n<td>Parse <code>&quot;(1 + 2) * 3&quot;</code></td>\n<td>AST: <code>Binary(Binary(Literal(1), PLUS, Literal(2)), STAR, Literal(3))</code></td>\n<td>Grouping overrides precedence</td>\n</tr>\n<tr>\n<td></td>\n<td>Error recovery</td>\n<td>Parse <code>&quot;1 + ; print 2;&quot;</code></td>\n<td>Reports syntax error at <code>;</code> but continues to parse <code>print 2;</code></td>\n<td>Panic-mode recovery to next statement</td>\n</tr>\n<tr>\n<td><strong>4. Evaluating Expressions</strong></td>\n<td>Arithmetic</td>\n<td>Evaluate <code>&quot;1 + 2 * 3&quot;</code></td>\n<td>Result: <code>7</code> (number)</td>\n<td>Binary operator evaluation with precedence</td>\n</tr>\n<tr>\n<td></td>\n<td>Type errors</td>\n<td>Evaluate <code>&quot;\\&quot;hello\\&quot; - 1&quot;</code></td>\n<td>Runtime error: &quot;Operands must be numbers.&quot;</td>\n<td>Runtime type checking</td>\n</tr>\n<tr>\n<td></td>\n<td>Truthiness</td>\n<td>Evaluate <code>&quot;!false&quot;</code></td>\n<td>Result: <code>true</code></td>\n<td>Boolean logic and truthiness rules</td>\n</tr>\n<tr>\n<td><strong>5. Statements and State</strong></td>\n<td>Variables</td>\n<td>Execute <code>&quot;var x = 1; print x;&quot;</code></td>\n<td>Prints <code>&quot;1&quot;</code></td>\n<td>Variable declaration, initialization, and lookup</td>\n</tr>\n<tr>\n<td></td>\n<td>Assignment</td>\n<td>Execute <code>&quot;var x = 1; x = 2; print x;&quot;</code></td>\n<td>Prints <code>&quot;2&quot;</code></td>\n<td>Variable reassignment</td>\n</tr>\n<tr>\n<td></td>\n<td>Scoping</td>\n<td>Execute <code>&quot;{ var x = 1; } print x;&quot;</code></td>\n<td>Runtime error: &quot;Undefined variable &#39;x&#39;.&quot;</td>\n<td>Block scope isolation</td>\n</tr>\n<tr>\n<td><strong>6. Control Flow</strong></td>\n<td>If/else</td>\n<td>Execute <code>&quot;if (true) print \\&quot;yes\\&quot;; else print \\&quot;no\\&quot;;&quot;</code></td>\n<td>Prints <code>&quot;yes&quot;</code></td>\n<td>Conditional branching</td>\n</tr>\n<tr>\n<td></td>\n<td>While loop</td>\n<td>Execute <code>&quot;var i = 0; while (i &lt; 3) { print i; i = i + 1; }&quot;</code></td>\n<td>Prints <code>0</code>, <code>1</code>, <code>2</code></td>\n<td>Loop execution with condition</td>\n</tr>\n<tr>\n<td></td>\n<td>Short-circuit</td>\n<td>Execute <code>&quot;false and print \\&quot;skipped\\&quot;;&quot;</code></td>\n<td>Nothing printed (no error)</td>\n<td>Short-circuit evaluation of <code>and</code></td>\n</tr>\n<tr>\n<td><strong>7. Functions</strong></td>\n<td>Function call</td>\n<td>Execute <code>&quot;fun sayHi() { print \\&quot;Hi!\\&quot;; } sayHi();&quot;</code></td>\n<td>Prints <code>&quot;Hi!&quot;</code></td>\n<td>Function declaration and invocation</td>\n</tr>\n<tr>\n<td></td>\n<td>Parameters</td>\n<td>Execute <code>&quot;fun add(a, b) { return a + b; } print add(1, 2);&quot;</code></td>\n<td>Prints <code>&quot;3&quot;</code></td>\n<td>Parameter binding and return values</td>\n</tr>\n<tr>\n<td></td>\n<td>Recursion</td>\n<td>Execute <code>&quot;fun fib(n) { if (n &lt;= 1) return n; return fib(n-1) + fib(n-2); } print fib(5);&quot;</code></td>\n<td>Prints <code>&quot;5&quot;</code></td>\n<td>Recursive function calls with proper environments</td>\n</tr>\n<tr>\n<td><strong>8. Closures</strong></td>\n<td>Closure capture</td>\n<td>Execute <code>&quot;fun makeCounter() { var i = 0; fun count() { i = i + 1; return i; } return count; } var counter = makeCounter(); print counter(); print counter();&quot;</code></td>\n<td>Prints <code>1</code>, then <code>2</code></td>\n<td>Functions capture enclosing environment</td>\n</tr>\n<tr>\n<td></td>\n<td>Multiple closures</td>\n<td>Execute closure test with two independent counters</td>\n<td>Each counter maintains separate state</td>\n<td>Each closure captures its own environment reference</td>\n</tr>\n<tr>\n<td><strong>9. Classes</strong></td>\n<td>Instance creation</td>\n<td>Execute <code>&quot;class Point {} var p = Point(); print p;&quot;</code></td>\n<td>Prints instance representation (e.g., <code>&quot;Point instance&quot;</code>)</td>\n<td>Class as constructor, instance creation</td>\n</tr>\n<tr>\n<td></td>\n<td>Fields and methods</td>\n<td>Execute class with <code>init</code> and method</td>\n<td>Instance fields initialized, methods bound with <code>this</code></td>\n<td>Property access, method binding, initializer</td>\n</tr>\n<tr>\n<td><strong>10. Inheritance</strong></td>\n<td>Method inheritance</td>\n<td>Execute subclass that inherits method from superclass</td>\n<td>Subclass instance can call inherited method</td>\n<td>Single inheritance, method resolution</td>\n</tr>\n<tr>\n<td></td>\n<td>Super calls</td>\n<td>Execute subclass method that calls <code>super.method()</code></td>\n<td>Superclass version of method executes</td>\n<td><code>super</code> keyword resolution and invocation</td>\n</tr>\n</tbody></table>\n<p><strong>Verification Procedure:</strong>\nFor each milestone, follow this step-by-step verification process:</p>\n<ol>\n<li><strong>Isolated Component Tests:</strong> First, test the new component in isolation using unit tests.</li>\n<li><strong>Integration with Previous Components:</strong> Test the new component integrated with all previously implemented components.</li>\n<li><strong>Edge Case Validation:</strong> Test boundary conditions and error cases specific to the milestone.</li>\n<li><strong>Regression Testing:</strong> Ensure existing functionality from previous milestones still works correctly.</li>\n</ol>\n<blockquote>\n<p><strong>Key Principle:</strong> <strong>Test incrementally and verify often.</strong> Don&#39;t wait until the entire interpreter is built to test it. Each milestone&#39;s acceptance criteria provide specific behaviors to test.</p>\n</blockquote>\n<h3 id=\"common-pitfalls-in-testing\">Common Pitfalls in Testing</h3>\n<p>⚠️ <strong>Pitfall: Testing Only Happy Paths</strong></p>\n<ul>\n<li><strong>Description:</strong> Writing tests that only verify correct programs execute successfully, neglecting error cases and edge conditions.</li>\n<li><strong>Why It&#39;s Wrong:</strong> An interpreter must handle malformed programs gracefully with clear error messages. Missing error tests leaves critical functionality unverified.</li>\n<li><strong>Fix:</strong> For each feature, write tests for: (1) valid usage, (2) type errors, (3) undefined variables, (4) syntax errors, (5) boundary conditions (empty strings, zero, nil).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Over-Reliance on End-to-End Tests</strong></p>\n<ul>\n<li><strong>Description:</strong> Testing everything through complete program execution, making it difficult to pinpoint which component has a bug.</li>\n<li><strong>Why It&#39;s Wrong:</strong> When a test fails, you must debug the entire pipeline rather than an isolated component.</li>\n<li><strong>Fix:</strong> Maintain a balanced test pyramid: many unit tests, fewer integration tests, minimal end-to-end tests. Use unit tests to verify component logic in isolation.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Hard-Coding Test Values</strong></p>\n<ul>\n<li><strong>Description:</strong> Writing tests that depend on specific string representations (e.g., <code>&quot;LoxFunction@4f023edb&quot;</code>) that vary across runs.</li>\n<li><strong>Why It&#39;s Wrong:</strong> Such tests are fragile and may fail due to unrelated changes like JVM memory address variations.</li>\n<li><strong>Fix:</strong> Test semantic behavior, not string representations. For functions and classes, test that they can be called, not how they convert to strings.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Neglecting Line Number Tracking</strong></p>\n<ul>\n<li><strong>Description:</strong> Forgetting to test that error messages include accurate line and column numbers.</li>\n<li><strong>Why It&#39;s Wrong:</strong> Without accurate location information, debugging user programs becomes difficult.</li>\n<li><strong>Fix:</strong> In error test cases, explicitly verify that reported line numbers match the source location.</li>\n</ul>\n<h3 id=\"architecture-decision-record-test-first-vs-test-after-development\">Architecture Decision Record: Test-First vs. Test-After Development</h3>\n<blockquote>\n<p><strong>Decision: Test-After Development with Milestone Checkpoints</strong></p>\n</blockquote>\n<p><strong>Context:</strong>\nWe need a testing strategy suitable for learners building an interpreter incrementally. The interpreter has clear component boundaries and well-defined milestones, each adding specific functionality.</p>\n<p><strong>Options Considered:</strong></p>\n<ol>\n<li><strong>Test-Driven Development (TDD):</strong> Write tests before implementing each feature.</li>\n<li><strong>Test-After with Milestone Verification:</strong> Implement functionality first, then write tests to verify the milestone&#39;s acceptance criteria.</li>\n<li><strong>Ad-hoc Manual Testing:</strong> Manually test features as implemented without systematic test suites.</li>\n</ol>\n<p><strong>Decision:</strong>\nWe adopt <strong>Test-After with Milestone Verification</strong>. After completing each milestone&#39;s implementation, learners write comprehensive tests to verify all acceptance criteria.</p>\n<p><strong>Rationale:</strong></p>\n<ul>\n<li><strong>Learning Focus:</strong> For educational purposes, understanding how to implement features precedes learning test-driven methodologies.</li>\n<li><strong>Clear Verification:</strong> Milestone checkpoints provide concrete, testable outcomes that learners can verify systematically.</li>\n<li><strong>Progressive Complexity:</strong> Early milestones (Scanner, Parser) benefit from unit testing; later milestones (Interpreter features) benefit from integration testing.</li>\n<li><strong>Practical Reality:</strong> Learners often need to see the implementation working before they understand what to test.</li>\n</ul>\n<p><strong>Consequences:</strong></p>\n<ul>\n<li><strong>Positive:</strong> Learners gain experience writing tests that verify specific behaviors. The milestone structure provides natural test boundaries.</li>\n<li><strong>Negative:</strong> Some implementation bugs might only be caught after implementation is complete. Requires discipline to write tests for all acceptance criteria.</li>\n<li><strong>Mitigation:</strong> The verification guide provides explicit test cases for each milestone, ensuring comprehensive coverage.</li>\n</ul>\n<p><strong>Comparison Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Suitability for Learning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Test-Driven Development</strong></td>\n<td>Ensures testable design, comprehensive test coverage from start</td>\n<td>Requires understanding of feature behavior before implementation, can feel artificial for learners</td>\n<td>Low: Adds cognitive load on top of implementation challenges</td>\n</tr>\n<tr>\n<td><strong>Test-After with Verification</strong></td>\n<td>Natural progression: implement then verify, milestone checkpoints guide testing</td>\n<td>May miss edge cases without upfront test design, requires retroactive test writing</td>\n<td>High: Matches how learners naturally build (implement then test)</td>\n</tr>\n<tr>\n<td><strong>Ad-hoc Manual Testing</strong></td>\n<td>Quick feedback, no test maintenance overhead</td>\n<td>Inconsistent coverage, difficult to regression test, errors may slip through</td>\n<td>Low: Doesn&#39;t teach systematic testing practices</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>While the main design avoids code, this implementation guidance provides practical testing infrastructure to verify each milestone.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Testing Framework</td>\n<td>JUnit 5 (standard Java testing)</td>\n<td>TestNG (more features)</td>\n</tr>\n<tr>\n<td>Assertion Library</td>\n<td>JUnit&#39;s built-in assertions</td>\n<td>AssertJ (fluent assertions)</td>\n</tr>\n<tr>\n<td>Test Organization</td>\n<td>One test class per component (ScannerTest, ParserTest, etc.)</td>\n<td>Nested test classes by feature</td>\n</tr>\n<tr>\n<td>Test Data Management</td>\n<td>Hard-coded strings in test methods</td>\n<td>External test files for programs</td>\n</tr>\n<tr>\n<td>Mocking</td>\n<td>Manual test doubles</td>\n<td>Mockito (for complex dependencies)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox-interpreter/\n  src/main/java/com/craftinginterpreters/lox/\n    Lox.java                    # Main entry point\n    Scanner.java                # Milestone 1\n    Token.java                  # Milestone 1\n    TokenType.java              # Milestone 1\n    parser/\n      Parser.java               # Milestone 3\n      ParseError.java           # Milestone 3\n    ast/\n      Expr.java                 # Milestone 2\n      Stmt.java                 # Milestone 2\n      AstPrinter.java           # Milestone 2 (for testing)\n    interpreter/\n      Interpreter.java          # Milestone 4+\n      Environment.java          # Milestone 5\n      RuntimeError.java         # Milestone 4\n      LoxFunction.java          # Milestone 7\n      LoxClass.java             # Milestone 9\n      LoxInstance.java          # Milestone 9\n  src/test/java/com/craftinginterpreters/lox/\n    ScannerTest.java            # Tests for Milestone 1\n    ParserTest.java             # Tests for Milestones 2-3\n    InterpreterTest.java        # Tests for Milestones 4-10\n    testdata/                   # Directory for test programs\n      hello.lox\n      arithmetic.lox\n      functions.lox\n      classes.lox</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-test-utilities\">C. Infrastructure Starter Code: Test Utilities</h4>\n<p>For comprehensive testing, implement these utility classes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TestUtilities.java - COMPLETE utility methods for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.ArrayList;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> TestUtilities</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper to create token list for parser tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Token</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">tokenList</span><span style=\"color:#E1E4E8\">(Token... </span><span style=\"color:#FFAB70\">tokens</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> ArrayList&#x3C;>(List.</span><span style=\"color:#B392F0\">of</span><span style=\"color:#E1E4E8\">(tokens));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper to create a NUMBER token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#E1E4E8\"> Token </span><span style=\"color:#B392F0\">numberToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">double</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType.NUMBER, String.</span><span style=\"color:#B392F0\">valueOf</span><span style=\"color:#E1E4E8\">(value), value, line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper to create a STRING token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#E1E4E8\"> Token </span><span style=\"color:#B392F0\">stringToken</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType.STRING, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, value, line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper to create an IDENTIFIER token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#E1E4E8\"> Token </span><span style=\"color:#B392F0\">identifierToken</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(TokenType.IDENTIFIER, name, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper to compare two values with tolerance for floating point</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> valuesEqual</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">, Object </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Double </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Double) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> Math.</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">((Double)a </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (Double)b) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.000001</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> a.</span><span style=\"color:#B392F0\">equals</span><span style=\"color:#E1E4E8\">(b);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-test-skeleton-code\">D. Core Test Skeleton Code</h4>\n<p><strong>Scanner Test Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ScannerTest.java - TODOs for core scanner tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> org.junit.jupiter.api.Test;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> static</span><span style=\"color:#E1E4E8\"> org.junit.jupiter.api.Assertions.</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ScannerTest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testScanSingleTokens</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create scanner with source: \"(){},.-+;/*\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Call scanTokens()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify token types: LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //         RIGHT_BRACE, COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify no errors reported</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testScanKeywords</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create scanner with source: \"var fun class if else while for return\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Call scanTokens()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify token types: VAR, FUN, CLASS, IF, ELSE, WHILE, FOR, RETURN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify lexemes match keywords exactly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testScanNumbers</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create scanner with source: \"123 45.67 .5\" (note: .5 is invalid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Call scanTokens()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify NUMBER tokens with correct literal values (123, 45.67)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify error reported for \".5\" (or tokenized as DOT then 5)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testScanStrings</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create scanner with source: \"\\\"hello\\\" \\\"world\\\\n\\\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Call scanTokens()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify STRING tokens with values \"hello\" and \"world\\n\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify line counting within strings (escaped newline doesn't increment)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testScanErrors</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create scanner with source: \"@ # $\\nvar\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Call scanTokens()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify errors reported for '@', '#', '$' at line 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify VAR token still scanned after errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Parser Test Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ParserTest.java - TODOs for core parser tests  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> org.junit.jupiter.api.Test;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> static</span><span style=\"color:#E1E4E8\"> org.junit.jupiter.api.Assertions.</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParserTest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testParseArithmetic</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create tokens: 1 + 2 * 3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create parser with tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Call parse() to get statements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Use AstPrinter to convert AST to string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Verify string matches expected: \"(+ 1 (* 2 3))\" or similar</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testParseParentheses</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create tokens: (1 + 2) * 3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Parse and get AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify structure: (* (+ 1 2) 3)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testParseComparison</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create tokens: 1 &#x3C; 2 == true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Parse and get AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify structure: (== (&#x3C; 1 2) true) with correct precedence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testParseErrorRecovery</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create tokens with error: 1 + ; print 2;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Parse - should report error at SEMICOLON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify parser continues and produces AST for \"print 2;\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Interpreter Test Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// InterpreterTest.java - TODOs for core interpreter tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> org.junit.jupiter.api.Test;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.ByteArrayOutputStream;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.io.PrintStream;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> static</span><span style=\"color:#E1E4E8\"> org.junit.jupiter.api.Assertions.</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InterpreterTest</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testEvaluateArithmetic</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create AST: Binary(Literal(1.0), PLUS, Literal(2.0))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create interpreter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Call evaluate() on AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify result equals 3.0 (with floating tolerance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testRuntimeTypeError</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create AST: Binary(Literal(\"hello\"), MINUS, Literal(1))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create interpreter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Call evaluate() - should throw RuntimeError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify error message: \"Operands must be numbers.\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testVariableScope</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create AST for: { var x = 1; print x; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create interpreter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Call interpret() with statements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Capture output, verify prints \"1\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Test nested scope: { var x = 1; { var x = 2; } print x; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testFunctionCall</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create AST for function declaration and call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Interpret statements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify function is callable and returns correct value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Test recursion with factorial function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> testClassInheritance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create AST for class hierarchy: class A { method() { return 1; } } class B &#x3C; A {}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Interpret statements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Create instance of B, call method()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify returns 1 (inherited method)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-java\">E. Language-Specific Hints (Java)</h4>\n<ol>\n<li><strong>Capturing Console Output:</strong> Use <code>ByteArrayOutputStream</code> and <code>PrintStream</code> to capture <code>System.out</code> for testing print statements:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   ByteArrayOutputStream output </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> ByteArrayOutputStream</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   System.</span><span style=\"color:#B392F0\">setOut</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> PrintStream</span><span style=\"color:#E1E4E8\">(output));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   // Run interpreter</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   assertEquals</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"3</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, output.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">());</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Testing Exceptions:</strong> Use JUnit&#39;s <code>assertThrows</code> to verify errors:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   RuntimeError error </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> assertThrows</span><span style=\"color:#E1E4E8\">(RuntimeError.class, () </span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\"> interpreter.</span><span style=\"color:#B392F0\">evaluate</span><span style=\"color:#E1E4E8\">(ast));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   assertTrue</span><span style=\"color:#E1E4E8\">(error.</span><span style=\"color:#B392F0\">getMessage</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">contains</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Operands must be numbers\"</span><span style=\"color:#E1E4E8\">));</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Floating Point Comparisons:</strong> Use epsilon comparison for double values:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> final</span><span style=\"color:#F97583\"> double</span><span style=\"color:#E1E4E8\"> EPSILON </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.000001</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   assertTrue</span><span style=\"color:#E1E4E8\">(Math.</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">((Double)result </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> expected) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> EPSILON);</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Visitor Pattern Testing:</strong> When testing visitors, you can create anonymous visitor implementations for specific test cases rather than relying on the full interpreter.</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint-commands\">F. Milestone Checkpoint Commands</h4>\n<p>For each milestone, after implementing the feature, run these verification commands:</p>\n<p><strong>Milestone 1 (Scanner):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run scanner tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./gradlew</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> --tests</span><span style=\"color:#9ECBFF\"> \"*.ScannerTest\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests pass, with green output showing tokenization works</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># If tests fail, check error messages to see which tokens are incorrect</span></span></code></pre></div>\n\n<p><strong>Milestones 2-3 (Parser &amp; AST):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run parser tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./gradlew</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> --tests</span><span style=\"color:#9ECBFF\"> \"*.ParserTest\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manually test with a simple expression</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#79B8FF\"> -cp</span><span style=\"color:#9ECBFF\"> build/classes/java/main</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#F97583\"> &#x3C;&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"print (1 + 2) * 3;\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should parse successfully (may not evaluate yet)</span></span></code></pre></div>\n\n<p><strong>Milestone 4 (Evaluating Expressions):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run interpreter expression tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./gradlew</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> --tests</span><span style=\"color:#9ECBFF\"> \"*.InterpreterTest.testEvaluate*\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test manually</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#79B8FF\"> -cp</span><span style=\"color:#9ECBFF\"> build/classes/java/main</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#F97583\"> &#x3C;&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"print 1 + 2 * 3;\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: 7</span></span></code></pre></div>\n\n<p><strong>Milestone 5 (Statements and State):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test variable functionality</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#79B8FF\"> -cp</span><span style=\"color:#9ECBFF\"> build/classes/java/main</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#F97583\"> &#x3C;&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"var x = 1; x = x + 2; print x;\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: 3</span></span></code></pre></div>\n\n<p><strong>Milestone 6 (Control Flow):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test if and while</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#79B8FF\"> -cp</span><span style=\"color:#9ECBFF\"> build/classes/java/main</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#F97583\"> &#x3C;&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">var i = 0;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">while (i &#x3C; 3) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  if (i % 2 == 0) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    print </span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">even: </span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\"> + i;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  i = i + 1;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: even: 0, even: 2</span></span></code></pre></div>\n\n<p><strong>Milestone 7 (Functions):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test function declaration and call</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#79B8FF\"> -cp</span><span style=\"color:#9ECBFF\"> build/classes/java/main</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#F97583\"> &#x3C;&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">fun factorial(n) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  if (n &#x3C;= 1) return 1;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  return n * factorial(n - 1);</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print factorial(5);\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: 120</span></span></code></pre></div>\n\n<p><strong>Milestone 8 (Closures):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test closure capture</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#79B8FF\"> -cp</span><span style=\"color:#9ECBFF\"> build/classes/java/main</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#F97583\"> &#x3C;&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">fun makeCounter() {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  var i = 0;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  fun count() {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    i = i + 1;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    return i;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  return count;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">var c = makeCounter();</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print c();</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print c();\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: 1, then 2</span></span></code></pre></div>\n\n<p><strong>Milestone 9 (Classes):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test class instantiation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#79B8FF\"> -cp</span><span style=\"color:#9ECBFF\"> build/classes/java/main</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#F97583\"> &#x3C;&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">class Point {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  init(x, y) {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    this.x = x;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    this.y = y;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">var p = Point(1, 2);</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print p.x;\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: 1</span></span></code></pre></div>\n\n<p><strong>Milestone 10 (Inheritance):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test inheritance chain</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">java</span><span style=\"color:#79B8FF\"> -cp</span><span style=\"color:#9ECBFF\"> build/classes/java/main</span><span style=\"color:#9ECBFF\"> com.craftinginterpreters.lox.Lox</span><span style=\"color:#F97583\"> &#x3C;&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">class A {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  method() { return </span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">A</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">; }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">class B &#x3C; A {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  method() { return super.method() + </span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">B</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">; }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">var b = B();</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print b.method();\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: AB</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips-for-test-failures\">G. Debugging Tips for Test Failures</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Scanner tests fail on multi-character operators</strong></td>\n<td>Not advancing <code>current</code> past both characters</td>\n<td>Add debug prints showing which characters are being examined</td>\n<td>Ensure <code>match()</code> advances position when successful</td>\n</tr>\n<tr>\n<td><strong>Parser goes into infinite loop</strong></td>\n<td>Left-recursive grammar rule</td>\n<td>Check that parsing methods always consume at least one token before recursing</td>\n<td>Rewrite grammar to eliminate left recursion or add progress check</td>\n</tr>\n<tr>\n<td><strong>AST structure incorrect</strong></td>\n<td>Wrong precedence or associativity</td>\n<td>Use AstPrinter to visualize AST, compare with expected</td>\n<td>Verify parsing method order matches precedence table</td>\n</tr>\n<tr>\n<td><strong>Variable lookup finds wrong value</strong></td>\n<td>Environment chain traversal incorrect</td>\n<td>Print environment chain during lookup, check parent links</td>\n<td>Ensure <code>enclosing</code> field set correctly when creating nested environments</td>\n</tr>\n<tr>\n<td><strong>Closure captures wrong environment</strong></td>\n<td>Capturing call environment instead of definition environment</td>\n<td>Check which environment is stored in LoxFunction</td>\n<td>Capture defining environment when function is created, not when called</td>\n</tr>\n<tr>\n<td><strong>Method call returns nil unexpectedly</strong></td>\n<td>Return statement not propagating value</td>\n<td>Add debug to trace return exception throwing/catching</td>\n<td>Ensure <code>visitReturnStmt</code> throws exception caught in <code>call()</code> method</td>\n</tr>\n<tr>\n<td><strong>Super calls wrong method</strong></td>\n<td>Incorrect method resolution order</td>\n<td>Print class hierarchy during super lookup</td>\n<td>Walk from current class&#39;s superclass, not instance&#39;s class</td>\n</tr>\n</tbody></table>\n<p><strong>Effective Debugging Techniques:</strong></p>\n<ol>\n<li><strong>Add AST Visualization:</strong> Implement a <code>toString()</code> method for each AST node or use the AstPrinter to see the actual structure.</li>\n<li><strong>Environment Dumper:</strong> Add a method to print all variables in an environment chain.</li>\n<li><strong>Execution Tracing:</strong> Add flags to log each evaluation step: <code>TRACE=true</code> environment that prints every visit method call.</li>\n<li><strong>Unit Test Isolation:</strong> When a test fails, create a minimal reproducing test case to isolate the issue.</li>\n<li><strong>Use a Debugger:</strong> Set breakpoints in key methods like <code>visitBinaryExpr</code>, <code>Environment.get</code>, <code>LoxFunction.call</code>.</li>\n</ol>\n<blockquote>\n<p><strong>Testing Philosophy:</strong> The goal of testing in this educational project is not just to verify correctness, but to <strong>build understanding</strong>. Each test you write forces you to think through edge cases and semantics, deepening your comprehension of the language you&#39;re implementing.</p>\n</blockquote>\n<h2 id=\"9-debugging-guide\">9. Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (Milestones 1-10) — Debugging is an integral skill for any software project, but for an interpreter, it involves reasoning across multiple layers of abstraction. This guide provides a structured reference for diagnosing and fixing common issues that arise during implementation, categorized by observable symptoms. It also suggests practical techniques to illuminate the interpreter&#39;s internal state.</p>\n</blockquote>\n<p>Interpreting a programming language involves a complex dance between static structures (tokens, AST) and dynamic behavior (environments, function calls). When a bug surfaces, it can be challenging to pinpoint which layer is at fault. This debugging guide is designed to help you develop a systematic approach: start from the observable symptom (e.g., a crash, incorrect output, or infinite loop), trace it back through the data flow, and identify the faulty component or logic.</p>\n<p>The guide is structured as a two-part toolkit. First, a comprehensive table maps specific symptoms to their likely root causes and provides targeted fixes. Second, it recommends proactive debugging techniques—like adding visualization tools to your interpreter—that can turn a opaque execution into a transparent, step-by-step narrative.</p>\n<h3 id=\"symptom-cause-fix-table\">Symptom → Cause → Fix Table</h3>\n<p>This table catalogs common issues you may encounter while building your Lox interpreter. For each symptom, we describe the typical manifestation, the underlying cause in the design or implementation, and a concrete fix to apply.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom (What you observe)</th>\n<th align=\"left\">Likely Cause (Where the bug lives)</th>\n<th align=\"left\">Steps to Diagnose</th>\n<th align=\"left\">Recommended Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Parser goes into an infinite loop or stack overflows on a simple expression like <code>1 + 2</code>.</strong></td>\n<td align=\"left\"><strong>Left-recursive grammar rule.</strong> In your parsing method for a precedence level (e.g., <code>expression()</code>), you might be unconditionally calling itself first, creating infinite recursion. For example, <code>expression() -&gt; equality() -&gt; comparison() -&gt; term() -&gt; factor() -&gt; unary() -&gt; primary() -&gt; expression()</code> forms a cycle.</td>\n<td align=\"left\">Add print statements at the start of each parsing method (<code>expression()</code>, <code>equality()</code>, etc.) to see the call sequence. You&#39;ll see the same method called repeatedly without consuming tokens.</td>\n<td align=\"left\">Ensure your parsing functions follow the pattern: parse a lower-precedence operator, then loop to parse higher-precedence operators. For example, <code>expression()</code> should call <code>equality()</code>, then loop while seeing <code>OR</code> tokens. The base of the recursion must be <code>primary()</code>, which consumes a literal or parenthesized expression without recursively calling the top-level <code>expression()</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>&quot;Unterminated string&quot;</code> error is reported for a perfectly valid string like <code>&quot;hello&quot;</code>.</strong></td>\n<td align=\"left\"><strong>Incorrect handling of the closing quote.</strong> The scanner&#39;s string literal logic advances until it finds a <code>&quot;</code> but doesn&#39;t check for the end of the source file (<code>isAtEnd()</code>). If the string is the last token in the file, it may run past the end and report an error.</td>\n<td align=\"left\">Check the scanner&#39;s <code>string()</code> method. Does it break only when it sees <code>&quot;</code>? What happens when <code>isAtEnd()</code> becomes true first?</td>\n<td align=\"left\">In the <code>while</code> loop that scans string characters, add a check for <code>isAtEnd()</code>. If reached, report an error: &quot;Unterminated string.&quot; and break. Ensure the loop condition is <code>while (!isAtEnd() &amp;&amp; peek() != &#39;&quot;&#39;)</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Variable lookup finds the wrong value or says <code>&quot;Undefined variable&quot;</code> for a variable that should be in scope.</strong></td>\n<td align=\"left\"><strong>Incorrect environment chain traversal.</strong> The <code>Environment.get()</code> method searches only the immediate scope, not the parent chain. Or, <code>Environment.assign()</code> updates the wrong scope, modifying a parent&#39;s binding when it should shadow.</td>\n<td align=\"left\">Print the environment chain during lookup. For a variable <code>x</code>, dump each environment&#39;s <code>values</code> map along the <code>enclosing</code> links. See if the binding exists in a different scope than expected.</td>\n<td align=\"left\">Ensure <code>Environment.get(Token name)</code> recursively checks the current scope, then <code>enclosing</code> (if not <code>null</code>). <code>Environment.assign(Token name, Object value)</code> must follow the same search path and update the <em>first</em> environment where the variable is found (or error if none).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>print 1 + &quot;string&quot;;</code> crashes or produces gibberish instead of a runtime error.</strong></td>\n<td align=\"left\"><strong>Missing runtime type checking.</strong> The <code>visitBinaryExpr</code> method for the <code>PLUS</code> operator directly performs arithmetic or concatenation without verifying the operands&#39; types.</td>\n<td align=\"left\">Check the code handling the <code>PLUS</code> token. Is there a call to <code>checkNumberOperands()</code> or similar validation? Does it handle the string concatenation case separately?</td>\n<td align=\"left\">Implement <code>checkNumberOperands()</code> and call it for arithmetic operators (<code>MINUS</code>, <code>SLASH</code>, <code>STAR</code>). For <code>PLUS</code>, explicitly check: if both operands are numbers, add; if both are strings, concatenate; else, throw a <code>RuntimeError</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Logical operator <code>and</code> does not short-circuit; it always evaluates both sides.</strong></td>\n<td align=\"left\"><strong>Eager evaluation of operands.</strong> In <code>visitLogicalExpr</code>, you likely evaluate <code>left</code> and <code>right</code> unconditionally before checking the operator.</td>\n<td align=\"left\">Add a print statement before evaluating each operand. You&#39;ll see both prints even when the left operand of an <code>and</code> is false.</td>\n<td align=\"left\">Evaluate the left operand first. For <code>AND</code>: if the left is falsy, return it immediately. For <code>OR</code>: if the left is truthy, return it immediately. Only evaluate the right operand if needed.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Function calls work once but incorrectly share local variables between subsequent calls.</strong></td>\n<td align=\"left\"><strong>Reusing the same environment for each call.</strong> The <code>LoxFunction.call()</code> method might be using a single environment instance for the function&#39;s local scope, rather than creating a new one per invocation.</td>\n<td align=\"left\">Print the environment&#39;s identity (e.g., <code>System.identityHashCode(environment)</code>) inside the function body for two calls. If it&#39;s the same, variables are being shared.</td>\n<td align=\"left\">In <code>LoxFunction.call()</code>, create a <em>new</em> <code>Environment</code> for each call, setting the closure (the function&#39;s <code>closure</code> field) as its parent. Bind parameters in this fresh environment.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Closure captures the <em>value</em> of an outer variable at definition time, not a <em>reference</em>; modifying the outer variable doesn&#39;t affect the closure.</strong></td>\n<td align=\"left\"><strong>Environment capture by copy, not by reference.</strong> The closure might be storing a <em>copy</em> of the defining environment&#39;s variable map, rather than a reference to the environment object itself.</td>\n<td align=\"left\">Check how the closure is created. Is it storing a new <code>Environment</code> object with the same mappings, or is it storing a reference to the existing environment?</td>\n<td align=\"left\">Ensure the <code>LoxFunction</code> stores a reference to the <em>defining</em> <code>Environment</code> object (the one active when the function was declared). Do not copy its <code>values</code> map.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>this</code> inside a method refers to the class, not the instance, or throws &quot;Undefined variable &#39;this&#39;.&quot;</strong></td>\n<td align=\"left\"><strong>Missing <code>this</code> binding in the method&#39;s environment.</strong> When a method is called, the interpreter must bind <code>this</code> in the method&#39;s local environment to the instance on which the method was invoked.</td>\n<td align=\"left\">In <code>visitCallExpr</code>, check how you prepare the environment for a method call. Is <code>this</code> defined? For a <code>LoxFunction</code> that represents a method, does its <code>call()</code> method bind <code>this</code>?</td>\n<td align=\"left\">In <code>LoxFunction.bind(LoxInstance instance)</code>, create a new environment with the closure as parent, define <code>&quot;this&quot;</code> as the instance, and return a new <code>LoxFunction</code> that uses this environment. In <code>visitGetExpr</code>, if the property is a method, call <code>bind(instance)</code> on it.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>super.method()</code> calls the subclass&#39;s overridden method, not the superclass version.</strong></td>\n<td align=\"left\"><strong>Incorrect resolution of <code>super</code>.</strong> The <code>visitSuperExpr</code> might be looking up the method starting from the instance&#39;s class, which would find the overridden method first.</td>\n<td align=\"left\">Print the class hierarchy in <code>visitSuperExpr</code>. Are you correctly accessing the superclass from the current class? Is the method lookup starting from the superclass?</td>\n<td align=\"left\">In <code>visitSuperExpr</code>, resolve the superclass via the interpreter&#39;s <code>environment</code> (or a dedicated <code>super</code> environment). Then, call <code>findMethod</code> on the <em>superclass</em> object, not the current class.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Division by zero (e.g., <code>1 / 0</code>) crashes with an arithmetic exception instead of a Lox runtime error.</strong></td>\n<td align=\"left\"><strong>Native Java arithmetic exception is not caught.</strong> The interpreter uses Java&#39;s <code>/</code> operator, which throws <code>ArithmeticException</code> for integer division by zero.</td>\n<td align=\"left\">Check if the division operation in <code>visitBinaryExpr</code> is wrapped in a try-catch for Java&#39;s <code>ArithmeticException</code>.</td>\n<td align=\"left\">Before performing division, explicitly check if the right operand is zero (or within an epsilon for floating-point). If so, throw a Lox <code>RuntimeError</code>. Alternatively, catch Java&#39;s <code>ArithmeticException</code> and convert it.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>The parser reports &quot;Expect expression&quot; when encountering a valid expression after an error.</strong></td>\n<td align=\"left\"><strong>Poor error recovery leaves the parser in a bad state.</strong> After a parse error, the parser might not synchronize to a known boundary (like a semicolon), causing subsequent valid code to be misparsed.</td>\n<td align=\"left\">Introduce a syntax error early in a multi-statement program. Observe if later statements are parsed correctly.</td>\n<td align=\"left\">Implement panic-mode synchronization in <code>Parser</code>. In <code>synchronize()</code>, discard tokens until you reach a statement boundary (e.g., <code>SEMICOLON</code>, <code>CLASS</code>, <code>FUN</code>, <code>VAR</code>, <code>FOR</code>, <code>IF</code>, <code>WHILE</code>, <code>PRINT</code>, <code>RETURN</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>A loop <code>while (true) { }</code> hangs the interpreter indefinitely with no way to stop.</strong></td>\n<td align=\"left\"><strong>No timeout or interrupt mechanism.</strong> The tree-walking interpreter will obediently execute the loop forever, as there&#39;s no built-in limit.</td>\n<td align=\"left\">This is expected behavior for a correct infinite loop, but it can be problematic during testing.</td>\n<td align=\"left\">For development, consider adding an optional execution step limit or a timeout. Increment a counter in <code>visitWhileStmt</code> and throw a runtime error after a large number (e.g., 1,000,000) iterations.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>nil</code> appears in arithmetic operations without a runtime error (e.g., <code>nil + 1</code> yields something).</strong></td>\n<td align=\"left\"><strong>Missing null/nil checks in type validation.</strong> The <code>checkNumberOperand</code> or <code>checkNumberOperands</code> functions might only check for <code>Double</code> type, not rejecting <code>nil</code>.</td>\n<td align=\"left\">Test <code>nil + 1</code>. Does it throw? Check <code>isTruthy</code> and <code>isEqual</code> functions as well—they must handle <code>nil</code> explicitly.</td>\n<td align=\"left\">In <code>checkNumberOperand</code> and <code>checkNumberOperands</code>, explicitly verify the operand is an instance of <code>Double</code> (or <code>LoxNumber</code>). If it&#39;s <code>nil</code> or any other non-number, throw a <code>RuntimeError</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Multiline string literals are not allowed, or newlines inside strings are lost.</strong></td>\n<td align=\"left\"><strong>Scanner&#39;s string literal logic stops at newline characters.</strong> The scanner might treat <code>\\n</code> as a whitespace character to be skipped, rather than as part of the string.</td>\n<td align=\"left\">Check the <code>string()</code> method. Does it break when it sees <code>\\n</code>? Does it handle escape sequences like <code>\\n</code>?</td>\n<td align=\"left\">In the string scanning loop, allow newline characters (<code>peek() == &#39;\\n&#39;</code>) and increment the line counter. To support escape sequences, when you see a backslash, call a helper to translate the escape sequence (e.g., <code>\\n</code> to newline character).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>print</code> statement outputs <code>null</code> for <code>nil</code> instead of the word <code>&quot;nil&quot;</code>.</strong></td>\n<td align=\"left\"><strong>The <code>stringify()</code> method returns Java&#39;s <code>null</code> string representation.</strong> When the value is <code>LoxNil</code> or Java <code>null</code>, <code>String.valueOf(value)</code> returns <code>&quot;null&quot;</code>.</td>\n<td align=\"left\">Examine <code>Interpreter.stringify(Object object)</code>. How does it handle the <code>nil</code> value?</td>\n<td align=\"left\">Explicitly check for <code>nil</code> in <code>stringify()</code>. If the object is <code>nil</code> (or <code>instanceof LoxNil</code>), return the string <code>&quot;nil&quot;</code>. For booleans, return <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code> instead of <code>&quot;true&quot;</code>/<code>&quot;false&quot;</code> as Java strings.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Class inheritance creates a cycle (class A &lt; B and class B &lt; A) and crashes.</strong></td>\n<td align=\"left\"><strong>No cycle detection in class inheritance.</strong> The parser or interpreter might allow a class to inherit from itself, directly or indirectly, leading to infinite recursion in method lookup.</td>\n<td align=\"left\">Try defining two classes that inherit from each other. Does the parser accept it? What happens at runtime?</td>\n<td align=\"left\">In <code>visitClassStmt</code>, after resolving the superclass expression, traverse the superclass chain starting from the current class. If you encounter the class being defined, report an error. Store a visited set or simply check that the superclass is not the class itself (direct cycle).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Return statement inside a nested block (but outside a function) causes a confusing error or crash.</strong></td>\n<td align=\"left\"><strong>The return exception is not caught at the appropriate level.</strong> The <code>Return</code> exception (used to unwind the call stack) might be caught only at the top level, or not caught at all, causing program termination.</td>\n<td align=\"left\">Place a <code>return</code> statement outside any function. Does the interpreter report a clear error?</td>\n<td align=\"left\">Ensure <code>visitReturnStmt</code> throws a custom <code>Return</code> exception (containing the value). In <code>executeBlock()</code> and function call execution, catch this exception only when you are within a function context. If caught at the wrong level, rethrow it. At the top level, if a <code>Return</code> exception escapes, report an error: &quot;Cannot return from top-level code.&quot;</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>fun</code> keyword used as a variable name is incorrectly tokenized as a keyword, causing a parse error.</strong></td>\n<td align=\"left\"><strong>Scanner&#39;s keyword detection does not check for identifiers after the keyword.</strong> The scanner might match <code>fun</code> as the <code>FUN</code> keyword even when it&#39;s part of a longer identifier like <code>function</code>.</td>\n<td align=\"left\">The scanner should match the longest possible lexeme. For <code>fun</code>, it&#39;s a keyword only if the following character is not a letter or digit (i.e., it&#39;s a separate token).</td>\n<td align=\"left\">In the scanner, after identifying an alphabetic character (start of an identifier/keyword), consume while <code>isAlphaNumeric(peek())</code>. Then, check the resulting lexeme against the keyword map. This ensures <code>fun</code> is recognized only as a complete token.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>The interpreter incorrectly allows reassignment to a variable that was declared with <code>var</code> in a deeper scope but not in the current scope.</strong></td>\n<td align=\"left\"><strong><code>Environment.assign()</code> searches and updates the first matching variable in the chain, which may be in an outer scope, incorrectly modifying a different variable than intended.</strong></td>\n<td align=\"left\">This is actually the correct behavior for lexical scoping: assignment should modify the nearest enclosing variable with that name. If you want to prevent this (some languages do), you need a different rule.</td>\n<td align=\"left\">If the desired semantics are that assignment can only modify variables declared in the current scope, then <code>assign()</code> should not traverse the parent chain. However, Lox uses lexical scoping for assignment, so the described behavior is correct. Verify your understanding of the language spec.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Using <code>print</code> as a variable name causes a conflict with the <code>print</code> statement.</strong></td>\n<td align=\"left\"><strong>The scanner tokenizes <code>print</code> as the <code>PRINT</code> keyword regardless of context.</strong> In Lox, <code>print</code> is a reserved keyword and cannot be used as an identifier.</td>\n<td align=\"left\">Check the language grammar: <code>print</code> is a keyword for the print statement, not a built-in function. Thus, it is reserved.</td>\n<td align=\"left\">This is by design. The scanner should recognize <code>print</code> as a <code>PRINT</code> token. The parser will then expect it as the start of a print statement. If you want to use <code>print</code> as a variable name, you would need to change the language, but that&#39;s outside the spec.</td>\n</tr>\n</tbody></table>\n<h3 id=\"effective-debugging-techniques\">Effective Debugging Techniques</h3>\n<p>Beyond reactive troubleshooting, you can embed diagnostic tools directly into your interpreter to shed light on its internal operations. Think of these techniques as installing surveillance cameras in a factory: you can watch the raw materials (tokens) move along the conveyor belt, see how they&#39;re assembled into products (AST nodes), and observe the final testing (evaluation). When a defect occurs, you can review the footage to pinpoint the malfunctioning station.</p>\n<h4 id=\"1-ast-printer-visualizing-the-syntax-tree\">1. AST Printer: Visualizing the Syntax Tree</h4>\n<p>The <strong>AST Printer</strong> is a visitor that converts an AST back into a human-readable string format, often as an S-expression. It&#39;s invaluable for verifying that your parser is building the correct tree structure.</p>\n<blockquote>\n<p><strong>Mental Model:</strong> The AST Printer is like a cartographer who translates a detailed, three-dimensional terrain model (the AST) back into a two-dimensional map with standardized symbols. By comparing the map to the source code, you can confirm the terrain was surveyed correctly.</p>\n</blockquote>\n<p><strong>How to implement:</strong> You already built a basic printer in Milestone 2. Enhance it to be more detailed. For each node type, output a parenthesized representation that includes the node type and its key data (e.g., <code>(Binary + (Literal 1) (Literal 2))</code>). Call the printer right after parsing and log the output.</p>\n<p><strong>What it reveals:</strong> Incorrect operator precedence (e.g., <code>1 + 2 * 3</code> parsed as <code>(+ 1 (* 2 3))</code> vs. <code>(+ 1 2) (* 3)</code>), missing nodes, or misplaced parentheses.</p>\n<h4 id=\"2-environment-dumper-mapping-the-variable-universe\">2. Environment Dumper: Mapping the Variable Universe</h4>\n<p>An <strong>Environment Dumper</strong> is a utility that prints the entire chain of environments, showing all variable bindings at a given point in execution. This is crucial for debugging scope, closure, and variable resolution issues.</p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Environment Dumper is like a building superintendent who provides a floor-by-floor directory of all tenants (variables) and their current apartment contents (values). When someone can&#39;t find a tenant, the superintendent can check which floor the tenant is registered on.</p>\n</blockquote>\n<p><strong>How to implement:</strong> Add a method <code>dump()</code> to the <code>Environment</code> class that iterates through the <code>values</code> map and prints each name-value pair, then recursively calls <code>dump()</code> on the <code>enclosing</code> environment (with an indentation increase). Call this at key points: before/after a function call, inside a block, or when a &quot;undefined variable&quot; error occurs.</p>\n<p><strong>What it reveals:</strong> Whether a variable is defined in the current scope or a parent, if a closure captured the correct environment, and if <code>this</code> is bound in a method.</p>\n<h4 id=\"3-step-by-step-execution-log-the-interpreter39s-diary\">3. Step-by-Step Execution Log: The Interpreter&#39;s Diary</h4>\n<p>An <strong>Execution Log</strong> is a trace of every step the interpreter takes as it walks the AST. It logs each node visited (<code>visitBinaryExpr</code>, <code>visitLiteralExpr</code>, etc.), the values computed, and any side effects (variable definition, assignment).</p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Execution Log is like a flight data recorder, meticulously timestamping every control input, sensor reading, and system state change during a flight. In a crash, the log tells you exactly what happened in the moments before.</p>\n</blockquote>\n<p><strong>How to implement:</strong> Add a static logging flag to your interpreter. In each <code>visit</code> method, log the method name and relevant details (e.g., <code>&quot;Evaluating binary + with left=1.0, right=2.0&quot;</code>). Use indentation to show the depth of recursion. Log environment changes separately.</p>\n<p><strong>What it reveals:</strong> The order of evaluation, short-circuiting behavior, function call entry/exit, and the exact point where a runtime error is thrown.</p>\n<h4 id=\"4-token-stream-visualizer-seeing-the-lexical-stream\">4. Token Stream Visualizer: Seeing the Lexical Stream</h4>\n<p>A <strong>Token Stream Visualizer</strong> simply prints the list of tokens produced by the scanner, one per line, with their type, lexeme, and line number. This helps verify that the scanner is correctly categorizing the source code.</p>\n<p><strong>How to implement:</strong> After calling <code>scanTokens()</code>, iterate through the list and print each token using its <code>toString()</code> method. Ensure you include identifiers, literals, and punctuation.</p>\n<p><strong>What it reveals:</strong> Misclassified tokens (e.g., <code>=</code> vs <code>==</code>), incorrect handling of whitespace/comments, and malformed number or string literals.</p>\n<h4 id=\"5-manual-test-harness-with-assertions\">5. Manual Test Harness with Assertions</h4>\n<p>Create a suite of small, focused Lox programs that test a single feature (e.g., variable shadowing, closure capture, super call). In each test, use <code>print</code> statements as assertions. For example, a test for closure capture might be:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lox</span><pre class=\"arch-pre shiki-highlighted\"><code>var x = &quot;outer&quot;;\nfun f() { print x; }\nf(); // Should print &quot;outer&quot;\nx = &quot;changed&quot;;\nf(); // Should print &quot;changed&quot;</code></pre></div>\n<p>Run these tests after each significant change to ensure you haven&#39;t introduced regressions.</p>\n<h4 id=\"6-using-a-debugger-strategic-breakpoints\">6. Using a Debugger: Strategic Breakpoints</h4>\n<p>While print-based logging is helpful, a modern IDE debugger allows you to pause execution, inspect variables, and step through code. Set breakpoints at critical junctions:</p>\n<ul>\n<li>In <code>Parser.parse()</code> when a specific token type is consumed.</li>\n<li>In <code>Interpreter.visitBinaryExpr</code> when the operator is <code>PLUS</code>.</li>\n<li>In <code>LoxFunction.call()</code> when a new environment is created.</li>\n<li>In <code>Environment.get()</code> when a particular variable name is looked up.</li>\n</ul>\n<p>Watch the call stack to understand the flow of control, especially for recursive functions and nested evaluations.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete code snippets to implement the debugging techniques described above. These are supplemental tools that you can integrate into your interpreter during development.</p>\n<h4 id=\"a-enhanced-ast-printer\">A. Enhanced AST Printer</h4>\n<p>Add this class to your project. It implements the <code>Expr.Visitor&lt;String&gt;</code> and <code>Stmt.Visitor&lt;String&gt;</code> interfaces to produce S-expression representations.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In file: tool/AstPrinter.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.tool;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Expr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> com.craftinginterpreters.lox.Stmt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> AstPrinter</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> Expr.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Stmt.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> expr.</span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(Stmt </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> stmt.</span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(Expr.Binary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> parenthesize</span><span style=\"color:#E1E4E8\">(expr.operator.lexeme, expr.left, expr.right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">visitGroupingExpr</span><span style=\"color:#E1E4E8\">(Expr.Grouping </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> parenthesize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"group\"</span><span style=\"color:#E1E4E8\">, expr.expression);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">visitLiteralExpr</span><span style=\"color:#E1E4E8\">(Expr.Literal </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (expr.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"nil\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> expr.value.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">visitUnaryExpr</span><span style=\"color:#E1E4E8\">(Expr.Unary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> parenthesize</span><span style=\"color:#E1E4E8\">(expr.operator.lexeme, expr.right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add visit methods for other expression types added later:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Variable, Assign, Logical, Call, Get, Set, This, Super</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For example:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // @Override</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // public String visitVariableExpr(Expr.Variable expr) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     return expr.name.lexeme;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">visitExpressionStmt</span><span style=\"color:#E1E4E8\">(Stmt.Expression </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> parenthesize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expr\"</span><span style=\"color:#E1E4E8\">, stmt.expression);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">visitPrintStmt</span><span style=\"color:#E1E4E8\">(Stmt.Print </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> parenthesize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"print\"</span><span style=\"color:#E1E4E8\">, stmt.expression);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">visitVarStmt</span><span style=\"color:#E1E4E8\">(Stmt.Var </span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (stmt.initializer </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> parenthesize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"var\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Variable</span><span style=\"color:#E1E4E8\">(stmt.name));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> parenthesize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"var\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">new</span><span style=\"color:#E1E4E8\"> Expr.</span><span style=\"color:#B392F0\">Variable</span><span style=\"color:#E1E4E8\">(stmt.name), stmt.initializer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add visit methods for other statement types added later:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Block, If, While, Function, Return, Class</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">parenthesize</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, Expr... </span><span style=\"color:#FFAB70\">exprs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StringBuilder builder </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> StringBuilder</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        builder.</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"(\"</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (Expr expr </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> exprs) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            builder.</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            builder.</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(expr.</span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        builder.</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\")\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> builder;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper to print a list of statements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">statements</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StringBuilder builder </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> StringBuilder</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (Stmt stmt </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> statements) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            builder.</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(stmt));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            builder.</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> builder.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"b-environment-dumper\">B. Environment Dumper</h4>\n<p>Add a static method to the <code>Environment</code> class to dump its contents. This method prints the current scope and recursively dumps enclosing scopes with indentation.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In file: environment/Environment.java (add this method)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... existing fields and methods ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> dump</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        dump</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> dump</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> depth</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        String indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"  \"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">repeat</span><span style=\"color:#E1E4E8\">(depth);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"Environment \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> System.</span><span style=\"color:#B392F0\">identityHashCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \":\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (Map.Entry&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> entry </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> values.</span><span style=\"color:#B392F0\">entrySet</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"  \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> entry.</span><span style=\"color:#B392F0\">getKey</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \" = \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> entry.</span><span style=\"color:#B392F0\">getValue</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (enclosing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            enclosing.</span><span style=\"color:#B392F0\">dump</span><span style=\"color:#E1E4E8\">(depth </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"  (no enclosing)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>To use it, call <code>environment.dump();</code> at any point in the interpreter, e.g., inside <code>visitVarStmt</code> after defining a variable, or inside <code>LoxFunction.call()</code> before executing the body.</p>\n<h4 id=\"c-execution-logging-with-a-flag\">C. Execution Logging with a Flag</h4>\n<p>Add a static boolean flag to your <code>Interpreter</code> class to enable/disable verbose logging. Then, add logging statements at the beginning of each <code>visit</code> method.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In file: interpreter/Interpreter.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Interpreter</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> Expr.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Stmt.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Void</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> final</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> DEBUG </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Set to false to disable logs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> indentLevel </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> log</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">DEBUG) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        String indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"  \"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">repeat</span><span style=\"color:#E1E4E8\">(indentLevel);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.err.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(Expr.Binary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"visitBinaryExpr: \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> expr.operator.lexeme);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indentLevel</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object left </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(expr.left);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object right </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(expr.right);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indentLevel</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  left=\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \", right=\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> right);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ... evaluation logic ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ...;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  result=\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> result);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Similarly, add log() calls in other visit methods.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Increase indentLevel when entering a node, decrease when leaving.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>For statement execution, you might want to log the statement type. For function calls, log the arguments and the return value.</p>\n<h4 id=\"d-token-stream-visualizer\">D. Token Stream Visualizer</h4>\n<p>A simple utility method in your main <code>Lox</code> class can print tokens.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In file: Lox.java (add this method)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> printTokens</span><span style=\"color:#E1E4E8\">(List</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Token</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> tokens) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (Token token </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> tokens) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(token);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Call it after scanning and before parsing when you need to debug the scanner.</p>\n<h4 id=\"e-language-specific-hints-java\">E. Language-Specific Hints (Java)</h4>\n<ul>\n<li><strong>Identity Hash Code:</strong> Use <code>System.identityHashCode(object)</code> to print a unique identifier for an object instance, helpful for distinguishing between different environment objects.</li>\n<li><strong>Exception Stack Trace:</strong> When catching exceptions (like <code>RuntimeError</code>), print the stack trace using <code>e.printStackTrace()</code> to see the call path.</li>\n<li><strong>Java Debugger (JDB):</strong> Learn to use JDB or the debugger integrated into your IDE (IntelliJ IDEA, Eclipse, VS Code). Set breakpoints and inspect variables.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint-for-debugging\">F. Milestone Checkpoint for Debugging</h4>\n<p>After implementing the core interpreter (Milestone 5), you should be able to run a test program and use the debugging tools to verify internal state.</p>\n<p><strong>Test Command:</strong> Create a file <code>test.lox</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lox</span><pre class=\"arch-pre shiki-highlighted\"><code>var a = 1;\n{\n    var a = 2;\n    print a;\n}\nprint a;</code></pre></div>\n<p>Run your interpreter on this file.</p>\n<p><strong>Expected Output:</strong> </p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>2\n1</code></pre></div>\n\n<p><strong>Debugging Verification:</strong></p>\n<ol>\n<li>Enable the AST printer and verify the AST structure includes a block statement with a nested variable declaration.</li>\n<li>Enable environment dumping inside the block. You should see two environments: the inner one with <code>a = 2</code> and the outer one with <code>a = 1</code>.</li>\n<li>If the output is reversed (1 then 2), your environment chain might be reversed, or variable resolution might be looking only at the global scope.</li>\n</ol>\n<h4 id=\"g-debugging-tips-table-recap-of-common-issues\">G. Debugging Tips Table (Recap of Common Issues)</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">How to Diagnose</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Infinite recursion in parser</td>\n<td align=\"left\">Left-recursive grammar</td>\n<td align=\"left\">Print parsing method calls</td>\n<td align=\"left\">Ensure base case is <code>primary()</code></td>\n</tr>\n<tr>\n<td align=\"left\">Variables not found</td>\n<td align=\"left\">Environment chain not searched</td>\n<td align=\"left\">Dump environment chain</td>\n<td align=\"left\">Implement recursive <code>get()</code> and <code>assign()</code></td>\n</tr>\n<tr>\n<td align=\"left\">No short-circuit evaluation</td>\n<td align=\"left\">Both operands evaluated eagerly</td>\n<td align=\"left\">Log evaluation order</td>\n<td align=\"left\">Check left operand first in <code>visitLogicalExpr</code></td>\n</tr>\n<tr>\n<td align=\"left\">Functions share state across calls</td>\n<td align=\"left\">Single environment reused</td>\n<td align=\"left\">Print environment identity in each call</td>\n<td align=\"left\">Create new <code>Environment</code> per call</td>\n</tr>\n<tr>\n<td align=\"left\"><code>this</code> not bound in methods</td>\n<td align=\"left\">Missing <code>this</code> in method environment</td>\n<td align=\"left\">Dump environment inside method call</td>\n<td align=\"left\">Bind <code>this</code> in <code>LoxFunction.bind()</code></td>\n</tr>\n</tbody></table>\n<p>By incorporating these debugging techniques and referring to the symptom table, you can systematically isolate and fix issues throughout your interpreter&#39;s development journey.</p>\n<h2 id=\"10-future-extensions\">10. Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> None (forward-looking enhancements)</p>\n</blockquote>\n<p>This section explores the frontiers beyond the core interpreter—potential enhancements that the current architecture can accommodate with modest modifications. Think of the interpreter you&#39;ve built as a <strong>foundational engine</strong>: robust and complete, but designed with extension points that invite further exploration. These extensions serve dual purposes: they demonstrate the flexibility of your design, and they provide meaningful projects for deepening your understanding of language implementation.</p>\n<blockquote>\n<p><strong>Design Principle:</strong> A well-architected interpreter should be <strong>extensible along three dimensions</strong>: new language features, performance improvements, and developer experience enhancements, without requiring fundamental redesigns of the core pipeline.</p>\n</blockquote>\n<h3 id=\"possible-feature-additions\">Possible Feature Additions</h3>\n<p>The interpreter&#39;s modular design—clean separation between lexical analysis, syntactic parsing, and semantic evaluation—creates natural insertion points for new capabilities. Each feature addition follows a consistent pattern: extend the <strong>grammar</strong> (Scanner and Parser), add corresponding <strong>AST nodes</strong> (Data Model), and implement <strong>semantics</strong> (Interpreter visitor methods). The Visitor pattern proves particularly valuable here, as new node types simply require new visitor methods without disturbing existing evaluation logic.</p>\n<h4 id=\"adding-a-read-eval-print-loop-repl\">Adding a Read-Eval-Print Loop (REPL)</h4>\n<p><strong>Mental Model:</strong> The REPL transforms the interpreter from a <strong>batch processor</strong> (reading files) into an <strong>interactive conversation partner</strong>, enabling immediate feedback and exploratory programming—like having a calculator that understands Lox syntax.</p>\n<p><strong>Current Architecture Fit:</strong> The interpreter already has a <code>Lox.run(String)</code> method that processes a source string. The REPL adds:</p>\n<ol>\n<li>A continuous loop in <code>Lox.runPrompt()</code> that reads lines from standard input</li>\n<li>Special handling for multi-line inputs (like function declarations spanning lines)</li>\n<li>A persistent top-level environment across inputs (unlike file execution which starts fresh)</li>\n</ol>\n<p><strong>Required Changes:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Modification Required</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Lox</code> class</td>\n<td>Add <code>runPrompt()</code> with readline loop, detect incomplete statements</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><code>Parser</code></td>\n<td>Synchronize on newline when in REPL mode vs. EOF in file mode</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td><code>Interpreter</code></td>\n<td>Maintain global environment across REPL inputs, maybe display results automatically</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Continue after errors in REPL (don&#39;t exit entire session)</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Considerations:</strong> The main challenge is handling <strong>incomplete statements</strong>. When the parser encounters EOF mid-statement (like <code>fun f(</code>), it must distinguish between &quot;end of file&quot; (error) and &quot;end of line, more input expected&quot; (REL prompt for continuation). A simple approach: catch <code>ParseError</code> and if in REPL mode and error was unexpected EOF, read another line and concatenate.</p>\n<blockquote>\n<p><strong>ADR: REPL Continuation Strategy</strong></p>\n<ul>\n<li><strong>Context:</strong> REPL must handle multi-line inputs gracefully without requiring perfect syntax on first line</li>\n<li><strong>Options Considered:</strong> <ol>\n<li><strong>Prompt-based continuation:</strong> When parser hits unexpected EOF, print <code>... &gt; </code> and read more input</li>\n<li><strong>Bracket counting:</strong> Track open <code>{</code>, <code>(</code>, <code>[</code> and continue until all closed</li>\n<li><strong>Statement delimiter:</strong> Require explicit continuation character (like <code>\\</code> at line end)</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Prompt-based continuation with basic bracket counting</li>\n<li><strong>Rationale:</strong> Mimics behavior of mature REPLs (Python, Node.js); bracket counting handles most real multi-line cases (function bodies, blocks)</li>\n<li><strong>Consequences:</strong> More complex parser error recovery logic; need to reset parser state on continuation</li>\n</ul>\n</blockquote>\n<h4 id=\"standard-library-functions\">Standard Library Functions</h4>\n<p><strong>Mental Model:</strong> The standard library provides <strong>pre-built tools</strong> that every Lox program can use without reinvention—like a Swiss Army knife included with the language. These are functions written not in Lox, but in Java (or your implementation language) and exposed as built-in callables.</p>\n<p><strong>Architecture Integration:</strong> The <code>Environment</code> class already has a <code>globals</code> field. Standard library functions become <code>LoxFunction</code> objects (or a new <code>LoxNativeFunction</code> subclass) registered in the global environment during interpreter initialization.</p>\n<table>\n<thead>\n<tr>\n<th>Function Category</th>\n<th>Example Functions</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mathematical</td>\n<td><code>sqrt(x)</code>, <code>sin(x)</code>, <code>random()</code></td>\n<td>Delegate to Java <code>Math</code> class, with type checking</td>\n</tr>\n<tr>\n<td>String Operations</td>\n<td><code>length(s)</code>, <code>substring(s, start, end)</code>, <code>split(s, delim)</code></td>\n<td>Operate on Java <code>String</code> wrapper, return new <code>LoxString</code></td>\n</tr>\n<tr>\n<td>Type Utilities</td>\n<td><code>typeOf(value)</code>, <code>isNumber(value)</code>, <code>toString(value)</code></td>\n<td>Inspect runtime object types, use existing <code>stringify()</code></td>\n</tr>\n<tr>\n<td>Collection Basics</td>\n<td><code>arrayCreate(size)</code>, <code>arrayPush(arr, value)</code></td>\n<td>Require new array data type (see below)</td>\n</tr>\n</tbody></table>\n<p><strong>Native Function Interface:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example interface (shown in Implementation Guidance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">interface</span><span style=\"color:#B392F0\"> LoxCallable</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> arity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Object </span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">(Interpreter </span><span style=\"color:#FFAB70\">interpreter</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Implementation Pattern:</strong> Each standard library function implements <code>LoxCallable</code> with type-checked arguments and Java-side logic. The <code>Interpreter</code> initializes <code>globals</code> with these functions before any user code runs.</p>\n<h4 id=\"native-functions-and-foreign-function-interface-ffi\">Native Functions and Foreign Function Interface (FFI)</h4>\n<p><strong>Mental Model:</strong> A <strong>bridge to the host world</strong>—allowing Lox programs to call functions written in Java (or C/Rust) and access system capabilities like file I/O, networking, or graphics. This transforms Lox from a toy language into one that can interact with the real world.</p>\n<p><strong>Architecture Extension:</strong> Native functions share the same <code>LoxCallable</code> interface as standard library functions but require careful design for data marshalling between Lox values and host language types.</p>\n<table>\n<thead>\n<tr>\n<th>Concern</th>\n<th>Design Decision</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Type Marshalling</strong></td>\n<td>Convert Lox values to Java objects: <code>LoxNumber</code> → <code>Double</code>, <code>LoxString</code> → <code>String</code></td>\n<td>Simpler for implementer, leverages host language type system</td>\n</tr>\n<tr>\n<td><strong>Error Propagation</strong></td>\n<td>Throw <code>RuntimeError</code> for invalid arguments or host-side failures</td>\n<td>Consistent with Lox&#39;s error handling model</td>\n</tr>\n<tr>\n<td><strong>Memory Management</strong></td>\n<td>Native functions can allocate host resources; need cleanup hooks</td>\n<td>Simple approach: no automatic cleanup (educational focus)</td>\n</tr>\n<tr>\n<td><strong>Callback Support</strong></td>\n<td>Allow native functions to call back into Lox functions</td>\n<td>Requires passing <code>LoxFunction</code> as argument, maintaining interpreter context</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>ADR: FFI Safety vs. Power Trade-off</strong></p>\n<ul>\n<li><strong>Context:</strong> Native functions can crash the interpreter or cause undefined behavior if misused</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Restricted FFI:</strong> Only pre-approved safe functions (math, string ops)</li>\n<li><strong>Unrestricted FFI:</strong> Allow any Java method call via reflection</li>\n<li><strong>Sandboxed FFI:</strong> Run native code in isolated environment with resource limits</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Restricted FFI with explicit registration of safe functions</li>\n<li><strong>Rationale:</strong> Educational project prioritizes safety and simplicity; reflection adds complexity without proportional learning value</li>\n<li><strong>Consequences:</strong> Limited to functions we explicitly implement; can&#39;t dynamically call arbitrary Java methods</li>\n</ul>\n</blockquote>\n<h4 id=\"additional-control-flow-break-continue-and-switch\">Additional Control Flow: <code>break</code>, <code>continue</code>, and <code>switch</code></h4>\n<p><strong>Mental Model:</strong> <code>break</code> and <code>continue</code> are <strong>loop control commands</strong>—emergency exits and fast-forward buttons for loops. <code>switch</code> is a <strong>multi-way branch</strong>—a more structured alternative to chained <code>if-else</code> statements.</p>\n<p><strong>Grammar Extensions:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>statement → exprStmt | printStmt | block | ifStmt | whileStmt | forStmt \n          | breakStmt | continueStmt | switchStmt ;\n\nbreakStmt → &quot;break&quot; &quot;;&quot; ;\ncontinueStmt → &quot;continue&quot; &quot;;&quot; ;\n\nswitchStmt → &quot;switch&quot; &quot;(&quot; expression &quot;)&quot; &quot;{&quot; \n             ( &quot;case&quot; expression &quot;:&quot; statement* )* \n             ( &quot;default&quot; &quot;:&quot; statement* )? \n           &quot;}&quot; ;</code></pre></div>\n\n<p><strong>Implementation Challenges:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Challenge</th>\n<th>Solution Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>break</code>/<code>continue</code></td>\n<td>Must exit/continue the innermost loop, not just any statement</td>\n<td>Store loop nesting depth in interpreter, use exception-like control flow</td>\n</tr>\n<tr>\n<td><code>switch</code></td>\n<td>Multiple cases with fall-through vs. break behavior</td>\n<td>Implement Java-style fall-through (educational) or require explicit <code>break</code></td>\n</tr>\n<tr>\n<td>Scope</td>\n<td>Do cases create new scopes?</td>\n<td>Each case block gets its own environment for consistency with <code>if</code></td>\n</tr>\n</tbody></table>\n<p><strong>Control Flow Implementation Pattern:</strong> Use a specialized exception (<code>BreakException</code>, <code>ContinueException</code>) that carries no value but unwinds the call stack to the nearest loop boundary. The <code>visitWhileStmt</code> and <code>visitForStmt</code> methods catch these exceptions and handle them appropriately.</p>\n<h4 id=\"arrays-and-basic-data-structures\">Arrays and Basic Data Structures</h4>\n<p><strong>Mental Model:</strong> Arrays are <strong>indexed collections</strong>—numbered slots that can hold values of any type. Adding arrays transforms Lox from a calculator with variables into a language capable of handling real data.</p>\n<p><strong>Architecture Impact:</strong></p>\n<ol>\n<li><strong>New Token Types:</strong> <code>LEFT_BRACKET</code>, <code>RIGHT_BRACKET</code></li>\n<li><strong>New AST Nodes:</strong> <code>ArrayLiteral</code> (list of expressions), <code>SubscriptExpr</code> (array[index])</li>\n<li><strong>New Runtime Type:</strong> <code>LoxArray</code> with internal <code>List&lt;Object&gt;</code> storage</li>\n<li><strong>New Operations:</strong> Index get/set, <code>length</code> property/method</li>\n</ol>\n<p><strong>Grammar:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>primary → ( &quot;[&quot; ( expression ( &quot;,&quot; expression )* )? &quot;]&quot; ) | ... existing rules ... ;\npostfix → primary ( &quot;[&quot; expression &quot;]&quot; | &quot;.&quot; IDENTIFIER | &quot;(&quot; arguments? &quot;)&quot; )* ;</code></pre></div>\n\n<p><strong>Design Decisions for Arrays:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Decision Point</th>\n<th>Options</th>\n<th>Recommended Choice</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Index Origin</strong></td>\n<td>0-based (C/Java) vs 1-based (Lua)</td>\n<td>0-based for consistency with implementation language</td>\n</tr>\n<tr>\n<td><strong>Bounds Checking</strong></td>\n<td>Check at runtime, throw error if out of bounds</td>\n<td>Always check; no buffer overflows</td>\n</tr>\n<tr>\n<td><strong>Dynamic Resizing</strong></td>\n<td>Fixed-size vs growable</td>\n<td>Growable via <code>add()</code> method for simplicity</td>\n</tr>\n<tr>\n<td><strong>Multi-dimensional</strong></td>\n<td>Arrays of arrays vs native multi-D</td>\n<td>Arrays of arrays (more flexible)</td>\n</tr>\n</tbody></table>\n<p><strong>Integration:</strong> The <code>LoxArray</code> class implements <code>LoxInstance</code> so arrays can have methods (<code>length()</code>, <code>push(value)</code>, <code>pop()</code>) while also supporting indexed access via <code>array[0]</code> syntax.</p>\n<h4 id=\"exception-handling-with-trycatch\">Exception Handling with <code>try</code>/<code>catch</code></h4>\n<p><strong>Mental Model:</strong> Exceptions are <strong>controlled crashes</strong>—a way for functions to signal &quot;I can&#39;t handle this situation&quot; and let callers decide what to do. The <code>try</code> block is a safety net, and <code>catch</code> is the person who catches what falls.</p>\n<p><strong>Grammar Extension:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>statement → ... | tryStmt ;\ntryStmt → &quot;try&quot; block &quot;catch&quot; &quot;(&quot; IDENTIFIER &quot;)&quot; block ;</code></pre></div>\n\n<p><strong>Implementation Approach:</strong></p>\n<ol>\n<li>Add <code>RuntimeError</code> subclass <code>LoxException</code> that carries a value (the exception object)</li>\n<li>In <code>Interpreter</code>, when evaluating an expression that throws, unwind until finding a <code>try</code> block</li>\n<li>The <code>catch</code> clause creates a new local variable (the identifier) bound to the exception value</li>\n<li>Execute the catch block in that environment</li>\n</ol>\n<p><strong>Design Considerations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Consideration</th>\n<th>Decision</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Exception Values</strong></td>\n<td>Any Lox value can be thrown</td>\n<td>Simple, flexible; follows JavaScript model</td>\n</tr>\n<tr>\n<td><strong>Finally Clause</strong></td>\n<td>Omit for simplicity</td>\n<td>Adds significant complexity for cleanup</td>\n</tr>\n<tr>\n<td><strong>Exception Hierarchy</strong></td>\n<td>Single exception type vs class hierarchy</td>\n<td>Single <code>LoxException</code> for educational simplicity</td>\n</tr>\n<tr>\n<td><strong>Uncaught Exceptions</strong></td>\n<td>Terminate program with error message</td>\n<td>Same as current runtime error behavior</td>\n</tr>\n</tbody></table>\n<h4 id=\"modules-and-imports\">Modules and Imports</h4>\n<p><strong>Mental Model:</strong> Modules are <strong>self-contained toolboxes</strong>—collections of related functions and classes that can be loaded on demand. The <code>import</code> statement is like saying &quot;I need the tools from that toolbox.&quot;</p>\n<p><strong>Architecture Changes Required:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Changes</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Scanner/Parser</strong></td>\n<td>New <code>import</code> keyword and statement</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><strong>Interpreter</strong></td>\n<td>Module cache, separate environments per module</td>\n<td>High</td>\n</tr>\n<tr>\n<td><strong>File System</strong></td>\n<td>Resolve module paths, detect cycles</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td><strong>Environment</strong></td>\n<td>Module-level vs global vs local scopes</td>\n<td>High</td>\n</tr>\n</tbody></table>\n<p><strong>Simplified Approach (Single File Modules):</strong></p>\n<ol>\n<li><code>import &quot;module.lox&quot;</code> loads and executes that file once</li>\n<li>Creates a new <code>Environment</code> for the module (parent is globals)</li>\n<li>Exports: all top-level declarations become available to importer</li>\n<li>Import returns a <code>LoxModule</code> object that provides access to exported names</li>\n</ol>\n<p><strong>Implementation Pattern:</strong> Use a <code>Map&lt;String, Environment&gt;</code> module cache. When importing, check cache first; if not present, run the module file&#39;s statements in a fresh environment, store that environment in cache, and return a wrapper that delegates lookups to it.</p>\n<h4 id=\"compiling-to-bytecode-transition-to-a-virtual-machine\">Compiling to Bytecode (Transition to a Virtual Machine)</h4>\n<p><strong>Mental Model:</strong> Bytecode compilation transforms the <strong>AST interpreter</strong> (walking the tree each time) into a <strong>virtual machine</strong> (walking a linear instruction list). Think of it as converting a recipe (AST) into a punch card for a cooking robot (bytecode VM)—more steps upfront, but faster execution.</p>\n<p><strong>Architecture Transformation Path:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Description</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. <strong>Define Bytecode Instruction Set</strong></td>\n<td>Simple stack-based operations: <code>CONSTANT</code>, <code>ADD</code>, <code>STORE</code>, <code>LOAD</code></td>\n<td>New <code>OpCode</code> enum, <code>Chunk</code> class</td>\n</tr>\n<tr>\n<td>2. <strong>Write Compiler Visitor</strong></td>\n<td>Transform AST nodes to bytecode sequences</td>\n<td>New <code>Compiler</code> class implementing visitor interfaces</td>\n</tr>\n<tr>\n<td>3. <strong>Build Virtual Machine</strong></td>\n<td>Stack machine that executes bytecode</td>\n<td>New <code>VM</code> class replacing parts of <code>Interpreter</code></td>\n</tr>\n<tr>\n<td>4. <strong>Gradual Migration</strong></td>\n<td>Start with expressions only, keep statements as tree-walking</td>\n<td>Hybrid approach reduces risk</td>\n</tr>\n</tbody></table>\n<p><strong>Bytecode Example:</strong> The expression <code>1 + 2 * 3</code> compiles to:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>CONSTANT 0  (value: 1)\nCONSTANT 1  (value: 2)\nCONSTANT 2  (value: 3)\nMULTIPLY\nADD</code></pre></div>\n\n<p><strong>Performance Benefits:</strong> Bytecode eliminates AST traversal overhead, enables optimization passes (constant folding, dead code elimination), and prepares for Just-In-Time (JIT) compilation.</p>\n<blockquote>\n<p><strong>ADR: Gradual vs Complete VM Migration</strong></p>\n<ul>\n<li><strong>Context:</strong> Transitioning from tree-walking to bytecode VM is a major architectural change</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Complete Rewrite:</strong> Build VM from scratch, discard tree-walking interpreter</li>\n<li><strong>Gradual Migration:</strong> Compile expressions to bytecode, interpret statements as AST</li>\n<li><strong>Dual Implementation:</strong> Support both interpreters, select via flag</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Gradual migration starting with expressions</li>\n<li><strong>Rationale:</strong> Lower risk, allows testing VM incrementally, preserves educational value of seeing both approaches</li>\n<li><strong>Consequences:</strong> Temporary complexity of two evaluation strategies; need bridge between VM and environment systems</li>\n</ul>\n</blockquote>\n<h3 id=\"performance-optimizations\">Performance Optimizations</h3>\n<p>While the tree-walking interpreter prioritizes clarity over speed, several optimizations can significantly improve performance without altering the fundamental architecture. These optimizations demonstrate important compiler techniques while keeping the codebase comprehensible.</p>\n<h4 id=\"constant-folding\">Constant Folding</h4>\n<p><strong>Mental Model:</strong> Constant folding is the interpreter&#39;s <strong>pre-calculation</strong>—evaluating constant expressions at compile time rather than runtime, like a baker measuring all ingredients before starting rather than stopping to measure between each step.</p>\n<p><strong>Implementation Approach:</strong> Add a compile-time optimization pass between parsing and interpretation that walks the AST, identifying sub-expressions with only literal values, evaluating them, and replacing with a single <code>Literal</code> node.</p>\n<p><strong>Example Transformation:</strong></p>\n<ul>\n<li><strong>Before:</strong> <code>Binary(+, Literal(1), Binary(*, Literal(2), Literal(3)))</code></li>\n<li><strong>After:</strong> <code>Literal(7)</code></li>\n</ul>\n<p><strong>Algorithm:</strong></p>\n<ol>\n<li>Create <code>ConstantFolder</code> class implementing <code>Expr.Visitor&lt;Expr&gt;</code> and <code>Stmt.Visitor&lt;Stmt&gt;</code></li>\n<li>For each <code>Binary</code> node: recursively fold children; if both are literals, compute result, return new <code>Literal</code></li>\n<li>Apply to <code>Unary</code>, <code>Grouping</code>, and <code>Logical</code> nodes similarly</li>\n<li>For statements: fold expressions within <code>Print</code>, <code>Var</code>, <code>If</code>, <code>While</code>, etc.</li>\n</ol>\n<p><strong>Limitations:</strong> Cannot fold variables (unknown at compile time) or function calls (side effects). Safe to apply only to pure arithmetic and logical operations.</p>\n<h4 id=\"environment-flattening-upvalue-resolution\">Environment Flattening (Upvalue Resolution)</h4>\n<p><strong>Mental Model:</strong> Environment flattening transforms the <strong>linked list of scopes</strong> (slow chain of hash map lookups) into a <strong>flat array of slots</strong> (fast indexed access). Think of it as creating a cheat sheet that lists all variables you&#39;ll need during a function&#39;s execution, with their &quot;home addresses&quot; pre-calculated.</p>\n<p><strong>Current Performance Issue:</strong> Each variable lookup in a closure may traverse multiple environment links: local → closure-captured → outer function → global. With nested closures, this becomes O(depth) per access.</p>\n<p><strong>Optimization Approach:</strong> </p>\n<ol>\n<li><strong>Analysis Phase:</strong> Walk function body AST before execution, identify all variable references</li>\n<li><strong>Upvalue Resolution:</strong> For variables not defined locally, record which enclosing environment and depth they come from</li>\n<li><strong>Flat Storage:</strong> Store all accessed variables (local and upvalues) in a single array</li>\n<li><strong>Fast Access:</strong> Variable references become array indices instead of name lookups</li>\n</ol>\n<p><strong>Implementation Steps:</strong></p>\n<ol>\n<li>Add <code>Resolver</code> pass before interpretation (similar to book&#39;s Chapter 11 resolver)</li>\n<li>Store resolution results in <code>Interpreter.locals: Map&lt;Expr, Integer&gt;</code> (already in design!)</li>\n<li>Modify <code>Environment</code> to support indexed access alongside name-based access</li>\n<li>Change <code>visitVariableExpr</code> to use index when available</li>\n</ol>\n<p><strong>Performance Impact:</strong> Variable access changes from O(n) hash lookup + chain traversal to O(1) array access. Most significant for loops accessing captured variables.</p>\n<h4 id=\"method-caching\">Method Caching</h4>\n<p><strong>Mental Model:</strong> Method caching is the interpreter&#39;s <strong>Rolodex</strong>—remembering where you found a method last time so you don&#39;t have to search the class hierarchy again. For <code>object.method()</code> calls, cache the resolved method at the call site.</p>\n<p><strong>Problem:</strong> Each <code>object.method()</code> call traverses: instance fields → class methods → superclass chain. With inheritance hierarchies, this repeated traversal adds overhead.</p>\n<p><strong>Solution:</strong> Add a <strong>cache at the call site</strong> (AST node) that remembers: for a given receiver object&#39;s class, which method was found. On subsequent calls with same class, use cached method.</p>\n<p><strong>Implementation:</strong></p>\n<ol>\n<li>Add field to <code>Expr.Call</code> node: <code>cachedMethod: LoxFunction</code> and <code>cachedClass: LoxClass</code></li>\n<li>In <code>visitCallExpr</code>, before full resolution: check if <code>callee</code> is <code>Get</code> expression and if receiver&#39;s class matches cached class</li>\n<li>If match, use cached method; if not, perform full resolution and update cache</li>\n</ol>\n<p><strong>Challenge:</strong> Cache invalidation when classes are redefined (unlikely in Lox) or when monkey-patching methods (not supported). Simple approach: clear all caches on any class declaration (heavy-handed but correct).</p>\n<h4 id=\"string-interning\">String Interning</h4>\n<p><strong>Mental Model:</strong> String interning is the interpreter&#39;s <strong>dictionary</strong>—ensuring identical strings share the same underlying object, so comparisons become pointer equality checks instead of character-by-character comparisons.</p>\n<p><strong>Performance Benefits:</strong></p>\n<ol>\n<li><strong>Faster equality checks:</strong> <code>==</code> on strings becomes reference comparison for interned strings</li>\n<li><strong>Reduced memory:</strong> Duplicate string literals share storage</li>\n<li><strong>Faster hash map lookups:</strong> Environment variable names are interned strings</li>\n</ol>\n<p><strong>Implementation:</strong> Add <code>StringPool</code> class with static <code>intern(String): String</code> method. In <code>Scanner</code>, after reading string literal text, pass through pool before creating <code>Token</code>. In <code>Interpreter</code>, intern string values created at runtime (concatenation results).</p>\n<p><strong>Trade-off:</strong> Interning pool grows indefinitely (memory leak for dynamic strings). Solution: weak references or limit to literals only.</p>\n<h4 id=\"tail-call-optimization-tco\">Tail Call Optimization (TCO)</h4>\n<p><strong>Mental Model:</strong> Tail call optimization transforms <strong>recursive function calls</strong> that would grow the call stack into <strong>loops</strong> that reuse the current stack frame. It&#39;s like realizing you&#39;re at the end of a hallway and instead of walking back to start a new hallway, you just turn around and continue.</p>\n<p><strong>Applicability:</strong> When a function&#39;s last action is returning the result of another function call (tail position), reuse the current call frame instead of pushing a new one.</p>\n<p><strong>Example:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lox</span><pre class=\"arch-pre shiki-highlighted\"><code>fun factorial(n, acc) {\n    if (n &lt;= 1) return acc;\n    return factorial(n - 1, n * acc);  // Tail call eligible for TCO\n}</code></pre></div>\n\n<p><strong>Implementation:</strong> In <code>LoxFunction.call()</code>, detect tail calls: if the last statement in function body is <code>return expr</code> and <code>expr</code> is a <code>Call</code> expression, then:</p>\n<ol>\n<li>Don&#39;t create new environment; reuse current with updated parameters</li>\n<li>Jump to evaluating the called function&#39;s body (loop instead of recursion)</li>\n<li>Implement as trampoline: functions return &quot;continue with this other function&quot; instead of recursing</li>\n</ol>\n<p><strong>Benefit:</strong> Enables infinite recursion without stack overflow for properly tail-recursive functions.</p>\n<h4 id=\"arithmetic-operation-specialization\">Arithmetic Operation Specialization</h4>\n<p><strong>Mental Model:</strong> Operation specialization creates <strong>fast paths</strong> for common cases—like having a special &quot;add integers&quot; circuit in a calculator instead of using the general &quot;add floating point&quot; logic every time.</p>\n<p><strong>Current Implementation:</strong> All numbers are <code>Double</code>, all arithmetic uses Java&#39;s double operators. This is simple but inefficient for integer-heavy code.</p>\n<p><strong>Optimizations:</strong></p>\n<ol>\n<li><strong>Integer Detection:</strong> If both operands are integers (no decimal part), use integer arithmetic</li>\n<li><strong>Type Tagging:</strong> Store numbers as <code>long</code> with type tag in low bits (NaN-boxing)</li>\n<li><strong>Specialized Ops:</strong> <code>ADD_INT</code>, <code>SUBTRACT_INT</code> bytecode instructions (if moving to VM)</li>\n</ol>\n<p><strong>Simple Approach:</strong> In <code>visitBinaryExpr</code>, check if both operands are integers (use <code>Math.floor()</code> comparison), perform integer arithmetic, convert back to double. Avoids floating point rounding for integer cases.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension</th>\n<th>Simple Implementation</th>\n<th>Advanced Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>REPL</strong></td>\n<td><code>java.util.Scanner</code> for line input</td>\n<td>JLine3 for history, completion, editing</td>\n</tr>\n<tr>\n<td><strong>Standard Library</strong></td>\n<td>Static methods in <code>LoxStdLib</code> class</td>\n<td>Dynamic loading via service provider interface</td>\n</tr>\n<tr>\n<td><strong>Native Functions</strong></td>\n<td>Hardcoded registry of <code>LoxCallable</code></td>\n<td>Reflection-based discovery with annotations</td>\n</tr>\n<tr>\n<td><strong>Arrays</strong></td>\n<td><code>LoxArray</code> with <code>ArrayList&lt;Object&gt;</code> backend</td>\n<td>Custom resizable array with type tagging</td>\n</tr>\n<tr>\n<td><strong>Bytecode VM</strong></td>\n<td>Stack VM with 30-40 opcodes</td>\n<td>Register VM with optimization passes</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure-for-extensions\">Recommended File Structure for Extensions</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lox/\n├── interpreter/          # Core interpreter (existing)\n│   ├── Interpreter.java\n│   ├── Environment.java\n│   └── ...\n├── extensions/           # New directory for optional extensions\n│   ├── repl/\n│   │   ├── Repl.java              # Enhanced REPL with continuation\n│   │   └── LineBuffer.java        # Multi-line input buffer\n│   ├── stdlib/\n│   │   ├── LoxStdLib.java         # Standard function registry\n│   │   ├── MathFunctions.java     # sqrt, sin, random\n│   │   ├── StringFunctions.java   # length, substring\n│   │   └── TypeFunctions.java     # typeOf, toString\n│   ├── native/\n│   │   ├── NativeRegistry.java    # Maps names to native functions\n│   │   ├── FileNative.java        # File I/O functions\n│   │   └── TimeNative.java        # Time/date functions\n│   ├── arrays/\n│   │   ├── LoxArray.java          # Array runtime type\n│   │   └── ArrayCompiler.java     # Compiler for [ ] syntax\n│   └── vm/                         # Bytecode VM extension\n│       ├── OpCode.java\n│       ├── Chunk.java\n│       ├── VM.java\n│       └── Compiler.java\n└── Lox.java              # Modified to load extensions</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-native-function-interface\">Infrastructure Starter Code: Native Function Interface</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// extensions/native/NativeCallable.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox.extensions.</span><span style=\"color:#FDAEB7;font-style:italic\">native</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.Interpreter;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Interface for native (Java-implemented) functions callable from Lox.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * All standard library and extension functions implement this.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> NativeCallable</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Number of arguments this function expects.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> arity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Call the function with the given arguments.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> interpreter</span><span style=\"color:#6A737D\"> The current interpreter context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> arguments</span><span style=\"color:#6A737D\"> The evaluated argument values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> The function's result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Object </span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">(Interpreter </span><span style=\"color:#FFAB70\">interpreter</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Human-readable name for debugging.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">name</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> getClass</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">getSimpleName</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// extensions/native/NativeRegistry.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox.extensions.</span><span style=\"color:#FDAEB7;font-style:italic\">native</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.Environment;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.HashMap;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Map;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Registry of all available native functions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Populates the global environment with these functions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> NativeRegistry</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Map&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">NativeCallable</span><span style=\"color:#E1E4E8\">> functions </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> HashMap&#x3C;>();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> NativeRegistry</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Register core standard library</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        register</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"clock\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> ClockFunction</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        register</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sqrt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> MathFunction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sqrt\"</span><span style=\"color:#E1E4E8\">, Math</span><span style=\"color:#F97583\">::</span><span style=\"color:#E1E4E8\">sqrt));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ... more registrations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> register</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, NativeCallable </span><span style=\"color:#FFAB70\">function</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        functions.</span><span style=\"color:#B392F0\">put</span><span style=\"color:#E1E4E8\">(name, function);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> installInto</span><span style=\"color:#E1E4E8\">(Environment </span><span style=\"color:#FFAB70\">globals</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Wrap each NativeCallable in a LoxCallable adapter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (Map.Entry&#x3C;</span><span style=\"color:#F97583\">String</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">NativeCallable</span><span style=\"color:#E1E4E8\">> entry </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> functions.</span><span style=\"color:#B392F0\">entrySet</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            globals.</span><span style=\"color:#B392F0\">define</span><span style=\"color:#E1E4E8\">(entry.</span><span style=\"color:#B392F0\">getKey</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> NativeAdapter</span><span style=\"color:#E1E4E8\">(entry.</span><span style=\"color:#B392F0\">getValue</span><span style=\"color:#E1E4E8\">()));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Adapter that makes NativeCallable work with existing LoxCallable interface.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> static</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> NativeAdapter</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#E1E4E8\"> lox.</span><span style=\"color:#B392F0\">LoxCallable</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> NativeCallable nativeFn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        NativeAdapter</span><span style=\"color:#E1E4E8\">(NativeCallable </span><span style=\"color:#FFAB70\">nativeFn</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.nativeFn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nativeFn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> arity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> nativeFn.</span><span style=\"color:#B392F0\">arity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">(Interpreter </span><span style=\"color:#FFAB70\">interpreter</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> nativeFn.</span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">(interpreter, arguments);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        public</span><span style=\"color:#E1E4E8\"> String </span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"&#x3C;native fn \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> nativeFn.</span><span style=\"color:#B392F0\">name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example native function: clock() returns seconds since epoch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ClockFunction</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> NativeCallable</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> arity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">// clock() takes no arguments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Object </span><span style=\"color:#B392F0\">call</span><span style=\"color:#E1E4E8\">(Interpreter </span><span style=\"color:#FFAB70\">interpreter</span><span style=\"color:#E1E4E8\">, List&#x3C;</span><span style=\"color:#F97583\">Object</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Return as Lox number (double)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">) System.</span><span style=\"color:#B392F0\">currentTimeMillis</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-constant-folding-optimizer\">Core Logic Skeleton: Constant Folding Optimizer</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// extensions/optimization/ConstantFolder.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox.extensions.optimization;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.Stmt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * AST optimizer that performs constant folding.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Replaces constant expressions with their computed values.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ConstantFolder</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> Expr.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Expr</span><span style=\"color:#E1E4E8\">>, </span><span style=\"color:#B392F0\">Stmt.Visitor</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Implement visitBinaryExpr to fold constant binary operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Recursively fold left and right operands first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check if both are Literal nodes after folding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If yes, compute result based on operator:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        PLUS: add values (handle string concatenation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        MINUS, STAR, SLASH: arithmetic (check division by zero)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        GREATER, LESS, etc.: comparisons</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return new Literal with computed value, or original if not foldable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    @</span><span style=\"color:#F97583\">Override</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> Expr </span><span style=\"color:#B392F0\">visitBinaryExpr</span><span style=\"color:#E1E4E8\">(Expr.Binary </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1.1: Fold left operand</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Expr left </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expr.left.</span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1.2: Fold right operand  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Expr right </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expr.right.</span><span style=\"color:#B392F0\">accept</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1.3: Check if both are Literal after folding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (left </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Expr.Literal </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> right </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Expr.Literal) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Object leftVal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((Expr.Literal) left).value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Object rightVal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((Expr.Literal) right).value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1.4: Based on operator type, compute result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            switch</span><span style=\"color:#E1E4E8\"> (expr.operator.type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                case</span><span style=\"color:#E1E4E8\"> PLUS</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // TODO: Handle number addition and string concatenation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                case</span><span style=\"color:#E1E4E8\"> MINUS</span><span style=\"color:#F97583\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // TODO: Check both are numbers, subtract</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // ... handle other operators</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1.5: If folded, return new Literal, otherwise new Binary with folded children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Implement visitUnaryExpr for - and ! on literals</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Implement visitGroupingExpr to fold grouped expressions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Implement visitLogicalExpr with short-circuit awareness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Fold left first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If left is literal and operator is OR with truthy left, return left</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If left is literal and operator is AND with falsy left, return left</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Otherwise fold right and rebuild</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Implement statement visitors to fold expressions within statements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   visitPrintStmt, visitVarStmt, visitIfStmt, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Add main fold() method that processes a list of statements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#E1E4E8\"> List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">fold</span><span style=\"color:#E1E4E8\">(List&#x3C;</span><span style=\"color:#F97583\">Stmt</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">statements</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Apply visitor to each statement, collect results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper method to check if value is numeric</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isNumber</span><span style=\"color:#E1E4E8\">(Object </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#E1E4E8\"> Double;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Helper method to check if expression is pure (no side effects)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Used to decide if folding is safe</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isPure</span><span style=\"color:#E1E4E8\">(Expr </span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Walk expression tree, return false if contains:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Variable expressions (values unknown at compile time)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Function calls (may have side effects)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Assignments (side effects)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-repl-with-continuation\">Core Logic Skeleton: REPL with Continuation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// extensions/repl/Repl.java</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#E1E4E8\"> lox.extensions.repl;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> lox.</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.Scanner;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.ArrayList;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> java.util.List;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Enhanced REPL with multi-line input support.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Repl</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Interpreter interpreter;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> Scanner scanner;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> hadError </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#E1E4E8\"> inMultilineMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> final</span><span style=\"color:#E1E4E8\"> StringBuilder multilineBuffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> StringBuilder</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> Repl</span><span style=\"color:#E1E4E8\">(Interpreter </span><span style=\"color:#FFAB70\">interpreter</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> interpreter;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.scanner </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Scanner</span><span style=\"color:#E1E4E8\">(System.in);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Lox REPL (type 'exit' to quit)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Display appropriate prompt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            String prompt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inMultilineMode </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"... > \"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"> \"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">print</span><span style=\"color:#E1E4E8\">(prompt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Read line, handle EOF (Ctrl+D)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">scanner.</span><span style=\"color:#B392F0\">hasNextLine</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            String line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> scanner.</span><span style=\"color:#B392F0\">nextLine</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Check for exit command</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (line.</span><span style=\"color:#B392F0\">equals</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"exit\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> line.</span><span style=\"color:#B392F0\">equals</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"quit\"</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Handle empty line in multiline mode (ends input)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (inMultilineMode </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> line.</span><span style=\"color:#B392F0\">isEmpty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                processBuffer</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Append to buffer (with newline if in multiline mode)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (inMultilineMode) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                multilineBuffer.</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(line).</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                multilineBuffer.</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 6: Try to parse current buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                run</span><span style=\"color:#E1E4E8\">(multilineBuffer.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Success: reset state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                multilineBuffer.</span><span style=\"color:#B392F0\">setLength</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                inMultilineMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (ParseError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 7: Check if error is due to incomplete input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                //   - If at EOF and expecting more tokens (like unclosed brace)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                //   - Set inMultilineMode = true and continue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                //   - Otherwise, report error and reset</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isIncompleteError</span><span style=\"color:#E1E4E8\">(error)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    inMultilineMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Report error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    multilineBuffer.</span><span style=\"color:#B392F0\">setLength</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    inMultilineMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scanner.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(String </span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Use existing Lox.run() logic but don't exit on error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Create scanner, parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Parse statements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - If parse error, throw</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Execute with interpreter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Catch runtime errors, print but don't exit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> boolean</span><span style=\"color:#B392F0\"> isIncompleteError</span><span style=\"color:#E1E4E8\">(ParseError </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Heuristic: error message contains \"expect\" and token is EOF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   or unclosed delimiter {, (, [</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> processBuffer</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Force parse attempt even with empty line continuation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            run</span><span style=\"color:#E1E4E8\">(multilineBuffer.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (ParseError </span><span style=\"color:#FFAB70\">e</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Give up on this input</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            System.out.</span><span style=\"color:#B392F0\">println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Syntax error: \"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> e.</span><span style=\"color:#B392F0\">getMessage</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">finally</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            multilineBuffer.</span><span style=\"color:#B392F0\">setLength</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            inMultilineMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-java\">Language-Specific Hints (Java)</h4>\n<ol>\n<li><strong>REPL Input:</strong> Use <code>java.util.Scanner</code> for simplicity, but it doesn&#39;t support arrow keys or history. For better UX, consider <code>jline3</code> dependency:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   LineReader reader </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LineReaderBuilder.</span><span style=\"color:#B392F0\">builder</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">build</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   String line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reader.</span><span style=\"color:#B392F0\">readLine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"> \"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><p><strong>Native-Java Integration:</strong> For exposing Java objects to Lox, use the <code>invoke</code> method from <code>java.lang.reflect</code> but beware of security and complexity. Better to create explicit wrapper classes for safety.</p>\n</li>\n<li><p><strong>Performance Measurement:</strong> Use <code>System.nanoTime()</code> before/after execution to benchmark optimizations:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">java</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   long</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> System.</span><span style=\"color:#B392F0\">nanoTime</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   interpreter.</span><span style=\"color:#B392F0\">interpret</span><span style=\"color:#E1E4E8\">(statements);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   long</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> System.</span><span style=\"color:#B392F0\">nanoTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   System.out.</span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Executed in %.2f ms%n\"</span><span style=\"color:#E1E4E8\">, elapsed </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1_000_000.0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Memory Profiling:</strong> For array/string interning, consider using <code>java.lang.ref.SoftReference</code> for cache entries that can be GC&#39;d under memory pressure.</li>\n</ol>\n<h4 id=\"milestone-checkpoints-for-extensions\">Milestone Checkpoints for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Extension</th>\n<th>Verification Command</th>\n<th>Expected Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>REPL</strong></td>\n<td>Run <code>java Lox</code> (no args)</td>\n<td>Shows <code>&gt;</code> prompt, executes <code>print 1+2;</code> prints <code>3</code></td>\n</tr>\n<tr>\n<td><strong>Standard Library</strong></td>\n<td><code>print clock();</code></td>\n<td>Prints current timestamp (number)</td>\n</tr>\n<tr>\n<td><strong>Arrays</strong></td>\n<td><code>var a = [1, 2, 3]; print a[1];</code></td>\n<td>Prints <code>2</code></td>\n</tr>\n<tr>\n<td><strong>Constant Folding</strong></td>\n<td>Test with <code>print 2 * 3 + 4 * 5;</code></td>\n<td>Prints <code>26</code>, check AST shows single literal</td>\n</tr>\n<tr>\n<td><strong>Native Functions</strong></td>\n<td><code>fun readFile(path) { ... }</code> (native)</td>\n<td>Can read and print file contents</td>\n</tr>\n</tbody></table>\n<h4 id=\"debugging-tips-for-extensions\">Debugging Tips for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>REPL exits after one line</strong></td>\n<td>Scanner reading full input as one line</td>\n<td>Add debug print of raw input string</td>\n<td>Use <code>Scanner.nextLine()</code> correctly</td>\n</tr>\n<tr>\n<td><strong>Native function returns wrong type</strong></td>\n<td>Marshalling between Java/Lox types incorrect</td>\n<td>Print Java value before returning</td>\n<td>Ensure numbers as Double, strings as LoxString</td>\n</tr>\n<tr>\n<td><strong>Constant folding changes program behavior</strong></td>\n<td>Folded expression with side effects</td>\n<td>Check <code>isPure()</code> heuristic</td>\n<td>Don&#39;t fold function calls or variable accesses</td>\n</tr>\n<tr>\n<td><strong>Array index out of bounds</strong></td>\n<td>No bounds checking in <code>LoxArray.get()</code></td>\n<td>Add check before array access</td>\n<td>Throw <code>RuntimeError</code> with index and length</td>\n</tr>\n<tr>\n<td><strong>Memory leak with string interning</strong></td>\n<td>Interning pool never clears entries</td>\n<td>Monitor heap usage with VisualVM</td>\n<td>Use <code>WeakHashMap</code> or limit to literals</td>\n</tr>\n<tr>\n<td><strong>Tail recursion still overflows stack</strong></td>\n<td>TCO not detecting all tail calls</td>\n<td>Add debug log of call frame creation</td>\n<td>Check <code>return func(args)</code> in tail position</td>\n</tr>\n<tr>\n<td><strong>Method cache returns wrong method</strong></td>\n<td>Cache not invalidated on class redefinition</td>\n<td>Print cache hits/misses</td>\n<td>Clear cache in <code>visitClassStmt</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-glossary\">11. Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (reference section)</p>\n</blockquote>\n<p>This glossary provides definitions for the key technical terms, acronyms, and domain-specific vocabulary used throughout this design document. Terms are organized alphabetically for easy reference.</p>\n<h3 id=\"a\">A</h3>\n<p><strong>Abstract Syntax Tree (AST)</strong>\nA hierarchical tree representation of the grammatical structure of source code, where each node corresponds to a language construct (expression, statement) and child nodes represent its components. The AST discards surface syntax details like parentheses and whitespace, focusing on the essential syntactic relationships.</p>\n<p><strong>Arity</strong>\nThe number of parameters a function or callable expects. In Lox, functions have a fixed arity determined by their parameter list declaration. The <code>LoxFunction.arity()</code> method returns this value, enabling the interpreter to check argument counts before calling.</p>\n<p><strong>Array</strong>\nAn indexed collection data type that stores elements in a contiguous, numerically-indexed sequence. While not in the base Lox language described in &quot;Crafting Interpreters,&quot; it&#39;s a common extension where arrays support operations like getting, setting, and checking length.</p>\n<p><strong>AST Node Classes</strong>\nThe concrete Java classes that implement the <code>Expr</code> and <code>Stmt</code> interfaces, representing specific language constructs in the AST. Examples include <code>Binary</code> (for binary operations), <code>Unary</code> (for unary operations), <code>Literal</code> (for literal values), <code>If</code> (for conditional statements), and <code>Function</code> (for function declarations).</p>\n<p><strong>AST Printer</strong>\nA visitor implementation that converts an AST to a human-readable string representation, typically using parenthesized S-expression notation. Useful for debugging the parser by visualizing the structure it produces.</p>\n<h3 id=\"b\">B</h3>\n<p><strong>Binary Expression</strong>\nAn expression with two operands and a single operator between them, such as <code>1 + 2</code> or <code>x &lt; y</code>. Represented by the <code>Binary</code> AST node with <code>left</code>, <code>operator</code>, and <code>right</code> fields.</p>\n<p><strong>Block</strong>\nA sequence of statements enclosed in curly braces <code>{}</code> that creates a new lexical scope. Represented by the <code>Block</code> AST node containing a list of statements. When executed, it creates a new nested <code>Environment</code>.</p>\n<p><strong>Boolean</strong>\nA primitive truth value in Lox, either <code>true</code> or <code>false</code>. Represented at runtime as a <code>LoxBoolean</code> object wrapping a Java <code>Boolean</code>. Subject to Lox&#39;s truthiness rules in conditional contexts.</p>\n<p><strong>Break Statement</strong>\nA control flow statement that immediately terminates execution of the innermost enclosing loop. While not in the base Lox language, it&#39;s a common extension implemented via a <code>BreakException</code> that unwinds the call stack until caught by the loop&#39;s execution machinery.</p>\n<p><strong>Bytecode</strong>\nA compact, intermediate representation of a program designed for efficient execution by a virtual machine. Each instruction (opcode) typically performs a simple operation like push constant, add, or jump. Contrasts with tree-walking interpretation, which directly traverses the AST.</p>\n<h3 id=\"c\">C</h3>\n<p><strong>Call</strong>\nThe act of invoking a function, method, or class constructor with arguments. Represented by the <code>Call</code> AST node with <code>callee</code> (the function expression), <code>paren</code> (the closing parenthesis token for error reporting), and <code>arguments</code> (list of argument expressions).</p>\n<p><strong>Chunk</strong>\nIn bytecode interpreter architectures, a container for a sequence of bytecode instructions and their associated constant pool. The <code>Chunk</code> class stores the instruction stream and constant values referenced by those instructions.</p>\n<p><strong>Class</strong>\nA blueprint for creating objects (instances) that encapsulates data (fields) and behavior (methods). In Lox, a class declaration creates a <code>LoxClass</code> object that can be called as a constructor to create <code>LoxInstance</code> objects. Classes support single inheritance via the <code>&lt;</code> syntax.</p>\n<p><strong>Closure</strong>\nA first-class function value that &quot;closes over&quot; (captures) variables from its lexical (surrounding) scope, maintaining access to those variables even after the enclosing function has returned. Implemented by storing a reference to the function&#39;s defining <code>Environment</code> within the <code>LoxFunction</code> object.</p>\n<p><strong>Comparison Operators</strong>\nBinary operators that compare two values and return a boolean: <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than or equal), <code>&gt;=</code> (greater than or equal). These have higher precedence than equality operators but lower than addition/subtraction.</p>\n<p><strong>Constant Folding</strong>\nA compiler optimization that evaluates constant expressions at compile time (parse time) rather than runtime. For example, the expression <code>3 + 4 * 2</code> can be computed once as <code>11</code> and replaced with a literal <code>11</code> in the AST, reducing runtime work.</p>\n<p><strong>Continue Statement</strong>\nA control flow statement that immediately skips to the next iteration of the innermost enclosing loop. While not in the base Lox language, it&#39;s a common extension implemented via a <code>ContinueException</code> caught by the loop execution.</p>\n<h3 id=\"d\">D</h3>\n<p><strong>Deep Equality</strong>\nAn equality comparison that compares the semantic value of objects rather than their object identity (reference equality). In Lox, <code>isEqual()</code> handles special cases: numbers are compared with a tolerance for floating-point errors, strings by character content, and <code>nil</code> equals only itself.</p>\n<p><strong>Defining Environment</strong>\nThe <code>Environment</code> that was active when a function was declared, captured by closures to provide lexical scoping. When a closure is called, this environment becomes the parent of the call&#39;s new environment, allowing access to outer variables.</p>\n<p><strong>Desugaring</strong>\nThe process of transforming higher-level syntactic constructs into lower-level primitive constructs. In Lox, <code>for</code> loops are desugared into equivalent <code>while</code> loop constructs with initialization and increment statements, simplifying the interpreter&#39;s implementation.</p>\n<p><strong>Division by Zero</strong>\nA runtime error that occurs when the right operand of a division (<code>/</code>) operator evaluates to zero. The interpreter detects this and raises a <code>RuntimeError</code> with an appropriate message, halting execution.</p>\n<p><strong>Double Dispatch</strong>\nA technique where an operation&#39;s behavior is determined by both the type of the receiver and the type of the argument. The Visitor pattern uses double dispatch: the AST node&#39;s <code>accept()</code> method calls the appropriate <code>visitXxx()</code> method on the visitor, selecting based on both the visitor type and the node type.</p>\n<p><strong>Dynamic Typing</strong>\nA type system where values carry their type information at runtime, and type checking occurs during program execution rather than compile time. Lox is dynamically typed: variables have no declared type, and operations check operand types at evaluation time.</p>\n<h3 id=\"e\">E</h3>\n<p><strong>End-of-file (EOF)</strong>\nA special token type (<code>EOF</code>) that marks the end of the source code input. The scanner adds this token after processing all characters, and the parser uses it to know when to stop parsing.</p>\n<p><strong>Environment</strong>\nA runtime data structure that maps variable names to their current values within a specific lexical scope. Implemented as the <code>Environment</code> class with a <code>values</code> hash map and an optional reference to an <code>enclosing</code> parent environment, forming a chain for variable resolution.</p>\n<p><strong>Environment Chain</strong>\nThe linked list of <code>Environment</code> objects representing nested lexical scopes, from the current local scope outward through enclosing function scopes to the global scope. Variable lookup proceeds up this chain until finding the name or reaching the global scope without it (causing a runtime error).</p>\n<p><strong>Environment Dumper</strong>\nA debugging utility that prints all variable bindings in the environment chain, typically with indentation to show nesting. Helps diagnose scoping issues by revealing which variables are defined in each scope and their current values.</p>\n<p><strong>Environment Flattening</strong>\nAn optimization technique that converts the chain of linked <code>Environment</code> objects into a flat array indexed by scope depth and variable slot, reducing variable lookup from O(n) in chain length to O(1) array access. Used in more advanced interpreters and compilers.</p>\n<p><strong>Equality Operators</strong>\nBinary operators that test for equality (<code>==</code>) or inequality (<code>!=</code>) between two values. These have the lowest precedence among comparison operators and implement Lox&#39;s deep equality semantics.</p>\n<p><strong>Exception</strong>\nA special value or object that can be &quot;thrown&quot; to signal an error or exceptional condition and &quot;caught&quot; by exception handling code. While not in base Lox, extensions might add <code>try</code>/<code>catch</code> statements with <code>Exception</code> objects carrying error information.</p>\n<p><strong>Execution Log</strong>\nA debug trace of the interpreter&#39;s step-by-step evaluation, showing which AST nodes are visited, what values they produce, and how the environment changes. Implemented by adding logging statements to visitor methods, often controlled by a <code>DEBUG</code> flag.</p>\n<p><strong>Expression</strong>\nA piece of syntax that produces a value when evaluated. Examples include literals (<code>5</code>, <code>&quot;hello&quot;</code>), variable references (<code>x</code>), arithmetic operations (<code>a + b</code>), and function calls (<code>f(3)</code>). Represented by the <code>Expr</code> abstract class and its concrete subclasses.</p>\n<p><strong>Expression Statement</strong>\nA statement that consists solely of an expression followed by a semicolon. The expression is evaluated for its side effects (like assignment or function calls), and the resulting value is discarded. Represented by the <code>Expression</code> AST node.</p>\n<h3 id=\"f\">F</h3>\n<p><strong>Fail-Fast</strong>\nAn error handling strategy where the interpreter halts execution immediately upon detecting a semantic violation (type mismatch, undefined variable, etc.), rather than attempting to continue with potentially corrupted state. Lox uses fail-fast for runtime errors.</p>\n<p><strong>Field</strong>\nA named property stored on a class instance (<code>LoxInstance</code>), accessible via dot notation (<code>instance.field</code>). Fields are dynamically created when assigned to and stored in the instance&#39;s <code>fields</code> hash map, separate from methods defined on the class.</p>\n<p><strong>First-Class Function</strong>\nA function that can be treated like any other value: assigned to variables, passed as arguments to other functions, returned from functions, and stored in data structures. Lox functions are first-class, implemented as <code>LoxFunction</code> objects.</p>\n<p><strong>For Loop</strong>\nA control flow statement with initialization, condition, and increment expressions: <code>for (var i = 0; i &lt; 10; i = i + 1) { ... }</code>. In Lox, this is desugared into a block containing the initializer, a <code>while</code> loop with the condition, and the increment as the last statement in the loop body.</p>\n<p><strong>Foreign Function Interface (FFI)</strong>\nA mechanism for calling functions implemented in the host language (Java) from Lox code. Typically implemented via a <code>NativeCallable</code> interface and a <code>NativeRegistry</code> that maps names to native implementations, which can then be installed into the global environment.</p>\n<p><strong>Function</strong>\nA reusable block of code that takes parameters, performs computations, and optionally returns a value. In Lox, functions are declared with the <code>fun</code> keyword, creating a <code>LoxFunction</code> object that captures its defining environment (for closures). Functions are called with arguments bound to parameters in a new environment.</p>\n<p><strong>Function Call</strong>\nThe runtime operation of invoking a function with concrete argument values. The interpreter evaluates the argument expressions, creates a new <code>Environment</code> with the function&#39;s closure environment as parent, binds parameters to argument values, and executes the function body.</p>\n<h3 id=\"g\">G</h3>\n<p><strong>Grammar Rules</strong>\nThe formal specification that defines which sequences of tokens constitute syntactically valid programs in the language. Expressed in a notation like Backus-Naur Form (BNF) or Parsing Expression Grammar (PEG), these rules guide the recursive descent parser&#39;s implementation.</p>\n<p><strong>Grouping Expression</strong>\nAn expression wrapped in parentheses <code>(expr)</code>, used to explicitly control operator precedence. Represented by the <code>Grouping</code> AST node with a single <code>expression</code> child. The parser handles grouping by matching <code>(</code> tokens and recursively parsing the inner expression.</p>\n<h3 id=\"h\">H</h3>\n<p><strong>High-Level Architecture</strong>\nThe macro-organization of the interpreter system into major components (Scanner, Parser, Interpreter) and their data flow relationships, as described in Section 3. This architecture defines the pipeline from source text to execution output.</p>\n<h3 id=\"i\">I</h3>\n<p><strong>Identifier</strong>\nA token representing a name defined by the programmer, such as a variable, function, or class name. The <code>IDENTIFIER</code> token type encompasses all names that aren&#39;t language keywords. Identifiers follow specific lexical rules (starting with letter/underscore, containing letters/numbers/underscores).</p>\n<p><strong>If/Else Statement</strong>\nA conditional control flow statement that executes one of two branches based on a condition&#39;s truthiness: <code>if (condition) thenBranch else elseBranch</code>. The <code>else</code> clause is optional. Represented by the <code>If</code> AST node with <code>condition</code>, <code>thenBranch</code>, and optional <code>elseBranch</code> fields.</p>\n<p><strong>Import Statement</strong>\nA statement that loads and executes code from another module, typically making its exported definitions available in the current scope. While not in base Lox, extensions might add <code>import</code> statements that load Lox source files and return a module object.</p>\n<p><strong>Inheritance</strong>\nThe mechanism by which a class (the subclass or derived class) acquires properties and methods from another class (the superclass or base class). Lox supports single inheritance via the <code>&lt;</code> syntax in class declarations. Method resolution proceeds up the inheritance chain.</p>\n<p><strong>Initializer</strong>\nA special method named <code>init</code> defined inside a class that is automatically called when an instance is created (via the class constructor call). It receives the constructor arguments and can perform setup, including calling <code>super.init()</code> for inheritance chains.</p>\n<p><strong>Instance</strong>\nA runtime object created from a class blueprint, with its own set of fields (stored in <code>LoxInstance.fields</code>) and access to methods defined on its class (via <code>LoxClass.methods</code>). Created by calling the class as a constructor function.</p>\n<p><strong>Interpreter</strong>\nThe core execution engine that walks the AST and performs the operations it represents. In this design, the <code>Interpreter</code> class implements the <code>Expr.Visitor&lt;Object&gt;</code> and <code>Stmt.Visitor&lt;Void&gt;</code> interfaces, providing <code>visitXxx()</code> methods that define the semantics for each AST node type.</p>\n<h3 id=\"j\">J</h3>\n<p><strong>JIT Compilation (Just-In-Time Compilation)</strong>\nAn advanced optimization technique where bytecode or AST is compiled to native machine code at runtime, just before execution, potentially yielding significant performance gains. Contrasts with ahead-of-time compilation and pure interpretation.</p>\n<h3 id=\"k\">K</h3>\n<p><strong>Keyword</strong>\nA reserved word in the language with special syntactic meaning, such as <code>var</code>, <code>fun</code>, <code>if</code>, <code>while</code>, <code>class</code>, etc. The scanner recognizes keywords and emits corresponding token types (e.g., <code>VAR</code>, <code>FUN</code>, <code>IF</code>) rather than <code>IDENTIFIER</code> tokens.</p>\n<h3 id=\"l\">L</h3>\n<p><strong>Left-Recursive Grammar</strong>\nA grammar rule where the leftmost symbol in a production is the nonterminal being defined, e.g., <code>expression → expression + term</code>. Naive recursive descent parsers get stuck in infinite recursion with left-recursive rules, requiring transformation to right-recursive or iterative forms.</p>\n<p><strong>Lexeme</strong>\nThe raw character sequence (text) of a token as it appears in the source code. For example, in the token for the number <code>123.45</code>, the lexeme is the string <code>&quot;123.45&quot;</code>. Stored in the <code>Token.lexeme</code> field for debugging and error reporting.</p>\n<p><strong>Lexical Analysis</strong>\nThe process of converting a sequence of characters (source code) into a sequence of meaningful tokens, performed by the scanner/lexer. This includes recognizing identifiers, keywords, literals, and operators while ignoring whitespace and comments.</p>\n<p><strong>Lexical Scoping</strong>\nA scoping discipline where variable visibility is determined by the textual (lexical) structure of the source code: a variable is visible within the block where it&#39;s defined and any nested blocks, but not in enclosing or sibling blocks. Lox uses lexical scoping for variables and closures.</p>\n<p><strong>Lexer</strong>\nSynonym for Scanner. See <strong>Scanner</strong>.</p>\n<p><strong>Literal</strong>\nA token representing a constant value directly written in source code: number literals (<code>123</code>, <code>3.14</code>), string literals (<code>&quot;hello&quot;</code>), boolean literals (<code>true</code>, <code>false</code>), and <code>nil</code>. The scanner extracts the runtime value (Java <code>Double</code>, <code>String</code>, <code>Boolean</code>, or <code>LoxNil</code>) and stores it in <code>Token.literal</code>.</p>\n<p><strong>Logical Operators</strong>\nThe <code>and</code> and <code>or</code> operators that combine boolean expressions with short-circuit evaluation. <code>and</code> returns the left operand if it&#39;s falsy (short-circuit), otherwise evaluates and returns the right operand. <code>or</code> returns the left operand if it&#39;s truthy (short-circuit), otherwise evaluates and returns the right operand.</p>\n<p><strong>Lox</strong>\nThe programming language being implemented in this project—a small, dynamically-typed, object-oriented language with C-like syntax, designed by Bob Nystrom for educational purposes in &quot;Crafting Interpreters.&quot;</p>\n<p><strong>LoxCallable</strong>\nA Java interface implemented by all callable entities in Lox: functions (<code>LoxFunction</code>), classes (<code>LoxClass</code>), and potentially native functions (<code>NativeCallable</code>). Defines <code>call()</code> and <code>arity()</code> methods that the interpreter uses uniformly.</p>\n<p><strong>LoxClass</strong>\nThe runtime representation of a class, created when a class declaration is evaluated. Stores the class <code>name</code>, its <code>methods</code> (including <code>init</code>), and optional <code>superclass</code>. When called as a function, creates a new <code>LoxInstance</code> and invokes the initializer.</p>\n<p><strong>LoxFunction</strong>\nThe runtime representation of a function, created when a function declaration is evaluated or a lambda is created. Stores the function&#39;s AST node (<code>declaration</code>), its <code>closure</code> (defining environment), and an <code>isInitializer</code> flag for distinguishing <code>init</code> methods.</p>\n<p><strong>LoxInstance</strong>\nThe runtime representation of a class instance, created by calling a <code>LoxClass</code>. Stores a reference to its <code>klass</code> (for method lookup) and a map of <code>fields</code> (instance-specific data). Provides <code>get()</code> and <code>set()</code> methods for property access.</p>\n<p><strong>LoxNil</strong>\nThe runtime representation of Lox&#39;s <code>nil</code> value, a singleton object indicating absence of meaningful value. Used as the default initializer value for variable declarations without explicit initializers and as the implicit return value from functions without <code>return</code> statements.</p>\n<h3 id=\"m\">M</h3>\n<p><strong>Mental Model</strong>\nAn intuitive analogy or conceptual framework that helps understand a complex system before delving into technical details. Used throughout this design document to bridge from &quot;what it feels like&quot; to &quot;how it actually works&quot; for each component.</p>\n<p><strong>Method</strong>\nA function defined within a class body, implicitly bound to instances of that class. When called on an instance, the <code>this</code> keyword within the method body refers to that instance. Methods are stored in the <code>LoxClass.methods</code> map and accessed via dot notation.</p>\n<p><strong>Method Caching</strong>\nAn optimization where the result of method lookup (resolving a method name to a specific <code>LoxFunction</code> in the class hierarchy) is cached at the call site, avoiding repeated traversal of the inheritance chain on subsequent calls with the same receiver type.</p>\n<p><strong>Method Resolution Order</strong>\nThe order in which classes are searched when looking up a method on an instance. In Lox&#39;s single inheritance: first check the instance&#39;s class, then its superclass, then the superclass&#39;s superclass, etc., until finding the method or reaching the top (causing a runtime error).</p>\n<p><strong>Module</strong>\nA self-contained unit of code with its own environment, potentially exporting some definitions for use by importing code. While not in base Lox, extensions might add modules to support larger programs and code organization, implemented as <code>LoxModule</code> runtime objects.</p>\n<h3 id=\"n\">N</h3>\n<p><strong>Native Function</strong>\nA function implemented in the host language (Java) rather than Lox, exposed to Lox programs via the FFI. Useful for providing I/O, mathematical functions, or other capabilities difficult or inefficient to implement in pure Lox.</p>\n<p><strong>Nil</strong>\nLox&#39;s null/none value, written as the keyword <code>nil</code>. The only value of the <code>LoxNil</code> type, representing absence of meaningful value. In truthiness rules, <code>nil</code> is falsy.</p>\n<p><strong>Number</strong>\nLox&#39;s numeric type, representing double-precision floating-point values (Java <code>Double</code>). Number literals can include optional decimal points (<code>3</code>, <code>3.14</code>). All arithmetic operations work on numbers, with runtime type checking to prevent operations on non-numbers.</p>\n<h3 id=\"o\">O</h3>\n<p><strong>Object</strong>\nIn the context of Lox&#39;s runtime values, any value that can be stored in variables, passed as arguments, or returned from functions. Includes <code>LoxNumber</code>, <code>LoxString</code>, <code>LoxBoolean</code>, <code>LoxNil</code>, <code>LoxFunction</code>, <code>LoxClass</code>, <code>LoxInstance</code>, and potentially <code>LoxArray</code> or <code>LoxModule</code>. Not to be confused with Java&#39;s <code>Object</code> class, though Lox values are represented as Java <code>Object</code> references in the interpreter.</p>\n<p><strong>Operator Precedence</strong>\nRules that determine which operations are performed first in expressions with multiple operators. In Lox, from highest to lowest: grouping <code>()</code>, unary <code>! -</code>, multiplication/division <code>* /</code>, addition/subtraction <code>+ -</code>, comparison <code>&lt; &gt; &lt;= &gt;=</code>, equality <code>== !=</code>, logical <code>and or</code>. The parser implements this via a cascade of recursive methods.</p>\n<p><strong>Optimization Pass</strong>\nA transformation phase applied to the AST or bytecode to improve performance without changing program semantics. Examples include constant folding, dead code elimination, or inlining. Typically run after parsing but before execution.</p>\n<h3 id=\"p\">P</h3>\n<p><strong>Panic-Mode Recovery</strong>\nAn error recovery strategy used by parsers where, upon encountering a syntax error, they discard tokens (panic) until reaching a known synchronization point (like a statement boundary), then continue parsing. This prevents cascading error reports from a single mistake.</p>\n<p><strong>Parameter</strong>\nA variable declared in a function definition that receives a value (argument) when the function is called. Parameters become local variables in the function&#39;s execution environment, initialized with the corresponding argument values.</p>\n<p><strong>Parser</strong>\nThe component that performs syntactic analysis, consuming tokens from the scanner and building an Abstract Syntax Tree according to the language&#39;s grammar rules. Our design uses a recursive descent parser implemented in the <code>Parser</code> class.</p>\n<p><strong>Parsing Expression Grammar (PEG)</strong>\nA formal grammar notation that describes a top-down parser&#39;s recognition process, well-suited for recursive descent parsers. Our expression parsing methods directly correspond to PEG rules for each precedence level.</p>\n<p><strong>Pretty Printer</strong>\nSee <strong>AST Printer</strong>.</p>\n<p><strong>Primary Expression</strong>\nThe most fundamental expressions that serve as building blocks for more complex expressions: literals, identifiers (variables), grouping parentheses, and other atomic forms. Parsed by the <code>primary()</code> method in the recursive descent parser.</p>\n<p><strong>Print Statement</strong>\nA statement that evaluates an expression and outputs its string representation to standard output, followed by a newline. The <code>Print</code> AST node contains the <code>expression</code> to evaluate. Used for program output and debugging.</p>\n<p><strong>Property</strong>\nA field or method accessible on a class instance via dot notation (<code>instance.property</code>). The interpreter handles property access uniformly: first check instance fields, then class methods (including inherited ones), raising a runtime error if neither exists.</p>\n<h3 id=\"r\">R</h3>\n<p><strong>Recursive Descent Parsing</strong>\nA top-down parsing technique where each nonterminal in the grammar is implemented as a function (method) that recursively calls other nonterminal functions. Our parser uses this approach, with methods like <code>expression()</code>, <code>equality()</code>, <code>comparison()</code>, etc., matching the precedence hierarchy.</p>\n<p><strong>Register VM</strong>\nA virtual machine architecture that uses named registers (slots) rather than an operand stack for holding intermediate values. Typically faster but more complex to compile to than stack VMs. Contrasts with the stack VM approach mentioned in future extensions.</p>\n<p><strong>REPL (Read-Eval-Print Loop)</strong>\nAn interactive programming environment that reads input, evaluates it, prints the result, and loops. While not a goal for the base project, a <code>Repl</code> class could be added to allow experimenting with Lox code without writing files.</p>\n<p><strong>Return Statement</strong>\nA statement that immediately exits the current function, optionally providing a value that becomes the function call&#39;s result. The <code>Return</code> AST node contains the <code>keyword</code> token (for error location) and optional <code>value</code> expression. Implemented via a <code>Return</code> exception that unwinds to the call site.</p>\n<p><strong>Runtime Error</strong>\nAn error that occurs during program execution (interpretation), such as type mismatches, undefined variables, division by zero, or calling non-functions. Represented by the <code>RuntimeError</code> exception class with <code>token</code> (location) and <code>message</code> fields. The interpreter catches these and reports them to the user.</p>\n<p><strong>Runtime Value</strong>\nThe concrete data that exists during program execution, representing the result of evaluating expressions. In our implementation, runtime values are Java objects (<code>Double</code>, <code>String</code>, <code>Boolean</code>, <code>LoxNil</code>, <code>LoxFunction</code>, <code>LoxClass</code>, <code>LoxInstance</code>) stored in variables and manipulated by operations.</p>\n<h3 id=\"s\">S</h3>\n<p><strong>Scanner</strong>\nThe component that performs lexical analysis, converting source code (string) into a list of tokens. Also called a lexer. Implemented by the <code>Scanner</code> class with methods to recognize tokens by scanning characters.</p>\n<p><strong>Semantic Analysis</strong>\nThe process of interpreting the meaning of valid syntactic structures, including type checking, variable resolution, and other static validations. In our simple interpreter, much of semantic analysis happens at runtime (dynamic checking), though some occurs during parsing (variable resolution for closures).</p>\n<p><strong>Short-Circuit Evaluation</strong>\nAn optimization where the right operand of a logical operator (<code>and</code>, <code>or</code>) is evaluated only if necessary to determine the result. For <code>and</code>, if the left operand is falsy, the result is the left operand (right not evaluated). For <code>or</code>, if the left operand is truthy, the result is the left operand.</p>\n<p><strong>S-Expression</strong>\nA parenthesized notation for representing tree structures, commonly used in Lisp and for debugging ASTs. Example: <code>(* (+ 1 2) 3)</code> represents the multiplication of <code>(+ 1 2)</code> and <code>3</code>. The <code>AstPrinter</code> produces S-expressions from ASTs.</p>\n<p><strong>Stack VM</strong>\nA virtual machine architecture that uses an operand stack for holding intermediate values and executing instructions (push, pop, operate). Simpler to compile to than register VMs and conceptually similar to the tree-walking evaluator&#39;s implicit call stack.</p>\n<p><strong>Standard Library</strong>\nA collection of built-in functions and types available to all Lox programs without explicit import. While not a goal for the base project, extensions might add a standard library with I/O, mathematical, and utility functions via native functions.</p>\n<p><strong>Statement</strong>\nA piece of syntax that performs an action but doesn&#39;t produce a value (unlike expressions). Examples include variable declarations, print statements, conditionals, loops, and function declarations. Represented by the <code>Stmt</code> abstract class and its concrete subclasses.</p>\n<p><strong>String</strong>\nA sequence of characters, created with double quotes (<code>&quot;hello&quot;</code>) and supporting escape sequences (<code>\\n</code>, <code>\\t</code>, <code>\\&quot;</code>, etc.). Strings can be concatenated with <code>+</code> operator (with any non-string operand converted via <code>stringify()</code>). Represented at runtime as Java <code>String</code> objects.</p>\n<p><strong>String Interning</strong>\nAn optimization where identical strings are stored once in a shared pool and reused, saving memory and enabling fast equality comparison via reference equality. Could be applied to Lox string literals and runtime string values.</p>\n<p><strong>Super</strong>\nA keyword used inside subclass methods to call a method from the superclass, bypassing any override in the subclass. The <code>Super</code> AST node stores the <code>keyword</code> token and <code>method</code> identifier. The interpreter resolves this by looking up the method in the superclass with <code>this</code> bound to the current instance.</p>\n<p><strong>Switch Statement</strong>\nA multi-way conditional statement that compares a value against multiple cases. While not in base Lox, extensions might add <code>switch</code>/<code>case</code>/<code>default</code> statements as syntactic sugar for nested <code>if</code>/<code>else if</code> chains.</p>\n<p><strong>Synchronization Point</strong>\nA token where the parser can safely resume after error recovery in panic mode. Typically statement boundaries (semicolons, closing braces, or keywords like <code>var</code>, <code>fun</code>, <code>class</code>, <code>for</code>, <code>if</code>, <code>while</code>, <code>return</code>). The <code>Parser.synchronize()</code> method skips tokens until reaching one.</p>\n<p><strong>Syntactic Analysis</strong>\nThe process of analyzing a sequence of tokens to determine its grammatical structure according to the language&#39;s grammar rules, producing an AST. Performed by the parser.</p>\n<h3 id=\"t\">T</h3>\n<p><strong>Tail Call Optimization</strong>\nAn optimization where a function call in tail position (the last action before returning) reuses the current stack frame instead of allocating a new one, preventing stack overflow in deeply recursive algorithms. Could be added to the interpreter for functional programming patterns.</p>\n<p><strong>This</strong>\nA keyword referring to the current instance within a method body. The <code>This</code> AST node stores the <code>keyword</code> token. During method calls, the interpreter binds <code>this</code> to the receiving instance by creating a special environment that defines <code>this</code> before executing the method body.</p>\n<p><strong>Token</strong>\nA categorized lexical unit extracted from source code by the scanner. Represented by the <code>Token</code> class with fields: <code>type</code> (a <code>TokenType</code> enum), <code>lexeme</code> (raw text), <code>literal</code> (runtime value for literals), and <code>line</code> (source line number). Tokens are the parser&#39;s input.</p>\n<p><strong>Token Stream Visualizer</strong>\nA debugging utility that prints the list of tokens produced by the scanner, showing type, lexeme, and line numbers. Helps verify the scanner is correctly recognizing tokens before parsing.</p>\n<p><strong>TokenType</strong>\nAn enumeration of all possible token categories in Lox, including punctuation (<code>LEFT_PAREN</code>, <code>COMMA</code>), operators (<code>PLUS</code>, <code>EQUAL_EQUAL</code>), keywords (<code>VAR</code>, <code>FUN</code>), literals (<code>NUMBER</code>, <code>STRING</code>), and special tokens (<code>IDENTIFIER</code>, <code>EOF</code>).</p>\n<p><strong>Tree-Walking Interpreter</strong>\nAn interpreter that executes code by recursively traversing the Abstract Syntax Tree, evaluating each node according to its semantics. Our design uses this approach, contrasting with bytecode interpreters that compile to an intermediate representation first.</p>\n<p><strong>Truthiness</strong>\nThe boolean interpretation of values in conditional contexts (if conditions, while conditions, logical operators). In Lox: <code>false</code> and <code>nil</code> are falsy; everything else (including <code>0</code>, empty string <code>&quot;&quot;</code>, and <code>true</code>) is truthy. The <code>isTruthy()</code> method implements this rule.</p>\n<h3 id=\"u\">U</h3>\n<p><strong>Unary Expression</strong>\nAn expression with a single operator and operand, such as <code>-5</code> or <code>!true</code>. Represented by the <code>Unary</code> AST node with <code>operator</code> and <code>right</code> fields. The parser recognizes unary operators at a higher precedence level than binary operators.</p>\n<p><strong>Upvalue</strong>\nA variable captured from an enclosing scope by a closure. In more advanced implementations, upvalues are specially allocated cells that survive after their declaring function returns, allowing closures to access them. Our design simply captures the entire environment.</p>\n<h3 id=\"v\">V</h3>\n<p><strong>Variable</strong>\nA named storage location that holds a value, declared with <code>var</code> statements. Variables can be accessed by name (via <code>Variable</code> expression node) and reassigned (via <code>Assign</code> expression node). Lookup proceeds through the environment chain following lexical scoping rules.</p>\n<p><strong>Variable Declaration</strong>\nA statement that introduces a new variable into the current scope, optionally with an initializer expression: <code>var x = 5;</code> or <code>var x;</code> (initialized to <code>nil</code>). The <code>Var</code> AST node stores the <code>name</code> token and optional <code>initializer</code> expression.</p>\n<p><strong>Virtual Machine (VM)</strong>\nAn abstract computing machine that executes bytecode instructions, typically implemented in software. In interpreter architectures, a VM provides a faster execution model than tree-walking by compiling to a compact bytecode and using efficient dispatch loops.</p>\n<p><strong>Visitor Pattern</strong>\nA behavioral design pattern that separates operations from the object structure they operate on. In our AST design, the <code>Expr.Visitor&lt;R&gt;</code> and <code>Stmt.Visitor&lt;V&gt;</code> interfaces define operations, and each AST node&#39;s <code>accept()</code> method calls the appropriate <code>visitXxx()</code> method on a visitor, enabling double dispatch without <code>instanceof</code> checks.</p>\n<h3 id=\"w\">W</h3>\n<p><strong>While Loop</strong>\nA control flow statement that repeatedly executes a body statement as long as a condition expression evaluates to truthy: <code>while (condition) body</code>. Represented by the <code>While</code> AST node with <code>condition</code> and <code>body</code> fields. The interpreter evaluates the condition before each iteration.</p>\n<p><strong>Whitespace</strong>\nCharacters that separate tokens but carry no meaning: spaces, tabs, carriage returns, and newlines. The scanner skips whitespace between tokens. Newlines increment the line counter for accurate error reporting.</p>\n","toc":[{"level":1,"text":"Building a Tree-Walking Interpreter for Lox: Design Document","id":"building-a-tree-walking-interpreter-for-lox-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"1. Context and Problem Statement","id":"1-context-and-problem-statement"},{"level":3,"text":"Mental Model: The Tour Guide","id":"mental-model-the-tour-guide"},{"level":3,"text":"The Core Challenge: Bridging Syntax and Runtime","id":"the-core-challenge-bridging-syntax-and-runtime"},{"level":3,"text":"Existing Interpreter Architectures","id":"existing-interpreter-architectures"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"2. Goals and Non-Goals","id":"2-goals-and-non-goals"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":3,"text":"Non-Functional Goals &amp; Non-Goals","id":"non-functional-goals-amp-non-goals"},{"level":4,"text":"Non-Functional Goals (Priorities)","id":"non-functional-goals-priorities"},{"level":4,"text":"Non-Goals (Explicitly Out of Scope)","id":"non-goals-explicitly-out-of-scope"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"3. High-Level Architecture","id":"3-high-level-architecture"},{"level":3,"text":"Component Overview and Data Flow","id":"component-overview-and-data-flow"},{"level":3,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"4. Data Model","id":"4-data-model"},{"level":3,"text":"Tokens: The Lexical Atoms","id":"tokens-the-lexical-atoms"},{"level":3,"text":"AST Nodes: The Program&#39;s Skeleton","id":"ast-nodes-the-program39s-skeleton"},{"level":3,"text":"Runtime Values: The Interpreter&#39;s Currency","id":"runtime-values-the-interpreter39s-currency"},{"level":3,"text":"Environments: The Scoped Namespace","id":"environments-the-scoped-namespace"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"5.1 Component Design: Scanner (Lexer) [Milestone 1]","id":"51-component-design-scanner-lexer-milestone-1"},{"level":3,"text":"Mental Model: The Tokenizer","id":"mental-model-the-tokenizer"},{"level":3,"text":"Interface and State","id":"interface-and-state"},{"level":4,"text":"Scanner Public Interface","id":"scanner-public-interface"},{"level":4,"text":"Scanner Internal State","id":"scanner-internal-state"},{"level":3,"text":"Scanning Algorithm","id":"scanning-algorithm"},{"level":4,"text":"Step-by-Step Scanning Procedure","id":"step-by-step-scanning-procedure"},{"level":4,"text":"Detailed Scanning Logic for Key Token Types","id":"detailed-scanning-logic-for-key-token-types"},{"level":3,"text":"ADR: Visitor vs. Procedural Scanning","id":"adr-visitor-vs-procedural-scanning"},{"level":4,"text":"Options Comparison Table","id":"options-comparison-table"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"5.2 Component Design: Parser &amp; AST [Milestones 2 &amp; 3]","id":"52-component-design-parser-amp-ast-milestones-2-amp-3"},{"level":3,"text":"Mental Model: The Sentence Diagrammer","id":"mental-model-the-sentence-diagrammer"},{"level":3,"text":"AST Definition and the Visitor Pattern","id":"ast-definition-and-the-visitor-pattern"},{"level":3,"text":"Parsing Expression Grammar (PEG) &amp; Recursive Descent","id":"parsing-expression-grammar-peg-amp-recursive-descent"},{"level":3,"text":"ADR: Recursive Descent vs. Pratt Parsing","id":"adr-recursive-descent-vs-pratt-parsing"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"5.3 Component Design: Core Interpreter [Milestones 4, 5, 6]","id":"53-component-design-core-interpreter-milestones-4-5-6"},{"level":3,"text":"Mental Model: The Tree-Walking Executor","id":"mental-model-the-tree-walking-executor"},{"level":3,"text":"Interface: The Evaluate and Execute Methods","id":"interface-the-evaluate-and-execute-methods"},{"level":3,"text":"Evaluation and Execution Algorithms","id":"evaluation-and-execution-algorithms"},{"level":4,"text":"Expression Evaluation Algorithms","id":"expression-evaluation-algorithms"},{"level":4,"text":"Statement Execution Algorithms","id":"statement-execution-algorithms"},{"level":3,"text":"ADR: Dynamic Type Checking Strategy","id":"adr-dynamic-type-checking-strategy"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"5.4 Component Design: Functions and Closures [Milestones 7 &amp; 8]","id":"54-component-design-functions-and-closures-milestones-7-amp-8"},{"level":3,"text":"Mental Model: The Function as a Recipe with a Kitchen","id":"mental-model-the-function-as-a-recipe-with-a-kitchen"},{"level":3,"text":"LoxFunction: A Callable Wrapper","id":"loxfunction-a-callable-wrapper"},{"level":3,"text":"Function Call and Return Algorithm","id":"function-call-and-return-algorithm"},{"level":4,"text":"1. Function Declaration Evaluation","id":"1-function-declaration-evaluation"},{"level":4,"text":"2. Function Call Evaluation","id":"2-function-call-evaluation"},{"level":4,"text":"3. Return Statement Execution","id":"3-return-statement-execution"},{"level":3,"text":"ADR: Environment Capture for Closures","id":"adr-environment-capture-for-closures"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"5.5 Component Design: Classes and Inheritance [Milestones 9 &amp; 10]","id":"55-component-design-classes-and-inheritance-milestones-9-amp-10"},{"level":3,"text":"Mental Model: The Class as a Blueprint and Factory","id":"mental-model-the-class-as-a-blueprint-and-factory"},{"level":3,"text":"LoxClass and LoxInstance Structures","id":"loxclass-and-loxinstance-structures"},{"level":3,"text":"Instantiation, Property Access, and Method Resolution","id":"instantiation-property-access-and-method-resolution"},{"level":4,"text":"1. Class Declaration Evaluation","id":"1-class-declaration-evaluation"},{"level":4,"text":"2. Instance Creation (Calling a Class)","id":"2-instance-creation-calling-a-class"},{"level":4,"text":"3. Property Access (Get Expression)","id":"3-property-access-get-expression"},{"level":4,"text":"4. Property Assignment (Set Expression)","id":"4-property-assignment-set-expression"},{"level":4,"text":"5. Method Resolution with Inheritance","id":"5-method-resolution-with-inheritance"},{"level":3,"text":"ADR: Storing a Dedicated &#39;super&#39; Environment","id":"adr-storing-a-dedicated-39super39-environment"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"6. Interactions and Data Flow","id":"6-interactions-and-data-flow"},{"level":3,"text":"End-to-End Sequence for a Sample Program","id":"end-to-end-sequence-for-a-sample-program"},{"level":3,"text":"Internal Data Handoffs","id":"internal-data-handoffs"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"7. Error Handling and Edge Cases","id":"7-error-handling-and-edge-cases"},{"level":3,"text":"Error Classification and Reporting","id":"error-classification-and-reporting"},{"level":4,"text":"Error Categories and Detection Points","id":"error-categories-and-detection-points"},{"level":4,"text":"Error Reporting Standards","id":"error-reporting-standards"},{"level":4,"text":"Error Class Hierarchy","id":"error-class-hierarchy"},{"level":4,"text":"Location Tracking Implementation","id":"location-tracking-implementation"},{"level":3,"text":"Error Recovery Strategies","id":"error-recovery-strategies"},{"level":4,"text":"Parser: Panic-Mode Recovery","id":"parser-panic-mode-recovery"},{"level":4,"text":"Scanner: Best-Effort Recovery","id":"scanner-best-effort-recovery"},{"level":4,"text":"Interpreter: Fail-Fast Runtime Errors","id":"interpreter-fail-fast-runtime-errors"},{"level":3,"text":"Specific Edge Cases and Semantics","id":"specific-edge-cases-and-semantics"},{"level":4,"text":"Type System Edge Cases","id":"type-system-edge-cases"},{"level":4,"text":"Truthiness Rules","id":"truthiness-rules"},{"level":4,"text":"Object Model Edge Cases","id":"object-model-edge-cases"},{"level":4,"text":"Special Numerical Semantics","id":"special-numerical-semantics"},{"level":4,"text":"String Concatenation Details","id":"string-concatenation-details"},{"level":4,"text":"Variable Resolution Edge Cases","id":"variable-resolution-edge-cases"},{"level":4,"text":"Function Call Edge Cases","id":"function-call-edge-cases"},{"level":4,"text":"Inheritance Edge Cases","id":"inheritance-edge-cases"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Error Exception Classes (Complete Starter Code)","id":"c-error-exception-classes-complete-starter-code"},{"level":4,"text":"D. Error Reporting in Main Class (Core Logic Skeleton)","id":"d-error-reporting-in-main-class-core-logic-skeleton"},{"level":4,"text":"E. Parser Error Recovery (Core Logic Skeleton)","id":"e-parser-error-recovery-core-logic-skeleton"},{"level":4,"text":"F. Runtime Type Checking (Core Logic Skeleton)","id":"f-runtime-type-checking-core-logic-skeleton"},{"level":4,"text":"G. Language-Specific Hints (Java)","id":"g-language-specific-hints-java"},{"level":4,"text":"H. Milestone Checkpoint: Error Handling Verification","id":"h-milestone-checkpoint-error-handling-verification"},{"level":2,"text":"8. Testing Strategy","id":"8-testing-strategy"},{"level":3,"text":"Mental Model: The Construction Inspector","id":"mental-model-the-construction-inspector"},{"level":3,"text":"Unit and Integration Testing","id":"unit-and-integration-testing"},{"level":3,"text":"Milestone Checkpoints (Verification Guide)","id":"milestone-checkpoints-verification-guide"},{"level":3,"text":"Common Pitfalls in Testing","id":"common-pitfalls-in-testing"},{"level":3,"text":"Architecture Decision Record: Test-First vs. Test-After Development","id":"architecture-decision-record-test-first-vs-test-after-development"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code: Test Utilities","id":"c-infrastructure-starter-code-test-utilities"},{"level":4,"text":"D. Core Test Skeleton Code","id":"d-core-test-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints (Java)","id":"e-language-specific-hints-java"},{"level":4,"text":"F. Milestone Checkpoint Commands","id":"f-milestone-checkpoint-commands"},{"level":4,"text":"G. Debugging Tips for Test Failures","id":"g-debugging-tips-for-test-failures"},{"level":2,"text":"9. Debugging Guide","id":"9-debugging-guide"},{"level":3,"text":"Symptom → Cause → Fix Table","id":"symptom-cause-fix-table"},{"level":3,"text":"Effective Debugging Techniques","id":"effective-debugging-techniques"},{"level":4,"text":"1. AST Printer: Visualizing the Syntax Tree","id":"1-ast-printer-visualizing-the-syntax-tree"},{"level":4,"text":"2. Environment Dumper: Mapping the Variable Universe","id":"2-environment-dumper-mapping-the-variable-universe"},{"level":4,"text":"3. Step-by-Step Execution Log: The Interpreter&#39;s Diary","id":"3-step-by-step-execution-log-the-interpreter39s-diary"},{"level":4,"text":"4. Token Stream Visualizer: Seeing the Lexical Stream","id":"4-token-stream-visualizer-seeing-the-lexical-stream"},{"level":4,"text":"5. Manual Test Harness with Assertions","id":"5-manual-test-harness-with-assertions"},{"level":4,"text":"6. Using a Debugger: Strategic Breakpoints","id":"6-using-a-debugger-strategic-breakpoints"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Enhanced AST Printer","id":"a-enhanced-ast-printer"},{"level":4,"text":"B. Environment Dumper","id":"b-environment-dumper"},{"level":4,"text":"C. Execution Logging with a Flag","id":"c-execution-logging-with-a-flag"},{"level":4,"text":"D. Token Stream Visualizer","id":"d-token-stream-visualizer"},{"level":4,"text":"E. Language-Specific Hints (Java)","id":"e-language-specific-hints-java"},{"level":4,"text":"F. Milestone Checkpoint for Debugging","id":"f-milestone-checkpoint-for-debugging"},{"level":4,"text":"G. Debugging Tips Table (Recap of Common Issues)","id":"g-debugging-tips-table-recap-of-common-issues"},{"level":2,"text":"10. Future Extensions","id":"10-future-extensions"},{"level":3,"text":"Possible Feature Additions","id":"possible-feature-additions"},{"level":4,"text":"Adding a Read-Eval-Print Loop (REPL)","id":"adding-a-read-eval-print-loop-repl"},{"level":4,"text":"Standard Library Functions","id":"standard-library-functions"},{"level":4,"text":"Native Functions and Foreign Function Interface (FFI)","id":"native-functions-and-foreign-function-interface-ffi"},{"level":4,"text":"Additional Control Flow: break, continue, and switch","id":"additional-control-flow-break-continue-and-switch"},{"level":4,"text":"Arrays and Basic Data Structures","id":"arrays-and-basic-data-structures"},{"level":4,"text":"Exception Handling with try/catch","id":"exception-handling-with-trycatch"},{"level":4,"text":"Modules and Imports","id":"modules-and-imports"},{"level":4,"text":"Compiling to Bytecode (Transition to a Virtual Machine)","id":"compiling-to-bytecode-transition-to-a-virtual-machine"},{"level":3,"text":"Performance Optimizations","id":"performance-optimizations"},{"level":4,"text":"Constant Folding","id":"constant-folding"},{"level":4,"text":"Environment Flattening (Upvalue Resolution)","id":"environment-flattening-upvalue-resolution"},{"level":4,"text":"Method Caching","id":"method-caching"},{"level":4,"text":"String Interning","id":"string-interning"},{"level":4,"text":"Tail Call Optimization (TCO)","id":"tail-call-optimization-tco"},{"level":4,"text":"Arithmetic Operation Specialization","id":"arithmetic-operation-specialization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure for Extensions","id":"recommended-file-structure-for-extensions"},{"level":4,"text":"Infrastructure Starter Code: Native Function Interface","id":"infrastructure-starter-code-native-function-interface"},{"level":4,"text":"Core Logic Skeleton: Constant Folding Optimizer","id":"core-logic-skeleton-constant-folding-optimizer"},{"level":4,"text":"Core Logic Skeleton: REPL with Continuation","id":"core-logic-skeleton-repl-with-continuation"},{"level":4,"text":"Language-Specific Hints (Java)","id":"language-specific-hints-java"},{"level":4,"text":"Milestone Checkpoints for Extensions","id":"milestone-checkpoints-for-extensions"},{"level":4,"text":"Debugging Tips for Extensions","id":"debugging-tips-for-extensions"},{"level":2,"text":"11. Glossary","id":"11-glossary"},{"level":3,"text":"A","id":"a"},{"level":3,"text":"B","id":"b"},{"level":3,"text":"C","id":"c"},{"level":3,"text":"D","id":"d"},{"level":3,"text":"E","id":"e"},{"level":3,"text":"F","id":"f"},{"level":3,"text":"G","id":"g"},{"level":3,"text":"H","id":"h"},{"level":3,"text":"I","id":"i"},{"level":3,"text":"J","id":"j"},{"level":3,"text":"K","id":"k"},{"level":3,"text":"L","id":"l"},{"level":3,"text":"M","id":"m"},{"level":3,"text":"N","id":"n"},{"level":3,"text":"O","id":"o"},{"level":3,"text":"P","id":"p"},{"level":3,"text":"R","id":"r"},{"level":3,"text":"S","id":"s"},{"level":3,"text":"T","id":"t"},{"level":3,"text":"U","id":"u"},{"level":3,"text":"V","id":"v"},{"level":3,"text":"W","id":"w"}],"title":"Building a Tree-Walking Interpreter for Lox: Design Document","markdown":"# Building a Tree-Walking Interpreter for Lox: Design Document\n\n\n## Overview\n\nThis document outlines the architecture for a complete interpreter for the Lox programming language, implementing a tree-walking evaluation strategy. The key architectural challenge is designing a clean separation between the static structure of the code (lexing, parsing) and its dynamic execution (environment-based evaluation), while managing state, scope, and first-class functions in a way that is both correct and educational for the implementer.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n> **Milestone(s):** All milestones (foundational context)\n\n## 1. Context and Problem Statement\n\nInterpreting a programming language is the art of imbuing inert text with life. The fundamental problem is transforming a linear sequence of characters—a program—into a dynamic, stateful computation that produces effects (like printing to a screen, modifying a file, or controlling a robot). This transformation is not direct; it requires bridging a profound conceptual gap between the **static syntax** of the language (its grammar and keywords) and the **dynamic runtime** (the execution of operations on data in memory). This section establishes the core architectural philosophy for our Lox interpreter: the tree-walking strategy, a deliberate design that prioritizes clarity and pedagogical value while solving this fundamental problem.\n\n### Mental Model: The Tour Guide\n\nImagine you are handed a detailed, hierarchical map of a complex city (**the Abstract Syntax Tree, or AST**). The map doesn't *do* anything; it's just a static representation of the city's layout—streets (expressions), landmarks (literals), and districts (statements). A **tree-walking interpreter** acts as your personal tour guide. The guide walks you through this map step-by-step, starting at the main entrance (the program entry point). At each landmark on the map, the guide consults a comprehensive rulebook (**the language semantics**) that dictates what action to perform at that specific type of location.\n\nFor example, upon reaching a `+` intersection (a Binary expression node), the rulebook states: \"First, walk down the left street and report back what you find. Then, walk down the right street and report back. Finally, if both reports are numbers, add them; if both are strings, join them.\" The guide faithfully executes these instructions, carrying a notebook (**the Environment**) to remember variable values assigned at different addresses. This direct, recursive walk through the map's structure is intuitive—the execution flow mirrors the code's syntactic structure. However, it can be inefficient, as the guide might re-walk the same paths (like in a loop) without remembering the terrain.\n\n### The Core Challenge: Bridging Syntax and Runtime\n\nSource code is a one-dimensional string. Runtime behavior is multidimensional, involving control flow jumps, mutable state, and nested function calls. The core architectural challenge is designing a pipeline that systematically translates the former into the latter. A single-step translation is impossible for all but the most trivial languages due to complexities like nested expressions, scoped variables, and forward references.\n\nOur solution is a **multi-phase design**, decomposing the problem into three sequential transformations, each building on the output of the previous phase. This separation of concerns is a classic pattern in language implementation:\n\n1.  **Lexical Analysis (Scanner):** The first transformation converts the raw character stream into a stream of meaningful **tokens**. This phase strips away whitespace and comments, and recognizes the basic vocabulary of the language: keywords (`if`, `while`), identifiers (`count`), literals (`42`, `\"hello\"`), and operators (`+`, `==`). It's akin to breaking a sentence into individual words and punctuation.\n2.  **Syntactic Analysis (Parser):** The second transformation organizes the flat token stream into a hierarchical **Abstract Syntax Tree (AST)**. This phase enforces the grammar rules of the language, ensuring tokens appear in a valid order and establishing the nesting relationships dictated by parentheses and operator precedence. It's like diagramming a sentence to identify subject, verb, object, and subordinate clauses.\n3.  **Semantic Analysis & Execution (Interpreter):** The final transformation walks the AST and performs the actual computations and side effects. This phase resolves the *meaning* of the syntactic constructs: evaluating expressions, executing statements, managing variable storage in **Environments**, and directing control flow. It's the tour guide bringing the map to life.\n\nThe data flows linearly through this pipeline: `Source Code (String)` → `Scanner` → `List<Token>` → `Parser` → `List<Stmt>` → `Interpreter` → `Runtime Effects/Output`.\n\n![High-Level System Component Diagram](./diagrams/diagram-system.svg)\n\n**Why is this separation necessary?** Each phase operates at a different level of abstraction and has a distinct, testable responsibility. The scanner worries about character-level patterns but not grammar. The parser worries about grammar but not what `+` *does*. The interpreter worries about semantics and state but not about where parentheses go. This modularity makes the system easier to understand, debug, and extend. For instance, adding a new operator like `**` requires: 1) teaching the scanner to recognize `**` as a token, 2) teaching the parser its precedence level, and 3) teaching the interpreter its mathematical meaning—all in isolated components.\n\n### Existing Interpreter Architectures\n\nThe tree-walking interpreter is one of several architectures for implementing a programming language. The choice among them represents a classic engineering trade-off between simplicity, performance, and flexibility.\n\n> **Decision: Choosing a Tree-Walking Interpreter Architecture**\n> - **Context**: We are building an interpreter for Lox primarily as an educational project. The primary goal is to understand language implementation concepts from the ground up, not to achieve peak execution speed. We need an architecture that maps clearly to the language's syntax and semantics, making the connection between source code and runtime behavior as transparent as possible.\n> - **Options Considered**:\n>     1.  **Tree-Walking Interpreter**: Directly traverses the AST, executing operations at each node.\n>     2.  **Bytecode Virtual Machine (VM)**: Compiles the AST to a compact, linear bytecode instruction set, which is then executed by a virtual stack- or register-based machine.\n>     3.  **Ahead-of-Time (AOT) or Just-in-Time (JIT) Compiler**: Translates source code directly to native machine code for the host CPU (e.g., x86, ARM).\n> - **Decision**: We will implement a **Tree-Walking Interpreter**.\n> - **Rationale**:\n>     - **Conceptual Clarity**: The execution path of a tree-walker directly mirrors the syntactic structure of the source code. A `while` loop node in the AST leads directly to a loop in the interpreter's execution. This 1:1 mapping is invaluable for learning.\n>     - **Implementation Simplicity**: It requires fewer moving parts. There is no need to design a bytecode instruction set, a compiler from AST to bytecode, or a virtual machine with its own instruction dispatch loop. The interpreter is essentially a large recursive function over the AST.\n>     - **Incremental Development**: Features can be added by extending the AST and adding a corresponding `visit` method in the interpreter. This aligns perfectly with the milestone-based learning approach.\n> - **Consequences**:\n>     - **Performance**: Tree-walking is slower than a bytecode VM. Each AST node involves a virtual method dispatch (via the Visitor pattern), and complex expressions require traversing a deep tree for every evaluation (e.g., in a tight loop).\n>     - **No Intermediate Representation**: The lack of a bytecode intermediate representation (IR) makes some optimizations (like constant folding or basic block analysis) more awkward to implement, though they are less of a priority for this project.\n>     - **Direct Semantics**: The interpreter's logic is the \"specification\" of the language. This can be both a pro (easy to reason about) and a con (runtime errors are deeply embedded in the traversal logic).\n\nThe following table compares the key architectural approaches:\n\n| Architecture | How it Works | Pros | Cons | Best For |\n| :--- | :--- | :--- | :--- | :--- |\n| **Tree-Walking Interpreter** | Recursively evaluates nodes in the Abstract Syntax Tree (AST). | **Simple to implement and understand.** Direct mapping from syntax to execution. Easy to add new language features. | **Slow.** High overhead per operation due to tree traversal and visitor pattern dispatch. No easy path to optimization. | **Educational projects, prototyping, scripting languages** where simplicity and clarity are paramount over raw speed. |\n| **Bytecode Virtual Machine** | Compiles AST to a dense, linear bytecode. A virtual CPU (stack-based or register-based) executes the bytecode. | **Much faster than tree-walking.** Bytecode is compact, and the dispatch loop is efficient. Enables optimizations at the bytecode level. Foundation for JIT compilation. | **More complex.** Requires designing a bytecode ISA, a compiler, and a VM. The mapping from source to execution is less direct. | **Production interpreters** (e.g., CPython, Lua, the Java JVM). Balances performance with portability. |\n| **Ahead-of-Time (AOT) Compiler** | Translates source code directly to native machine code for a specific CPU architecture. | **Maximum runtime performance.** Executes directly on hardware, no interpreter loop overhead. | **Extremely complex.** Must handle low-level details of the target CPU (registers, instruction selection). Loss of portability; output is platform-specific. Long compilation time. | **Systems programming languages** (C, C++, Rust) and performance-critical applications. |\n| **Just-in-Time (JIT) Compiler** | Starts as an interpreter or bytecode VM, but profiles \"hot\" code paths and dynamically compiles them to native code during execution. | **Can approach AOT performance** for hot code while maintaining the flexibility of an interpreter for cold code. Adaptive optimization based on runtime profiling. | **Extreme complexity.** Combines challenges of VM and compiler design. High memory usage for storing both bytecode and native code. | **High-performance managed runtimes** (JavaScript V8, Java HotSpot, .NET CLR). |\n\nOur chosen path, the tree-walking interpreter, is the **simplest gateway** into the world of language implementation. It allows us to focus on the core concepts—lexing, parsing, environments, closures, and classes—without the additional cognitive load of designing a bytecode format and a virtual machine. The performance trade-off is acceptable for an educational interpreter; Lox programs will be plenty fast for learning and scripting purposes. Furthermore, the skills and patterns learned here (especially the Visitor pattern for AST traversal and environment management for scope) are directly transferable to building more advanced bytecode VMs or compilers in the future.\n\n### Implementation Guidance\n\nThis section is foundational and does not involve writing code. However, establishing a solid project structure from the outset is critical. Below is the recommended Java package and directory layout that aligns with the high-level architecture. We will flesh out these directories in subsequent component design sections.\n\n**Recommended File/Module Structure:**\n\n```\nlox/\n├── src/main/java/com/craftinginterpreters/lox/\n│   ├── Lox.java                          # Main entry point, coordinates scanning, parsing, interpreting\n│   │\n│   ├── scanner/                          # Milestone 1: Scanner (Lexer)\n│   │   ├── Scanner.java\n│   │   ├── Token.java\n│   │   └── TokenType.java\n│   │\n│   ├── parser/                           # Milestones 2 & 3: Parser & AST\n│   │   ├── Parser.java\n│   │   └── ParseError.java\n│   │\n│   ├── ast/                              # Milestone 2: Abstract Syntax Tree nodes\n│   │   ├── Expr.java                     # Base expression class\n│   │   ├── Stmt.java                     # Base statement class\n│   │   ├── expr/                         # Concrete expression subclasses\n│   │   │   ├── Assign.java\n│   │   │   ├── Binary.java\n│   │   │   ├── Call.java\n│   │   │   ├── Get.java\n│   │   │   ├── Grouping.java\n│   │   │   ├── Literal.java\n│   │   │   ├── Logical.java\n│   │   │   ├── Set.java\n│   │   │   ├── Super.java\n│   │   │   ├── This.java\n│   │   │   ├── Unary.java\n│   │   │   └── Variable.java\n│   │   └── stmt/                         # Concrete statement subclasses\n│   │       ├── Block.java\n│   │       ├── Class.java\n│   │       ├── Expression.java\n│   │       ├── Function.java\n│   │       ├── If.java\n│   │       ├── Print.java\n│   │       ├── Return.java\n│   │       ├── Var.java\n│   │       └── While.java\n│   │\n│   ├── interpreter/                      # Milestones 4-10: Interpreter & Runtime\n│   │   ├── Interpreter.java              # Main tree-walking visitor\n│   │   ├── RuntimeError.java\n│   │   ├── environment/                  # Milestone 5: Environments\n│   │   │   └── Environment.java\n│   │   └── runtime/                      # Runtime value representations\n│   │       ├── LoxCallable.java          # Interface for functions/classes\n│   │       ├── LoxClass.java\n│   │       ├── LoxFunction.java\n│   │       ├── LoxInstance.java\n│   │       └── Return.java               # Control flow for return statements\n│   │\n│   └── tools/                            # Utilities\n│       └── AstPrinter.java               # Milestone 2: Pretty-printer for debugging\n│\n└── src/test/java/com/craftinginterpreters/lox/   # Unit tests for each component\n    ├── scanner/\n    ├── parser/\n    └── interpreter/\n```\n\n**Language-Specific Hints (Java):**\n- Use `enum` for `TokenType` to represent the finite set of token categories (keywords, operators, etc.).\n- The Visitor pattern for AST traversal is a natural fit in Java using abstract classes and accept/visit methods. While it involves some boilerplate, it provides type safety and clean separation between the AST structure and operations on it.\n- For representing runtime values, consider using `Object` as the base type in the interpreter, with explicit casting and `instanceof` checks. Alternatively, you can define a base `LoxValue` interface. We will explore this decision in the Data Model section.\n- Use `java.util.HashMap<String, Object>` for the core storage within an `Environment`.\n- **Milestone Checkpoint**: After setting up this structure, you should be able to compile the project. A simple test is to create a `Lox.java` file with a `main` method that prints a message. Run `javac` on the source directory and execute the main class to verify your build environment is configured.\n\n---\n\n\n> **Milestone(s):** All milestones (foundational goals)\n\n## 2. Goals and Non-Goals\n\nThis section defines the precise boundaries of the interpreter project, establishing what constitutes a successful implementation. By explicitly stating functional requirements, non-functional priorities, and out-of-scope features, we create a clear target for development and prevent scope creep in this educational endeavor. The goals are structured to align with the 10 milestones, which incrementally build from lexical analysis to inheritance.\n\n### Functional Goals\n\nThe interpreter must fully implement the Lox programming language as defined in *Crafting Interpreters*. Lox is a dynamically-typed, object-oriented scripting language designed to be small enough for a single implementer yet complete enough to illustrate core language implementation concepts. The functional requirements are broken down by language feature category, each corresponding to a specific milestone.\n\n> **Mental Model: The Language Specification Checklist**\n> Think of the Lox language specification as a checklist of features that a \"complete\" Lox interpreter must support. Our implementation is a faithful translation of that checklist into executable code, feature by feature, milestone by milestone. Each checked item moves us closer to a fully functional language.\n\nThe following table enumerates the mandatory language features, their corresponding implementation milestones, and a precise description of what \"support\" entails:\n\n| Feature Category | Milestone | Implementation Requirement Description |\n|------------------|-----------|----------------------------------------|\n| **Lexical Structure** | 1 (Scanner) | The scanner must tokenize all Lox lexical elements: keywords (`var`, `fun`, `if`, `else`, `while`, `for`, `return`, `class`, `super`, `this`, `and`, `or`, `print`, `nil`, `true`, `false`), identifiers, literals (strings with escape sequences, numbers with decimal points), operators (`+`, `-`, `*`, `/`, `!`, `=`, `==`, `!=`, `<`, `<=`, `>`, `>=`), and punctuation (`(`, `)`, `{`, `}`, `,`, `.`, `;`). Whitespace and comments (both `//` line and `/* */` block) must be ignored. |\n| **Expressions & Precedence** | 3 (Parsing Expressions) | The parser must correctly parse all expression types with proper operator precedence and associativity. Precedence levels (from lowest to highest) are: assignment (`=`), logical (`or`, `and`), equality (`==`, `!=`), comparison (`<`, `<=`, `>`, `>=`), term (`+`, `-`), factor (`*`, `/`), and unary (`!`, `-`). Parentheses must override precedence. |\n| **Basic Evaluation** | 4 (Evaluating Expressions) | The interpreter must evaluate expressions to produce runtime values: arithmetic operations on numbers, string concatenation with `+`, unary negation and logical NOT, truthiness rules (`nil` and `false` are falsy, everything else truthy), and comparison/equality operations with appropriate type checking. |\n| **Variables & State** | 5 (Statements and State) | Support variable declaration (`var x = value;`), assignment (`x = value;`), and scoping via nested environments. The `print` statement must output values to standard output. Expression statements must evaluate expressions for side effects. |\n| **Control Flow** | 6 (Control Flow) | Implement `if`/`else` conditional execution, `while` loops, `for` loops (desugared to `while`), and logical operators `and`/`or` with short-circuit evaluation. |\n| **First-Class Functions** | 7 (Functions) | Support function declaration (`fun name(parameters) { body }`), function calls, `return` statements, and treating functions as first-class values (assignable to variables, passable as arguments, returnable from functions). Recursion must work. |\n| **Lexical Closures** | 8 (Closures) | Functions must capture their **lexical environment** at definition time, creating closures that retain access to variables from outer scopes even after those scopes have exited. Nested functions must be supported. |\n| **Classes & Instances** | 9 (Classes) | Support class declarations (`class Name { methods }`), instance creation (`ClassName()`), property access (`instance.field`), method calls (`instance.method()`), and the `this` keyword bound to the instance within methods. An `init()` method serves as the constructor. |\n| **Single Inheritance** | 10 (Inheritance) | Support subclassing via `class Derived < Base`. Derived classes inherit methods from their superclass. The `super` keyword must invoke superclass methods from within overridden methods. `super.init()` must be callable within a derived class's `init`. |\n\nThese nine categories represent the complete syntactic and semantic feature set of the Lox language. A successful interpreter must correctly execute Lox programs utilizing any combination of these features.\n\n### Non-Functional Goals & Non-Goals\n\nWhile functional goals define *what* the interpreter does, non-functional goals define *how well* it does them and what qualities we prioritize. For an educational project, clarity, simplicity, and learning value take precedence over performance, robustness, or production readiness.\n\n#### Non-Functional Goals (Priorities)\n\n1.  **Clarity and Readability of Implementation:** The code should be structured to be understandable by a developer learning interpreter construction. This means favoring explicit, well-named functions over clever optimizations, using consistent patterns (like the Visitor pattern for AST traversal), and adding explanatory comments for non-obvious algorithms.\n\n2.  **Educational Value:** Each component should illustrate a fundamental concept of language implementation (lexical analysis, recursive descent parsing, environment-based evaluation, closure capture, etc.). The architecture should make these concepts visible and decoupled.\n\n3.  **Incremental Buildability:** The design must support implementation in the order of the 10 milestones, where each milestone yields a testable, functional subset of the interpreter. Earlier milestones should not require knowledge or infrastructure from later ones.\n\n4.  **Helpful Error Reporting:** When the interpreter encounters an error (lexical, syntactic, or runtime), it should report the error with a clear message and the precise source location (line number, ideally column). This aids debugging for both the interpreter user and the implementer.\n\n5.  **Correctness for the Lox Specification:** The interpreter's behavior must match the semantics described in *Crafting Interpreters*. Edge cases (e.g., truthiness, string concatenation with non-strings, inheritance chains) should be handled as specified.\n\n#### Non-Goals (Explicitly Out of Scope)\n\nThe following are explicitly **not** goals for this project. Including them would expand scope beyond the core educational objectives, add significant complexity, and distract from understanding the foundational concepts.\n\n| Non-Goal Category | Specific Exclusions | Rationale |\n|-------------------|---------------------|-----------|\n| **Performance** | No performance optimization (e.g., bytecode compilation, JIT, AST caching, hash table optimization), no benchmarking against other interpreters. | The primary aim is education, not speed. A tree-walking interpreter is inherently slower than a bytecode VM; optimizing it would add complexity without illuminating new core concepts. |\n| **Tooling & Ergonomics** | No REPL (Read-Eval-Print Loop), no debugger, no syntax highlighting, no language server protocol support. | These are valuable tools but are separate projects that build *upon* a working interpreter. They would significantly increase scope. |\n| **Standard Library** | No built-in functions (e.g., `clock()`, `input()`, `type()`), no data structures beyond classes, no I/O beyond `print`. | Lox as defined in the book has a minimal runtime. Adding a standard library involves designing APIs and implementing native functions, which is a separate topic (native interop). |\n| **Memory Management** | No garbage collection implementation. We rely on the host language's (e.g., Java) garbage collector to reclaim unused `LoxInstance`, `LoxFunction`, and `Environment` objects. | Implementing a garbage collector is a major project unto itself. For simplicity, we assume automatic memory management by the host platform. |\n| **Native Extensions** | No ability to call functions written in the host language (Java/C/Rust) from Lox, nor to embed the interpreter in a larger application. | Interoperability introduces complex binding and type conversion logic. The project focuses on implementing a self-contained language. |\n| **Language Extensions** | No additional syntax or features beyond standard Lox (e.g., no `+=` operators, no `switch` statements, no `try`/`catch`, no modules). | Staying true to the book's specification ensures the project remains focused and comparable to reference implementations. |\n| **Concurrency** | No threads, no async/await, no parallelism. | Concurrency introduces immense complexity in state management and is orthogonal to the core interpreter pipeline. |\n| **Robust Production Deployment** | No sandboxing, no security model, no support for multi-file programs/imports, no detailed logging or monitoring. | This is a learning project, not a production engine. |\n\n> **ADR: Tree-Walking Interpreter vs. Bytecode Virtual Machine**\n> - **Context:** We must choose the core execution strategy for our Lox interpreter. The two primary patterns presented in *Crafting Interpreters* are the tree-walking interpreter (Part I) and the bytecode virtual machine (Part II).\n> - **Options Considered:**\n>     1.  **Tree-Walking Interpreter:** Directly traverses the AST, executing nodes by recursively evaluating their children and combining results.\n>     2.  **Bytecode Virtual Machine:** Compiles the AST to a dense bytecode instruction stream, then executes it using a stack-based virtual machine.\n> - **Decision:** Implement a **tree-walking interpreter**.\n> - **Rationale:** The tree-walking approach has a more direct correspondence between the source code structure (AST) and execution logic, making it easier to understand, debug, and incrementally build. It requires less upfront infrastructure (no compiler, no bytecode definition, no VM loop). It perfectly serves the educational goal of understanding semantic evaluation without the added complexity of an intermediate representation and virtual machine.\n> - **Consequences:** The interpreter will be simpler to implement and understand but will be slower (often 5-10x) than a bytecode VM. This is an acceptable trade-off for learning. The design cleanly separates scanning, parsing, and interpreting phases.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Tree-Walking Interpreter** | Direct mapping from AST to execution; simpler to implement and debug; less code; ideal for incremental milestones. | Slower execution speed; repeated traversal of AST nodes; less illustrative of production interpreter techniques. | **Yes** |\n| **Bytecode Virtual Machine** | Faster execution; introduces important concepts of compilation and VM design; more realistic for production languages. | Significantly more complex; requires designing bytecode, compiler, and VM; harder to debug; larger upfront investment. | No |\n\nBy adhering to these goals and non-goals, the project remains a focused, educational journey through the essential components of a dynamic language interpreter, providing maximum learning value within a manageable scope.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option (Recommended) | Advanced Option (If Curious) |\n|-----------|-----------------------------|-------------------------------|\n| **Project Structure** | Single-language monolithic project (Java). | Multi-language comparison (implement scanner in C, parser in Java, interpreter in Rust). |\n| **Build System** | Maven or Gradle for Java; simple `Makefile` for C; Cargo for Rust. | Custom build scripts integrating multiple languages. |\n| **Testing Framework** | JUnit (Java), Catch2 (C), `cargo test` (Rust). Use simple assertion libraries. | Property-based testing (e.g., jqwik for Java) for generative tests. |\n| **Error Reporting** | Print errors with line numbers to `stderr`. | Fancy error formatting with source code snippets and underlines. |\n\n**B. Recommended File/Module Structure:**\nOrganize your code by the logical phases of the interpreter. This separation of concerns makes the codebase navigable and mirrors the architectural diagram.\n\n```\nlox-interpreter/                    # Project root\n├── src/main/java/com/craftinginterpreters/lox/\n│   ├── Lox.java                    # Main entry point: reads file, drives pipeline\n│   ├── Token.java                  # Token data class (type, lexeme, literal, line)\n│   ├── TokenType.java              # Enum of all token types (IF, PLUS, IDENTIFIER, etc.)\n│   │\n│   ├── scanner/                    # Milestone 1\n│   │   └── Scanner.java            # Converts source string to List<Token>\n│   │\n│   ├── ast/                        # Milestone 2\n│   │   ├── Expr.java               # Abstract base class for expressions\n│   │   ├── Stmt.java               # Abstract base class for statements\n│   │   ├── *.java                  # Concrete subclasses: Binary, Unary, Literal, Var, etc.\n│   │   └── AstPrinter.java         # Visitor that prints AST as S-expressions\n│   │\n│   ├── parser/                     # Milestone 3\n│   │   └── Parser.java             # Recursive descent parser: List<Token> -> List<Stmt>\n│   │\n│   ├── interpreter/                # Milestones 4-10\n│   │   ├── Interpreter.java        # Main tree-walking interpreter, implements Expr.Visitor<Void>, Stmt.Visitor<Void>\n│   │   ├── Environment.java        # Chain of scopes for variable storage\n│   │   ├── RuntimeError.java       # Exception for runtime errors (e.g., type mismatch)\n│   │   ├── LoxCallable.java        # Interface for functions/classes\n│   │   ├── LoxFunction.java        # Represents a user-defined function (closure)\n│   │   ├── LoxClass.java           # Represents a class\n│   │   └── LoxInstance.java        # Represents an instance of a class\n│   │\n│   └── utils/                      # Utilities\n│       └── ErrorReporter.java      # Centralized error reporting (optional)\n├── lib/                            # Dependencies (if any)\n└── test/                           # Unit tests (parallel to src structure)\n```\n\n**C. Infrastructure Starter Code (COMPLETE, ready to use):**\nHere is a complete, minimal `Token` class and `TokenType` enum as they are foundational and not the core learning challenge of any milestone.\n\n```java\n// TokenType.java\npackage com.craftinginterpreters.lox;\n\npublic enum TokenType {\n    // Single-character tokens.\n    LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,\n    COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,\n\n    // One or two character tokens.\n    BANG, BANG_EQUAL,\n    EQUAL, EQUAL_EQUAL,\n    GREATER, GREATER_EQUAL,\n    LESS, LESS_EQUAL,\n\n    // Literals.\n    IDENTIFIER, STRING, NUMBER,\n\n    // Keywords.\n    AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,\n    PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,\n\n    EOF\n}\n```\n\n```java\n// Token.java\npackage com.craftinginterpreters.lox;\n\npublic class Token {\n    public final TokenType type;\n    public final String lexeme;\n    public final Object literal;\n    public final int line;\n\n    public Token(TokenType type, String lexeme, Object literal, int line) {\n        this.type = type;\n        this.lexeme = lexeme;\n        this.literal = literal;\n        this.line = line;\n    }\n\n    public String toString() {\n        return type + \" \" + lexeme + \" \" + literal;\n    }\n}\n```\n\n**D. Core Logic Skeleton Code (for the main driver):**\nThe `Lox` class is the entry point. It demonstrates the high-level pipeline.\n\n```java\n// Lox.java\npackage com.craftinginterpreters.lox;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class Lox {\n    // TODO 1: Add a static errorReporter field or use a global flag to track if an error occurred.\n    static boolean hadError = false;\n    static boolean hadRuntimeError = false;\n\n    public static void main(String[] args) throws IOException {\n        if (args.length > 1) {\n            System.out.println(\"Usage: jlox [script]\");\n            System.exit(64);\n        } else if (args.length == 1) {\n            runFile(args[0]);\n        } else {\n            runPrompt();\n        }\n    }\n\n    private static void runFile(String path) throws IOException {\n        byte[] bytes = Files.readAllBytes(Paths.get(path));\n        run(new String(bytes, Charset.defaultCharset()));\n        // TODO 2: If there was a scan or parse error, exit with code 65 (data error).\n        if (hadError) System.exit(65);\n        // TODO 3: If there was a runtime error, exit with code 70 (software error).\n        if (hadRuntimeError) System.exit(70);\n    }\n\n    private static void runPrompt() throws IOException {\n        InputStreamReader input = new InputStreamReader(System.in);\n        BufferedReader reader = new BufferedReader(input);\n\n        for (;;) {\n            System.out.print(\"> \");\n            String line = reader.readLine();\n            if (line == null) break;\n            run(line);\n            // TODO 4: Reset error flag for interactive session so errors don't kill the REPL.\n            hadError = false;\n        }\n    }\n\n    private static void run(String source) {\n        // TODO 5: Instantiate the Scanner with the source string.\n        // Scanner scanner = new Scanner(source);\n        // TODO 6: Call scanner.scanTokens() to get a List<Token>.\n        // List<Token> tokens = scanner.scanTokens();\n\n        // TODO 7: Instantiate the Parser with the tokens.\n        // Parser parser = new Parser(tokens);\n        // TODO 8: Call parser.parse() to get a List<Stmt>.\n        // List<Stmt> statements = parser.parse();\n\n        // TODO 9: Stop if there was a parse error (indicated by hadError).\n        // if (hadError) return;\n\n        // TODO 10: Instantiate the Interpreter.\n        // Interpreter interpreter = new Interpreter();\n        // TODO 11: Call interpreter.interpret(statements) to execute the program.\n        // interpreter.interpret(statements);\n    }\n\n    // TODO 12: Implement error reporting methods (static) that print to stderr and set hadError.\n    // public static void error(int line, String message) { ... }\n    // public static void error(Token token, String message) { ... }\n    // public static void runtimeError(RuntimeError error) { ... }\n}\n```\n\n**E. Language-Specific Hints (Java):**\n- Use `java.util.HashMap` for `Environment` values map and `LoxInstance` fields.\n- Use `java.util.List` for sequences (tokens, statements, parameters).\n- For the Visitor pattern, define interfaces `Expr.Visitor<R>` and `Stmt.Visitor<R>` with visit methods for each node type. Have `Interpreter` implement these interfaces.\n- Use `Double` for Lox number values. Be careful with equality comparisons (`==` on `Double` objects); consider checking for `double` values within an epsilon for numeric equality, but for simplicity, you can use `equals` for Lox's `==` operator (but note `Double.NaN`).\n- Represent Lox `nil` as Java `null`. Represent Lox booleans as Java `Boolean`.\n- For runtime errors, define a custom `RuntimeError` exception class that extends `RuntimeException` and holds a `Token` for location.\n\n**F. Milestone Checkpoint (Verification for Section 2):**\nAfter setting up the project structure and the basic `Lox` driver with the skeleton above, you can verify your environment works:\n- **Command:** `javac -d out src/main/java/com/craftinginterpreters/lox/*.java src/main/java/com/craftinginterpreters/lox/scanner/*.java ...` (or use your build tool)\n- **Expected:** Successful compilation with no errors (just warnings about unused imports/todos).\n- **Manual Test:** Create a simple Lox file `test.lox` with `print \"Hello, world!\";`. Run your interpreter (once you implement the pipeline). You should see `\"Hello, world!\"` printed.\n- **Signs of Trouble:** If you encounter `ClassNotFoundException` or `NoClassDefFoundError`, check your classpath and package declarations.\n\n**G. Debugging Tips for Goals Alignment:**\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Interpreter supports `+=` operator. | Implemented language extension beyond Lox spec. | Review scanner and parser for non-standard tokens/grammar rules. | Remove support for `+=` to stay true to the book's Lox language. |\n| Function does not capture outer variables (closure broken). | Environment capture strategy is incorrect (copy vs. reference). | Print environment chain during function call; check if parent environment is the defining one. | Ensure `LoxFunction` stores a reference to the *defining* environment, not a copy or the current one. |\n| Interpreter is extremely slow on loops. | Tree-walking interpreter overhead. | Profile to confirm; this is expected. | Acceptable for learning. If performance is critical, consider later moving to a bytecode VM (non-goal for this project). |\n\n\n> **Milestone(s):** All milestones (foundational architecture)\n\n## 3. High-Level Architecture\n\nThis section outlines the macro-architecture of the Lox interpreter, providing a mental map of how source code transforms into executable behavior. The system follows a classic **compiler pipeline** pattern, though it culminates in interpretation rather than code generation. The primary architectural challenge is managing the distinct responsibilities of **static structure analysis** (lexing and parsing) and **dynamic execution** (evaluation), while ensuring state is properly scoped and managed across the lifetime of a program.\n\n### Component Overview and Data Flow\n\nAt its heart, the interpreter is a linear, **unidirectional pipeline** composed of three core transformational components. Imagine a manufacturing assembly line: raw material (source code) enters at one end, is shaped and assembled through successive stations, and a finished product (program output) emerges at the other. Each station is stateless with respect to the others, consuming the output of the previous station and producing input for the next.\n\nThe following diagram illustrates this pipeline and the key data structures that flow between components:\n\n![High-Level System Component Diagram](./diagrams/diagram-system.svg)\n\n**The Pipeline Stages:**\n\n1.  **Scanner (Lexer) → Tokens:** The Scanner acts as the pipeline's initial quality inspector and disassembler. It consumes a raw string of Lox source code and breaks it down into its smallest meaningful parts, called **Tokens**. This process, known as **lexical analysis**, strips away whitespace and comments, recognizes keywords and operators, and extracts literals (strings and numbers). Its output is a flat, sequential list of `Token` objects, each tagged with a type, the original text (lexeme), the literal value (if any), and its source location.\n\n    > **Design Insight:** The Scanner's job is purely syntactic recognition—it doesn't understand that `var` starts a declaration or that `(` groups an expression. It only knows that the characters `v`,`a`,`r` in sequence form the `VAR` token.\n\n2.  **Parser → Abstract Syntax Tree (AST):** The Parser is the assembly line's robotic arm that organizes parts into a structured form. It consumes the linear list of `Token`s and, following Lox's **grammar rules**, builds a hierarchical **Abstract Syntax Tree (AST)**. This tree captures the grammatical nesting and operator precedence inherent in the source code. For example, the expression `1 + 2 * 3` is parsed into a tree where the multiplication node is a child of the addition node, correctly representing that `*` has higher precedence. The parser's output is a `List<Stmt>`, representing the sequence of top-level statements in the program.\n\n    > **Design Insight:** The AST is a *static* representation of the program's *syntax*. It is completely agnostic to runtime values, state, or execution order. It answers \"what is the structure of this code?\" not \"what does this code do when run?\"\n\n3.  **Interpreter → Program Output/Side Effects:** The Interpreter is the final station where the assembled product is activated. It performs a **tree-walk** over the AST, recursively evaluating each node according to the **semantic rules** of Lox. This is where static syntax meets dynamic behavior: expressions compute values, statements execute commands, and control flow directives direct the walk's path. The interpreter's primary output is side effects: printed text to the console, changes to variable state, or, in a more advanced system, network calls or file I/O.\n\n**The Persistent Runtime State: The Environment**\n\nWhile the three core components form a pipeline, the **Interpreter** requires a persistent, dynamic data structure to track program state: the **Environment**. An `Environment` is a scoped mapping from variable names to their current runtime values. It is not a stage in the pipeline but rather a **supporting actor** that the Interpreter consults and modifies during execution.\n\n*   **Structure:** Environments form a **chain** via parent (`enclosing`) references. The global scope is the root of this chain. Each new block or function call creates a new child environment. Variable resolution proceeds from the current environment outward toward the global scope.\n*   **Lifetime:** The Environment chain is built and torn down dynamically at runtime, mirroring the call stack and block structure of the program. This is a key distinction from the AST, which is built once statically.\n\n**End-to-End Data Transformation Flow:**\n\nThe following table traces the complete data transformation for a simple Lox program, `print \"Hello, \" + \"world!\";`.\n\n| Pipeline Stage | Input | Core Action | Output | Key Data Structure |\n| :--- | :--- | :--- | :--- | :--- |\n| **Scanner** | `String`: `'print \"Hello, \" + \"world!\";'` | Scan characters, categorize lexemes, ignore whitespace. | `List<Token>`: `[PRINT, STRING(\"Hello, \"), PLUS, STRING(\"world!\"), SEMICOLON, EOF]` | `Token` (type, lexeme, literal, line) |\n| **Parser** | `List<Token>` (from Scanner) | Recursively group tokens according to grammar rules (e.g., `STRING + STRING` → a `Binary` expression). | `List<Stmt>`: `[PrintStmt(BinaryExpr(Literal(\"Hello, \"), PLUS, Literal(\"world!\")))]` | `Expr` and `Stmt` node hierarchy |\n| **Interpreter** | `List<Stmt>` (from Parser) | Walk AST: Evaluate `BinaryExpr` (string concatenation) → `\"Hello, world!\"`, pass to `PrintStmt`. | **Side Effect**: `\"Hello, world!\"` printed to stdout. | Runtime values (`LoxString`, `LoxNumber`, etc.), `Environment` chain |\n\n**Key Architectural Decisions:**\n\n> **Decision: Tree-Walking Interpreter vs. Bytecode Virtual Machine**\n> *   **Context:** We must choose a strategy for executing Lox programs. The core choice is between directly traversing the AST (tree-walking) or compiling to an intermediate bytecode and executing that on a virtual stack machine.\n> *   **Options Considered:**\n>     1.  **Tree-Walking Interpreter:** The interpreter recursively traverses the AST, executing operations at each node.\n>     2.  **Bytecode Virtual Machine (VM):** A separate compiler phase transforms the AST into a linear sequence of bytecode instructions. A separate VM with a stack and instruction pointer executes this bytecode.\n> *   **Decision:** Implement a **Tree-Walking Interpreter**.\n> *   **Rationale:** This is an educational project where clarity and direct mapping from language semantics to implementation are paramount. A tree-walker's control flow mirrors the recursive structure of the language grammar, making it easier to understand and debug. The performance penalty of tree-walking is acceptable for our learning goals.\n> *   **Consequences:** The interpreter logic is interwoven with the AST traversal (via the Visitor pattern). This simplifies the initial architecture but makes certain optimizations (like direct jumps for loops) more awkward. It also means runtime errors must be propagated via exception handling up the recursive call stack.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Tree-Walking Interpreter** | Simple, direct mapping from syntax to execution. Easier to implement and debug. No separate compiler/VM phase. | Slower (many pointer indirections). Harder to optimize control flow. Traversal logic can become complex. | **Yes** |\n| **Bytecode VM** | Faster execution (dense bytecode, tight interpreter loop). Clear separation of compile/run phases. Better foundation for optimizations (JIT). | More complex architecture. Additional concepts (bytecode, stack, IP). Harder to debug execution flow. | No |\n\n> **Decision: Visitor Pattern for AST Operations**\n> *   **Context:** We need a clean way to define operations (like evaluation, pretty-printing, static analysis) over our heterogeneous AST node types without resorting to verbose type-checking (`instanceof`) and casting.\n> *   **Options Considered:**\n>     1.  **Visitor Pattern:** Define an interface with a `visit` method for each AST node type. Each node type has an `accept(Visitor)` method that calls the appropriate `visit` method.\n>     2.  **Procedural Switch/`instanceof`:** Write functions that take a base `Expr` or `Stmt` and use a switch or if-else chain to handle each concrete type.\n> *   **Decision:** Use the **Visitor Pattern**.\n> *   **Rationale:** The Visitor pattern cleanly separates the *structure* of the AST (the node classes) from the *operations* performed on it. This allows us to add new operations (e.g., a static type checker, a code formatter) without modifying the AST node classes themselves (adhering to the Open/Closed Principle). It also makes the type-dispatching logic explicit and compiler-checked.\n> *   **Consequences:** Requires defining two visitor interfaces (`ExprVisitor<V>`, `StmtVisitor<V>`) and adding an `accept` method to every AST node class. This introduces some boilerplate but pays off in maintainability and clarity for the core interpreter operations.\n\n### Recommended File/Module Structure\n\nA well-organized codebase is critical for managing the complexity of an interpreter. The following package structure mirrors the pipeline architecture, grouping related components and isolating concerns. This structure is recommended for the primary implementation language, Java.\n\n```\nlox/                             # Project root\n├── Lox.java                     # Main entry point (orchestrates pipeline)\n│\n├── scan/                        # Milestone 1: Lexical Analysis\n│   ├── Scanner.java             # Converts source string to tokens\n│   ├── Token.java               # Token data class\n│   └── TokenType.java           # Enumeration of all token types\n│\n├── parse/                       # Milestones 2 & 3: Syntactic Analysis\n│   ├── Parser.java              # Recursive descent parser\n│   ├── ParseError.java          # Checked exception for syntax errors\n│   │\n│   └── ast/                     # Abstract Syntax Tree node definitions\n│       ├── Expr.java            # Abstract base class for expressions\n│       ├── Stmt.java            # Abstract base class for statements\n│       ├── expr/                # Concrete expression nodes\n│       │   ├── Binary.java      # left, operator, right\n│       │   ├── Unary.java       # operator, right\n│       │   ├── Literal.java     # value\n│       │   └── ...              # (Grouping, Variable, Assign, etc.)\n│       └── stmt/                # Concrete statement nodes\n│           ├── Print.java       # expression\n│           ├── Var.java         # name, initializer\n│           └── ...              # (ExpressionStmt, Block, If, While, etc.)\n│\n└── interpret/                   # Milestones 4-10: Execution\n    ├── Interpreter.java         # Tree-walking evaluator (implements ExprVisitor<Object>, StmtVisitor<Void>)\n    ├── RuntimeError.java        # Unchecked exception for runtime errors\n    │\n    ├── environment/             # Runtime state management\n    │   └── Environment.java     # Scoped variable storage (values map, enclosing reference)\n    │\n    └── runtime/                 # Representations of Lox values at runtime\n        ├── LoxCallable.java     # Interface for callable objects (functions, classes)\n        ├── LoxFunction.java     # Represents a Lox function/closure\n        ├── LoxClass.java        # Represents a Lox class\n        ├── LoxInstance.java     # Represents an instance of a class\n        ├── LoxNumber.java       # (Optional) Wrapper for Double\n        ├── LoxString.java       # (Optional) Wrapper for String\n        ├── LoxBoolean.java      # (Optional) Wrapper for Boolean\n        └── LoxNil.java          # Singleton representing nil\n```\n\n**Package Responsibilities:**\n\n*   **`lox` (Root):** Contains the driver class `Lox` which coordinates the entire process: reading source (from file or prompt), invoking the scanner, parser, and interpreter, and catching/reporting errors.\n*   **`scan`:** Isolated lexer module. `Token` and `TokenType` are simple data/enum types used by both the parser and for error reporting.\n*   **`parse`:** Contains all parsing logic and the immutable AST definition. The `ast` subpackage is a **closed hierarchy**; once defined, new node types should not be added lightly as they require updates to the parser and all visitors.\n*   **`interpret`:** The heart of runtime execution. It depends on the `parse.ast` package for the tree structure and contains:\n    *   `Interpreter`: The main engine.\n    *   `environment`: Manages dynamic scoping.\n    *   `runtime`: Defines the object model for Lox values. These classes encapsulate Lox semantics (e.g., how `+` works on `LoxString` vs. `LoxNumber`).\n\n**Data Flow Between Packages:**\n\nThe dependencies flow strictly left-to-right, enforcing the pipeline architecture and preventing circular dependencies.\n\n```\nLox.java\n    │   (Source String)\n    ▼\nscan.Scanner ──── List<Token> ────▶ parse.Parser\n    │                                    │\n    │                                    ▼\n    └──────────── Token ───────────▶ parse.ast.*\n                                          │\n                                          │ (List<Stmt>)\n                                          ▼\n                               interpret.Interpreter\n                                          │\n                                          ├─────▶ interpret.environment.Environment\n                                          │\n                                          └─────▶ interpret.runtime.* (LoxFunction, etc.)\n```\n\nThis structure provides a clear roadmap for implementation, allowing you to focus on one logical component at a time, from scanning through to advanced runtime features like classes and inheritance.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (Recommended) | Advanced Option (Consider Later) |\n| :--- | :--- | :--- |\n| **Project Build** | Plain Java files, compile with `javac` | Use a build system (Maven, Gradle) for dependency and test management |\n| **AST Generation** | Hand-written visitor pattern classes | Use an annotation processor (e.g., Java Poet) or parser generator (ANTLR) to generate boilerplate |\n| **Runtime Value Representation** | Use plain Java types (`Double`, `String`, `Boolean`) with `null` for nil | Wrap in dedicated classes (e.g., `LoxNumber`) for explicit type tagging and custom behavior |\n| **Error Reporting** | Print formatted messages to `System.err` | Use a structured logging library (SLF4J) or collect errors for IDE integration |\n\n**B. Recommended File/Module Structure (Starter)**\n\nCreate the following directory and empty Java files to establish the project skeleton. This enforces the architectural separation from the start.\n\n```\nmkdir -p lox/scan lox/parse/ast/expr lox/parse/ast/stmt lox/interpret/environment lox/interpret/runtime\n```\n\n**C. Infrastructure Starter Code**\n\nThe following are complete, foundational classes that you can use as-is. They define the core data structures that flow between components.\n\n**File: `lox/scan/TokenType.java`**\n```java\npackage scan;\n\n// Exhaustive enum of all token types in Lox.\n// Based on Chapter 4 of Crafting Interpreters.\npublic enum TokenType {\n    // Single-character tokens.\n    LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,\n    COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,\n\n    // One or two character tokens.\n    BANG, BANG_EQUAL,\n    EQUAL, EQUAL_EQUAL,\n    GREATER, GREATER_EQUAL,\n    LESS, LESS_EQUAL,\n\n    // Literals.\n    IDENTIFIER, STRING, NUMBER,\n\n    // Keywords.\n    AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,\n    PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,\n\n    EOF\n}\n```\n\n**File: `lox/scan/Token.java`**\n```java\npackage scan;\n\n// Represents a single lexical token from the source code.\npublic class Token {\n    public final TokenType type;\n    public final String lexeme;    // The raw text of the token\n    public final Object literal;   // The interpreted value for literals (String, Double, null)\n    public final int line;         // Source line number (1-indexed) for error reporting\n\n    public Token(TokenType type, String lexeme, Object literal, int line) {\n        this.type = type;\n        this.lexeme = lexeme;\n        this.literal = literal;\n        this.line = line;\n    }\n\n    public String toString() {\n        return type + \" \" + lexeme + \" \" + literal;\n    }\n}\n```\n\n**File: `lox/interpret/environment/Environment.java`**\n```java\npackage interpret.environment;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n// A chain of scopes mapping variable names to values.\n// This is a core runtime data structure for state management.\npublic class Environment {\n    // The immediately enclosing scope. `null` for the global environment.\n    public final Environment enclosing;\n    // Storage for variables defined in this specific scope.\n    private final Map<String, Object> values = new HashMap<>();\n\n    // Constructor for the global scope (no enclosing environment).\n    public Environment() {\n        this.enclosing = null;\n    }\n\n    // Constructor for a new nested scope.\n    public Environment(Environment enclosing) {\n        this.enclosing = enclosing;\n    }\n\n    // Defines a new variable in the current scope.\n    // Used for 'var' declarations.\n    public void define(String name, Object value) {\n        values.put(name, value);\n    }\n\n    // Gets the value of a variable, searching outward through enclosing scopes.\n    // Throws a runtime error if the variable is not found.\n    public Object get(Token name) {\n        if (values.containsKey(name.lexeme)) {\n            return values.get(name.lexeme);\n        }\n        // Look up in the parent scope.\n        if (enclosing != null) return enclosing.get(name);\n\n        throw new RuntimeError(name, \"Undefined variable '\" + name.lexeme + \"'.\");\n    }\n\n    // Assigns a new value to an existing variable.\n    // Searches outward through enclosing scopes. Throws if variable not found.\n    public void assign(Token name, Object value) {\n        if (values.containsKey(name.lexeme)) {\n            values.put(name.lexeme, value);\n            return;\n        }\n        // Try to assign in the parent scope.\n        if (enclosing != null) {\n            enclosing.assign(name, value);\n            return;\n        }\n        throw new RuntimeError(name, \"Undefined variable '\" + name.lexeme + \"'.\");\n    }\n}\n```\n\n**D. Core Logic Skeleton Code**\n\n**File: `lox/Lox.java` (Main Driver)**\n```java\npackage lox;\n\nimport scan.Scanner;\nimport scan.Token;\nimport parse.Parser;\nimport parse.ast.Stmt;\nimport interpret.Interpreter;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\n\n// The main entry point. Can run files or a REPL.\npublic class Lox {\n    // Static interpreter instance shared across runs in REPL mode.\n    private static final Interpreter interpreter = new Interpreter();\n    // Flag to indicate if a parsing or runtime error occurred.\n    static boolean hadError = false;\n    static boolean hadRuntimeError = false;\n\n    public static void main(String[] args) throws IOException {\n        if (args.length > 1) {\n            System.out.println(\"Usage: jlox [script]\");\n            System.exit(64); // EX_USAGE\n        } else if (args.length == 1) {\n            runFile(args[0]);\n        } else {\n            runPrompt();\n        }\n    }\n\n    // Read and execute a Lox source file.\n    private static void runFile(String path) throws IOException {\n        byte[] bytes = Files.readAllBytes(Paths.get(path));\n        run(new String(bytes, \"UTF-8\"));\n        // Indicate an error in the exit code.\n        if (hadError) System.exit(65); // EX_DATAERR\n        if (hadRuntimeError) System.exit(70); // EX_SOFTWARE\n    }\n\n    // Start an interactive Read-Eval-Print Loop (REPL).\n    private static void runPrompt() throws IOException {\n        InputStreamReader input = new InputStreamReader(System.in);\n        BufferedReader reader = new BufferedReader(input);\n\n        for (;;) {\n            System.out.print(\"> \");\n            String line = reader.readLine();\n            if (line == null) break; // Ctrl-D\n            run(line);\n            // Reset error flags for the next line in the REPL.\n            hadError = false;\n            hadRuntimeError = false;\n        }\n    }\n\n    // Core run routine: scan, parse, interpret.\n    private static void run(String source) {\n        // TODO 1: Instantiate the Scanner with the source string.\n        // TODO 2: Call scanner.scanTokens() to get the token list.\n        // TODO 3: Instantiate the Parser with the token list.\n        // TODO 4: Call parser.parse() to get the statement list.\n        // TODO 5: If there were no syntax errors (hadError is false), call interpreter.interpret(statements).\n        // Hint: Catch ParseError and RuntimeError exceptions and report them using the error() and runtimeError() methods below.\n    }\n\n    // Error reporting helpers (to be called from Scanner, Parser, Interpreter).\n    static void error(int line, String message) {\n        report(line, \"\", message);\n    }\n    static void error(Token token, String message) {\n        if (token.type == TokenType.EOF) {\n            report(token.line, \" at end\", message);\n        } else {\n            report(token.line, \" at '\" + token.lexeme + \"'\", message);\n        }\n    }\n    private static void report(int line, String where, String message) {\n        System.err.println(\"[line \" + line + \"] Error\" + where + \": \" + message);\n        hadError = true;\n    }\n    static void runtimeError(RuntimeError error) {\n        System.err.println(error.getMessage() + \"\\n[line \" + error.token.line + \"]\");\n        hadRuntimeError = true;\n    }\n}\n```\n\n**E. Language-Specific Hints (Java)**\n\n*   **Visitor Pattern Implementation:** Use generic interfaces `ExprVisitor<R>` and `StmtVisitor<R>` with a generic return type `R`. This allows the interpreter to return `Object` (values) and `Void` (for statements).\n*   **Runtime Value Representation:** Java's `Double`, `String`, and `Boolean` can be used directly, with `null` representing Lox's `nil`. For type checking, use `instanceof` (e.g., `if (leftOperand instanceof Double)`).\n*   **Immutability:** Make AST node fields `final` to ensure they are immutable after construction. This prevents accidental modification and simplifies reasoning.\n*   **Error Handling:** Use a custom `ParseError` (extends `RuntimeException`) for syntax errors to enable panic-mode recovery in the parser. Use a custom `RuntimeError` (also extends `RuntimeException`) for runtime errors like type mismatches.\n\n**F. Milestone Checkpoint (Architecture Verification)**\n\nAfter setting up the skeleton structure and the `Lox` driver class, you can verify the pipeline is plumbed correctly with a simple test:\n\n1.  **Create a test file:** `test.lox` containing a single line: `print \"Hello, world!\";`\n2.  **Run the driver:** `java lox.Lox test.lox`\n3.  **Expected Output at this stage:** The program should compile without errors. When run, it may do nothing (if the scanner/parser/interpreter are stubs) or throw a `NullPointerException`. The key is that the project structure is in place and the main class runs without compilation errors.\n4.  **Next Step:** The first real output will come after implementing the **Scanner (Milestone 1)**, when you can print the list of tokens to verify lexing works.\n\n\n## 4. Data Model\n> **Milestone(s):** All milestones (foundational data structures)\n\nThis section defines the core immutable data structures that form the backbone of our interpreter. Think of these as the **permanent artifacts** produced and consumed as source code moves through the interpretation pipeline. Unlike the procedural logic of scanning, parsing, or evaluating, these data structures are the **static definitions** that represent the program at each phase of its lifecycle. Properly designing these structures is crucial because they determine how information flows between components and what capabilities our interpreter can support.\n\nThe data model has four interrelated layers:\n1. **Tokens** – The atomic units of meaning from the source text\n2. **AST Nodes** – The hierarchical tree structure representing program syntax  \n3. **Runtime Values** – The living data that exists during program execution\n4. **Environments** – The scoped namespace that maps variable names to runtime values\n\nEach layer builds upon the previous one, creating a clear separation between static structure and dynamic execution. This separation is fundamental to the interpreter's architecture—it allows us to reason about the program's syntax independently from its runtime behavior.\n\n### Tokens: The Lexical Atoms\n\n**Mental Model: The Scrabble Tiles**\n> Think of tokens as Scrabble tiles formed from the continuous stream of source code letters. The scanner's job is to break the text into these discrete, categorized tiles—some represent numbers (`5.2`), others operators (`+`), keywords (`var`), or punctuation (`;`). Each tile carries not just its face value (the actual text) but also its classification (is this tile an addition operator or a string concatenator?). These tiles are then passed to the parser, which assembles them into meaningful structures according to grammatical rules.\n\nTokens are the smallest meaningful units produced by the **Scanner** (Milestone 1). They represent the categorized lexical elements of the Lox language, stripping away insignificant whitespace and comments while preserving the essential structure of the source code.\n\n**Token Structure**\nEvery token contains four pieces of information that collectively identify what it represents and where it came from:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `type` | `TokenType` | The category of token (e.g., `PLUS`, `IDENTIFIER`, `NUMBER`). Determines how the parser will interpret this token. |\n| `lexeme` | `String` | The actual text from the source code that generated this token. For the source `123.45`, the lexeme would be `\"123.45\"`. |\n| `literal` | `Object` | The runtime value associated with the token, if any. For a number token, this would be a `Double`; for a string token, a `String`; for identifiers and keywords, `null`. |\n| `line` | `int` | The line number in the source file where this token begins (1-indexed). Critical for error reporting. |\n\n**TokenType Enumeration**\nThe `TokenType` enumeration defines all possible token categories in Lox. Each token type corresponds to a specific lexical pattern in the language grammar. The complete set includes:\n\n| Category | Examples | Notes |\n|----------|----------|-------|\n| **Single-character tokens** | `LEFT_PAREN`, `RIGHT_PAREN`, `LEFT_BRACE`, `RIGHT_BRACE`, `COMMA`, `DOT`, `MINUS`, `PLUS`, `SEMICOLON`, `SLASH`, `STAR` | These map directly to individual characters in source code. |\n| **One-or-two character tokens** | `BANG`, `BANG_EQUAL`, `EQUAL`, `EQUAL_EQUAL`, `GREATER`, `GREATER_EQUAL`, `LESS`, `LESS_EQUAL` | The scanner must look ahead to distinguish `!` from `!=`. |\n| **Literals** | `IDENTIFIER`, `STRING`, `NUMBER` | These tokens carry additional value in their `literal` field. |\n| **Keywords** | `AND`, `CLASS`, `ELSE`, `FALSE`, `FUN`, `FOR`, `IF`, `NIL`, `OR`, `PRINT`, `RETURN`, `SUPER`, `THIS`, `TRUE`, `VAR`, `WHILE` | Reserved words that cannot be used as identifiers. |\n| **End-of-file** | `EOF` | A special sentinel token indicating the end of the input stream. |\n\n> **Design Insight:** The `literal` field uses Java's `Object` type (which can be `null`) rather than a dedicated union type because it simplifies the implementation while maintaining type safety through careful programming. For number literals, we store `Double`; for string literals, `String`; for `true`/`false`/`nil` keywords, we use the corresponding runtime value objects (which we'll define later). This design allows the scanner to produce values that can flow directly into the interpreter without conversion.\n\n**Token Lifecycle**\n1. **Creation**: The scanner creates tokens as it recognizes lexical patterns in the source text. For example, when it encounters the sequence `\"hello\"`, it creates a `Token` with `type=STRING`, `lexeme=\"\\\"hello\\\"\"`, `literal=\"hello\"` (without quotes), and `line` set to the current line.\n2. **Consumption**: The parser receives the stream of tokens and uses their `type` fields to guide parsing decisions. The `literal` field may be used to embed constant values directly into the AST.\n3. **Error Reporting**: When a parse or runtime error occurs, the associated token's `line` (and potentially `lexeme`) is used to generate a user-friendly error message like `\"Error at line 5: Unexpected token '}'\"`.\n\n**ADR: Token Representation Strategy**\n\n> **Decision: Unified Token Class with Optional Literal Field**\n> - **Context**: We need to represent categorized lexical elements with associated metadata (source location, actual text, and sometimes a computed value).\n> - **Options Considered**:\n>   1. **Separate token classes for each type**: Create distinct `IdentifierToken`, `NumberToken`, `OperatorToken` etc., each with type-specific fields.\n>   2. **Tagged union/discriminated record**: Use a single `Token` type with an enum tag and type-specific data in a union (not natively supported in Java).\n>   3. **Unified class with optional fields**: One `Token` class with fields for all possible metadata, some of which may be `null`.\n> - **Decision**: Use a single `Token` class with all four fields, where `literal` may be `null` for tokens without associated values.\n> - **Rationale**: This approach is simple to implement in Java, minimizes class explosion, and matches the typical Java pattern for token representation. The occasional `null` checks are acceptable given the small number of token types that carry literals. It also keeps the scanner and parser logic straightforward.\n> - **Consequences**: We get a clean, immutable token representation. However, we must be careful to handle `null` literals appropriately in the parser and interpreter. Type safety is maintained through discipline rather than the type system.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Separate token classes | Type-safe, no null checks | Class explosion, harder to handle generically | No |\n| Tagged union | Type-safe, memory efficient | Not natively supported in Java, requires pattern matching | No |\n| Unified class | Simple, fewer classes, easy to pass around | Some fields null for certain tokens, less type-safe | **Yes** |\n\n### AST Nodes: The Program's Skeleton\n\n**Mental Model: The Russian Nesting Dolls**\n> The Abstract Syntax Tree (AST) is like a set of Russian nesting dolls, where each doll contains smaller dolls inside it. A `Binary` expression doll contains two smaller expression dolls (left and right operands) plus an operator token. A `Block` statement doll contains a list of statement dolls inside it. The parser's job is to assemble these nested structures by matching grammatical patterns in the token stream, creating a complete hierarchical representation that mirrors the program's syntactic structure.\n\nAST nodes form the **canonical representation** of a Lox program's syntax after parsing (Milestones 2-3). Unlike concrete syntax trees (which include every detail like parentheses and semicolons), the AST abstracts away syntactic noise, leaving only the essential structure needed for execution.\n\n**Node Hierarchy**\nThe AST is composed of two parallel class hierarchies: `Expr` for expressions (which produce values) and `Stmt` for statements (which perform actions). Both are abstract base classes that define the Visitor pattern interface.\n\n**Expression Node Types**\nEach expression node type represents a distinct syntactic construct that evaluates to a value:\n\n| Node Type | Key Fields | Description | Example Lox Code |\n|-----------|------------|-------------|------------------|\n| `Binary` | `Expr left`, `Token operator`, `Expr right` | Binary operation with two operands and an operator token. | `1 + 2` |\n| `Unary` | `Token operator`, `Expr right` | Unary operation with one operand and an operator token. | `-5` or `!true` |\n| `Grouping` | `Expr expression` | Parenthesized expression (for explicit precedence). | `(1 + 2) * 3` |\n| `Literal` | `Object value` | Constant literal value (number, string, boolean, nil). | `42`, `\"hello\"`, `true`, `nil` |\n| `Variable` | `Token name` | Reference to a variable by its name token. | `x` |\n| `Assign` | `Token name`, `Expr value` | Assignment to a previously declared variable. | `x = 10` |\n| `Logical` | `Expr left`, `Token operator`, `Expr right` | Logical `and` or `or` with short-circuit evaluation. | `a and b` |\n| `Call` | `Expr callee`, `Token paren`, `List<Expr> arguments` | Function or method call with argument list. | `foo(1, 2)` |\n| `Get` | `Expr object`, `Token name` | Property access on an instance using dot notation. | `obj.property` |\n| `Set` | `Expr object`, `Token name`, `Expr value` | Property assignment on an instance. | `obj.property = 5` |\n| `This` | `Token keyword` | Reference to the current instance within a method. | `this` |\n| `Super` | `Token keyword`, `Token method` | Reference to a superclass method. | `super.method()` |\n\n**Statement Node Types**\nStatement nodes represent syntactic constructs that perform actions but don't produce values (except for expression statements, which evaluate an expression for side effects):\n\n| Node Type | Key Fields | Description | Example Lox Code |\n|-----------|------------|-------------|------------------|\n| `Expression` | `Expr expression` | Expression evaluated for side effects. | `x + 1;` |\n| `Print` | `Expr expression` | Evaluates expression and prints result. | `print \"hello\";` |\n| `Var` | `Token name`, `Expr initializer` | Variable declaration with optional initializer. | `var x = 5;` |\n| `Block` | `List<Stmt> statements` | Block of statements creating a new scope. | `{ var x = 1; print x; }` |\n| `If` | `Expr condition`, `Stmt thenBranch`, `Stmt elseBranch` | Conditional execution (else branch may be null). | `if (x) print \"yes\"; else print \"no\";` |\n| `While` | `Expr condition`, `Stmt body` | Loop with precondition. | `while (x < 10) x = x + 1;` |\n| `Function` | `Token name`, `List<Token> params`, `List<Stmt> body` | Function declaration (name, parameters, body). | `fun add(a, b) { return a + b; }` |\n| `Return` | `Token keyword`, `Expr value` | Return statement from function (value may be null). | `return 42;` |\n| `Class` | `Token name`, `Expr.Variable superclass`, `List<Stmt.Function> methods` | Class declaration with optional superclass. | `class Point { init(x, y) { this.x = x; this.y = y; } }` |\n\n**Visitor Pattern Architecture**\nThe Visitor pattern enables **open recursion**—allowing new operations on the AST without modifying the node classes themselves. This is essential because our interpreter will define multiple operations: pretty-printing, static analysis (in advanced implementations), and interpretation.\n\n> **Design Insight:** The Visitor pattern creates a double dispatch mechanism. When we call `accept(visitor)` on an AST node, the node calls the appropriate `visitXxx` method on the visitor, passing itself as an argument. This gives the visitor type-safe access to the node's specific fields without requiring instanceof checks.\n\n**AST Immutability**\nAll AST nodes are **immutable**—their fields are set at construction and never modified. This has several benefits:\n1. **Thread safety**: Though our interpreter is single-threaded, immutability prevents accidental modification.\n2. **Predictable behavior**: An AST can be traversed multiple times without fear of side effects.\n3. **Simpler reasoning**: Once parsed, the program structure doesn't change during execution.\n\n![AST Node Class Hierarchy](./diagrams/diagram-ast-hierarchy.svg)\n\n**ADR: Visitor Pattern vs. Instanceof Checks**\n\n> **Decision: Visitor Pattern for AST Operations**\n> - **Context**: We need to define operations (like evaluation, pretty-printing) that work across the heterogeneous AST node types.\n> - **Options Considered**:\n>   1. **Instanceof checks with casting**: Use a switch on node type with explicit casts in each operation.\n>   2. **Interpreter method in each node**: Put an `interpret()` method directly in each AST node class.\n>   3. **Visitor pattern**: Separate the operations from the node structure using double dispatch.\n> - **Decision**: Use the Visitor pattern with separate `Expr.Visitor<R>` and `Stmt.Visitor<V>` interfaces.\n> - **Rationale**: The Visitor pattern cleanly separates concerns—node definitions are purely structural, while operations are defined elsewhere. This makes it easy to add new operations (like a static analyzer or code generator) without modifying the AST classes. It's also the pattern used in the reference \"Crafting Interpreters\" book, providing consistency for learners.\n> - **Consequences**: We incur some boilerplate (the `accept()` method in each node), but gain flexibility and organization. The pattern also naturally supports return values from visits (unlike the interpreter-in-each-node approach).\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Instanceof checks | Simple, no boilerplate | Type-unsafe, spreads logic across type checks | No |\n| Interpreter in each node | Encapsulated, no casting | Mixes structure and behavior, hard to add operations | No |\n| Visitor pattern | Separates concerns, extensible, type-safe | Boilerplate accept methods, more complex | **Yes** |\n\n### Runtime Values: The Interpreter's Currency\n\n**Mental Model: The Theater Props**\n> Runtime values are like props in a theater production. When the interpreter \"performs\" the program (walks the AST), it needs tangible objects to work with: numbers to calculate, strings to concatenate, function objects to call, and instances to manipulate. Each value type has specific capabilities (a function can be called, a class can be instantiated) just as each prop has a specific purpose (a sword can be swung, a book can be opened). These props are created, passed around, and transformed during the performance.\n\nRuntime values are the **living data** that exist during program execution (Milestones 4-10). They flow through the interpreter as expressions evaluate, get stored in variables, and are passed between functions. The interpreter's entire purpose is to produce and manipulate these values according to the semantics defined by the AST structure.\n\n**Value Type Hierarchy**\nLox is dynamically typed, meaning values carry their type at runtime. We represent this in Java using a hierarchy of classes, all ultimately extending `Object`. However, for clarity and to avoid confusion with Java's `Object`, we'll refer to these as **Lox values**.\n\n| Value Type | Java Representation | Description | Example Literals |\n|------------|---------------------|-------------|------------------|\n| **LoxNumber** | `Double` | 64-bit floating-point number (IEEE 754). | `123`, `4.56`, `-7.89` |\n| **LoxString** | `String` | Immutable sequence of Unicode characters. | `\"hello\"`, `\"multi\\nline\"` |\n| **LoxBoolean** | `Boolean` | Logical truth value. | `true`, `false` |\n| **LoxNil** | `null` sentinel | Represents absence of a value. | `nil` |\n| **LoxFunction** | `LoxFunction` class | Callable function object with parameters, body, and closure environment. | Created by `fun` declarations |\n| **LoxClass** | `LoxClass` class | Callable class object that creates instances and holds methods. | Created by `class` declarations |\n| **LoxInstance** | `LoxInstance` class | Instance of a class with its own field storage. | Created by class constructor calls |\n\n**Truthiness Rules**\nLox defines **truthiness** (whether a value is considered \"true\" in boolean contexts) as:\n- `false` and `nil` are **falsy**\n- **Everything else** is **truthy** (including `0`, empty strings, and even `0.0`)\n\nThis differs from some languages but matches Lox's semantics: only explicit falsehoods are falsy.\n\n**Value Operations**\nEach value type supports specific operations:\n\n| Operation | Supported Types | Behavior |\n|-----------|----------------|----------|\n| **Arithmetic** (`+`, `-`, `*`, `/`) | `LoxNumber` | Standard math. `+` also works for string concatenation. |\n| **Comparison** (`<`, `<=`, `>`, `>=`) | `LoxNumber` | Numeric ordering. |\n| **Equality** (`==`, `!=`) | All types | Value equality (structural for objects, reference for functions/classes/instances). |\n| **Negation** (`-`) | `LoxNumber` | Unary minus. |\n| **Logical NOT** (`!`) | Any | Returns `true` if operand is falsy, `false` otherwise. |\n| **Call** (`(...)`) | `LoxFunction`, `LoxClass` | Invokes with arguments. |\n| **Property access** (`.`) | `LoxInstance` | Gets/sets field values or calls methods. |\n\n**ADR: Unified vs. Tagged Value Representation**\n\n> **Decision: Polymorphic Value Classes with Common Supertype**\n> - **Context**: We need to represent Lox values in Java, which is statically typed, while Lox is dynamically typed.\n> - **Options Considered**:\n>   1. **Single `Object` with instanceof checks**: Store all values as Java `Object` and check types at runtime.\n>   2. **Tagged union/enum wrapper**: Create a `Value` class with an enum tag and type-specific storage.\n>   3. **Polymorphic hierarchy**: Create specific classes for each Lox type, all implementing a common `LoxValue` interface.\n> - **Decision**: Use specific classes (`LoxFunction`, `LoxClass`, `LoxInstance`) for complex types, and Java built-in types (`Double`, `String`, `Boolean`) for simple ones, with `null` for nil.\n> - **Rationale**: This approach minimizes boilerplate while leveraging Java's type system where possible. Built-in types give us arithmetic and comparison operators for free. For user-defined types (functions, classes, instances), we need custom behavior (calling, instantiating, property access), so classes are natural. Using `null` for nil is idiomatic in Java.\n> - **Consequences**: We must be careful with `null` checks (nil is a valid Lox value, not an error). Some operations require explicit type checking (e.g., `+` for numbers vs. strings). The interpreter's `evaluate()` method returns `Object`, which we must cast appropriately.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Single `Object` | Simple, uniform | Lots of instanceof, no type safety | No |\n| Tagged union | Explicit type tags, can add new types easily | Manual tag checking, memory overhead | No |\n| Polymorphic hierarchy | Natural for OOP, leverages Java types | Mixed representation (built-ins + custom classes) | **Yes** |\n\n### Environments: The Scoped Namespace\n\n**Mental Model: The Russian Doll Scopes**\n> Environments are like a set of nested Russian dolls, where each doll represents a scope. The innermost doll (current scope) can see its own contents and everything in the dolls enclosing it, but outer dolls cannot see inside inner ones. When you enter a function or block, you open a new doll inside the current one; when you exit, you close it and return to the outer doll. Variables are stored in the smallest doll that contains their declaration.\n\nEnvironments implement **lexical scoping** (Milestones 5, 8) by maintaining a chain of variable bindings. Each environment corresponds to a scope in the program: global scope, function scope, block scope, or class method scope. The environment chain forms a tree structure that the interpreter traverses when resolving variable names.\n\n**Environment Structure**\nEach environment is essentially a dictionary (name → value) with a reference to its parent (enclosing) environment:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `enclosing` | `Environment` | The parent environment (null for the global scope). |\n| `values` | `Map<String, Object>` | The variable bindings in this scope (name → runtime value). |\n\n**Core Operations**\nEnvironments support three fundamental operations:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `define` | `String name`, `Object value` | `void` | Creates a new variable in the current environment. Used for `var` declarations. |\n| `get` | `Token name` | `Object` | Looks up a variable by its name token, searching outward through enclosing environments. Throws if not found. |\n| `assign` | `Token name`, `Object value` | `void` | Updates an existing variable's value, searching outward. Throws if variable wasn't previously defined. |\n\n**Environment Chains in Practice**\nConsider this Lox program:\n```lox\nvar global = \"outside\";\n{\n  var inner = \"inside\";\n  print global; // Looks in inner scope, then outer (global) scope\n}\n```\n\nThis creates the following environment structure:\n```\nGlobal Environment {global: \"outside\"}\n    ↑\nBlock Environment {inner: \"inside\"}\n```\n\nWhen the interpreter evaluates `print global;` inside the block:\n1. It looks for `\"global\"` in the block environment → not found\n2. It follows the `enclosing` link to the global environment\n3. It finds `\"global\"` there and returns its value `\"outside\"`\n\n**Closure Environment Capture**\nFor closures (Milestone 8), the key insight is that a function **captures its defining environment** (the environment active when the function was created, not when it's called). This captured environment becomes the parent of the function's call environment:\n\n```\nGlobal {x: 10}\n    ↑ (captured)\nmakeCounter's defining environment\n    ↑\ncall environment (when makeCounter() is called)\n```\n\nThis allows the inner function to access `x` even after `makeCounter` has returned.\n\n**ADR: Environment Chain vs. Static Distance**\n\n> **Decision: Simple Parent-Chain Lookup**\n> - **Context**: We need to resolve variable names to their values at runtime, respecting lexical scoping rules.\n> - **Options Considered**:\n>   1. **Parent-chain lookup**: Each environment stores a reference to its parent; lookups walk the chain.\n>   2. **Static distance/indices**: At compile time, compute the \"distance\" (number of hops) to the defining environment; at runtime, navigate directly.\n>   3. **Flat closure representation**: Copy all captured variables into the closure at creation time.\n> - **Decision**: Use parent-chain lookup for simplicity and clarity.\n> - **Rationale**: Parent-chain lookup is straightforward to implement and understand—it directly models the mental model of nested scopes. While less efficient than static distance (which requires a separate compilation phase), it's sufficient for an educational interpreter. It also makes closures simple: a function just stores a reference to its defining environment.\n> - **Consequences**: Variable lookup is O(depth) where depth is the nesting level. For deeply nested code, this could be slow, but Lox programs in practice are shallow. The design also naturally supports dynamic additions to outer scopes (though Lox doesn't allow this).\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Parent-chain lookup | Simple, intuitive, easy closures | O(depth) lookup time | **Yes** |\n| Static distance | O(1) lookup, efficient | Requires compile-time analysis, more complex | No |\n| Flat closures | Fast access to captured variables | Complex copy semantics, doesn't support mutation of outer variables | No |\n\n**Common Pitfalls with Environments**\n\n⚠️ **Pitfall: Forgetting to Create New Environment for Each Function Call**\n- **Description**: Reusing the same environment for multiple calls to the same function.\n- **Why it's wrong**: Function parameters and local variables from previous calls would persist, breaking recursion and causing incorrect behavior.\n- **Fix**: Every function call must create a **fresh** environment with the function's closure environment as its parent.\n\n⚠️ **Pitfall: Incorrect Parent Link in Block Environments**\n- **Description**: Setting a block environment's parent to the global environment instead of the current environment.\n- **Why it's wrong**: The block wouldn't have access to variables in enclosing functions or outer blocks.\n- **Fix**: When creating a block environment, pass the **current** environment as the parent.\n\n⚠️ **Pitfall: Not Checking for Undefined Variables in assign()**\n- **Description**: Allowing assignment to create new variables implicitly (like Python) instead of requiring explicit declaration.\n- **Why it's wrong**: Lox requires `var` declarations; assignment to undefined variables should be a runtime error.\n- **Fix**: In `Environment.assign()`, search through the chain and throw if the name isn't found.\n\n### Implementation Guidance\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Data Structures** | Java Collections (`HashMap`, `ArrayList`) | Custom persistent/immutable collections |\n| **Value Representation** | Java built-in types + custom classes | Tagged union with explicit type hierarchy |\n| **Environment Lookup** | Linear chain search | Compile-time static distance resolution |\n\n**Recommended File/Module Structure**\n\n```\nlox/\n├── Token.java              # Token class definition\n├── TokenType.java          # TokenType enum\n├── ast/\n│   ├── Expr.java           # Expression base class and visitor\n│   ├── Stmt.java           # Statement base class and visitor\n│   └── (concrete AST node classes can be inner classes or separate files)\n├── runtime/\n│   ├── LoxFunction.java    # Function value\n│   ├── LoxClass.java       # Class value  \n│   ├── LoxInstance.java    # Instance value\n│   └── Environment.java    # Environment chain\n└── Interpreter.java        # Main interpreter (evaluates AST)\n```\n\n**Infrastructure Starter Code**\n\nComplete, ready-to-use code for foundational data structures:\n\n```java\n// Token.java\npackage lox;\n\nimport java.util.Objects;\n\npublic class Token {\n    public final TokenType type;\n    public final String lexeme;\n    public final Object literal;\n    public final int line;\n\n    public Token(TokenType type, String lexeme, Object literal, int line) {\n        this.type = type;\n        this.lexeme = lexeme;\n        this.literal = literal;\n        this.line = line;\n    }\n\n    @Override\n    public String toString() {\n        return type + \" \" + lexeme + \" \" + literal;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Token token = (Token) o;\n        return line == token.line &&\n               type == token.type &&\n               Objects.equals(lexeme, token.lexeme) &&\n               Objects.equals(literal, token.literal);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(type, lexeme, literal, line);\n    }\n}\n```\n\n```java\n// TokenType.java\npackage lox;\n\npublic enum TokenType {\n    // Single-character tokens\n    LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,\n    COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,\n\n    // One or two character tokens\n    BANG, BANG_EQUAL,\n    EQUAL, EQUAL_EQUAL,\n    GREATER, GREATER_EQUAL,\n    LESS, LESS_EQUAL,\n\n    // Literals\n    IDENTIFIER, STRING, NUMBER,\n\n    // Keywords\n    AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,\n    PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,\n\n    EOF\n}\n```\n\n```java\n// Environment.java (starter version - will be extended)\npackage lox.runtime;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport lox.Token;\nimport lox.Lox;\n\npublic class Environment {\n    final Environment enclosing;\n    private final Map<String, Object> values = new HashMap<>();\n\n    public Environment() {\n        this.enclosing = null;\n    }\n\n    public Environment(Environment enclosing) {\n        this.enclosing = enclosing;\n    }\n\n    public void define(String name, Object value) {\n        values.put(name, value);\n    }\n\n    public Object get(Token name) {\n        if (values.containsKey(name.lexeme)) {\n            return values.get(name.lexeme);\n        }\n\n        if (enclosing != null) return enclosing.get(name);\n\n        throw new RuntimeError(name, \n            \"Undefined variable '\" + name.lexeme + \"'.\");\n    }\n\n    public void assign(Token name, Object value) {\n        if (values.containsKey(name.lexeme)) {\n            values.put(name.lexeme, value);\n            return;\n        }\n\n        if (enclosing != null) {\n            enclosing.assign(name, value);\n            return;\n        }\n\n        throw new RuntimeError(name,\n            \"Undefined variable '\" + name.lexeme + \"'.\");\n    }\n}\n```\n\n**Core Logic Skeleton Code**\n\nAST node base classes with Visitor pattern:\n\n```java\n// ast/Expr.java\npackage lox.ast;\n\nimport java.util.List;\nimport lox.Token;\n\npublic abstract class Expr {\n    public interface Visitor<R> {\n        R visitBinaryExpr(Binary expr);\n        R visitUnaryExpr(Unary expr);\n        R visitGroupingExpr(Grouping expr);\n        R visitLiteralExpr(Literal expr);\n        R visitVariableExpr(Variable expr);\n        R visitAssignExpr(Assign expr);\n        R visitLogicalExpr(Logical expr);\n        R visitCallExpr(Call expr);\n        R visitGetExpr(Get expr);\n        R visitSetExpr(Set expr);\n        R visitThisExpr(This expr);\n        R visitSuperExpr(Super expr);\n    }\n\n    public abstract <R> R accept(Visitor<R> visitor);\n\n    public static class Binary extends Expr {\n        public final Expr left;\n        public final Token operator;\n        public final Expr right;\n\n        public Binary(Expr left, Token operator, Expr right) {\n            this.left = left;\n            this.operator = operator;\n            this.right = right;\n        }\n\n        @Override\n        public <R> R accept(Visitor<R> visitor) {\n            return visitor.visitBinaryExpr(this);\n        }\n    }\n\n    // TODO: Add other expression node classes (Unary, Grouping, Literal, \n    // Variable, Assign, Logical, Call, Get, Set, This, Super) following\n    // the same pattern as Binary above.\n    // Each should have:\n    // 1. Public final fields for its data\n    // 2. A constructor initializing those fields\n    // 3. An accept() method calling the appropriate visitor method\n}\n```\n\n```java\n// ast/Stmt.java  \npackage lox.ast;\n\nimport java.util.List;\nimport lox.Token;\n\npublic abstract class Stmt {\n    public interface Visitor<V> {\n        V visitExpressionStmt(Expression stmt);\n        V visitPrintStmt(Print stmt);\n        V visitVarStmt(Var stmt);\n        V visitBlockStmt(Block stmt);\n        V visitIfStmt(If stmt);\n        V visitWhileStmt(While stmt);\n        V visitFunctionStmt(Function stmt);\n        V visitReturnStmt(Return stmt);\n        V visitClassStmt(Class stmt);\n    }\n\n    public abstract <V> V accept(Visitor<V> visitor);\n\n    public static class Expression extends Stmt {\n        public final Expr expression;\n\n        public Expression(Expr expression) {\n            this.expression = expression;\n        }\n\n        @Override\n        public <V> V accept(Visitor<V> visitor) {\n            return visitor.visitExpressionStmt(this);\n        }\n    }\n\n    // TODO: Add other statement node classes (Print, Var, Block, If,\n    // While, Function, Return, Class) following the same pattern.\n    // Remember: FunctionStmt should store name (Token), params (List<Token>),\n    // and body (List<Stmt>).\n}\n```\n\n**Language-Specific Hints**\n\n1. **Use `final` fields** in all data classes (Token, AST nodes) to ensure immutability.\n2. **Override `toString()`** in Token and AST nodes for debugging.\n3. **Use `HashMap` for environments** - it's simple and fast enough for our needs.\n4. **Be careful with `null`** - Lox's `nil` is represented by Java `null`, but not all `null` values are Lox nil (could be uninitialized Java references).\n5. **Use `Double` for numbers** - Lox uses double-precision floats. Remember that `1 + 2` produces `3.0` (a Double), not `3` (an Integer).\n\n**Milestone Checkpoint: Data Structures**\n\nAfter implementing the data model, you should be able to:\n- Compile all Java files without errors\n- Create Token objects manually in a test and verify their fields\n- Construct a simple AST manually (e.g., `new Expr.Binary(new Expr.Literal(1), new Token(TokenType.PLUS, \"+\", null, 1), new Expr.Literal(2))`)\n- Create nested environments and verify variable lookup follows the chain\n\nRun a simple test:\n```java\n// Test.java\npublic class Test {\n    public static void main(String[] args) {\n        // Test Token\n        Token plus = new Token(TokenType.PLUS, \"+\", null, 1);\n        System.out.println(\"Token: \" + plus);\n        \n        // Test Environment chain\n        Environment global = new Environment();\n        global.define(\"x\", 10.0);\n        \n        Environment local = new Environment(global);\n        local.define(\"y\", 20.0);\n        \n        Token xToken = new Token(TokenType.IDENTIFIER, \"x\", null, 1);\n        Token yToken = new Token(TokenType.IDENTIFIER, \"y\", null, 1);\n        \n        System.out.println(\"x in local: \" + local.get(xToken)); // Should print 10.0\n        System.out.println(\"y in local: \" + local.get(yToken)); // Should print 20.0\n    }\n}\n```\n\nExpected output:\n```\nToken: PLUS + null\nx in local: 10.0\ny in local: 20.0\n```\n\nIf you get `NullPointerException` or incorrect values, check:\n1. Environment chain links (parent references)\n2. HashMap key matching (names are case-sensitive)\n3. That you're using `Double` values, not `Integer`\n\n\n> **Milestone(s):** Milestone 1 - Scanner (Lexer)\n\n## 5.1 Component Design: Scanner (Lexer) [Milestone 1]\n\nThe **Scanner**, also called the **lexer** (lexical analyzer), is the gateway through which raw Lox source code enters the interpreter pipeline. Its singular responsibility is to transform a linear sequence of characters into a structured sequence of **tokens**—meaningful atomic units that represent the basic vocabulary of the language. Without this component, the interpreter would see only an undifferentiated stream of characters, unable to distinguish keywords from identifiers or numbers from operators.\n\n### Mental Model: The Tokenizer\n\nThink of the scanner as a **language translator breaking down a sentence into labeled dictionary entries**. Given the sentence \"The quick brown fox jumps over 42.5 lazy dogs,\" a translator would identify each word (\"The\" → article, \"quick\" → adjective, \"brown\" → adjective, \"fox\" → noun, \"jumps\" → verb, etc.), recognize \"42.5\" as a number, and note the period as punctuation. The scanner performs exactly this role for Lox source code: it reads character by character, recognizes patterns that constitute valid language elements, categorizes them (is \"while\" a keyword or an identifier?), and outputs a structured list where each entry knows its type, exact text, literal value (for numbers and strings), and position in the source. This tokenized form provides the parser with manageable, semantically meaningful units instead of raw characters.\n\n### Interface and State\n\nThe Scanner is a stateful component that processes source code in a single, linear pass. Its interface is deliberately minimal: a constructor accepting the source string and a single public method that drives the scanning process.\n\n#### Scanner Public Interface\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `Scanner` constructor | `source: String` | `Scanner` instance | Creates a new scanner for the given source code string. Stores the source and initializes scanning state. |\n| `scanTokens` | None | `List<Token>` | The main entry point. Scans the entire source, returning a complete list of tokens. This method orchestrates the scanning loop until the end of the source is reached. |\n\n#### Scanner Internal State\n\nThe scanner maintains four essential pieces of state during its operation, each tracked by an integer index or counter:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `source` | `String` | The complete source code text to be scanned. This is the input character stream. |\n| `tokens` | `List<Token>` | The accumulating list of successfully scanned tokens. This is the output of the scanning process. |\n| `start` | `int` | Index in `source` pointing to the first character of the *current* token being scanned. |\n| `current` | `int` | Index in `source` pointing to the *next* character to be examined (the \"lookahead\" position). |\n| `line` | `int` | Current line number in the source (1-indexed). Incremented when newline characters are encountered. Essential for accurate error reporting. |\n\nThe relationship between `start` and `current` is fundamental: `start` marks where the current token began, while `current` marches forward through the source as characters are examined. When a complete token is recognized, the substring from `start` to `current-1` becomes the token's `lexeme`, and both positions are captured in a new `Token` object added to the `tokens` list. Then `start` is reset to `current` to begin the next token.\n\n### Scanning Algorithm\n\nThe scanner operates via a central loop that repeatedly examines characters, identifies token boundaries, and emits tokens until the source is exhausted. The algorithm follows a deterministic, procedural flow with clear branching based on the character at the current position.\n\n#### Step-by-Step Scanning Procedure\n\n1. **Initialization**: Create empty token list. Set `start = 0`, `current = 0`, `line = 1`.\n\n2. **Main Scanning Loop**: While not at end of source (`current < source.length()`):\n   a. **Reset token start**: Set `start = current`.\n   b. **Examine next character**: Call `peek()` to look at character at `current` without consuming it.\n   c. **Branch on character type**:\n      - **Single-character tokens** (`(`, `)`, `{`, `}`, `,`, `.`, `-`, `+`, `;`, `*`, `/`): Directly create corresponding token.\n      - **One-or-two-character tokens** (`!`, `=`, `<`, `>`, `==`, `!=`, `<=`, `>=`): Check next character for `=` to decide between single or double operator.\n      - **String literals** (`\"`): Enter string scanning mode, consuming until closing `\"` (handling escapes).\n      - **Number literals** (`0`-`9`): Enter number scanning mode, consuming digits and optional decimal point followed by more digits.\n      - **Identifiers and keywords** (`a`-`z`, `A`-`Z`, `_`): Enter identifier scanning mode, consuming alphanumeric/underscore characters, then check if lexeme matches a reserved keyword.\n      - **Whitespace** (` `, `\\t`, `\\r`, `\\n`): Skip (update line count for newlines).\n      - **Comments** (`//` or `/*`): Skip until end of line or closing `*/`.\n      - **Unrecognized character**: Report lexical error with line number.\n   d. **Advance position**: Increment `current` as characters are consumed.\n   e. **Emit token**: For recognized tokens (excluding whitespace/comments), create `Token` with type, lexeme, literal value (if any), and current line, then add to `tokens`.\n\n3. **Finalization**: After loop, add an `EOF` (end-of-file) token to mark the end of the token stream.\n\n#### Detailed Scanning Logic for Key Token Types\n\n**String Literals**:\n1. Advance past opening `\"`.\n2. While next character is not `\"`:\n   - If end of file, report error: \"Unterminated string.\"\n   - If newline, increment `line` (Lox supports multiline strings).\n   - If `\\` (backslash), process escape sequence: `\\\"`, `\\\\`, `\\n`, `\\t`, etc.\n   - Otherwise, add character to string value.\n3. Advance past closing `\"`.\n4. Create token with literal value as the accumulated string (without quotes).\n\n**Number Literals**:\n1. Consume consecutive digits (`0`-`9`).\n2. If next character is `.` and character after that is a digit:\n   - Consume `.`.\n   - Consume consecutive digits after decimal.\n3. Convert lexeme to `double` value (Lox uses double-precision floating point).\n\n**Identifiers and Keywords**:\n1. Consume consecutive alphanumeric characters and underscores (`a`-`z`, `A`-`Z`, `0`-`9`, `_`).\n2. Check if resulting lexeme matches a reserved keyword (e.g., \"and\", \"class\", \"if\", \"while\").\n   - Use a hash map from string to `TokenType` for efficient lookup.\n3. If match, emit keyword token; otherwise, emit identifier token.\n\n### ADR: Visitor vs. Procedural Scanning\n\n> **Decision: Procedural Scanning Loop Over State Machine/Visitor Patterns**\n>\n> - **Context**: The scanner must reliably recognize a finite set of token patterns from a linear character stream. While lexical analysis can be implemented using various formalisms (state machines, table-driven scanners, or visitor patterns), we need a solution that is educational, straightforward to implement and debug, and maps clearly to the lexical grammar of Lox.\n>\n> - **Options Considered**:\n>   1. **Procedural scanning loop**: A manual loop with explicit character-by-character examination and branching via `switch`/`if` statements.\n>   2. **Finite-state machine (FSM)**: Explicit state transitions driven by character classes, possibly implemented via state pattern or transition table.\n>   3. **Visitor pattern scanning**: Separate visitor classes for each major token category that traverse the character stream.\n>\n> - **Decision**: Implement a **procedural scanning loop**.\n>\n> - **Rationale**:\n>   1. **Educational clarity**: The procedural approach maps directly to the human mental model of \"look at character, decide what to do.\" Each token type's recognition logic is localized and explicit, making it easier for learners to trace execution and understand the scanning process.\n>   2. **Simplicity**: No need to define state classes, transition tables, or visitor hierarchies. The scanner's logic is contained in one straightforward class with helper methods.\n>   3. **Direct control**: Error reporting and recovery (like skipping invalid characters) can be inserted precisely where needed in the flow.\n>   4. **Performance**: While not a primary goal, the direct character manipulation and explicit branching are efficient for the small-scale scanning needs of an educational interpreter.\n>\n> - **Consequences**:\n>   - **Positive**: Implementation is straightforward to write, read, and debug. Changes to token recognition (e.g., adding a new operator) involve localized edits.\n>   - **Negative**: The scanner class becomes a \"god object\" containing all scanning logic, which could grow large. However, for Lox's limited token set, this is manageable.\n>   - **Mitigation**: Logic for different token categories can be separated into well-named private methods (e.g., `scanString()`, `scanNumber()`, `scanIdentifier()`).\n\n#### Options Comparison Table\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| **Procedural scanning loop** | Direct mapping to lexical grammar; Easy to understand and debug; Simple error handling; No abstraction overhead | Can become monolithic; Manual character-by-character handling may be verbose | **Chosen** - Best aligns with educational goals and simplicity |\n| **Finite-state machine** | Formal, clean separation of states; Potentially easier to extend for complex patterns | Significant boilerplate for state classes; Obfuscates the straightforward logic; Harder to debug state transitions | Adds unnecessary complexity for Lox's simple lexical patterns |\n| **Visitor pattern scanning** | Separates token recognition logic into visitor classes; Follows OOP principles | Heavy abstraction for a linear process; Visitors don't naturally fit scanning; Overkill for simple token patterns | The visitor pattern is better suited for heterogeneous tree traversal (AST), not linear scanning |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Mishandling Multi-Character Operators**\n\n**Description**: Failing to properly handle operators that could be one or two characters long (`=`, `==`, `!`, `!=`, `<`, `<=`, `>`, `>=`). A naive implementation might emit a single `=` token when seeing `==`, leaving the second `=` to be scanned as a separate token or causing a parse error.\n\n**Why it's wrong**: The parser expects a single `==` token for equality comparison. Receiving two separate `=` tokens would lead to a syntax error or incorrect parsing (e.g., interpreting `a == b` as assignment `a = = b`).\n\n**How to avoid**: Implement a `match(expected)` helper that looks at the next character. If it matches `expected`, consume it and return `true`. Use this when scanning `=`, `!`, `<`, `>`: if `match('=')` returns `true`, emit the two-character operator; otherwise emit the single-character one.\n\n⚠️ **Pitfall: Unterminated Strings Without Error Recovery**\n\n**Description**: When scanning a string literal, if the closing double quote is missing (e.g., `\"hello`), the scanner may either crash (index out of bounds) or enter an infinite loop consuming the rest of the source.\n\n**Why it's wrong**: Lexical errors should be reported gracefully with location information, not cause interpreter crashes. The scanner should detect the EOF before the closing quote and report a meaningful error.\n\n**How to avoid**: In `scanString()`, check for EOF (`peek() == '\\0'`) at each iteration. If EOF is reached before the closing quote, call an error reporting function with the line number and message \"Unterminated string.\" Then break out of the loop to continue scanning the rest of the source (or halt, depending on error recovery strategy).\n\n⚠️ **Pitfall: Incorrect Number Literal Scanning**\n\n**Description**: Numbers with multiple decimal points (e.g., `123.45.67`) might be incorrectly tokenized as a single number, or numbers trailing with a dot (e.g., `123.`) might be mishandled.\n\n**Why it's wrong**: These are invalid numeric literals in Lox. The scanner should emit a single token for valid numbers but should not silently accept invalid ones. A number with two decimal points is a syntax error that should be caught by the scanner.\n\n**How to avoid**: After consuming the integer part and seeing a `.`, peek at the *next* character. If it's a digit, consume the dot and fractional digits. If it's not a digit, **do not consume the dot**—the number ends at the previous digit, and the dot will be scanned as a separate `.` token (likely leading to a parse error). This correctly handles both `123.` (two tokens: `123` and `.`) and `123.45` (one token).\n\n⚠️ **Pitfall: Forgetting Line Number Tracking**\n\n**Description**: Not updating the `line` counter when encountering newline characters (`\\n`), especially inside strings or when skipping comments.\n\n**Why it's wrong**: Error messages (lexical, syntactic, runtime) rely on accurate line numbers to point developers to the problematic code. If line numbers are off by even one, debugging becomes significantly harder.\n\n**How to avoid**: Increment `line` consistently in three places: 1) When advancing past a `\\n` character in the main scanning loop (for newlines in general code). 2) Inside `scanString()` when a `\\n` is encountered (Lox supports multiline strings). 3) Inside block comment skipping when `\\n` is encountered.\n\n⚠️ **Pitfall: Keyword Matching Case-Sensitivity Issues**\n\n**Description**: Using case-sensitive string comparison for keywords when Lox keywords are case-sensitive (`while` is a keyword, `While` is not).\n\n**Why it's wrong**: If matching is case-insensitive, `While` would be incorrectly tokenized as a keyword rather than an identifier, preventing users from using that as a variable name (contrary to language spec).\n\n**How to avoid**: Use exact string equality when checking the identifier lexeme against the keyword map. Lox's keywords are all lowercase, so the lexeme must match exactly in case.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Scanner Implementation | Manual character-by-character scanning with `String.charAt()` | Using `java.io.Reader` with buffering for file I/O, or regex for token patterns (not recommended for learning) |\n| Token Storage | `ArrayList<Token>` | `LinkedList<Token>` if frequent insertion at middle needed (not the case here) |\n| Keyword Lookup | `HashMap<String, TokenType>` with static initialization | Trie data structure for efficient prefix matching (overkill for ~20 keywords) |\n\n#### B. Recommended File/Module Structure\n\n```\nlox/\n├── Lox.java                 # Main entry point, coordinates components\n├── Token.java              # Token class definition\n├── TokenType.java          # Enumeration of token types\n├── scanner/\n│   ├── Scanner.java        # Scanner implementation (this component)\n│   └── ScannerTest.java    # Unit tests for scanner\n├── parser/                 # (Milestone 2-3)\n├── ast/                    # (Milestone 2)\n└── interpreter/            # (Milestone 4+)\n```\n\n#### C. Infrastructure Starter Code\n\nThe `Token` class and `TokenType` enum are foundational data structures used throughout the interpreter. Here is their complete implementation:\n\n**TokenType.java** (complete):\n```java\npackage com.craftinginterpreters.lox;\n\n// Each enum value represents a distinct category of lexical element in Lox.\npublic enum TokenType {\n    // Single-character tokens.\n    LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,\n    COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,\n\n    // One or two character tokens.\n    BANG, BANG_EQUAL,\n    EQUAL, EQUAL_EQUAL,\n    GREATER, GREATER_EQUAL,\n    LESS, LESS_EQUAL,\n\n    // Literals.\n    IDENTIFIER, STRING, NUMBER,\n\n    // Keywords.\n    AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,\n    PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,\n\n    // End-of-file marker.\n    EOF\n}\n```\n\n**Token.java** (complete):\n```java\npackage com.craftinginterpreters.lox;\n\n// Represents a single lexical token with its metadata.\npublic class Token {\n    public final TokenType type;    // Category of token (e.g., NUMBER, WHILE)\n    public final String lexeme;     // Raw text as it appeared in source\n    public final Object literal;    // Runtime value for literals (String, Double)\n    public final int line;          // Line number where token starts (1-indexed)\n\n    public Token(TokenType type, String lexeme, Object literal, int line) {\n        this.type = type;\n        this.lexeme = lexeme;\n        this.literal = literal;\n        this.line = line;\n    }\n\n    @Override\n    public String toString() {\n        return type + \" \" + lexeme + \" \" + literal;\n    }\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**Scanner.java** (skeleton with TODOs):\n```java\npackage com.craftinginterpreters.lox.scanner;\n\nimport com.craftinginterpreters.lox.Token;\nimport com.craftinginterpreters.lox.TokenType;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Scanner {\n    private final String source;          // The raw source code\n    private final List<Token> tokens = new ArrayList<>();\n    private int start = 0;                // Start index of current token\n    private int current = 0;              // Current character index being examined\n    private int line = 1;                 // Current line number\n\n    // Static map for keyword lookup: lexeme -> TokenType\n    private static final Map<String, TokenType> keywords;\n    static {\n        keywords = new HashMap<>();\n        keywords.put(\"and\",    TokenType.AND);\n        keywords.put(\"class\",  TokenType.CLASS);\n        keywords.put(\"else\",   TokenType.ELSE);\n        keywords.put(\"false\",  TokenType.FALSE);\n        keywords.put(\"for\",    TokenType.FOR);\n        keywords.put(\"fun\",    TokenType.FUN);\n        keywords.put(\"if\",     TokenType.IF);\n        keywords.put(\"nil\",    TokenType.NIL);\n        keywords.put(\"or\",     TokenType.OR);\n        keywords.put(\"print\",  TokenType.PRINT);\n        keywords.put(\"return\", TokenType.RETURN);\n        keywords.put(\"super\",  TokenType.SUPER);\n        keywords.put(\"this\",   TokenType.THIS);\n        keywords.put(\"true\",   TokenType.TRUE);\n        keywords.put(\"var\",    TokenType.VAR);\n        keywords.put(\"while\",  TokenType.WHILE);\n    }\n\n    public Scanner(String source) {\n        this.source = source;\n    }\n\n    // Main entry point: scan all tokens from source.\n    public List<Token> scanTokens() {\n        // TODO 1: Loop while not at end of source\n        while (!isAtEnd()) {\n            // We are at the beginning of the next token.\n            start = current;\n            scanToken();\n        }\n\n        // TODO 2: Add EOF token at the end\n        tokens.add(new Token(TokenType.EOF, \"\", null, line));\n        return tokens;\n    }\n\n    // Examines the next character(s) and emits a token.\n    private void scanToken() {\n        // TODO 3: Get the next character (consume it)\n        char c = advance();\n        \n        // TODO 4: Branch based on character using switch statement\n        switch (c) {\n            // Single-character tokens\n            case '(': addToken(TokenType.LEFT_PAREN); break;\n            case ')': addToken(TokenType.RIGHT_PAREN); break;\n            case '{': addToken(TokenType.LEFT_BRACE); break;\n            case '}': addToken(TokenType.RIGHT_BRACE); break;\n            case ',': addToken(TokenType.COMMA); break;\n            case '.': addToken(TokenType.DOT); break;\n            case '-': addToken(TokenType.MINUS); break;\n            case '+': addToken(TokenType.PLUS); break;\n            case ';': addToken(TokenType.SEMICOLON); break;\n            case '*': addToken(TokenType.STAR); break;\n            \n            // One-or-two-character tokens\n            case '!':\n                // TODO 5: If next char is '=', emit BANG_EQUAL else BANG\n                addToken(match('=') ? TokenType.BANG_EQUAL : TokenType.BANG);\n                break;\n            case '=':\n                // TODO 6: If next char is '=', emit EQUAL_EQUAL else EQUAL\n                addToken(match('=') ? TokenType.EQUAL_EQUAL : TokenType.EQUAL);\n                break;\n            case '<':\n                // TODO 7: If next char is '=', emit LESS_EQUAL else LESS\n                addToken(match('=') ? TokenType.LESS_EQUAL : TokenType.LESS);\n                break;\n            case '>':\n                // TODO 8: If next char is '=', emit GREATER_EQUAL else GREATER\n                addToken(match('=') ? TokenType.GREATER_EQUAL : TokenType.GREATER);\n                break;\n            \n            // Division operator or comment\n            case '/':\n                // TODO 9: If next char is '/', it's a single-line comment\n                if (match('/')) {\n                    // Consume until end of line\n                    while (peek() != '\\n' && !isAtEnd()) advance();\n                } \n                // TODO 10: Optional - handle block comments /* ... */\n                // else if (match('*')) {\n                //     blockComment();\n                // }\n                else {\n                    addToken(TokenType.SLASH);\n                }\n                break;\n            \n            // Whitespace (ignore, but track newlines)\n            case ' ':\n            case '\\r':\n            case '\\t':\n                break;\n            case '\\n':\n                // TODO 11: Increment line counter\n                line++;\n                break;\n            \n            // String literals\n            case '\"': \n                // TODO 12: Call string() method to handle string scanning\n                string(); \n                break;\n            \n            default:\n                // TODO 13: Handle numbers (if c is digit)\n                if (isDigit(c)) {\n                    number();\n                } \n                // TODO 14: Handle identifiers/keywords (if c is letter or underscore)\n                else if (isAlpha(c)) {\n                    identifier();\n                } \n                else {\n                    // TODO 15: Report lexical error for unexpected character\n                    Lox.error(line, \"Unexpected character: '\" + c + \"'\");\n                }\n                break;\n        }\n    }\n\n    // Scans a string literal: assumes opening \" has been consumed.\n    private void string() {\n        // TODO 16: Loop while next char is not '\"' and not at end\n        while (peek() != '\"' && !isAtEnd()) {\n            // TODO 17: If newline, increment line counter (Lox supports multiline strings)\n            if (peek() == '\\n') line++;\n            // TODO 18: Handle escape sequences if desired (optional milestone)\n            advance();\n        }\n        \n        // TODO 19: Check for unterminated string (if at end)\n        if (isAtEnd()) {\n            Lox.error(line, \"Unterminated string.\");\n            return;\n        }\n        \n        // TODO 20: Consume the closing \"\n        advance();\n        \n        // TODO 21: Extract string value (without quotes) and add token\n        String value = source.substring(start + 1, current - 1);\n        addToken(TokenType.STRING, value);\n    }\n\n    // Scans a number literal: digits optionally followed by . and more digits.\n    private void number() {\n        // TODO 22: Consume consecutive digits\n        while (isDigit(peek())) advance();\n        \n        // TODO 23: Look for fractional part (decimal point followed by digits)\n        if (peek() == '.' && isDigit(peekNext())) {\n            // Consume the decimal point\n            advance();\n            // Consume fractional digits\n            while (isDigit(peek())) advance();\n        }\n        \n        // TODO 24: Convert lexeme to double and add NUMBER token\n        double value = Double.parseDouble(source.substring(start, current));\n        addToken(TokenType.NUMBER, value);\n    }\n\n    // Scans an identifier or keyword: alphanumeric characters and underscores.\n    private void identifier() {\n        // TODO 25: Consume alphanumeric characters and underscores\n        while (isAlphaNumeric(peek())) advance();\n        \n        // TODO 26: Check if lexeme is a keyword\n        String text = source.substring(start, current);\n        TokenType type = keywords.get(text);\n        if (type == null) type = TokenType.IDENTIFIER;\n        \n        // TODO 27: Add appropriate token (keyword or identifier)\n        addToken(type);\n    }\n\n    // =============== Helper Methods ===============\n\n    // Returns true if we've consumed all characters.\n    private boolean isAtEnd() {\n        return current >= source.length();\n    }\n\n    // Consumes and returns the next character.\n    private char advance() {\n        current++;\n        return source.charAt(current - 1);\n    }\n\n    // Returns the next character without consuming it (lookahead).\n    private char peek() {\n        if (isAtEnd()) return '\\0';\n        return source.charAt(current);\n    }\n\n    // Returns the character after the next (two-character lookahead).\n    private char peekNext() {\n        if (current + 1 >= source.length()) return '\\0';\n        return source.charAt(current + 1);\n    }\n\n    // Checks if the next character matches expected, consuming it only if true.\n    private boolean match(char expected) {\n        // TODO 28: If at end, return false\n        if (isAtEnd()) return false;\n        // TODO 29: If next character matches expected, consume it and return true\n        if (source.charAt(current) != expected) return false;\n        current++;\n        return true;\n    }\n\n    // Adds a token with no literal value.\n    private void addToken(TokenType type) {\n        addToken(type, null);\n    }\n\n    // Adds a token with a literal value.\n    private void addToken(TokenType type, Object literal) {\n        // TODO 30: Extract lexeme from source and create token\n        String text = source.substring(start, current);\n        tokens.add(new Token(type, text, literal, line));\n    }\n\n    // Returns true if c is a digit (0-9).\n    private boolean isDigit(char c) {\n        return c >= '0' && c <= '9';\n    }\n\n    // Returns true if c is a letter (a-z, A-Z) or underscore.\n    private boolean isAlpha(char c) {\n        return (c >= 'a' && c <= 'z') ||\n               (c >= 'A' && c <= 'Z') ||\n                c == '_';\n    }\n\n    // Returns true if c is alphanumeric or underscore.\n    private boolean isAlphaNumeric(char c) {\n        return isAlpha(c) || isDigit(c);\n    }\n}\n```\n\n**Note on Error Reporting**: The skeleton references `Lox.error(line, message)`. You'll need to implement a simple error reporting mechanism in your main `Lox` class. For now, you can use:\n\n```java\npublic class Lox {\n    static void error(int line, String message) {\n        report(line, \"\", message);\n    }\n    \n    private static void report(int line, String where, String message) {\n        System.err.println(\"[line \" + line + \"] Error\" + where + \": \" + message);\n    }\n}\n```\n\n#### E. Language-Specific Hints\n\n- **Character Access**: Use `String.charAt()` for simple character access. For production code, consider converting the source to a `char[]` for performance, but for clarity, `charAt()` is fine.\n- **String Substrings**: `source.substring(start, current)` creates a new string each time. This is acceptable for scanning, but be aware of memory if scanning huge files.\n- **Number Parsing**: `Double.parseDouble()` handles both integer and decimal numbers. Lox uses double-precision floating point for all numbers.\n- **HashMap Initialization**: The static initializer for `keywords` runs once when the class is loaded. This is efficient and thread-safe for this use case.\n- **Error Handling**: For lexical errors, you might want to collect multiple errors rather than halting at the first. Consider adding an `errors` list to the scanner and reporting all at once.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the scanner, you should be able to test it with simple Lox code snippets:\n\n**Test Command** (assuming you have a simple main method in `Lox.java` that creates a scanner and prints tokens):\n```bash\ncd /path/to/lox\njavac com/craftinginterpreters/lox/*.java com/craftinginterpreters/lox/scanner/*.java\njava com.craftinginterpreters.lox.Lox \"var x = 42;\"\n```\n\n**Expected Output**: A list of tokens printed, something like:\n```\nVAR var null\nIDENTIFIER x null\nEQUAL = null\nNUMBER 42 42.0\nSEMICOLON ; null\nEOF  null\n```\n\n**Verification Steps**:\n1. **Single-character tokens**: Test `( ) { } , . - + ; * /` all produce correct tokens.\n2. **Multi-character operators**: Test `= == ! != < <= > >=` produce correct single or double tokens.\n3. **Strings**: Test `\"hello\"` produces STRING token with literal \"hello\". Test `\"multi\\nline\"` handles escape sequences (optional) and newline counting.\n4. **Numbers**: Test `123`, `123.456`, `.456` (should be DOT then NUMBER 456), `123.` (should be NUMBER 123 then DOT).\n5. **Keywords and identifiers**: Test `while` → WHILE keyword, `While` → IDENTIFIER.\n6. **Whitespace and comments**: Test that spaces, tabs, and `// comments` are ignored and don't produce tokens.\n7. **Error reporting**: Test `\"unterminated` produces \"Unterminated string\" error with line number. Test `@` produces \"Unexpected character\" error.\n\n**Signs of Problems**:\n- Infinite loop: Likely missing advance() calls or incorrect condition in scanning loop.\n- Missing tokens: `start` and `current` not being reset properly after token emission.\n- Incorrect line numbers: Not incrementing `line` on newlines inside strings or comments.\n- Number parsing errors: `Double.parseDouble()` throwing exception for invalid numbers like `123.` (should be caught by your logic before parsing).\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Scanner goes into infinite loop | Missing `advance()` call in a branch, or `isAtEnd()` always returns false | Add debug prints showing `current` and character at each loop iteration. | Ensure every path through `scanToken()` either advances `current` or breaks/returns. |\n| String literal includes quotes in value | Using `start` to `current` without trimming quotes | Print the extracted substring value before creating token. | In `string()` method, use `start + 1` and `current - 1` as indices. |\n| Numbers with decimal point produce two tokens | Not checking that character after `.` is a digit before consuming | Print lexeme when scanning numbers. Check logic for fractional part. | Use `peekNext()` to look ahead two characters when seeing `.`. |\n| Keywords not recognized | Case mismatch or missing entry in keywords map | Print the extracted identifier text and check map lookup. | Ensure keyword map has all lowercase entries and identifier is converted to lowercase for lookup (if language is case-insensitive; Lox is case-sensitive). |\n| Line numbers off by one | Not counting newlines in strings or block comments | Add print statement showing line number for each token. | Increment `line` counter when encountering `\\n` in `string()` and comment-skipping logic. |\n| \"Unterminated string\" error on valid strings | Not consuming the closing quote character | Check that `advance()` is called after the while loop in `string()`. | Ensure the closing `\"` is consumed before creating the token. |\n\n\n> **Milestone(s):** Milestone 2 - Representing Code (AST), Milestone 3 - Parsing Expressions\n\n## 5.2 Component Design: Parser & AST [Milestones 2 & 3]\n\nThis section details the design of the **Parser**, the component that translates a linear sequence of tokens into a structured, hierarchical **Abstract Syntax Tree (AST)**, and the definition of the AST node classes themselves. If the scanner breaks a paragraph into words, the parser is the grammarian who diagrams the sentence, identifying the subject, verb, object, and how they relate through nesting and precedence rules. This transformation from `List<Token>` to `List<Stmt>` is the heart of syntactic analysis, bridging the gap between raw text and executable structure.\n\n### Mental Model: The Sentence Diagrammer\n\nImagine you are given a jumbled list of words and punctuation from a sentence: `[\"The\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\", \".\"]`. Your task is to reconstruct the sentence's grammatical structure. You identify \"fox\" as the subject noun, \"jumps\" as the verb, and \"over the lazy dog\" as a prepositional phrase modifying the verb. You then arrange these into a tree showing that \"quick brown\" modifies \"fox\", and \"lazy\" modifies \"dog\".\n\nThe **Parser** performs exactly this role for programming languages. It consumes the flat list of tokens produced by the scanner and applies the formal grammar rules of Lox to build a tree structure (the AST). This tree explicitly represents the nesting (parentheses, blocks), precedence (multiplication before addition), and associativity (left-to-right for most operators) that are only implicit in the linear token stream. Each node in the tree corresponds to a syntactic construct in the language—an expression, a statement, a declaration—and its children are the sub-components of that construct.\n\n### AST Definition and the Visitor Pattern\n\nThe **Abstract Syntax Tree (AST)** is the canonical, in-memory representation of a Lox program's syntactic structure after parsing. It is \"abstract\" because it omits syntactic details that don't affect meaning, like the exact placement of parentheses (though their grouping effect is captured) and semicolons between statements. The AST serves as the immutable input to all subsequent phases: the **Interpreter** walks it to execute the program, and a **PrettyPrinter** can traverse it to regenerate formatted source code.\n\nThe AST is defined as a hierarchy of node types, rooted in two abstract base classes: `Expr` for expressions (which produce a value) and `Stmt` for statements (which perform an action). Each concrete node type (e.g., `Binary`, `If`) is a subclass of one of these and holds fields referencing its child nodes and relevant tokens.\n\n| AST Node Type (Class) | Base Class | Key Fields (Name → Type) | Description |\n| :--- | :--- | :--- | :--- |\n| **Binary** | `Expr` | `left` → `Expr`, `operator` → `Token`, `right` → `Expr` | A binary operation like `1 + 2` or `x == y`. |\n| **Unary** | `Expr` | `operator` → `Token`, `right` → `Expr` | A unary operation like `-5` or `!true`. |\n| **Grouping** | `Expr` | `expression` → `Expr` | A parenthesized expression `(1 + 2)`. |\n| **Literal** | `Expr` | `value` → `Object` | A literal value: number, string, boolean, `nil`. |\n| **Variable** | `Expr` | `name` → `Token` | A reference to a variable by its name. |\n| **Assign** | `Expr` | `name` → `Token`, `value` → `Expr` | An assignment `x = 5`. |\n| **Logical** | `Expr` | `left` → `Expr`, `operator` → `Token`, `right` → `Expr` | A logical `and` or `or` expression. |\n| **Call** | `Expr` | `callee` → `Expr`, `paren` → `Token`, `arguments` → `List<Expr>` | A function call `fn(1, 2)`. |\n| **Get** | `Expr` | `object` → `Expr`, `name` → `Token` | Property access `obj.property`. |\n| **Set** | `Expr` | `object` → `Expr`, `name` → `Token`, `value` → `Expr` | Property assignment `obj.property = 5`. |\n| **This** | `Expr` | `keyword` → `Token` | The `this` keyword. |\n| **Super** | `Expr` | `keyword` → `Token`, `method` → `Token` | A superclass method call `super.method()`. |\n| **Expression** | `Stmt` | `expression` → `Expr` | A statement that wraps a single expression. |\n| **Print** | `Stmt` | `expression` → `Expr` | A `print` statement. |\n| **Var** | `Stmt` | `name` → `Token`, `initializer` → `Expr` | A `var` declaration. |\n| **Block** | `Stmt` | `statements` → `List<Stmt>` | A block `{ ... }` of statements. |\n| **If** | `Stmt` | `condition` → `Expr`, `thenBranch` → `Stmt`, `elseBranch` → `Stmt` | An `if` statement with optional `else`. |\n| **While** | `Stmt` | `condition` → `Expr`, `body` → `Stmt` | A `while` loop. |\n| **Function** | `Stmt` | `name` → `Token`, `params` → `List<Token>`, `body` → `List<Stmt>` | A `fun` function declaration. |\n| **Return** | `Stmt` | `keyword` → `Token`, `value` → `Expr` | A `return` statement. |\n| **Class** | `Stmt` | `name` → `Token`, `superclass` → `Expr.Variable`, `methods` → `List<Stmt.Function>` | A `class` declaration. |\n\nTo perform operations over this heterogeneous tree (like evaluation or printing), we need a way to dispatch to type-specific logic for each node. A naive approach uses a cascade of `instanceof` checks and casts, which is brittle and verbose. The **Visitor Pattern** provides an elegant, type-safe alternative. It leverages **double dispatch**: the AST node's `accept` method calls the appropriate `visit` method on the visitor object, passing itself as an argument. This allows the visitor to define behavior for each node type in a single class.\n\n> **Key Insight:** The Visitor Pattern effectively adds a virtual method to each AST node type without modifying the node classes themselves. This keeps the AST data structures simple and immutable, while allowing arbitrary operations (interpretation, printing, static analysis) to be defined as separate, cohesive visitor classes.\n\nThe pattern requires two visitor interfaces—one for expressions, one for statements—each declaring a `visit` method for every concrete node type.\n\n| Interface Method | Parameters | Returns | Description |\n| :--- | :--- | :--- | :--- |\n| `Expr.Visitor<R>.visitBinaryExpr` | `Binary` expr | `R` | Visit a `Binary` expression node. |\n| `Expr.Visitor<R>.visitUnaryExpr` | `Unary` expr | `R` | Visit a `Unary` expression node. |\n| ... (and so on for every `Expr` subclass) | ... | ... | ... |\n| `Stmt.Visitor<V>.visitExpressionStmt` | `Expression` stmt | `V` | Visit an `Expression` statement node. |\n| `Stmt.Visitor<V>.visitPrintStmt` | `Print` stmt | `V` | Visit a `Print` statement node. |\n| ... (and so on for every `Stmt` subclass) | ... | ... | ... |\n\nEvery concrete `Expr` and `Stmt` node implements an `accept` method that calls the corresponding visitor method, passing `this`.\n\n### Parsing Expression Grammar (PEG) & Recursive Descent\n\nThe parser must implement the **grammar rules** that define valid Lox programs. We use a **Parsing Expression Grammar (PEG)** style, which is well-suited for **recursive descent parsing**. In recursive descent, each grammar rule becomes a function in the parser. The parser's internal state is simple: a list of tokens and an index pointing to the next token to consume (`current`).\n\nThe core challenge is correctly parsing expressions with multiple levels of **operator precedence** and **associativity**. Lox has the following precedence levels (from lowest/binding loosest to highest/binding tightest):\n1. **Assignment** (`=`), which is right-associative.\n2. **Logical `or`** (`or`), left-associative.\n3. **Logical `and`** (`and`), left-associative.\n4. **Equality** (`==`, `!=`), left-associative.\n5. **Comparison** (`<`, `>`, `<=`, `>=`), left-associative.\n6. **Term** (`+`, `-`), left-associative.\n7. **Factor** (`*`, `/`), left-associative.\n8. **Unary** (`!`, `-`), right-associative.\n9. **Primary** (literals, variables, grouping, calls, etc.).\n\nThe recursive descent parser encodes this precedence hierarchy directly into its call graph. The function for the lowest-precedence operator (`assignment`) calls the function for the next higher level (`logical_or`), which calls the next (`logical_and`), and so on, until reaching `primary()`, which handles atomic expressions. This creates a natural nesting where higher-precedence operators are parsed deeper in the recursive call stack, resulting in an AST where they are lower in the tree (closer to the leaves).\n\n![Parser Expression Precedence Flowchart](./diagrams/diagram-parser-precedence.svg)\n\nThe parsing algorithm for a single expression follows this step-by-step procedure:\n\n1.  **Start Parsing**: The entry point `expression()` (or `assignment()` for Lox) is called.\n2.  **Parse Lower Precedence First**: The `assignment()` method first calls `logicalOr()` to parse the left-hand side. This begins the descent down the precedence chain.\n3.  **Recursive Descent**: Control flows down through `logicalOr()` → `logicalAnd()` → `equality()` → `comparison()` → `term()` → `factor()` → `unary()` → `primary()`. Each function is responsible for parsing its own level of operators and delegating sub-expressions to the function for the next higher precedence level.\n4.  **Handle Operators at Current Level**: When a function (e.g., `term()`) regains control after its delegate call (to `factor()`), it checks if the current token is an operator at its level (`+` or `-`). If so, it consumes the operator, recursively calls `factor()` again to parse the right operand, and builds a `Binary` AST node. It repeats in a loop to handle chains of same-precedence operators (e.g., `1 + 2 - 3`), ensuring left associativity.\n5.  **Build AST**: As the recursion unwinds, each function returns an `Expr` node representing the parsed sub-expression at its precedence level. The `Binary` and `Unary` nodes constructed become the children of nodes at lower precedence levels.\n6.  **Final Result**: The top-level `assignment()` function may perform additional logic (like checking for `=` for assignment) and finally returns the complete `Expr` AST for the entire expression.\n\nFor statements, the parsing is more straightforward, as statements do not have complex precedence interactions. The `parse()` method of the parser repeatedly calls `statement()` until it runs out of tokens. The `statement()` function looks at the current token to decide which specific statement parsing function (`printStatement()`, `ifStatement()`, etc.) to invoke.\n\n> The critical nuance is that parsing functions *predict* what they are about to parse based on the current token, then delegate to more specific functions. This is a top-down, predictive parsing strategy.\n\n### ADR: Recursive Descent vs. Pratt Parsing\n\n> **Decision: Use Classic Recursive Descent for Expression Parsing**\n> - **Context**: We need a parsing algorithm for Lox expressions that correctly handles operator precedence and associativity, is understandable for learners, and maps clearly to the language grammar.\n> - **Options Considered**:\n>     1.  **Classic Recursive Descent**: One parsing function per precedence level, with explicit calls between them forming the precedence hierarchy.\n>     2.  **Pratt Parsing (Top-Down Operator Precedence)**: A more compact algorithm that uses a table of precedence values and generic `parseExpression` calls, with binding power driving recursion.\n>     3.  **Parser Generator (e.g., ANTLR)**: Use a tool to generate a parser from a formal grammar specification.\n> - **Decision**: We choose **Classic Recursive Descent**.\n> - **Rationale**:\n>     - **Explicitness & Educational Value**: The call graph of functions (`expression` → `equality` → `comparison` → ...) provides a direct, visual mapping to the precedence table. A learner can read the code and immediately see how precedence is implemented. Pratt parsing, while elegant, condenses this logic into a less intuitive loop and table lookup.\n>     - **Simplicity for Statements**: Recursive descent handles the statement grammar (which has diverse starting keywords like `if`, `while`, `for`) very naturally with simple `if`/`else if` checks on the lookahead token. Pratt parsing is primarily designed for expressions.\n>     - **Control and Error Reporting**: Having a dedicated function for each grammar rule makes it easier to craft specific, helpful error messages when a parse error occurs at a particular point (e.g., \"Expect ')' after expression\" inside `grouping()`).\n> - **Consequences**:\n>     - **More Boilerplate**: We will have ~8 functions for expression precedence levels, each with similar looping structures. This is more code than a Pratt parser.\n>     - **Clear Structure**: The resulting parser is longer but extremely easy to debug and extend. Adding a new operator precedence level is as simple as adding a new function and slotting it into the call chain.\n>     - **Direct Implementation**: It avoids the need to understand the somewhat subtle \"binding power\" concept of Pratt parsing, lowering the initial learning barrier.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Classic Recursive Descent** | Direct mapping to grammar. Easy to understand and debug. Excellent for error reporting. Handles statements naturally. | More verbose code. Requires careful ordering of function calls to get precedence right. | **Yes** |\n| **Pratt Parsing** | Very concise for expressions. Elegant handling of precedence and associativity. Easy to add new operators. | More abstract, harder to understand initially. Less straightforward for non-expression grammar rules. | No |\n| **Parser Generator** | Automatically handles complex grammars. Can generate efficient code. | Adds a build-time dependency. Hides the parsing logic, reducing educational value. Error messages can be cryptic. | No |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Left-Recursion Infinite Loop**\n- **Description**: Writing a grammar rule that directly or indirectly calls itself without consuming a token first, e.g., `expression() -> expression() + term()`. In recursive descent, this leads to infinite recursion and a stack overflow.\n- **Why it's wrong**: The parser function immediately calls itself again, making no progress on the token stream.\n- **Fix**: Always structure grammar rules to consume at least one token (a *terminal*) before any recursive call. The standard pattern is to have a rule delegate to a higher-precedence rule first (e.g., `expression() -> equality()`, and `equality() -> comparison ( ( \"!=\" \\| \"==\" ) comparison )*`).\n\n⚠️ **Pitfall: Incorrect Precedence or Associativity**\n- **Description**: Getting the order of operator parsing wrong. For example, parsing `+` before `*`, or making `=` left-associative. This results in an AST that evaluates to the wrong value.\n- **Why it's wrong**: The tree structure no longer reflects the intended meaning of the expression. `1 + 2 * 3` might be parsed as `(1 + 2) * 3`.\n- **Fix**: Meticulously follow the precedence table. Ensure the call chain in the parser respects the table order (lowest precedence calls next level). For associativity, use a loop for left-associative operators (parsing left-to-right) and recursion for right-associative ones (like `=`).\n\n⚠️ **Pitfall: Poor Error Reporting and Recovery**\n- **Description**: The parser throws a generic \"syntax error\" without indicating location or what was expected, or it crashes completely on the first error, making it hard to find multiple issues.\n- **Why it's wrong**: A user cannot effectively debug their Lox code.\n- **Fix**: **Synchronized panic-mode recovery**. When a parse error is detected, report the line, the token, and a context-specific message. Then, discard tokens until reaching a known \"synchronization point\" (like a semicolon or a statement-starting keyword) before attempting to continue parsing. This allows reporting multiple independent errors in one run.\n\n⚠️ **Pitfall: Visitor Pattern Boilerplate Overload**\n- **Description**: Manually writing the `accept` method in every AST node class and the visitor interface with a dozen `visit` methods is tedious and error-prone.\n- **Why it's wrong**: It distracts from the core logic and introduces risk of typos or missing methods.\n- **Fix**: Use your IDE's code generation features (if available) or write a small script to generate the skeleton. In the educational context, writing it once reinforces understanding of the pattern. The provided implementation guidance includes the complete boilerplate to copy.\n\n⚠️ **Pitfall: Forgetting to Handle the End-of-File (EOF) Token**\n- **Description**: The parser's loop or matching logic doesn't explicitly check for the `EOF` token, leading to infinite loops or `IndexOutOfBounds` exceptions when the token list is exhausted.\n- **Why it's wrong**: Every valid program ends with `EOF`. The parser must gracefully stop when it reaches it.\n- **Fix**: The helper method `isAtEnd()` should check if the current token is of type `EOF`. All parsing functions should use this before attempting to consume tokens.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table**\n| Component | Simple Option | Advanced Option |\n| :--- | :--- | :--- |\n| **AST Definition** | Manual Java classes with fields and Visitor interfaces. | Use an Annotation Processor or Kotlin data classes to reduce boilerplate (out of scope for learning). |\n| **Parsing Algorithm** | Classic Recursive Descent as described. | Pratt Parsing for a more compact, generalized expression parser. |\n| **Error Handling** | Simple `throw new ParseError(...)` with line number. | Collect multiple errors in a list before throwing, or implement more sophisticated recovery. |\n\n**B. Recommended File/Module Structure**\n```\nlox/\n├── Lox.java                 # Main CLI/REPL entry point\n├── Token.java              # Token data class\n├── TokenType.java          # TokenType enum\n│\n├── scanner/\n│   └── Scanner.java        # Milestone 1 component\n│\n├── ast/                    # Milestone 2: AST Definitions\n│   ├── Expr.java           # Abstract Expr base class and Visitor\n│   └── Stmt.java           # Abstract Stmt base class and Visitor\n│\n├── parser/                 # Milestone 3: Parser\n│   ├── Parser.java\n│   └── ParseError.java     # Checked exception for parse errors\n│\n└── interpreter/            # Future milestones\n    └── ... (Interpreter, Environment, etc.)\n```\n\n**C. Infrastructure Starter Code**\n\nThe following is the complete, ready-to-use boilerplate for the AST node classes and Visitor interfaces. This is foundational infrastructure; the learner should copy this exactly and then focus on implementing the parser logic.\n\n**`ast/Expr.java`**\n```java\npackage com.craftinginterpreters.lox.ast;\n\nimport com.craftinginterpreters.lox.Token;\nimport java.util.List;\n\npublic abstract class Expr {\n  public interface Visitor<R> {\n    R visitBinaryExpr(Binary expr);\n    R visitUnaryExpr(Unary expr);\n    R visitGroupingExpr(Grouping expr);\n    R visitLiteralExpr(Literal expr);\n    R visitVariableExpr(Variable expr);\n    R visitAssignExpr(Assign expr);\n    R visitLogicalExpr(Logical expr);\n    R visitCallExpr(Call expr);\n    R visitGetExpr(Get expr);\n    R visitSetExpr(Set expr);\n    R visitThisExpr(This expr);\n    R visitSuperExpr(Super expr);\n  }\n\n  public abstract <R> R accept(Visitor<R> visitor);\n\n  public static class Binary extends Expr {\n    public Binary(Expr left, Token operator, Expr right) {\n      this.left = left;\n      this.operator = operator;\n      this.right = right;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitBinaryExpr(this);\n    }\n\n    public final Expr left;\n    public final Token operator;\n    public final Expr right;\n  }\n\n  public static class Unary extends Expr {\n    public Unary(Token operator, Expr right) {\n      this.operator = operator;\n      this.right = right;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitUnaryExpr(this);\n    }\n\n    public final Token operator;\n    public final Expr right;\n  }\n\n  public static class Grouping extends Expr {\n    public Grouping(Expr expression) {\n      this.expression = expression;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitGroupingExpr(this);\n    }\n\n    public final Expr expression;\n  }\n\n  public static class Literal extends Expr {\n    public Literal(Object value) {\n      this.value = value;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitLiteralExpr(this);\n    }\n\n    public final Object value;\n  }\n\n  public static class Variable extends Expr {\n    public Variable(Token name) {\n      this.name = name;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitVariableExpr(this);\n    }\n\n    public final Token name;\n  }\n\n  public static class Assign extends Expr {\n    public Assign(Token name, Expr value) {\n      this.name = name;\n      this.value = value;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitAssignExpr(this);\n    }\n\n    public final Token name;\n    public final Expr value;\n  }\n\n  public static class Logical extends Expr {\n    public Logical(Expr left, Token operator, Expr right) {\n      this.left = left;\n      this.operator = operator;\n      this.right = right;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitLogicalExpr(this);\n    }\n\n    public final Expr left;\n    public final Token operator;\n    public final Expr right;\n  }\n\n  public static class Call extends Expr {\n    public Call(Expr callee, Token paren, List<Expr> arguments) {\n      this.callee = callee;\n      this.paren = paren;\n      this.arguments = arguments;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitCallExpr(this);\n    }\n\n    public final Expr callee;\n    public final Token paren;\n    public final List<Expr> arguments;\n  }\n\n  public static class Get extends Expr {\n    public Get(Expr object, Token name) {\n      this.object = object;\n      this.name = name;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitGetExpr(this);\n    }\n\n    public final Expr object;\n    public final Token name;\n  }\n\n  public static class Set extends Expr {\n    public Set(Expr object, Token name, Expr value) {\n      this.object = object;\n      this.name = name;\n      this.value = value;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitSetExpr(this);\n    }\n\n    public final Expr object;\n    public final Token name;\n    public final Expr value;\n  }\n\n  public static class This extends Expr {\n    public This(Token keyword) {\n      this.keyword = keyword;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitThisExpr(this);\n    }\n\n    public final Token keyword;\n  }\n\n  public static class Super extends Expr {\n    public Super(Token keyword, Token method) {\n      this.keyword = keyword;\n      this.method = method;\n    }\n\n    @Override\n    public <R> R accept(Visitor<R> visitor) {\n      return visitor.visitSuperExpr(this);\n    }\n\n    public final Token keyword;\n    public final Token method;\n  }\n}\n```\n\n**`ast/Stmt.java`**\n```java\npackage com.craftinginterpreters.lox.ast;\n\nimport com.craftinginterpreters.lox.Token;\nimport java.util.List;\n\npublic abstract class Stmt {\n  public interface Visitor<V> {\n    V visitExpressionStmt(Expression stmt);\n    V visitPrintStmt(Print stmt);\n    V visitVarStmt(Var stmt);\n    V visitBlockStmt(Block stmt);\n    V visitIfStmt(If stmt);\n    V visitWhileStmt(While stmt);\n    V visitFunctionStmt(Function stmt);\n    V visitReturnStmt(Return stmt);\n    V visitClassStmt(Class stmt);\n  }\n\n  public abstract <V> V accept(Visitor<V> visitor);\n\n  public static class Expression extends Stmt {\n    public Expression(Expr expression) {\n      this.expression = expression;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitExpressionStmt(this);\n    }\n\n    public final Expr expression;\n  }\n\n  public static class Print extends Stmt {\n    public Print(Expr expression) {\n      this.expression = expression;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitPrintStmt(this);\n    }\n\n    public final Expr expression;\n  }\n\n  public static class Var extends Stmt {\n    public Var(Token name, Expr initializer) {\n      this.name = name;\n      this.initializer = initializer;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitVarStmt(this);\n    }\n\n    public final Token name;\n    public final Expr initializer;\n  }\n\n  public static class Block extends Stmt {\n    public Block(List<Stmt> statements) {\n      this.statements = statements;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitBlockStmt(this);\n    }\n\n    public final List<Stmt> statements;\n  }\n\n  public static class If extends Stmt {\n    public If(Expr condition, Stmt thenBranch, Stmt elseBranch) {\n      this.condition = condition;\n      this.thenBranch = thenBranch;\n      this.elseBranch = elseBranch;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitIfStmt(this);\n    }\n\n    public final Expr condition;\n    public final Stmt thenBranch;\n    public final Stmt elseBranch;\n  }\n\n  public static class While extends Stmt {\n    public While(Expr condition, Stmt body) {\n      this.condition = condition;\n      this.body = body;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitWhileStmt(this);\n    }\n\n    public final Expr condition;\n    public final Stmt body;\n  }\n\n  public static class Function extends Stmt {\n    public Function(Token name, List<Token> params, List<Stmt> body) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitFunctionStmt(this);\n    }\n\n    public final Token name;\n    public final List<Token> params;\n    public final List<Stmt> body;\n  }\n\n  public static class Return extends Stmt {\n    public Return(Token keyword, Expr value) {\n      this.keyword = keyword;\n      this.value = value;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitReturnStmt(this);\n    }\n\n    public final Token keyword;\n    public final Expr value;\n  }\n\n  public static class Class extends Stmt {\n    public Class(Token name, Expr.Variable superclass, List<Stmt.Function> methods) {\n      this.name = name;\n      this.superclass = superclass;\n      this.methods = methods;\n    }\n\n    @Override\n    public <V> V accept(Visitor<V> visitor) {\n      return visitor.visitClassStmt(this);\n    }\n\n    public final Token name;\n    public final Expr.Variable superclass;\n    public final List<Stmt.Function> methods;\n  }\n}\n```\n\n**`parser/ParseError.java`**\n```java\npackage com.craftinginterpreters.lox.parser;\n\n// This is a checked exception to allow simple error recovery\n// in the recursive descent parser.\npublic class ParseError extends RuntimeException {\n  // No need to store extra state; the error message is sufficient.\n}\n```\n\n**D. Core Logic Skeleton Code**\n\n**`parser/Parser.java`**\n```java\npackage com.craftinginterpreters.lox.parser;\n\nimport com.craftinginterpreters.lox.Token;\nimport com.craftinginterpreters.lox.TokenType;\nimport com.craftinginterpreters.lox.ast.Expr;\nimport com.craftinginterpreters.lox.ast.Stmt;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static com.craftinginterpreters.lox.TokenType.*;\n\npublic class Parser {\n  private final List<Token> tokens;\n  private int current = 0;\n\n  public Parser(List<Token> tokens) {\n    this.tokens = tokens;\n  }\n\n  public List<Stmt> parse() {\n    List<Stmt> statements = new ArrayList<>();\n    while (!isAtEnd()) {\n      // TODO 1: Parse a single statement and add it to the list.\n      // Hint: Use declaration() which can parse any statement.\n      statements.add(declaration());\n    }\n    return statements;\n  }\n\n  // declaration → varDecl | funDecl | classDecl | statement ;\n  private Stmt declaration() {\n    try {\n      // TODO 2: Look at the current token to decide what kind of declaration this is.\n      // If it's VAR, call varDecl().\n      // If it's FUN, call funDecl(\"function\").\n      // If it's CLASS, call classDecl().\n      // Otherwise, it's a statement; call statement().\n      if (match(VAR)) return varDecl();\n      if (match(FUN)) return funDecl(\"function\");\n      if (match(CLASS)) return classDecl();\n      return statement();\n    } catch (ParseError error) {\n      synchronize();\n      return null; // Return null to allow parsing to continue after an error.\n    }\n  }\n\n  // varDecl → \"var\" IDENTIFIER ( \"=\" expression )? \";\" ;\n  private Stmt varDecl() {\n    // TODO 3: Consume the identifier token (the variable name).\n    Token name = consume(IDENTIFIER, \"Expect variable name.\");\n\n    // TODO 4: Check for an initializer (an '=' token).\n    Expr initializer = null;\n    if (match(EQUAL)) {\n      initializer = expression();\n    }\n\n    // TODO 5: Expect a semicolon after the variable declaration.\n    consume(SEMICOLON, \"Expect ';' after variable declaration.\");\n    return new Stmt.Var(name, initializer);\n  }\n\n  // funDecl → \"fun\" function ;\n  // function → IDENTIFIER \"(\" parameters? \")\" block ;\n  // parameters → IDENTIFIER ( \",\" IDENTIFIER )* ;\n  private Stmt funDecl(String kind) {\n    // TODO 6: Consume the function name identifier.\n    Token name = consume(IDENTIFIER, \"Expect \" + kind + \" name.\");\n\n    // TODO 7: Expect a '(' for the parameter list.\n    consume(LEFT_PAREN, \"Expect '(' after \" + kind + \" name.\");\n\n    // TODO 8: Parse the parameter list.\n    List<Token> parameters = new ArrayList<>();\n    if (!check(RIGHT_PAREN)) {\n      do {\n        if (parameters.size() >= 255) {\n          error(peek(), \"Cannot have more than 255 parameters.\");\n        }\n        parameters.add(consume(IDENTIFIER, \"Expect parameter name.\"));\n      } while (match(COMMA));\n    }\n    consume(RIGHT_PAREN, \"Expect ')' after parameters.\");\n\n    // TODO 9: Parse the function body as a block.\n    consume(LEFT_BRACE, \"Expect '{' before \" + kind + \" body.\");\n    List<Stmt> body = block();\n    return new Stmt.Function(name, parameters, body);\n  }\n\n  // classDecl → \"class\" IDENTIFIER ( \"<\" IDENTIFIER )? \"{\" function* \"}\" ;\n  private Stmt classDecl() {\n    // TODO 10: Consume the class name identifier.\n    Token name = consume(IDENTIFIER, \"Expect class name.\");\n\n    // TODO 11: Check for a superclass inheritance clause.\n    Expr.Variable superclass = null;\n    if (match(LESS)) {\n      consume(IDENTIFIER, \"Expect superclass name.\");\n      superclass = new Expr.Variable(previous());\n    }\n\n    // TODO 12: Expect a '{' before the class body.\n    consume(LEFT_BRACE, \"Expect '{' before class body.\");\n\n    // TODO 13: Parse the list of method declarations inside the class.\n    List<Stmt.Function> methods = new ArrayList<>();\n    while (!check(RIGHT_BRACE) && !isAtEnd()) {\n      methods.add(funDecl(\"method\"));\n    }\n\n    consume(RIGHT_BRACE, \"Expect '}' after class body.\");\n    return new Stmt.Class(name, superclass, methods);\n  }\n\n  // statement → exprStmt | printStmt | block | ifStmt | whileStmt | forStmt | returnStmt ;\n  private Stmt statement() {\n    // TODO 14: Check the current token to decide which statement type to parse.\n    if (match(PRINT)) return printStmt();\n    if (match(LEFT_BRACE)) return new Stmt.Block(block());\n    if (match(IF)) return ifStmt();\n    if (match(WHILE)) return whileStmt();\n    if (match(FOR)) return forStmt();\n    if (match(RETURN)) return returnStmt();\n    return expressionStmt();\n  }\n\n  // exprStmt → expression \";\" ;\n  private Stmt expressionStmt() {\n    // TODO 15: Parse an expression, expect a semicolon, and wrap it in an Expression statement.\n    Expr expr = expression();\n    consume(SEMICOLON, \"Expect ';' after expression.\");\n    return new Stmt.Expression(expr);\n  }\n\n  // printStmt → \"print\" expression \";\" ;\n  private Stmt printStmt() {\n    // TODO 16: Parse an expression, expect a semicolon, and wrap it in a Print statement.\n    Expr value = expression();\n    consume(SEMICOLON, \"Expect ';' after value.\");\n    return new Stmt.Print(value);\n  }\n\n  // block → \"{\" declaration* \"}\" ;\n  private List<Stmt> block() {\n    List<Stmt> statements = new ArrayList<>();\n    while (!check(RIGHT_BRACE) && !isAtEnd()) {\n      statements.add(declaration());\n    }\n    consume(RIGHT_BRACE, \"Expect '}' after block.\");\n    return statements;\n  }\n\n  // ifStmt → \"if\" \"(\" expression \")\" statement ( \"else\" statement )? ;\n  private Stmt ifStmt() {\n    // TODO 17: Expect '(' after 'if', parse the condition, expect ')'.\n    consume(LEFT_PAREN, \"Expect '(' after 'if'.\");\n    Expr condition = expression();\n    consume(RIGHT_PAREN, \"Expect ')' after if condition.\");\n\n    // TODO 18: Parse the then branch statement.\n    Stmt thenBranch = statement();\n\n    // TODO 19: Check for an else token and parse the else branch if present.\n    Stmt elseBranch = null;\n    if (match(ELSE)) {\n      elseBranch = statement();\n    }\n    return new Stmt.If(condition, thenBranch, elseBranch);\n  }\n\n  // whileStmt → \"while\" \"(\" expression \")\" statement ;\n  private Stmt whileStmt() {\n    // TODO 20: Expect '(' after 'while', parse the condition, expect ')'.\n    consume(LEFT_PAREN, \"Expect '(' after 'while'.\");\n    Expr condition = expression();\n    consume(RIGHT_PAREN, \"Expect ')' after condition.\");\n    Stmt body = statement();\n    return new Stmt.While(condition, body);\n  }\n\n  // forStmt → \"for\" \"(\" ( varDecl | exprStmt | \";\" ) expression? \";\" expression? \")\" statement ;\n  // This is a \"desugaring\" parser: it transforms for-loop syntax into an equivalent while-loop AST.\n  private Stmt forStmt() {\n    // TODO 21: Expect '(' after 'for'.\n    consume(LEFT_PAREN, \"Expect '(' after 'for'.\");\n\n    // TODO 22: Parse the initializer (could be a var declaration, an expression statement, or empty).\n    Stmt initializer;\n    if (match(SEMICOLON)) {\n      initializer = null;\n    } else if (match(VAR)) {\n      initializer = varDecl();\n    } else {\n      initializer = expressionStmt();\n    }\n\n    // TODO 23: Parse the loop condition. If missing, treat it as 'true'.\n    Expr condition = null;\n    if (!check(SEMICOLON)) {\n      condition = expression();\n    }\n    consume(SEMICOLON, \"Expect ';' after loop condition.\");\n\n    // TODO 24: Parse the increment expression. If missing, treat it as empty.\n    Expr increment = null;\n    if (!check(RIGHT_PAREN)) {\n      increment = expression();\n    }\n    consume(RIGHT_PAREN, \"Expect ')' after for clauses.\");\n\n    // TODO 25: Parse the body statement.\n    Stmt body = statement();\n\n    // TODO 26: Desugar: Build the AST for a block containing initializer, a while loop with condition and body,\n    // and the increment executed at the end of each loop iteration.\n    // Hint: If increment exists, the body becomes a block: { original_body; increment; }\n    // Wrap that in a while loop with the condition (or true).\n    // If initializer exists, the whole thing becomes a block: { initializer; while_loop; }\n    if (increment != null) {\n      body = new Stmt.Block(List.of(body, new Stmt.Expression(increment)));\n    }\n    if (condition == null) condition = new Expr.Literal(true);\n    body = new Stmt.While(condition, body);\n    if (initializer != null) {\n      body = new Stmt.Block(List.of(initializer, body));\n    }\n    return body;\n  }\n\n  // returnStmt → \"return\" expression? \";\" ;\n  private Stmt returnStmt() {\n    Token keyword = previous();\n    Expr value = null;\n    if (!check(SEMICOLON)) {\n      value = expression();\n    }\n    consume(SEMICOLON, \"Expect ';' after return value.\");\n    return new Stmt.Return(keyword, value);\n  }\n\n  // expression → assignment ;\n  private Expr expression() {\n    return assignment();\n  }\n\n  // assignment → ( call \".\" )? IDENTIFIER \"=\" assignment | logical_or ;\n  private Expr assignment() {\n    // TODO 27: Parse a logical_or expression (this will parse the left-hand side).\n    Expr expr = logicalOr();\n\n    // TODO 28: Check if the next token is an '=' (assignment).\n    if (match(EQUAL)) {\n      Token equals = previous();\n      // TODO 29: Recursively parse the right-hand side (the value being assigned).\n      Expr value = assignment();\n\n      // TODO 30: Check if the left-hand side (expr) is a valid assignment target.\n      // Valid targets are: Variable, Get (property access).\n      if (expr instanceof Expr.Variable) {\n        Token name = ((Expr.Variable)expr).name;\n        return new Expr.Assign(name, value);\n      } else if (expr instanceof Expr.Get) {\n        Expr.Get get = (Expr.Get)expr;\n        return new Expr.Set(get.object, get.name, value);\n      }\n      // If not, report an error (invalid assignment target).\n      error(equals, \"Invalid assignment target.\");\n    }\n    return expr;\n  }\n\n  // logical_or → logical_and ( \"or\" logical_and )* ;\n  private Expr logicalOr() {\n    // TODO 31: Parse a logical_and expression.\n    Expr expr = logicalAnd();\n\n    // TODO 32: While the next token is 'or', consume it and parse the right-hand logical_and.\n    while (match(OR)) {\n      Token operator = previous();\n      Expr right = logicalAnd();\n      expr = new Expr.Logical(expr, operator, right);\n    }\n    return expr;\n  }\n\n  // logical_and → equality ( \"and\" equality )* ;\n  private Expr logicalAnd() {\n    // TODO 33: Parse an equality expression.\n    Expr expr = equality();\n\n    // TODO 34: While the next token is 'and', consume it and parse the right-hand equality.\n    while (match(AND)) {\n      Token operator = previous();\n      Expr right = equality();\n      expr = new Expr.Logical(expr, operator, right);\n    }\n    return expr;\n  }\n\n  // equality → comparison ( ( \"!=\" | \"==\" ) comparison )* ;\n  private Expr equality() {\n    // TODO 35: Parse a comparison expression.\n    Expr expr = comparison();\n\n    // TODO 36: While the next token is '!=' or '==', consume it and parse the next comparison.\n    while (match(BANG_EQUAL, EQUAL_EQUAL)) {\n      Token operator = previous();\n      Expr right = comparison();\n      expr = new Expr.Binary(expr, operator, right);\n    }\n    return expr;\n  }\n\n  // comparison → term ( ( \">\" | \">=\" | \"<\" | \"<=\" ) term )* ;\n  private Expr comparison() {\n    // TODO 37: Parse a term expression.\n    Expr expr = term();\n\n    // TODO 38: While the next token is '>', '>=', '<', or '<=', consume it and parse the next term.\n    while (match(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL)) {\n      Token operator = previous();\n      Expr right = term();\n      expr = new Expr.Binary(expr, operator, right);\n    }\n    return expr;\n  }\n\n  // term → factor ( ( \"-\" | \"+\" ) factor )* ;\n  private Expr term() {\n    // TODO 39: Parse a factor expression.\n    Expr expr = factor();\n\n    // TODO 40: While the next token is '-' or '+', consume it and parse the next factor.\n    while (match(MINUS, PLUS)) {\n      Token operator = previous();\n      Expr right = factor();\n      expr = new Expr.Binary(expr, operator, right);\n    }\n    return expr;\n  }\n\n  // factor → unary ( ( \"/\" | \"*\" ) unary )* ;\n  private Expr factor() {\n    // TODO 41: Parse a unary expression.\n    Expr expr = unary();\n\n    // TODO 42: While the next token is '/' or '*', consume it and parse the next unary.\n    while (match(SLASH, STAR)) {\n      Token operator = previous();\n      Expr right = unary();\n      expr = new Expr.Binary(expr, operator, right);\n    }\n    return expr;\n  }\n\n  // unary → ( \"!\" | \"-\" ) unary | call ;\n  private Expr unary() {\n    // TODO 43: If the next token is '!' or '-', consume it, recursively parse a unary, and return a Unary node.\n    if (match(BANG, MINUS)) {\n      Token operator = previous();\n      Expr right = unary();\n      return new Expr.Unary(operator, right);\n    }\n    // TODO 44: Otherwise, parse a call expression.\n    return call();\n  }\n\n  // call → primary ( \"(\" arguments? \")\" | \".\" IDENTIFIER )* ;\n  private Expr call() {\n    // TODO 45: Start by parsing a primary expression (the leftmost part of the call chain).\n    Expr expr = primary();\n\n    while (true) {\n      // TODO 46: If we see a '(', this is a function call.\n      if (match(LEFT_PAREN)) {\n        expr = finishCall(expr);\n      } else if (match(DOT)) {\n        // TODO 47: If we see a '.', this is a property access.\n        Token name = consume(IDENTIFIER, \"Expect property name after '.'.\");\n        expr = new Expr.Get(expr, name);\n      } else {\n        break;\n      }\n    }\n    return expr;\n  }\n\n  // arguments → expression ( \",\" expression )* ;\n  private Expr finishCall(Expr callee) {\n    List<Expr> arguments = new ArrayList<>();\n    if (!check(RIGHT_PAREN)) {\n      do {\n        if (arguments.size() >= 255) {\n          error(peek(), \"Cannot have more than 255 arguments.\");\n        }\n        arguments.add(expression());\n      } while (match(COMMA));\n    }\n    Token paren = consume(RIGHT_PAREN, \"Expect ')' after arguments.\");\n    return new Expr.Call(callee, paren, arguments);\n  }\n\n  // primary → NUMBER | STRING | \"true\" | \"false\" | \"nil\" | \"this\"\n  //         | \"(\" expression \")\" | IDENTIFIER | \"super\" \".\" IDENTIFIER ;\n  private Expr primary() {\n    // TODO 48: Handle literal tokens: NUMBER, STRING, TRUE, FALSE, NIL.\n    if (match(FALSE)) return new Expr.Literal(false);\n    if (match(TRUE)) return new Expr.Literal(true);\n    if (match(NIL)) return new Expr.Literal(null);\n    if (match(NUMBER, STRING)) {\n      return new Expr.Literal(previous().literal);\n    }\n\n    // TODO 49: Handle the 'this' keyword.\n    if (match(THIS)) return new Expr.This(previous());\n\n    // TODO 50: Handle the 'super' keyword for superclass method calls.\n    if (match(SUPER)) {\n      Token keyword = previous();\n      consume(DOT, \"Expect '.' after 'super'.\");\n      Token method = consume(IDENTIFIER, \"Expect superclass method name.\");\n      return new Expr.Super(keyword, method);\n    }\n\n    // TODO 51: Handle identifier (variable name).\n    if (match(IDENTIFIER)) {\n      return new Expr.Variable(previous());\n    }\n\n    // TODO 52: Handle grouping parentheses.\n    if (match(LEFT_PAREN)) {\n      Expr expr = expression();\n      consume(RIGHT_PAREN, \"Expect ')' after expression.\");\n      return new Expr.Grouping(expr);\n    }\n\n    // TODO 53: If none of the above match, throw a parse error.\n    throw error(peek(), \"Expect expression.\");\n  }\n\n  // ========== Parser Utility Methods ==========\n  private boolean match(TokenType... types) {\n    for (TokenType type : types) {\n      if (check(type)) {\n        advance();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private Token consume(TokenType type, String message) {\n    if (check(type)) return advance();\n    throw error(peek(), message);\n  }\n\n  private boolean check(TokenType type) {\n    if (isAtEnd()) return false;\n    return peek().type == type;\n  }\n\n  private Token advance() {\n    if (!isAtEnd()) current++;\n    return previous();\n  }\n\n  private boolean isAtEnd() {\n    return peek().type == EOF;\n  }\n\n  private Token peek() {\n    return tokens.get(current);\n  }\n\n  private Token previous() {\n    return tokens.get(current - 1);\n  }\n\n  private ParseError error(Token token, String message) {\n    Lox.error(token, message); // Assume Lox.error reports the error to the user.\n    return new ParseError();\n  }\n\n  private void synchronize() {\n    advance();\n    while (!isAtEnd()) {\n      if (previous().type == SEMICOLON) return;\n      switch (peek().type) {\n        case CLASS:\n        case FUN:\n        case VAR:\n        case FOR:\n        case IF:\n        case WHILE:\n        case PRINT:\n        case RETURN:\n          return;\n      }\n      advance();\n    }\n  }\n}\n```\n\n**E. Language-Specific Hints**\n- Use `final` fields in AST node classes to enforce immutability.\n- The `Object` type for `Literal.value` and `Token.literal` can hold `Double`, `String`, `Boolean`, or `null` (for `nil`). Be cautious with autoboxing.\n- Use `List<Stmt>` and `List<Expr>` from `java.util`. For mutable lists during parsing, use `ArrayList`.\n- The `ParseError` class extends `RuntimeException` but is used as a checked exception for control flow within the parser's error recovery. This is a slight abuse but keeps code simple.\n- The `synchronize()` method uses a `switch` on `TokenType`; ensure your `TokenType` enum includes all statement-starting keywords.\n\n**F. Milestone Checkpoint**\nAfter implementing the AST classes and the parser (Milestones 2 & 3), you can verify your work with a simple test:\n\n1.  **Create a test Lox program**, `test.lox`:\n    ```\n    var a = 1 + 2 * 3;\n    print a;\n    if (a > 5) {\n      print \"greater\";\n    } else {\n      print \"less or equal\";\n    }\n    ```\n2.  **Add a temporary main method or test** that reads this file, runs the scanner to get tokens, passes them to the parser, and prints the resulting AST using a `PrettyPrinter` visitor (which you should implement as part of Milestone 2).\n3.  **Run your test**. The expected output should be a correctly parenthesized S-expression reflecting precedence and grouping:\n    ```\n    (block\n      (var a (= (group (+ 1 (* 2 3)))))\n      (print (variable a))\n      (if (> (variable a) 5)\n        (block (print \"greater\"))\n        (block (print \"less or equal\")))\n    )\n    ```\n4.  **Signs of Success**: The parser runs without throwing a `ParseError`. The AST structure matches the expected precedence (`*` before `+`). The `if` statement's condition and branches are correctly nested.\n5.  **Common Failure Modes**:\n    - **Infinite loop/stack overflow**: Likely due to left-recursion in a grammar rule. Review your `expression()`, `equality()`, etc., to ensure they always consume a token before any recursive call.\n    - **Incorrect AST (wrong precedence)**: Verify the order of calls in your expression parsing cascade. The function for lower precedence (like `term`) must call the function for higher precedence (`factor`), not the other way around.\n    - **\"Expect expression\" error on valid code**: Your `primary()` method might not handle all token types (like `IDENTIFIER` or `NUMBER`). Ensure all literal types and the grouping `(` are covered.\n\n---\n\n\n> **Milestone(s):** Milestone 4 - Evaluating Expressions, Milestone 5 - Statements and State, Milestone 6 - Control Flow\n\n## 5.3 Component Design: Core Interpreter [Milestones 4, 5, 6]\n\nThis section details the design of the **Interpreter**, the component responsible for bringing Lox programs to life. It takes the static Abstract Syntax Tree produced by the parser and animates it by walking its structure, evaluating expressions and executing statements to produce observable side effects. This component introduces dynamic runtime behavior, state management through environments, and control flow—transforming a declarative program description into executable logic.\n\n### Mental Model: The Tree-Walking Executor\n\nImagine the interpreter as a puppeteer, and the AST as a complex marionette. The puppeteer doesn't see the entire puppet at once but instead walks along its strings (the AST edges), visiting each joint (node) in a predetermined order. At each joint, the puppeteer performs a specific action based on the joint's type: for a **`Binary`** node, they calculate a mathematical result by combining the values from its two child strings; for an **`If`** node, they check a condition and decide which branch string to follow next. The puppeteer carries with them a notebook—the **`Environment`**—where they record and look up variable names and their current values as they move through different scopes (like changing rooms in a theater). This hands-on, step-by-step navigation of the tree structure is the essence of tree-walking interpretation—direct, intuitive, and a perfect match for educational implementation.\n\n### Interface: The Evaluate and Execute Methods\n\nThe interpreter's public interface is minimal, centered on two core dispatch methods that serve as entry points for interpreting different types of AST nodes. Internally, it maintains the runtime state through an environment chain and handles control flow.\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `interpret` | `List<Stmt>` statements | `void` | The primary public method. Takes a list of statements (the top-level program) and executes them sequentially. Internally, it calls `execute` on each statement. |\n| `evaluate` | `Expr` expression | `Object` (runtime value) | Dispatches to the appropriate `visit` method for an expression node, recursively evaluates its subexpressions, and returns the computed runtime value (e.g., a Java `Double` for numbers, `String` for strings). |\n| `execute` | `Stmt` statement | `void` | Dispatches to the appropriate `visit` method for a statement node, performing its side effects (e.g., printing, variable assignment, control flow). |\n| `executeBlock` | `List<Stmt>` statements, `Environment` environment | `void` | A specialized method for executing a block of statements within a new, nested environment. This is called from `visitBlockStmt` and is key to implementing lexical scoping. |\n\nThe interpreter also maintains critical internal state:\n\n| State Component | Type | Description |\n|-----------------|------|-------------|\n| `globals` | `Environment` | The outermost environment, shared across all interpretations. Contains built-in functions and global variable definitions. Persists for the lifetime of the interpreter. |\n| `environment` | `Environment` | A reference to the *current* active environment. This reference changes as the interpreter enters and exits blocks, functions, and other scopes. Initially points to `globals`. |\n| `locals` | `Map<Expr, Integer>` | An optional optimization mapping from expression nodes (particularly `Variable` and `Assign`) to the number of environment \"hops\" required to resolve them. Used for efficient variable lookup in the presence of closures (detailed in Section 5.4). |\n\nThe interpreter implements the **`Expr.Visitor<Object>`** and **`Stmt.Visitor<Void>`** interfaces generated in Section 5.2. Each `visit` method (e.g., `visitBinaryExpr`, `visitPrintStmt`) contains the logic to evaluate or execute that specific node type. The `evaluate` and `execute` methods are thin wrappers that call `expression.accept(this)` or `statement.accept(this)`, leveraging the Visitor pattern's double dispatch.\n\n### Evaluation and Execution Algorithms\n\nThe interpreter's logic is defined by the collection of `visit` methods. Below are detailed, step-by-step algorithms for the core expression and statement types covered in Milestones 4-6. Each algorithm assumes it is operating within the context of the current `environment`.\n\n#### Expression Evaluation Algorithms\n\n1.  **`visitLiteralExpr` (for `Literal` nodes):**\n    1.  Return the `value` field stored in the node directly. This value is the Java object (e.g., `Double`, `String`, `Boolean`, `null` for nil) placed there by the parser after reading the token's literal.\n\n2.  **`visitGroupingExpr` (for `Grouping` nodes):**\n    1.  Recursively `evaluate` the inner `expression` field.\n    2.  Return the resulting value. The grouping parentheses only affect parsing precedence; they have no runtime effect.\n\n3.  **`visitUnaryExpr` (for `Unary` nodes):**\n    1.  Evaluate the `right` operand expression by calling `evaluate`.\n    2.  Inspect the `operator.type`:\n        *   If `BANG` (`!`): Apply Lox's **truthiness** rule. Determine if the operand value is \"falsy\" (only `false` or `nil`). Return the logical negation: `true` if the operand is falsy, `false` otherwise.\n        *   If `MINUS` (`-`): Check that the operand is a number (Java `Double`). If not, throw a `RuntimeError`. If it is, negate its numeric value and return the new `Double`.\n    3.  Return the computed result.\n\n4.  **`visitBinaryExpr` (for `Binary` nodes):**\n    1.  Evaluate the `left` operand expression.\n    2.  **Short-circuit evaluation for `OR` and `AND` (logical operators):**\n        *   For `OR`: If the left operand is *truthy*, return it immediately without evaluating the right operand.\n        *   For `AND`: If the left operand is *falsy*, return it immediately without evaluating the right operand.\n    3.  If not short-circuited, evaluate the `right` operand.\n    4.  Based on the `operator.type`, perform the operation:\n        *   **Arithmetic (`+`, `-`, `*`, `/`)**: Ensure both operands are numbers (`Double`). For `+`, also allow the special case where *either* operand is a `String`, in which case perform string concatenation (converting the other operand to its string representation). Perform the arithmetic operation and return the numeric result.\n        *   **Comparison (`>`, `>=`, `<`, `<=`)**: Ensure both operands are numbers. Perform the numeric comparison and return a Java `Boolean`.\n        *   **Equality (`==`, `!=`)**: These operators work on operands of *any* type. Two values are equal if they are the same Java object (for references) or have the same primitive value. `nil` is only equal to `nil`.\n    5.  If any type check fails, throw a `RuntimeError`.\n\n5.  **`visitVariableExpr` (for `Variable` nodes):**\n    1.  Look up the variable's name (`name.lexeme`) in the environment chain. Use `environment.get(name)`.\n    2.  If the name is found, return its bound value.\n    3.  If the name is not found (i.e., the variable is undefined), throw a `RuntimeError`.\n\n6.  **`visitAssignExpr` (for `Assign` nodes):**\n    1.  Evaluate the `value` expression to get the new value.\n    2.  Assign this value to the variable named `name.lexeme` in the appropriate environment. Use `environment.assign(name, value)`. This method searches outward through the environment chain for an existing binding and updates it.\n    3.  If the variable is not found (was never declared), `assign` throws a `RuntimeError`.\n    4.  Return the assigned value (assignment is an expression in Lox).\n\n#### Statement Execution Algorithms\n\n1.  **`visitExpressionStmt` (for `Expression` nodes):**\n    1.  Evaluate the contained `expression`.\n    2.  Discard the result. This statement exists solely for side effects (e.g., a function call or assignment).\n\n2.  **`visitPrintStmt` (for `Print` nodes):**\n    1.  Evaluate the `expression`.\n    2.  Convert the resulting value to its string representation (using a helper `stringify` method that handles `nil` and numbers without trailing `.0`).\n    3.  Print the string to standard output, typically followed by a newline.\n\n3.  **`visitVarStmt` (for `Var` nodes):**\n    1.  Initialize a value: if the `initializer` field is not `null`, evaluate it; otherwise, use `nil` (`null` in Java).\n    2.  Define a new variable in the *current* environment with `name.lexeme` bound to this value. Use `environment.define(name.lexeme, value)`.\n\n4.  **`visitBlockStmt` (for `Block` nodes):**\n    1.  Create a new `Environment` object whose enclosing/parent environment is the *current* `environment`.\n    2.  Execute the list of `statements` within this newly created environment. This is done by calling the dedicated `executeBlock` method, which temporarily swaps the interpreter's `environment` reference, runs the statements, and then restores the previous environment.\n    3.  This nested environment is discarded when the block finishes, implementing block-level scoping.\n\n5.  **`visitIfStmt` (for `If` nodes):**\n    1.  Evaluate the `condition` expression.\n    2.  Apply the truthiness rule: if the result is truthy (not `false` or `nil`), `execute` the `thenBranch` statement.\n    3.  Otherwise, if an `elseBranch` exists, `execute` it.\n\n6.  **`visitWhileStmt` (for `While` nodes):**\n    1.  Evaluate the `condition`.\n    2.  If the condition is truthy:\n        *   `Execute` the `body` statement.\n        *   Jump back to step 1 (re-evaluate the condition).\n    3.  If the condition is falsy, exit the loop and continue with the next statement.\n\n7.  **`visitLogicalExpr` (for `Logical` nodes):** (While an expression, its algorithm is closely tied to control flow via short-circuiting, as described in step 4.ii of the binary expression algorithm above).\n\n### ADR: Dynamic Type Checking Strategy\n\n> **Decision: Perform Runtime Type Checks at Each Operation Site**\n> - **Context**: Lox is a dynamically typed language. The type of an expression (number, string, boolean, etc.) is only known at runtime when the expression is evaluated. We must ensure operations like addition or comparison are only applied to compatible operand types to maintain language semantics and prevent undefined behavior.\n> - **Options Considered**:\n>     1.  **Inline Type Guards**: Within each `visit` method (e.g., `visitBinaryExpr`), check the types of the evaluated operands immediately before performing the operation. Throw a `RuntimeError` on mismatch.\n>     2.  **Centralized Type Validation**: Create a separate `TypeChecker` component that performs all type validation in a separate, pre-evaluation pass over the AST. This pass would annotate nodes with expected types or flag type errors statically.\n>     3.  **Coercive Typing**: Automatically convert operands to a common type (e.g., converting numbers to strings in `+` operations, or treating any non-number as `0` in arithmetic). This is common in languages like JavaScript but not Lox's specified semantics.\n> - **Decision**: We chose **Option 1: Inline Type Guards**.\n> - **Rationale**:\n>     *   **Simplicity and Direct Mapping**: It is the most straightforward approach for a tree-walking interpreter. The logic for an operation (e.g., \"add two numbers\") and the check for its preconditions (\"are both operands numbers?\") are colocated, making the code easier to understand and debug for learners.\n>     *   **Faithfulness to Lox Semantics**: Lox's specification calls for runtime type errors, not static type warnings. A separate type-checking pass (Option 2) adds significant complexity (a fourth phase to the interpreter) for a feature not required by the language.\n>     *   **Explicit Error Messages**: Inline checks allow for very specific, context-rich error messages (e.g., \"Operands must be two numbers or two strings for addition.\") at the exact point of failure.\n>     *   **Performance Adequacy**: For an educational interpreter, the performance overhead of repeated type checks is negligible and does not justify the complexity of the other options.\n> - **Consequences**:\n>     *   **Positive**: The implementation is clear, modular, and easy to extend. Adding a new operation only requires modifying one `visit` method.\n>     *   **Negative**: Type errors are only caught when the erroneous code path is executed, not during a \"compile\" phase. A program with a latent type error in an unused function will run without complaint until that function is called.\n>     *   **Trade-off Accepted**: We prioritize implementation clarity and alignment with Lox's dynamic nature over early error detection.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Inline Type Guards | Simple, direct, clear error messages, faithful to dynamic typing. | Errors are runtime-only, not static. | **Yes** |\n| Centralized Type Validation | Catches errors before execution, can enable optimizations. | High complexity, not required by Lox, conflates static and dynamic analysis. | No |\n| Coercive Typing | More forgiving for programmers, can reduce runtime errors. | Changes language semantics, can hide bugs, less predictable behavior. | No |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Confusing Java `null` with Lox `nil`**\n*   **Description**: Using Java's `null` reference directly to represent Lox's `nil` can lead to `NullPointerException`s if you forget to handle `null` before calling methods like `toString()` or before performing operations. Also, the truthiness rule must explicitly treat Java `null` as falsy.\n*   **Why it's wrong**: It breaks the interpreter when `nil` values flow into operations or print statements. The interpreter must treat `nil` as a valid, first-class runtime value.\n*   **How to fix**: Create a dedicated singleton object (e.g., `public static final Object NIL = new Object();`) to represent Lox's `nil`. Alternatively, consistently check for Java `null` before any operation and treat it according to Lox's rules. A `stringify()` helper method should explicitly return the string `\"nil\"` for `null`.\n\n⚠️ **Pitfall: Improper Scoping Leading to Shadowing Bugs**\n*   **Description**: Incorrectly managing the `environment` reference when entering/exiting blocks can cause variables from an outer scope to become inaccessible (if the new environment doesn't link to the parent) or cause changes in an inner scope to incorrectly modify an outer variable (if you reuse the same environment object).\n*   **Why it's wrong**: This violates lexical scoping rules. Variables should be correctly shadowed, and inner blocks should not pollute outer scopes unless using `var` at the outer level.\n*   **How to fix**: Meticulously follow the `executeBlock` pattern: 1) Create a *new* `Environment` with the current one as its parent. 2) Use a temporary variable to save the old `environment` reference. 3) Set the interpreter's `environment` to the new one. 4) Execute the statements. 5) **Restore** the saved environment reference. This ensures a clean scope hierarchy.\n\n⚠️ **Pitfall: Forgetting Short-Circuit Evaluation in Logical Operators**\n*   **Description**: Implementing `visitLogicalExpr` by evaluating both the `left` and `right` operands unconditionally before checking the operator.\n*   **Why it's wrong**: This breaks the defined semantics of `and` and `or`. For `false and someFunction()`, `someFunction()` should never be called. This is not just an optimization; it's a semantic requirement that affects programs with side effects.\n*   **How to fix**: Implement the algorithm described in Step 4.ii of the Binary Expression algorithm. Evaluate the left operand first. For `or`, if truthy, return it. For `and`, if falsy, return it. Only evaluate the right operand if needed.\n\n⚠️ **Pitfall: Infinite Loops Without a Safety Net**\n*   **Description**: A simple `while (true) {}` loop will cause the interpreter to hang forever, as there's no mechanism to interrupt execution.\n*   **Why it's wrong**: While this is semantically correct for Lox, it's a poor user experience in an educational environment, especially in a REPL.\n*   **How to fix**: Consider adding an optional loop iteration limit or a timeout mechanism, particularly in the REPL mode. This can be implemented as a counter in the `visitWhileStmt` method that increments each iteration and throws a `RuntimeError` if a threshold (e.g., 10,000) is exceeded. Document this as a non-standard, educational extension.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (Recommended for Learning) | Advanced Option (For Further Exploration) |\n|-----------|------------------------------------------|------------------------------------------|\n| Value Representation | Java `Object` (using `Double`, `String`, `Boolean`, and `null`/a sentinel for `nil`) | Define a sealed hierarchy `LoxValue` with subclasses `LoxNumber`, `LoxString`, etc. |\n| Environment Lookup | Linear chain search via `Map<String, Object>` and parent reference. | Implement persistent hash maps or indexed environments for faster lookups in deep chains. |\n| Error Reporting | Basic `RuntimeError` with message and token line number. | Collect stack traces on error, showing the call chain. |\n\n**B. Recommended File/Module Structure**\n\n```\nsrc/\n└── com/\n    └── craftinginterpreters/\n        └── lox/\n            ├── Lox.java                 # Main CLI/REPL launcher\n            ├── Token.java               # Token data class\n            ├── TokenType.java           # Token type enum\n            ├── Scanner.java             # Lexer (Milestone 1)\n            ├── Expr.java                # Expression AST nodes (Visitor pattern)\n            ├── Stmt.java                # Statement AST nodes (Visitor pattern)\n            ├── Parser.java              # Recursive descent parser (Milestones 2 & 3)\n            ├── Interpreter.java         # **This component** (Milestones 4, 5, 6)\n            ├── Environment.java         # Runtime environment chain\n            ├── RuntimeError.java        # Exception for runtime errors\n            └── (Later: LoxFunction.java, LoxClass.java, etc.)\n```\n\n**C. Infrastructure Starter Code (COMPLETE)**\n\n*RuntimeError.java* (Complete):\n```java\npackage com.craftinginterpreters.lox;\n\npublic class RuntimeError extends RuntimeException {\n    final Token token; // The token where the error occurred (for line number)\n\n    public RuntimeError(Token token, String message) {\n        super(message);\n        this.token = token;\n    }\n}\n```\n\n*Environment.java* (Complete - core logic):\n```java\npackage com.craftinginterpreters.lox;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Environment {\n    final Environment enclosing;\n    private final Map<String, Object> values = new HashMap<>();\n\n    // Constructor for global scope\n    public Environment() {\n        enclosing = null;\n    }\n\n    // Constructor for local scope\n    public Environment(Environment enclosing) {\n        this.enclosing = enclosing;\n    }\n\n    // Define a new variable in the current scope\n    public void define(String name, Object value) {\n        values.put(name, value);\n    }\n\n    // Get the value of a variable, searching outward\n    public Object get(Token name) {\n        if (values.containsKey(name.lexeme)) {\n            return values.get(name.lexeme);\n        }\n        // Look in parent scope\n        if (enclosing != null) return enclosing.get(name);\n        // Not found anywhere\n        throw new RuntimeError(name, \"Undefined variable '\" + name.lexeme + \"'.\");\n    }\n\n    // Assign to an existing variable, searching outward\n    public void assign(Token name, Object value) {\n        if (values.containsKey(name.lexeme)) {\n            values.put(name.lexeme, value);\n            return;\n        }\n        // Look in parent scope\n        if (enclosing != null) {\n            enclosing.assign(name, value);\n            return;\n        }\n        throw new RuntimeError(name, \"Undefined variable '\" + name.lexeme + \"'.\");\n    }\n}\n```\n\n**D. Core Logic Skeleton Code**\n\n*Interpreter.java* (Skeleton with TODOs):\n```java\npackage com.craftinginterpreters.lox;\n\nimport java.util.List;\n\npublic class Interpreter implements Expr.Visitor<Object>, Stmt.Visitor<Void> {\n    // The global environment, shared across interpretations\n    final Environment globals = new Environment();\n    // The current active environment (changes with scope)\n    private Environment environment = globals;\n\n    public Interpreter() {\n        // TODO 1 (Optional): Add native functions to globals here later\n        // e.g., define a \"clock()\" function.\n    }\n\n    // Main public API\n    public void interpret(List<Stmt> statements) {\n        try {\n            for (Stmt statement : statements) {\n                execute(statement);\n            }\n        } catch (RuntimeError error) {\n            Lox.runtimeError(error);\n        }\n    }\n\n    // --- Expression Visitor Methods ---\n    @Override\n    public Object visitLiteralExpr(Expr.Literal expr) {\n        // TODO 2: Return the literal value stored in the node.\n        return null;\n    }\n\n    @Override\n    public Object visitGroupingExpr(Expr.Grouping expr) {\n        // TODO 3: Evaluate the inner expression and return its value.\n        return null;\n    }\n\n    @Override\n    public Object visitUnaryExpr(Expr.Unary expr) {\n        Object right = evaluate(expr.right);\n\n        switch (expr.operator.type) {\n            case BANG:\n                // TODO 4: Return the logical negation of 'right'.\n                // Apply Lox truthiness: false and nil are false, everything else true.\n                return null;\n            case MINUS:\n                // TODO 5: Check that 'right' is a number (Double).\n                // If not, throw a RuntimeError with expr.operator.\n                // If it is, negate it and return the new Double.\n                return null;\n        }\n\n        // Unreachable\n        return null;\n    }\n\n    @Override\n    public Object visitBinaryExpr(Expr.Binary expr) {\n        Object left = evaluate(expr.left);\n        Object right = evaluate(expr.right); // **CAUTION**: See TODO 6 about short-circuit.\n\n        switch (expr.operator.type) {\n            case GREATER:\n                // TODO 7: Check both operands are numbers. Compare, return Boolean.\n                break;\n            case GREATER_EQUAL:\n                // TODO 8: Check both operands are numbers. Compare, return Boolean.\n                break;\n            case LESS:\n                // TODO 9: Check both operads are numbers. Compare, return Boolean.\n                break;\n            case LESS_EQUAL:\n                // TODO 10: Check both operands are numbers. Compare, return Boolean.\n                break;\n            case MINUS:\n                // TODO 11: Check both operands are numbers. Subtract, return Double.\n                break;\n            case SLASH:\n                // TODO 12: Check both operands are numbers. Divide, return Double.\n                // Bonus: Check for division by zero.\n                break;\n            case STAR:\n                // TODO 13: Check both operands are numbers. Multiply, return Double.\n                break;\n            case PLUS:\n                // TODO 14: Handle addition and string concatenation.\n                // If both are Doubles, add.\n                // If both are Strings, concatenate.\n                // If one is String and one is Number, convert Number to string and concatenate.\n                // Otherwise, throw RuntimeError.\n                break;\n            case BANG_EQUAL:\n                // TODO 15: Return !isEqual(left, right)\n                break;\n            case EQUAL_EQUAL:\n                // TODO 16: Return isEqual(left, right)\n                break;\n            // Logical operators (short-circuit handled separately in visitLogicalExpr)\n        }\n\n        // Unreachable\n        return null;\n    }\n\n    @Override\n    public Object visitVariableExpr(Expr.Variable expr) {\n        // TODO 17: Look up the variable name in the environment and return its value.\n        return null;\n    }\n\n    @Override\n    public Object visitAssignExpr(Expr.Assign expr) {\n        Object value = evaluate(expr.value);\n        // TODO 18: Assign the value to the variable in the environment.\n        // Use environment.assign(...). Then return the value.\n        return null;\n    }\n\n    @Override\n    public Object visitLogicalExpr(Expr.Logical expr) {\n        Object left = evaluate(expr.left);\n\n        // TODO 19: Implement short-circuit logic.\n        // If operator is OR and left is truthy, return left.\n        // If operator is AND and left is falsy, return left.\n        // Otherwise, evaluate the right operand and return it.\n        return null;\n    }\n\n    // --- Statement Visitor Methods ---\n    @Override\n    public Void visitExpressionStmt(Stmt.Expression stmt) {\n        evaluate(stmt.expression);\n        // TODO 20: Evaluate the expression and discard the result.\n        return null;\n    }\n\n    @Override\n    public Void visitPrintStmt(Stmt.Print stmt) {\n        Object value = evaluate(stmt.expression);\n        // TODO 21: Convert value to string using stringify() and print it.\n        System.out.println(stringify(value));\n        return null;\n    }\n\n    @Override\n    public Void visitVarStmt(Stmt.Var stmt) {\n        Object value = null;\n        if (stmt.initializer != null) {\n            value = evaluate(stmt.initializer);\n        }\n        // TODO 22: Define the variable in the current environment with this value.\n        environment.define(stmt.name.lexeme, value);\n        return null;\n    }\n\n    @Override\n    public Void visitBlockStmt(Stmt.Block stmt) {\n        // TODO 23: Execute the block of statements in a new nested environment.\n        // 1. Create new Environment with current environment as parent.\n        // 2. Call executeBlock(stmt.statements, newEnvironment).\n        executeBlock(stmt.statements, new Environment(environment));\n        return null;\n    }\n\n    @Override\n    public Void visitIfStmt(Stmt.If stmt) {\n        // TODO 24: Evaluate condition. If truthy, execute thenBranch.\n        // If falsy and elseBranch exists, execute elseBranch.\n        if (isTruthy(evaluate(stmt.condition))) {\n            execute(stmt.thenBranch);\n        } else if (stmt.elseBranch != null) {\n            execute(stmt.elseBranch);\n        }\n        return null;\n    }\n\n    @Override\n    public Void visitWhileStmt(Stmt.While stmt) {\n        // TODO 25: While the condition evaluates to truthy, execute the body.\n        while (isTruthy(evaluate(stmt.condition))) {\n            execute(stmt.body);\n        }\n        return null;\n    }\n\n    // --- Helper Methods ---\n    private void execute(Stmt stmt) {\n        stmt.accept(this);\n    }\n\n    private Object evaluate(Expr expr) {\n        return expr.accept(this);\n    }\n\n    public void executeBlock(List<Stmt> statements, Environment environment) {\n        Environment previous = this.environment;\n        try {\n            this.environment = environment;\n            for (Stmt statement : statements) {\n                execute(statement);\n            }\n        } finally {\n            // TODO 26: Restore the previous environment, even if an exception is thrown.\n            this.environment = previous;\n        }\n    }\n\n    // Helper: Lox truthiness rule\n    private boolean isTruthy(Object object) {\n        // TODO 27: Return false if object is null (nil) or Boolean.FALSE.\n        // Return true for everything else.\n        if (object == null) return false;\n        if (object instanceof Boolean) return (boolean) object;\n        return true;\n    }\n\n    // Helper: Deep equality for Lox values\n    private boolean isEqual(Object a, Object b) {\n        // TODO 28: Handle nil/null equality.\n        // If both are null, return true.\n        // If only one is null, return false.\n        // Otherwise, use Java's equals().\n        if (a == null && b == null) return true;\n        if (a == null) return false;\n        return a.equals(b);\n    }\n\n    // Helper: Convert a Lox value to its string representation\n    private String stringify(Object object) {\n        // TODO 29: Convert object to a readable string.\n        // If null, return \"nil\".\n        // If it's a Double, remove trailing \".0\" if it's an integer.\n        // Otherwise, use Java's toString().\n        if (object == null) return \"nil\";\n        if (object instanceof Double) {\n            String text = object.toString();\n            if (text.endsWith(\".0\")) {\n                text = text.substring(0, text.length() - 2);\n            }\n            return text;\n        }\n        return object.toString();\n    }\n}\n```\n\n**E. Language-Specific Hints**\n*   Use `instanceof` for type checks (e.g., `right instanceof Double`).\n*   Cast carefully after `instanceof` checks (e.g., `double rightValue = (Double)right;`).\n*   Remember that Java's `==` for `Double` objects checks reference equality, not numeric equality. Use `.equals()` or compare the primitive `doubleValue()`.\n*   The `isTruthy` helper is critical and used frequently. Keep its logic simple and in one place.\n\n**F. Milestone Checkpoint**\nAfter implementing this section, you should be able to run Lox programs with variables, arithmetic, print statements, and control flow.\n\n1.  **Test Command**: Create a test file `test.lox`:\n    ```lox\n    var a = 5;\n    var b = 10;\n    print a + b; // Should print 15\n\n    if (a < b) {\n        print \"a is smaller\";\n    } else {\n        print \"a is not smaller\";\n    }\n\n    var counter = 0;\n    while (counter < 3) {\n        print counter;\n        counter = counter + 1;\n    }\n    ```\n2.  **Expected Output**:\n    ```\n    15\n    a is smaller\n    0\n    1\n    2\n    ```\n3.  **Verification**: Run your interpreter (e.g., `java com.craftinginterpreters.lox.Lox test.lox`). The output should match exactly.\n4.  **Signs of Trouble**:\n    *   `NullPointerException`: Likely missing null/nil handling in `stringify` or `isTruthy`.\n    *   `\"Undefined variable\"` error for a declared variable: Check that `environment.define` is being called and that scopes (`executeBlock`) are managing the environment chain correctly.\n    *   Infinite loop: Verify the condition in `visitWhileStmt` is being re-evaluated each iteration.\n\n**G. Debugging Tips**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| All numbers print with \".0\" (e.g., \"15.0\") | The `stringify` method isn't stripping the `.0` from integer-valued doubles. | Check the `stringify` logic for `Double` objects. | Implement the substring logic shown in TODO 29. |\n| `if` statement never executes the `else` branch | The truthiness condition (`isTruthy`) is incorrect, possibly treating `false` as truthy. | Add a debug print in `isTruthy` or test with `if (false) print \"wrong\"; else print \"right\";` | Ensure `isTruthy` returns `false` for `Boolean.FALSE`. |\n| Changing a variable inside a block affects an outer variable with the same name | The block is not creating a new environment; you're using the same `Map`. | Print the environment reference before/after entering a block. | Ensure `new Environment(environment)` is called in `visitBlockStmt`. |\n| `while` loop runs one extra time or not at all | The condition is evaluated at the wrong time (e.g., only once before the loop). | Trace the order of `evaluate(condition)` and `execute(body)` in `visitWhileStmt`. | The condition must be evaluated *before each* iteration, including the first. |\n\n\n## 5.4 Component Design: Functions and Closures [Milestones 7 & 8]\n\n> **Milestone(s):** Milestone 7 - Functions, Milestone 8 - Closures\n\nThis section extends the interpreter's capabilities from simple statements and expressions to **first-class functions**, **function calls**, **return statements**, and **lexical scoping via closures**. These features transform the interpreter from a calculator into a true programming language, enabling code organization, abstraction, and powerful functional patterns.\n\n### Mental Model: The Function as a Recipe with a Kitchen\n\nBefore diving into technical details, let's build intuition with an analogy. Think of a function as a **recipe** with two essential parts:\n\n1. **The Recipe Card (Function Declaration):** This contains the list of ingredients (parameters) and the step-by-step instructions (body statements).\n2. **The Kitchen (Environment):** This is where the cooking happens, containing all the available ingredients (variables) at the time the recipe is written.\n\nWhen you define a function, you're creating a recipe card. When you call it, you:\n- Gather the actual ingredients (evaluate arguments)\n- Set up a clean work area (create a new environment)\n- Place the measured ingredients on the counter (bind parameters)\n- Follow the instructions step by step (execute the body)\n\nA **closure** is a recipe card that comes with a **snapshot of the kitchen** where it was written. Even if you later take the recipe to a different kitchen (call it from a different scope), it still has access to all the original kitchen's ingredients (variables from the defining environment). This allows inner functions to \"remember\" and access variables from outer functions, even after those outer functions have finished executing.\n\n> The critical insight: **Closures capture the environment, not just the values.** This means if a closure modifies a captured variable, all closures sharing that environment see the change.\n\n### LoxFunction: A Callable Wrapper\n\nA function in Lox is a **first-class value** that can be stored in variables, passed as arguments, returned from other functions, and called. To represent this, we need a runtime value that wraps the static function definition with its dynamic execution context.\n\n| Component | Description |\n|-----------|-------------|\n| `LoxFunction` | A runtime object representing a callable Lox function or closure |\n\n**Data Structure Details:**\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `declaration` | `Stmt.Function` | The AST node representing the function definition (contains name, parameters, body) |\n| `closure` | `Environment` | A reference to the **defining environment**—the environment active when the function was declared |\n| `isInitializer` | `boolean` | Flag indicating whether this function is a class's `init` method (affects `this` and return value behavior) |\n\n**Interface Methods:**\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `call` | `Interpreter interpreter, List<Object> arguments` | `Object` | Executes the function body with the given arguments, returning the function's result |\n| `arity` | (none) | `int` | Returns the number of parameters the function expects |\n| `toString` | (none) | `String` | Returns a string representation like \"<fn functionName>\" |\n\nThe `LoxFunction` object serves as a **bridge** between the static function definition (in the AST) and the dynamic execution context (the environment chain). When a function is declared, we create a `LoxFunction` object, capturing the *current* environment as its `closure` field. This captured environment becomes the **parent** of the new environment created each time the function is called.\n\n> **Key Design Insight:** The function's `closure` field is set once, when the function is **defined**, not when it's called. This is what enables lexical scoping—the function can access variables that existed when it was created, even if they're no longer in scope at the call site.\n\n### Function Call and Return Algorithm\n\nFunction execution involves several coordinated steps across the interpreter, the `LoxFunction` object, and the environment chain. Here's the complete algorithm:\n\n#### 1. Function Declaration Evaluation\n\nWhen the interpreter encounters a function declaration statement (`Stmt.Function`):\n\n1. **Create closure:** Capture a reference to the interpreter's *current* environment (the one active when the function is defined).\n2. **Wrap in LoxFunction:** Instantiate a `LoxFunction` object with:\n   - The function's AST node (`declaration`)\n   - The captured environment (`closure`)\n   - `isInitializer` = `false` (for regular functions; class methods set this differently)\n3. **Bind to name:** Define the function's name in the current environment, mapping it to the `LoxFunction` object.\n\n#### 2. Function Call Evaluation\n\nWhen evaluating a call expression (`Expr.Call`):\n\n1. **Evaluate callee:** Evaluate the expression before the parentheses (could be a variable name, property access, or another call).\n2. **Validate callee:** Ensure the callee is actually callable (an instance of `LoxFunction`, `LoxClass`, or a native function). If not, throw a runtime error.\n3. **Evaluate arguments:** Evaluate each argument expression from left to right, collecting the resulting values.\n4. **Check arity:** Verify the number of arguments matches the function's expected parameter count (`arity`). If not, throw a runtime error.\n5. **Create call environment:** Instantiate a new `Environment` object with the function's `closure` as its parent.\n6. **Bind parameters:** For each parameter name and corresponding argument value, define a binding in the new call environment.\n7. **Execute body:** \n   - Temporarily set the interpreter's current environment to the new call environment\n   - Execute each statement in the function's body using `executeBlock`\n   - Catch any `Return` exception thrown by a return statement\n   - Restore the interpreter's previous environment\n8. **Handle return:**\n   - If a `Return` exception was caught, extract its value and return that as the call expression's result\n   - If no return statement was encountered (or the function completes without hitting one), return `nil`\n\n#### 3. Return Statement Execution\n\nWhen executing a return statement (`Stmt.Return`):\n\n1. **Evaluate value:** If the return statement has a value expression, evaluate it. Otherwise, use `nil`.\n2. **Throw Return exception:** Create and throw a custom `Return` exception containing the value. This exception propagates up through the call stack until caught by the function call logic.\n\n> The `Return` exception is a **control flow mechanism**, not an error. It provides a clean way to immediately exit nested statement execution and propagate a value back to the caller without unwinding the call stack manually.\n\n### ADR: Environment Capture for Closures\n\n> **Decision: Capture Defining Environment by Reference**\n> - **Context:** Functions in Lox use lexical scoping: an inner function can access variables from any outer scope where it's defined. We need to decide how to make these outer variables available when the function is called, possibly much later and from a different scope.\n> - **Options Considered:**\n>   1. **Capture defining environment by reference:** Store a pointer to the actual environment object active at function definition.\n>   2. **Capture defining environment by copy:** Create a snapshot copy of all variable bindings at definition time.\n>   3. **Use caller's environment:** Ignore lexical scoping and use the environment at the call site (dynamic scoping).\n> - **Decision:** We chose option 1—capture the defining environment by reference.\n> - **Rationale:** \n>   - **Correct semantics:** Capturing by reference allows closures to see *updates* to captured variables, which matches the behavior of most modern languages and is essential for implementing mutable state in functional patterns.\n>   - **Memory efficiency:** Copying the entire environment (which could be large) for every function definition would be wasteful, especially for deeply nested functions.\n>   - **Implementation simplicity:** A reference is trivial to store and creates the natural parent-child environment relationship needed for variable lookup.\n>   - **Dynamic scoping rejection:** Option 3 would violate Lox's specified lexical scoping rules and make programs much harder to reason about.\n> - **Consequences:**\n>   - Closures can modify captured variables, affecting other closures sharing the same environment.\n>   - The captured environment must stay alive as long as any closure references it (no garbage collection in our simple interpreter).\n>   - Variable lookup follows the natural parent chain: call environment → defining environment → its parent → ... → global.\n\n**Comparison of Environment Capture Strategies:**\n\n![Environment Chain](./diagrams/diagram-environment-chain.svg)\n\n| Option | Pros | Cons | Suitable For |\n|--------|------|------|--------------|\n| **Capture by reference** | - Allows mutable captured variables<br>- Memory efficient<br>- Simple implementation | - Can create unintentional sharing<br>- Requires environment lifetime management | Lexical scoping with mutable state (Lox, JavaScript, Python) |\n| **Capture by copy** | - Isolates closure from changes<br>- Easier reasoning about behavior | - Inefficient for large environments<br>- Doesn't allow updates to outer variables | Immutable functional languages |\n| **Use caller's environment** | - Extremely simple to implement<br>- No capture needed | - Violates lexical scoping<br>- Unpredictable variable resolution | Dynamic scoping languages (some Lisps, early Perl) |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Not creating a new environment per function call**\n- **Description:** Reusing the same environment object for multiple calls to the same function.\n- **Why it's wrong:** Breaks recursion and reentrancy. Each call needs its own parameter bindings; otherwise, a recursive call would overwrite the previous call's parameters, and returns would leave the environment in an inconsistent state.\n- **Fix:** Always create a fresh `Environment` object inside `LoxFunction.call()`, with the closure as its parent.\n\n⚠️ **Pitfall: Incorrectly binding 'this' in methods**\n- **Description:** Forgetting to bind the `this` keyword to the instance when a method is called.\n- **Why it's wrong:** Methods need access to their instance's fields via `this`. Without proper binding, `this` either resolves to nothing or resolves incorrectly.\n- **Fix:** When calling a method, create an environment for the call with an extra binding: `\"this\" → instance`. This happens in the method call logic, not in regular function calls.\n\n⚠️ **Pitfall: Forgetting to propagate return values through the call stack**\n- **Description:** Catching the `Return` exception but not properly extracting and returning its value to the caller.\n- **Why it's wrong:** Function calls would always return `nil` regardless of what the return statement specified.\n- **Fix:** Ensure `LoxFunction.call()` catches the `Return` exception, extracts its `value` field, and returns that value as the call result.\n\n⚠️ **Pitfall: Memory leaks from captured environment chains**\n- **Description:** Environments captured by closures are never released, causing unbounded memory growth in long-running programs.\n- **Why it's wrong:** In a production interpreter, this would eventually exhaust available memory. Each closure keeps its entire defining environment chain alive.\n- **Fix:** In our educational interpreter, we accept this limitation. A production implementation would need a garbage collector to detect and reclaim unreachable environments.\n\n⚠️ **Pitfall: Confusing Java's return with Lox's return**\n- **Description:** Using Java's `return` statement inside the interpreter's visitor methods to implement Lox's return statement.\n- **Why it's wrong:** A Java `return` only exits the current visitor method, not the entire Lox function body. The interpreter needs to unwind through potentially multiple nested statements.\n- **Fix:** Use the custom `Return` exception thrown by `visitReturnStmt` and caught in `LoxFunction.call()`.\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Function Representation | Single `LoxFunction` class with all fields | Separate interfaces for callables: `LoxCallable` with `call()` and `arity()` |\n| Return Mechanism | Custom `Return` exception class | Special `ReturnValue` object with stack unwinding logic |\n| Environment Capture | Direct reference to `Environment` object | Environment identifier with indirect lookup table |\n\n**Recommended File/Module Structure:**\n\n```\nlox/\n  interpreter/\n    Interpreter.java           # Updated with function visit methods\n    Environment.java           # Already exists from Milestone 5\n    LoxFunction.java           # NEW: Function/closure runtime representation\n    Return.java                # NEW: Exception for return statements\n  parser/\n    # Existing files unchanged\n  ast/\n    # Existing files unchanged\n  lox/\n    Lox.java                   # Main entry point\n```\n\n**Infrastructure Starter Code (Complete):**\n\n```java\n// File: interpreter/Return.java\npackage com.craftinginterpreters.lox.interpreter;\n\n/**\n * Internal exception used to implement return statements.\n * This is not an error but a control flow mechanism.\n */\npublic class Return extends RuntimeException {\n  public final Object value;\n\n  public Return(Object value) {\n    super(null, null, false, false);  // Disable stack trace for performance\n    this.value = value;\n  }\n}\n```\n\n**Core Logic Skeleton Code:**\n\n```java\n// File: interpreter/LoxFunction.java\npackage com.craftinginterpreters.lox.interpreter;\n\nimport com.craftinginterpreters.lox.ast.*;\nimport java.util.List;\n\npublic class LoxFunction implements LoxCallable {\n  private final Stmt.Function declaration;\n  private final Environment closure;\n  private final boolean isInitializer;\n\n  public LoxFunction(Stmt.Function declaration, Environment closure, \n                     boolean isInitializer) {\n    this.declaration = declaration;\n    this.closure = closure;\n    this.isInitializer = isInitializer;\n  }\n\n  @Override\n  public int arity() {\n    // TODO 1: Return the number of parameters in the declaration\n    return 0;\n  }\n\n  @Override\n  public Object call(Interpreter interpreter, List<Object> arguments) {\n    // TODO 2: Create a new environment for this function call\n    //         The parent should be the captured closure, not the current environment\n    \n    // TODO 3: Bind each parameter name to its corresponding argument value\n    //         Use environment.define(name.lexeme, value)\n    \n    try {\n      // TODO 4: Execute the function body in the new environment\n      //         Use interpreter.executeBlock(declaration.body, callEnvironment)\n    } catch (Return returnValue) {\n      // TODO 5: Handle return statement\n      //         If this is an initializer, always return 'this' from closure\n      //         Otherwise, return the value from the Return exception\n      return null;\n    }\n    \n    // TODO 6: Handle normal completion (no return statement reached)\n    //         If this is an initializer, return 'this' from closure\n    //         Otherwise, return nil\n    return null;\n  }\n\n  @Override\n  public String toString() {\n    return \"<fn \" + declaration.name.lexeme + \">\";\n  }\n  \n  // TODO 7: Add a bind method for binding 'this' to instances (for methods)\n  //         This will be used in the class implementation\n}\n```\n\n```java\n// File: interpreter/Interpreter.java (additions only)\npublic class Interpreter implements Expr.Visitor<Object>, Stmt.Visitor<Void> {\n  // ... existing fields and methods ...\n  \n  @Override\n  public Object visitCallExpr(Expr.Call expr) {\n    // TODO 1: Evaluate the callee expression (the part before parentheses)\n    \n    // TODO 2: Evaluate each argument expression, collecting values in a list\n    \n    // TODO 3: Verify the callee is callable (instanceof LoxCallable)\n    //         If not, throw RuntimeError with expr.paren token\n    \n    // TODO 4: Check arity: arguments.size() must equal callee.arity()\n    //         If not, throw RuntimeError with expr.paren token\n    \n    // TODO 5: Call the function: callee.call(this, arguments)\n    //         Return the result\n    return null;\n  }\n  \n  @Override\n  public Void visitFunctionStmt(Stmt.Function stmt) {\n    // TODO 1: Create a LoxFunction with:\n    //         - declaration = stmt\n    //         - closure = current environment\n    //         - isInitializer = false (for now)\n    \n    // TODO 2: Define the function name in the current environment\n    //         environment.define(stmt.name.lexeme, function)\n    return null;\n  }\n  \n  @Override\n  public Void visitReturnStmt(Stmt.Return stmt) {\n    Object value = null;\n    \n    // TODO 1: If stmt.value is not null, evaluate it\n    \n    // TODO 2: Throw a Return exception with the value\n    //         This will be caught in LoxFunction.call()\n    throw new Return(value);\n  }\n  \n  // Helper method for executing blocks (already exists, but ensure it supports functions)\n  public void executeBlock(List<Stmt> statements, Environment environment) {\n    Environment previous = this.environment;\n    try {\n      this.environment = environment;\n      for (Stmt statement : statements) {\n        execute(statement);\n      }\n    } finally {\n      this.environment = previous;\n    }\n  }\n}\n```\n\n**Language-Specific Hints (Java):**\n- Use `List<Object>` for argument lists; Java's type erasure means you'll need to cast returned values.\n- The `Return` exception should extend `RuntimeException` but disable stack trace generation for better performance since it's used for normal control flow.\n- Consider creating a `LoxCallable` interface with `call()` and `arity()` methods to unify functions, classes, and future native functions.\n- When implementing `executeBlock`, use a try-finally block to ensure the environment is always restored, even if an exception is thrown.\n\n**Milestone Checkpoint:**\nAfter implementing functions, verify with this test:\n\n```lox\n// test.lox\nfun makeCounter() {\n  var i = 0;\n  fun count() {\n    i = i + 1;\n    return i;\n  }\n  return count;\n}\n\nvar counter = makeCounter();\nprint counter();  // Should print: 1\nprint counter();  // Should print: 2\n```\n\nExpected output:\n```\n1\n2\n```\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Function always returns nil | Return exception not caught or value not extracted | Add debug prints in `LoxFunction.call()` to see if Return is caught | Ensure `call()` catches `Return` and returns `returnValue.value` |\n| Recursive function overwrites variables | Same environment reused for recursive calls | Check if you're creating new Environment in each `call()` | Create fresh `Environment` for each call with closure as parent |\n| Closure can't see outer variables | Wrong environment captured as closure | Print closure's parent chain during function definition | Capture current environment when creating `LoxFunction`, not global |\n| \"Expected X arguments but got Y\" error on correct call | Arity calculation wrong | Print `declaration.params.size()` in `arity()` | Return the correct parameter count |\n| Function call evaluates arguments in wrong order | List evaluation order not left-to-right | Check order in `visitCallExpr` argument evaluation | Evaluate arguments sequentially before calling function |\n\n---\n\n\n## 5.5 Component Design: Classes and Inheritance [Milestones 9 & 10]\n\n> **Milestone(s):** Milestone 9 - Classes, Milestone 10 - Inheritance\n\nThis section extends the interpreter from a procedural language with functions to an object-oriented language with classes, instances, and inheritance. We'll design the runtime structures that represent classes and objects, implement method calls with implicit `this` binding, and add single inheritance with `super` calls. The key architectural challenge is modeling the relationship between classes, instances, and their environments while maintaining lexical scoping for closures and proper method resolution order.\n\n### Mental Model: The Class as a Blueprint and Factory\n\nThink of a **class** as both a **blueprint** and a **factory**. The blueprint defines the structure—what methods the object will have—while the factory is a callable entity that produces new instances. An **instance** is a house built from the blueprint: it has its own storage rooms (fields) that can hold unique furnishings (values), but shares the architectural plans (methods) with every other house from the same blueprint. **Inheritance** is creating a modified copy of the blueprint: you start with the original blueprint, trace over it, and add or change some rooms while keeping the rest. When you build a house from this derived blueprint, it includes features from both the original and the modifications.\n\n![Class and Instance Relationships](./diagrams/diagram-class-inheritance.svg)\n\nThe `this` keyword is like a labeled floor plan inside the house that says \"you are here\"—it allows methods running within an instance to refer to the instance itself. The `super` keyword is a special phone line installed in the house that connects directly to the original blueprint's architect, allowing you to ask how a room was originally designed even if you've modified it in your copy.\n\n### LoxClass and LoxInstance Structures\n\nWe need two new runtime value types to represent classes and instances. These extend the existing `Object` type hierarchy (which already includes `LoxFunction`, `LoxString`, `LoxNumber`, etc.).\n\n| Type | Fields | Description |\n|------|--------|-------------|\n| `LoxClass` | `name` (String) | The class's name as declared in source code |\n| | `methods` (Map<String, LoxFunction>) | A map from method names to their corresponding `LoxFunction` objects |\n| | `superclass` (LoxClass or `null`) | Reference to the superclass this class inherits from, if any |\n| `LoxInstance` | `klass` (LoxClass) | Reference to the class this instance belongs to |\n| | `fields` (Map<String, Object>) | A mutable map storing the instance's field names and their current values |\n\nBoth `LoxClass` and `LoxInstance` must implement a `call()` method to be callable (classes are called as constructors, instances are not callable unless they have a `call()` method, which Lox doesn't support). `LoxClass`'s `call()` creates a new instance and invokes the initializer. `LoxInstance`'s `call()` should throw a runtime error.\n\nAdditionally, we need to extend the `LoxFunction` class from Milestone 8 with an `isInitializer` boolean flag to mark the special `init` method, which must return `this` instead of its explicit return value.\n\n> **Design Insight:** Classes in Lox are first-class values—they can be stored in variables, passed as arguments, and returned from functions. This is why `LoxClass` is a runtime value type just like numbers and strings. The class declaration statement evaluates to a `LoxClass` object and stores it in the current environment.\n\n### Instantiation, Property Access, and Method Resolution\n\nThe lifecycle of a class involves declaration, instantiation, property access, and method invocation. The following numbered procedures describe each operation.\n\n#### 1. Class Declaration Evaluation\nWhen the interpreter encounters a `Class` statement:\n1. **Evaluate superclass (if present):** If the class has a superclass clause (`class Derived < Base`), evaluate the superclass expression (which must be a variable referencing a class). This yields a `LoxClass` object or throws an error if not a class.\n2. **Create method map:** For each method in the class body, create a `LoxFunction` object. The function's **closure** is set to the *current environment* (where the class is being defined), capturing the surrounding lexical scope. Mark the function as an initializer if its name is `\"init\"`.\n3. **Instantiate class object:** Create a new `LoxClass` with the class name, method map, and superclass reference.\n4. **Bind to name:** Store the `LoxClass` object in the current environment under the class's name.\n\n#### 2. Instance Creation (Calling a Class)\nWhen a class is called as a function (e.g., `MyClass()`):\n1. **Create instance:** Instantiate a new `LoxInstance` with its `klass` field pointing to the called `LoxClass` and an empty `fields` map.\n2. **Bind `this`:** Create a new environment whose *enclosing* environment is the **instance's class's method closure environment** (the environment captured when the class was defined). In this new environment, define a special variable named `\"this\"` bound to the instance.\n3. **Invoke initializer:** Look up the `\"init\"` method in the class's `methods` map. If found:\n   - Create a new `LoxFunction` bound to the instance by setting its closure to the environment created in step 2 (which has `this` bound).\n   - Call this function with the provided arguments.\n   - If the initializer returns a value, discard it (unless it's a special early return). Instead, automatically return `this`.\n4. **Return instance:** The result of the class call is the new `LoxInstance`.\n\n#### 3. Property Access (Get Expression)\nWhen evaluating `instance.property`:\n1. **Evaluate object:** Evaluate the left-hand expression to obtain an `LoxInstance`. If it's not an instance, throw a runtime error.\n2. **Check fields:** Look up the property name in the instance's `fields` map. If found, return the value.\n3. **Check methods:** If not in fields, look up the method name in the instance's class's `methods` map (and superclass chain). If found, return that method **bound to the instance** (create a new `LoxFunction` with the same declaration but whose closure is an environment that has `this` bound to the current instance).\n4. **Error:** If neither field nor method exists, throw a runtime error.\n\n#### 4. Property Assignment (Set Expression)\nWhen evaluating `instance.property = value`:\n1. **Evaluate object:** Evaluate the left-hand object expression to an `LoxInstance`.\n2. **Evaluate value:** Evaluate the right-hand expression.\n3. **Store in fields:** Insert or update the property name in the instance's `fields` map with the value.\n4. **Return value:** The assignment expression returns the assigned value (consistent with Lox's assignment semantics).\n\n#### 5. Method Resolution with Inheritance\nWhen a method is called on an instance:\n1. **Find method:** Starting at the instance's class, look for the method name in its `methods` map. If not found, recursively search the superclass chain.\n2. **Bind `this`:** When found, create a new environment whose parent is the method's original closure (captured at class definition time) and define `\"this\"` as the instance in this new environment. Return a new `LoxFunction` with this environment as its closure.\n3. **Super calls:** For `super.method()`, the lookup starts in the *superclass* of the class where the surrounding method is defined (not the instance's class). This ensures calling the inherited version, not an override.\n\n### ADR: Storing a Dedicated 'super' Environment\n\n> **Decision: Store Superclass Reference in a Dedicated Environment for Method Execution**\n> - **Context:** When a method uses `super.method()`, we need to resolve `method` in the superclass's scope, not the current class's. The simplest approach is to pass both the current instance and the superclass reference through the call chain, but this complicates the function call interface. Another approach is to create a special environment that links to the superclass.\n> - **Options Considered:**\n>   1. **Pass superclass explicitly:** Add a `superclass` parameter to `LoxFunction.call()` and modify all call sites.\n>   2. **Store superclass in a dedicated environment:** Create a special environment that sits between the method's closure and the instance-binding environment, containing a `\"super\"` variable pointing to the superclass.\n>   3. **Compute superclass at runtime:** Walk the class hierarchy on every `super` call by starting from the instance's class and finding the surrounding method's class via lexical analysis.\n> - **Decision:** Option 2—store a reference to the superclass in a dedicated environment that becomes part of the chain when methods are executed.\n> - **Rationale:** This approach keeps the function call interface unchanged and leverages the existing environment chain mechanism. The `super` keyword behaves like a special variable that's accessible only within methods, similar to `this`. By storing it in an environment, we maintain lexical scoping consistency and avoid adding special cases to the function call protocol.\n> - **Consequences:** \n>   - ✅ `super` is naturally limited to method contexts (the environment only exists during method execution).\n>   - ✅ The method resolution for `super` is efficient (direct reference).\n>   - ✅ No changes to `LoxFunction.call()` signature.\n>   - ❄️ Adds complexity to the environment chain construction for method calls.\n>   - ❄️ Requires careful setup to ensure `super` points to the correct superclass when methods are inherited.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Pass superclass explicitly | Simple implementation; Clear data flow | Pollutes call interface; Requires changes at all call sites | No |\n| **Store superclass in dedicated environment** | **Leverages existing environment mechanism; Clean separation of concerns** | **Adds extra environment layer; More complex setup** | **Yes** |\n| Compute superclass at runtime | No extra state needed; Dynamic resolution | Computationally expensive; Requires tracking lexical class context | No |\n\nThe implementation creates a new environment (call it the \"super environment\") whose *enclosing* environment is the method's original closure. This super environment contains a single binding: `\"super\"` → `LoxClass` (the superclass). Then, the instance-binding environment (with `this`) has this super environment as its parent. This creates a three-layer chain: instance environment (has `this`) → super environment (has `super`) → method closure (captured lexical scope).\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Forgetting to bind `this` in methods**  \n**Description:** When a method is accessed (e.g., `instance.method`), returning the raw `LoxFunction` stored in the class without binding `this` to the specific instance.  \n**Why it's wrong:** The method's body references `this` expecting it to be the instance the method was called on, but without binding, `this` resolves to whatever it was when the class was defined (likely `nil` or wrong object).  \n**Fix:** When a method is retrieved from a class (via property access), return a *new* `LoxFunction` that wraps the original function but with a closure that has `this` bound to the current instance.\n\n⚠️ **Pitfall: Improper initialization order (fields vs. init)**  \n**Description:** Allowing field assignments in the `init` method to overwrite fields set before `init` runs, or vice versa.  \n**Why it's wrong:** The instance should be fully initialized after the constructor runs, with fields set either in `init` or directly. If the instance's `fields` map is not created before `init` runs, assignments inside `init` fail.  \n**Fix:** Create the instance's `fields` map *before* calling `init`. Inside `init`, assignments modify this existing map. This allows `init` to set default values or validate fields.\n\n⚠️ **Pitfall: Incorrect method resolution order (instance → class → superclass)**  \n**Description:** When looking up a method, checking the instance's fields first, then the class's methods, but forgetting to walk the superclass chain for inherited methods.  \n**Why it's wrong:** Subclass instances cannot call inherited methods, breaking inheritance.  \n**Fix:** Implement recursive method lookup: start at the instance's class, search its method map; if not found, recursively search its superclass.\n\n⚠️ **Pitfall: Cycles in inheritance**  \n**Description:** Allowing a class to inherit from itself directly (`class A < A`) or indirectly (`class A < B; class B < A`).  \n**Why it's wrong:** Infinite loops during method resolution or instance creation.  \n**Fix:** During class declaration, validate that the superclass is not the class itself and that no cycle exists in the inheritance chain (simple cycle detection by walking the superclass chain).\n\n⚠️ **Pitfall: Not handling `super` outside of a class context**  \n**Description:** Allowing `super` keyword to be used outside of a method (e.g., in top-level code).  \n**Why it's wrong:** `super` only makes sense within a method to call a superclass method. Using it elsewhere is a semantic error.  \n**Fix:** During parsing, `super` is allowed anywhere (as it's an expression), but at runtime, throw a clear error if `super` is evaluated outside of a method context (i.e., when there's no `\"super\"` variable in the environment chain).\n\n### Implementation Guidance\n\n**Technology Recommendations Table:**\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Class representation | `LoxClass` and `LoxInstance` as plain Java classes with fields | Use interfaces `LoxCallable` and `LoxObject` for uniformity |\n| Method binding | Create new `LoxFunction` with modified closure on each property get | Cache bound methods per instance to avoid recreation |\n| Inheritance chain | Store `superclass` reference and walk recursively | Precompute method table per class (vtable) for faster dispatch |\n\n**Recommended File/Module Structure:**\n```\nsrc/\n└── com/\n    └── craftinginterpreters/\n        └── lox/\n            ├── AstPrinter.java          (existing)\n            ├── Environment.java         (existing)\n            ├── Interpreter.java         (extended)\n            ├── Lox.java                 (existing)\n            ├── Parser.java              (existing)\n            ├── Scanner.java             (existing)\n            ├── Token.java               (existing)\n            ├── TokenType.java           (existing)\n            ├── ast/                     (existing)\n            │   ├── Expr.java            (extended with Get, Set, This, Super)\n            │   └── Stmt.java            (extended with Class)\n            └── runtime/\n                ├── LoxCallable.java     (interface)\n                ├── LoxFunction.java     (extended with isInitializer)\n                ├── LoxClass.java        (new)\n                └── LoxInstance.java     (new)\n```\n\n**Infrastructure Starter Code:**\n\nFirst, extend the `LoxFunction` class to support initializers:\n\n```java\npackage com.craftinginterpreters.lox.runtime;\n\nimport com.craftinginterpreters.lox.Interpreter;\nimport com.craftinginterpreters.lox.ast.Stmt;\nimport com.craftinginterpreters.lox.Environment;\nimport java.util.List;\n\npublic class LoxFunction implements LoxCallable {\n    private final Stmt.Function declaration;\n    private final Environment closure;\n    private final boolean isInitializer;\n\n    public LoxFunction(Stmt.Function declaration, Environment closure, \n                       boolean isInitializer) {\n        this.declaration = declaration;\n        this.closure = closure;\n        this.isInitializer = isInitializer;\n    }\n\n    @Override\n    public int arity() {\n        return declaration.params.size();\n    }\n\n    @Override\n    public Object call(Interpreter interpreter, List<Object> arguments) {\n        Environment environment = new Environment(closure);\n        for (int i = 0; i < declaration.params.size(); i++) {\n            environment.define(declaration.params.get(i).lexeme, arguments.get(i));\n        }\n\n        try {\n            interpreter.executeBlock(declaration.body, environment);\n        } catch (Return returnValue) {\n            // Special case: init() always returns 'this'\n            if (isInitializer) return closure.getAt(0, \"this\");\n            return returnValue.value;\n        }\n\n        // If no return statement, init() returns 'this', others return nil\n        if (isInitializer) return closure.getAt(0, \"this\");\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        return \"<fn \" + declaration.name.lexeme + \">\";\n    }\n\n    // Bind this function to a specific instance\n    public LoxFunction bind(LoxInstance instance) {\n        Environment environment = new Environment(closure);\n        environment.define(\"this\", instance);\n        return new LoxFunction(declaration, environment, isInitializer);\n    }\n}\n```\n\n**Core Logic Skeleton Code:**\n\n1. **LoxClass.java** (complete starter):\n\n```java\npackage com.craftinginterpreters.lox.runtime;\n\nimport com.craftinginterpreters.lox.Interpreter;\nimport java.util.List;\nimport java.util.Map;\n\npublic class LoxClass implements LoxCallable {\n    public final String name;\n    public final LoxClass superclass;\n    private final Map<String, LoxFunction> methods;\n\n    public LoxClass(String name, LoxClass superclass, \n                    Map<String, LoxFunction> methods) {\n        this.name = name;\n        this.superclass = superclass;\n        this.methods = methods;\n    }\n\n    @Override\n    public String toString() {\n        return name;\n    }\n\n    @Override\n    public Object call(Interpreter interpreter, List<Object> arguments) {\n        // TODO 1: Create a new instance of this class\n        // TODO 2: Find the init method in the class's methods\n        // TODO 3: If init exists, bind it to the instance and call it with arguments\n        // TODO 4: Return the instance (init's return value is ignored, instance is returned)\n        return null;\n    }\n\n    @Override\n    public int arity() {\n        // TODO: Return the arity of the init method, or 0 if no init\n        return 0;\n    }\n\n    public LoxFunction findMethod(String name) {\n        // TODO 1: Check if method exists in this class's methods map\n        // TODO 2: If not found and superclass exists, recursively search superclass\n        // TODO 3: Return the method or null if not found\n        return null;\n    }\n}\n```\n\n2. **LoxInstance.java** (complete starter):\n\n```java\npackage com.craftinginterpreters.lox.runtime;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LoxInstance {\n    private final LoxClass klass;\n    private final Map<String, Object> fields = new HashMap<>();\n\n    public LoxInstance(LoxClass klass) {\n        this.klass = klass;\n    }\n\n    @Override\n    public String toString() {\n        return klass.name + \" instance\";\n    }\n\n    public Object get(String name) {\n        // TODO 1: Check if field exists in the fields map, return if found\n        // TODO 2: If not a field, look up method in the class\n        // TODO 3: If method found, return it bound to this instance\n        // TODO 4: Throw a runtime error if neither field nor method exists\n        return null;\n    }\n\n    public void set(String name, Object value) {\n        // TODO: Store the value in the fields map\n    }\n}\n```\n\n3. **Interpreter.java extensions** (skeleton for new visitor methods):\n\n```java\n// Add to Interpreter class:\n\n@Override\npublic Void visitClassStmt(Stmt.Class stmt) {\n    // TODO 1: Evaluate superclass expression (if present) and ensure it's a LoxClass\n    // TODO 2: Create a map of method names to LoxFunctions\n    //   - For each method, create a LoxFunction with closure = current environment\n    //   - Mark as initializer if method name is \"init\"\n    // TODO 3: Create a new LoxClass with name, superclass, and methods\n    // TODO 4: Define the class name in the current environment\n    return null;\n}\n\n@Override\npublic Object visitGetExpr(Expr.Get expr) {\n    // TODO 1: Evaluate the object expression (must be a LoxInstance)\n    // TODO 2: Call instance.get(propertyName) to get field or bound method\n    // TODO 3: Return the result\n    return null;\n}\n\n@Override\npublic Object visitSetExpr(Expr.Set expr) {\n    // TODO 1: Evaluate the object expression (must be a LoxInstance)\n    // TODO 2: Evaluate the value expression\n    // TODO 3: Call instance.set(propertyName, value)\n    // TODO 4: Return the value\n    return null;\n}\n\n@Override\npublic Object visitThisExpr(Expr.This expr) {\n    // TODO 1: Look up \"this\" in the environment chain\n    // TODO 2: Return the value (must be a LoxInstance)\n    return null;\n}\n\n@Override\npublic Object visitSuperExpr(Expr.Super expr) {\n    // TODO 1: Retrieve the \"super\" variable from the environment (should be a LoxClass)\n    // TODO 2: Retrieve the \"this\" variable from the environment (should be a LoxInstance)\n    // TODO 3: Find the method in the superclass (not the current class)\n    // TODO 4: Return the method bound to the current instance\n    return null;\n}\n```\n\n**Language-Specific Hints (Java):**\n- Use `HashMap<String, Object>` for the fields map in `LoxInstance` and methods map in `LoxClass`.\n- The `bind` method in `LoxFunction` creates a shallow copy of the function with a new closure—this is efficient and maintains the original function's code.\n- When throwing runtime errors for invalid property access, use the token's line number from the AST node for error reporting.\n- For the `super` environment, create a new `Environment` with a single binding: `environment.define(\"super\", superclass)`. This environment's parent should be the method's original closure.\n\n**Milestone Checkpoint:**\nAfter implementing classes (Milestone 9), test with this Lox program:\n```lox\nclass Breakfast {\n  init(meat, bread) {\n    this.meat = meat;\n    this.bread = bread;\n  }\n  \n  serve(who) {\n    print \"Enjoy your \" + this.meat + \" and \" + this.bread + \", \" + who + \".\";\n  }\n}\n\nvar baconAndToast = Breakfast(\"bacon\", \"toast\");\nbaconAndToast.serve(\"Dear Reader\");\n```\nExpected output: `Enjoy your bacon and toast, Dear Reader.`\n\nAfter implementing inheritance (Milestone 10), test with:\n```lox\nclass A {\n  method() {\n    print \"A.method()\";\n  }\n}\n\nclass B < A {\n  method() {\n    print \"B.method()\";\n  }\n  \n  test() {\n    super.method();\n  }\n}\n\nvar b = B();\nb.test();  // Should print \"A.method()\"\n```\nExpected output: `A.method()`\n\n**Debugging Tips:**\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| `this` is `nil` inside a method | Method not bound to instance | Check if `visitGetExpr` calls `bind()` on the retrieved method | Ensure property get returns `method.bind(instance)` |\n| `super` call says \"superclass method not found\" | Super environment not set up | Print environment chain during method call to see if `\"super\"` exists | Make sure the super environment is created and linked when a method is bound |\n| Instance fields disappear after init | Fields map reinitialized | Check if `init` creates a new map instead of using instance's map | Ensure instance's fields map is created once and passed to init |\n| Inherited method calls subclass override | Method lookup starts at wrong class | Trace `findMethod` calls; should start at superclass for `super` | In `visitSuperExpr`, look up method in superclass, not instance's class |\n\n---\n\n\n## 6. Interactions and Data Flow\n> **Milestone(s):** All milestones (Milestones 1-10) — This section demonstrates how the components defined in previous design sections collaborate to transform inert source code into executed behavior. Understanding these interactions is critical for debugging and for appreciating the architecture as a cohesive system.\n\nThis section traces the complete journey of a Lox program from a string of characters to executed side effects and printed output. We'll follow the data as it flows through the pipeline of components—**Scanner**, **Parser**, and **Interpreter**—and examine the concrete data structures that carry meaning at each stage. Think of this as tracing a package through a sophisticated logistics network: the **Scanner** scans the shipping label (source code) and produces a detailed packing list (tokens), the **Parser** inspects that list and builds a precise loading plan (AST), and the **Interpreter** executes that plan by moving goods (runtime values) between warehouses (environments) to deliver the final outcome.\n\n### End-to-End Sequence for a Sample Program\n\nLet's trace the complete execution of a simple Lox program: `var x = 1 + 2; print x;`. This program declares a variable, initializes it with the result of an arithmetic expression, and then prints the variable's value. The following numbered steps detail the transformation at each stage of the interpretation pipeline.\n\n1.  **Source Code Input**: The program begins as a plain Java `String`: `\"var x = 1 + 2; print x;\"`. This string is passed to the main entry point, typically `Lox.run()`.\n\n2.  **Lexical Analysis (Scanner)**: The `Scanner` receives the source string and begins its character-by-character scan. Its internal state (`start`, `current`, `line`) advances, identifying lexical boundaries.\n    *   It skips the initial whitespace, then recognizes `var` as a keyword, producing a `Token` with `type = VAR`, `lexeme = \"var\"`, `literal = null`, `line = 1`.\n    *   It advances, recognizes `x` as an identifier, producing a token with `type = IDENTIFIER`, `lexeme = \"x\"`, `literal = null`, `line = 1`.\n    *   It recognizes `=` as a single-character operator (`EQUAL`).\n    *   It recognizes `1` as a number literal, converting the substring `\"1\"` to a Java `Double` value `1.0` stored in the token's `literal` field (`type = NUMBER`, `lexeme = \"1\"`, `literal = 1.0`).\n    *   It recognizes `+` as an operator (`PLUS`).\n    *   It recognizes `2` as another number literal (`NUMBER` with `literal = 2.0`).\n    *   It recognizes `;` as a delimiter (`SEMICOLON`).\n    *   It then processes the second statement similarly: `print` becomes a `PRINT` keyword token, `x` becomes another `IDENTIFIER` token, and the final `;` becomes a `SEMICOLON`.\n    *   Finally, it appends an `EOF` token to signal the end of the token stream. The `Scanner` returns a `List<Token>` containing these 9 tokens (excluding whitespace).\n\n3.  **Syntactic Analysis (Parser)**: The `Parser` receives the `List<Token>` and begins its recursive descent parse, starting with the `program()` rule which calls `declaration()` repeatedly.\n    *   For the first statement, `declaration()` matches the `VAR` token and invokes `varDeclaration()`. This method consumes the `IDENTIFIER(\"x\")` token, expects and consumes the `EQUAL` token, then calls `expression()` to parse the initializer.\n    *   Parsing the expression `1 + 2` involves the precedence cascade: `expression()` → `equality()` → `comparison()` → `term()` → `factor()` → `unary()` → `primary()`. At the `primary()` level, the number literal `1` is recognized, creating a `Literal` expression node with `value = 1.0`. The parser backtracks: at the `term()` level, it sees the `PLUS` token. Since `+` is handled at the `term` precedence level, it continues parsing the right-hand side, resulting in another `Literal` for `2`. It then constructs a `Binary` expression node with `left = Literal(1.0)`, `operator = Token(PLUS, \"+\")`, `right = Literal(2.0)`.\n    *   The `varDeclaration()` method thus creates a `Var` statement node with `name = Token(IDENTIFIER, \"x\")` and `initializer = Binary(Literal(1.0), PLUS, Literal(2.0))`.\n    *   The parser then synchronizes at the `SEMICOLON`.\n    *   For the second statement, `declaration()` sees `PRINT` and calls `printStatement()`. This method consumes the `PRINT` token, parses the following expression (which is just a `Variable` expression node referencing the token `IDENTIFIER(\"x\")`), expects the `SEMICOLON`, and returns a `Print` statement node with `expression = Variable(Token(IDENTIFIER, \"x\"))`.\n    *   The `Parser` returns a `List<Stmt>` containing two elements: first the `Var` statement, then the `Print` statement.\n\n4.  **Semantic Analysis and Execution (Interpreter)**: The `Interpreter` receives the `List<Stmt>` via its `interpret()` method. It creates or reuses a global `Environment` (a chain of variable name-to-value maps). It then iterates through the statements, calling `execute()` on each.\n    *   **Executing `Var x = 1 + 2;`**: The `visitVarStmt()` method is invoked with the `Var` node. It first evaluates the initializer expression by calling `evaluate()` on the `Binary` node.\n        *   `evaluate()` on the `Binary` node recursively evaluates its left operand (`Literal(1.0)`) → returns `1.0`.\n        *   It evaluates the right operand (`Literal(2.0)`) → returns `2.0`.\n        *   It checks the operator (`PLUS`) and, since both operands are numbers, performs arithmetic addition, producing the runtime value `3.0` (a Java `Double`).\n    *   The interpreter then calls `environment.define(\"x\", 3.0)`, which inserts the binding `\"x\" → 3.0` into the current environment's `values` map.\n    *   **Executing `print x;`**: The `visitPrintStmt()` method is invoked. It evaluates its expression—a `Variable` node.\n        *   `evaluate()` on the `Variable` node calls `environment.get(Token(IDENTIFIER, \"x\"))`. The environment looks up `\"x\"` in its map and returns the value `3.0`.\n    *   The interpreter passes this value to its `stringify()` helper, which converts the Double `3.0` to the string `\"3\"`. This string is then written to standard output (e.g., `System.out.println(\"3\")`).\n\n5.  **Program Completion**: The interpreter finishes executing the statement list. The `interpret()` method returns void. The program's side effect—printing `\"3\"`—has been achieved. The runtime values (`3.0` bound to `x`) may persist in the global environment if the interpreter continues (e.g., in a REPL), but for this script execution, they are discarded as the process ends.\n\nFor a more complex program involving functions and closures, the data flow extends further. Consider a brief excerpt: `fun makeCounter() { var i=0; return fun() { i = i + 1; return i; }; }`. ![Sequence Diagram: Function Call and Return](./diagrams/diagram-function-call-sequence.svg) illustrates the interactions during a function call. The **Parser** produces a `Function` statement node for `makeCounter`. When the **Interpreter** executes this declaration, it creates a `LoxFunction` object that captures the *current* environment as its `closure`. Later, when `makeCounter()` is called, `LoxFunction.call()` creates a *new* environment whose *enclosing* link is that captured closure. The inner function's `LoxFunction` is created within this new environment, capturing a reference to it. When the inner function is later called, its execution environment chains back through that captured link, allowing it to access and modify the `i` variable that outlives the execution of `makeCounter`. This environment chain is the mechanism that enables lexical scoping and closures.\n\n### Internal Data Handoffs\n\nThe transformation pipeline is defined by specific, immutable data structures passed between components. Each handoff point represents a complete shift in perspective on the program: from characters to words, from words to grammatical structure, from structure to executable meaning.\n\nThe following table details the primary data structures at each stage of the pipeline, their role, and the component responsible for producing them.\n\n| Pipeline Stage | Input Data Structure | Output Data Structure | Producing Component | Description of Transformation |\n| :--- | :--- | :--- | :--- | :--- |\n| **Lexical Analysis** | `String` (source code) | `List<Token>` | `Scanner` | Converts a linear sequence of characters into a linear sequence of categorized tokens. Whitespace and comments are filtered out. Each token carries its source location (`line`) and, for literals, a cooked value (`literal`). |\n| **Syntactic Analysis** | `List<Token>` | `List<Stmt>` (a program AST) | `Parser` | Converts a flat sequence of tokens into a hierarchical tree of syntactic nodes (the AST). The tree structure implicitly encodes operator precedence, grouping, and the nesting of statements within blocks, functions, and control flow bodies. |\n| **Semantic Analysis & Execution** | `List<Stmt>` (AST) | Side Effects & Program Output | `Interpreter` (with `Environment`) | Recursively traverses the AST, evaluating expressions to produce runtime values (`Object`s) and executing statements to modify the environment (variable bindings) and produce side effects (e.g., printing to console). The `Environment` chain is the primary mutable runtime state. |\n\nThe flow of control and data during interpretation is more intricate than a simple linear pipeline. The following numbered procedure outlines the key handoffs and decision points within the Interpreter's core execution loop.\n\n1.  **Initialization**: The `Interpreter` is initialized with a `globals` environment. At the start of `interpret(List<Stmt>)`, it sets `environment = globals`.\n\n2.  **Statement Iteration**: For each `Stmt` in the list:\n    *   The interpreter calls `stmt.accept(this)`. This invokes the appropriate `visit*Stmt` method via the Visitor pattern's double dispatch.\n    *   Each `visit*Stmt` method may call `evaluate(Expr)` on embedded expression nodes, which in turn triggers `expr.accept(this)` and the corresponding `visit*Expr` methods.\n    *   This creates a recursive descent through the AST that mirrors the syntactic structure but is driven by execution semantics.\n\n3.  **Expression Evaluation Handoff**: When `evaluate(Expr)` is called on an expression node:\n    *   **Literal**: Returns the pre-computed `value` object (e.g., `Double`, `String`).\n    *   **Variable**: Handles off to `environment.get(nameToken)` to retrieve the current value bound to that name in the environment chain.\n    *   **Assign**: First `evaluate()`s the right-hand side value, then hands off to `environment.assign(nameToken, value)` to update the binding.\n    *   **Binary**: `evaluate()`s left and right operands, then performs type checking and the appropriate operation (e.g., arithmetic, comparison), returning a new runtime value.\n\n4.  **Environment Chain Traversal**: The `Environment.get()` and `Environment.assign()` methods implement the **handoff between scopes**. They first check the current environment's `values` map. If the identifier is not found, they recursively delegate to the `enclosing` environment (if not `null`). This chain of handoffs continues until the variable is found (success) or the global scope is reached without success (runtime error).\n\n5.  **Function Call Handoff**: A function call (`Expr.Call`) represents a major handoff:\n    *   The `callee` expression is evaluated to a `LoxFunction` (or `LoxClass`).\n    *   Argument expressions are evaluated to produce a `List<Object>` of runtime values.\n    *   Control hands off to `LoxFunction.call(interpreter, arguments)`. This method:\n        *   Creates a new `Environment` whose `enclosing` link is the function's captured `closure`.\n        *   Defines parameters in this new environment, mapping names to argument values.\n        *   Pushes this environment onto the interpreter's scope stack (`executeBlock()` with the new environment).\n        *   Executes the function's body statements. A `Return` statement throws a custom exception to unwind the call stack and hand the return value back to the caller.\n\n6.  **Output Handoff**: The `Print` statement's final handoff is to the host platform's standard output stream. The interpreter's `stringify()` method converts a Lox runtime `Object` to a Java `String`, which is then passed to `System.out.println()`.\n\n> **Key Insight:** The data handoffs are not merely passing data forward; they also establish **responsibility boundaries**. The Scanner is responsible for *lexical correctness*, the Parser for *syntactic correctness*, and the Interpreter for *semantic (runtime) correctness*. Errors detected at each stage are reported using the most appropriate data available: the Scanner reports character and line numbers, the Parser reports unexpected tokens, and the Interpreter reports runtime values and operation types.\n\n### Implementation Guidance\n\nThis section bridges the architectural description to concrete Java code. It provides a skeleton for the main driver class that orchestrates the component interactions and shows how the data flows through method calls.\n\n#### A. Technology Recommendations Table\n| Component | Simple Option | Advanced Option |\n| :--- | :--- | :--- |\n| **Main Driver** | Single `Lox` class with static methods | Separate `Lox` (frontend), `Interpreter` (backend), and `Runner` (orchestrator) classes |\n| **Error Reporting** | Print errors to `System.err` with line numbers | Collect errors in a list, allow for multiple error reporting, support IDE integration |\n| **Output Stream** | Direct `System.out` and `System.err` | Configurable `PrintStream` for output and error for easier testing |\n\n#### B. Recommended File/Module Structure\nPlace the main orchestration logic in the root package, with components in their respective packages.\n```\nlox/\n├── Lox.java                    # Main driver class\n├── scanner/\n│   ├── Scanner.java\n│   └── Token.java\n├── parser/\n│   ├── Parser.java\n│   └── ParseError.java\n├── ast/\n│   ├── Expr.java\n│   ├── Stmt.java\n│   └── (Visitor interfaces)\n└── interpreter/\n    ├── Interpreter.java\n    ├── Environment.java\n    ├── RuntimeError.java\n    ├── LoxFunction.java\n    ├── LoxClass.java\n    └── LoxInstance.java\n```\n\n#### C. Infrastructure Starter Code\nThe `Lox` class serves as the entry point and orchestrator. Here is a complete, working version that handles file and REPL input, coordinates the components, and reports errors.\n\n```java\npackage com.craftinginterpreters.lox;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class Lox {\n    private static final Interpreter interpreter = new Interpreter();\n    static boolean hadError = false;\n    static boolean hadRuntimeError = false;\n\n    public static void main(String[] args) throws IOException {\n        if (args.length > 1) {\n            System.out.println(\"Usage: jlox [script]\");\n            System.exit(64);\n        } else if (args.length == 1) {\n            runFile(args[0]);\n        } else {\n            runPrompt();\n        }\n    }\n\n    private static void runFile(String path) throws IOException {\n        byte[] bytes = Files.readAllBytes(Paths.get(path));\n        run(new String(bytes, Charset.defaultCharset()));\n        if (hadError) System.exit(65);\n        if (hadRuntimeError) System.exit(70);\n    }\n\n    private static void runPrompt() throws IOException {\n        InputStreamReader input = new InputStreamReader(System.in);\n        BufferedReader reader = new BufferedReader(input);\n\n        for (;;) {\n            System.out.print(\"> \");\n            String line = reader.readLine();\n            if (line == null) break;\n            run(line);\n            hadError = false; // Reset error flag for REPL\n        }\n    }\n\n    private static void run(String source) {\n        // 1. LEXICAL ANALYSIS: Source String -> Tokens\n        Scanner scanner = new Scanner(source);\n        List<Token> tokens = scanner.scanTokens();\n\n        // 2. SYNTACTIC ANALYSIS: Tokens -> AST\n        Parser parser = new Parser(tokens);\n        List<Stmt> statements = parser.parse();\n\n        // Stop if there was a parse error.\n        if (hadError) return;\n\n        // 3. SEMANTIC ANALYSIS & EXECUTION: AST -> Side Effects\n        interpreter.interpret(statements);\n    }\n\n    // Error reporting methods (used by Scanner, Parser, Interpreter)\n    static void error(int line, String message) {\n        report(line, \"\", message);\n    }\n\n    private static void report(int line, String where, String message) {\n        System.err.println(\"[line \" + line + \"] Error\" + where + \": \" + message);\n        hadError = true;\n    }\n\n    static void error(Token token, String message) {\n        if (token.type == TokenType.EOF) {\n            report(token.line, \" at end\", message);\n        } else {\n            report(token.line, \" at '\" + token.lexeme + \"'\", message);\n        }\n    }\n\n    static void runtimeError(RuntimeError error) {\n        System.err.println(error.getMessage() + \"\\n[line \" + error.token.line + \"]\");\n        hadRuntimeError = true;\n    }\n}\n```\n\n#### D. Core Logic Skeleton Code\nThe `Interpreter.interpret()` method is the heart of the execution phase. Below is its skeleton with TODOs that map to the steps described in the data flow.\n\n```java\npublic class Interpreter implements Expr.Visitor<Object>, Stmt.Visitor<Void> {\n    final Environment globals = new Environment();\n    private Environment environment = globals;\n\n    // Main entry point for execution\n    public void interpret(List<Stmt> statements) {\n        try {\n            // TODO 1: Iterate through each statement in the provided list\n            // TODO 2: For each statement, call execute(stmt)\n        } catch (RuntimeError error) {\n            Lox.runtimeError(error);\n        }\n    }\n\n    // Execute a single statement\n    private void execute(Stmt stmt) {\n        // TODO: Use the Visitor pattern: stmt.accept(this)\n    }\n\n    // Evaluate an expression to a runtime value\n    Object evaluate(Expr expr) {\n        // TODO: Use the Visitor pattern: expr.accept(this)\n        return null;\n    }\n\n    // ... visitor method implementations will go here ...\n}\n```\n\n#### E. Language-Specific Hints\n*   **Error Handling**: Use custom exception classes (`ParseError`, `RuntimeError`) to separate error reporting from control flow. `ParseError` can be caught internally by the Parser for synchronization, while `RuntimeError` is caught at the top level in `interpret()`.\n*   **Visitor Pattern Boilerplate**: Consider using an IDE or script to generate the visitor interface methods for the many `Expr` and `Stmt` subclasses.\n*   **REPL and File Execution**: The `runPrompt()` method uses `readLine()` which provides line editing history on many systems. For file execution, read the entire file into a string for simplicity.\n\n#### F. Milestone Checkpoint\nAfter implementing the core pipeline (through Milestone 5), you can verify the end-to-end flow with the sample program:\n\n1.  **Create a test file** `test.lox` with content: `var x = 1 + 2; print x;`\n2.  **Run your interpreter**: `java com.craftinginterpreters.lox.Lox test.lox`\n3.  **Expected Output**: The number `3` printed on a line by itself.\n4.  **Signs of Trouble**:\n    *   No output or an error: Check that your `Scanner` is producing the correct token list (use a debug print). Verify the `Parser` builds the expected AST (use an AST printer). Ensure the `Interpreter`'s `visitVarStmt` and `visitPrintStmt` are being called.\n    *   Incorrect output (e.g., `1`, `2`, `12`): Likely an issue in expression evaluation precedence or in the `Binary` expression evaluation logic (check operator handling).\n\n#### G. Debugging Tips\n| Symptom | Likely Cause | How to Diagnose | Fix |\n| :--- | :--- | :--- | :--- |\n| **Program prints nothing** | Parser failed silently due to error, `hadError` is true, `interpret()` not called. | Add a debug print in `run()` after parsing to see if `statements` is null/empty. Check `hadError` flag. | Ensure error reporting sets `hadError` and that `run()` returns early if `hadError` is true. |\n| **\"Undefined variable 'x'\" at runtime** | Variable binding not stored or retrieved correctly from the environment. | Print the environment's `values` map after `define()` and before `get()`. Check that the environment chain is correct. | Verify `environment.define()` is called with the correct name string and value. Ensure `environment.get()` is searching the chain via the `enclosing` field. |\n| **Incorrect arithmetic result (e.g., 1+2=12)** | Operands treated as strings, concatenated instead of added. | Print the types (`instanceof`) of the left and right operands in `visitBinaryExpr`. | Implement runtime type checking: ensure both operands are `Double` before performing arithmetic. |\n| **Parser goes into infinite loop** | Grammar rule left-recursion or missing advance over tokens. | Add a debug print at the start of each parsing method showing the current token. | Ensure each parsing method that consumes a token calls `advance()` or `consume()`. Check for left-recursive grammar rules (not a problem in our recursive descent formulation if written correctly). |\n\n\n## 7. Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones (Milestones 1-10) — Error handling is a cross-cutting concern that evolves through each phase of interpretation, from lexical analysis through runtime execution.\n\nRobust error handling is what separates a toy interpreter from a usable programming tool. In a tree-walking interpreter, errors can occur at three distinct phases: **lexical** (scanning), **syntactic** (parsing), and **semantic** (runtime). Each phase requires different detection, reporting, and recovery strategies. This section defines a comprehensive approach that provides clear, actionable feedback to Lox programmers while maintaining interpreter stability.\n\n### Error Classification and Reporting\n\n**Mental Model: The Error Lifecycle**\nThink of error handling as a quality control pipeline in a manufacturing plant. At the first station (Scanner), raw materials (characters) are inspected for obvious defects like unrecognized symbols or malformed parts. Defective items are rejected immediately with a detailed defect report. At the second station (Parser), the arrangement of approved parts is checked against assembly diagrams (grammar rules); misassemblies trigger a pause while the assembly line resets. Finally, at the third station (Interpreter), the assembled product is tested under real-world conditions; operational failures (like trying to use a hammer as a screwdriver) halt production entirely with a clear explanation of what went wrong.\n\n#### Error Categories and Detection Points\n\n| Error Category | Detection Point | Trigger Condition | Example |\n|----------------|-----------------|-------------------|---------|\n| **Lexical Error** | `Scanner.scanTokens()` | Unrecognized character, unterminated string, malformed number | `\"Hello, world!` (missing closing quote) |\n| **Syntactic Error** | `Parser.parse()` | Token sequence violates grammar rules | `var x = ;` (missing expression after `=`) |\n| **Runtime Error** | `Interpreter.evaluate()`/`execute()` | Semantic violation during execution | `\"text\" - 1` (invalid operands for `-`) |\n\n#### Error Reporting Standards\n\nAll errors must include:\n1. **Location**: The exact line number (and ideally column) in the source file\n2. **Phase**: Clear indication of whether it's a scanning, parsing, or runtime error\n3. **Specific Message**: A human-readable description of what went wrong\n4. **Context**: The offending token or expression that triggered the error\n\n> **Key Insight:** Good error messages don't just say *what* went wrong; they help the programmer understand *why* and *how to fix it*. A message like \"Unexpected ';' at line 5, expected expression\" is far more actionable than simply \"Syntax error.\"\n\n#### Error Class Hierarchy\n\nThe interpreter uses a three-tiered exception hierarchy:\n\n| Exception Class | Superclass | When Thrown | Recovery Strategy |\n|-----------------|-------------|-------------|-------------------|\n| `ScanError` | `RuntimeException` | During lexical analysis when encountering invalid characters or unterminated strings | Report and continue scanning (skip invalid token) |\n| `ParseError` | `RuntimeException` | During parsing when token sequence violates grammar | Enter panic mode, synchronize, continue parsing |\n| `RuntimeError` | `RuntimeException` | During evaluation when semantic rules are violated | Propagate up, halt current statement execution |\n\n**ADR: Unified vs. Phase-Specific Error Types**\n\n> **Decision: Phase-Specific Error Types**\n> - **Context**: We need to handle errors differently based on which phase of interpretation encounters them. The scanner can often recover and continue, the parser uses panic-mode recovery, while runtime errors typically halt execution of the current statement.\n> - **Options Considered**:\n>   1. **Single `LoxError` class**: One exception type for all phases, with an enum field for phase.\n>   2. **Phase-specific subclasses**: Separate classes for `ScanError`, `ParseError`, and `RuntimeError`.\n> - **Decision**: Use phase-specific exception subclasses.\n> - **Rationale**: \n>   - **Type Safety**: The compiler ensures each phase only throws appropriate errors.\n>   - **Clear Intent**: Code that catches `ParseError` explicitly states it's handling parsing failures.\n>   - **Recovery Separation**: Each phase can implement recovery logic specific to its error type without complex conditional logic.\n> - **Consequences**:\n>   - Slightly more class definitions.\n>   - Clearer code organization and error handling flow.\n>   - Enables phase-specific recovery strategies.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Single `LoxError` class | Simpler hierarchy, uniform handling | Loses phase information, forces all handlers to check phase type | ❌ |\n| Phase-specific subclasses | Type-safe, clear intent, enables tailored recovery | More classes, some duplication | ✅ |\n\n#### Location Tracking Implementation\n\nBoth tokens and exceptions must carry precise location information:\n\n| Data Structure | Location Fields | Purpose |\n|----------------|-----------------|---------|\n| `Token` | `line: int`, `column: int` (optional) | Record where token appears in source |\n| `ScanError` | `line: int`, `message: String` | Report where scanning failed |\n| `ParseError` | `token: Token`, `message: String` | Report which token caused parse failure |\n| `RuntimeError` | `token: Token`, `message: String` | Report which expression caused runtime failure |\n\n### Error Recovery Strategies\n\n**Mental Model: The Fault-Tolerant Assembly Line**\nImagine an assembly line that can recover from different types of faults. For minor part defects (lexical errors), workers remove the bad part but keep the line moving. For assembly mistakes (syntax errors), the line pauses, discards the partially assembled unit back to the last known good checkpoint, then resumes. For operational failures (runtime errors), the entire unit is scrapped, but the factory can still produce subsequent units.\n\n#### Parser: Panic-Mode Recovery\n\nThe parser implements **panic-mode recovery**, a technique where upon encountering a syntax error, it discards tokens until reaching a known synchronization point (typically a statement boundary), then continues parsing. This prevents a single syntax error from causing a cascade of spurious follow-up errors.\n\n**Panic-Mode Recovery Algorithm:**\n1. **Detection**: When `Parser.error()` is called with the current token and an error message.\n2. **Panic Mode Entry**: Set an internal `panicMode` flag to `true`.\n3. **Synchronization Point**: Discard tokens until finding one that can reasonably continue parsing:\n   - Statement boundaries: `SEMICOLON`, `PRINT`, `RETURN`, `IF`, `WHILE`, `FOR`, `CLASS`, `FUN`, `VAR`\n   - Class/function boundaries: `RIGHT_BRACE`\n4. **Recovery**: Clear `panicMode` flag and continue parsing from the synchronization point.\n5. **Error Reporting**: Report the error immediately with token location and expected construct.\n\n> **Design Principle:** The parser should never crash or enter an infinite loop due to invalid syntax. It should report *all* syntax errors in a single pass when possible, giving programmers comprehensive feedback.\n\n**ADR: Synchronization Point Selection**\n\n> **Decision: Synchronize at Statement Boundaries**\n> - **Context**: After a syntax error, we need to discard tokens until we reach a point where parsing can reasonably resume without producing garbage.\n> - **Options Considered**:\n>   1. **Synchronize at statement boundaries** (`;`, keywords starting statements).\n>   2. **Synchronize at expression boundaries** (operators, parentheses).\n>   3. **Synchronize at any \"safe\" token** (tokens that can't appear in the current context).\n> - **Decision**: Synchronize at statement boundaries.\n> - **Rationale**:\n>   - **Simplicity**: Statement boundaries are easy to identify and match programmer intuition.\n>   - **Effectiveness**: Most syntax errors affect a single statement; discarding the rest of a malformed statement is safe.\n>   - **Predictability**: Programmers can understand why parsing resumed where it did.\n> - **Consequences**:\n>   - May discard multiple tokens for errors early in a statement.\n>   - Provides good recovery for most common syntax errors.\n>   - Simple to implement with a set of synchronization tokens.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Statement boundaries | Simple, effective, predictable | May discard many tokens | ✅ |\n| Expression boundaries | Finer-grained recovery | Complex to implement, may produce confusing follow-up errors | ❌ |\n| Contextual \"safe\" tokens | Most precise recovery | Very complex, requires full context tracking | ❌ |\n\n#### Scanner: Best-Effort Recovery\n\nThe scanner implements a simpler recovery strategy: when encountering an unrecognized character or unterminated string, it reports the error but continues scanning from the next character (for invalid characters) or line (for unterminated strings).\n\n**Scanner Recovery Rules:**\n\n| Error Type | Recovery Action | Rationale |\n|------------|-----------------|-----------|\n| Unrecognized character (e.g., `@`) | Report error, advance past character | Single character likely a typo; rest of file may be valid |\n| Unterminated string | Report error, consume until end of line | Strings can't span lines; assume programmer forgot closing quote |\n| Malformed number (e.g., `123.`) | Report error, tokenize as valid prefix | Helps identify exact location while allowing continued parsing |\n\n#### Interpreter: Fail-Fast Runtime Errors\n\nRuntime errors follow a **fail-fast** strategy: when a semantic violation occurs, execution of the current expression/statement halts immediately, the error propagates up the call stack, and the interpreter stops evaluating the current program (or statement in REPL mode).\n\n**Runtime Error Propagation:**\n1. **Detection**: A runtime check fails in an evaluation method (e.g., type mismatch).\n2. **Throw**: `RuntimeError` is thrown with the offending token and descriptive message.\n3. **Propagation**: Exception bubbles up through `evaluate()` and `execute()` calls.\n4. **Top-Level Catch**: `Interpreter.interpret()` catches `RuntimeError`, reports it, and stops execution of the current program (but keeps interpreter alive in REPL mode).\n\n> **Important Distinction:** Runtime errors halt *execution* but don't crash the *interpreter process*. In batch mode, the interpreter exits with an error code. In REPL mode, it prints the error and returns to the prompt.\n\n### Specific Edge Cases and Semantics\n\n**Mental Model: The Law of Least Surprise**\nProgramming language semantics should follow the \"principle of least surprise\": edge cases should behave in ways that are intuitive to experienced programmers. When intuition fails, the behavior should be explicitly defined and documented rather than left to implementation chance.\n\n#### Type System Edge Cases\n\nLox uses dynamic typing with implicit conversions only where mathematically sensible. The following table defines the complete semantics:\n\n| Operation | Left Operand | Right Operand | Result | Error Condition |\n|-----------|--------------|---------------|--------|-----------------|\n| **Addition (`+`)** | Number | Number | Numeric sum | None |\n| | String | Any | Concatenation (right converted to string) | None |\n| | Any | String | Concatenation (left converted to string) | None |\n| | Non-string, Non-number | Non-string | `RuntimeError`: \"Operands must be two numbers or at least one string.\" | ✅ |\n| **Other Arithmetic (`-`, `*`, `/`)** | Number | Number | Numeric operation | Division by zero → `RuntimeError` |\n| | Non-number | Any | `RuntimeError`: \"Operand must be a number.\" | ✅ |\n| | Any | Non-number | `RuntimeError`: \"Operand must be a number.\" | ✅ |\n| **Comparison (`<`, `<=`, `>`, `>=`)** | Number | Number | Boolean comparison | None |\n| | Non-number | Any | `RuntimeError`: \"Operands must be numbers.\" | ✅ |\n| | Any | Non-number | `RuntimeError`: \"Operands must be numbers.\" | ✅ |\n| **Equality (`==`, `!=`)** | Any | Any | Deep equality comparison | None (even different types can be compared) |\n| **Unary Negation (`-`)** | Number | - | Negated number | None |\n| | Non-number | - | `RuntimeError`: \"Operand must be a number.\" | ✅ |\n| **Unary Not (`!`)** | Any | - | Logical negation (applies truthiness) | None |\n\n#### Truthiness Rules\n\nLox's truthiness rules are simple but must be implemented consistently:\n\n| Value | Truthiness | Rationale |\n|-------|------------|-----------|\n| `false` | Falsy | Boolean false |\n| `nil` | Falsy | Represents \"no value\" |\n| `true` | Truthy | Boolean true |\n| Number (`0`, `0.0`, negative, positive) | Truthy | Common convention: only booleans control flow |\n| String (empty `\"\"`, non-empty) | Truthy | Empty string is still a valid value |\n| Function object | Truthy | Callable entity exists |\n| Class object | Truthy | Type definition exists |\n| Instance object | Truthy | Object exists |\n\n> **Key Insight:** Unlike some languages, Lox does *not* treat `0`, `0.0`, or empty string `\"\"` as falsy. This simplifies the mental model: only `false` and `nil` are falsy.\n\n#### Object Model Edge Cases\n\n| Scenario | Behavior | Error Condition |\n|----------|----------|-----------------|\n| **Accessing undefined property** | Returns `nil` | None (dynamic languages often allow this) |\n| **Setting new property** | Creates property on instance | None (objects are open) |\n| **Calling non-function value** | `RuntimeError`: \"Can only call functions and classes.\" | ✅ |\n| **Calling class as function** | Creates new instance, calls `init` if defined | Wrong arity for `init` → `RuntimeError` |\n| **`super` outside class** | `ParseError` at parse time | ✅ |\n| **`this` outside method** | `RuntimeError`: \"Can't use 'this' outside of a class.\" | ✅ |\n| **Return at top level** | `RuntimeError`: \"Can't return from top-level code.\" | ✅ |\n| **Inheritance cycle** | `RuntimeError`: \"Inheritance cycle detected.\" | ✅ (at class definition) |\n\n#### Special Numerical Semantics\n\n| Operation | Special Case | Result | Notes |\n|-----------|--------------|--------|-------|\n| Division (`/`) | `1 / 0` | `RuntimeError`: \"Division by zero.\" | Must be caught at runtime |\n| Negation (`-`) | `-0` | `-0` (negative zero) | IEEE 754 floating-point behavior |\n| String to number | `Number(\"123\")` (hypothetical) | N/A | Lox has no explicit conversion functions |\n\n#### String Concatenation Details\n\nString concatenation follows these conversion rules:\n\n| Value Type | String Representation | Example |\n|------------|-----------------------|---------|\n| `nil` | `\"nil\"` | `\"Value: \" + nil` → `\"Value: nil\"` |\n| `false` | `\"false\"` | `\"Status: \" + false` → `\"Status: false\"` |\n| `true` | `\"true\"` | `\"Status: \" + true` → `\"Status: true\"` |\n| Number | Decimal representation (no trailing `.0` for integers) | `\"Count: \" + 42` → `\"Count: 42\"` |\n| String | The string itself (no extra quotes) | `\"Hello, \" + \"world\"` → `\"Hello, world\"` |\n| Function | Implementation-defined (e.g., `<fn foo>`) | `\"Func: \" + foo` → `\"Func: <fn foo>\"` |\n| Class | Implementation-defined (e.g., `<class Foo>`) | `\"Class: \" + Foo` → `\"Class: <class Foo>\"` |\n| Instance | Implementation-defined (e.g., `<Foo instance>`) | `\"Obj: \" + Foo()` → `\"Obj: <Foo instance>\"` |\n\n#### Variable Resolution Edge Cases\n\n| Scenario | Behavior | Error Condition |\n|----------|----------|-----------------|\n| **Accessing undefined variable** | `RuntimeError`: \"Undefined variable 'x'.\" | ✅ |\n| **Assigning to undefined variable** | `RuntimeError`: \"Undefined variable 'x'.\" | ✅ |\n| **Redeclaring variable in same scope** | Allowed (overwrites previous value) | None (dynamic languages often allow) |\n| **Shadowing outer variable** | Allowed (inner scope variable masks outer) | None |\n| **Closure accessing mutable outer variable** | Gets current value at execution time | None (captures variable, not value) |\n\n#### Function Call Edge Cases\n\n| Scenario | Behavior | Error Condition |\n|----------|----------|-----------------|\n| **Wrong number of arguments** | `RuntimeError`: \"Expected X arguments but got Y.\" | ✅ |\n| **Recursive call depth exceeded** | Stack overflow (JVM handles) | None (system-dependent) |\n| **Return without value** | Returns `nil` | None |\n| **Call on `nil`** | `RuntimeError`: \"Can only call functions and classes.\" | ✅ |\n\n#### Inheritance Edge Cases\n\n| Scenario | Behavior | Error Condition |\n|----------|----------|-----------------|\n| **Inheriting from non-class** | `RuntimeError`: \"Superclass must be a class.\" | ✅ |\n| **Accessing `super` in class with no superclass** | `RuntimeError`: \"Can't use 'super' in a class with no superclass.\" | ✅ |\n| **Calling `super.init()` multiple times** | Allowed (but unusual) | None |\n| **Overriding method with different arity** | Allowed (Lox doesn't check) | None |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Confusing Java null with Lox nil**\n- **Description**: Using Java's `null` to represent Lox's `nil` without proper boxing.\n- **Why it's wrong**: Many operations that should work on `nil` (like concatenation with strings) will throw `NullPointerException` if using raw `null`.\n- **Fix**: Create a dedicated `LoxNil` singleton class or use a sentinel object to represent `nil` distinct from Java `null`.\n\n⚠️ **Pitfall: Incomplete error location reporting**\n- **Description**: Reporting errors without line numbers or with incorrect line numbers.\n- **Why it's wrong**: Programmers can't find the error in their source code.\n- **Fix**: Ensure every `Token` carries accurate line (and ideally column) information, and every error includes the token's location.\n\n⚠️ **Pitfall: Forgetting to synchronize after parse error**\n- **Description**: Parser enters infinite loop or produces cascading errors after first syntax error.\n- **Why it's wrong**: Makes interpreter unusable for debugging multi-error programs.\n- **Fix**: Implement proper panic-mode recovery with synchronization at statement boundaries.\n\n⚠️ **Pitfall: Allowing division by zero to propagate as Java exception**\n- **Description**: Letting Java's `ArithmeticException` bubble up instead of catching and converting to `RuntimeError`.\n- **Why it's wrong**: Gives Java-specific error messages instead of Lox-specific ones.\n- **Fix**: Explicitly check divisor before division operation and throw `RuntimeError` with Lox message.\n\n⚠️ **Pitfall: Not checking operand types before operations**\n- **Description**: Assuming operands are numbers without verification, leading to `ClassCastException`.\n- **Why it's wrong**: Breaks dynamic typing guarantees and produces Java-level errors.\n- **Fix**: Use `instanceof` checks or visitor pattern to verify operand types before operations.\n\n⚠️ **Pitfall: Poor truthiness implementation**\n- **Description**: Treating `0`, `\"\"`, or other values as falsy contrary to Lox spec.\n- **Why it's wrong**: Programs behave differently than specified in language definition.\n- **Fix**: Implement `isTruthy()` method that returns `false` only for `false` and `nil`.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Reporting | Plain `System.err.println()` with formatting | Structured logging framework (SLF4J) |\n| Exception Handling | Java built-in exceptions | Custom exception hierarchy with chained causes |\n| Location Tracking | Line numbers only | Line and column with source snippet display |\n\n#### B. Recommended File/Module Structure\n\n```\nlox/\n  src/main/java/com/craftinginterpreters/lox/\n    Lox.java                 # Main entry point with error reporting\n    Token.java               # Token definition with location\n    TokenType.java           # Enum of token types\n    Scanner.java             # Lexical analysis with ScanError\n    Parser.java              # Syntactic analysis with ParseError\n    Interpreter.java         # Runtime evaluation with RuntimeError\n    RuntimeError.java        # Runtime exception class\n    ParseError.java          # Parse exception class  \n    environment/\n      Environment.java       # Variable storage\n    ast/\n      Expr.java              # Expression base class\n      Stmt.java              # Statement base class\n      ...                    # All AST node classes\n    runtime/\n      LoxCallable.java       # Callable interface\n      LoxFunction.java       # Function representation\n      LoxClass.java          # Class representation\n      LoxInstance.java       # Instance representation\n      LoxNil.java            # Nil singleton\n```\n\n#### C. Error Exception Classes (Complete Starter Code)\n\n```java\n// RuntimeError.java\npackage com.craftinginterpreters.lox;\n\n// Runtime errors occur during evaluation when semantic rules are violated\npublic class RuntimeError extends RuntimeException {\n  public final Token token;  // The token where the error occurred\n  \n  public RuntimeError(Token token, String message) {\n    super(message);\n    this.token = token;\n  }\n}\n```\n\n```java\n// ParseError.java  \npackage com.craftinginterpreters.lox;\n\n// Parse errors occur during parsing when syntax rules are violated\n// This is a wrapper exception used for panic-mode recovery\npublic class ParseError extends RuntimeException {\n  public ParseError(Token token, String message) {\n    super(message);\n    // Note: We could store token for location, but ParseError is caught\n    // internally by Parser for recovery, not reported to user directly\n  }\n}\n```\n\n#### D. Error Reporting in Main Class (Core Logic Skeleton)\n\n```java\n// Lox.java (partial)\npackage com.craftinginterpreters.lox;\n\npublic class Lox {\n  private static final Interpreter interpreter = new Interpreter();\n  static boolean hadError = false;\n  static boolean hadRuntimeError = false;\n  \n  // Main entry point for running a source file\n  public static void runFile(String path) {\n    // TODO 1: Read the file contents into a string\n    // TODO 2: Call run() with the source string\n    // TODO 3: Exit with appropriate code: 65 for syntax errors, 70 for runtime errors\n  }\n  \n  // Main entry point for REPL\n  public static void runPrompt() {\n    // TODO 1: Create InputStreamReader for interactive input\n    // TODO 2: For each line: run(line), reset hadError flag (but not hadRuntimeError)\n    // TODO 3: Handle Ctrl+D gracefully\n  }\n  \n  // Core execution engine\n  public static void run(String source) {\n    try {\n      // TODO 1: Create Scanner and scan tokens\n      // TODO 2: Create Parser and parse statements\n      // TODO 3: If no parse error, interpret with Interpreter\n    } catch (RuntimeError error) {\n      runtimeError(error);\n    }\n  }\n  \n  // Report a scanning or parsing error\n  public static void error(int line, String message) {\n    report(line, \"\", message);\n  }\n  \n  // Overload for token-based errors\n  public static void error(Token token, String message) {\n    // TODO 1: Check if token is EOF and report differently\n    // TODO 2: Otherwise report with line number and token lexeme\n  }\n  \n  private static void report(int line, String where, String message) {\n    // TODO: Print to stderr: \"[line X] ErrorY: message\"\n    // TODO: Set hadError = true\n  }\n  \n  // Report a runtime error\n  public static void runtimeError(RuntimeError error) {\n    // TODO 1: Print to stderr: error.getMessage() + \"\\n[line \" + error.token.line + \"]\"\n    // TODO 2: Set hadRuntimeError = true\n  }\n}\n```\n\n#### E. Parser Error Recovery (Core Logic Skeleton)\n\n```java\n// Parser.java (partial)\npublic class Parser {\n  private boolean hadError = false;\n  private boolean panicMode = false;\n  \n  // Entry point for parsing\n  public List<Stmt> parse() {\n    List<Stmt> statements = new ArrayList<>();\n    while (!isAtEnd()) {\n      // TODO 1: Parse a declaration (which parses statements)\n      // TODO 2: Add to statements list\n    }\n    return statements;\n  }\n  \n  // Report a parse error and enter panic mode\n  private ParseError error(Token token, String message) {\n    // TODO 1: Call Lox.error(token, message) to report to user\n    // TODO 2: Set hadError = true\n    // TODO 3: Return new ParseError for synchronization\n  }\n  \n  // Consume tokens until reaching a synchronization point\n  private void synchronize() {\n    // TODO 1: Exit panic mode\n    // TODO 2: Advance past bad token\n    // TODO 3: Skip tokens until reaching a statement boundary:\n    //         - SEMICOLON\n    //         - Keywords: CLASS, FUN, VAR, FOR, IF, WHILE, PRINT, RETURN\n    // TODO 4: Return to normal parsing\n  }\n  \n  // Helper method used in parsing methods\n  private Token consume(TokenType type, String message) {\n    if (check(type)) return advance();\n    throw error(peek(), message);  // This triggers panic mode\n  }\n}\n```\n\n#### F. Runtime Type Checking (Core Logic Skeleton)\n\n```java\n// Interpreter.java (partial)\npublic class Interpreter implements Expr.Visitor<Object>, Stmt.Visitor<Void> {\n  \n  // Binary expression evaluation with type checking\n  @Override\n  public Object visitBinaryExpr(Expr.Binary expr) {\n    // TODO 1: Evaluate left and right operands\n    // TODO 2: For arithmetic operations (-, *, /):\n    //         - Check both operands are Double using checkNumberOperand()\n    //         - For division, check right != 0.0\n    // TODO 3: For comparison (<, <=, >, >=):\n    //         - Check both operands are Double using checkNumberOperands()\n    // TODO 4: For equality (==, !=):\n    //         - Use isEqual() helper (works for any types)\n    // TODO 5: For addition (+):\n    //         - If either operand is String, convert both to strings and concatenate\n    //         - Otherwise check both are Double\n    // TODO 6: Throw RuntimeError with token location for type mismatches\n  }\n  \n  // Helper to check unary operand type\n  private void checkNumberOperand(Token operator, Object operand) {\n    // TODO: If operand is not Double, throw RuntimeError\n  }\n  \n  // Helper to check binary operand types  \n  private void checkNumberOperands(Token operator, Object left, Object right) {\n    // TODO: If either operand is not Double, throw RuntimeError\n  }\n  \n  // String conversion helper\n  private String stringify(Object object) {\n    // TODO 1: Handle null (return \"nil\")\n    // TODO 2: Handle Double: remove trailing \".0\" for integers\n    // TODO 3: Handle Boolean: return \"true\" or \"false\"\n    // TODO 4: For other objects, call toString()\n  }\n}\n```\n\n#### G. Language-Specific Hints (Java)\n\n1. **Use `Double` for numbers**: Java's `double` primitive can't be `null`, so use `Double` object type to represent Lox numbers and allow `nil` distinction.\n\n2. **Create a `LoxNil` singleton**: \n   ```java\n   public class LoxNil {\n     public static final LoxNil INSTANCE = new LoxNil();\n     private LoxNil() {}\n     @Override public String toString() { return \"nil\"; }\n   }\n   ```\n\n3. **Careful with floating-point equality**: Use epsilon comparison for `==` on numbers:\n   ```java\n   private boolean isEqual(Object a, Object b) {\n     if (a == null && b == null) return true;\n     if (a == null) return false;\n     if (a instanceof Double && b instanceof Double) {\n       return Math.abs((Double)a - (Double)b) < 1e-12;\n     }\n     return a.equals(b);\n   }\n   ```\n\n4. **Throw, don't return errors**: In visitor methods, throw `RuntimeError` immediately when semantic violation detected rather than returning error sentinel values.\n\n#### H. Milestone Checkpoint: Error Handling Verification\n\n| Milestone | Test Command | Expected Behavior |\n|-----------|--------------|-------------------|\n| 1 (Scanner) | `java Lox test.lox` with `\"unterminated string` | Reports \"[line 1] Error: Unterminated string.\" |\n| 2-3 (Parser) | `java Lox test.lox` with `var x = ;` | Reports \"[line 1] Error at ';': Expect expression.\" |\n| 4 (Interpreter) | `java Lox test.lox` with `print \"hello\" - 1;` | Reports \"RuntimeError: Operands must be numbers. [line 1]\" |\n| 5-10 (All) | `java Lox test.lox` with multiple errors | Reports all syntax errors, stops at first runtime error |\n\n**Debugging Tips Table:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| `NullPointerException` in string concatenation | Using Java `null` for Lox `nil` | Check if operand is raw `null` instead of `LoxNil` | Use `LoxNil.INSTANCE` sentinel |\n| Parser goes into infinite loop on syntax error | Missing panic-mode recovery | Add print statements in `synchronize()` | Implement proper statement boundary synchronization |\n| Error reported at wrong line number | Scanner not tracking lines correctly | Test with multi-line string literals | Update line counter when encountering `\\n` |\n| Division by zero doesn't throw error | Not checking divisor before operation | Add debug print before division | Explicitly check if divisor equals 0.0 |\n| `\"hello\" + 123` works but `123 + \"hello\"` doesn't | Only checking left operand type in `+` | Test both operand orders | Check if EITHER operand is string |\n| Closures see wrong variable values | Capturing environment by reference vs value | Print environment IDs during execution | Ensure closures capture environment reference, not copy |\n\n\n## 8. Testing Strategy\n\n> **Milestone(s):** All milestones (Milestones 1-10) — Testing is a cross-cutting concern that evolves alongside the interpreter, from isolated component validation to integrated system verification.\n\nA robust testing strategy is essential for building a correct and reliable interpreter. The tree-walking interpreter's architecture naturally lends itself to **component-wise testing**—each major phase (scanning, parsing, interpretation) can be tested in isolation before integration. This section outlines a pragmatic testing methodology aligned with the project milestones, providing concrete verification checkpoints to ensure each component works correctly before proceeding to the next.\n\n### Mental Model: The Construction Inspector\n\nThink of testing as a **construction inspector** who examines each stage of a building project. First, they check the raw materials (tokens), then the structural framework (AST), then the plumbing and electrical systems (expressions and statements), and finally the complete building with all its features (functions, classes). At each milestone, the inspector has a specific checklist of what should work. This incremental verification prevents foundational defects from propagating upward, where they become exponentially harder to debug.\n\n### Unit and Integration Testing\n\nThe interpreter's pipeline architecture suggests a natural testing hierarchy: **unit tests** for individual components, **integration tests** for component boundaries, and **end-to-end tests** for complete programs. This layered approach mirrors the development progression through milestones.\n\n**Component Isolation Strategy:**\nEach major component (Scanner, Parser, Interpreter) should be testable in isolation with minimal dependencies:\n- The **Scanner** can be tested by providing source strings and verifying the output token sequence.\n- The **Parser** can be tested by feeding it pre-generated tokens and checking the resulting AST structure.\n- The **Interpreter** can be tested by constructing AST nodes directly and verifying evaluation results.\n\n**Test Infrastructure Table:**\n\n| Test Level | Purpose | Input | Verification Method | Example |\n|------------|---------|-------|-------------------|---------|\n| **Scanner Unit Tests** | Verify tokenization rules | Source code string | Compare actual token list with expected token types, lexemes, literals, and line numbers | `\"var x = 42;\"` → `[VAR, IDENTIFIER(\"x\"), EQUAL, NUMBER(42), SEMICOLON]` |\n| **Parser Unit Tests** | Verify AST construction | Token list | Compare generated AST structure with expected AST (using pretty-printing or visitor) | `[NUMBER(1), PLUS, NUMBER(2)]` → `Binary(Literal(1), PLUS, Literal(2))` |\n| **Interpreter Unit Tests** | Verify expression evaluation | AST nodes | Compare evaluation result with expected runtime value | `Binary(Literal(1), PLUS, Literal(2))` → `3` |\n| **Integration Tests** | Verify component handoffs | Source code string | Compare program output with expected output (printed results) | `\"print 1 + 2;\"` → Console shows `\"3\"` |\n| **End-to-End Tests** | Verify complete language features | Complete Lox programs | Compare actual vs. expected output and runtime behavior | Test files with `print` statements and expected output |\n\n**Testing Visitor Pattern Implementations:**\nThe Visitor pattern presents a unique testing challenge because operations are distributed across many `visitXxx` methods. Two effective strategies are:\n\n1. **Pretty Printer Tests:** Implement a `PrettyPrinter` visitor that converts AST nodes back to a canonical string representation (like S-expressions). This provides a language-independent way to verify parser output without requiring a working interpreter.\n   \n2. **Evaluation Assertion Tests:** For the interpreter itself, write tests that construct AST nodes programmatically, evaluate them, and assert on the resulting runtime values.\n\n> **Design Insight:** Testing the parser with a pretty printer creates a **self-verifying loop**: source code → tokens → AST → pretty-printed string → compare with expected formatted output. This isolates parser correctness from interpreter implementation details.\n\n**Integration Testing Strategy:**\nAs components become ready, write tests that exercise the full pipeline:\n\n```plaintext\nSource Code → Scanner → Parser → Interpreter → Output\n```\n\nThese tests should verify not just successful execution but also proper error propagation (lexical errors from scanner, syntax errors from parser, runtime errors from interpreter).\n\n### Milestone Checkpoints (Verification Guide)\n\nThe following table provides concrete verification steps for each milestone. These checkpoints serve as **progress indicators**—if you can successfully run these tests, your implementation is likely correct for that milestone's requirements.\n\n**Milestone Verification Table:**\n\n| Milestone | Test Focus | Sample Test Command (Conceptual) | Expected Output/Behavior | What It Verifies |\n|-----------|------------|----------------------------------|--------------------------|------------------|\n| **1. Scanner** | Tokenization | Provide `\"var x = 42;\"` to Scanner | Token sequence: `VAR, IDENTIFIER(\"x\"), EQUAL, NUMBER(42), SEMICOLON` | Keywords, identifiers, numbers, operators, line tracking |\n| | String literals | `\"\\\"hello\\\"\"` | `STRING(\"hello\")` with correct literal value | String scanning with quotes, escape sequence handling |\n| | Error reporting | `\"@\\nvar\"` | Scanner reports error at line 1: \"Unexpected character '@'\" | Lexical error detection with line numbers |\n| **2. AST & 3. Parser** | Expression parsing | Parse `\"1 + 2 * 3\"` | AST: `Binary(Literal(1), PLUS, Binary(Literal(2), STAR, Literal(3)))` | Operator precedence (* before +) |\n| | Parentheses | Parse `\"(1 + 2) * 3\"` | AST: `Binary(Binary(Literal(1), PLUS, Literal(2)), STAR, Literal(3))` | Grouping overrides precedence |\n| | Error recovery | Parse `\"1 + ; print 2;\"` | Reports syntax error at `;` but continues to parse `print 2;` | Panic-mode recovery to next statement |\n| **4. Evaluating Expressions** | Arithmetic | Evaluate `\"1 + 2 * 3\"` | Result: `7` (number) | Binary operator evaluation with precedence |\n| | Type errors | Evaluate `\"\\\"hello\\\" - 1\"` | Runtime error: \"Operands must be numbers.\" | Runtime type checking |\n| | Truthiness | Evaluate `\"!false\"` | Result: `true` | Boolean logic and truthiness rules |\n| **5. Statements and State** | Variables | Execute `\"var x = 1; print x;\"` | Prints `\"1\"` | Variable declaration, initialization, and lookup |\n| | Assignment | Execute `\"var x = 1; x = 2; print x;\"` | Prints `\"2\"` | Variable reassignment |\n| | Scoping | Execute `\"{ var x = 1; } print x;\"` | Runtime error: \"Undefined variable 'x'.\" | Block scope isolation |\n| **6. Control Flow** | If/else | Execute `\"if (true) print \\\"yes\\\"; else print \\\"no\\\";\"` | Prints `\"yes\"` | Conditional branching |\n| | While loop | Execute `\"var i = 0; while (i < 3) { print i; i = i + 1; }\"` | Prints `0`, `1`, `2` | Loop execution with condition |\n| | Short-circuit | Execute `\"false and print \\\"skipped\\\";\"` | Nothing printed (no error) | Short-circuit evaluation of `and` |\n| **7. Functions** | Function call | Execute `\"fun sayHi() { print \\\"Hi!\\\"; } sayHi();\"` | Prints `\"Hi!\"` | Function declaration and invocation |\n| | Parameters | Execute `\"fun add(a, b) { return a + b; } print add(1, 2);\"` | Prints `\"3\"` | Parameter binding and return values |\n| | Recursion | Execute `\"fun fib(n) { if (n <= 1) return n; return fib(n-1) + fib(n-2); } print fib(5);\"` | Prints `\"5\"` | Recursive function calls with proper environments |\n| **8. Closures** | Closure capture | Execute `\"fun makeCounter() { var i = 0; fun count() { i = i + 1; return i; } return count; } var counter = makeCounter(); print counter(); print counter();\"` | Prints `1`, then `2` | Functions capture enclosing environment |\n| | Multiple closures | Execute closure test with two independent counters | Each counter maintains separate state | Each closure captures its own environment reference |\n| **9. Classes** | Instance creation | Execute `\"class Point {} var p = Point(); print p;\"` | Prints instance representation (e.g., `\"Point instance\"`) | Class as constructor, instance creation |\n| | Fields and methods | Execute class with `init` and method | Instance fields initialized, methods bound with `this` | Property access, method binding, initializer |\n| **10. Inheritance** | Method inheritance | Execute subclass that inherits method from superclass | Subclass instance can call inherited method | Single inheritance, method resolution |\n| | Super calls | Execute subclass method that calls `super.method()` | Superclass version of method executes | `super` keyword resolution and invocation |\n\n**Verification Procedure:**\nFor each milestone, follow this step-by-step verification process:\n\n1. **Isolated Component Tests:** First, test the new component in isolation using unit tests.\n2. **Integration with Previous Components:** Test the new component integrated with all previously implemented components.\n3. **Edge Case Validation:** Test boundary conditions and error cases specific to the milestone.\n4. **Regression Testing:** Ensure existing functionality from previous milestones still works correctly.\n\n> **Key Principle:** **Test incrementally and verify often.** Don't wait until the entire interpreter is built to test it. Each milestone's acceptance criteria provide specific behaviors to test.\n\n### Common Pitfalls in Testing\n\n⚠️ **Pitfall: Testing Only Happy Paths**\n- **Description:** Writing tests that only verify correct programs execute successfully, neglecting error cases and edge conditions.\n- **Why It's Wrong:** An interpreter must handle malformed programs gracefully with clear error messages. Missing error tests leaves critical functionality unverified.\n- **Fix:** For each feature, write tests for: (1) valid usage, (2) type errors, (3) undefined variables, (4) syntax errors, (5) boundary conditions (empty strings, zero, nil).\n\n⚠️ **Pitfall: Over-Reliance on End-to-End Tests**\n- **Description:** Testing everything through complete program execution, making it difficult to pinpoint which component has a bug.\n- **Why It's Wrong:** When a test fails, you must debug the entire pipeline rather than an isolated component.\n- **Fix:** Maintain a balanced test pyramid: many unit tests, fewer integration tests, minimal end-to-end tests. Use unit tests to verify component logic in isolation.\n\n⚠️ **Pitfall: Hard-Coding Test Values**\n- **Description:** Writing tests that depend on specific string representations (e.g., `\"LoxFunction@4f023edb\"`) that vary across runs.\n- **Why It's Wrong:** Such tests are fragile and may fail due to unrelated changes like JVM memory address variations.\n- **Fix:** Test semantic behavior, not string representations. For functions and classes, test that they can be called, not how they convert to strings.\n\n⚠️ **Pitfall: Neglecting Line Number Tracking**\n- **Description:** Forgetting to test that error messages include accurate line and column numbers.\n- **Why It's Wrong:** Without accurate location information, debugging user programs becomes difficult.\n- **Fix:** In error test cases, explicitly verify that reported line numbers match the source location.\n\n### Architecture Decision Record: Test-First vs. Test-After Development\n\n> **Decision: Test-After Development with Milestone Checkpoints**\n\n**Context:**\nWe need a testing strategy suitable for learners building an interpreter incrementally. The interpreter has clear component boundaries and well-defined milestones, each adding specific functionality.\n\n**Options Considered:**\n1. **Test-Driven Development (TDD):** Write tests before implementing each feature.\n2. **Test-After with Milestone Verification:** Implement functionality first, then write tests to verify the milestone's acceptance criteria.\n3. **Ad-hoc Manual Testing:** Manually test features as implemented without systematic test suites.\n\n**Decision:**\nWe adopt **Test-After with Milestone Verification**. After completing each milestone's implementation, learners write comprehensive tests to verify all acceptance criteria.\n\n**Rationale:**\n- **Learning Focus:** For educational purposes, understanding how to implement features precedes learning test-driven methodologies.\n- **Clear Verification:** Milestone checkpoints provide concrete, testable outcomes that learners can verify systematically.\n- **Progressive Complexity:** Early milestones (Scanner, Parser) benefit from unit testing; later milestones (Interpreter features) benefit from integration testing.\n- **Practical Reality:** Learners often need to see the implementation working before they understand what to test.\n\n**Consequences:**\n- **Positive:** Learners gain experience writing tests that verify specific behaviors. The milestone structure provides natural test boundaries.\n- **Negative:** Some implementation bugs might only be caught after implementation is complete. Requires discipline to write tests for all acceptance criteria.\n- **Mitigation:** The verification guide provides explicit test cases for each milestone, ensuring comprehensive coverage.\n\n**Comparison Table:**\n\n| Option | Pros | Cons | Suitability for Learning |\n|--------|------|------|--------------------------|\n| **Test-Driven Development** | Ensures testable design, comprehensive test coverage from start | Requires understanding of feature behavior before implementation, can feel artificial for learners | Low: Adds cognitive load on top of implementation challenges |\n| **Test-After with Verification** | Natural progression: implement then verify, milestone checkpoints guide testing | May miss edge cases without upfront test design, requires retroactive test writing | High: Matches how learners naturally build (implement then test) |\n| **Ad-hoc Manual Testing** | Quick feedback, no test maintenance overhead | Inconsistent coverage, difficult to regression test, errors may slip through | Low: Doesn't teach systematic testing practices |\n\n### Implementation Guidance\n\nWhile the main design avoids code, this implementation guidance provides practical testing infrastructure to verify each milestone.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Testing Framework | JUnit 5 (standard Java testing) | TestNG (more features) |\n| Assertion Library | JUnit's built-in assertions | AssertJ (fluent assertions) |\n| Test Organization | One test class per component (ScannerTest, ParserTest, etc.) | Nested test classes by feature |\n| Test Data Management | Hard-coded strings in test methods | External test files for programs |\n| Mocking | Manual test doubles | Mockito (for complex dependencies) |\n\n#### B. Recommended File/Module Structure\n\n```\nlox-interpreter/\n  src/main/java/com/craftinginterpreters/lox/\n    Lox.java                    # Main entry point\n    Scanner.java                # Milestone 1\n    Token.java                  # Milestone 1\n    TokenType.java              # Milestone 1\n    parser/\n      Parser.java               # Milestone 3\n      ParseError.java           # Milestone 3\n    ast/\n      Expr.java                 # Milestone 2\n      Stmt.java                 # Milestone 2\n      AstPrinter.java           # Milestone 2 (for testing)\n    interpreter/\n      Interpreter.java          # Milestone 4+\n      Environment.java          # Milestone 5\n      RuntimeError.java         # Milestone 4\n      LoxFunction.java          # Milestone 7\n      LoxClass.java             # Milestone 9\n      LoxInstance.java          # Milestone 9\n  src/test/java/com/craftinginterpreters/lox/\n    ScannerTest.java            # Tests for Milestone 1\n    ParserTest.java             # Tests for Milestones 2-3\n    InterpreterTest.java        # Tests for Milestones 4-10\n    testdata/                   # Directory for test programs\n      hello.lox\n      arithmetic.lox\n      functions.lox\n      classes.lox\n```\n\n#### C. Infrastructure Starter Code: Test Utilities\n\nFor comprehensive testing, implement these utility classes:\n\n```java\n// TestUtilities.java - COMPLETE utility methods for testing\npackage com.craftinginterpreters.lox;\n\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class TestUtilities {\n    // Helper to create token list for parser tests\n    public static List<Token> tokenList(Token... tokens) {\n        return new ArrayList<>(List.of(tokens));\n    }\n    \n    // Helper to create a NUMBER token\n    public static Token numberToken(double value, int line) {\n        return new Token(TokenType.NUMBER, String.valueOf(value), value, line);\n    }\n    \n    // Helper to create a STRING token\n    public static Token stringToken(String value, int line) {\n        return new Token(TokenType.STRING, \"\\\"\" + value + \"\\\"\", value, line);\n    }\n    \n    // Helper to create an IDENTIFIER token\n    public static Token identifierToken(String name, int line) {\n        return new Token(TokenType.IDENTIFIER, name, null, line);\n    }\n    \n    // Helper to compare two values with tolerance for floating point\n    public static boolean valuesEqual(Object a, Object b) {\n        if (a == null && b == null) return true;\n        if (a == null) return false;\n        \n        if (a instanceof Double && b instanceof Double) {\n            return Math.abs((Double)a - (Double)b) < 0.000001;\n        }\n        return a.equals(b);\n    }\n}\n```\n\n#### D. Core Test Skeleton Code\n\n**Scanner Test Skeleton:**\n\n```java\n// ScannerTest.java - TODOs for core scanner tests\npackage com.craftinginterpreters.lox;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ScannerTest {\n    @Test\n    void testScanSingleTokens() {\n        // TODO 1: Create scanner with source: \"(){},.-+;/*\"\n        // TODO 2: Call scanTokens()\n        // TODO 3: Verify token types: LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, \n        //         RIGHT_BRACE, COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR\n        // TODO 4: Verify no errors reported\n    }\n    \n    @Test \n    void testScanKeywords() {\n        // TODO 1: Create scanner with source: \"var fun class if else while for return\"\n        // TODO 2: Call scanTokens()\n        // TODO 3: Verify token types: VAR, FUN, CLASS, IF, ELSE, WHILE, FOR, RETURN\n        // TODO 4: Verify lexemes match keywords exactly\n    }\n    \n    @Test\n    void testScanNumbers() {\n        // TODO 1: Create scanner with source: \"123 45.67 .5\" (note: .5 is invalid)\n        // TODO 2: Call scanTokens()\n        // TODO 3: Verify NUMBER tokens with correct literal values (123, 45.67)\n        // TODO 4: Verify error reported for \".5\" (or tokenized as DOT then 5)\n    }\n    \n    @Test\n    void testScanStrings() {\n        // TODO 1: Create scanner with source: \"\\\"hello\\\" \\\"world\\\\n\\\"\"\n        // TODO 2: Call scanTokens()\n        // TODO 3: Verify STRING tokens with values \"hello\" and \"world\\n\"\n        // TODO 4: Verify line counting within strings (escaped newline doesn't increment)\n    }\n    \n    @Test\n    void testScanErrors() {\n        // TODO 1: Create scanner with source: \"@ # $\\nvar\"\n        // TODO 2: Call scanTokens()\n        // TODO 3: Verify errors reported for '@', '#', '$' at line 1\n        // TODO 4: Verify VAR token still scanned after errors\n    }\n}\n```\n\n**Parser Test Skeleton:**\n\n```java\n// ParserTest.java - TODOs for core parser tests  \npackage com.craftinginterpreters.lox;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ParserTest {\n    @Test\n    void testParseArithmetic() {\n        // TODO 1: Create tokens: 1 + 2 * 3\n        // TODO 2: Create parser with tokens\n        // TODO 3: Call parse() to get statements\n        // TODO 4: Use AstPrinter to convert AST to string\n        // TODO 5: Verify string matches expected: \"(+ 1 (* 2 3))\" or similar\n    }\n    \n    @Test\n    void testParseParentheses() {\n        // TODO 1: Create tokens: (1 + 2) * 3\n        // TODO 2: Parse and get AST\n        // TODO 3: Verify structure: (* (+ 1 2) 3)\n    }\n    \n    @Test\n    void testParseComparison() {\n        // TODO 1: Create tokens: 1 < 2 == true\n        // TODO 2: Parse and get AST\n        // TODO 3: Verify structure: (== (< 1 2) true) with correct precedence\n    }\n    \n    @Test\n    void testParseErrorRecovery() {\n        // TODO 1: Create tokens with error: 1 + ; print 2;\n        // TODO 2: Parse - should report error at SEMICOLON\n        // TODO 3: Verify parser continues and produces AST for \"print 2;\"\n    }\n}\n```\n\n**Interpreter Test Skeleton:**\n\n```java\n// InterpreterTest.java - TODOs for core interpreter tests\npackage com.craftinginterpreters.lox;\n\nimport org.junit.jupiter.api.Test;\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass InterpreterTest {\n    @Test\n    void testEvaluateArithmetic() {\n        // TODO 1: Create AST: Binary(Literal(1.0), PLUS, Literal(2.0))\n        // TODO 2: Create interpreter\n        // TODO 3: Call evaluate() on AST\n        // TODO 4: Verify result equals 3.0 (with floating tolerance)\n    }\n    \n    @Test\n    void testRuntimeTypeError() {\n        // TODO 1: Create AST: Binary(Literal(\"hello\"), MINUS, Literal(1))\n        // TODO 2: Create interpreter\n        // TODO 3: Call evaluate() - should throw RuntimeError\n        // TODO 4: Verify error message: \"Operands must be numbers.\"\n    }\n    \n    @Test\n    void testVariableScope() {\n        // TODO 1: Create AST for: { var x = 1; print x; }\n        // TODO 2: Create interpreter\n        // TODO 3: Call interpret() with statements\n        // TODO 4: Capture output, verify prints \"1\"\n        // TODO 5: Test nested scope: { var x = 1; { var x = 2; } print x; }\n    }\n    \n    @Test\n    void testFunctionCall() {\n        // TODO 1: Create AST for function declaration and call\n        // TODO 2: Interpret statements\n        // TODO 3: Verify function is callable and returns correct value\n        // TODO 4: Test recursion with factorial function\n    }\n    \n    @Test\n    void testClassInheritance() {\n        // TODO 1: Create AST for class hierarchy: class A { method() { return 1; } } class B < A {}\n        // TODO 2: Interpret statements\n        // TODO 3: Create instance of B, call method()\n        // TODO 4: Verify returns 1 (inherited method)\n    }\n}\n```\n\n#### E. Language-Specific Hints (Java)\n\n1. **Capturing Console Output:** Use `ByteArrayOutputStream` and `PrintStream` to capture `System.out` for testing print statements:\n   ```java\n   ByteArrayOutputStream output = new ByteArrayOutputStream();\n   System.setOut(new PrintStream(output));\n   // Run interpreter\n   assertEquals(\"3\\n\", output.toString());\n   ```\n\n2. **Testing Exceptions:** Use JUnit's `assertThrows` to verify errors:\n   ```java\n   RuntimeError error = assertThrows(RuntimeError.class, () -> interpreter.evaluate(ast));\n   assertTrue(error.getMessage().contains(\"Operands must be numbers\"));\n   ```\n\n3. **Floating Point Comparisons:** Use epsilon comparison for double values:\n   ```java\n   private static final double EPSILON = 0.000001;\n   assertTrue(Math.abs((Double)result - expected) < EPSILON);\n   ```\n\n4. **Visitor Pattern Testing:** When testing visitors, you can create anonymous visitor implementations for specific test cases rather than relying on the full interpreter.\n\n#### F. Milestone Checkpoint Commands\n\nFor each milestone, after implementing the feature, run these verification commands:\n\n**Milestone 1 (Scanner):**\n```bash\n# Run scanner tests\n./gradlew test --tests \"*.ScannerTest\"\n\n# Expected: All tests pass, with green output showing tokenization works\n# If tests fail, check error messages to see which tokens are incorrect\n```\n\n**Milestones 2-3 (Parser & AST):**\n```bash\n# Run parser tests\n./gradlew test --tests \"*.ParserTest\"\n\n# Manually test with a simple expression\njava -cp build/classes/java/main com.craftinginterpreters.lox.Lox <<< \"print (1 + 2) * 3;\"\n# Should parse successfully (may not evaluate yet)\n```\n\n**Milestone 4 (Evaluating Expressions):**\n```bash\n# Run interpreter expression tests\n./gradlew test --tests \"*.InterpreterTest.testEvaluate*\"\n\n# Test manually\njava -cp build/classes/java/main com.craftinginterpreters.lox.Lox <<< \"print 1 + 2 * 3;\"\n# Should print: 7\n```\n\n**Milestone 5 (Statements and State):**\n```bash\n# Test variable functionality\njava -cp build/classes/java/main com.craftinginterpreters.lox.Lox <<< \"var x = 1; x = x + 2; print x;\"\n# Should print: 3\n```\n\n**Milestone 6 (Control Flow):**\n```bash\n# Test if and while\njava -cp build/classes/java/main com.craftinginterpreters.lox.Lox <<< \"\nvar i = 0;\nwhile (i < 3) {\n  if (i % 2 == 0) {\n    print \\\"even: \\\" + i;\n  }\n  i = i + 1;\n}\"\n# Should print: even: 0, even: 2\n```\n\n**Milestone 7 (Functions):**\n```bash\n# Test function declaration and call\njava -cp build/classes/java/main com.craftinginterpreters.lox.Lox <<< \"\nfun factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\nprint factorial(5);\"\n# Should print: 120\n```\n\n**Milestone 8 (Closures):**\n```bash\n# Test closure capture\njava -cp build/classes/java/main com.craftinginterpreters.lox.Lox <<< \"\nfun makeCounter() {\n  var i = 0;\n  fun count() {\n    i = i + 1;\n    return i;\n  }\n  return count;\n}\nvar c = makeCounter();\nprint c();\nprint c();\"\n# Should print: 1, then 2\n```\n\n**Milestone 9 (Classes):**\n```bash\n# Test class instantiation\njava -cp build/classes/java/main com.craftinginterpreters.lox.Lox <<< \"\nclass Point {\n  init(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\nvar p = Point(1, 2);\nprint p.x;\"\n# Should print: 1\n```\n\n**Milestone 10 (Inheritance):**\n```bash\n# Test inheritance chain\njava -cp build/classes/java/main com.craftinginterpreters.lox.Lox <<< \"\nclass A {\n  method() { return \\\"A\\\"; }\n}\nclass B < A {\n  method() { return super.method() + \\\"B\\\"; }\n}\nvar b = B();\nprint b.method();\"\n# Should print: AB\n```\n\n#### G. Debugging Tips for Test Failures\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Scanner tests fail on multi-character operators** | Not advancing `current` past both characters | Add debug prints showing which characters are being examined | Ensure `match()` advances position when successful |\n| **Parser goes into infinite loop** | Left-recursive grammar rule | Check that parsing methods always consume at least one token before recursing | Rewrite grammar to eliminate left recursion or add progress check |\n| **AST structure incorrect** | Wrong precedence or associativity | Use AstPrinter to visualize AST, compare with expected | Verify parsing method order matches precedence table |\n| **Variable lookup finds wrong value** | Environment chain traversal incorrect | Print environment chain during lookup, check parent links | Ensure `enclosing` field set correctly when creating nested environments |\n| **Closure captures wrong environment** | Capturing call environment instead of definition environment | Check which environment is stored in LoxFunction | Capture defining environment when function is created, not when called |\n| **Method call returns nil unexpectedly** | Return statement not propagating value | Add debug to trace return exception throwing/catching | Ensure `visitReturnStmt` throws exception caught in `call()` method |\n| **Super calls wrong method** | Incorrect method resolution order | Print class hierarchy during super lookup | Walk from current class's superclass, not instance's class |\n\n**Effective Debugging Techniques:**\n1. **Add AST Visualization:** Implement a `toString()` method for each AST node or use the AstPrinter to see the actual structure.\n2. **Environment Dumper:** Add a method to print all variables in an environment chain.\n3. **Execution Tracing:** Add flags to log each evaluation step: `TRACE=true` environment that prints every visit method call.\n4. **Unit Test Isolation:** When a test fails, create a minimal reproducing test case to isolate the issue.\n5. **Use a Debugger:** Set breakpoints in key methods like `visitBinaryExpr`, `Environment.get`, `LoxFunction.call`.\n\n> **Testing Philosophy:** The goal of testing in this educational project is not just to verify correctness, but to **build understanding**. Each test you write forces you to think through edge cases and semantics, deepening your comprehension of the language you're implementing.\n\n\n## 9. Debugging Guide\n\n> **Milestone(s):** All milestones (Milestones 1-10) — Debugging is an integral skill for any software project, but for an interpreter, it involves reasoning across multiple layers of abstraction. This guide provides a structured reference for diagnosing and fixing common issues that arise during implementation, categorized by observable symptoms. It also suggests practical techniques to illuminate the interpreter's internal state.\n\nInterpreting a programming language involves a complex dance between static structures (tokens, AST) and dynamic behavior (environments, function calls). When a bug surfaces, it can be challenging to pinpoint which layer is at fault. This debugging guide is designed to help you develop a systematic approach: start from the observable symptom (e.g., a crash, incorrect output, or infinite loop), trace it back through the data flow, and identify the faulty component or logic.\n\nThe guide is structured as a two-part toolkit. First, a comprehensive table maps specific symptoms to their likely root causes and provides targeted fixes. Second, it recommends proactive debugging techniques—like adding visualization tools to your interpreter—that can turn a opaque execution into a transparent, step-by-step narrative.\n\n### Symptom → Cause → Fix Table\n\nThis table catalogs common issues you may encounter while building your Lox interpreter. For each symptom, we describe the typical manifestation, the underlying cause in the design or implementation, and a concrete fix to apply.\n\n| Symptom (What you observe) | Likely Cause (Where the bug lives) | Steps to Diagnose | Recommended Fix |\n| :--- | :--- | :--- | :--- |\n| **Parser goes into an infinite loop or stack overflows on a simple expression like `1 + 2`.** | **Left-recursive grammar rule.** In your parsing method for a precedence level (e.g., `expression()`), you might be unconditionally calling itself first, creating infinite recursion. For example, `expression() -> equality() -> comparison() -> term() -> factor() -> unary() -> primary() -> expression()` forms a cycle. | Add print statements at the start of each parsing method (`expression()`, `equality()`, etc.) to see the call sequence. You'll see the same method called repeatedly without consuming tokens. | Ensure your parsing functions follow the pattern: parse a lower-precedence operator, then loop to parse higher-precedence operators. For example, `expression()` should call `equality()`, then loop while seeing `OR` tokens. The base of the recursion must be `primary()`, which consumes a literal or parenthesized expression without recursively calling the top-level `expression()`. |\n| **`\"Unterminated string\"` error is reported for a perfectly valid string like `\"hello\"`.** | **Incorrect handling of the closing quote.** The scanner's string literal logic advances until it finds a `\"` but doesn't check for the end of the source file (`isAtEnd()`). If the string is the last token in the file, it may run past the end and report an error. | Check the scanner's `string()` method. Does it break only when it sees `\"`? What happens when `isAtEnd()` becomes true first? | In the `while` loop that scans string characters, add a check for `isAtEnd()`. If reached, report an error: \"Unterminated string.\" and break. Ensure the loop condition is `while (!isAtEnd() && peek() != '\"')`. |\n| **Variable lookup finds the wrong value or says `\"Undefined variable\"` for a variable that should be in scope.** | **Incorrect environment chain traversal.** The `Environment.get()` method searches only the immediate scope, not the parent chain. Or, `Environment.assign()` updates the wrong scope, modifying a parent's binding when it should shadow. | Print the environment chain during lookup. For a variable `x`, dump each environment's `values` map along the `enclosing` links. See if the binding exists in a different scope than expected. | Ensure `Environment.get(Token name)` recursively checks the current scope, then `enclosing` (if not `null`). `Environment.assign(Token name, Object value)` must follow the same search path and update the *first* environment where the variable is found (or error if none). |\n| **`print 1 + \"string\";` crashes or produces gibberish instead of a runtime error.** | **Missing runtime type checking.** The `visitBinaryExpr` method for the `PLUS` operator directly performs arithmetic or concatenation without verifying the operands' types. | Check the code handling the `PLUS` token. Is there a call to `checkNumberOperands()` or similar validation? Does it handle the string concatenation case separately? | Implement `checkNumberOperands()` and call it for arithmetic operators (`MINUS`, `SLASH`, `STAR`). For `PLUS`, explicitly check: if both operands are numbers, add; if both are strings, concatenate; else, throw a `RuntimeError`. |\n| **Logical operator `and` does not short-circuit; it always evaluates both sides.** | **Eager evaluation of operands.** In `visitLogicalExpr`, you likely evaluate `left` and `right` unconditionally before checking the operator. | Add a print statement before evaluating each operand. You'll see both prints even when the left operand of an `and` is false. | Evaluate the left operand first. For `AND`: if the left is falsy, return it immediately. For `OR`: if the left is truthy, return it immediately. Only evaluate the right operand if needed. |\n| **Function calls work once but incorrectly share local variables between subsequent calls.** | **Reusing the same environment for each call.** The `LoxFunction.call()` method might be using a single environment instance for the function's local scope, rather than creating a new one per invocation. | Print the environment's identity (e.g., `System.identityHashCode(environment)`) inside the function body for two calls. If it's the same, variables are being shared. | In `LoxFunction.call()`, create a *new* `Environment` for each call, setting the closure (the function's `closure` field) as its parent. Bind parameters in this fresh environment. |\n| **Closure captures the *value* of an outer variable at definition time, not a *reference*; modifying the outer variable doesn't affect the closure.** | **Environment capture by copy, not by reference.** The closure might be storing a *copy* of the defining environment's variable map, rather than a reference to the environment object itself. | Check how the closure is created. Is it storing a new `Environment` object with the same mappings, or is it storing a reference to the existing environment? | Ensure the `LoxFunction` stores a reference to the *defining* `Environment` object (the one active when the function was declared). Do not copy its `values` map. |\n| **`this` inside a method refers to the class, not the instance, or throws \"Undefined variable 'this'.\"** | **Missing `this` binding in the method's environment.** When a method is called, the interpreter must bind `this` in the method's local environment to the instance on which the method was invoked. | In `visitCallExpr`, check how you prepare the environment for a method call. Is `this` defined? For a `LoxFunction` that represents a method, does its `call()` method bind `this`? | In `LoxFunction.bind(LoxInstance instance)`, create a new environment with the closure as parent, define `\"this\"` as the instance, and return a new `LoxFunction` that uses this environment. In `visitGetExpr`, if the property is a method, call `bind(instance)` on it. |\n| **`super.method()` calls the subclass's overridden method, not the superclass version.** | **Incorrect resolution of `super`.** The `visitSuperExpr` might be looking up the method starting from the instance's class, which would find the overridden method first. | Print the class hierarchy in `visitSuperExpr`. Are you correctly accessing the superclass from the current class? Is the method lookup starting from the superclass? | In `visitSuperExpr`, resolve the superclass via the interpreter's `environment` (or a dedicated `super` environment). Then, call `findMethod` on the *superclass* object, not the current class. |\n| **Division by zero (e.g., `1 / 0`) crashes with an arithmetic exception instead of a Lox runtime error.** | **Native Java arithmetic exception is not caught.** The interpreter uses Java's `/` operator, which throws `ArithmeticException` for integer division by zero. | Check if the division operation in `visitBinaryExpr` is wrapped in a try-catch for Java's `ArithmeticException`. | Before performing division, explicitly check if the right operand is zero (or within an epsilon for floating-point). If so, throw a Lox `RuntimeError`. Alternatively, catch Java's `ArithmeticException` and convert it. |\n| **The parser reports \"Expect expression\" when encountering a valid expression after an error.** | **Poor error recovery leaves the parser in a bad state.** After a parse error, the parser might not synchronize to a known boundary (like a semicolon), causing subsequent valid code to be misparsed. | Introduce a syntax error early in a multi-statement program. Observe if later statements are parsed correctly. | Implement panic-mode synchronization in `Parser`. In `synchronize()`, discard tokens until you reach a statement boundary (e.g., `SEMICOLON`, `CLASS`, `FUN`, `VAR`, `FOR`, `IF`, `WHILE`, `PRINT`, `RETURN`). |\n| **A loop `while (true) { }` hangs the interpreter indefinitely with no way to stop.** | **No timeout or interrupt mechanism.** The tree-walking interpreter will obediently execute the loop forever, as there's no built-in limit. | This is expected behavior for a correct infinite loop, but it can be problematic during testing. | For development, consider adding an optional execution step limit or a timeout. Increment a counter in `visitWhileStmt` and throw a runtime error after a large number (e.g., 1,000,000) iterations. |\n| **`nil` appears in arithmetic operations without a runtime error (e.g., `nil + 1` yields something).** | **Missing null/nil checks in type validation.** The `checkNumberOperand` or `checkNumberOperands` functions might only check for `Double` type, not rejecting `nil`. | Test `nil + 1`. Does it throw? Check `isTruthy` and `isEqual` functions as well—they must handle `nil` explicitly. | In `checkNumberOperand` and `checkNumberOperands`, explicitly verify the operand is an instance of `Double` (or `LoxNumber`). If it's `nil` or any other non-number, throw a `RuntimeError`. |\n| **Multiline string literals are not allowed, or newlines inside strings are lost.** | **Scanner's string literal logic stops at newline characters.** The scanner might treat `\\n` as a whitespace character to be skipped, rather than as part of the string. | Check the `string()` method. Does it break when it sees `\\n`? Does it handle escape sequences like `\\n`? | In the string scanning loop, allow newline characters (`peek() == '\\n'`) and increment the line counter. To support escape sequences, when you see a backslash, call a helper to translate the escape sequence (e.g., `\\n` to newline character). |\n| **`print` statement outputs `null` for `nil` instead of the word `\"nil\"`.** | **The `stringify()` method returns Java's `null` string representation.** When the value is `LoxNil` or Java `null`, `String.valueOf(value)` returns `\"null\"`. | Examine `Interpreter.stringify(Object object)`. How does it handle the `nil` value? | Explicitly check for `nil` in `stringify()`. If the object is `nil` (or `instanceof LoxNil`), return the string `\"nil\"`. For booleans, return `\"true\"` or `\"false\"` instead of `\"true\"`/`\"false\"` as Java strings. |\n| **Class inheritance creates a cycle (class A < B and class B < A) and crashes.** | **No cycle detection in class inheritance.** The parser or interpreter might allow a class to inherit from itself, directly or indirectly, leading to infinite recursion in method lookup. | Try defining two classes that inherit from each other. Does the parser accept it? What happens at runtime? | In `visitClassStmt`, after resolving the superclass expression, traverse the superclass chain starting from the current class. If you encounter the class being defined, report an error. Store a visited set or simply check that the superclass is not the class itself (direct cycle). |\n| **Return statement inside a nested block (but outside a function) causes a confusing error or crash.** | **The return exception is not caught at the appropriate level.** The `Return` exception (used to unwind the call stack) might be caught only at the top level, or not caught at all, causing program termination. | Place a `return` statement outside any function. Does the interpreter report a clear error? | Ensure `visitReturnStmt` throws a custom `Return` exception (containing the value). In `executeBlock()` and function call execution, catch this exception only when you are within a function context. If caught at the wrong level, rethrow it. At the top level, if a `Return` exception escapes, report an error: \"Cannot return from top-level code.\" |\n| **`fun` keyword used as a variable name is incorrectly tokenized as a keyword, causing a parse error.** | **Scanner's keyword detection does not check for identifiers after the keyword.** The scanner might match `fun` as the `FUN` keyword even when it's part of a longer identifier like `function`. | The scanner should match the longest possible lexeme. For `fun`, it's a keyword only if the following character is not a letter or digit (i.e., it's a separate token). | In the scanner, after identifying an alphabetic character (start of an identifier/keyword), consume while `isAlphaNumeric(peek())`. Then, check the resulting lexeme against the keyword map. This ensures `fun` is recognized only as a complete token. |\n| **The interpreter incorrectly allows reassignment to a variable that was declared with `var` in a deeper scope but not in the current scope.** | **`Environment.assign()` searches and updates the first matching variable in the chain, which may be in an outer scope, incorrectly modifying a different variable than intended.** | This is actually the correct behavior for lexical scoping: assignment should modify the nearest enclosing variable with that name. If you want to prevent this (some languages do), you need a different rule. | If the desired semantics are that assignment can only modify variables declared in the current scope, then `assign()` should not traverse the parent chain. However, Lox uses lexical scoping for assignment, so the described behavior is correct. Verify your understanding of the language spec. |\n| **Using `print` as a variable name causes a conflict with the `print` statement.** | **The scanner tokenizes `print` as the `PRINT` keyword regardless of context.** In Lox, `print` is a reserved keyword and cannot be used as an identifier. | Check the language grammar: `print` is a keyword for the print statement, not a built-in function. Thus, it is reserved. | This is by design. The scanner should recognize `print` as a `PRINT` token. The parser will then expect it as the start of a print statement. If you want to use `print` as a variable name, you would need to change the language, but that's outside the spec. |\n\n### Effective Debugging Techniques\n\nBeyond reactive troubleshooting, you can embed diagnostic tools directly into your interpreter to shed light on its internal operations. Think of these techniques as installing surveillance cameras in a factory: you can watch the raw materials (tokens) move along the conveyor belt, see how they're assembled into products (AST nodes), and observe the final testing (evaluation). When a defect occurs, you can review the footage to pinpoint the malfunctioning station.\n\n#### 1. AST Printer: Visualizing the Syntax Tree\n\nThe **AST Printer** is a visitor that converts an AST back into a human-readable string format, often as an S-expression. It's invaluable for verifying that your parser is building the correct tree structure.\n\n> **Mental Model:** The AST Printer is like a cartographer who translates a detailed, three-dimensional terrain model (the AST) back into a two-dimensional map with standardized symbols. By comparing the map to the source code, you can confirm the terrain was surveyed correctly.\n\n**How to implement:** You already built a basic printer in Milestone 2. Enhance it to be more detailed. For each node type, output a parenthesized representation that includes the node type and its key data (e.g., `(Binary + (Literal 1) (Literal 2))`). Call the printer right after parsing and log the output.\n\n**What it reveals:** Incorrect operator precedence (e.g., `1 + 2 * 3` parsed as `(+ 1 (* 2 3))` vs. `(+ 1 2) (* 3)`), missing nodes, or misplaced parentheses.\n\n#### 2. Environment Dumper: Mapping the Variable Universe\n\nAn **Environment Dumper** is a utility that prints the entire chain of environments, showing all variable bindings at a given point in execution. This is crucial for debugging scope, closure, and variable resolution issues.\n\n> **Mental Model:** The Environment Dumper is like a building superintendent who provides a floor-by-floor directory of all tenants (variables) and their current apartment contents (values). When someone can't find a tenant, the superintendent can check which floor the tenant is registered on.\n\n**How to implement:** Add a method `dump()` to the `Environment` class that iterates through the `values` map and prints each name-value pair, then recursively calls `dump()` on the `enclosing` environment (with an indentation increase). Call this at key points: before/after a function call, inside a block, or when a \"undefined variable\" error occurs.\n\n**What it reveals:** Whether a variable is defined in the current scope or a parent, if a closure captured the correct environment, and if `this` is bound in a method.\n\n#### 3. Step-by-Step Execution Log: The Interpreter's Diary\n\nAn **Execution Log** is a trace of every step the interpreter takes as it walks the AST. It logs each node visited (`visitBinaryExpr`, `visitLiteralExpr`, etc.), the values computed, and any side effects (variable definition, assignment).\n\n> **Mental Model:** The Execution Log is like a flight data recorder, meticulously timestamping every control input, sensor reading, and system state change during a flight. In a crash, the log tells you exactly what happened in the moments before.\n\n**How to implement:** Add a static logging flag to your interpreter. In each `visit` method, log the method name and relevant details (e.g., `\"Evaluating binary + with left=1.0, right=2.0\"`). Use indentation to show the depth of recursion. Log environment changes separately.\n\n**What it reveals:** The order of evaluation, short-circuiting behavior, function call entry/exit, and the exact point where a runtime error is thrown.\n\n#### 4. Token Stream Visualizer: Seeing the Lexical Stream\n\nA **Token Stream Visualizer** simply prints the list of tokens produced by the scanner, one per line, with their type, lexeme, and line number. This helps verify that the scanner is correctly categorizing the source code.\n\n**How to implement:** After calling `scanTokens()`, iterate through the list and print each token using its `toString()` method. Ensure you include identifiers, literals, and punctuation.\n\n**What it reveals:** Misclassified tokens (e.g., `=` vs `==`), incorrect handling of whitespace/comments, and malformed number or string literals.\n\n#### 5. Manual Test Harness with Assertions\n\nCreate a suite of small, focused Lox programs that test a single feature (e.g., variable shadowing, closure capture, super call). In each test, use `print` statements as assertions. For example, a test for closure capture might be:\n```lox\nvar x = \"outer\";\nfun f() { print x; }\nf(); // Should print \"outer\"\nx = \"changed\";\nf(); // Should print \"changed\"\n```\nRun these tests after each significant change to ensure you haven't introduced regressions.\n\n#### 6. Using a Debugger: Strategic Breakpoints\n\nWhile print-based logging is helpful, a modern IDE debugger allows you to pause execution, inspect variables, and step through code. Set breakpoints at critical junctions:\n- In `Parser.parse()` when a specific token type is consumed.\n- In `Interpreter.visitBinaryExpr` when the operator is `PLUS`.\n- In `LoxFunction.call()` when a new environment is created.\n- In `Environment.get()` when a particular variable name is looked up.\n\nWatch the call stack to understand the flow of control, especially for recursive functions and nested evaluations.\n\n### Implementation Guidance\n\nThis section provides concrete code snippets to implement the debugging techniques described above. These are supplemental tools that you can integrate into your interpreter during development.\n\n#### A. Enhanced AST Printer\n\nAdd this class to your project. It implements the `Expr.Visitor<String>` and `Stmt.Visitor<String>` interfaces to produce S-expression representations.\n\n```java\n// In file: tool/AstPrinter.java\npackage com.craftinginterpreters.lox.tool;\n\nimport com.craftinginterpreters.lox.Expr;\nimport com.craftinginterpreters.lox.Stmt;\nimport java.util.List;\n\npublic class AstPrinter implements Expr.Visitor<String>, Stmt.Visitor<String> {\n    public String print(Expr expr) {\n        return expr.accept(this);\n    }\n\n    public String print(Stmt stmt) {\n        return stmt.accept(this);\n    }\n\n    @Override\n    public String visitBinaryExpr(Expr.Binary expr) {\n        return parenthesize(expr.operator.lexeme, expr.left, expr.right);\n    }\n\n    @Override\n    public String visitGroupingExpr(Expr.Grouping expr) {\n        return parenthesize(\"group\", expr.expression);\n    }\n\n    @Override\n    public String visitLiteralExpr(Expr.Literal expr) {\n        if (expr.value == null) return \"nil\";\n        return expr.value.toString();\n    }\n\n    @Override\n    public String visitUnaryExpr(Expr.Unary expr) {\n        return parenthesize(expr.operator.lexeme, expr.right);\n    }\n\n    // TODO: Add visit methods for other expression types added later:\n    // Variable, Assign, Logical, Call, Get, Set, This, Super\n    // For example:\n    // @Override\n    // public String visitVariableExpr(Expr.Variable expr) {\n    //     return expr.name.lexeme;\n    // }\n\n    @Override\n    public String visitExpressionStmt(Stmt.Expression stmt) {\n        return parenthesize(\"expr\", stmt.expression);\n    }\n\n    @Override\n    public String visitPrintStmt(Stmt.Print stmt) {\n        return parenthesize(\"print\", stmt.expression);\n    }\n\n    @Override\n    public String visitVarStmt(Stmt.Var stmt) {\n        if (stmt.initializer == null) {\n            return parenthesize(\"var\", new Expr.Variable(stmt.name));\n        }\n        return parenthesize(\"var\", new Expr.Variable(stmt.name), stmt.initializer);\n    }\n\n    // TODO: Add visit methods for other statement types added later:\n    // Block, If, While, Function, Return, Class\n\n    private String parenthesize(String name, Expr... exprs) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"(\").append(name);\n        for (Expr expr : exprs) {\n            builder.append(\" \");\n            builder.append(expr.accept(this));\n        }\n        builder.append(\")\");\n        return builder;\n    }\n\n    // Helper to print a list of statements\n    public String print(List<Stmt> statements) {\n        StringBuilder builder = new StringBuilder();\n        for (Stmt stmt : statements) {\n            builder.append(print(stmt));\n            builder.append(\"\\n\");\n        }\n        return builder.toString();\n    }\n}\n```\n\n#### B. Environment Dumper\n\nAdd a static method to the `Environment` class to dump its contents. This method prints the current scope and recursively dumps enclosing scopes with indentation.\n\n```java\n// In file: environment/Environment.java (add this method)\npublic class Environment {\n    // ... existing fields and methods ...\n\n    public void dump() {\n        dump(0);\n    }\n\n    private void dump(int depth) {\n        String indent = \"  \".repeat(depth);\n        System.out.println(indent + \"Environment \" + System.identityHashCode(this) + \":\");\n        for (Map.Entry<String, Object> entry : values.entrySet()) {\n            System.out.println(indent + \"  \" + entry.getKey() + \" = \" + entry.getValue());\n        }\n        if (enclosing != null) {\n            enclosing.dump(depth + 1);\n        } else {\n            System.out.println(indent + \"  (no enclosing)\");\n        }\n    }\n}\n```\n\nTo use it, call `environment.dump();` at any point in the interpreter, e.g., inside `visitVarStmt` after defining a variable, or inside `LoxFunction.call()` before executing the body.\n\n#### C. Execution Logging with a Flag\n\nAdd a static boolean flag to your `Interpreter` class to enable/disable verbose logging. Then, add logging statements at the beginning of each `visit` method.\n\n```java\n// In file: interpreter/Interpreter.java\npublic class Interpreter implements Expr.Visitor<Object>, Stmt.Visitor<Void> {\n    private static final boolean DEBUG = true; // Set to false to disable logs\n    private int indentLevel = 0;\n\n    private void log(String message) {\n        if (!DEBUG) return;\n        String indent = \"  \".repeat(indentLevel);\n        System.err.println(indent + message);\n    }\n\n    @Override\n    public Object visitBinaryExpr(Expr.Binary expr) {\n        log(\"visitBinaryExpr: \" + expr.operator.lexeme);\n        indentLevel++;\n        Object left = evaluate(expr.left);\n        Object right = evaluate(expr.right);\n        indentLevel--;\n        log(\"  left=\" + left + \", right=\" + right);\n        // ... evaluation logic ...\n        Object result = ...;\n        log(\"  result=\" + result);\n        return result;\n    }\n\n    // Similarly, add log() calls in other visit methods.\n    // Increase indentLevel when entering a node, decrease when leaving.\n}\n```\n\nFor statement execution, you might want to log the statement type. For function calls, log the arguments and the return value.\n\n#### D. Token Stream Visualizer\n\nA simple utility method in your main `Lox` class can print tokens.\n\n```java\n// In file: Lox.java (add this method)\nprivate static void printTokens(List<Token> tokens) {\n    for (Token token : tokens) {\n        System.out.println(token);\n    }\n}\n```\n\nCall it after scanning and before parsing when you need to debug the scanner.\n\n#### E. Language-Specific Hints (Java)\n\n- **Identity Hash Code:** Use `System.identityHashCode(object)` to print a unique identifier for an object instance, helpful for distinguishing between different environment objects.\n- **Exception Stack Trace:** When catching exceptions (like `RuntimeError`), print the stack trace using `e.printStackTrace()` to see the call path.\n- **Java Debugger (JDB):** Learn to use JDB or the debugger integrated into your IDE (IntelliJ IDEA, Eclipse, VS Code). Set breakpoints and inspect variables.\n\n#### F. Milestone Checkpoint for Debugging\n\nAfter implementing the core interpreter (Milestone 5), you should be able to run a test program and use the debugging tools to verify internal state.\n\n**Test Command:** Create a file `test.lox`:\n```lox\nvar a = 1;\n{\n    var a = 2;\n    print a;\n}\nprint a;\n```\nRun your interpreter on this file.\n\n**Expected Output:** \n```\n2\n1\n```\n\n**Debugging Verification:**\n1. Enable the AST printer and verify the AST structure includes a block statement with a nested variable declaration.\n2. Enable environment dumping inside the block. You should see two environments: the inner one with `a = 2` and the outer one with `a = 1`.\n3. If the output is reversed (1 then 2), your environment chain might be reversed, or variable resolution might be looking only at the global scope.\n\n#### G. Debugging Tips Table (Recap of Common Issues)\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n| :--- | :--- | :--- | :--- |\n| Infinite recursion in parser | Left-recursive grammar | Print parsing method calls | Ensure base case is `primary()` |\n| Variables not found | Environment chain not searched | Dump environment chain | Implement recursive `get()` and `assign()` |\n| No short-circuit evaluation | Both operands evaluated eagerly | Log evaluation order | Check left operand first in `visitLogicalExpr` |\n| Functions share state across calls | Single environment reused | Print environment identity in each call | Create new `Environment` per call |\n| `this` not bound in methods | Missing `this` in method environment | Dump environment inside method call | Bind `this` in `LoxFunction.bind()` |\n\nBy incorporating these debugging techniques and referring to the symptom table, you can systematically isolate and fix issues throughout your interpreter's development journey.\n\n\n## 10. Future Extensions\n\n> **Milestone(s):** None (forward-looking enhancements)\n\nThis section explores the frontiers beyond the core interpreter—potential enhancements that the current architecture can accommodate with modest modifications. Think of the interpreter you've built as a **foundational engine**: robust and complete, but designed with extension points that invite further exploration. These extensions serve dual purposes: they demonstrate the flexibility of your design, and they provide meaningful projects for deepening your understanding of language implementation.\n\n> **Design Principle:** A well-architected interpreter should be **extensible along three dimensions**: new language features, performance improvements, and developer experience enhancements, without requiring fundamental redesigns of the core pipeline.\n\n### Possible Feature Additions\n\nThe interpreter's modular design—clean separation between lexical analysis, syntactic parsing, and semantic evaluation—creates natural insertion points for new capabilities. Each feature addition follows a consistent pattern: extend the **grammar** (Scanner and Parser), add corresponding **AST nodes** (Data Model), and implement **semantics** (Interpreter visitor methods). The Visitor pattern proves particularly valuable here, as new node types simply require new visitor methods without disturbing existing evaluation logic.\n\n#### Adding a Read-Eval-Print Loop (REPL)\n\n**Mental Model:** The REPL transforms the interpreter from a **batch processor** (reading files) into an **interactive conversation partner**, enabling immediate feedback and exploratory programming—like having a calculator that understands Lox syntax.\n\n**Current Architecture Fit:** The interpreter already has a `Lox.run(String)` method that processes a source string. The REPL adds:\n1. A continuous loop in `Lox.runPrompt()` that reads lines from standard input\n2. Special handling for multi-line inputs (like function declarations spanning lines)\n3. A persistent top-level environment across inputs (unlike file execution which starts fresh)\n\n**Required Changes:**\n| Component | Modification Required | Complexity |\n|-----------|----------------------|------------|\n| `Lox` class | Add `runPrompt()` with readline loop, detect incomplete statements | Low |\n| `Parser` | Synchronize on newline when in REPL mode vs. EOF in file mode | Medium |\n| `Interpreter` | Maintain global environment across REPL inputs, maybe display results automatically | Low |\n| Error Handling | Continue after errors in REPL (don't exit entire session) | Medium |\n\n**Implementation Considerations:** The main challenge is handling **incomplete statements**. When the parser encounters EOF mid-statement (like `fun f(`), it must distinguish between \"end of file\" (error) and \"end of line, more input expected\" (REL prompt for continuation). A simple approach: catch `ParseError` and if in REPL mode and error was unexpected EOF, read another line and concatenate.\n\n> **ADR: REPL Continuation Strategy**\n> - **Context:** REPL must handle multi-line inputs gracefully without requiring perfect syntax on first line\n> - **Options Considered:** \n>   1. **Prompt-based continuation:** When parser hits unexpected EOF, print `... > ` and read more input\n>   2. **Bracket counting:** Track open `{`, `(`, `[` and continue until all closed\n>   3. **Statement delimiter:** Require explicit continuation character (like `\\` at line end)\n> - **Decision:** Prompt-based continuation with basic bracket counting\n> - **Rationale:** Mimics behavior of mature REPLs (Python, Node.js); bracket counting handles most real multi-line cases (function bodies, blocks)\n> - **Consequences:** More complex parser error recovery logic; need to reset parser state on continuation\n\n#### Standard Library Functions\n\n**Mental Model:** The standard library provides **pre-built tools** that every Lox program can use without reinvention—like a Swiss Army knife included with the language. These are functions written not in Lox, but in Java (or your implementation language) and exposed as built-in callables.\n\n**Architecture Integration:** The `Environment` class already has a `globals` field. Standard library functions become `LoxFunction` objects (or a new `LoxNativeFunction` subclass) registered in the global environment during interpreter initialization.\n\n| Function Category | Example Functions | Implementation Approach |\n|-------------------|-------------------|------------------------|\n| Mathematical | `sqrt(x)`, `sin(x)`, `random()` | Delegate to Java `Math` class, with type checking |\n| String Operations | `length(s)`, `substring(s, start, end)`, `split(s, delim)` | Operate on Java `String` wrapper, return new `LoxString` |\n| Type Utilities | `typeOf(value)`, `isNumber(value)`, `toString(value)` | Inspect runtime object types, use existing `stringify()` |\n| Collection Basics | `arrayCreate(size)`, `arrayPush(arr, value)` | Require new array data type (see below) |\n\n**Native Function Interface:**\n```java\n// Example interface (shown in Implementation Guidance)\ninterface LoxCallable {\n    int arity();\n    Object call(Interpreter interpreter, List<Object> arguments);\n}\n```\n\n**Implementation Pattern:** Each standard library function implements `LoxCallable` with type-checked arguments and Java-side logic. The `Interpreter` initializes `globals` with these functions before any user code runs.\n\n#### Native Functions and Foreign Function Interface (FFI)\n\n**Mental Model:** A **bridge to the host world**—allowing Lox programs to call functions written in Java (or C/Rust) and access system capabilities like file I/O, networking, or graphics. This transforms Lox from a toy language into one that can interact with the real world.\n\n**Architecture Extension:** Native functions share the same `LoxCallable` interface as standard library functions but require careful design for data marshalling between Lox values and host language types.\n\n| Concern | Design Decision | Rationale |\n|---------|----------------|-----------|\n| **Type Marshalling** | Convert Lox values to Java objects: `LoxNumber` → `Double`, `LoxString` → `String` | Simpler for implementer, leverages host language type system |\n| **Error Propagation** | Throw `RuntimeError` for invalid arguments or host-side failures | Consistent with Lox's error handling model |\n| **Memory Management** | Native functions can allocate host resources; need cleanup hooks | Simple approach: no automatic cleanup (educational focus) |\n| **Callback Support** | Allow native functions to call back into Lox functions | Requires passing `LoxFunction` as argument, maintaining interpreter context |\n\n> **ADR: FFI Safety vs. Power Trade-off**\n> - **Context:** Native functions can crash the interpreter or cause undefined behavior if misused\n> - **Options Considered:**\n>   1. **Restricted FFI:** Only pre-approved safe functions (math, string ops)\n>   2. **Unrestricted FFI:** Allow any Java method call via reflection\n>   3. **Sandboxed FFI:** Run native code in isolated environment with resource limits\n> - **Decision:** Restricted FFI with explicit registration of safe functions\n> - **Rationale:** Educational project prioritizes safety and simplicity; reflection adds complexity without proportional learning value\n> - **Consequences:** Limited to functions we explicitly implement; can't dynamically call arbitrary Java methods\n\n#### Additional Control Flow: `break`, `continue`, and `switch`\n\n**Mental Model:** `break` and `continue` are **loop control commands**—emergency exits and fast-forward buttons for loops. `switch` is a **multi-way branch**—a more structured alternative to chained `if-else` statements.\n\n**Grammar Extensions:**\n```\nstatement → exprStmt | printStmt | block | ifStmt | whileStmt | forStmt \n          | breakStmt | continueStmt | switchStmt ;\n\nbreakStmt → \"break\" \";\" ;\ncontinueStmt → \"continue\" \";\" ;\n\nswitchStmt → \"switch\" \"(\" expression \")\" \"{\" \n             ( \"case\" expression \":\" statement* )* \n             ( \"default\" \":\" statement* )? \n           \"}\" ;\n```\n\n**Implementation Challenges:**\n\n| Feature | Challenge | Solution Approach |\n|---------|-----------|-------------------|\n| `break`/`continue` | Must exit/continue the innermost loop, not just any statement | Store loop nesting depth in interpreter, use exception-like control flow |\n| `switch` | Multiple cases with fall-through vs. break behavior | Implement Java-style fall-through (educational) or require explicit `break` |\n| Scope | Do cases create new scopes? | Each case block gets its own environment for consistency with `if` |\n\n**Control Flow Implementation Pattern:** Use a specialized exception (`BreakException`, `ContinueException`) that carries no value but unwinds the call stack to the nearest loop boundary. The `visitWhileStmt` and `visitForStmt` methods catch these exceptions and handle them appropriately.\n\n#### Arrays and Basic Data Structures\n\n**Mental Model:** Arrays are **indexed collections**—numbered slots that can hold values of any type. Adding arrays transforms Lox from a calculator with variables into a language capable of handling real data.\n\n**Architecture Impact:**\n1. **New Token Types:** `LEFT_BRACKET`, `RIGHT_BRACKET`\n2. **New AST Nodes:** `ArrayLiteral` (list of expressions), `SubscriptExpr` (array[index])\n3. **New Runtime Type:** `LoxArray` with internal `List<Object>` storage\n4. **New Operations:** Index get/set, `length` property/method\n\n**Grammar:**\n```\nprimary → ( \"[\" ( expression ( \",\" expression )* )? \"]\" ) | ... existing rules ... ;\npostfix → primary ( \"[\" expression \"]\" | \".\" IDENTIFIER | \"(\" arguments? \")\" )* ;\n```\n\n**Design Decisions for Arrays:**\n\n| Decision Point | Options | Recommended Choice |\n|----------------|---------|-------------------|\n| **Index Origin** | 0-based (C/Java) vs 1-based (Lua) | 0-based for consistency with implementation language |\n| **Bounds Checking** | Check at runtime, throw error if out of bounds | Always check; no buffer overflows |\n| **Dynamic Resizing** | Fixed-size vs growable | Growable via `add()` method for simplicity |\n| **Multi-dimensional** | Arrays of arrays vs native multi-D | Arrays of arrays (more flexible) |\n\n**Integration:** The `LoxArray` class implements `LoxInstance` so arrays can have methods (`length()`, `push(value)`, `pop()`) while also supporting indexed access via `array[0]` syntax.\n\n#### Exception Handling with `try`/`catch`\n\n**Mental Model:** Exceptions are **controlled crashes**—a way for functions to signal \"I can't handle this situation\" and let callers decide what to do. The `try` block is a safety net, and `catch` is the person who catches what falls.\n\n**Grammar Extension:**\n```\nstatement → ... | tryStmt ;\ntryStmt → \"try\" block \"catch\" \"(\" IDENTIFIER \")\" block ;\n```\n\n**Implementation Approach:**\n1. Add `RuntimeError` subclass `LoxException` that carries a value (the exception object)\n2. In `Interpreter`, when evaluating an expression that throws, unwind until finding a `try` block\n3. The `catch` clause creates a new local variable (the identifier) bound to the exception value\n4. Execute the catch block in that environment\n\n**Design Considerations:**\n\n| Consideration | Decision | Rationale |\n|---------------|----------|-----------|\n| **Exception Values** | Any Lox value can be thrown | Simple, flexible; follows JavaScript model |\n| **Finally Clause** | Omit for simplicity | Adds significant complexity for cleanup |\n| **Exception Hierarchy** | Single exception type vs class hierarchy | Single `LoxException` for educational simplicity |\n| **Uncaught Exceptions** | Terminate program with error message | Same as current runtime error behavior |\n\n#### Modules and Imports\n\n**Mental Model:** Modules are **self-contained toolboxes**—collections of related functions and classes that can be loaded on demand. The `import` statement is like saying \"I need the tools from that toolbox.\"\n\n**Architecture Changes Required:**\n\n| Component | Changes | Complexity |\n|-----------|---------|------------|\n| **Scanner/Parser** | New `import` keyword and statement | Low |\n| **Interpreter** | Module cache, separate environments per module | High |\n| **File System** | Resolve module paths, detect cycles | Medium |\n| **Environment** | Module-level vs global vs local scopes | High |\n\n**Simplified Approach (Single File Modules):**\n1. `import \"module.lox\"` loads and executes that file once\n2. Creates a new `Environment` for the module (parent is globals)\n3. Exports: all top-level declarations become available to importer\n4. Import returns a `LoxModule` object that provides access to exported names\n\n**Implementation Pattern:** Use a `Map<String, Environment>` module cache. When importing, check cache first; if not present, run the module file's statements in a fresh environment, store that environment in cache, and return a wrapper that delegates lookups to it.\n\n#### Compiling to Bytecode (Transition to a Virtual Machine)\n\n**Mental Model:** Bytecode compilation transforms the **AST interpreter** (walking the tree each time) into a **virtual machine** (walking a linear instruction list). Think of it as converting a recipe (AST) into a punch card for a cooking robot (bytecode VM)—more steps upfront, but faster execution.\n\n**Architecture Transformation Path:**\n\n| Step | Description | Impact |\n|------|-------------|--------|\n| 1. **Define Bytecode Instruction Set** | Simple stack-based operations: `CONSTANT`, `ADD`, `STORE`, `LOAD` | New `OpCode` enum, `Chunk` class |\n| 2. **Write Compiler Visitor** | Transform AST nodes to bytecode sequences | New `Compiler` class implementing visitor interfaces |\n| 3. **Build Virtual Machine** | Stack machine that executes bytecode | New `VM` class replacing parts of `Interpreter` |\n| 4. **Gradual Migration** | Start with expressions only, keep statements as tree-walking | Hybrid approach reduces risk |\n\n**Bytecode Example:** The expression `1 + 2 * 3` compiles to:\n```\nCONSTANT 0  (value: 1)\nCONSTANT 1  (value: 2)\nCONSTANT 2  (value: 3)\nMULTIPLY\nADD\n```\n\n**Performance Benefits:** Bytecode eliminates AST traversal overhead, enables optimization passes (constant folding, dead code elimination), and prepares for Just-In-Time (JIT) compilation.\n\n> **ADR: Gradual vs Complete VM Migration**\n> - **Context:** Transitioning from tree-walking to bytecode VM is a major architectural change\n> - **Options Considered:**\n>   1. **Complete Rewrite:** Build VM from scratch, discard tree-walking interpreter\n>   2. **Gradual Migration:** Compile expressions to bytecode, interpret statements as AST\n>   3. **Dual Implementation:** Support both interpreters, select via flag\n> - **Decision:** Gradual migration starting with expressions\n> - **Rationale:** Lower risk, allows testing VM incrementally, preserves educational value of seeing both approaches\n> - **Consequences:** Temporary complexity of two evaluation strategies; need bridge between VM and environment systems\n\n### Performance Optimizations\n\nWhile the tree-walking interpreter prioritizes clarity over speed, several optimizations can significantly improve performance without altering the fundamental architecture. These optimizations demonstrate important compiler techniques while keeping the codebase comprehensible.\n\n#### Constant Folding\n\n**Mental Model:** Constant folding is the interpreter's **pre-calculation**—evaluating constant expressions at compile time rather than runtime, like a baker measuring all ingredients before starting rather than stopping to measure between each step.\n\n**Implementation Approach:** Add a compile-time optimization pass between parsing and interpretation that walks the AST, identifying sub-expressions with only literal values, evaluating them, and replacing with a single `Literal` node.\n\n**Example Transformation:**\n- **Before:** `Binary(+, Literal(1), Binary(*, Literal(2), Literal(3)))`\n- **After:** `Literal(7)`\n\n**Algorithm:**\n1. Create `ConstantFolder` class implementing `Expr.Visitor<Expr>` and `Stmt.Visitor<Stmt>`\n2. For each `Binary` node: recursively fold children; if both are literals, compute result, return new `Literal`\n3. Apply to `Unary`, `Grouping`, and `Logical` nodes similarly\n4. For statements: fold expressions within `Print`, `Var`, `If`, `While`, etc.\n\n**Limitations:** Cannot fold variables (unknown at compile time) or function calls (side effects). Safe to apply only to pure arithmetic and logical operations.\n\n#### Environment Flattening (Upvalue Resolution)\n\n**Mental Model:** Environment flattening transforms the **linked list of scopes** (slow chain of hash map lookups) into a **flat array of slots** (fast indexed access). Think of it as creating a cheat sheet that lists all variables you'll need during a function's execution, with their \"home addresses\" pre-calculated.\n\n**Current Performance Issue:** Each variable lookup in a closure may traverse multiple environment links: local → closure-captured → outer function → global. With nested closures, this becomes O(depth) per access.\n\n**Optimization Approach:** \n1. **Analysis Phase:** Walk function body AST before execution, identify all variable references\n2. **Upvalue Resolution:** For variables not defined locally, record which enclosing environment and depth they come from\n3. **Flat Storage:** Store all accessed variables (local and upvalues) in a single array\n4. **Fast Access:** Variable references become array indices instead of name lookups\n\n**Implementation Steps:**\n1. Add `Resolver` pass before interpretation (similar to book's Chapter 11 resolver)\n2. Store resolution results in `Interpreter.locals: Map<Expr, Integer>` (already in design!)\n3. Modify `Environment` to support indexed access alongside name-based access\n4. Change `visitVariableExpr` to use index when available\n\n**Performance Impact:** Variable access changes from O(n) hash lookup + chain traversal to O(1) array access. Most significant for loops accessing captured variables.\n\n#### Method Caching\n\n**Mental Model:** Method caching is the interpreter's **Rolodex**—remembering where you found a method last time so you don't have to search the class hierarchy again. For `object.method()` calls, cache the resolved method at the call site.\n\n**Problem:** Each `object.method()` call traverses: instance fields → class methods → superclass chain. With inheritance hierarchies, this repeated traversal adds overhead.\n\n**Solution:** Add a **cache at the call site** (AST node) that remembers: for a given receiver object's class, which method was found. On subsequent calls with same class, use cached method.\n\n**Implementation:**\n1. Add field to `Expr.Call` node: `cachedMethod: LoxFunction` and `cachedClass: LoxClass`\n2. In `visitCallExpr`, before full resolution: check if `callee` is `Get` expression and if receiver's class matches cached class\n3. If match, use cached method; if not, perform full resolution and update cache\n\n**Challenge:** Cache invalidation when classes are redefined (unlikely in Lox) or when monkey-patching methods (not supported). Simple approach: clear all caches on any class declaration (heavy-handed but correct).\n\n#### String Interning\n\n**Mental Model:** String interning is the interpreter's **dictionary**—ensuring identical strings share the same underlying object, so comparisons become pointer equality checks instead of character-by-character comparisons.\n\n**Performance Benefits:**\n1. **Faster equality checks:** `==` on strings becomes reference comparison for interned strings\n2. **Reduced memory:** Duplicate string literals share storage\n3. **Faster hash map lookups:** Environment variable names are interned strings\n\n**Implementation:** Add `StringPool` class with static `intern(String): String` method. In `Scanner`, after reading string literal text, pass through pool before creating `Token`. In `Interpreter`, intern string values created at runtime (concatenation results).\n\n**Trade-off:** Interning pool grows indefinitely (memory leak for dynamic strings). Solution: weak references or limit to literals only.\n\n#### Tail Call Optimization (TCO)\n\n**Mental Model:** Tail call optimization transforms **recursive function calls** that would grow the call stack into **loops** that reuse the current stack frame. It's like realizing you're at the end of a hallway and instead of walking back to start a new hallway, you just turn around and continue.\n\n**Applicability:** When a function's last action is returning the result of another function call (tail position), reuse the current call frame instead of pushing a new one.\n\n**Example:**\n```lox\nfun factorial(n, acc) {\n    if (n <= 1) return acc;\n    return factorial(n - 1, n * acc);  // Tail call eligible for TCO\n}\n```\n\n**Implementation:** In `LoxFunction.call()`, detect tail calls: if the last statement in function body is `return expr` and `expr` is a `Call` expression, then:\n1. Don't create new environment; reuse current with updated parameters\n2. Jump to evaluating the called function's body (loop instead of recursion)\n3. Implement as trampoline: functions return \"continue with this other function\" instead of recursing\n\n**Benefit:** Enables infinite recursion without stack overflow for properly tail-recursive functions.\n\n#### Arithmetic Operation Specialization\n\n**Mental Model:** Operation specialization creates **fast paths** for common cases—like having a special \"add integers\" circuit in a calculator instead of using the general \"add floating point\" logic every time.\n\n**Current Implementation:** All numbers are `Double`, all arithmetic uses Java's double operators. This is simple but inefficient for integer-heavy code.\n\n**Optimizations:**\n1. **Integer Detection:** If both operands are integers (no decimal part), use integer arithmetic\n2. **Type Tagging:** Store numbers as `long` with type tag in low bits (NaN-boxing)\n3. **Specialized Ops:** `ADD_INT`, `SUBTRACT_INT` bytecode instructions (if moving to VM)\n\n**Simple Approach:** In `visitBinaryExpr`, check if both operands are integers (use `Math.floor()` comparison), perform integer arithmetic, convert back to double. Avoids floating point rounding for integer cases.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Extension | Simple Implementation | Advanced Implementation |\n|-----------|----------------------|-------------------------|\n| **REPL** | `java.util.Scanner` for line input | JLine3 for history, completion, editing |\n| **Standard Library** | Static methods in `LoxStdLib` class | Dynamic loading via service provider interface |\n| **Native Functions** | Hardcoded registry of `LoxCallable` | Reflection-based discovery with annotations |\n| **Arrays** | `LoxArray` with `ArrayList<Object>` backend | Custom resizable array with type tagging |\n| **Bytecode VM** | Stack VM with 30-40 opcodes | Register VM with optimization passes |\n\n#### Recommended File Structure for Extensions\n\n```\nlox/\n├── interpreter/          # Core interpreter (existing)\n│   ├── Interpreter.java\n│   ├── Environment.java\n│   └── ...\n├── extensions/           # New directory for optional extensions\n│   ├── repl/\n│   │   ├── Repl.java              # Enhanced REPL with continuation\n│   │   └── LineBuffer.java        # Multi-line input buffer\n│   ├── stdlib/\n│   │   ├── LoxStdLib.java         # Standard function registry\n│   │   ├── MathFunctions.java     # sqrt, sin, random\n│   │   ├── StringFunctions.java   # length, substring\n│   │   └── TypeFunctions.java     # typeOf, toString\n│   ├── native/\n│   │   ├── NativeRegistry.java    # Maps names to native functions\n│   │   ├── FileNative.java        # File I/O functions\n│   │   └── TimeNative.java        # Time/date functions\n│   ├── arrays/\n│   │   ├── LoxArray.java          # Array runtime type\n│   │   └── ArrayCompiler.java     # Compiler for [ ] syntax\n│   └── vm/                         # Bytecode VM extension\n│       ├── OpCode.java\n│       ├── Chunk.java\n│       ├── VM.java\n│       └── Compiler.java\n└── Lox.java              # Modified to load extensions\n```\n\n#### Infrastructure Starter Code: Native Function Interface\n\n```java\n// extensions/native/NativeCallable.java\npackage lox.extensions.native;\n\nimport lox.Interpreter;\nimport java.util.List;\n\n/**\n * Interface for native (Java-implemented) functions callable from Lox.\n * All standard library and extension functions implement this.\n */\npublic interface NativeCallable {\n    /**\n     * Number of arguments this function expects.\n     */\n    int arity();\n    \n    /**\n     * Call the function with the given arguments.\n     * \n     * @param interpreter The current interpreter context\n     * @param arguments The evaluated argument values\n     * @return The function's result\n     */\n    Object call(Interpreter interpreter, List<Object> arguments);\n    \n    /**\n     * Human-readable name for debugging.\n     */\n    default String name() {\n        return getClass().getSimpleName();\n    }\n}\n\n// extensions/native/NativeRegistry.java\npackage lox.extensions.native;\n\nimport lox.Environment;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Registry of all available native functions.\n * Populates the global environment with these functions.\n */\npublic class NativeRegistry {\n    private final Map<String, NativeCallable> functions = new HashMap<>();\n    \n    public NativeRegistry() {\n        // Register core standard library\n        register(\"clock\", new ClockFunction());\n        register(\"sqrt\", new MathFunction(\"sqrt\", Math::sqrt));\n        // ... more registrations\n    }\n    \n    public void register(String name, NativeCallable function) {\n        functions.put(name, function);\n    }\n    \n    public void installInto(Environment globals) {\n        // Wrap each NativeCallable in a LoxCallable adapter\n        for (Map.Entry<String, NativeCallable> entry : functions.entrySet()) {\n            globals.define(entry.getKey(), new NativeAdapter(entry.getValue()));\n        }\n    }\n    \n    /**\n     * Adapter that makes NativeCallable work with existing LoxCallable interface.\n     */\n    private static class NativeAdapter implements lox.LoxCallable {\n        private final NativeCallable nativeFn;\n        \n        NativeAdapter(NativeCallable nativeFn) {\n            this.nativeFn = nativeFn;\n        }\n        \n        @Override\n        public int arity() {\n            return nativeFn.arity();\n        }\n        \n        @Override\n        public Object call(Interpreter interpreter, List<Object> arguments) {\n            return nativeFn.call(interpreter, arguments);\n        }\n        \n        @Override\n        public String toString() {\n            return \"<native fn \" + nativeFn.name() + \">\";\n        }\n    }\n}\n\n// Example native function: clock() returns seconds since epoch\nclass ClockFunction implements NativeCallable {\n    @Override\n    public int arity() {\n        return 0;  // clock() takes no arguments\n    }\n    \n    @Override\n    public Object call(Interpreter interpreter, List<Object> arguments) {\n        // Return as Lox number (double)\n        return (double) System.currentTimeMillis() / 1000.0;\n    }\n}\n```\n\n#### Core Logic Skeleton: Constant Folding Optimizer\n\n```java\n// extensions/optimization/ConstantFolder.java\npackage lox.extensions.optimization;\n\nimport lox.*;\nimport lox.Stmt;\nimport java.util.List;\n\n/**\n * AST optimizer that performs constant folding.\n * Replaces constant expressions with their computed values.\n */\npublic class ConstantFolder implements Expr.Visitor<Expr>, Stmt.Visitor<Stmt> {\n    \n    // TODO 1: Implement visitBinaryExpr to fold constant binary operations\n    //   - Recursively fold left and right operands first\n    //   - Check if both are Literal nodes after folding\n    //   - If yes, compute result based on operator:\n    //        PLUS: add values (handle string concatenation)\n    //        MINUS, STAR, SLASH: arithmetic (check division by zero)\n    //        GREATER, LESS, etc.: comparisons\n    //   - Return new Literal with computed value, or original if not foldable\n    \n    @Override\n    public Expr visitBinaryExpr(Expr.Binary expr) {\n        // TODO 1.1: Fold left operand\n        Expr left = expr.left.accept(this);\n        // TODO 1.2: Fold right operand  \n        Expr right = expr.right.accept(this);\n        \n        // TODO 1.3: Check if both are Literal after folding\n        if (left instanceof Expr.Literal && right instanceof Expr.Literal) {\n            Object leftVal = ((Expr.Literal) left).value;\n            Object rightVal = ((Expr.Literal) right).value;\n            \n            // TODO 1.4: Based on operator type, compute result\n            switch (expr.operator.type) {\n                case PLUS:\n                    // TODO: Handle number addition and string concatenation\n                    break;\n                case MINUS:\n                    // TODO: Check both are numbers, subtract\n                    break;\n                // ... handle other operators\n            }\n        }\n        \n        // TODO 1.5: If folded, return new Literal, otherwise new Binary with folded children\n        return null; // placeholder\n    }\n    \n    // TODO 2: Implement visitUnaryExpr for - and ! on literals\n    \n    // TODO 3: Implement visitGroupingExpr to fold grouped expressions\n    \n    // TODO 4: Implement visitLogicalExpr with short-circuit awareness\n    //   - Fold left first\n    //   - If left is literal and operator is OR with truthy left, return left\n    //   - If left is literal and operator is AND with falsy left, return left\n    //   - Otherwise fold right and rebuild\n    \n    // TODO 5: Implement statement visitors to fold expressions within statements\n    //   visitPrintStmt, visitVarStmt, visitIfStmt, etc.\n    \n    // TODO 6: Add main fold() method that processes a list of statements\n    public List<Stmt> fold(List<Stmt> statements) {\n        // TODO: Apply visitor to each statement, collect results\n        return null; // placeholder\n    }\n    \n    // Helper method to check if value is numeric\n    private boolean isNumber(Object value) {\n        return value instanceof Double;\n    }\n    \n    // Helper method to check if expression is pure (no side effects)\n    // Used to decide if folding is safe\n    private boolean isPure(Expr expr) {\n        // TODO: Walk expression tree, return false if contains:\n        //   - Variable expressions (values unknown at compile time)\n        //   - Function calls (may have side effects)\n        //   - Assignments (side effects)\n        return false; // placeholder\n    }\n}\n```\n\n#### Core Logic Skeleton: REPL with Continuation\n\n```java\n// extensions/repl/Repl.java\npackage lox.extensions.repl;\n\nimport lox.*;\nimport java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Enhanced REPL with multi-line input support.\n */\npublic class Repl {\n    private final Interpreter interpreter;\n    private final Scanner scanner;\n    private boolean hadError = false;\n    private boolean inMultilineMode = false;\n    private final StringBuilder multilineBuffer = new StringBuilder();\n    \n    public Repl(Interpreter interpreter) {\n        this.interpreter = interpreter;\n        this.scanner = new Scanner(System.in);\n    }\n    \n    public void run() {\n        System.out.println(\"Lox REPL (type 'exit' to quit)\");\n        \n        while (true) {\n            // TODO 1: Display appropriate prompt\n            String prompt = inMultilineMode ? \"... > \" : \"> \";\n            System.out.print(prompt);\n            \n            // TODO 2: Read line, handle EOF (Ctrl+D)\n            if (!scanner.hasNextLine()) {\n                System.out.println();\n                break;\n            }\n            String line = scanner.nextLine().trim();\n            \n            // TODO 3: Check for exit command\n            if (line.equals(\"exit\") || line.equals(\"quit\")) {\n                break;\n            }\n            \n            // TODO 4: Handle empty line in multiline mode (ends input)\n            if (inMultilineMode && line.isEmpty()) {\n                processBuffer();\n                continue;\n            }\n            \n            // TODO 5: Append to buffer (with newline if in multiline mode)\n            if (inMultilineMode) {\n                multilineBuffer.append(line).append(\"\\n\");\n            } else {\n                multilineBuffer.append(line);\n            }\n            \n            // TODO 6: Try to parse current buffer\n            try {\n                run(multilineBuffer.toString());\n                // Success: reset state\n                multilineBuffer.setLength(0);\n                inMultilineMode = false;\n            } catch (ParseError error) {\n                // TODO 7: Check if error is due to incomplete input\n                //   - If at EOF and expecting more tokens (like unclosed brace)\n                //   - Set inMultilineMode = true and continue\n                //   - Otherwise, report error and reset\n                if (isIncompleteError(error)) {\n                    inMultilineMode = true;\n                } else {\n                    // Report error\n                    multilineBuffer.setLength(0);\n                    inMultilineMode = false;\n                }\n            }\n        }\n        \n        scanner.close();\n    }\n    \n    private void run(String source) {\n        // TODO: Use existing Lox.run() logic but don't exit on error\n        //   - Create scanner, parser\n        //   - Parse statements\n        //   - If parse error, throw\n        //   - Execute with interpreter\n        //   - Catch runtime errors, print but don't exit\n    }\n    \n    private boolean isIncompleteError(ParseError error) {\n        // TODO: Heuristic: error message contains \"expect\" and token is EOF\n        //   or unclosed delimiter {, (, [\n        return false; // placeholder\n    }\n    \n    private void processBuffer() {\n        // Force parse attempt even with empty line continuation\n        try {\n            run(multilineBuffer.toString());\n        } catch (ParseError e) {\n            // Give up on this input\n            System.out.println(\"Syntax error: \" + e.getMessage());\n        } finally {\n            multilineBuffer.setLength(0);\n            inMultilineMode = false;\n        }\n    }\n}\n```\n\n#### Language-Specific Hints (Java)\n\n1. **REPL Input:** Use `java.util.Scanner` for simplicity, but it doesn't support arrow keys or history. For better UX, consider `jline3` dependency:\n   ```java\n   LineReader reader = LineReaderBuilder.builder().build();\n   String line = reader.readLine(\"> \");\n   ```\n\n2. **Native-Java Integration:** For exposing Java objects to Lox, use the `invoke` method from `java.lang.reflect` but beware of security and complexity. Better to create explicit wrapper classes for safety.\n\n3. **Performance Measurement:** Use `System.nanoTime()` before/after execution to benchmark optimizations:\n   ```java\n   long start = System.nanoTime();\n   interpreter.interpret(statements);\n   long elapsed = System.nanoTime() - start;\n   System.out.printf(\"Executed in %.2f ms%n\", elapsed / 1_000_000.0);\n   ```\n\n4. **Memory Profiling:** For array/string interning, consider using `java.lang.ref.SoftReference` for cache entries that can be GC'd under memory pressure.\n\n#### Milestone Checkpoints for Extensions\n\n| Extension | Verification Command | Expected Output |\n|-----------|---------------------|-----------------|\n| **REPL** | Run `java Lox` (no args) | Shows `>` prompt, executes `print 1+2;` prints `3` |\n| **Standard Library** | `print clock();` | Prints current timestamp (number) |\n| **Arrays** | `var a = [1, 2, 3]; print a[1];` | Prints `2` |\n| **Constant Folding** | Test with `print 2 * 3 + 4 * 5;` | Prints `26`, check AST shows single literal |\n| **Native Functions** | `fun readFile(path) { ... }` (native) | Can read and print file contents |\n\n#### Debugging Tips for Extensions\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **REPL exits after one line** | Scanner reading full input as one line | Add debug print of raw input string | Use `Scanner.nextLine()` correctly |\n| **Native function returns wrong type** | Marshalling between Java/Lox types incorrect | Print Java value before returning | Ensure numbers as Double, strings as LoxString |\n| **Constant folding changes program behavior** | Folded expression with side effects | Check `isPure()` heuristic | Don't fold function calls or variable accesses |\n| **Array index out of bounds** | No bounds checking in `LoxArray.get()` | Add check before array access | Throw `RuntimeError` with index and length |\n| **Memory leak with string interning** | Interning pool never clears entries | Monitor heap usage with VisualVM | Use `WeakHashMap` or limit to literals |\n| **Tail recursion still overflows stack** | TCO not detecting all tail calls | Add debug log of call frame creation | Check `return func(args)` in tail position |\n| **Method cache returns wrong method** | Cache not invalidated on class redefinition | Print cache hits/misses | Clear cache in `visitClassStmt` |\n\n---\n\n\n## 11. Glossary\n\n> **Milestone(s):** All milestones (reference section)\n\nThis glossary provides definitions for the key technical terms, acronyms, and domain-specific vocabulary used throughout this design document. Terms are organized alphabetically for easy reference.\n\n### A\n\n**Abstract Syntax Tree (AST)**\nA hierarchical tree representation of the grammatical structure of source code, where each node corresponds to a language construct (expression, statement) and child nodes represent its components. The AST discards surface syntax details like parentheses and whitespace, focusing on the essential syntactic relationships.\n\n**Arity**\nThe number of parameters a function or callable expects. In Lox, functions have a fixed arity determined by their parameter list declaration. The `LoxFunction.arity()` method returns this value, enabling the interpreter to check argument counts before calling.\n\n**Array**\nAn indexed collection data type that stores elements in a contiguous, numerically-indexed sequence. While not in the base Lox language described in \"Crafting Interpreters,\" it's a common extension where arrays support operations like getting, setting, and checking length.\n\n**AST Node Classes**\nThe concrete Java classes that implement the `Expr` and `Stmt` interfaces, representing specific language constructs in the AST. Examples include `Binary` (for binary operations), `Unary` (for unary operations), `Literal` (for literal values), `If` (for conditional statements), and `Function` (for function declarations).\n\n**AST Printer**\nA visitor implementation that converts an AST to a human-readable string representation, typically using parenthesized S-expression notation. Useful for debugging the parser by visualizing the structure it produces.\n\n### B\n\n**Binary Expression**\nAn expression with two operands and a single operator between them, such as `1 + 2` or `x < y`. Represented by the `Binary` AST node with `left`, `operator`, and `right` fields.\n\n**Block**\nA sequence of statements enclosed in curly braces `{}` that creates a new lexical scope. Represented by the `Block` AST node containing a list of statements. When executed, it creates a new nested `Environment`.\n\n**Boolean**\nA primitive truth value in Lox, either `true` or `false`. Represented at runtime as a `LoxBoolean` object wrapping a Java `Boolean`. Subject to Lox's truthiness rules in conditional contexts.\n\n**Break Statement**\nA control flow statement that immediately terminates execution of the innermost enclosing loop. While not in the base Lox language, it's a common extension implemented via a `BreakException` that unwinds the call stack until caught by the loop's execution machinery.\n\n**Bytecode**\nA compact, intermediate representation of a program designed for efficient execution by a virtual machine. Each instruction (opcode) typically performs a simple operation like push constant, add, or jump. Contrasts with tree-walking interpretation, which directly traverses the AST.\n\n### C\n\n**Call**\nThe act of invoking a function, method, or class constructor with arguments. Represented by the `Call` AST node with `callee` (the function expression), `paren` (the closing parenthesis token for error reporting), and `arguments` (list of argument expressions).\n\n**Chunk**\nIn bytecode interpreter architectures, a container for a sequence of bytecode instructions and their associated constant pool. The `Chunk` class stores the instruction stream and constant values referenced by those instructions.\n\n**Class**\nA blueprint for creating objects (instances) that encapsulates data (fields) and behavior (methods). In Lox, a class declaration creates a `LoxClass` object that can be called as a constructor to create `LoxInstance` objects. Classes support single inheritance via the `<` syntax.\n\n**Closure**\nA first-class function value that \"closes over\" (captures) variables from its lexical (surrounding) scope, maintaining access to those variables even after the enclosing function has returned. Implemented by storing a reference to the function's defining `Environment` within the `LoxFunction` object.\n\n**Comparison Operators**\nBinary operators that compare two values and return a boolean: `<` (less than), `>` (greater than), `<=` (less than or equal), `>=` (greater than or equal). These have higher precedence than equality operators but lower than addition/subtraction.\n\n**Constant Folding**\nA compiler optimization that evaluates constant expressions at compile time (parse time) rather than runtime. For example, the expression `3 + 4 * 2` can be computed once as `11` and replaced with a literal `11` in the AST, reducing runtime work.\n\n**Continue Statement**\nA control flow statement that immediately skips to the next iteration of the innermost enclosing loop. While not in the base Lox language, it's a common extension implemented via a `ContinueException` caught by the loop execution.\n\n### D\n\n**Deep Equality**\nAn equality comparison that compares the semantic value of objects rather than their object identity (reference equality). In Lox, `isEqual()` handles special cases: numbers are compared with a tolerance for floating-point errors, strings by character content, and `nil` equals only itself.\n\n**Defining Environment**\nThe `Environment` that was active when a function was declared, captured by closures to provide lexical scoping. When a closure is called, this environment becomes the parent of the call's new environment, allowing access to outer variables.\n\n**Desugaring**\nThe process of transforming higher-level syntactic constructs into lower-level primitive constructs. In Lox, `for` loops are desugared into equivalent `while` loop constructs with initialization and increment statements, simplifying the interpreter's implementation.\n\n**Division by Zero**\nA runtime error that occurs when the right operand of a division (`/`) operator evaluates to zero. The interpreter detects this and raises a `RuntimeError` with an appropriate message, halting execution.\n\n**Double Dispatch**\nA technique where an operation's behavior is determined by both the type of the receiver and the type of the argument. The Visitor pattern uses double dispatch: the AST node's `accept()` method calls the appropriate `visitXxx()` method on the visitor, selecting based on both the visitor type and the node type.\n\n**Dynamic Typing**\nA type system where values carry their type information at runtime, and type checking occurs during program execution rather than compile time. Lox is dynamically typed: variables have no declared type, and operations check operand types at evaluation time.\n\n### E\n\n**End-of-file (EOF)**\nA special token type (`EOF`) that marks the end of the source code input. The scanner adds this token after processing all characters, and the parser uses it to know when to stop parsing.\n\n**Environment**\nA runtime data structure that maps variable names to their current values within a specific lexical scope. Implemented as the `Environment` class with a `values` hash map and an optional reference to an `enclosing` parent environment, forming a chain for variable resolution.\n\n**Environment Chain**\nThe linked list of `Environment` objects representing nested lexical scopes, from the current local scope outward through enclosing function scopes to the global scope. Variable lookup proceeds up this chain until finding the name or reaching the global scope without it (causing a runtime error).\n\n**Environment Dumper**\nA debugging utility that prints all variable bindings in the environment chain, typically with indentation to show nesting. Helps diagnose scoping issues by revealing which variables are defined in each scope and their current values.\n\n**Environment Flattening**\nAn optimization technique that converts the chain of linked `Environment` objects into a flat array indexed by scope depth and variable slot, reducing variable lookup from O(n) in chain length to O(1) array access. Used in more advanced interpreters and compilers.\n\n**Equality Operators**\nBinary operators that test for equality (`==`) or inequality (`!=`) between two values. These have the lowest precedence among comparison operators and implement Lox's deep equality semantics.\n\n**Exception**\nA special value or object that can be \"thrown\" to signal an error or exceptional condition and \"caught\" by exception handling code. While not in base Lox, extensions might add `try`/`catch` statements with `Exception` objects carrying error information.\n\n**Execution Log**\nA debug trace of the interpreter's step-by-step evaluation, showing which AST nodes are visited, what values they produce, and how the environment changes. Implemented by adding logging statements to visitor methods, often controlled by a `DEBUG` flag.\n\n**Expression**\nA piece of syntax that produces a value when evaluated. Examples include literals (`5`, `\"hello\"`), variable references (`x`), arithmetic operations (`a + b`), and function calls (`f(3)`). Represented by the `Expr` abstract class and its concrete subclasses.\n\n**Expression Statement**\nA statement that consists solely of an expression followed by a semicolon. The expression is evaluated for its side effects (like assignment or function calls), and the resulting value is discarded. Represented by the `Expression` AST node.\n\n### F\n\n**Fail-Fast**\nAn error handling strategy where the interpreter halts execution immediately upon detecting a semantic violation (type mismatch, undefined variable, etc.), rather than attempting to continue with potentially corrupted state. Lox uses fail-fast for runtime errors.\n\n**Field**\nA named property stored on a class instance (`LoxInstance`), accessible via dot notation (`instance.field`). Fields are dynamically created when assigned to and stored in the instance's `fields` hash map, separate from methods defined on the class.\n\n**First-Class Function**\nA function that can be treated like any other value: assigned to variables, passed as arguments to other functions, returned from functions, and stored in data structures. Lox functions are first-class, implemented as `LoxFunction` objects.\n\n**For Loop**\nA control flow statement with initialization, condition, and increment expressions: `for (var i = 0; i < 10; i = i + 1) { ... }`. In Lox, this is desugared into a block containing the initializer, a `while` loop with the condition, and the increment as the last statement in the loop body.\n\n**Foreign Function Interface (FFI)**\nA mechanism for calling functions implemented in the host language (Java) from Lox code. Typically implemented via a `NativeCallable` interface and a `NativeRegistry` that maps names to native implementations, which can then be installed into the global environment.\n\n**Function**\nA reusable block of code that takes parameters, performs computations, and optionally returns a value. In Lox, functions are declared with the `fun` keyword, creating a `LoxFunction` object that captures its defining environment (for closures). Functions are called with arguments bound to parameters in a new environment.\n\n**Function Call**\nThe runtime operation of invoking a function with concrete argument values. The interpreter evaluates the argument expressions, creates a new `Environment` with the function's closure environment as parent, binds parameters to argument values, and executes the function body.\n\n### G\n\n**Grammar Rules**\nThe formal specification that defines which sequences of tokens constitute syntactically valid programs in the language. Expressed in a notation like Backus-Naur Form (BNF) or Parsing Expression Grammar (PEG), these rules guide the recursive descent parser's implementation.\n\n**Grouping Expression**\nAn expression wrapped in parentheses `(expr)`, used to explicitly control operator precedence. Represented by the `Grouping` AST node with a single `expression` child. The parser handles grouping by matching `(` tokens and recursively parsing the inner expression.\n\n### H\n\n**High-Level Architecture**\nThe macro-organization of the interpreter system into major components (Scanner, Parser, Interpreter) and their data flow relationships, as described in Section 3. This architecture defines the pipeline from source text to execution output.\n\n### I\n\n**Identifier**\nA token representing a name defined by the programmer, such as a variable, function, or class name. The `IDENTIFIER` token type encompasses all names that aren't language keywords. Identifiers follow specific lexical rules (starting with letter/underscore, containing letters/numbers/underscores).\n\n**If/Else Statement**\nA conditional control flow statement that executes one of two branches based on a condition's truthiness: `if (condition) thenBranch else elseBranch`. The `else` clause is optional. Represented by the `If` AST node with `condition`, `thenBranch`, and optional `elseBranch` fields.\n\n**Import Statement**\nA statement that loads and executes code from another module, typically making its exported definitions available in the current scope. While not in base Lox, extensions might add `import` statements that load Lox source files and return a module object.\n\n**Inheritance**\nThe mechanism by which a class (the subclass or derived class) acquires properties and methods from another class (the superclass or base class). Lox supports single inheritance via the `<` syntax in class declarations. Method resolution proceeds up the inheritance chain.\n\n**Initializer**\nA special method named `init` defined inside a class that is automatically called when an instance is created (via the class constructor call). It receives the constructor arguments and can perform setup, including calling `super.init()` for inheritance chains.\n\n**Instance**\nA runtime object created from a class blueprint, with its own set of fields (stored in `LoxInstance.fields`) and access to methods defined on its class (via `LoxClass.methods`). Created by calling the class as a constructor function.\n\n**Interpreter**\nThe core execution engine that walks the AST and performs the operations it represents. In this design, the `Interpreter` class implements the `Expr.Visitor<Object>` and `Stmt.Visitor<Void>` interfaces, providing `visitXxx()` methods that define the semantics for each AST node type.\n\n### J\n\n**JIT Compilation (Just-In-Time Compilation)**\nAn advanced optimization technique where bytecode or AST is compiled to native machine code at runtime, just before execution, potentially yielding significant performance gains. Contrasts with ahead-of-time compilation and pure interpretation.\n\n### K\n\n**Keyword**\nA reserved word in the language with special syntactic meaning, such as `var`, `fun`, `if`, `while`, `class`, etc. The scanner recognizes keywords and emits corresponding token types (e.g., `VAR`, `FUN`, `IF`) rather than `IDENTIFIER` tokens.\n\n### L\n\n**Left-Recursive Grammar**\nA grammar rule where the leftmost symbol in a production is the nonterminal being defined, e.g., `expression → expression + term`. Naive recursive descent parsers get stuck in infinite recursion with left-recursive rules, requiring transformation to right-recursive or iterative forms.\n\n**Lexeme**\nThe raw character sequence (text) of a token as it appears in the source code. For example, in the token for the number `123.45`, the lexeme is the string `\"123.45\"`. Stored in the `Token.lexeme` field for debugging and error reporting.\n\n**Lexical Analysis**\nThe process of converting a sequence of characters (source code) into a sequence of meaningful tokens, performed by the scanner/lexer. This includes recognizing identifiers, keywords, literals, and operators while ignoring whitespace and comments.\n\n**Lexical Scoping**\nA scoping discipline where variable visibility is determined by the textual (lexical) structure of the source code: a variable is visible within the block where it's defined and any nested blocks, but not in enclosing or sibling blocks. Lox uses lexical scoping for variables and closures.\n\n**Lexer**\nSynonym for Scanner. See **Scanner**.\n\n**Literal**\nA token representing a constant value directly written in source code: number literals (`123`, `3.14`), string literals (`\"hello\"`), boolean literals (`true`, `false`), and `nil`. The scanner extracts the runtime value (Java `Double`, `String`, `Boolean`, or `LoxNil`) and stores it in `Token.literal`.\n\n**Logical Operators**\nThe `and` and `or` operators that combine boolean expressions with short-circuit evaluation. `and` returns the left operand if it's falsy (short-circuit), otherwise evaluates and returns the right operand. `or` returns the left operand if it's truthy (short-circuit), otherwise evaluates and returns the right operand.\n\n**Lox**\nThe programming language being implemented in this project—a small, dynamically-typed, object-oriented language with C-like syntax, designed by Bob Nystrom for educational purposes in \"Crafting Interpreters.\"\n\n**LoxCallable**\nA Java interface implemented by all callable entities in Lox: functions (`LoxFunction`), classes (`LoxClass`), and potentially native functions (`NativeCallable`). Defines `call()` and `arity()` methods that the interpreter uses uniformly.\n\n**LoxClass**\nThe runtime representation of a class, created when a class declaration is evaluated. Stores the class `name`, its `methods` (including `init`), and optional `superclass`. When called as a function, creates a new `LoxInstance` and invokes the initializer.\n\n**LoxFunction**\nThe runtime representation of a function, created when a function declaration is evaluated or a lambda is created. Stores the function's AST node (`declaration`), its `closure` (defining environment), and an `isInitializer` flag for distinguishing `init` methods.\n\n**LoxInstance**\nThe runtime representation of a class instance, created by calling a `LoxClass`. Stores a reference to its `klass` (for method lookup) and a map of `fields` (instance-specific data). Provides `get()` and `set()` methods for property access.\n\n**LoxNil**\nThe runtime representation of Lox's `nil` value, a singleton object indicating absence of meaningful value. Used as the default initializer value for variable declarations without explicit initializers and as the implicit return value from functions without `return` statements.\n\n### M\n\n**Mental Model**\nAn intuitive analogy or conceptual framework that helps understand a complex system before delving into technical details. Used throughout this design document to bridge from \"what it feels like\" to \"how it actually works\" for each component.\n\n**Method**\nA function defined within a class body, implicitly bound to instances of that class. When called on an instance, the `this` keyword within the method body refers to that instance. Methods are stored in the `LoxClass.methods` map and accessed via dot notation.\n\n**Method Caching**\nAn optimization where the result of method lookup (resolving a method name to a specific `LoxFunction` in the class hierarchy) is cached at the call site, avoiding repeated traversal of the inheritance chain on subsequent calls with the same receiver type.\n\n**Method Resolution Order**\nThe order in which classes are searched when looking up a method on an instance. In Lox's single inheritance: first check the instance's class, then its superclass, then the superclass's superclass, etc., until finding the method or reaching the top (causing a runtime error).\n\n**Module**\nA self-contained unit of code with its own environment, potentially exporting some definitions for use by importing code. While not in base Lox, extensions might add modules to support larger programs and code organization, implemented as `LoxModule` runtime objects.\n\n### N\n\n**Native Function**\nA function implemented in the host language (Java) rather than Lox, exposed to Lox programs via the FFI. Useful for providing I/O, mathematical functions, or other capabilities difficult or inefficient to implement in pure Lox.\n\n**Nil**\nLox's null/none value, written as the keyword `nil`. The only value of the `LoxNil` type, representing absence of meaningful value. In truthiness rules, `nil` is falsy.\n\n**Number**\nLox's numeric type, representing double-precision floating-point values (Java `Double`). Number literals can include optional decimal points (`3`, `3.14`). All arithmetic operations work on numbers, with runtime type checking to prevent operations on non-numbers.\n\n### O\n\n**Object**\nIn the context of Lox's runtime values, any value that can be stored in variables, passed as arguments, or returned from functions. Includes `LoxNumber`, `LoxString`, `LoxBoolean`, `LoxNil`, `LoxFunction`, `LoxClass`, `LoxInstance`, and potentially `LoxArray` or `LoxModule`. Not to be confused with Java's `Object` class, though Lox values are represented as Java `Object` references in the interpreter.\n\n**Operator Precedence**\nRules that determine which operations are performed first in expressions with multiple operators. In Lox, from highest to lowest: grouping `()`, unary `! -`, multiplication/division `* /`, addition/subtraction `+ -`, comparison `< > <= >=`, equality `== !=`, logical `and or`. The parser implements this via a cascade of recursive methods.\n\n**Optimization Pass**\nA transformation phase applied to the AST or bytecode to improve performance without changing program semantics. Examples include constant folding, dead code elimination, or inlining. Typically run after parsing but before execution.\n\n### P\n\n**Panic-Mode Recovery**\nAn error recovery strategy used by parsers where, upon encountering a syntax error, they discard tokens (panic) until reaching a known synchronization point (like a statement boundary), then continue parsing. This prevents cascading error reports from a single mistake.\n\n**Parameter**\nA variable declared in a function definition that receives a value (argument) when the function is called. Parameters become local variables in the function's execution environment, initialized with the corresponding argument values.\n\n**Parser**\nThe component that performs syntactic analysis, consuming tokens from the scanner and building an Abstract Syntax Tree according to the language's grammar rules. Our design uses a recursive descent parser implemented in the `Parser` class.\n\n**Parsing Expression Grammar (PEG)**\nA formal grammar notation that describes a top-down parser's recognition process, well-suited for recursive descent parsers. Our expression parsing methods directly correspond to PEG rules for each precedence level.\n\n**Pretty Printer**\nSee **AST Printer**.\n\n**Primary Expression**\nThe most fundamental expressions that serve as building blocks for more complex expressions: literals, identifiers (variables), grouping parentheses, and other atomic forms. Parsed by the `primary()` method in the recursive descent parser.\n\n**Print Statement**\nA statement that evaluates an expression and outputs its string representation to standard output, followed by a newline. The `Print` AST node contains the `expression` to evaluate. Used for program output and debugging.\n\n**Property**\nA field or method accessible on a class instance via dot notation (`instance.property`). The interpreter handles property access uniformly: first check instance fields, then class methods (including inherited ones), raising a runtime error if neither exists.\n\n### R\n\n**Recursive Descent Parsing**\nA top-down parsing technique where each nonterminal in the grammar is implemented as a function (method) that recursively calls other nonterminal functions. Our parser uses this approach, with methods like `expression()`, `equality()`, `comparison()`, etc., matching the precedence hierarchy.\n\n**Register VM**\nA virtual machine architecture that uses named registers (slots) rather than an operand stack for holding intermediate values. Typically faster but more complex to compile to than stack VMs. Contrasts with the stack VM approach mentioned in future extensions.\n\n**REPL (Read-Eval-Print Loop)**\nAn interactive programming environment that reads input, evaluates it, prints the result, and loops. While not a goal for the base project, a `Repl` class could be added to allow experimenting with Lox code without writing files.\n\n**Return Statement**\nA statement that immediately exits the current function, optionally providing a value that becomes the function call's result. The `Return` AST node contains the `keyword` token (for error location) and optional `value` expression. Implemented via a `Return` exception that unwinds to the call site.\n\n**Runtime Error**\nAn error that occurs during program execution (interpretation), such as type mismatches, undefined variables, division by zero, or calling non-functions. Represented by the `RuntimeError` exception class with `token` (location) and `message` fields. The interpreter catches these and reports them to the user.\n\n**Runtime Value**\nThe concrete data that exists during program execution, representing the result of evaluating expressions. In our implementation, runtime values are Java objects (`Double`, `String`, `Boolean`, `LoxNil`, `LoxFunction`, `LoxClass`, `LoxInstance`) stored in variables and manipulated by operations.\n\n### S\n\n**Scanner**\nThe component that performs lexical analysis, converting source code (string) into a list of tokens. Also called a lexer. Implemented by the `Scanner` class with methods to recognize tokens by scanning characters.\n\n**Semantic Analysis**\nThe process of interpreting the meaning of valid syntactic structures, including type checking, variable resolution, and other static validations. In our simple interpreter, much of semantic analysis happens at runtime (dynamic checking), though some occurs during parsing (variable resolution for closures).\n\n**Short-Circuit Evaluation**\nAn optimization where the right operand of a logical operator (`and`, `or`) is evaluated only if necessary to determine the result. For `and`, if the left operand is falsy, the result is the left operand (right not evaluated). For `or`, if the left operand is truthy, the result is the left operand.\n\n**S-Expression**\nA parenthesized notation for representing tree structures, commonly used in Lisp and for debugging ASTs. Example: `(* (+ 1 2) 3)` represents the multiplication of `(+ 1 2)` and `3`. The `AstPrinter` produces S-expressions from ASTs.\n\n**Stack VM**\nA virtual machine architecture that uses an operand stack for holding intermediate values and executing instructions (push, pop, operate). Simpler to compile to than register VMs and conceptually similar to the tree-walking evaluator's implicit call stack.\n\n**Standard Library**\nA collection of built-in functions and types available to all Lox programs without explicit import. While not a goal for the base project, extensions might add a standard library with I/O, mathematical, and utility functions via native functions.\n\n**Statement**\nA piece of syntax that performs an action but doesn't produce a value (unlike expressions). Examples include variable declarations, print statements, conditionals, loops, and function declarations. Represented by the `Stmt` abstract class and its concrete subclasses.\n\n**String**\nA sequence of characters, created with double quotes (`\"hello\"`) and supporting escape sequences (`\\n`, `\\t`, `\\\"`, etc.). Strings can be concatenated with `+` operator (with any non-string operand converted via `stringify()`). Represented at runtime as Java `String` objects.\n\n**String Interning**\nAn optimization where identical strings are stored once in a shared pool and reused, saving memory and enabling fast equality comparison via reference equality. Could be applied to Lox string literals and runtime string values.\n\n**Super**\nA keyword used inside subclass methods to call a method from the superclass, bypassing any override in the subclass. The `Super` AST node stores the `keyword` token and `method` identifier. The interpreter resolves this by looking up the method in the superclass with `this` bound to the current instance.\n\n**Switch Statement**\nA multi-way conditional statement that compares a value against multiple cases. While not in base Lox, extensions might add `switch`/`case`/`default` statements as syntactic sugar for nested `if`/`else if` chains.\n\n**Synchronization Point**\nA token where the parser can safely resume after error recovery in panic mode. Typically statement boundaries (semicolons, closing braces, or keywords like `var`, `fun`, `class`, `for`, `if`, `while`, `return`). The `Parser.synchronize()` method skips tokens until reaching one.\n\n**Syntactic Analysis**\nThe process of analyzing a sequence of tokens to determine its grammatical structure according to the language's grammar rules, producing an AST. Performed by the parser.\n\n### T\n\n**Tail Call Optimization**\nAn optimization where a function call in tail position (the last action before returning) reuses the current stack frame instead of allocating a new one, preventing stack overflow in deeply recursive algorithms. Could be added to the interpreter for functional programming patterns.\n\n**This**\nA keyword referring to the current instance within a method body. The `This` AST node stores the `keyword` token. During method calls, the interpreter binds `this` to the receiving instance by creating a special environment that defines `this` before executing the method body.\n\n**Token**\nA categorized lexical unit extracted from source code by the scanner. Represented by the `Token` class with fields: `type` (a `TokenType` enum), `lexeme` (raw text), `literal` (runtime value for literals), and `line` (source line number). Tokens are the parser's input.\n\n**Token Stream Visualizer**\nA debugging utility that prints the list of tokens produced by the scanner, showing type, lexeme, and line numbers. Helps verify the scanner is correctly recognizing tokens before parsing.\n\n**TokenType**\nAn enumeration of all possible token categories in Lox, including punctuation (`LEFT_PAREN`, `COMMA`), operators (`PLUS`, `EQUAL_EQUAL`), keywords (`VAR`, `FUN`), literals (`NUMBER`, `STRING`), and special tokens (`IDENTIFIER`, `EOF`).\n\n**Tree-Walking Interpreter**\nAn interpreter that executes code by recursively traversing the Abstract Syntax Tree, evaluating each node according to its semantics. Our design uses this approach, contrasting with bytecode interpreters that compile to an intermediate representation first.\n\n**Truthiness**\nThe boolean interpretation of values in conditional contexts (if conditions, while conditions, logical operators). In Lox: `false` and `nil` are falsy; everything else (including `0`, empty string `\"\"`, and `true`) is truthy. The `isTruthy()` method implements this rule.\n\n### U\n\n**Unary Expression**\nAn expression with a single operator and operand, such as `-5` or `!true`. Represented by the `Unary` AST node with `operator` and `right` fields. The parser recognizes unary operators at a higher precedence level than binary operators.\n\n**Upvalue**\nA variable captured from an enclosing scope by a closure. In more advanced implementations, upvalues are specially allocated cells that survive after their declaring function returns, allowing closures to access them. Our design simply captures the entire environment.\n\n### V\n\n**Variable**\nA named storage location that holds a value, declared with `var` statements. Variables can be accessed by name (via `Variable` expression node) and reassigned (via `Assign` expression node). Lookup proceeds through the environment chain following lexical scoping rules.\n\n**Variable Declaration**\nA statement that introduces a new variable into the current scope, optionally with an initializer expression: `var x = 5;` or `var x;` (initialized to `nil`). The `Var` AST node stores the `name` token and optional `initializer` expression.\n\n**Virtual Machine (VM)**\nAn abstract computing machine that executes bytecode instructions, typically implemented in software. In interpreter architectures, a VM provides a faster execution model than tree-walking by compiling to a compact bytecode and using efficient dispatch loops.\n\n**Visitor Pattern**\nA behavioral design pattern that separates operations from the object structure they operate on. In our AST design, the `Expr.Visitor<R>` and `Stmt.Visitor<V>` interfaces define operations, and each AST node's `accept()` method calls the appropriate `visitXxx()` method on a visitor, enabling double dispatch without `instanceof` checks.\n\n### W\n\n**While Loop**\nA control flow statement that repeatedly executes a body statement as long as a condition expression evaluates to truthy: `while (condition) body`. Represented by the `While` AST node with `condition` and `body` fields. The interpreter evaluates the condition before each iteration.\n\n**Whitespace**\nCharacters that separate tokens but carry no meaning: spaces, tabs, carriage returns, and newlines. The scanner skips whitespace between tokens. Newlines increment the line counter for accurate error reporting.\n"}